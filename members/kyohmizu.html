<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon shortcut" type="image/png" href="https://blog.3-shake.com//logo.png"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&amp;display=swap"/><title>kyohmizu | 3-shake Engineers&#x27; Blogs</title><meta property="og:title" content="kyohmizu"/><meta property="og:url" content="https://blog.3-shake.com//members/kyohmizu"/><meta name="twitter:card" content="summary_large_image"/><meta property="og:site" content="3-shake Engineers&#x27; Blogs"/><meta property="og:image" content="https://blog.3-shake.com//og.png"/><link rel="canonical" href="https://blog.3-shake.com//members/kyohmizu"/><link rel="preload" href="/_next/static/css/fc85ecde7ad989e258c3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/fc85ecde7ad989e258c3.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-8a83f0fd99327c4684a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.1daf1ec1ecf144ee9147.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9e003f150a446b53bdd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-de809e7fcd6e160a3411.js" as="script"/><link rel="preload" href="/_next/static/chunks/81b50c7ab23905e464b4340eb234bd6ea389d26b.a959eb3c8a77689c86fe.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/members/%5Bid%5D-82bdc617ad4a0fa06a9e.js" as="script"/></head><body><div id="__next"><header class="site-header"><div class="content-wrapper"><div class="site-header__inner"><a class="site-header__logo-link" href="/"><img src="/logo.svg" alt="3-shake Engineers&#x27; Blogs" class="site-header__logo-img"/></a><div class="site-header__links"><a href="https://3-shake.com/category/recruit/" class="site-header__link">Recruit</a><a href="https://3-shake.com/" class="site-header__link">Company</a></div></div></div></header><section class="member"><div class="content-wrapper"><header class="member-header"><div class="member-header__avatar"><img src="/avatars/kyohmizu.png" alt="kyohmizu" width="100" height="100" class="member-header__avatar-img"/></div><h1 class="member-header__name">kyohmizu</h1><p class="member-header__bio">mizumoto</p><div class="member-header__links"><a href="https://twitter.com/kyohmizu" class="member-header__link"><img src="/icons/twitter.svg" alt="Twitterのユーザー@kyohmizu" width="22" height="22"/></a><a href="https://github.com/kyohmizu" class="member-header__link"><img src="/icons/github.svg" alt="GitHubのユーザー@kyohmizu" width="22" height="22"/></a><a href="https://kyohmizu.com/" class="member-header__link"><img src="/icons/link.svg" alt="ウェブサイトのリンク" width="22" height="22"/></a></div></header><div class="member-posts-container"><div class="post-list"><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2020-12-17T10:54:47.000Z" class="post-link__date">a year ago</time></div></a><a href="https://qiita.com/kyohmizu/items/40bee7037e1ce7949772" class="post-link__main-link"><h2 class="post-link__title">VolumePlugin がボリュームを作成・マウントするしくみ</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2020-08-05T02:54:59.000Z" class="post-link__date">2 years ago</time></div></a><a href="https://kyohmizu.hatenablog.com/entry/2020/08/05/115459" class="post-link__main-link"><h2 class="post-link__title">情報処理安全確保支援士の関連資料</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=kyohmizu.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>kyohmizu.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2020-01-31T19:03:51.000Z" class="post-link__date">2 years ago</time></div></a><a href="https://kyohmizu.hatenablog.com/entry/2020/02/01/040351" class="post-link__main-link"><h2 class="post-link__title">2019年のふりかえり、2020年の目標</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=kyohmizu.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>kyohmizu.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2019-12-22T18:19:52.000Z" class="post-link__date">2 years ago</time></div></a><a href="https://qiita.com/kyohmizu/items/dffdd49123b1e47c3ac4" class="post-link__main-link"><h2 class="post-link__title">0からはじめる Windows on Kubernetes</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2019-12-09T16:20:41.000Z" class="post-link__date">2 years ago</time></div></a><a href="https://kyohmizu.hatenablog.com/entry/2019/12/10/012041" class="post-link__main-link"><h2 class="post-link__title">【イベント参加レポート】Microsoft Ignite The Tour Tokyo</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=kyohmizu.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>kyohmizu.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2019-10-09T01:56:54.000Z" class="post-link__date">2 years ago</time></div></a><a href="https://qiita.com/kyohmizu/items/d5d6fedc527efa9f649c" class="post-link__main-link"><h2 class="post-link__title">LPIC 102 チートシート</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2019-10-09T01:48:33.000Z" class="post-link__date">2 years ago</time></div></a><a href="https://qiita.com/kyohmizu/items/923844999018fd456d44" class="post-link__main-link"><h2 class="post-link__title">LPIC 101チートシート</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2019-09-06T02:09:56.000Z" class="post-link__date">3 years ago</time></div></a><a href="https://qiita.com/kyohmizu/items/118bf654d0288da2294e" class="post-link__main-link"><h2 class="post-link__title">ArgoCDのApplicationにhelmを使用する</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2019-08-01T02:42:59.000Z" class="post-link__date">3 years ago</time></div></a><a href="https://qiita.com/kyohmizu/items/7bc0bec96cc4664473eb" class="post-link__main-link"><h2 class="post-link__title">Azure VMの作成からDockerの実行環境構築まで</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2019-07-04T12:15:58.000Z" class="post-link__date">3 years ago</time></div></a><a href="https://qiita.com/kyohmizu/items/9cedf39c70445a7da58e" class="post-link__main-link"><h2 class="post-link__title">Azure Key Vault で AKS の secret を管理する</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2019-06-06T02:18:05.000Z" class="post-link__date">3 years ago</time></div></a><a href="https://kyohmizu.hatenablog.com/entry/2019/06/06/111805" class="post-link__main-link"><h2 class="post-link__title">de:code 2019 参加レポート</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=kyohmizu.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>kyohmizu.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2019-05-28T02:55:04.000Z" class="post-link__date">3 years ago</time></div></a><a href="https://kyohmizu.hatenablog.com/entry/2019/05/28/115504" class="post-link__main-link"><h2 class="post-link__title">Kubernetesリンク集</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=kyohmizu.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>kyohmizu.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2019-05-23T08:21:19.000Z" class="post-link__date">3 years ago</time></div></a><a href="https://kyohmizu.hatenablog.com/entry/2019/05/23/172119" class="post-link__main-link"><h2 class="post-link__title">【20日チャレンジ】LinuxコマンドをGoで実装</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=kyohmizu.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>kyohmizu.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2019-05-23T05:14:55.000Z" class="post-link__date">3 years ago</time></div></a><a href="https://qiita.com/kyohmizu/items/d0cf760e000aa2a20710" class="post-link__main-link"><h2 class="post-link__title">Azure AD認証を使用して、Azure仮想マシン(Linux)にSSH接続する</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2019-04-26T09:44:54.000Z" class="post-link__date">3 years ago</time></div></a><a href="https://qiita.com/kyohmizu/items/bfe1763b4cefa69718cf" class="post-link__main-link"><h2 class="post-link__title">Rancher2.0でAKSクラスタ作成からWordPressデプロイまで</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2019-03-13T05:42:05.000Z" class="post-link__date">3 years ago</time></div></a><a href="https://qiita.com/kyohmizu/items/cbf9cca76a826d8eb130" class="post-link__main-link"><h2 class="post-link__title">fluentd-gcp-scaler コードリーディング</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2018-12-31T14:17:40.000Z" class="post-link__date">3 years ago</time></div></a><a href="https://kyohmizu.hatenablog.com/entry/2018/12/31/231740" class="post-link__main-link"><h2 class="post-link__title">2018年振り返りと、2019年の目標</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=kyohmizu.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>kyohmizu.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2018-12-22T17:33:14.000Z" class="post-link__date">3 years ago</time></div></a><a href="https://qiita.com/kyohmizu/items/5f1929a2e949a9fa0da8" class="post-link__main-link"><h2 class="post-link__title">GCEのVMインスタンス作成からDockerの利用開始まで</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2018-12-20T06:21:26.000Z" class="post-link__date">3 years ago</time></div></a><a href="https://qiita.com/kyohmizu/items/b7b8de409d9e5b0f2626" class="post-link__main-link"><h2 class="post-link__title">【C#】ショートコード・テクニック</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/kyohmizu"><img src="/avatars/kyohmizu.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">kyohmizu</div><time dateTime="2018-04-26T01:59:46.000Z" class="post-link__date">4 years ago</time></div></a><a href="https://qiita.com/kyohmizu/items/be47b8d01a78cd3f0f0d" class="post-link__main-link"><h2 class="post-link__title">Windowsコマンド一覧</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article></div></div></div></section><footer class="site-footer"><div class="content-wrapper"><p>© <!-- -->3-shake Inc.</p></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"member":{"id":"kyohmizu","name":"kyohmizu","role":"SRE","bio":"mizumoto","avatarSrc":"/avatars/kyohmizu.png","sources":["https://kyohmizu.hatenablog.com/feed","https://qiita.com/kyohmizu/feed"],"includeUrlRegex":"","twitterUsername":"kyohmizu","githubUsername":"kyohmizu","websiteUrl":"https://kyohmizu.com/"},"postItems":[{"title":"VolumePlugin がボリュームを作成・マウントするしくみ","contentSnippet":"はじめにPod の作成時、pod.spec.volumes に記述したボリュームがコンテナにマウントされます。マウントされる Node 側のボリュームを、VolumePlugin がどのように作成・マウントしているのか調べました。機能VolumePlugin は kubelet 内で動作するプラグインで、ボリュームの種類（hostPath / EmptyDir / ConfigMap など）ごとに実装されています。VolumePlugin は以下のように定義されています。（ソースはこちら）// VolumePlugin is an interface to volume plugins that can be used on a// kubernetes node (e.g. by kubelet) to instantiate and manage volumes.type VolumePlugin interface {    // Init initializes the plugin.  This will be called exactly once    // before any New* calls are made - implementations of plugins may    // depend on this.    Init(host VolumeHost) error    // Name returns the plugin's name.  Plugins must use namespaced names    // such as \"example.com/volume\" and contain exactly one '/' character.    // The \"kubernetes.io\" namespace is reserved for plugins which are    // bundled with kubernetes.    GetPluginName() string    // GetVolumeName returns the name/ID to uniquely identifying the actual    // backing device, directory, path, etc. referenced by the specified volume    // spec.    // For Attachable volumes, this value must be able to be passed back to    // volume Detach methods to identify the device to act on.    // If the plugin does not support the given spec, this returns an error.    GetVolumeName(spec *Spec) (string, error)    // CanSupport tests whether the plugin supports a given volume    // specification from the API.  The spec pointer should be considered    // const.    CanSupport(spec *Spec) bool    // RequiresRemount returns true if this plugin requires mount calls to be    // reexecuted. Atomically updating volumes, like Downward API, depend on    // this to update the contents of the volume.    RequiresRemount(spec *Spec) bool    // NewMounter creates a new volume.Mounter from an API specification.    // Ownership of the spec pointer in *not* transferred.    // - spec: The v1.Volume spec    // - pod: The enclosing pod    NewMounter(spec *Spec, podRef *v1.Pod, opts VolumeOptions) (Mounter, error)    // NewUnmounter creates a new volume.Unmounter from recoverable state.    // - name: The volume name, as per the v1.Volume spec.    // - podUID: The UID of the enclosing pod    NewUnmounter(name string, podUID types.UID) (Unmounter, error)    // ConstructVolumeSpec constructs a volume spec based on the given volume name    // and volumePath. The spec may have incomplete information due to limited    // information from input. This function is used by volume manager to reconstruct    // volume spec by reading the volume directories from disk    ConstructVolumeSpec(volumeName, volumePath string) (*Spec, error)    // SupportsMountOption returns true if volume plugins supports Mount options    // Specifying mount options in a volume plugin that doesn't support    // user specified mount options will result in error creating persistent volumes    SupportsMountOption() bool    // SupportsBulkVolumeVerification checks if volume plugin type is capable    // of enabling bulk polling of all nodes. This can speed up verification of    // attached volumes by quite a bit, but underlying pluging must support it.    SupportsBulkVolumeVerification() bool}ボリュームの作成・マウントに関する機能は NewMounter です。NewMounter はボリュームの種類に応じた Mounter を生成し、Mounter が実際のボリュームの作成・マウントを行います。同様に NewUnmounter はボリュームの削除・アンマウントを行う Unmounter を生成します。Mounter \u0026 UnmounterMounter、Unmounter の機能をインタフェースの定義から確認します。（ソースはこちら）// Mounter interface provides methods to set up/mount the volume.type Mounter interface {    // Uses Interface to provide the path for Docker binds.    Volume    // CanMount is called immediately prior to Setup to check if    // the required components (binaries, etc.) are available on    // the underlying node to complete the subsequent SetUp (mount)    // operation. If CanMount returns error, the mount operation is    // aborted and an event is generated indicating that the node    // does not have the required binaries to complete the mount.    // If CanMount succeeds, the mount operation continues    // normally. The CanMount check can be enabled or disabled    // using the experimental-check-mount-binaries binary flag    CanMount() error    // SetUp prepares and mounts/unpacks the volume to a    // self-determined directory path. The mount point and its    // content should be owned by `fsUser` or 'fsGroup' so that it can be    // accessed by the pod. This may be called more than once, so    // implementations must be idempotent.    // It could return following types of errors:    //   - TransientOperationFailure    //   - UncertainProgressError    //   - Error of any other type should be considered a final error    SetUp(mounterArgs MounterArgs) error    // SetUpAt prepares and mounts/unpacks the volume to the    // specified directory path, which may or may not exist yet.    // The mount point and its content should be owned by `fsUser`    // 'fsGroup' so that it can be accessed by the pod. This may    // be called more than once, so implementations must be    // idempotent.    SetUpAt(dir string, mounterArgs MounterArgs) error    // GetAttributes returns the attributes of the mounter.    // This function is called after SetUp()/SetUpAt().    GetAttributes() Attributes}Mounter にはパスを指定してボリュームを作成する SetUpAt、パスを指定しないで作成する SetUp が用意されています。SetUp からパスを指定して SetUpAt を呼び出す実装が多いようです。CanMount では該当 Node でボリュームを作成・マウント可能かどうかを確認します。ほとんどは nil を返すだけの実装ですが、NFS では OS の種類（Linux / Windows）に応じたテストコマンドを実行しています。またGetAttributes では以下の値を返します。// Attributes represents the attributes of this mounter.type Attributes struct {    ReadOnly        bool    Managed         bool    SupportsSELinux bool}続いて Unmounter を軽く見ていきます。// Unmounter interface provides methods to cleanup/unmount the volumes.type Unmounter interface {    Volume    // TearDown unmounts the volume from a self-determined directory and    // removes traces of the SetUp procedure.    TearDown() error    // TearDown unmounts the volume from the specified directory and    // removes traces of the SetUp procedure.    TearDownAt(dir string) error}Unmounter はボリュームの削除・アンマウントの機能を提供します。Mounter と同様にパス指定、パス未指定のメソッドがそれぞれ用意されています。実装VolumePlugin の具体的な実装について、いくつか調べたものを紹介します。Mounter の実装を中心に見ていきます。EmptyDirソースはこちらSetUp はパスを指定して SetUpAt を呼び出します。func (ed *emptyDir) SetUp(mounterArgs volume.MounterArgs) error {    return ed.SetUpAt(ed.GetPath(), mounterArgs)}ボリュームのパスは以下で生成し、/var/lib/kubelet/pods/{Pod の UID}/volumes/kubernetes.io~empty-dir/{ボリューム名} の形になります。func getPath(uid types.UID, volName string, host volume.VolumeHost) string {    return host.GetPodVolumeDir(uid, utilstrings.EscapeQualifiedName(emptyDirPluginName), volName)}SetUpAt は次の流れでボリューム（ディレクトリ）を作成・マウントします。ディレクトリが ready であるか確認し、ready の場合は何もしないpod.spec.volumes.emptyDir.medium の設定に従ってディレクトリを作成・マウントfsGroup が設定されている場合は所有者を設定ディレクトリを ready に設定ディレクトリに Quota を設定// コメントは省略func (ed *emptyDir) SetUpAt(dir string, mounterArgs volume.MounterArgs) error {    notMnt, err := ed.mounter.IsLikelyNotMountPoint(dir)    if err != nil \u0026\u0026 !os.IsNotExist(err) {        return err    }    readyDir := ed.getMetaDir()    if volumeutil.IsReady(readyDir) {  // 1        if ed.medium == v1.StorageMediumMemory \u0026\u0026 !notMnt {            return nil        } else if ed.medium == v1.StorageMediumDefault {            if _, err := os.Stat(dir); err == nil {                return nil            }            klog.Warningf(\"volume ready file dir %s exist, but volume dir %s does not. Remove ready dir\", readyDir, dir)            if err := os.RemoveAll(readyDir); err != nil \u0026\u0026 !os.IsNotExist(err) {                klog.Warningf(\"failed to remove ready dir [%s]: %v\", readyDir, err)            }        }    }    switch {  // 2    case ed.medium == v1.StorageMediumDefault:        err = ed.setupDir(dir)    case ed.medium == v1.StorageMediumMemory:        err = ed.setupTmpfs(dir)    case v1helper.IsHugePageMedium(ed.medium):        err = ed.setupHugepages(dir)    default:        err = fmt.Errorf(\"unknown storage medium %q\", ed.medium)    }    volume.SetVolumeOwnership(ed, mounterArgs.FsGroup, nil /*fsGroupChangePolicy*/, volumeutil.FSGroupCompleteHook(ed.plugin, nil))  // 3    if err == nil {        volumeutil.SetReady(ed.getMetaDir())  // 4        if mounterArgs.DesiredSize != nil {            hasQuotas, err := fsquota.SupportsQuotas(ed.mounter, dir)            if err != nil {                klog.V(3).Infof(\"Unable to check for quota support on %s: %s\", dir, err.Error())            } else if hasQuotas {                klog.V(4).Infof(\"emptydir trying to assign quota %v on %s\", mounterArgs.DesiredSize, dir)                err := fsquota.AssignQuota(ed.mounter, dir, ed.pod.UID, mounterArgs.DesiredSize)  // 5                if err != nil {                    klog.V(3).Infof(\"Set quota on %s failed %s\", dir, err.Error())                }            }        }    }    return err}実際のディレクトリの作成には os.MkdirAll を使用しています。pod.spec.volumes.emptyDir.medium が Memory の場合は、mount コマンドで tmpfs にマウントします。（Hugepages については省略）ちなみにディレクトリの ready の確認は、/var/lib/kubelet/pods/{Pod の UID}/plugins/kubernetes.io~empty-dir/{ボリューム名} 以下の ready ファイルの有無を調べています。ConfigMapソースはこちらSetUp は EmptyDir と同様で、渡されるボリュームのパスは /var/lib/kubelet/pods/{Pod の UID}/volumes/kubernetes.io~configmap/{ボリューム名} になります。func (b *configMapVolumeMounter) SetUp(mounterArgs volume.MounterArgs) error {    return b.SetUpAt(b.GetPath(), mounterArgs)}ConfigMap のボリュームの実態は EmptyDir です。SetUpAt は次の流れでボリュームを作成・マウントします。EmptyDir の WrapperMounter を生成ConfigMap を取得ConfigMap から作成するファイル用のデータ（payload）を生成EmptyDir の WrapperMounter でディレクトリを作成ディレクトリにファイルを作成fsGroup が設定されている場合は所有者を設定// コメントは省略func (b *configMapVolumeMounter) SetUpAt(dir string, mounterArgs volume.MounterArgs) error {    klog.V(3).Infof(\"Setting up volume %v for pod %v at %v\", b.volName, b.pod.UID, dir)    wrapped, err := b.plugin.host.NewWrapperMounter(b.volName, wrappedVolumeSpec(), \u0026b.pod, *b.opts)  // 1    if err != nil {        return err    }    optional := b.source.Optional != nil \u0026\u0026 *b.source.Optional    configMap, err := b.getConfigMap(b.pod.Namespace, b.source.Name)  // 2    if err != nil {        if !(errors.IsNotFound(err) \u0026\u0026 optional) {            klog.Errorf(\"Couldn't get configMap %v/%v: %v\", b.pod.Namespace, b.source.Name, err)            return err        }        configMap = \u0026v1.ConfigMap{            ObjectMeta: metav1.ObjectMeta{                Namespace: b.pod.Namespace,                Name:      b.source.Name,            },        }    }    totalBytes := totalBytes(configMap)    klog.V(3).Infof(\"Received configMap %v/%v containing (%v) pieces of data, %v total bytes\",        b.pod.Namespace,        b.source.Name,        len(configMap.Data)+len(configMap.BinaryData),        totalBytes)    payload, err := MakePayload(b.source.Items, configMap, b.source.DefaultMode, optional)  // 3    if err != nil {        return err    }    setupSuccess := false    if err := wrapped.SetUpAt(dir, mounterArgs); err != nil {  // 4        return err    }    if err := volumeutil.MakeNestedMountpoints(b.volName, dir, b.pod); err != nil {        return err    }    defer func() {        if !setupSuccess {            unmounter, unmountCreateErr := b.plugin.NewUnmounter(b.volName, b.podUID)            if unmountCreateErr != nil {                klog.Errorf(\"error cleaning up mount %s after failure. Create unmounter failed with %v\", b.volName, unmountCreateErr)                return            }            tearDownErr := unmounter.TearDown()            if tearDownErr != nil {                klog.Errorf(\"Error tearing down volume %s with : %v\", b.volName, tearDownErr)            }        }    }()    writerContext := fmt.Sprintf(\"pod %v/%v volume %v\", b.pod.Namespace, b.pod.Name, b.volName)    writer, err := volumeutil.NewAtomicWriter(dir, writerContext)    if err != nil {        klog.Errorf(\"Error creating atomic writer: %v\", err)        return err    }    err = writer.Write(payload)  // 5    if err != nil {        klog.Errorf(\"Error writing payload to dir: %v\", err)        return err    }    err = volume.SetVolumeOwnership(b, mounterArgs.FsGroup, nil /*fsGroupChangePolicy*/, volumeutil.FSGroupCompleteHook(b.plugin, nil))  // 6    if err != nil {        klog.Errorf(\"Error applying volume ownership settings for group: %v\", mounterArgs.FsGroup)        return err    }    setupSuccess = true    return nil}NewWrapperMounter はボリューム名にプレフィックスとして wrapped_ を付与した Mounter を生成します。Mounter の生成には直接 EmptyDir を指定するのではなく、volume.Spec からプラグインを特定する方法を取ります。ConfigMap では以下のように VolumeSource に EmptyDir を設定しているため、EmptyDir の Mounter が生成されます。// コメントは省略func wrappedVolumeSpec() volume.Spec {    return volume.Spec{        Volume: \u0026v1.Volume{VolumeSource: v1.VolumeSource{EmptyDir: \u0026v1.EmptyDirVolumeSource{}}},    }}EmptyDir の Mounter で空のディレクトリを作成したら、あとはファイルを作成するだけです。ファイルの作成には ioutil.WriteFile os.Chmod os.Chown を使用します。SecretソースはこちらSecret は ConfigMap とほとんど同じ実装です。EmptyDir の Mounter で作成したディレクトリにファイルを書き込みます。ただし Secret のボリュームは tmpfs にマウントする必要があるため、volume.Spec で EmptyDir を設定する時に Medium: v1.StorageMediumMemory を指定しておきます。func wrappedVolumeSpec() volume.Spec {    return volume.Spec{        Volume: \u0026v1.Volume{VolumeSource: v1.VolumeSource{EmptyDir: \u0026v1.EmptyDirVolumeSource{Medium: v1.StorageMediumMemory}}},    }}ボリュームのパスは /var/lib/kubelet/pods/{Pod の UID}/volumes/kubernetes.io~secret/{ボリューム名} になります。ProjectedソースはこちらProjected は Secret とほとんど同じ実装です。ConfigMap / Secret/ DownwardAPI / ServiceAccountToken のデータを取得し、tmpfs にマウントしたディレクトリに書き込みます。VolumePlugin の種類通常の VolumePlugin の他に、VolumePlugin を埋め込んだインタフェースが複数用意されています。以下はその一例です。PersistentVolumePlugin：GetAccessModes を実装（hostPath / Amazon EBS など）RecyclableVolumePlugin：Recycle を実装（hostPath / NFS など）ProvisionableVolumePlugin：NewProvisioner を実装（hostPath / Amazon EBS など）※ hostPath は通常のボリュームと PV の両方の実装を含む今回取り扱ったのは通常の VolumePlugin のみですので、VolumePlugin の実装によっては紹介した内容と異なるものがあります。おわりにKubernetes を利用する上であまり意識することのない部分ですが、しくみを理解していればトラブルシューティング等での助けになるのではないかと思います。ConfigMap / Secret のマウントについては以前から気になっていたので、今回詳しく知ることができて満足です。ご指摘等ありましたらよろしくお願いします。","link":"https://qiita.com/kyohmizu/items/40bee7037e1ce7949772","isoDate":"2020-12-17T10:54:47.000Z","dateMiliSeconds":1608202487000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"情報処理安全確保支援士の関連資料","contentSnippet":"情報処理安全確保支援士の業務を行う上で、参照すべき資料一覧です。サイバーセキュリティ基本法（平成二十六年法律第百四号）情報処理の促進に関する法律（昭和四十五年法律第九十号）情報処理学会倫理綱領RFC:1087 倫理とインターネット(Ethics and the Internet)セキュリティ対応組織 (SOC,CSIRT)強化に向けたサイバーセキュリティ情報共有の「5W1H」 v2.0 (2019年4月)JPCERT インシデントハンドリングマニュアルIPA 脆弱性対策の効果的な進め方（ツール活用編）情報セキュリティ早期警戒パートナーシップガイドラインIPA 重要なセキュリティ情報一覧IPA 共通脆弱性評価システムCVSS v3概説JVN (Japan Vulnerability Notes)JVN 脆弱性レポートの読み方JVN iPediaFIRST Common Vulnerability Scoring System SIGCWE (Common Weakness Enumeration)IPA 脆弱性体験学習ツール AppGoatMyJVNIPA 組織における内部不正防止ガイドライン地方公共団体における情報セキュリティポリシーに関するガイドライン(平成30年9月版)IPA 委託関係における情報セキュリティ対策ガイドラインIPA 中小企業の情報セキュリティ対策ガイドラインIPA 情報漏えい対策のしおりNISC スマートフォン等の業務利用における情報セキュリティ対策の実施手順作成手引書個人情報の保護に関する法律についてのガイドラインIPA 企業(組織)における最低限の情報セキュリティ対策のしおりスマートフォンのセキュリティ＜危険回避＞対策のしおりJPCERT/CC 技術メモ - 安全な Web ブラウザの使い方IPA ウェブブラウザのプロテクションプロファイル","link":"https://kyohmizu.hatenablog.com/entry/2020/08/05/115459","isoDate":"2020-08-05T02:54:59.000Z","dateMiliSeconds":1596596099000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"2019年のふりかえり、2020年の目標","contentSnippet":"すでに年が明けて1ヶ月経ちましたが、2019年の活動を振り返ろうと思います。Kubernetes、Cloud Native技術を中心に学習を進めました。勉強会、カンファレンス1月Cloud Native Meetup Tokyo #6 KubeCon + CNCon RecapKubernetes Meetup Tokyo #15 - KubeCon 2018 RecapRancher/Kubernetes勉強会　Kubernetes管理ツールの活用法OWASP Connect in Tokyo #2今回は特別編！Cloud Nativeなアプリ開発から学んだことを全部シェア - cndjp#92月Yahoo! JAPAN MEETUP #31 インフラ技術カンファレンスGo 1.12 Release Party in Tokyo w/ Fukuoka\u0026Umedassmjp 2019/02Docker Meetup Tokyo #28第三回ボトムアップドメイン駆動設計サイバーセキュリティシンポジウム3月k8s source code reading #3Cloud Native Meetup Tokyo #7 @Abema Towers4月Cloud Native Tokyo #01Serverlessについて思いを馳せる一夜 - cndjp第11回勉強会ssmjp 2019/04Rancher k3s もくもく勉強会 #035月レガシーをぶっつぶせ。現場でDDD！ssmjp 2019/05IIJ Technical NIGHT vol.7SRE Lounge #9Docker Meetup Tokyo #30 (DockerCon・KubeConEU報告会)Yahoo! JAPAN MEETUP #32 インフラ技術／Kubernetes6月NoOps Meetup Tokyo #6Kubernetes Meetup Tokyo #20 - KubeCon RecapGCPUG Tokyo Next Extended 2019 Infra DayInteract 20197月恐るることなかれ! Cloud NativeリレーショナルDB特集!! - cndjp第12回第三十五回 Azureもくもく会 @ 品川CloudNative Days Tokyo Meetup w/ Melanie CebulaKubernetes Meetup Tokyo #21 - Cloud Native CI/CDSekkeiKaigiCloud Native Days Tokyo 2019 → スタッフとして参加8月SRE Lounge #10CloudNative Days Tokyo 2019振り返りNightGo 1.13 Release Party in TokyoKubernetes Meetup Tokyo #229月Docker Meetup Tokyo #32Japan Azure User Group 9周年イベントXP祭り2019golang.tokyo #26Cloud Native Meetup Tokyo #10Kubernetes Meetup Tokyo #23 - Operator Deep Dive10月Terraform meetup tokyo#2Kubernetes Meetup Tokyo #24SRE Lounge #1111月さくらの夕べDocker/Kubernetesナイト #2Go Release 10 Year Anniversary Party in Tokyoゴリラ.vim #10 非公式VimConf後夜祭 girls.vimと合同開催技術書典8 はじめてのサークル参加meetupMicrosoft Open Tech Night #1 - インフラ編+Ignite速報俺たちの最適なCloud Nativeを求めて…。本気のこと始め！ - cndjp第13回12月Japan Rook Meetup #1Cloud Native Meetup Tokyo #11 KubeCon RecapGDG DevFest Tokyo 2019Microsoft Open Tech Night #3 - クラウドネイティブ編登壇資料speakerdeck.comspeakerdeck.comspeakerdeck.com書籍商業誌Kubernetes完全ガイドしくみがわかるKubernetesみんなのDocker/KubernetesKubernetes実践入門情報処理安全確保支援士 教科書みんなのGo言語インフラエンジニアの教科書Linuxのしくみ分散システムデザインパターン入門監視Linux教科書 LPICレベル1Docker実践ガイドKubernetes実践ガイド同人誌ふりかえり読本 場作り編ふりかえり読本 学び編ふりかえり読本 実践編理論と事例でわかる自己肯定感理論と事例でわかるモチベーション現場の「ズレ」を解消するコミュニケーションメソッド 第2版会話の引き出しを増やす 1on1カード と 使いこなしブックPrometheusでKubernetesを監視する本Kubernetes-Native Development \u0026 Deployment実践入門 Kubernetes カスタムコントローラへの道Knativeの歩き方資格情報処理安全確保支援士LPIC 101、102ツール・技術DockerKubernetesHelmPrometheusGrafanaLokiArgo CDConcourseTerraformTelepresencecert-managerWindowsコンテナMicrosoft AzureGo言語Vue.js社内での活動定期勉強会を主催ふりかえりを実施、ファシリテーター役Dockerワークショップを開催2020年の目標2020年もCloud Nativeを突き進む予定です。マストCKA、CKADを取得するコミュニティに貢献するOSSにコントリビュートするGo言語でのプログラミングに慣れる英語力を高めるできれば業務としてKubernetesを扱える環境に身を置く（遠回しな表現）技術書を書く","link":"https://kyohmizu.hatenablog.com/entry/2020/02/01/040351","isoDate":"2020-01-31T19:03:51.000Z","dateMiliSeconds":1580497431000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"0からはじめる Windows on Kubernetes","contentSnippet":"はじめにKubernetes の Windows 対応は v.1.14 でGAとなりました。本記事では、既存の Kubernetes クラスタに0から Windows ワーカーノードを追加する方法をご紹介します。実行環境今回は実行環境として Azure を使用しています。Kubernetes クラスタ（hard way on azure で作成）Linux VM（ubuntu 18.04）×6Windows ノードWindows VM（Windows Server 2019 Datacenter）×1# クラスタには3台の Linux ワーカーノード$ kubectl get noNAME       STATUS   ROLES    AGE     VERSIONworker-0   Ready    \u003cnone\u003e   12m     v1.15.0worker-1   Ready    \u003cnone\u003e   7m26s   v1.15.0worker-2   Ready    \u003cnone\u003e   5m59s   v1.15.0クラスタ側の修正hard way で作成したクラスタですが、kube-controller-manager の起動オプションが足りていません。kube-controller-manager.service[Unit]Description=Kubernetes Controller ManagerDocumentation=https://github.com/kubernetes/kubernetes[Service]ExecStart=/usr/local/bin/kube-controller-manager \\  --address=0.0.0.0 \\+ --allocate-node-cidrs=true \\  --cluster-cidr=10.200.0.0/16 \\  --cluster-name=kubernetes \\  --cluster-signing-cert-file=/var/lib/kubernetes/ca.pem \\  --cluster-signing-key-file=/var/lib/kubernetes/ca-key.pem \\  --kubeconfig=/var/lib/kubernetes/kube-controller-manager.kubeconfig \\  --leader-elect=true \\  --root-ca-file=/var/lib/kubernetes/ca.pem \\  --service-account-private-key-file=/var/lib/kubernetes/service-account-key.pem \\  --service-cluster-ip-range=10.32.0.0/24 \\  --use-service-account-credentials=true \\  --v=2Restart=on-failureRestartSec=5[Install]WantedBy=multi-user.targetこのオプションがないとcluster-cidrが適用されず、ノードのpodCIDRが未設定になってしまいます。以降で使用するスクリプトでpodCIDRが必要になるので、事前に修正しておきましょう。Windows ノードの追加途中までMSのドキュメントを参考に進めていきます。Docker のインストール手順に従って Docker をインストールし、マシンを再起動します。Install-Module -Name DockerMsftProvider -Repository PSGallery -ForceInstall-Package -Name Docker -ProviderName DockerMsftProviderRestart-Computer -Force再起動後、docker pullでコンテナイメージを取得します。ここで取得するイメージは Pod 内のインフラ用コンテナの作成に使用します。Dockerfile に記載されているイメージはタグが未指定なので、取得したイメージに latest タグを付加してください。docker pull mcr.microsoft.com/windows/nanoserver:1809docker tag mcr.microsoft.com/windows/nanoserver:1809 mcr.microsoft.com/windows/nanoserver:latestちなみにインストールが完了すると、Get-HNSNetworkなど HNS の操作が可能になります。実行ファイルの用意Kubernetes のファイルを配置するディレクトリを作成します。mkdir c:\\kディレクトリを作成したら以下のファイルを配置してください。クラスタに接続できる kubeconfig（ファイル名は config）kubernetes ノード用バイナリkubectl.exekubelet.exekube-proxy.exeバイナリは Kubernetes のリリースページにアクセスし、CHANGE LOGから取得できます。次のような構成になっていればOKです。ls config,*exe    Directory: C:\\kMode                LastWriteTime         Length Name----                -------------         ------ -----a----       12/22/2019  11:49 AM           6254 config-a----       12/11/2019   1:14 PM       40086016 kube-proxy.exe-a----       12/11/2019   1:20 PM       47195136 kubectl.exe-a----       12/11/2019   1:20 PM      119127552 kubelet.exeスクリプトの実行ではいよいよ、各種設定とバイナリの起動を行う powershell スクリプトを実行していきます。github からスクリプトをダウンロードしてください。cd c:\\kStart-BitsTransfer https://github.com/microsoft/SDN/raw/master/Kubernetes/windows/start.ps1ここではMSのドキュメントの手順とは異なるスクリプトをダウンロードしています。MSのドキュメントでは CNI プラグインとして flannel を使用し、vxlan overlay ネットワークを構成しています。flannel はクラスタに事前にインストールする必要がありますが、hard way のクラスタでは別の CNI プラグインを使用しているため、今回は flannel を使用しない方法を取りました。ダウンロードしたスクリプトでは wincni.exe を使用し、L2 ブリッジネットワークを構成します。（overlay も選択可）start.ps1 は以下の処理を順番に行います。必要なバイナリ、スクリプト、Dockerfile をダウンロードコンテナイメージを作成（InstallImages.ps1）HNS ネットワークを初期化kubelet を起動（start-kubelet.ps1）kube-proxy を起動（start-kubeproxy.ps1）ルーティングテーブルに追加（AddRoutes.ps1）スクリプト1つで必要な処理をすべて行ってくれるようです。またスクリプトの中を見てみると、2つの param を設定できることがわかります。start.ps1Param(    [parameter(Mandatory = $true)] [string] $masterIp,    [parameter(Mandatory = $false)] $clusterCIDR=\"192.168.0.0/16\")masterIpは VM のプライベートIP（10.240.0.4）、clusterCIDRは上述の kube-controller-manager で設定した値（10.200.0.0/16）を使用します。.\\start.ps1 -masterIp 10.240.0.4 -clusterCIDR 10.200.0.0/16これでノードの追加完了！…とはいきませんでした。動かない…案の定そのままでは動きませんでした。powershell ウィンドウにはWaiting for the Network to be createdが延々と出力され続けていると思います。一度実行すると必要なファイル等はダウンロードされるので、start.ps1は捨てて個別のスクリプトを修正＆実行していきます。スクリプトの修正＆実行helper.psm1helper.psm1function Get-PodCIDR(){-   return c:\\k\\kubectl.exe --kubeconfig=c:\\k\\config get nodes/$($(hostname).ToLower()) -o custom-columns=podCidr:.spec.podCIDR --no-headers+   return \"10.200.3.0/24\"}まずはモジュールの修正から。これは本当に疑問なのですが、ノードの追加前なのにクラスタから自身のノード情報を取得しようとしているのはどうしてでしょうか…？（間違っていたらご指摘ください）当然取得はできないので、自分で決めた podCIDR を返すように修正します。モジュールをインポート済みの場合は一度削除しておいてください。Remove-Module helperInstallImages.ps1問題なく実行できているので、修正・再実行は行いません。事前に取得した Docker イメージから、pause コンテナを作成しています。docker image ls | Out-String -Stream | Select-String pausekubeletwin/pause                       latest              14d3bdf2f5cb        5 hours ago         251MBstart-kubelet.ps1start-kubelet.ps1Param(+   $clusterCIDR=\"10.200.0.0/16\",-   $clusterCIDR=\"192.168.0.0/16\",    $NetworkMode = \"L2Bridge\",    $NetworkName = \"l2bridge\",    [ValidateSet(\"process\", \"hyperv\")]    $IsolationType = \"process\")# Todo : Get these values using kubectl$KubeDnsSuffix =\"svc.cluster.local\"+$KubeDnsServiceIp=\"10.32.0.10\"-$KubeDnsServiceIp=\"11.0.0.10\"+$serviceCIDR=\"10.32.0.0/24\"-$serviceCIDR=\"11.0.0.0/8\"Todo と記載された変数は外から設定できないようです。なぜこんなところに？$KubeDnsServiceIpには kube-dns サービスのクラスタIP、$serviceCIDRには kube-controller-manager で設定したservice-cluster-ip-rangeを使用します。ついでに param の$clusterCIDRも修正しておきました。これでオプションなしでスクリプトを実行できるはずです。.\\start-kubelet.ps1成功するとフォアグラウンドで kubelet.exe が実行中になるので、別の powershell ウィンドウを起動してください。（start powershellで別ウィンドウで起動しても良いです）kubelet を無事に起動できると、クラスタにノードが追加されていることが確認できます。$ kubectl get noNAME         STATUS   ROLES    AGE    VERSIONwin-server   Ready    \u003cnone\u003e   173m   v1.16.4worker-0     Ready    \u003cnone\u003e   28h    v1.15.0worker-1     Ready    \u003cnone\u003e   28h    v1.15.0worker-2     Ready    \u003cnone\u003e   28h    v1.15.0start-kubelet.ps1start-kubelet.ps1Param(    [parameter(Mandatory = $false)] $LogDir = \"C:\\k\",        $NetworkName = \"cbr0\")特に修正の必要はありません。初回起動時にはここまで到達していないので、スクリプトを実行します。他の箇所とは違い$NetworkNameの初期値がなぜかcbr0になっていますが、惑わされずにl2bridgeを指定しましょう。（私は惑わされました）.\\start-Kubeproxy.ps1 -NetworkName l2bridge成功するとフォアグラウンドで kube-proxy.exe が実行中になります。AddRoutes.ps1最後にこのスクリプトを実行します。こちらも修正は不要です。初回起動時と同様、$masterIpには VM のプライベートIPをしていてください。.\\AddRoutes.ps1 -masterIp 10.240.0.4これでノードの追加完了です！動作確認Windows コンテナのデプロイを試したり、Linux ノード上のコンテナから Windows ノード上のコンテナにアクセスしてみたり、色々と試してみてください。$ kubectl get po,svc -o wideNAME                                 READY   STATUS    RESTARTS   AGE   IP             NODE        NOMINATED NODE   READINESS GATESpod/busybox                          1/1     Running   13         13h   10.200.2.4     worker-2    \u003cnone\u003e           \u003cnone\u003epod/nginx                            1/1     Running   0          38h   10.200.1.3     worker-1    \u003cnone\u003e           \u003cnone\u003epod/ubuntu                           1/1     Running   0          20h   10.200.1.4     worker-1    \u003cnone\u003e           \u003cnone\u003epod/win-webserver-784d66c84f-bqh9l   1/1     Running   0          10h   10.200.3.159   win-server  \u003cnone\u003e           \u003cnone\u003epod/win-webserver-784d66c84f-ssxfr   1/1     Running   0          10h   10.200.3.39    win-server  \u003cnone\u003e           \u003cnone\u003eNAME                    TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE   SELECTORservice/kubernetes      ClusterIP   10.32.0.1    \u003cnone\u003e        443/TCP        38h   \u003cnone\u003eservice/nginx           NodePort    10.32.0.52   \u003cnone\u003e        80:32121/TCP   37h   run=nginxservice/win-webserver   NodePort    10.32.0.65   \u003cnone\u003e        80:31663/TCP   10h   app=win-webserverサービスとして起動する今回は powershell 上で kubelet.exe と kube-proxy.exe を起動しましたが、これらを Windows のサービスとして起動する方法もあります。詳細はこちらをご参照ください。感想最後までたどり着いて本当に良かった…色々と悩んで調べまわった結果、ネットワーク周りと powershell の知識が身についてきたのは良かったです。Issue はあまり確認する時間がなかったので、きちんと調べたら別の方法があったかもしれません。何かご存知の方は教えてくださいm(_ _)m実際に Windows ノードを使用する場合は、やはりマネージドサービスがおススメです。AKS であれば Windows ノードプールを指定するだけで簡単に始められます。オンプレの場合は kubeadm + flannel を使用した方法が kubernetes.io で紹介されています。その他の方法についてもサイト下部に記載があるので、興味のある方は読んでみてください。参考Joining Windows Server Nodes to a Clustergithub: microsoft/SDN/Kubernetes/WindowsKubernetesとFlannelでWindows上にPod間VXLAN Overlayネットワークを構成Kubernetes Networking: Behind the scenesTroubleshooting Kubernetes Networking on Windows: Part 1","link":"https://qiita.com/kyohmizu/items/dffdd49123b1e47c3ac4","isoDate":"2019-12-22T18:19:52.000Z","dateMiliSeconds":1577038792000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"【イベント参加レポート】Microsoft Ignite The Tour Tokyo","contentSnippet":"2019/12/5(木)、6(金)に開催された Microsoft の Tech イベントに参加しました。www.microsoft.com概要アメリカで行われた Ignite のセッションを再演登壇者は他人の資料で発表 (翻訳以上の改変はできないと聞きました)新情報の発表等はされず、通常セッションとハンズオンのみMicrosoft エキスパートとの交流の場外国人のスタッフを多数配置基本的には英語でやり取りするらしい (私は話しませんでした)感想外国人が多く、グローバルな印象を受けました。会場はいつものホテルでしたが、やはりセッションの入れ替え時は非常に混雑します。ブースのエリアはスペースを広くとってあり、割と閑散としていた気がします (セッション中は特に)。技術的には初級者向けの内容が多かったと思います。セッションよりは、どちらかといえばコミュニケーションを重視したイベントのようでした。MSの方やブースの担当者と話すことができ、有意義な時間を過ごせました。参加して得るものはありました。セッション参加セッションのまとめとメモ。THR30031 - Azure とコマンドライン－オプション、ヒント、テクニック難易度：初級メモエクスプローラーでcmdをパスに入力(powershell、wslも)Windows Console → Windows TerminalTerminalはStoreで入手可能Azure CLIやVSCode RemoteはサラッとAPPS30 - コンテナーを利用したアプリケーションの最新化資料：https://github.com/microsoft/ignite-learning-paths-training-apps/tree/master/apps30難易度：初級要点コンテナ、Dockerの基礎的な説明コンテナランタイムやマルチステージビルド等は、軽く話に出る程度コンテナに関しては特に知らない話はなかったACRやACIの概要、使い方の軽い説明サービス移行のデモではコンテナ化してApp Service、CosmosDB、SQL Databaseを使用メモデータセンターのアプリをクラウドにLift\u0026Shift仮想マシンはいいけど無駄が多いコンテナを使ったモダナイゼーションアプリの境界を明確にする旧バージョンの残りファイルがなくなるオーバーヘッドなしでリソース分離繰り返し可能なビルド、環境構築コンテナを使う理由あらゆる環境で同じように動作するベロシティの向上コンテナの仕組み高度に構成されたプロセスcgroupsnamespaceベースイメージからの差分をgzip化したものコンテナランタイムの軽い説明Docker以外にも対応、containerd、runCDockerfileイメージのビルド方法を説明するテキストファイルバッチスクリプトみたいなものビルドリポジトリACRACIサーバーレスのコンテナ実行環境ハイパーバイザーレベルの分離デモサービス移行の話APPS40 - インフラストラクチャと Azure Kubernetes Service を統合する資料：https://github.com/microsoft/ignite-learning-paths-training-apps/tree/master/apps40難易度：中級要点AKSの作成手順の説明AKSとAzureの連携サービスについて知識を整理できたオートスケールの話は理解が浅かったので参考になったAKSを使う最大のメリットはAzureADとの連携ネットワークとセキュリティの話は非常に参考になったネットワークポリシーやAZメモ基本的な使い方ではなく、発展的な内容Tailwind Tradaersのデモ経営、ビジネス課題に対応復元力セキュリティ柔軟性スケールKubernetesを選択する理由抽象化のための標準化されたAPI自己修復スケーラビリティk8sアーキテクチャAKSはマスターノードが無料で提供されるネットワークに2種類指定できるデフォルトはkubenetAzure CNI 仮想ネットワークを使用。大規模ネットワークに対応。きちんと設計する必要があるACIを仮想ノードとして使用AZAKSの作成リソースグループ仮想ネットワークサブネットサービスプリンシパル(k8sから他のリソースを作成)クラスタ本番クラスタを作成するにはオプションを多数指定する必要がある作成時にしか設定できないオプションがあるインストール時にCNI、AZの設定をする仮想ノードの有効化ACIをAKSから使えるようにする必要があるRabbitMQ is 何？HPAメトリクスサーバーにPodから情報が送られる閾値を超えたらスケールクラスタオートスケーラーノードのスケール仮想ノードLinux、Windows、GPUに対応nodeselectorで指定仮想ノードによるスケールのデモネットワークとセキュリティACRでコンテナの脆弱性をチェックAKSを使う最大のメリットはAzureADとの連携！Azure Key VaultPod間の通信Pod IdentityNMI Server(Daemonset)MICAzure Identity BindingネットワークポリシーPod間トラフィックの保護Azure Network PolicyAzure CNIを使ったPodブリッジレベルCalico Network PolicyカーネルレベルAZベータ版データセンター障害の回復性ゾーンは3つまで使用可能ゾーンの数に合わせてレプリカ数を設定THR10007 - ITと技術者の将来について語り合うエモい話要点ディスカッション形式コミュニティ参加やアウトプットを重視しているどんどんチャレンジしてスキルをつけていくことが大事メモ今後あるいは10年後どうなる？これからチャレンジしたいことは？MRフリーランス自分の営業をこれからも続けていく自分が何が得意で、何が苦手かアピールブルーオーシャンを探したいコミュニティのエンパワーメント出てこない人にどうやって技術を好きになってもらうか社内コミュニティを作ってもらうお勧めしたいことは？技術を楽しんで、周りに広めていく仲間ができてコミュニティができる人を変えるのは難しい、好きなことを広めることならできる楽しんでる雰囲気を出していると向こうから来てくれる自分の強みを知って、それを発信していく業務で触ってなくてもコミュニティで発表いていたやりたいこと、好きなことを見つけて、人が見える場所に出していく外のコミュニティに参加してみる会社にいるだけではスキルはプロジェクト依存コミュニティの熱量がすごいアウトプットすると強い人がインプットをくれるとりあえず踏み出してみる楽しんだもの勝ちやりたいことを素直にやってみるUNC10013 - Vue.js 3 に向けた Vue.js 入門難易度：初級～中級要点Vue.js の設計思想、V3 でも使える構文、V3 の新機能コンポジッションAPI関数ベースで提供される APIコンポーネントのロジックが綺麗になるV2 でもお試しで使えるブース立ち寄ったブースの中で、興味を持った内容を紹介します。LenovoLenovo ThinkSystem SE350 | レノボジャパン軽量でコンパクトなエッジサーバーWifi、LTE、有線ネットワーク対応Intel製品概要: OpenVINO™ ツールキットエッジでのディープラーニング推論アプリケーション開発学習済みモデルを無料で利用可能インテルCPUに対応PivotalAzure Spring Cloud | Microsoft DocsSpring Boot アプリをクラウドで実行ベータ版のサービスAKS 上にデプロイされる水平スケールやメトリクス、ログの収集が可能AKS は隠蔽されているため、ユーザーからは見えない手軽に導入できるので POC にも適している","link":"https://kyohmizu.hatenablog.com/entry/2019/12/10/012041","isoDate":"2019-12-09T16:20:41.000Z","dateMiliSeconds":1575908441000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"LPIC 102 チートシート","contentSnippet":"試験前の確認事項としてまとめた内容です。環境変数namecontentDISPLAYリモートアクセス先のホストLANGロケール(全カテゴリ)TZタイムゾーンUSERログインユーザーHOSTNAMEホスト名PATHコマンドやプログラムを検索するディレクトリの一覧PWDカレントディレクトリのパスロケールcategorycontentLC_CTYPE文字の分類、文字の種類の規定LC_NUMERIC数値の書式LC_TIME日付・時刻の書式LC_MESSAGES出力メッセージの言語LC_MONETARY通貨の書式LC_NAME名前の書式LC_ADDRESSアドレス、ロケーションの書式LC_TELEPHONE電話番号の書式LC_ALL指定した値が全カテゴリを上書き、個別設定はできないLANGデフォルト値ディレクトリ・ファイルpathcontent/proc起動中のプロセスやカーネルが認識しているハードウェアの情報が格納されているディレクトリ/proc/sys/net/ipv4/ip_forward/etcシステムの設定ファイルなどが格納されているディレクトリ/etc/X11/xorg.confX.Orgの設定ファイル/etc/X11/xorg.conf.d/(~.conf)X.Orgの設定ファイルが格納されるディレクトリ/etc/X11/xdmXDMの設定ファイルを格納するディレクトリ/etc/X11/gdmGDMの設定ファイルを格納するディレクトリ/etc/X11/kdmKDMの設定ファイルを格納するディレクトリ/etc/X11/xinit/Xclientsウィンドウマネージャの起動ファイル/etc/X11/xinit/xinitrcstartxやxinitコマンドで読み込まれるスクリプト(~/.Xresourcesファイル、~/.Xclientsファイルが呼び出される, /etc/X11/xinit/xinitrc.d/ディレクトリ以下のファイルが呼び出される)/etc/X11/xdm/Xsessionウィンドウマネージャの起動(/etc/X11/xinit/xinitrc.d/ディレクトリ配下のファイルが呼び出される)/etc/X11/xdm/Xresourcesログイン画面の表示やXクライアントの設定(xinitrc（または~/.xinitrc）やXsession（または~/xsession）で読み込まれる)/etc/passwdユーザーアカウント情報/etc/shadowシャドウパスワード情報/etc/groupグループの設定/etc/crontabシステムのcrontabファイル/etc/cron.*/etc/crontabから呼び出される/etc/cron.dcronジョブを記述したファイルを格納したディレクトリ/etc/cron.hourly1時間に1度実行されるcronジョブを記述したファイルを格納するディレクトリ/etc/cron.daily1日に1度実行されるcronジョブを記述したファイルを格納するディレクトリ/etc/cron.weekly週に1度実行されるcronジョブを記述したファイルを格納するディレクトリ/etc/cron.monthly月に1度実行されるcronジョブを記述したファイルを格納するディレクトリ/etc/at.allowatコマンドのアクセスを許可するユーザーを記述するファイル/etc/at.denyatコマンドのアクセスを拒否するユーザーを記述するファイル/etc/localtimeシステムで利用するタイムゾーンを/usr/share/zoneinfoからコピー。バイナリファイル/etc/timezoneTZの設定を全ユーザーで利用するために記述するテキストファイル/etc/skelユーザーに新規作成時、ホームディレクトリにコピーされるファイルを格納するディレクトリ/etc/ntp.confNTPサーバーの設定/etc/ntp.driftNTPサーバーの補正情報/etc/chrony.confChronyの設定ファイル/etc/rsyslog.confrsyslogの設定ファイル/etc/rsyslog.drsyslogの設定ファイルを格納するディレクトリ/etc/systemd/journald.confjournaldの設定ファイル/etc/logrotate.conflogrotateの設定/etc/aliasesメールアドレスの別名を設定/etc/cups/cupsd.confCUPSの設定ファイル/etc/cups/printers.confプリンタに関する設定ファイル/etc/servicesポート番号とサービスの対応を記述したファイル/etc/hostnameホスト名を記述したファイル/etc/hostsホスト名とIPアドレスの対応を記述したファイル/etc/network/interfacesネットワークインターフェースの設定を記述したファイル(Debian系)/etc/sysconfig/network-scriptsネットワークインターフェースの設定ファイルを配置するディレクトリ(Red Hat系)/etc/resolv.conf参照先DNSサーバの設定/etc/nsswitch.conf名前解決の順序設定/etc/systemd/resolved.confsystemd-resolvedサービスの設定ファイル/etc/xinetd.confxinetdの設定ファイル/etc/xinetd.dxinetdの設定ファイルを格納するディレクトリ/etc/hosts.allowtcpdのアクセス許可設定/etc/hosts.denytcpdのアクセス拒否設定/etc/nologinrootアカウントによるログイン以外を禁止/etc/ssh/sshd_configsshdの設定ファイル/etc/default/useradduseraddでオプションを指定しない場合に使用されるデフォルト値/etc/sudoerssudoの設定ファイル/var/var/spool/cron(/crontabs)ユーザーのcrontabファイルを格納するディレクトリ/var/spool/mail/メールスプール(表示コマンド：mail)/var/spool/mqueue/メールキュー(表示コマンド：mailq)/var/log/messages/var/log/lastlog/var/log/journal/var/run/log/journal/var/log/syslog/var/log/secure認証サービスのログファイル/var/log/maillogメールサービスに関するログの出力先となるディレクトリ/var/log/wtmplastが参照するファイル/var/log/utmp/var/run/utmpwやwhoが参照するファイル。システムにログインしているユーザー情報/boot/usr/usr/share/zoneinfoタイムゾーン情報を記述したバイナリファイルを格納するディレクトリ~/ホームディレクトリ~/.ssh/known_hostsサーバーの公開鍵が登録されるファイル~/.ssh/authorized_keysサーバーに登録される公開鍵情報~/.xsesssionユーザごとのXsessionスクリプト~/.XresourcesユーザーごとのXクライアントの設定~/.xinitrcユーザーごとのxinitrcスクリプト~/.xsession-errorsX Window Systemのエラーが出力されるファイル~/.gnupgGnuPGに関連するファイルの置かれるディレクトリ文字コードcodecontentASCII7ビットの文字コード。128種類の文字(英数字、記号、制御コード)を表現ISO-8859ASCIIを8ビットに拡張したもの。256種類の文字を表現Unicode他言語を扱うために作成された文字コードUTF-8Unicodeで定義された文字を表示する符号化方式(ASCIIと互換)EUC-JPUNIX環境で標準的に利用される日本語文字コードShift_JISWindowsで標準的に利用される日本語文字コードIPアドレスのクラスclassrangesubnetA0.0.0.0 - 127.255.255.255255.0.0.0B128.0.0.0 - 191.255.255.255255.255.0.0C192.0.0.0 - 223.255.255.255255.255.255.0D224.0.0.0 - 239.255.255.255E240.0.0.0 - 255.255.255.255プライベートアドレスclassrangesubnetA10.0.0.0 - 10.255.255.255B172.16.0.0 - 172.31.255.255C192.168.0.0 - 192.168.255.255ポートnumTCP/UDPcontent143IMAP631CUPSのWEBブラウザ設定画面変数commandcontentenv環境変数を表示printenv環境変数を表示setシェル変数と環境変数を表示unset変数を削除envoptioncontent-i何も環境変数が設定されていない状態にする-u 環境変数名環境変数を一時的に削除環境変数名=値環境変数の値を一時的に変更(オプションなし)全ての環境変数を表示setshellのオプションsubcommandcontent-oオプションを有効にする/オプションの一覧を表示+oオプションを無効にするoptioncontent-a, allexport作成・変更した変数を自動的にエクスポートするemacsemacs風のキーバインドにするignoreeofCtrl+Dによってログアウトしないようにする-C, noclobber出力リダイレクトによる上書きを禁止する-f, noglobメタキャラクタを使ったファイル名展開を無効にするvivi風のキーバインドにする-n, noexecシェルスクリプトを読み込むが、実行はせずに構文エラーのみ確認エイリアスcommandcontentaliasエイリアスの設定unaliasエイリアスの解除\\をつけるとエイリアスを使用しないで実行関数commandcontentfunction関数を定義declare -f定義されている関数を表示unset関数を削除bashの設定ファイルfilecontent/etc/profileログイン時に実行され、全ユーザーから参照される/etc/bash.bashrcbash起動時に実行され、全ユーザーから参照される/etc/bashrc~/.bashrcから参照される~/.bash_profileログイン時に実行される~/.bash_login~/.bash_profileがない場合、ログイン時に実行される~/.profile~/.bash_profileも~/.bash_loginもない場合、ログイン時に実行される~/.bashrcbash起動時に実行される~/.bash_logoutログアウト時に実行されるスクリプトシェル変数の特殊変数argcontent$0シェルスクリプトファイル名(フルパス)$11番目の引数$22番目の引数。n番目も同様$#引数の数$@すべての引数(スペース区切り)$*すべての引数(区切りは環境変数IFSで指定されたもの)$$現在のシェルのPID(プロセスID)testtest 条件文[ 条件文 ]conditionresultファイル形式-fファイルがあれば真-dディレクトリがあれば真-rファイルが存在し、かつ読み込み可能であれば真-wファイルが存在し、かつ書き込み可能であれば真-xファイルが存在し、かつ実行可能であれば真-sサイズが0より大きいファイルがあれば真-Lシンボリックリンクであるファイルがあれば真ファイル特性-eファイルがあれば真-ntファイル1がファイル2より修正時刻が新しければ真-otファイル1がファイル2より修正時刻が古ければ真数値-eq数値1と数値2が等しければ真-ge数値1が数値2より大きい、もしくは等しければ真-gt数値1が数値2より大きければ真-le数値1が数値2より小さい、もしくは等しければ真-lt数値1が数値2未満であれば真-ne数値1と数値2が等しくなければ真文字列-n文字列の長さが0より大きければ真-z文字列の長さが0であれば真=2つの文字列が等しければ真!=2つの文字列が等しくなければ真論理結合!条件式が偽であれば真-aAND演算-oOR演算X.Orgの設定ファイル/etc/X11/xorg.confsectioncontentServerLayout入出力デバイスに関する設定FilesRGBカラーデータベースの場所やフォントの格納場所に関する設定Module組み込むモジュールの設定InputDeviceキーボードやマウスなどの入力デバイスの設定Monitorモニタータイプの設定Deviceビデオカードの設定Screenディスプレイの表示色数や画面サイズなどの設定ディスプレイマネージャnamecontentXDMX.Org標準GDMGNOMEで利用されるSDDMKDE Plasmaで利用されるLigthDMUbuntu標準ウィンドウマネージャnamecontenttwm最小限の機能を備えた基本的なウィンドウマネージャFVWM軽快でシンプルEnlightment高度なカスタマイズが可能MetacityGNOME 2の標準MutterGNOME 3の標準Fluxbox軽快でカスタマイズ性が高いWindowMaker簡素で軽量Compiz立体的な画面効果が華々しいKWinKDEの標準リモートデスクトップnamecontentVNCクロスプラットフォーム対応RDPWindows標準SPICERDPと同様の画面転送プロトコル。オープンソースXDMCPディスプレイマネージャをネットワーク越しに利用できるプロトコルXDM設定/etc/X11/xdm ディレクトリ内filecontentxdm-configXDMの設定ファイルXresourcesXDMログイン画面のデザイン設定XaccessホストからXDMへアクセス許可の設定Xsetup_0XDMログイン画面表示前に実行されるスクリプトXsessionXDMのログイン後に実行されるスクリプトキーボードアクセシビリティsettingcontentハイコントラスト視覚障がい者のためにコントラストを強調大きな文字システムの文字を大きく表示カーソルの大きさ大きなカーソルを表示ズームカーソル位置をズームスクリーンリーダーフォーカスのある画面のテキストを音声で読み上げる切り替えキーCapsLockとNumLockのオン・オフが切り替わるとビープ音を鳴らす視覚警告警告音が鳴った時に、画面全体をフラッシュするなど視覚的にも警告スクリーンキーボードマウスで操作するスクリーン上のキーボードリピートキーキーを長押しすると繰り返しキー入力したことにするカーソルの点滅テキスト入力時のカーソル点滅速度を調整タイピング支援(AccessX)スティッキーキー、スローキー、バウンスキーを設定マウスキーテンキーでもマウスカーソルを動かせるようにするクリック支援主ボタンの押しっぱなしを副ボタン押下とみなす等ダブルクリックと認識する間隔ダブルクリックと認識する間隔時間を調整スティッキーキー修飾キーを押されたままの状態にするスローキーキー押下を認識する時間を調整、ビープ音を鳴らす等バウンスキー素早く何度も押したキーを認識しないトグルキーNumLock、CapsLockなどの切り替え時にビープ音を鳴らすuseraddユーザーアカウントを作成するoptioncontent-cコメントフィールドを指定-dホームディレクトリを指定-gプライマリグループを指定-Gプライマリグループ以外に所属するグループを指定-sデフォルトシェルを指定-Dデフォルトの設定値を表示・設定-mホームディレクトリを自動的に設定-p暗号化済みのパスワードを設定usermod既存のユーザーアカウントを変更optioncontent-c, --commentコメントフィールドを変更-d, --homeホームディレクトリを変更-g, --gidプライマリグループを変更-G, --groups所属するグループを変更-sデフォルトシェルを変更-L, --lockパスワードをロックして一時的に無効にする-U, --unlockパスワードのロックを解除する-p, --passwordパスワードを変更userdelユーザーアカウントを削除optioncontent-rホームディレクトリも同時に削除passwdパスワードを変更。スーパーユーザー以外は自分のパスワードのみ変更可能optioncontent-lパスワードをロックして一時的に無効にする-uパスワードのロックを解除するgroupaddグループを作成groupmod既存のグループ情報を変更optioncontent-gGIDを変更-nグループ名を変更groupdelグループを削除chshログインシェルを変更optioncontent-sログインシェルを設定idユーザー情報を表示getent はLDAPサーバーの情報を表示crontabcrantabファイルを編集optioncontent-eエディタを使って編集-lファイルの内容を表示-rファイルを削除-i削除時に確認する-uユーザーを指定して編集(rootのみ)crontabファイルのフィールドfieldcontent分0 ~ 59時0 ~ 23日1 ~ 31月1 ~ 12, jan ~ dec曜日0 ~ 7, Sun ~ Satコマンド実行するコマンドat1回限りの実行スケジュールoptioncontent-d/-r予約中のジョブをジョブ番号指定で削除(=atrm)-l予約中のジョブを表示(=atq)-fコマンドを記述したファイルを指定/etc/at.allow、/etc/at.denyでアクセス制御systemd-runタイマーUnitのスケジューリングlocale現在のロケール設定を確認optioncontent-a設定可能なロケールを表示-m利用できる文字コード一覧iconv文字コードを変換optioncontent-f変換前の文字コードを指定-t変換して出力したい文字コードを指定-l扱える文字コードを表示tzselectタイムゾーンを設定tzconfig/etc/localtimeと/etc/timezoneをまとめて変更hwclockハードウェアクロックを参照・設定optioncontent-rハードウェアクロックを表示-w(--systohc)システムクロックの時刻をハードウェアクロックに設定-s(--hctosys)ハードウェアクロックの時刻をシステムクロックに設定timedatectl日付と時刻・タイムゾーンを管理subcommandcontentstatus現在の時刻を表示set-time日付、時刻を設定(YYYY-MM-DD HH:MM:SS)set-timezoneタイムゾーンを設定list-timezonesタイムゾーンを一覧表示set-ntp yes/noNTPを使うかどうかntpdate指定したNTPサーバーから現在時刻を取得ntpqNTPサーバーの状態を照会chronycchronydを管理subcommandcontentactivityNTPサーバーのオンライン/オフライン数sources時刻ソースの情報を表示sourcestats時刻ソースの統計情報を表示trackingトラッキングを確認quit対話状態を終了loggerログメッセージを生成optioncontent-pプライオリティを設定systemd-catコマンドの実行結果をジャーナルに書き込むwhoログイン中のユーザー一覧wuptime + wholast最近ログインしたユーザーの一覧lastlog/var/log/lastlogファイルを参照し、ユーザーごとの最近のログイン一覧を表示journalctlsystemdのログを閲覧optioncontent-a, --all画面表示できない文字も含めて表示-D, --directory指定したディレクトリのログを表示-f, --followログの末尾を表示し続ける-l, --full画面表示可能なすべてのログを表示-r, --reverseログを新しい順に表示-n, --lines直近のログから指定行数分を表示(デフォルトは10)-eジャーナルの末尾(最新)を表示-x説明文付きで表示-o, --outputログの出力形式を指定-k, --dmesgカーネルメッセージのみ表示-b, --bootブート時のメッセージを表示-p指定したプライオリティより高いメッセージを表示-u, --unit指定したUnitのログを出力--fullエスケープ文字を除いてプレーテキストで出力--no-pager1ページごとに表示せず、すべてのログを出力(lessコマンドを使用しない)--since指定した日付時刻以降のログを表示--unitl指定した日付時刻までのログを表示--vacuum-size=アーカイブジャーナルの総容量が指定したサイズを下回るまで古いジャーナルを削除--vacuum-time=指定した期間より古いアーカイブジャーナルを削除検索条件指定keycontent_PID=プロセス番号の指定_UID=ユーザーIDの指定_SYSTEMD_UNIT=Unit名の指定newaliases/etc/aliasesの設定を有効にするmailqメールキューの内容を表示lprファイルを印刷optioncontent-#部数印刷部数を指定-P印刷を行うプリンタを指定lpqプリントキューの内容を表示optioncontent-Pプリンタを指定lprmプリントキューにある印刷要求を削除optioncontent-Pプリンタを指定-自分の全印刷ジョブを削除nmcliNetwork Managerの管理コマンドobjectcommandcontentgeneralstatusNetworkManagerの状態を表示hostnameホスト名を表示、指定したホスト名に変更networkingon/offネットワークを有効/無効にするconnectivity [check]ネットワークの状態を表示(checkを指定すると再確認)radiowifiWi-Fiの状態を表示wifi on/offWi-Fi接続を有効/無効にするwwanモバイルブロードバンドの状態を表示wwan on/offモバイルブロードバンド接続を有効/無効にするall on/off全ての無線接続を有効/無効にするconnectionshow [--active]接続情報を表示(--activeが指定されればアクティブな接続のみ)modify指定した接続を設定up接続を有効にするdown接続を無効にするdevicestatusデバイスの状態を表示show指定したデバイスの情報を表示modify指定したデバイスを設定connect指定したデバイスを接続disconnect指定したデバイスを切断delete指定したデバイスを削除monitor指定したデバイスをモニタするwifi listWi-Fiアクセスポイントを表示wifi connectWi-Fiアクセスポイントに接続wifi hotspotWi-Fiホットスポットを作成wifi rescanWi-Fiアクセスポイントを再検索nmcli networking connectivitystatuscontentfullインターネットにアクセス可能なネットワークに接続しているportalインターネットにアクセスする前のcaptive portalの状態であるlimitedネットワークに接続しているが、インターネットにアクセスできないnoneどのネットワークにも接続していないunknown接続状態が見つからないhostnamectlホスト名を管理subcommandcontentstatusホスト名と関連情報を表示set-hostnameホスト名を設定pingICMPパケットを送信、反応を表示optioncontent-c指定した回数だけICMPパケットを送信-i指定した間隔(秒)ごとにパケットを送信IPv6ではping6traceroute指定したホストまでパケットが伝わる経路を表示IPv6ではtraceroute6tracepath指定したホストまでパケットが伝わる経路を表示IPv6ではtracepath6hostnameホスト名を表示・変更netstatネットワーク機能に関する様々な情報を表示optioncontent-a全てのソケット情報を表示-c状況を1秒ごとにリアルタイム表示-iネットワークインターフェースの状態を表示-nアドレスやポートを数値で表示-pPIDとプロセス名も表示-rルーティングテーブルを表示-tTCPポートのみ表示-uUDPポートのみ表示ncnetcatoptioncontent-l指定したポートをリッスン-pポート番号を指定-uUDPを利用(デフォルトはTCP)-o指定したファイルに出力routeルーティングテーブルを表示・操作optioncontent-Fカーネルのルーティングテーブルを表示-Cカーネルのルーティングキャッシュを表示subcommandcontentaddルーティングテーブルに新たな経路を追加delルーティングテーブルから経路情報を削除ipネットワークインターフェースやルーティングテーブル、ARPテーブル等を管理targetcontentlinkデータリンク層addrIPアドレスrouteルーティングテーブルsubcommandcontentshow表示add設定ifconfigネットワークインターフェースの状態を表示、設定parametercontentIPアドレスIPアドレスを設定netmask サブネットマスクサブネットマスクを設定upネットワークインターフェースを有効化downネットワークインターフェースを無効化ifup、ifdownhostDNSサーバを使ってホストやドメインに関する情報を表示optioncontent-v詳細情報を表示digDNSサーバに登録されている情報を表示optioncontent-xIPアドレスからホスト名を検索search typecontentaIPアドレスaaaaIPv6アドレスany全ての情報mxメールサーバの情報nsネームサーバの情報ssソケットを調査netstatの後継optioncontent-a全てのソケット情報を表示-nサービス名の名前解決をしない-tTCPポートのみ表示-uUDPポートのみ表示ftpリモートホストとファイルを送受信subcommandcontentgetファイルのダウンロードputファイルのアップロードbye, quit終了lsofoptioncontent-i開いているポートの情報を表示-i:ポート番号指定したポート番号が使われている通信を表示nmapポートスキャンfuserポートを開いているプロセスを特定optioncontent-kプロセスにSIGKILLを送信-mマウントされたファイルシステムを指定-n検索する領域(名前空間)を指定-u検索結果をユーザー名を追加-v詳細な情報を表示chageパスワードに有効期限を設定optioncontent-lパスワードもしくはアカウントの有効期限を表示-mパスワード変更間隔の最低日数を設定-Mパスワードの最大有効期限日数を設定-dパスワードの最終更新日を設定-Wパスワードの有効期限切れの警告が何日前から始まるか設定-Iパスワードの有効期限後にアカウントがロックされるまでの日数-Eユーザーアカウントが無効になる日付を設定su一時的に別ユーザーになるsudoroot権限で実行optioncontent-l許可されているコマンドを表示-i変更先ユーザーでシェルを起動(ログイン時の処理を行う)-s変更先ユーザーでシェルを起動-urootではなく指定したユーザーでコマンドを実行visudosudoの利用設定ulimitユーザーが利用できるリソースを制限optioncontent-a制限の設定値をすべて表示-c生成されるコアファイルのサイズを指定-fシェルが生成できるファイルの最大サイズをブロック単位で指定-n同時に開くことのできるファイルの最大数-u1人のユーザーが利用できる最大プロセス数を指定-vシェルとその子プロセスが利用できる最大仮想メモリサイズsshoptioncontent-pポート番号を指定-l接続するユーザーを指定-i秘密鍵ファイルを指定-ossh_configで設定できるオプションの指定ssh-keygen公開鍵と秘密鍵の鍵ペアを作成optioncontent-t暗号化タイプを指定-pパスフレーズを変更-f鍵ファイルを指定-R指定されたホストの鍵をknown_hostsファイルから削除-b鍵の長さをビット長で指定scpSSHの仕組みを使い、ホスト間で安全にファイルをコピーoptioncontent-pパーミッションなどを保持したままコピー-rディレクトリ内を再帰的にコピー-Pポート番号を指定ssh-agentクライアント側で稼働するsshエージェントssh-add秘密鍵を登録。パスフレーズを入力gpgGnuPGを管理optioncontent--full-generate-key鍵ペアを作成--list-keys鍵ペアを一覧表示-o 失効証明書 --gen-revoke メールアドレス失効証明書を作成--import 失効証明書鍵を無効化-c共通鍵を使用して暗号化--decrypt共通鍵を使用して複合化-o 出力ファイル名 -a --export　メールアドレス公開鍵をエクスポート--import 公開鍵公開鍵をインポート--sign-key受け取った公開鍵に署名-e -a -r 宛先メールアドレス 暗号化するファイルファイルを暗号化-o 署名ファイル --sign 対象ファイルファイルに署名--verifyファイルの署名を検証xinetdスーパーサーバsetting itemcontentbind/interfaceサービスを提供するインターフェースのIPアドレスdisableサービスを無効化するかの設定(yes/no)instancesサーバプログラムの最大起動プロセス数log_typeログの記録先指定(syslogや記録するログファイルの絶対パス)no_accessサービスへのアクセスを拒否する接続元only_fromサービスへのアクセスを許可する接続元serverサーバプログラムの絶対パスserver_argsサーバプログラム起動時に指定する引数socket_typeストリーム型、データグラム型といったサービスの接続タイプuserサーバプログラムを起動するユーザーwaitサーバプログラムへの接続処理を待ち合わせるかの設定","link":"https://qiita.com/kyohmizu/items/d5d6fedc527efa9f649c","isoDate":"2019-10-09T01:56:54.000Z","dateMiliSeconds":1570586214000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"LPIC 101チートシート","contentSnippet":"試験前の確認事項としてまとめた内容です。環境変数namecontentPATHコマンドのパスEDITORデフォルトのエディタHISTFILE履歴ファイルのパスHISTFILESIZE履歴ファイルの保存履歴数LD_LIBRARY_PATH共有ライブラリの検索パスデバイスファイルdevice filecontent/dev/sda1番目のハードディスクドライブ/dev/sdb2番目のハードディスクドライブ/dev/sdc3番目のハードディスクドライブ/dev/sr01番目のCD/DVDドライブ/dev/st01番目のテープドライブファイルシステムfilesystemcontentext2Linuxの標準ファイルシステムext3ext2にジャーナリング機能を追加ext4ext3を機能拡張XFSSGI社が開発したジャーナリングファイルシステムBtrfs高度な機能iso9660CD-ROMudfDVD-ROMディレクトリ・ファイルpathcontent/proc起動中のプロセスやカーネルが認識しているハードウェアの情報が格納されているディレクトリ/proc/modulesロードされているカーネルモジュールの情報/proc/cpuinfoCPUに関する情報/proc/meminfoメモリの使用状況を確認できるファイル/proc/bus/usb/devicesUSBデバイスに関する情報/proc/bus/pci/devicesPCIデバイスに関する情報/proc/interruptsIRQに関する情報/proc/ioportsI/Oポートアドレスの情報/proc/dmaデバイスが使用中のDMAチャンネルに関する情報/proc/scsi/scsiSCSIデバイスに関する情報/proc/cmdlineブートローダからカーネルに渡されたパラメータ/etcシステムの設定ファイルなどが格納されているディレクトリ/etc/inittab/etc/rc[0-6].dSysVinitでランレベルに応じたスクリプトが格納されるディレクトリ/etc/systemd/system//etc/udev/rules.d/(~.rules)udevが使用するデバイス設定情報/etc/modprobe.d/(~.conf)modprobeの設定ファイル/etc/default/grubGRUB2の設定ファイル/etc/grub.dGRUB2の設定ファイルを配置するディレクトリ/etc/ld.so.confldconfigで/etc/ld.so.cacheを作成するために参照/etc/ld.so.cacheプログラムの実行時に共有ライブラリの場所を検索するために使用/etc/dpkg/dpkg.cfgdpkgの設定ファイル/etc/apt/apt/conf.d/aptの設定ファイル/etc/apt/sources.listaptのパッケージ取得元を設定するファイル/etc/yum.confyumの設定ファイル/etc/yum.repos.dyumで使用されるパッケージの取得元を設定するファイルを格納するディレクトリ/etc/machine-idマシンIDが格納されているファイル/etc/fstabファイルシステムのマウント設定を記載するファイル/etc/mtab現在マウントされているファイルシステムの情報が格納されているファイル/var/var/log/messagesカーネルのログが記録されるなど、Linuxでメインで使用されるログファイル/boot/boot/efiESP(EFIシステムパーティション)のマウント先/boot/grub/menu.lstGRUB Legacyの設定ファイル/boot/grub/grub.confGRUB Legacyの設定ファイル/boot/grub/grub.cfgGRUB2の設定ファイル(変更不可)/usr/usr/share/manマニュアルsystemdのユニットunitcontentdevice各種デバイスを管理するUnitmountファイルシステムのマウントを管理するUnitserviceサービスを制御するUnitswapスワップ領域を管理するUnittarget複数のサービスを一つのグループにするためのUnitvicommandcontentZZ保存して終了(:wq):e!最後に保存した内容に復帰:r ファイル名ファイルの内容をカレント行以降に読み込む:!コマンドviを終了せずにシェルコマンドを実行:r!コマンドシェルコマンドの実行結果を挿入dwカーソル位置から次の単語までを削除rカーソル位置の1文字を置換:%s/A/B/最初に見つかった文字列Aを文字列Bに置換:%s/A/B/g全ての文字列Aを文字列Bに置換:set nu (number)行番号を表示:set nonu (nonumber)行番号を非表示:set ts=タブ幅 (tabstop)タブ幅を指定正規表現codecontent.任意の1文字*直前の文字の0回以上の繰り返し[][]内のいずれか1文字(-：範囲、^：除外)^行頭$行末\\次の1文字をエスケープ+直前の文字の1回以上の繰り返し(拡張正規表現)?直前の文字の0回もしくは1回の繰り返し(拡張正規表現)\\dpkg設定ファイル  /etc/dpkg/dpkg.cfgactioncontent-i (--install)インストール-r (--remove)設定ファイルを残してアンインストール-P (--purge)完全にアンインストール-l (--list)インストール済みパッケージを検索-S (--search)ファイルがどのパッケージからインストールされたか表示-L (--listFfiles)指定パッケージからインストールされたファイル一覧を表示-s (--status)パッケージ情報を表示する--configure展開されたパッケージを構成--unpackパッケージを展開(インストールしない)optioncontent-E同バージョンがインストールされていればインストールしない-G新バージョンがインストールされていればインストールしない-R (--recursive)再帰処理apt-getsubcommandcontentcleanパッケージファイルを削除dist-upgradeシステムを最新にアップグレードinstallパッケージをインストールまたはアップグレードremoveパッケージをアンインストールupdateパッケージデータベースを更新upgrade他のパッケージを削除しないものをアップグレードoptioncontent-dファイルをダウンロード(インストールしない)-sシステムを変更せず動作をシミュレートapt-cachesubcommandcontentsearchキーワードを含むパッケージを検索showパッケージの一般的な情報を表示showpkgパッケージの詳細情報を表示dependsパッケージの依存関係を表示apt設定ファイル  /etc/apt/apt/conf.d/ソース  /etc/apt/sources.listsubcommandcontentupdateパッケージリストを更新installパッケージをインストールremove設定ファイルを残してパッケージを削除purgeパッケージを完全に削除upgradeシステムをアップグレード(ファイル削除は行わない)full-upgradeシステムのメジャーバージョンを最新にアップグレードshow指定したパッケージに関する情報を表示listパッケージのリストを表示list --installedインストールされたパッケージを一覧表示list --upgradableアップグレード可能なパッケージを表示search指定したキーワードでパッケージ情報を全文検索dependsパッケージの依存関係を表示autoremove必須とされていないパッケージを自動削除optioncontent-C設定ファイルを指定-dパッケージのダウンロードのみ行う-y自動的にyesを回答--no-install-reccomends必須でない推奨パッケージはインストールしない--install-suggests提案パッケージもインストール--reinstallインストール済みパッケージの再インストールを許可rpm設定ファイル  /usr/lib/rpm/rpmrcoptionsuboptioncontent-i (--install)パッケージをインストール-U (--upgrade)パッケージをアップグレード(なければインストール)-F (--freshen)パッケージがインストールされていればアップグレード-v詳細な情報を表示-h (--hash)進行状況を「#」で表示--nodeps依存関係を無視してインストール--force既存のファイルを新しいものに置き換える--test実際にはインストールせずテスト-e (--erase)パッケージをアンインストール--nodeps依存関係を無視してアンインストール-q指定したパッケージがインストールされているか照会-a (--all)インストール済みのすべてのパッケージを表示-f指定したファイルを含むパッケージ名を表示-p対象としてパッケージファイルを指定-c (--configfiles)設定ファイルのみ表示-d (--docfiles)ドキュメントのみ表示-i (--info)指定したパッケージの情報を表示-l (--list)指定したパッケージに含まれるファイルを表示-R (--requires)指定したパッケージが依存しているファイル等を表示--changelog変更履歴を表示使い方# インストール$ rpm -ivh [パッケージ名]# どのようなファイルがインストールされるか表示$ rpm -qlp [パッケージ名]# 依存関係を調べる$ rpm -qR [パッケージ名]yum設定ファイル  /etc/yum.confパッケージ取得元  /etc/yum.repos.d/subcommandcontentcheck-updateアップデート対象のパッケージリストを表示update指定したパッケージをアップデート(指定しない場合は全パッケージ)install指定したパッケージをインストールremove指定したパッケージをアンインストールinfo指定したパッケージの情報を表示list全パッケージ情報をリスト表示repolistリポジトリ一覧を表示searchパッケージ情報をキーワード検索search allキーワード検索(パッケージ名、説明文等すべて)groups listパッケージグループをリスト表示graoups install指定したグループのパッケージをインストールdnfsubcommandcontentcheck-updateアップデート対象のパッケージリストを表示cleanキャッシュデータを削除upgrade (update)システムの全パッケージをアップグレードupgrade指定したパッケージをアップグレードinstall指定したパッケージをインストールremove指定したパッケージをアンインストールinfo指定したパッケージの情報を表示list全パッケージ情報をリスト表示searchパッケージ情報をキーワード検索history処理の履歴を表示updateinfoパッケージのアップデート情報を表示zypperoptioncontentinstall (in)パッケージのインストールupdate (up)パッケージのアップデートremove (rm)パッケージのアンインストールinfoパッケージの詳細情報の表示search (se)指定したキーワードでパッケージの検索list-updates (lu)アップデート可能なパッケージの表示repos (lr)リポジトリの一覧表示refreshリポジトリの更新mansectioncontent1ユーザーコマンド2システムコール3ライブラリ4デバイスファイル5設定ファイル6ゲーム7その他8システム管理コマンド9Linuxカーネル用ドキュメントcpoptioncontent-fコピー先に同名のファイルがあれば上書きする-iコピー先に同名のファイルがあれば上書きするか確認-pコピー元ファイルの属性を保持-r, -R再帰的にコピー-dシンボリックリンクをシンボリックリンクとしてコピー-aできる限り元ファイルの構成と属性を保持(-dpRと同じ)taroptioncontent-cアーカイブを作成-xアーカイブからファイルを取り出す-tアーカイブの内容を確認-fアーカイブファイル名を指定-zgzipによる圧縮/展開-jbzip2による圧縮/展開-Jxzによる圧縮/展開-v詳細情報を表示-uアーカイブ内にある同名のファイルより新しいものだけを追加-rアーカイブにファイルを追加-N指定した日時より新しいデータのみを対象-M複数デバイスへの分割--deleteアーカイブからファイルを削除使い方# /homeのアーカイブをテープドライブに作成$ tar cvf /dev/st0 /home# アーカイブファイルをカレントディレクトリ上に展開$ tar xvzf software.tar.gzkillsignalIDcontentHUP1ハングアップ(端末が制御不能もしくは切断による終了)INT2キーボードからの割り込みKILL9強制終了TERM15終了(デフォルト)CONT18再開STOP19一時停止killallプロセス名で指定grepoptioncontent-cマッチした行の行数のみ表示-f検索パターンをファイルから読み込む-i大文字と小文字を区別しない-n先頭に行番号をつけて、マッチした行を表示-vマッチしなかった行を表示-E拡張正規表現を使用(egrepコマンドと同様)-F検索パターンを正規表現ではなく、固定文字列とする(fgrepコマンドと同様)typecontentgrep正規表現でパターンマッチegrep拡張正規表現fgrep正規表現を使わないpgrepPIDを表示fdiskパーティションの作成、削除、変更、情報開示などsubcommandcontentlパーティションタイプを一覧表示nパーティションを作成dパーティションを削除pパーティションテーブルを表示tパーティションタイプを変更aブートフラグのON/OFF切り替えwパーティションテーブルの変更を保存して終了qパーティションテーブルの変更を保存しないで終了mヘルプメニューを表示gdiskGPTに対応partedMBR、GPTに対応subcommandcontentcheckファイルシステムの簡単なチェックmklabel [gpt\\msdos]mkpart指定した種類のパーティションを作成rm指定したパーティションを削除print, pパーティションテーブルを表示quit, q終了fsckoptioncontent-tファイルシステムの種類を指定-A「/etc/fstab」に記述されている全ファイルシステムに対して実行-N実際には実行せず、実行する内容だけ表示-a問題を自動的に修復-r問題を対話的に修復e2fsckoptioncontent-y全ての問い合わせに対し、自動的に「yes」と回答-n全ての問い合わせに対し、自動的に「no」と回答-p全ての問題を自動的に修復nicenice [-n nice値] コマンドnice [-nice値] コマンドoptioncontent-nnice値renicerenice [-n] nice値 オプションoptioncontent-u指定したユーザーが所有する全てのプロセスのnice値を変更-p指定したPIDのプロセスのnice値を変更(「-p」は省略可能)sedoptioncontent-e編集コマンドを指定(コマンドが一つの場合は省略可)-f編集コマンドを記述したファイルを指定edit commandcontent/s/文字列1/文字列2/各行の最初に現れる文字列1を文字列2に置換/s/文字列1/文字列2/g全ての文字列1を文字列2に置換/文字列/d文字列が含まれる行を削除行番号1,行番号2d行番号1から行番号2までの行を削除y/文字1文字2/文字3文字4/文字1を文字3に、文字2を文字4に置換cutoptioncontent-c抽出する文字位置を指定-d区切り文字を指定(デフォルトはタブ)-f抽出するフィールドを指定mkdiroptioncontent-m指定したアクセス権でディレクトリを作成-p引数に階層のあるディレクトリを指定した場合、存在しない中間ディレクトリも同時に作成その他ldconfig共有ライブラリのパス構成/etc/ld.so.conf を /etc/ld.co.cache に反映nl行番号をつけて出力odバイナリデータとして出力chown所有者を変更chgrpグループを変更top実行中のプロセス監視freeメモリの利用状況、空き状況uptimeシステムの稼働時間や平均負荷unameシステムアーキテクチャやOSを確認nice, reniceプロセスの優先度を変更(-19~20)lsblkシステムのブロックデバイス一覧blkidデバイスファイルとUUIDの関係(/etc/fstabファイル)locateあらかじめ作成したDBに基づいてファイルを検索updatedbDBを更新設定ファイル  /etc/updatedb.confwhichコマンドの絶対パスを表示typeコマンドの種類を表示","link":"https://qiita.com/kyohmizu/items/923844999018fd456d44","isoDate":"2019-10-09T01:48:33.000Z","dateMiliSeconds":1570585713000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"ArgoCDのApplicationにhelmを使用する","contentSnippet":"はじめにKubernetesのCDツールとしてArgoCDを使用しています。ArgoCDの管理対象(Application)にhelmチャートを指定してみたので、調べた内容をまとめました。参考：ArgoCD - Declarative Setup クイックリファレンス動作環境Azure Kubernetes Service(AKS)ArgoCD v1.1.1yaml記述例Applicationにはhelm公式のnginx ingressを使用しています。argocd-app-nginx-ingress.yamlapiVersion: argoproj.io/v1alpha1kind: Applicationmetadata:  name: nginx-ingress  namespace: argocdspec:  project: default  source:    repoURL: https://github.com/helm/charts.git    targetRevision: 0ef8d0d9033417d17d2872f32c97b7f999f9eb8f    path: stable/nginx-ingress    helm:      parameters:      - name: \"controller.replicaCount\"        value: \"2\"      releaseName: nginx-ingress      valueFiles:      - https://raw.githubusercontent.com/user/sample/values-nginx.yaml  destination:    server: https://kubernetes.default.svc    namespace: default  syncPolicy:    automated:      prune: true  ignoreDifferences:  - group: \"\"    kind: Service    jsonPointers:    - /spec/clusterIPArgoCDが動作しているクラスタに対し、上記リソースを作成すればApplicationを管理できます。$ kubectl apply -f argocd-app-nginx-ingress.yaml設定(spec.source)repoURLhelmを含むリポジトリのURL。targetRevision管理対象リビジョン。HEADやコミットハッシュを指定します。HEADを指定すれば、リポジトリへのコミット時に自動的にKubernetesリソースを更新します。pathリポジトリ内のhelmチャートを含むディレクトリパス。helmreleaseNamehelmに指定するリリース名。parametersnameで指定したhelmの設定項目をvalueで上書きします。values.yamlでの設定と同じですが、values.yamlよりも優先されます。valueFileshelmに適用するvalues.yamlをURLで指定。補足spec.ignoreDifferencesArgoCDで同期したくない項目を指定します。kind、groupにはKubernetesリソースの種類を、jsonPointersには対象項目を指定します。実際はhelm template内部では以下のようなコマンドを実行してマニフェストを作成しています。$ helm template -n {helm.releaseName} --set {helm.parameters[0].name}={helm.parameters[0].value}... -f {helm.valueFiles[0]}...","link":"https://qiita.com/kyohmizu/items/118bf654d0288da2294e","isoDate":"2019-09-06T02:09:56.000Z","dateMiliSeconds":1567735796000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"Azure VMの作成からDockerの実行環境構築まで","contentSnippet":"はじめに※超初心者向け社内教育用に作成したドキュメントです。（以前投稿した記事のAzure版）パブリッククラウドもDockerも触ったことがない人を対象にしています。準備するもの作業マシン（Windowsを使用しました）AzureアカウントAzure VMの作成AzureポータルからVMインスタンスを作成します。Addをクリック。作成画面が表示されます。入力、変更項目は以下の通りです。Resource group：VMを作成するリソースグループを選択。新規作成もできますVM name：VMの名前Region：VMを作成するリージョン。何でもいいですが、今回はJapan Eastを選択Image：VMのOSイメージ。今回はUbuntuベースのコマンドを使用するので、デフォルトのUbuntu Server 18.04 LTSを選択Size：VMのスペック。デフォルトのは高いのでグレードを落としていますAuthentication type：ユーザー名、SSHのパブリックキーを設定します。SSHキーがない場合は、こちらを参考に作成してくださいINBOUND PORT RULES：INBOUNDポートを選択。SSHのみで大丈夫ですが、サービスを公開する等の場合はHTTPやHTTPSも選択する必要がありますMonitoring：モニタリングはOffにしました。VMの監視を行いたい場合はOnにしてくださいAzure Active Directory：AADでのログインに対応します。SSHキーは一つしか設定できないので、別マシンからVMにアクセスしたい場合はOnにすると良いですAuto-shutdown：VMを自動で停止する設定。VMの停止忘れで課金が発生するのを防げますあとはバリデーションに成功することを確認し、作成を実行して数分待ちます。VMが作成されました。VMのOverviewから、Connectをクリック。右側に表示される画面から、ローカルアカウントで接続するコマンドをコピーします。シェルを起動し、コピーしたコマンドを貼り付けて実行すればVMに接続できます。※コマンドプロンプトはデフォルトではSSH接続できないので、PowershellかGit Bashを使用すると良いです。※AADで接続する場合は、こちらの手順2以降を行ってくださいDockerの環境構築インストール以下の2つの方法で、Dockerをインストールできます。パッケージ管理ツールを使用Ubuntuのパッケージ管理ツールaptを使用してインストールできます。$ sudo apt update$ sudo apt install docker.io公式サイトからダウンロードUbuntu用の公式サイトはこちら。いくつかの方法が記載されていますが、スクリプトで実行するのが楽です。※インターネットからダウンロードしたスクリプトは、実行前に必ず確認を行いましょう$ curl -fsSL https://get.docker.com -o get-docker.sh$ sudo sh get-docker.shインストールの確認バージョンが確認できればOKです。$ sudo docker versionClient: Docker Engine - Community Version:           19.03.1 API version:       1.40 Go version:        go1.12.5 Git commit:        74b1e89 Built:             Thu Jul 25 21:21:05 2019 OS/Arch:           linux/amd64 Experimental:      falseServer: Docker Engine - Community Engine:  Version:          19.03.1  API version:      1.40 (minimum version 1.12)  Go version:       go1.12.5  Git commit:       74b1e89  Built:            Thu Jul 25 21:19:41 2019  OS/Arch:          linux/amd64  Experimental:     false containerd:  Version:          1.2.6  GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb runc:  Version:          1.0.0-rc8  GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f docker-init:  Version:          0.18.0  GitCommit:        fec3683Dockerコンテナを起動してみます。$ sudo docker container run hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-world1b930d010525: Pull completeDigest: sha256:6540fc08ee6e6b7b63468dc3317e3303aae178cb8a45ed3123180328bcc1d20fStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.（以下略）Dockerの実行にはroot権限が必要です。以下のようにsudoをつけずに実行することもできますが、コンテナにホスト側のroot権限を与えてしまうため注意が必要です。$ sudo usermod -aG docker $USER（再ログイン）$ docker container run hello-worldWarning:Adding a user to the “docker” group grants them the ability to run containers which can be used to obtain root privileges on the Docker host. Refer to Docker Daemon Attack Surface for more information.","link":"https://qiita.com/kyohmizu/items/7bc0bec96cc4664473eb","isoDate":"2019-08-01T02:42:59.000Z","dateMiliSeconds":1564627379000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"Azure Key Vault で AKS の secret を管理する","contentSnippet":"Kubernetes の secret リソースの保管先として、Azure Key Vault を使用してみたので手順を残しておきます。前提事前準備として、AKS 上に Kubernetes クラスタを作成しておきます。$ kubectl get nodeNAME                     STATUS   ROLES   AGE   VERSIONaks-default-09796230-0   Ready    agent   23h   v1.12.8aks-default-09796230-1   Ready    agent   23h   v1.12.8手順Azure Key Vault にデータを追加Key Vault FlexVolume を有効化secret を使用する Pod をデプロイ1. Azure Key Vault にデータを追加Azure ポータル上で操作します。https://docs.microsoft.com/en-us/azure/key-vault/quick-create-portalKey vaultsリソースを検索し、左上の「追加」をクリック。必要項目を入力して Key Vault を作成。名前はユニークなものにしないといけないようです。作成が完了したらデータを登録します。左の項目の中からSecretsを選択し、「作成」をクリック。以下の内容で secret を作成します。Name:testValue：secretdataこのデータを Pod 上にマウントします。2. Key Vault FlexVolume を有効化GitHub の README に沿ってコマンド操作していきます。https://github.com/Azure/kubernetes-keyvault-flexvolKey Vault FlexVolume をインストール作成済みの Kubernetes クラスタに Key Vault FlexVolume をデプロイします。$ kubectl create -f https://raw.githubusercontent.com/Azure/kubernetes-keyvault-flexvol/master/deployment/kv-flexvol-installer.yaml作成が完了すると、クラスタ上の各ノードに Pod が配置されます。$ kubectl get po -n kvNAME                        READY   STATUS    RESTARTS   AGEkeyvault-flexvolume-nsn6s   1/1     Running   0          23hkeyvault-flexvolume-xh64w   1/1     Running   0          23hサービスプリンシパルを設定サービスプリンシパルの情報を、secret としてクラスタに追加します。※サービスプリンシパルの追加については以下のリンクを参照https://docs.microsoft.com/en-us/cli/azure/create-an-azure-service-principal-azure-cli$ kubectl create secret generic kvcreds --from-literal clientid=\u003cCLIENTID\u003e --from-literal clientsecret=\u003cCLIENTSECRET\u003e --type=azure/kvKey Vault にアクセスするため、サービスプリンシパルにロールの割り当てを行います。\u003cprincipalid\u003eと\u003cYOUR SPN CLIENT ID\u003eは、上の\u003cCLIENTID\u003eと同じ値で大丈夫でした。\u003cresourcegroup\u003e、\u003ckeyvaultname\u003eには Key Vault 作成時の値を入力します。az role assignment create --role Reader --assignee \u003cprincipalid\u003e --scope /subscriptions/\u003csubscriptionid\u003e/resourcegroups/\u003cresourcegroup\u003e/providers/Microsoft.KeyVault/vaults/\u003ckeyvaultname\u003eaz keyvault set-policy -n $KV_NAME --key-permissions get --spn \u003cYOUR SPN CLIENT ID\u003eaz keyvault set-policy -n $KV_NAME --secret-permissions get --spn \u003cYOUR SPN CLIENT ID\u003eaz keyvault set-policy -n $KV_NAME --certificate-permissions get --spn \u003cYOUR SPN CLIENT ID\u003e3. secret を使用する Pod をデプロイGitHub のサンプルコードを修正してマニフェストを作成します。test-pod.yamlapiVersion: v1kind: Podmetadata:  name: nginx-flex-kvspec:  containers:  - name: nginx-flex-kv    image: nginx    volumeMounts:    - name: test      mountPath: /kvmnt      readOnly: true  volumes:  - name: test    flexVolume:      driver: \"azure/kv\"      secretRef:        name: kvcreds      options:        usepodidentity: \"false\"        keyvaultname: \"testkeyvault-aks\"        keyvaultobjectnames: test        keyvaultobjecttypes: secret        resourcegroup: \"testresourcegroup\"        subscriptionid: \"\"        tenantid: \"\"subscriptionidとtenantidを環境に合わせて設定します。tenantidはリンクを参考に取得してください。https://stackoverflow.com/questions/26384034/how-to-get-the-azure-account-tenant-idマニフェストを使用して Pod をデプロイします。$ kubectl apply -f test-pod.yaml$ kubectl get poNAME                                                  READY   STATUS    RESTARTS   AGEnginx-flex-kv                                         1/1     Running   0         5h25msecret を確認Pod 上で secret を取得してみます。マウント先は/kvmnt/testになります。$ kubectl exec -it nginx-flex-kv cat /kvmnt/testsecretdataおまけマウント先のファイル名は、flexVolume のオプションにkeyvaultobjectaliases:をつけることで変更できます。test-pod.yaml(一部)    flexVolume:      options:        keyvaultobjectnames: test        keyvaultobjectaliases: \"secret.json\"上のようにエイリアスを設定すると、secret.jsonファイルにマウントされます。$ kubectl exec -it nginx-flex-kv cat /kvmnt/secret.jsonsecretdata","link":"https://qiita.com/kyohmizu/items/9cedf39c70445a7da58e","isoDate":"2019-07-04T12:15:58.000Z","dateMiliSeconds":1562242558000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"de:code 2019 参加レポート","contentSnippet":"Microsoft主催のテクニカルカンファレンス「de:code 2019」に参加してきました。www.microsoft.com参加セッション1日目コンテナ技術を中心にセッションを選択【KN01】基調講演【CD06】しくみがわかる Azure Kubernetes Service (AKS) ～開発者目線で Kubernetes の基本を理解する～【CD01】Windows Containers と Azure による、既存 .NET アプリケーションのモダナイゼーション【CD91】HashiCorp Terraform Azure Provider チュートリアル【CD12】マネージド Kubernetes ガチ本番運用 in ZOZOTOWNwww.youtube.com2日目コンテナ・セキュリティのセッションを選択【SE07】脆弱性はなぜ生まれ、どのように攻撃されるのか? 安全なアプリを開発、運用するためのきほん【CD93】コンテナ環境の永続化ストレージ問題を NetApp Kubernetes Service と Azure NetApp Files でさらっと解決【CM12】.NET Core マルチ プラットフォームの本質【SE05】もうセキュリティはやりたくない!! 第 3 弾 ～Azure Sentinel Deep Dive～注目技術参加したセッションの中で、特に印象に残った or 関心のある技術を取り上げます。Azure Kubernetes Service(AKS)Azureのマネージド Kubernetes サービスである AKS ですが、導入事例が増えてきているそうです。ノロジーズをはじめ、いくつかの企業が自社の導入について講演していました。Kubernetes に概要や操作に関しては特筆することはありませんでしたが、Azure関連の技術として以下に興味を持ちました。Kubernetes-based Event-driven Autoscaling(KEDA)Microsoft と Red Hatが共同作成したプロジェクト。イベント駆動でコンテナのオートスケールを実現します。GitHub - kedacore/keda: KEDA is a Kubernetes-based Event Driven Autoscaling component. It provides event driven scale for any container running in KubernetesVirtual Kubeletkubelet のように動作し、Kubernetes と他のAPIを接続する役割を果たすもの。VM と同じように Kubernetes クラスタで一元管理できます。GitHub - virtual-kubelet/virtual-kubelet: Virtual Kubelet is an open source Kubernetes kubelet implementation.Windows コンテナサポートWindows Server Node が、Kubernetes クラスタで Linux Node と同時に管理できるようになりました。AKS では Multiple Node Pool を使用することで Windows Server Node を作成できます。チュートリアルを試しましたが、なぜかクラスタ作成に失敗)Windows containers now supported in Kubernetes - Open Source blogAzure NetApp FilesNetApp 社の高速ストレージサービス。SSD 並みの速度が出るそうで、Kubernetes の永続化ボリュームとして有用だと思います。また NetApp Kubernetes Service という Kubernetes 管理サービスも提供しているようです。(Rancher みたいなもの？)Azure NetApp Files documentation | Microsoft DocsAzure SentinelAI を使用した高機能なセキュリティサービス。Azure Sentinel | Microsoft Azureその他Azure DevOpsAzure PiplineApp ServiceService FabricWSL2感想Azureに関連したテーマのセッションがほとんどでした。クラウドサービスは以前に比べ使いやすくなっていて、機能も充実してきた印象です。AKS、AzureADの動向は今後も注目していこうと思います。LT資料社内勉強会で de:code の recap を発表しました。    Recap of de code 2019  from Kyohei Mizumoto www.slideshare.netおまけ2日間のお昼のお弁当です。1日目2日目","link":"https://kyohmizu.hatenablog.com/entry/2019/06/06/111805","isoDate":"2019-06-06T02:18:05.000Z","dateMiliSeconds":1559787485000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"Kubernetesリンク集","contentSnippet":"Kubernetes関連の役立つリンクを記載します。公式リファレンスReference - KubernetesKubectl Reference DocsPhippy and Friends - Cloud Native Computing FoundationGitHubGitHub - kubernetes/kubernetes: Production-Grade Container Scheduling and ManagementGitHub - kelseyhightower/kubernetes-the-hard-way: Bootstrap Kubernetes the hard way on Google Cloud Platform. No scripts.GitHub - jamiehannaford/what-happens-when-k8s: 🤔 What happens when I type kubectl run?プロダクトGoogle Kubernetes Engine documentation  |  Kubernetes Engine  |  Google CloudAzure Kubernetes Service (AKS) Documentation - Tutorials, API Reference | Microsoft DocsWhat Is Amazon EKS? - Amazon EKSDocumentation | Rancher LabsK3s: Kightweight KubernetesPivotal Container Service (PKS) | Pivotalスライド、ブログ等Kubernetes のソースコードとの付き合い方 #gounco / Kubernetes source code reading - Speaker DeckKubernetes Patterns : Capacity PlanningKubeWeekly - QiitaKubernetesのユーザー管理と認証・権限確認機構を理解しよう | さくらのナレッジ書籍Kubernetes完全ガイド - インプレスブックス","link":"https://kyohmizu.hatenablog.com/entry/2019/05/28/115504","isoDate":"2019-05-28T02:55:04.000Z","dateMiliSeconds":1559012104000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"【20日チャレンジ】LinuxコマンドをGoで実装","contentSnippet":"Go言語の学習のため、LinuxコマンドをGoで実装します。\r目的\r\rGo言語に慣れる\r標準パッケージの機能、使い方を知る\r\rルール\r以下のルールでチャレンジを行います。\r\r1日1コマンドを実装する\r最低限、コマンドの基本的な動作(オプションなしの実行など)を行えるようにする\r余裕があれば追加機能を実装する\rコマンド名は\"my\" + \"Linuxコマンド名\"とする\r極力標準パッケージを使用する\r\rソースコード\rソースコードはGithubで管理します。\rhttps://github.com/kyohmizu/go-cli-tools\rスケジュール\r\r\r\rNo\r日付\rコマンド\r基本実装\rオプション\r学習内容\r\r\r1\r5/23\rmyls\r〇\r \r\rディレクトリ操作\rエラー処理 \r\r\r\r2\r5/24\rmycp\r〇\r△\rファイル操作\r\r\r3\r5/25\rmymv\r〇\r△\r \r\r\r4\r5/26\rmyrm\r〇\r△\r \r\r\r5\r5/27\rmycat\r〇\r△\r \r\r\r6\r5/28\rmycurl\r〇\r△\r\rhttp接続の実装\rオプションの複数回指定\r\r\r\r7\r5/29\rmypwd\r〇\r△\r OSによる条件分岐\r\r\r8\r5/30\rmytouch\r〇\r△\rbuild tagの設定 \r\r\r9\r5/31\rmymkdir\r〇\r△\r ファイルの操作権限\r\r\r10\r6/1\rmykill\r〇\r〇\rプロセスとシグナル \r\r\r11\r6/2\rmyecho\r〇\r-\r引数の取得\r\r\r12\r6/3\rmytime\r△\r-\r\rコマンド実行\rtimeの操作\r\r\r\r13\r6/4\rmychmod\r△\r-\r\rbit演算\rファイルの権限\r\r\r\r14\r6/5\rmyyes\r〇\r〇\r \r\r\r15\r6/6\rmyenv\r〇\r△\r\rwindowsで確認不可\r\r\r\r16\r6/7\rmychown\r〇\r△\r\ruser,group操作\rwindowsで確認不可\r\r\r\r17\r6/8\rmygrep\r〇\r△\r\rgrepの操作\rgoの正規表現\r\r\r\r18\r6/9\rmysleep\r〇\r△\r \r\r\r19\r6/10\rmymkdir\r〇\r△\r \r\r\r20\r6/11\rmyln\r〇\r△\rリンクの操作\r\r\r\r \r成果\r\rGoの構文や記法に慣れてきた\rGo標準パッケージの使い方、調べ方を覚えた\rLinuxコマンドの動作を知ることができた \r\r感想\r20日も書けば、ある程度書けるようになることがわかりました。\r普段使用するC#とGoが似ている点も覚えやすかったのだと思います。\r次はGoでAPIを作成してみようと考えています。","link":"https://kyohmizu.hatenablog.com/entry/2019/05/23/172119","isoDate":"2019-05-23T08:21:19.000Z","dateMiliSeconds":1558599679000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"Azure AD認証を使用して、Azure仮想マシン(Linux)にSSH接続する","contentSnippet":"はじめにAzure仮想マシンにはSSH接続用の公開鍵は一つしか設定できないため、複数マシンからの接続は困難です。(公開鍵の再設定はできるが、毎回行うのは面倒)Azure AD認証を使用することで、環境を選ばず接続することができます。用意するものAzure仮想マシン(Linux)手順拡張機能をインストールするロールを割り当てるSSH接続を行う1. 拡張機能をインストールするCloud Shellを開きます。リソースグループと仮想マシンを指定し、Azure ADでの接続に必要な拡張機能をインストールします。リソースグループ：myResourceGroup仮想マシン：myVM$ az vm extension set \\    --publisher Microsoft.Azure.ActiveDirectory.LinuxSSH \\    --name AADLoginForLinux \\    --resource-group myResourceGroup \\    --vm-name myVM2. ロールを割り当てるAzureアカウントに仮想マシン接続用のロールを割り当てます。接続に関するロールは以下の二つです。Virtual Machine Administrator Login(管理者権限)Virtual Machine User Login(ユーザー権限)# アカウント名、仮想マシンIDを変数に設定$ username=$(az account show --query user.name --output tsv)$ vm=$(az vm show --resource-group myResourceGroup --name myVM --query id -o tsv)# ロールの割り当て$ az role assignment create \\    --role \"Virtual Machine Administrator Login\" \\    --assignee $username \\    --scope $vmロールの割り当てはポータル上でも行えます。3. SSH接続を行うポータル上で仮想マシンのリソースを表示し、接続を選択します。Azure ADでの接続用コマンドが表示されるので、コピーしてCLIでコマンドを実行します。~$ ssh azureuser@azure.com@13.71.141.35To sign in, use a web browser to open the page https://microsoft.com/devicelogin and enter the code GZ3KVMCHK to authenticate. Press ENTER when ready.表示されたURL(https://microsoft.com/devicelogin)にブラウザでアクセスし、コードを入力します。指定したアカウントでサインインし、CLIに戻ってENTERを押せば接続完了です。新規に仮想マシンを作成する場合(ポータル)「Ubuntu Server」のマシンでは、Azure ADで接続する機能(プレビュー版)を選択できます。この機能を有効にすることで上記手順1が不要となり、ロールの割り当てのみ行うことでSSH接続が可能になります。補足仮想マシンはデフォルトでは全てのポートが閉じているため、SSHのポート(22)を開放する必要があります。参考サイト","link":"https://qiita.com/kyohmizu/items/d0cf760e000aa2a20710","isoDate":"2019-05-23T05:14:55.000Z","dateMiliSeconds":1558588495000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"Rancher2.0でAKSクラスタ作成からWordPressデプロイまで","contentSnippet":"Rancher2.0 を利用してAKSにkubernetesクラスタを作成、Rancherのカタログ機能からWordPressをデプロイしてみました。Azure上でのAKSの操作は、ポータルではなくコマンドベースで行っています。TL;DR完全上位互換のスライドがあるので、こちらを読めば大丈夫です。GUIベースで操作も簡単だと思います。デプロイが終わった後に知り、先に読んでおけばよかったと後悔しました。環境Rancher Serverを事前に用意し、クラスタを構築できる状態にしておきます。バージョンは Rancher2.0 v2.2.2 を使用しました。Azure側の準備Rancher を利用したクラスタ作成に必要な準備を行います。リソースグループの作成AKSクラスタ用のリソースグループを作成します。名前はrancher-aks-sampleにしました。$ az group create -l japaneast -n rancher-aks-sampleサービスプリンシパルの作成リソースグループを操作するためのサービスプリンシパルを作成します。表示されるappIdなどの情報は、Rancher でクラスタを作成する際に必要になります。$ az ad sp create-for-rbac --skip-assignment -n sp-aks-sampleappId: 03f94503-xxxx-xxxx-xxxx-xxxxxxxxxxxxdisplayName: sp-aks-samplename: http://sp-aks-samplepassword: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxtenant: 2bdec7af-xxxx-xxxx-xxxx-xxxxxxxxxxxx// ロールの割り当て$ az role assignment create --assignee 03f94503-xxxx-xxxx-xxxx-xxxxxxxxxxxx \\  --role Contributor --resource-group rancher-aks-sampleリソースプロバイダの登録これがないとクラスタ作成時にエラーが発生します。トラブルシューティングを参考にしました。$ az provider register -n Microsoft.OperationalInsights$ az provider register -n Microsoft.OperationsManagementAKSクラスタの作成Rancher ポータル上でAKSクラスタを作成します。Add Cluster でAzure AKSを選択。Azureとのアクセスに必要な情報を設定します。Client IDはサービスプリンシパルのappId、Client secretはパスワードの値を設定します。実行するとクラスタが作成されます。しかし未対応の問題があり、Control ManagerとSchedulerが正常な状態になっていません。とりあえずアプリケーションのデプロイに問題はないようです。AKSのIssueRancherのIssueWordPress のデプロイCatalog を使用してデプロイを行います。（一部画像の対象クラスタが異なりますが、AKSクラスタに読み替えてください）カタログからデプロイカタログで WordPress を選択します。L7 LoadBalancer の作成をOFFにし、パスワードを設定して実行します。LoadBalancer をデプロイAKS用の L7 LoadBalancer は Rancher がサポートしていないため、Azure上で作成する必要があります。Azure CloudShell を起動し、Helmを有効にします。// Tiller のサービスアカウントを作成$ kubectl create serviceaccount --namespace kube-system tiller$ kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller$ kubectl patch deploy --namespace kube-system tiller-deploy -p '{\"spec\":{\"template\":{\"spec\":{\"serviceAccount\":\"tiller\"}}}}'// Helm の初期化$ helm initHelm を使用して Ingress Controller を作成します。$ helm install stable/nginx-ingress WordPress 用の Ingress を以下のマニフェストファイルから作成します。wordpress-ingress.yamlapiVersion: extensions/v1beta1kind: Ingressmetadata:  name: wordpress-ingress  annotations:    kubernetes.io/ingress.class: nginx    nginx.ingress.kubernetes.io/ssl-redirect: \"false\"    nginx.ingress.kubernetes.io/rewrite-target: /spec:  rules:  - http:      paths:      - path: /        backend:          serviceName: wordpress-wordpress          servicePort: 80$ kubectl apply -f wordpress-ingress.yamlこれで LoadBalancer の公開IPから WordPress にアクセスできるようになりました。参考マルチクラウド時代の最強コンビ　RancherによるKubernetes活用ガイドRancher 2.x 公式ドキュメントRancher2.0 v2.0.0でGKEにkubernetesクラスタ構築からWordPressデプロイまで","link":"https://qiita.com/kyohmizu/items/bfe1763b4cefa69718cf","isoDate":"2019-04-26T09:44:54.000Z","dateMiliSeconds":1556271894000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"fluentd-gcp-scaler コードリーディング","contentSnippet":"はじめにGKEで Fluentd について調べていたところ、fluentd-gcp-scaler というリソースがありました。$ kubectl get po -n kube-system | grep fluentdfluentd-gcp-scaler-8b674f786-k8989                 1/1       Running   0          2mfluentd-gcp-v3.2.0-2rszh                           2/2       Running   0          2mfluentd-gcp-v3.2.0-klv6r                           2/2       Running   0          2mfluentd-gcp-v3.2.0-z65k7                           2/2       Running   0          2m気になって GitHub のソースコードを読んでみたので、内容をまとめます。構成fluentd-gcp-scaler は以下の4つのファイルで構成されています。DockerFileMakefileexample-deployment.yamlscaler.shDockerFilefluentd-gcp-scaler のイメージ用 DockerFile。コンテナ内で次の処理を行います。curl のインストールcurl を使用した kubectl のインストールcurl の削除scaler.sh の配置MakefileDocker イメージのビルド＆プッシュを行います。記載時点のバージョンは0.5.1example-deployment.yamlfluentd-gcp-scaler のデプロイ用マニフェストファイルのサンプル。デプロイしたコンテナに対して、以下の処理を行います。環境変数の設定$ CPU_REQUEST=100m$ MEMORY_REQUEST=200Mi$ MEMORY_LIMIT=300Miスクリプトの実行scaler.sh をオプション付きで実行。$ /scaler.sh --ds-name fluentd-gcp-v2.0.13 --scaling-policy fluentd-gcp-scaling-policyscaler.shfluentd-gcp-scaling-policy の本体となるshellスクリプト。機能ごとにコードを見ていきます。変数の定義SLEEP_SECONDS=${SLEEP_SECONDS:-60}NAMESPACE=${NAMESPACE:-kube-system}DEFAULT_CPU_REQUEST=${CPU_REQUEST:-}DEFAULT_MEMORY_REQUEST=${MEMORY_REQUEST:-}DEFAULT_CPU_LIMIT=${CPU_LIMIT:-}DEFAULT_MEMORY_LIMIT=${MEMORY_LIMIT:-}パラメータのチェックwhile test $# -gt 0; do  case \"$1\" in    --ds-name=*)      export DS_NAME=$(echo $1 | sed -e 's/^[^=]*=//g')      if [ -z ${DS_NAME} ]; then        log \"Missing DaemonSet name in --ds-name flag.\" \u003e\u00262        exit 1      fi      shift      ;;    --scaling-policy=*)      export SCALING_POLICY=$(echo $1 | sed -e 's/^[^=]*=//g')      if [ -z ${SCALING_POLICY} ]; then        log \"Missing ScalingPolicy name in --scaling-policy flag.\" \u003e\u00262        exit 1      fi      shift      ;;    *)      log \"Unrecognized argument $1.\" \u003e\u00262      exit 1      ;;  esacdonetestコマンドでパラメータ数をカウントし、パラメータが存在する場合は次の操作を行います。オプションがds-nameの時、環境変数DS_NAMEに設定設定したDS_NAMEが空の場合はエラーを出力し終了オプションがscaling-policyの場合、環境変数SCALING_POLICYに設定設定したSCALING_POLICYが空の場合はエラーを出力し終了それ以外の場合はエラーを出力し終了ロジックとしては「第1パラメータを判定 → shiftコマンドで次のパラメータにシフト」を繰り返します。if [ -z ${DS_NAME} ]; then  log \"DaemonSet name has to be set via --ds-name flag.\" \u003e\u00262  exit 1fiif [ -z ${SCALING_POLICY} ]; then  log \"ScalingPolicy name has to be set via --scaling-policy flag.\" \u003e\u00262  exit 1fi環境変数DS_NAME、SCALING_POLICYが空の場合はエラーを出力し処理を終了します。オプションにds-name、scaling-policyのいずれかが存在しない場合はエラーとなります。メイン処理while truedo  reset_to_defaults  apply_scaling  build_flags  update_if_needed  sleep ${SLEEP_SECONDS}doneSLEEP_SECONDSのインターバルでループ処理を実行します。（デフォルトは60秒）ループ内では4つの関数を順に呼び出しています。reset_to_defaults()reset_to_defaults() {  REQUESTS_FLAG=  LIMITS_FLAG=  CPU_REQUEST=${DEFAULT_CPU_REQUEST}  MEMORY_REQUEST=${DEFAULT_MEMORY_REQUEST}  CPU_LIMIT=${DEFAULT_CPU_LIMIT}  MEMORY_LIMIT=${DEFAULT_MEMORY_LIMIT}}フラグ値を空にし、変数にデフォルト値を設定。apply_scaling()apply_scaling() {  # This is assuming there is a ScalingPolicy installed in the cluster.  # See https://github.com/justinsb/scaler for more details.  if ! kubectl get scalingpolicies -n ${NAMESPACE} ${SCALING_POLICY} 2\u003e /dev/null  then    return  fi  for resource_class in request limit  do    for resource_type in cpu memory    do      TMP=$(kubectl get scalingpolicies -n ${NAMESPACE} ${SCALING_POLICY} \\        -o=jsonpath=\"{.spec.containers[?(@.name=='fluentd-gcp')].resources.${resource_class}s[?(@.resource=='${resource_type}')].base}\")      if [ ${TMP} ]; then        # Build the right variable name from resource_type and resource_class        # and assign it.        export $(echo ${resource_type}_${resource_class} | awk '{print toupper($0)}')=${TMP}      fi    done  done}ScalingPolicy リソースから取得した値を、以下の変数に設定します。CPU_REQUESTCPU_LIMITMEMORY_REQUESTMEMORY_LIMITresource_class(request, limit)とresource_type(cpu, memory)の二重ループ処理で変数名を生成しています。ScalingPolicy が存在しない場合は何も行いません。ScalingPolicy(イメージ)# ScalingPolicy にはCPU、メモリの条件が設定されているspec:  containers:    - name: fluentd-gcp      resources:        - requests:          - resource: cpu            base: 500m          - resource: memory            base: 512Mi        - limits:          - resource: cpu            base: 1000m          - resource: memory            base: 1024Mibuild_flags()build_flags() {  add_request cpu ${CPU_REQUEST}  add_request memory ${MEMORY_REQUEST}  add_limit cpu ${CPU_LIMIT}  add_limit memory ${MEMORY_LIMIT}}apply_scaling()で設定した環境変数を使用し、以下の変数に値を設定します。REQUESTS_FLAGLIMITS_FLAG関数add_request()とadd_limit()はそれぞれの変数に値を追加していきます。REQUESTS_FLAG=--requests=cup=500m,memory=512MiLIMITS_FLAG=--limits=cup=1000m,memory=1024Miupdate_if_needed()update_if_needed() {  NEED_UPDATE=false  if needs_update requests.cpu ${CPU_REQUEST}; then NEED_UPDATE=true; fi  if needs_update requests.memory ${MEMORY_REQUEST}; then NEED_UPDATE=true; fi  if needs_update limits.cpu ${CPU_LIMIT}; then NEED_UPDATE=true; fi  if needs_update limits.memory ${MEMORY_LIMIT}; then NEED_UPDATE=true; fi  if ! ${NEED_UPDATE}  then    return  fi  if [ ${REQUESTS_FLAG} ] || [ ${LIMITS_FLAG} ]  then    KUBECTL_CMD=\"kubectl set resources -n ${NAMESPACE} ds ${DS_NAME} -c fluentd-gcp ${REQUESTS_FLAG} ${LIMITS_FLAG}\"    log \"Running: ${KUBECTL_CMD}\"    ${KUBECTL_CMD}  fi}関数needs_update()でDaemonSet の現在のCPU、メモリ設定値ScalingPolicy によるCPU、メモリ要求値を比較し、差異がある場合にアップデートを行います。アップデートにはkubectlコマンドを使用します。# コマンド例kubectl set resources -n kube-system ds fluentd-gcp-v2.0.13 -c fluentd-gcp \\--requests=cup=500m,memory=512Mi --limits=cup=1000m,memory=1024Miコマンドリファレンスコマンド意味[ 文字列 ]文字列の長さが0より大きければTrue[ -z 文字列 ]文字列の長さが0であればTrue$#パラメータ数$0実行プログラム\\$1 ~ $9プログラムに渡したパラメータ\u003e\u00262標準エラー出力2\u003e /dev/null標準エラー出力を破棄shift先頭のパラメータを破棄し、以降を先頭にシフトJSONPath Support - KubernetesまとめScalingPolicy に値を設定することで、Fluentd の使用リソースを変更する機能のようです。中身がわかりスッキリしました。shellスクリプトには不慣れだったので、良い勉強になりました。","link":"https://qiita.com/kyohmizu/items/cbf9cca76a826d8eb130","isoDate":"2019-03-13T05:42:05.000Z","dateMiliSeconds":1552455725000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"2018年振り返りと、2019年の目標","contentSnippet":"2018年5月末から、エンジニアリングに関する様々な活動を行ってきました。\r1年の終わりにそれらの活動をまとめ、2019年の目標を記したいと思います。\r\r2018年の活動\r2018年は積極的に新しい技術へチャレンジし、勉強会を通して素晴らしい方々に出会うことができました。\r新たに触れた技術・ツール\r\rGitHub\rNode.js\rAngular\rGolang\rCentOS\rDocker\rKubernetes\rAzure\rGCP\rOWASP ZAP\rLINE BOT/Clova\rAgile\rペアプログラミング/モブプログラミング\r\r勉強会・カンファレンス\r\rLINE Developer Meetup\rde:code 2018\rAzureもくもく会\rng-japan 2018\rSQL Server 2017勉強会\rInteract 2018\rCCSE 2018\rThink Japan IBM Code Day\rJXUG Xamarinハンズオン\rCosmos DBハンズオン\rくじらや Dockerハンズオン\rLINE Clovaスキル開発ハンズオン\rLINE BOOT AWARDS 2018 ハッカソン\rGDG DevFest Tokyo 2018\rXP祭り\rAzureML勉強会\rBIT VALLEY 2018\r.NET Conf 2018\rContainer SIG Meet-up\rテスト管理を語る夕べ\rAVTOKYO\rアジャイル相談室\rOSSセキュリティ技術の会\rJapan Container Days\r\r※Japan Container Daysはスタッフとして参加させてもらいました。\r書籍\r読了\r\r徹底攻略 データベーススペシャリスト教科書\r徹底攻略 ネットワークスペシャリスト教科書\rショートコードプログラミング 第3版\r新装版 達人プログラマー\rSQLアンチパターン\rインフラエンジニアの教科書2\rプログラマのためのDocker教科書 第2版\rDocker/Kubernetes 実践コンテナ開発入門\r\r読みかけ\r\r体系的に学ぶ 安全なWebアプリケーションの作り方 第2版\r\r社内の活動\r\r技術交流、コミュニケーション促進のためチャンネルを開設\r社内勉強会を主催\rモブプログラミング・ペアプログラミングを開始\r\r資格\r合格\r\rデータベーススペシャリスト\r\r不合格\r\rネットワークスペシャリスト\r\r午後Ⅰが1点足りず…\rその他\r\rはてなブログを開設\rQiitaアドベントカレンダーに参加\r\r2019年の目標\r7ヶ月間の活動の中で、様々な技術分野にチャレンジした結果、インフラ・セキュリティへの関心が強いことがわかりました。\r2019年はContainerを中心にインフラのスキルを身に着け、セキュリティ分野の知見を広めていきます。\r書籍\r\r体系的に学ぶ 安全なWebアプリケーションの作り方 第2版\rKubernetes完全ガイド\rハッカーの学校\rテスト駆動開発\r徹底マスター JavaScriptの教科書\rドメイン駆動設計\rハッキング・ラボのつくりかた\r\r資格\r\rLPIC Level1\r情報処理安全確保支援士\rネットワークスペシャリスト","link":"https://kyohmizu.hatenablog.com/entry/2018/12/31/231740","isoDate":"2018-12-31T14:17:40.000Z","dateMiliSeconds":1546265860000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"GCEのVMインスタンス作成からDockerの利用開始まで","contentSnippet":"背景コンテナの学習にGCPを使用しています。Dockerのテスト用にGCEのVMインスタンスを作成することが何度かあったので、その手順を記載します。VMインスタンスの作成docker-sampleという名称で、CentOS7のVMインスタンスを作成します。コンソールから作成するか、以下のようなコマンドを実行します。--projectには自身のプロジェクト名を指定してください。$ gcloud beta compute --project=yourproject instances create docker-sample \\--zone=asia-northeast1-b --machine-type=n1-standard-1 --image=centos-7-v20181210 \\--image-project=centos-cloud --boot-disk-size=10GB --boot-disk-type=pd-standard \\--boot-disk-device-name=docker-sample作成したVMインスタンスにSSHで接続すれば、事前準備は完了です。Dockerのインストール複数のインストール方法がありますが、スクリプト実行によるインストールが簡単だと思います。※インターネットからダウンロードしたスクリプトは、実行前に必ず確認を行いましょう参考：Get Docker CE for CentOS[user@docker-sample ~]$ curl -fsSL https://get.docker.com -o get-docker.sh[user@docker-sample ~]$ sudo sh get-docker.sh-f : サーバーエラーを出力しない-s : 進捗、エラーを表示しない-S : エラーを表示する(-sと同時に使用)-L : リクエストページが移動していた場合、移動先で再実行するDockerのインストールに成功すると、バージョン確認ができるようになります。[user@docker-sample ~]$ sudo docker versionClient: Version:           18.09.0 API version:       1.39 Go version:        go1.10.4 Git commit:        4d60db4 Built:             Wed Nov  7 00:48:22 2018 OS/Arch:           linux/amd64 Experimental:      falseCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?Dockerデーモンの起動バージョンの確認では、最終行にDockerデーモンに接続できないというメッセージが表示されていました。この状態ではDockerを利用することはできません。[user@docker-sample ~]$ docker container run hello-worlddocker: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?.See 'docker run --help'.Dockerを利用するためには、Dockerデーモンを起動する必要があります。[user@docker-sample ~]$ sudo systemctl start docker[user@docker-sample ~]$ sudo docker container run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.-- 以下略ただし、VMを再起動すると再びDockerを利用できなくなります。VMの起動時に毎回Dockerデーモンを起動しなくてはなりません。Dockerデーモンを自動起動する場合は、次のコマンドを実行します。[user@docker-sample ~]$ sudo systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.参考：systemd で Docker の管理・設定ローカルユーザーでの実行Dockerは初期状態ではrootユーザーでのみ利用できるので、sudoをつけてコマンドを実行しなければなりません。sudoをつけなかった場合はエラーとなります。[user@docker-sample ~]$ docker container run hello-worlddocker: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post http://%2Fvar%2Frun%2Fdocker.sock/v1.39/containers/create: dial unix /var/run/docker.sock: connect: permission denied.ローカルユーザーでDockerを利用するためには、次のコマンドを実行します。[user@docker-sample ~]$ sudo usermod -aG docker youruser[user@docker-sample ~]$ docker container run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.（以下略）※うまく実行できない場合は、SSH接続を一度終了し再接続してみてください。","link":"https://qiita.com/kyohmizu/items/5f1929a2e949a9fa0da8","isoDate":"2018-12-22T17:33:14.000Z","dateMiliSeconds":1545499994000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"【C#】ショートコード・テクニック","contentSnippet":"C#開発における、ショートコーディングに役立つテクニックを紹介します。動作環境現在業務で使用している、以下の開発環境を想定しています。.NET Framework 4.6Visual Studio 2015修正前サンプルStudentクラス、Teacherクラス、テスト用メソッドのクラスを用意しました。XMLコメントはコードが長くなるので省略。Student.cs    class Student : Person    {        private string _Name;        private int _Number;        private int _Score;        public string Name        {            get { return _Name; }        }        public int Number        {            get { return _Number; }        }        public int Score        {            get { return _Score; }        }        public Student(string name, int number)        {            _Name = name;            _Number = number;        }        public void SetScore(int score)        {            _Score = score;        }        public bool HasName()        {            return string.IsNullOrEmpty(_Name);        }        public int CompareNumber(Student student)        {            int target = 0;            if(student != null)            {                target = student.Number;            }            return _Number.CompareTo(target);        }    }Teacher.cs    class Teacher : Person    {        private List\u003cStudent\u003e _Students = new List\u003cStudent\u003e();        public List\u003cStudent\u003e Students        {            get { return _Students; }        }        public Teacher(IEnumerable\u003cStudent\u003e students)        {            _Students.AddRange(students);        }        public double AverageScore()        {            if (_Students.Count == 0)            {                return 0;            }            return _Students.Average(student =\u003e student.Score);        }    }Test.cs    class Test    {        public void ResetScore(Student student)        {            if (student != null)            {                student.SetScore(0);            }        }        public IEnumerable\u003cStudent\u003e CreateSample(int count)        {            var students = new List\u003cStudent\u003e();            for (int number = 1; number \u003c= count; number++)            {                students.Add(new Student($\"生徒{number.ToString()}\", number));            }            return students;        }        public IEnumerable\u003cStudent\u003e GetAllStudents(IEnumerable\u003cTeacher\u003e teachers)        {            var students = new List\u003cStudent\u003e();            foreach (var teacher in teachers)            {                students.AddRange(teacher.Students);            }            return students;        }        public IEnumerable\u003cString\u003e GetStudentNames(IEnumerable\u003cPerson\u003e people)        {            var studentNames = new List\u003cstring\u003e();            foreach (var person in people)            {                var student = person as Student;                if (student != null)                {                    studentNames.Add(student.Name);                }            }            return studentNames;        }    }メソッド、プロパティのラムダ式記法1行のメソッドやgetterのみのプロパティを記述する時に、ラムダ式のような=\u003eを使用できます。Student.cs(修正前)        public string Name        {            get { return _Name; }        }        public int Number        {            get { return _Number; }        }        public int Score        {            get { return _Score; }        }        public void SetScore(int score)        {            _Score = score;        }        public bool HasName()        {            return string.IsNullOrEmpty(_Name);        }{ }で行数が多くなっていますが、ラムダ式記法では以下のようにスッキリ書けます。プロパティは意識することなく、setterを公開しない実装にできる点もポイント。Student.cs(修正後)        public string Name =\u003e _Name;        public int Number =\u003e _Number;        public int Score =\u003e _Score;        public void SetScore(int score) =\u003e _Score = score;    // 戻り値がないメソッド        public bool HasName() =\u003e string.IsNullOrEmpty(_Name); // 戻り値があるメソッドnull条件演算子＆null合体演算子null条件演算子?とnull合体演算子??を使用することで、nullチェックの記述を簡略化できます。null条件演算子Test.cs(修正前)        public void ResetScore(Student student)        {            if (student != null)            {                student.SetScore(0);            }        }参照型の引数のメンバにアクセスする時、NullReferenceExceptionを避けるためnullチェックを行うことがあります。null条件演算子?を使用すれば、nullチェックが不要になります。Test.cs(修正後)        public void ResetScore(Student student) =\u003e student?.SetScore(0);null条件演算子 + null合体演算子Student.cs(修正前)        public int CompareNumber(Student student)        {            int target = 0;            if(student != null)            {                target = student.Number;            }            return _Number.CompareTo(target);        }引数がnullの時に、既定値が必要となる場合があります。null条件演算子?だけでは既定値0を指定できませんが、null合体演算子??を組み合わせれば指定できます。Student.cs(修正後)        public int CompareNumber(Student student) =\u003e _Number.CompareTo(student?.Number ?? 0);EnumerableクラスLINQには、ショートコーディングを実現できる様々なメソッドが用意されています。ただしLINQの遅延評価により、完全に同じ動作にならないことには注意が必要です。Enumerable ClassLINQ と遅延評価Range連続する数字のコレクションを作成します。Test.cs(修正前)        public IEnumerable\u003cStudent\u003e CreateSample(int count)        {            var students = new List\u003cStudent\u003e();            for (int number = 1; number \u003c= count; number++)            {                students.Add(new Student($\"生徒{number.ToString()}\"));            }            return students;        }for文を用いた一般的なコードですが、ローカル変数の宣言やネストがやや冗長です。Rangeを使用することで以下のように記述できます。Test.cs(修正後)        public IEnumerable\u003cStudent\u003e CreateSample(int count) =\u003e Enumerable.Range(1, count).Select(number =\u003e new Student($\"生徒{number.ToString()}\", number));DefaultIfEmptyコレクションが空の場合にデフォルト値を返します。Teacher.cs(修正前)        public double AverageScore()        {            if (_Students.Count == 0)            {                return 0;            }            return _Students.Average(student =\u003e student.Score);        }Average、Sum、Maxなどの集計演算子は、コレクションが空の場合にエラーとなるため事前チェックが必要です。DefaultIfEmptyで既定値を設定すればこのチェックが不要になります。Teacher.cs(修正後)        public double AverageScore() =\u003e _Students.Select(student =\u003e student.Score).DefaultIfEmpty(0).Average();SelectManyコレクション同士を統合します。Test.cs(修正前)        public IEnumerable\u003cStudent\u003e GetAllStudents(IEnumerable\u003cTeacher\u003e teachers)        {            var students = new List\u003cStudent\u003e();            foreach (var teacher in teachers)            {                students.AddRange(teacher.Students);            }            return students;        }一時リストの作成とループをSelectManyで回避します。Test.cs(修正後)        public IEnumerable\u003cStudent\u003e GetAllStudents(IEnumerable\u003cTeacher\u003e teachers) =\u003e teachers.SelectMany(teacher =\u003e teacher.Students);OfType型によるフィルタリングを行います。Test.cs(修正前)        public IEnumerable\u003cString\u003e GetStudentNames(IEnumerable\u003cPerson\u003e people)        {            var studentNames = new List\u003cstring\u003e();            foreach (var person in people)            {                var student = person as Student;                if (student != null)                {                    studentNames.Add(student.Name);                }            }            return studentNames;        }コレクションの中から特定の型を選択したい場合はOfTypeが便利です。OfType使用後はキャストも不要。Test.cs(修正後)        public IEnumerable\u003cString\u003e GetStudentNames(IEnumerable\u003cPerson\u003e people) =\u003e people.OfType\u003cStudent\u003e().Select(student =\u003e student.Name);修正後サンプル上記修正をすべて行うことにより、コードの行数をかなり削減することができました。Student.cs    // 48行 → 17行    class Student : Person    {        private string _Name;        private int _Number;        private int _Score;        public string Name =\u003e _Name;        public int Number =\u003e _Number;        public int Score =\u003e _Score;        public Student(string name, int number)        {            _Name = name;            _Number = number;        }        public void SetScore(int score) =\u003e _Score = score;        public bool HasName() =\u003e string.IsNullOrEmpty(_Name);        public int CompareNumber(Student student) =\u003e _Number.CompareTo(student?.Number ?? 0);    }Teacher.cs    // 20行 → 10行    class Teacher : Person    {        private List\u003cStudent\u003e _Students = new List\u003cStudent\u003e();        public List\u003cStudent\u003e Students =\u003e _Students;        public Teacher(IEnumerable\u003cStudent\u003e students)        {            _Students.AddRange(students);        }        public double AverageScore() =\u003e _Students.Select(student =\u003e student.Score).DefaultIfEmpty(0).Average();    }Test.cs    // 41行 → 7行    class Test    {        public void ResetScore(Student student) =\u003e student?.SetScore(0);        public IEnumerable\u003cStudent\u003e CreateSample(int count) =\u003e Enumerable.Range(1, count).Select(number =\u003e new Student($\"生徒{number.ToString()}\", number));        public IEnumerable\u003cStudent\u003e GetAllStudents(IEnumerable\u003cTeacher\u003e teachers) =\u003e teachers.SelectMany(teacher =\u003e teacher.Students);        public IEnumerable\u003cString\u003e GetStudentNames(IEnumerable\u003cPerson\u003e people) =\u003e people.OfType\u003cStudent\u003e().Select(student =\u003e student.Name);    }まとめC#の様々な機能を使って、簡潔で読みやすいコードを目指しましょう。他にも便利な機能がありましたら教えてください。ご意見、ご指摘もよろしくお願いします。追記変更のないメンバStudent.cs        private string _Name;        private int _Number;        public string Name =\u003e _Name;        public int Number =\u003e _Number;        public Student(string name, int number)        {            _Name = name;            _Number = number;        }Name、Numberはコンストラクタで設定後、バッキングフィールドを変更していません。=\u003eの説明のため本文はそのままにしますが、変更のない場合は自動プロパティで十分です。Student.cs        public string Name { get; }        public int Number { get; }        public Student(string name, int number)        {            Name = name;            Number = number;        }","link":"https://qiita.com/kyohmizu/items/b7b8de409d9e5b0f2626","isoDate":"2018-12-20T06:21:26.000Z","dateMiliSeconds":1545286886000,"authorName":"kyohmizu","authorId":"kyohmizu"},{"title":"Windowsコマンド一覧","contentSnippet":"Windowsのコマンドプロンプトで使用するコマンド例を記載します。詳細は /? で確認してください。システム情報を表示systeminfoリダイレクト標準出力dir *.bat \u003e result.txt　 type result.txt標準入力sort \u003c items.txt追記for %i in (*.*) do ( echo %i ) \u003e\u003e result.txtネットワーク情報ipconfig /all実行ファイルの起動rem 別プロセスstart notepadrem 同一プロセス(終了まで待つ)call notepadファイルから文字列を検索rem サブディレクトリも含む、ファイル名のみ、.txtファイル内を検索findstr /s /m \"hoge\" *.txtファイル削除del {filename}ディレクトリ削除rd {directoryname}ディレクトリ作成md {directoryname}文字コードの表示、設定chcpDOSの背景・文字色を変更colorエスケープ文字^キャレット\\findstrのエスケープ文字for文delims= 区切り文字を指定。空文字の場合は1行全てを取得。IPアドレスからホスト名を見つけるnbtstat -A {IP address}ホスト名からIPアドレスを見つけるnslookup {hostname}MACアドレスキャッシュ一覧arp -a接続ポートを確認netstat -aon送信テストping {IP address}rem 自分の仮想IPアドレスに送信ping 127.0.0.1127.0.0.1 = ループバックアドレスタスク一覧を表示tasklist /svcDNSキャッシュの内容を更新・表示ipconfig /flushdnsipconfig /displaydnssqlcmd接続sqlcmd -S .\\{databaseinstance}use {dbname}データベース名一覧select name from sys.Databasesテーブル名一覧select name from sys.Tablesカラム名一覧select name from sys.columns where object_id = OBJECT_ID('dbo.{tablename}')psqlPostgreSQLに接続psql -U postgres -p 5433ページャーを無効\\pset pager offデータベース一覧\\lデータベース接続\\connect {databasename}スキーマ一覧\\dnテーブル表示\\d {schemaname}.{tablename}スキーマ内テーブル名一覧select relname as TABLE_NAME from pg_stat_user_tables where schemaname = '{schemaname}'","link":"https://qiita.com/kyohmizu/items/be47b8d01a78cd3f0f0d","isoDate":"2018-04-26T01:59:46.000Z","dateMiliSeconds":1524707986000,"authorName":"kyohmizu","authorId":"kyohmizu"}]},"__N_SSG":true},"page":"/members/[id]","query":{"id":"kyohmizu"},"buildId":"zZ6r2EH5Ok5H6VAz6x2S6","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["link",{"rel":"icon shortcut","type":"image/png","href":"https://blog.3-shake.com//logo.png"}],["link",{"rel":"stylesheet","href":"https://fonts.googleapis.com/css2?family=Inter:wght@400;700\u0026display=swap"}],["title",{"children":"kyohmizu | 3-shake Engineers' Blogs"}],["meta",{"property":"og:title","content":"kyohmizu"}],["meta",{"property":"og:url","content":"https://blog.3-shake.com//members/kyohmizu"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"property":"og:site","content":"3-shake Engineers' Blogs"}],["meta",{"property":"og:image","content":"https://blog.3-shake.com//og.png"}],["link",{"rel":"canonical","href":"https://blog.3-shake.com//members/kyohmizu"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-4beebf4ac9054f0bf4e6.js"></script><script src="/_next/static/chunks/main-8a83f0fd99327c4684a8.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.1daf1ec1ecf144ee9147.js" async=""></script><script src="/_next/static/chunks/commons.9e003f150a446b53bdd9.js" async=""></script><script src="/_next/static/chunks/pages/_app-de809e7fcd6e160a3411.js" async=""></script><script src="/_next/static/chunks/81b50c7ab23905e464b4340eb234bd6ea389d26b.a959eb3c8a77689c86fe.js" async=""></script><script src="/_next/static/chunks/pages/members/%5Bid%5D-82bdc617ad4a0fa06a9e.js" async=""></script><script src="/_next/static/zZ6r2EH5Ok5H6VAz6x2S6/_buildManifest.js" async=""></script><script src="/_next/static/zZ6r2EH5Ok5H6VAz6x2S6/_ssgManifest.js" async=""></script></body></html>