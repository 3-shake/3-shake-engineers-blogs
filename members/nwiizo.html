<!DOCTYPE html><html lang="ja"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="icon shortcut" type="image/png" href="https://blog.3-shake.com/logo.png" data-next-head=""/><title data-next-head="">nwiizo | 3-shake Engineers&#x27; Blogs</title><meta property="og:title" content="nwiizo" data-next-head=""/><meta property="og:url" content="https://blog.3-shake.com/members/nwiizo" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta property="og:site" content="3-shake Engineers&#x27; Blogs" data-next-head=""/><meta property="og:image" content="https://blog.3-shake.com/og.png" data-next-head=""/><link rel="canonical" href="https://blog.3-shake.com/members/nwiizo" data-next-head=""/><link rel="preload" href="/_next/static/css/683b82a315c74ead.css" as="style"/><link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;500;700&amp;family=Roboto:wght@300;400;500;700&amp;display=swap" rel="stylesheet"/><link rel="stylesheet" href="/_next/static/css/683b82a315c74ead.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-6ffd07a3317375c1.js" defer=""></script><script src="/_next/static/chunks/framework-292291387d6b2e39.js" defer=""></script><script src="/_next/static/chunks/main-185e55058f08a063.js" defer=""></script><script src="/_next/static/chunks/pages/_app-eb27c9050fc0d186.js" defer=""></script><script src="/_next/static/chunks/736-8fc2be7889d42e92.js" defer=""></script><script src="/_next/static/chunks/pages/members/%5Bid%5D-1cb8738aa03f0d9c.js" defer=""></script><script src="/_next/static/Jj9pZK7GvCPEg_YOHhVqy/_buildManifest.js" defer=""></script><script src="/_next/static/Jj9pZK7GvCPEg_YOHhVqy/_ssgManifest.js" defer=""></script></head><body><link rel="preload" as="image" href="/logo.svg"/><link rel="preload" as="image" href="/avatars/nwiizo.jpeg"/><link rel="preload" as="image" href="/icons/twitter.svg"/><link rel="preload" as="image" href="/icons/github.svg"/><link rel="preload" as="image" href="/icons/link.svg"/><link rel="preload" as="image" href="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com"/><link rel="preload" as="image" href="https://www.google.com/s2/favicons?domain=speakerdeck.com"/><div id="__next"><header class="site-header"><div class="content-wrapper"><div class="site-header__inner"><a class="site-header__logo-link" href="/"><img src="/logo.svg" alt="3-shake Engineers&#x27; Blogs" class="site-header__logo-img"/><span class="site-header__logo-text">3-shake<br/>Engineers&#x27; Blogs</span></a><div class="site-header__links"><a class="site-header__link" href="/feed.xml">RSS</a><a href="https://jobs-3-shake.com/" class="site-header__link">Recruit</a><a href="https://3-shake.com/" class="site-header__link">Company</a></div></div></div></header><section class="member"><div class="content-wrapper"><header class="member-header"><div class="member-header__avatar"><img src="/avatars/nwiizo.jpeg" alt="nwiizo" width="100" height="100" class="member-header__avatar-img"/></div><h1 class="member-header__name">nwiizo</h1><p class="member-header__bio">The Passionate Programmer</p><div class="member-header__links"><a href="https://twitter.com/nwiizo" class="member-header__link"><img src="/icons/twitter.svg" alt="Twitterのユーザー@nwiizo" width="22" height="22"/></a><a href="https://github.com/nwiizo" class="member-header__link"><img src="/icons/github.svg" alt="GitHubのユーザー@nwiizo" width="22" height="22"/></a><a href="https://nwiizo.github.io/" class="member-header__link"><img src="/icons/link.svg" alt="ウェブサイトのリンク" width="22" height="22"/></a></div></header><div class="member-posts-container"><div class="post-list"><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-11-02T17:03:16.000Z" class="post-link__date">2 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/11/03/020316" class="post-link__main-link"><h2 class="post-link__title">おい、部屋を掃除しろ</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a><div class="post-link__new-label">NEW</div></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-11-01T03:00:27.000Z" class="post-link__date">3 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/11/01/120027" class="post-link__main-link"><h2 class="post-link__title">言葉にしない限り、『なんか』は永遠に巨大な壁であり続ける</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-10-31T03:52:56.000Z" class="post-link__date">4 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/10/31/125256" class="post-link__main-link"><h2 class="post-link__title">近すぎず、遠すぎず - コードの結合度とちょうどいい距離の測り方</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-10-30T11:33:42.000Z" class="post-link__date">5 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/10/30/203342" class="post-link__main-link"><h2 class="post-link__title">構造的類似性を捉える技術 - similarity-rsで学ぶAST-basedコード解析の実装</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-10-28T02:30:09.000Z" class="post-link__date">7 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/10/28/113009" class="post-link__main-link"><h2 class="post-link__title">ソフトウェアエンジニアにおける才能という幻想、あるいは成長を阻む最大の敵について</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-10-27T04:46:29.000Z" class="post-link__date">8 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/10/27/134629" class="post-link__main-link"><h2 class="post-link__title">技術力に優劣はある(「技術力に優劣はない」を読んで)</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-10-18T07:39:11.000Z" class="post-link__date">17 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/10/18/163911" class="post-link__main-link"><h2 class="post-link__title">cargo-chefがRustのDockerビルドを高速化する話</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-10-16T22:02:50.000Z" class="post-link__date">19 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/10/17/070250" class="post-link__main-link"><h2 class="post-link__title">RustのDockerfile、2025年はこれでいこう</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-10-16T08:08:00.000Z" class="post-link__date">19 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/10/16/170800" class="post-link__main-link"><h2 class="post-link__title">baconを知らずにRust書いてた</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-10-14T04:36:02.000Z" class="post-link__date">21 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/10/14/133602" class="post-link__main-link"><h2 class="post-link__title">文章力を分解してちゃんと文章を書く。</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-10-11T23:13:00.000Z" class="post-link__date">24 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/10/12/081300" class="post-link__main-link"><h2 class="post-link__title">読解力を分解してちゃんと文章を読む。</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-10-08T00:17:49.000Z" class="post-link__date">a month ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/10/08/091749" class="post-link__main-link"><h2 class="post-link__title">生成AI時代に必要なコンサルタントの秘密</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-10-05T22:42:20.000Z" class="post-link__date">a month ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/10/06/074220" class="post-link__main-link"><h2 class="post-link__title">システム思考を使う人が知っておいてよい12のシステムアーキタイプ</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-10-01T11:39:24.000Z" class="post-link__date">a month ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/10/01/203924" class="post-link__main-link"><h2 class="post-link__title">システム思考を日々の開発に取り入れる実践ガイド</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-10-01T11:36:33.000Z" class="post-link__date">a month ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/10/01/203633" class="post-link__main-link"><h2 class="post-link__title">システムを作る人がまず理解すべきシステム思考の基礎</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-09-30T04:00:00.000Z" class="post-link__date">a month ago</time></div></a><a href="https://speakerdeck.com/nwiizo/baibukodeingutoji-sok-de-depuroimento" class="post-link__main-link"><h2 class="post-link__title">バイブコーディングと継続的デプロイメント</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=speakerdeck.com" width="14" height="14" class="post-link__site-favicon"/>speakerdeck.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-09-22T08:53:53.000Z" class="post-link__date">a month ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/09/22/175353" class="post-link__main-link"><h2 class="post-link__title">エンジニアはちゃんと身銭を切れ</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-09-22T00:45:33.000Z" class="post-link__date">a month ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/09/22/094533" class="post-link__main-link"><h2 class="post-link__title">ACPでAgentに行動させる</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-09-10T04:00:00.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://speakerdeck.com/nwiizo/webapurikesiyonniobuzababiriteiwoshi-zhuang-sururustru-men-gaido" class="post-link__main-link"><h2 class="post-link__title">Webアプリケーションにオブザーバビリティを実装するRust入門ガイド</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=speakerdeck.com" width="14" height="14" class="post-link__site-favicon"/>speakerdeck.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-09-09T05:33:06.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/09/09/143306" class="post-link__main-link"><h2 class="post-link__title">Claude CodeのSubagentsは設定したほうがいい</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-09-05T04:00:00.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://speakerdeck.com/nwiizo/2025nian-xia-kodeinguezientowotong-beruzhe" class="post-link__main-link"><h2 class="post-link__title">2025年夏 コーディングエージェントを統べる者</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=speakerdeck.com" width="14" height="14" class="post-link__site-favicon"/>speakerdeck.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-09-03T08:48:30.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/09/03/174830" class="post-link__main-link"><h2 class="post-link__title">続: 自分が書いたコードより目立つな - エンジニアがバズったので自戒</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-09-01T05:57:00.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/09/01/145700" class="post-link__main-link"><h2 class="post-link__title">『禅とオートバイ修理技術』を読んだ。</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-08-22T06:58:56.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/08/22/155856" class="post-link__main-link"><h2 class="post-link__title"> RustでLinuxのシグナル処理とプロセス間通信をしてみた</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-08-21T07:12:34.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/08/21/161234" class="post-link__main-link"><h2 class="post-link__title">RustでLinuxプロセス管理をしてみた</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-08-14T05:35:27.000Z" class="post-link__date">3 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/08/14/143527" class="post-link__main-link"><h2 class="post-link__title">缶つぶし機とソフトウェア移行技術 - Refactoring to Rust の読書感想文</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-08-12T12:00:21.000Z" class="post-link__date">3 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/08/12/210021" class="post-link__main-link"><h2 class="post-link__title">エンジニアのための「中身のある話」の作り方</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-08-04T08:35:59.000Z" class="post-link__date">3 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/08/04/173559" class="post-link__main-link"><h2 class="post-link__title">組織の成長に伴う私のtimes の終焉についての思索</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-07-29T10:56:08.000Z" class="post-link__date">3 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/07/29/195608" class="post-link__main-link"><h2 class="post-link__title">2025年夏 AIエージェントシステムに対する考え方</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-07-23T04:00:00.000Z" class="post-link__date">3 months ago</time></div></a><a href="https://speakerdeck.com/nwiizo/zhuan-zhi-sitaraaws-mcpsabadatutajian" class="post-link__main-link"><h2 class="post-link__title">転職したらAWS MCPサーバーだった件</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=speakerdeck.com" width="14" height="14" class="post-link__site-favicon"/>speakerdeck.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-07-16T02:55:10.000Z" class="post-link__date">4 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/07/16/115510" class="post-link__main-link"><h2 class="post-link__title">AI時代の新たな疲労：なぜ私(たち)は『説明のつかないしんどさ』を抱えているのか</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-07-14T01:58:12.000Z" class="post-link__date">4 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/07/14/105812" class="post-link__main-link"><h2 class="post-link__title">Claude CodeのHooksは設定したほうがいい</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article></div><div class="post-list-load"><button class="post-list-load__button">LOAD MORE</button></div></div></div></section><footer class="site-footer"><div class="content-wrapper"><p>© <!-- -->3-shake Inc.</p></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"member":{"id":"nwiizo","name":"nwiizo","role":"Software Developer","bio":"The Passionate Programmer","avatarSrc":"/avatars/nwiizo.jpeg","sources":["https://syu-m-5151.hatenablog.com/feed","https://zenn.dev/nwiizo/feed","https://speakerdeck.com/nwiizo.rss"],"includeUrlRegex":"","twitterUsername":"nwiizo","githubUsername":"nwiizo","websiteUrl":"https://nwiizo.github.io/"},"postItems":[{"title":"おい、部屋を掃除しろ","link":"https://syu-m-5151.hatenablog.com/entry/2025/11/03/020316","contentSnippet":"はじめにどれだけ技術を学んでも、どれだけ正しいプロセスを知っていても、燃え尽きてしまったら意味がない。才能ある若者たちが最初は誰よりも速く理解して、誰よりも多くのコードを書いていたのに、数ヶ月後には姿を見せなくなる。「疲れた」と言って離れていく。逆に、最初は遅くても数年経った今も黙々と学び続けている人たちがいる。彼らに共通しているのは、自分を大切に扱う習慣を持っていることだった。ちゃんと眠る。ちゃんと食べる。ちゃんと休む。そしてちゃんと掃除する。その中でも最も基本的な実践が、掃除だ。在宅勤務を始めて六年目のある朝、ふと自分の部屋を見回した。今、部屋は比較的綺麗だ。床に物は落ちていない。デスクの上も整理されている。技術書も本棚に並んでいる。窓を開けて空気を入れ替える習慣もついた。カーテンも開いていて、部屋の中は明るい。30歳のエンジニア、独身。在宅勤務という働き方は自由をくれたはずなのに、気づけば自分は4畳半の部屋の中で完結した生活を送っている。仕事もする。プログラミングもする。読書もする。ブログも書く。趣味もある。孤独は嫌いではない。むしろ好きだ。一人で考える時間、一人でコードを書く時間、一人で本を読む時間。誰にも邪魔されず、自分のペースで物事に向き合える時間。これは孤独であって、寂しさではない。寂しいと孤独は別物だ。孤独は選べるが、寂しさは選べない。でも私生活がぐちゃぐちゃになってしまうと、自分のプライベートも引きずられて悪くなる。掃除をしなくなる。自炊をしなくなる。身だしなみが雑になる。運動をしなくなる。風呂に入らなくなる。これらが崩れ始めると、部屋は散らかり、仕事も集中できなくなり、趣味も楽しめなくなり、選んだはずの孤独が、望まない寂しさに変わっていく。掃除は、精神の指標になる。部屋を見れば、今の自分の精神状態が分かる。乱れている時は心も乱れている。整っている時は心も整っている。結局、最も重要なのは燃え尽きずに続けることで、そのために必要なのは自分を大切に扱うことで、その最も基本的な実践が掃除なのではないか。この記事は、そんな仮説を自分自身で検証するために書いている。掃除とは何か。なぜ自分は掃除ができなくなるのか。そして掃除することで何が変わるのか。表面的な整理整頓の話ではなく、もっと根本的な、自分をどう扱うかという話だ。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。掃除できない理由は全て言い訳だ「忙しいから掃除できない」。でも本当にそうか？毎日Twitterを見て、YouTubeのショート動画を延々と見ている。気づけば一時間、二時間が過ぎている。つまり、時間がないのではない。掃除を優先していないだけだ。「疲れているから」という言い訳もある。でも実は、散らかった部屋で過ごしていることが疲れの原因かもしれない。視界の隅に常にゴミや散らかったものが入ってきて、それが無意識のストレスになっている。朝起きたときにすでに憂鬱で、仕事を始める前からエネルギーが削がれている。だから疲れる。そして疲れているから掃除しない。この悪循環。「どうせすぐ散らかるから」という諦めもある。以前掃除したけど三日後には元通りだった。でもなぜか。綺麗にした後、何も仕組みを変えていなかったからだ。服を脱いだら床に置く習慣、ゴミが出たらデスクに置く習慣、本を読んだら床に積む習慣。掃除をしたというより、一時的に物を移動させただけだった。これらの言い訳を並べてみて気づく。どれも本質的な理由ではない。本当の理由はもっと深いところにある。「どうせ自分なんか」という、言葉にならない諦めが。部屋を整えることが心を整えるよく「部屋の乱れは心の乱れ」と言われる。でもこの言葉は因果関係が逆だ。「部屋の乱れが心を乱す」のだ。そしてもっと正確に言えば「部屋を整えることが心を整える」。心という曖昧なものを直接コントロールすることは難しい。でも部屋という物理的な空間は、手を動かせば変えられる。服をハンガーにかける。ゴミを捨てる。床を拭く。これらは全て、具体的で、実行可能で、結果が目に見える行動だ。そしてこれらの行動が、不思議なことに心に作用する。綺麗な部屋で目覚めると、一日の始まりが違う。整理されたデスクで仕事をすると、思考がクリアになる。物が少ない空間にいると、頭の中も軽くなる。部屋を整えることは、心を整えるための、最も具体的で確実な方法なのだ。掃除は自分への態度を訓練する修行だ掃除は単に「清潔にする」ための行動だと思われがちだ。でも実は、もっと深い意味を持っている。自分をどう扱うかを、身体に教えている訓練なのだ。掃除とは、「自分の空間を整える力が自分にある」と確認することだ。散らかった部屋を見て「どうせ自分には無理だ」と諦めるのではなく、一つずつ片付けていく。床に落ちている服を拾う。ゴミを捨てる。デスクを拭く。この行為を通じて「自分には変える力がある」と身体で理解する。これは掃除だけではない。自炊なら「自分のために手を動かす価値がある」と身体が覚えること。身だしなみを整えるのは「私は丁寧に扱っていい存在だ」と身体に教えること。運動することは「自分の身体に投資する価値がある」と確認すること。風呂に入ることは「私は清潔でいていい存在だ」と身体に教えること。しかし、その中でも掃除は最も基本的で、最も効果が目に見えやすい実践だ。「どうせ自分なんか」と思って放っておく時間が続くと、それらの行為がどうしても億劫に感じて、身体は「私は放っておかれて当然なんだ」と学んでしまう。逆に言えば、少しずつでも、適当でも、掃除をしていくことで、「自分は守られていい」「手をかけられていい」と身体が再び信じ始める。これは精神論ではない。実際に起きることだ。部屋を掃除した日の夜、なぜか少しだけ自己肯定感が上がる。掃除は、自分への態度を訓練する修行なのだ。放置のサイクルと手入れのサイクル放置のサイクル朝起きる。部屋が汚い。気分が重い。でも掃除する気力がない。「今日は忙しいから」と自分に言い訳をする。朝食も作らない。シャワーも浴びない。適当な服を着る。仕事を始める。集中できない。視界の隅にゴミが見える。気が散る。効率が落ちる。疲れる。夜になる。もっと疲れている。掃除なんてできない。自炊もめんどくさい。風呂に入るのもめんどくさい。運動なんてもってのほか。「明日やろう」と思う。眠る。次の日も同じ。部屋は昨日より汚い。服がもう一枚増えている。ゴミがもう一つ増えている。気分はもっと重い。でも何もする気力はもっとない。そしてまた「明日やろう」と思う。一週間後、すべてが荒れ果てている。部屋は散らかり、床はほとんど見えない。デスクは物で埋まっている。空気は淀んでいる。そして自分の気持ちも荒れ果てている。「もうどこから手をつけていいか分からない」という諦めが支配している。毎日、放置という行動を通じて、「お前は放っておかれて当然だ」というメッセージを自分自身に送り続けている。手入れのサイクル朝起きる。部屋が綺麗。気持ちがいい。窓を開ける。空気を入れ替える。ベッドを整える。たった一分の作業だが、これだけで一日の始まりが違う。シャワーを浴びる。髪を整える。清潔な服を着る。朝食を作る。簡単なものでいい。温かいご飯。身体が目覚める。仕事を始める。デスクが綺麗だから集中できる。必要なものがすぐ見つかる。思考がクリア。コードがスムーズに書ける。効率が上がる。気持ちがいい。昼休み、食器をすぐ洗う。軽く散歩する。身体を動かす。夜、仕事を終える。運動する日もある。しない日も軽くストレッチする。夕食を作る。自分のために作った温かいご飯。シャワーを浴びる。床に落ちているものを片付ける。ゴミを捨てる。読んだ本を本棚に戻す。合計十分。でもこの十分が、明日の自分を助ける。身体は学習する。「私は手をかけられる存在だ」と。「私の空間は整っていていい」と。「私は価値がある」と。行動が、その人の存在の意味を決める。言葉ではなく、行動が。毎日の小さな選択が、自分をどう扱うかを決めている。規律という美学部屋が散らかっている時の自分は、不思議なことに、あらゆる面が乱れている。時間管理も散らかる。締切ギリギリになって慌てる。生活のあらゆる面は繋がっていて、一つの領域での乱れは、他の領域にも波及する。逆に、部屋を整えている時期の自分は、あらゆる面が整っている。朝、決まった時間に起きられる。約束を守れる。締切を守れる。自分との約束も守れる。そしてこの規律が、自分という存在に秩序をもたらす。美しさとは、日々の規律ある行動から生まれる副産物なのではないか。一つ一つの動作に美を宿すこと。服を畳むときに丁寧に畳む。食器を洗うときに丁寧に洗う。掃除をするときに隅々まで拭く。これらの「めんどくさい」行為が、実は自分を美しくしている。誰も見ていない。在宅勤務だから誰にも会わない。だから適当でいい。そう思って過ごしていると、その「適当さ」が身体に染み込んでいく。でも逆に、誰も見ていなくても、自分のために丁寧に生きる。その選択が、自分を美しくする。掃除は「修行」として捉えるべき実践なのだ。小さく始めるという勇気ある日、決意した。「今日から毎日掃除をする」と。でも夜には忘れていた。三日目には諦めていた。「やっぱり自分には無理だ」と。問題は、始め方が大きすぎたことだ。「毎日掃除をする」というのは、実は途方もなく大きな変化だ。でもある時、試しに小さく始めてみた。「朝起きたら、ベッドを整える。それだけ」。これなら一分もかからない。簡単すぎる。でもこれを続けた。一週間、二週間、一ヶ月。気づけば習慣になっていた。そして不思議なことに、ベッドを整える習慣ができると、他のことも少しずつやりたくなってきた。「どうせベッドを整えるなら、カーテンも開けよう」「どうせカーテンを開けるなら、窓も開けよう」「どうせ窓を開けるなら、ゴミも捨てよう」。小さな一歩が、次の一歩を呼ぶ。完璧を求めて何もしないより、不完全でも小さく始める方が、ずっと前に進める。一日五分の掃除と、週に一回の大掃除、どちらが効果的か。前者だ。なぜなら習慣になるから。小さく始めることは、実は最も大きな勇気を必要とする。なぜなら、小さすぎて効果がないように感じるから。「たったこれだけで意味があるのか」という疑念と戦わなければならない。でも意味はある。確実にある。身体は小さな変化を記憶する。そして小さな変化の積み重ねが、大きな変化になる。おわりにこの記事を書きながら、自分の部屋を見回している。今、部屋は比較的綺麗だ。床に物はほとんど落ちていない。デスクの上も整理されている。窓を開けて空気を入れ替える習慣もついた。これらの小さな習慣が、気持ちを支えている。仕事にも集中できる。コードを書くのも、ブログを書くのも、本を読むのも楽しい。掃除は、精神の指標になる。今、部屋が比較的綺麗なのは、今の精神状態が比較的安定しているということだ。でも油断すると、すぐに乱れる。だから毎日少しずつ手をかけ続ける。才能があっても燃え尽きたら意味がない。理解が速くても続かなければ意味がない。結局、長く続けた人が、最も遠くまで行く。そして長く続けるために必要なのは、派手なスキルでも高度な知識でもなく、自分を丁寧に扱う日々の習慣だ。掃除は単なる家事ではない。自分への態度を訓練する修行であり、自分という存在をどう扱うかを身体に教える実践だ。そして何より、燃え尽きないための、最も基本的な自己防衛の手段なのだ。在宅勤務で過ごす30歳の自分にとって、掃除は生き延びるための技術になった。孤独は好きだ。一人で考える時間、一人でコードを書く時間、一人で本を読む時間。誰にも邪魔されない自由。でもその孤独を愛するためには、まず自分の空間を整える必要があった。部屋を整えることで、心を整える。空間に秩序をもたらすことで、人生に秩序をもたらす。そして集中して仕事ができる。コードが書ける。ブログが書ける。本が読める。選んだ孤独を、寂しさに侵食されずに生きられる。自分を大切にするということ。それは掃除をすること、自炊をすること、身だしなみを整えること、運動をすること、風呂に入ること。これらすべてが大切だ。でもその第一歩が、掃除なのだ。「どうせ自分なんか」という声が聞こえたら、まず床に落ちている服を一枚拾う。ゴミを一つ捨てる。デスクを一度拭く。たったそれだけでいい。その小さな行動が、「自分は手をかけられていい」というメッセージを、自分自身に送る。そして身体がそれを覚える。少しずつ、少しずつ、「自分は大切にされていい存在だ」と信じ始める。完璧を目指す必要はない。毎日完璧に掃除する必要もない。ただ、少しずつでも、適当でも、自分に手をかけ続けること。それが掃除の本質であり、同時に自分を整えることの本質であり、そして燃え尽きずに続けるための、最も確実な方法なのだ。技術は大切だ。知識も大切だ。仕事も大切だ。プログラミングも大切だ。読書も大切だ。ブログも大切だ。趣味も大切だ。孤独を愛することも大切だ。でも最も大切なのは、自分を大切にすることだ。そしてその第一歩が、自分の部屋を掃除することなのかもしれない。おい、部屋を掃除しろ。それは命令ではなく、自分自身への、静かな呼びかけだ。長く続けるために。燃え尽きないために。そして、自分を大切にするために。利他・ケア・傷の倫理学作者:近内悠太晶文社Amazonカウンセリングとは何か　変化するということ (講談社現代新書)作者:東畑開人講談社Amazon","isoDate":"2025-11-02T17:03:16.000Z","dateMiliSeconds":1762102996000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"言葉にしない限り、『なんか』は永遠に巨大な壁であり続ける","link":"https://syu-m-5151.hatenablog.com/entry/2025/11/01/120027","contentSnippet":"はじめにワークショップが始まる三十分前、会場の隅で、一人の若者がノートPCの画面を凝視していた。ブラウザには二十を超えるタブが開かれている。Dockerの公式ドキュメント、Kubernetesの公式リファレンス、Qiita、Zenn、個人ブログ。静かな会場に響くのは、マウスホイールを回す音だけで、彼は次から次へとタブを切り替えながら、何かを探すように、あるいは何かから逃げるように、ドキュメントを読み続けていた。読んでいた、という言葉はきっと正確ではなくて、目で文字を追っているだけで、その言葉が本当に頭の中に入っているかどうかは、おそらく彼自身にも分からなかったのだろうし、分からないことに気づかないふりをしていたのかもしれないし、あるいは気づいていたけれど認めたくなかったのかもしれない。「準備しておかないと」ぽつりと呟いた声は、誰に向けられたものでもなかった。会場には他にも何人か早めに来ている参加者がいたけれど、彼らに向けた言葉でもなく、講師である僕に向けた言葉でもなく、けれど僕には分かった、あの言葉は自分自身への言い訳で、読み続けている限り「まだ始めていない」という事実から目を逸らせて、手元にあるyamlファイルを開くことも、Dockerfileを書き始めることもなく、ただスクロールを繰り返していれば、準備という名の猶予期間はどこまでも続いていくような気がして、その錯覚こそが彼を動けなくしているのだと、その姿を見ながら僕は思った。彼は、昔の僕だ。気づけば開始時刻になっていた。けれど彼の画面に立ち上がったコンテナは一つもなくて、代わりにあったのは無数に開かれたタブと、そして不思議なことに「今日は勉強した」という、根拠はどこにもないのにどこか心地よい、温かくて柔らかい達成感だけだった。手は動かしていないのに、頭は働かせた気がして、何も作っていないのに、何かを学んだ気がして、この感覚はとても甘くて危険で、僕も何度もこの甘い罠に捕まってきたから分かる。僕も石橋を叩いて渡るタイプで、新しい技術を学ぶときはまず本を買って安心する。「準備してから」「もう少し理解してから」「完璧になってから」、その言葉は、とても合理的に聞こえる、誰も反論できない、自分自身も反論できない、だから安心してその言葉に逃げ込むことができる。でも、ある時気づいてしまった。「まだ準備が足りない」と思って読み続けるうちに、何時間も、何日も経っていて、僕は実際には何一つ手を動かしていなかったことに。本当は、もっと早く気づいていたのかもしれない。けれど気づかないふりをして、気づきたくなくて、「準備」という名の停滞を「努力」だと自分に言い聞かせていた。「明日からやろう」という言葉の背後で何が起きているのか、本人は意外と気づいていない。いや、もしかしたら気づいているのかもしれないけれど、気づかないふりをしているのかもしれないし、気づいていることに気づかないふりをしているのかもしれない。このポストは動けない人の構造を解剖し、そこから抜け出すための実践について書いたもので、三年間ワークショップで自分や多くの若手エンジニアと向き合う中で見えてきたことがある。動けない理由は一見バラバラに見える、けれどこれらの言葉を一つ一つ丁寧に剥いでいくと、驚くほど似た構造が現れる。恥への恐怖、完璧主義、そして「才能がない」という誰も反論できない便利な逃げ道。面白いことに、これらの根底には共通するものがあって、それは「なんとなく不安」「どうも気が進まない」「なんか怖い」という、この「なんか」という輪郭を持たない曖昧な言葉で、僕らはこの「なんか」という便利な言葉の中に、言葉にしたくない、言葉にするのが怖い、言葉にしてしまったら向き合わなければならなくなる、そういう感情を全部押し込めて蓋をしている。この「なんか」を言葉にしない限り、恐怖は形を持たない。形を持たない恐怖は霧のように僕らの思考を覆って、じわじわと、気づかないうちに、判断力を奪い続ける。ここで一つ断っておきたいのは、僕の「なんか」とあなたの「なんか」は、きっと少し違うということで、僕が恐れているものとあなたが恐れているものは同じではないかもしれないし、僕が「恥」だと感じるものとあなたが「恥」だと感じるものは、同じ言葉を使っていても中身は違うのかもしれない。けれど、それでも共通しているのは、その「なんか」を言葉にしないまま放置していることで、言葉にしない限り、それが何であれ、形を持たないまま僕らの中で勝手に膨らんでいくということだ。だから本人も周りもなかなか気づかないまま、「準備している」「慎重なだけ」「向いていないのかも」という、どこか優しげに聞こえて、誰も否定できない言葉の裏側で、実は何ヶ月も何年も同じ場所に立ち止まっていて、立ち止まっていることにすら気づかないまま時間だけが過ぎていく。さらに現代という時代が、この自己欺瞞を加速させている。生成AIに聞けばそれっぽい答えがすぐ返ってきて「理解した気」になれるし、スマホを開けば無限に刺激があって「ちょっと休憩」が気づけば一時間になる。立ち止まっている自分を見て見ぬふりをするための道具が、これほど揃っている時代はない。けれど同時に、この構造を理解すれば抜け出す方法も見えてくる。言語化すること、小さく始めること、遊ぶこと、不完全でも動くこと。これらは全て才能ではなく訓練可能な技術で、動けない理由を言語化できれば、動くための方法も見えてくる。「なんか不安」と思ったとき、立ち止まって「何が不安なのか」と問いかけるようになった。その答えを、怖くても、恥ずかしくても、認めたくなくても、言葉にするようになった。そうすると不思議なことに動けるようになって、言葉にしてしまえば思ったより大したことなかったりして、「こんなことで止まっていたのか」と拍子抜けするほどで、でも、言葉にしない限り、その「こんなこと」は永遠に巨大な壁であり続ける。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。三つの声いろんな彼というか昔の僕から動けない理由を聞くと、大きく三つのパターンに分かれる。正確には、休憩時間や終了後に雑談をしていて「今日はどうだった？」と聞くと、こんな答えが返ってくる。「失敗したくない」という声がある。ワークショップである学生が「エラーが出たら、どうしていいか分からなくなるんです」と言った。その時は「エラーメッセージを読むといいよ」とアドバイスして終わったのだが、後になって考えた。彼が本当に恐れていたのはエラーそのものだったのだろうか。よく思い返してみると、彼は他の参加者を横目で見ていて「みんな進んでる」とも言っていた。つまり、エラーが出たときにそれを解決できない自分が露呈するのが怖かったのではないか。「このエラーの意味が分からない」「基礎的な知識が足りない」と認めることは、自分の無知を他者に見せることになる。他の参加者は解決できているかもしれないし、講師は当然知っている。その中で自分だけが分からない。失敗への恐怖は、実は無知の露呈への恐怖なのかもしれない。エラーそのものは怖くないが、エラーを通じて自分の能力の限界が可視化されることが怖い。だからエラーが出る前に完璧に準備しようとしてドキュメントを読み漁るが、どれだけ読んでも「完璧」には到達しない。そして永遠に始められない。「もっと良い方法があるはず」という声もある。別の学生は「このやり方で合っているのか分からなくて」と言った。その時の彼の画面を覗き込むと、Dockerfileが半分書きかけのまま止まっていた。「どうしたの？」と聞くと「ベストプラクティスを調べてて」と言い、ブラウザには10個以上のタブが開いていた。終わった後、もう少し話を聞いてみた。「何が一番困った？」「うーん、正解が分からなくて」。その「正解」という言葉が引っかかった。プログラミングに唯一の正解なんてあるだろうか。後で考えてみると、彼が求めていたのは「正解」ではなく「間違っていないという保証」だったのかもしれない。Dockerfileを書き始めて一行書いては止まり、「これは本当にベストプラクティスなのか」とブラウザに戻って「Docker ベストプラクティス」で検索する。いくつかの記事を読むと別のやり方が紹介されていて「どっちが正しいんだろう」とまた別の記事を読み、さらに別のやり方を見つける。最適解を求めるほど選択肢は増え、決断は遠のく。でもよく考えてみると、おかしなことを言っている。「最適解」は実際にやってみないと分からず、プロジェクトの要件やチームの習熟度、運用の制約といった文脈によって「最適」は変わる。にもかかわらず文脈なしで「最適解」を求めている。これは実は決断を先延ばしにするための言い訳なのかもしれない。なぜ決断を先延ばしにするのか。おそらく決断には責任が伴うからだ。「これで行く」と決めた瞬間、それが間違っていたときの責任を負うことになる。でも「まだ調べている」段階なら責任は発生せず、間違える可能性もなく、評価されることもない。完璧主義は行動の質の問題ではなく、存在の先延ばしの問題なのかもしれない。「周りの目が気になって」という声は、終わった後の雑談で最も正直に語られた。「質問すると『こんなことも知らないのか』と思われそうで」という学生は、ワークショップ中に何度もつまずいていて画面を見れば分かるのだが、質問もせず隣の人に聞くこともせずに、ただ黙って画面を見つめていた。「どうして質問しなかったの？」と聞くと、「みんな分かってそうな雰囲気で、自分だけ分かってないって思われたくなくて」と言った。でも実際には、後で他の参加者に聞いてみると同じところでつまずいていた人が何人もいたのだが、誰も質問しなかった。みんな同じことを思っていた。恥という感情の不思議なところは、実際の他者の反応ではなく想像上の他者の視線に縛られることだ。「こう思われるかもしれない」という想像がその行動を止めるが、その想像が現実と一致しているかは確かめられない。なぜなら行動していないから。三つの声の正体失敗したくない、もっと良い方法があるはず、周りの目が気になる。学生たちから聞いたこれらの言葉を一人になってから反芻していた。一見バラバラに見えるこれらの理由だが、丁寧に分解していくと共通した構造が見えてくる気がした。すべて恥への恐怖に行き着くのではないか。「失敗したくない」は無知を露呈したくない、つまり恥をかきたくないということであり、「もっと良い方法があるはず」は間違った選択の責任を負いたくない、つまりこれも恥の回避だ。「周りの目が気になる」はそのものズバリ、他者の視線という恥の源泉である。そしてさらに抽象化すると、三つの根源的な恐怖に還元される気がした。恥をかきたくない、損をしたくない、嫌われたくない。でも面白いことに、これらを具体的に言葉にした瞬間、その恐怖は不思議なほど小さく見える。「エラーメッセージの意味が分からないのが怖い」と言葉にすればそれは解決可能な課題になるし、「ベストプラクティスを知らないのが不安」と認めれば「じゃあまず動くものを作って後で改善しよう」という選択肢が見える。「質問して笑われるのが怖い」と明確にすれば、「実際に笑う人がいるのか？ いたとしてその人の評価を気にする必要があるのか？」と問い直せる。具体的に言葉にした瞬間、恐怖は相対化される。でも多くの人はこの言語化の一歩手前で止まっている。いくつになっても恥をかける人になる【DL特典 恥克服ワークシート】作者:中川諒ディスカヴァー・トゥエンティワンAmazon「なんか」の正体「なんとなく不安で」「どうも気が進まなくて」「なんか怖くて」。この「なんか」という言葉が問題だ。「なんか」で済ませている限り恐怖は輪郭を持たない。輪郭を持たない恐怖は無限の可能性として脅威を放ち続け、それは霧のように思考空間を覆って判断力を奪う。逆に言えば、恐怖を明瞭に言語化すればそれは相対化可能な「ひとつの感情」へと縮小する。言葉は混沌に秩序を与える。でも、なぜ人は言語化を避けるのか。試しに自分が動けない理由を紙に書き出してみるといい。「なぜこのタスクに取り掛かれないのか」を具体的に書き始めると手が止まる。なぜか。言語化とは「嫌な自分」と正面から向き合う行為だから。曖昧なままなら自己欺瞞の余地が残り、「本気出せばできる」「時間がないだけ」「環境が悪いだけ」とそう思い込んでいられる。でも一度言葉にしてしまえばもはや逃げ場はない。「基礎的なことを理解していない」と書けばそれは事実として目の前に現れ、「エラーメッセージを読み飛ばしている」と認めればその怠慢は言い逃れできなくなり、「質問する勇気がない」と言葉にすれば自分の臆病さと向き合わざるを得ない。だから人は言語化を避ける。でもこの回避こそが停滞を生み出す。言葉にできない感情は実体以上に巨大化し、漠然とした不安のまま放置すればそれはどんどん大きくなっていく。「なんとなく怖い」が「とても怖い」になり「絶対に無理」になる。未言語化の不安は輪郭を持たないがゆえに肥大化し、行動を麻痺させる。このポストは動けない人の構造を解剖しそこから抜け出すための実践について書いたものだ。抽象的な話に聞こえるかもしれないが、これは極めて実践的な話だ。なぜなら動けない理由を言語化できれば動くための方法も見えてくるからだ。ワークショップでドキュメントを読み漁る若者を見ながら、自分もかつてそうだったことを思い出す。そして今も新しい技術に触れるとき同じパターンに陥りそうになる。でも一つだけ変わったことがある。「なんか不安」と思ったとき立ち止まって「何が不安なのか」と問いかけるようになった。その答えを言葉にするようになった。そうすると不思議なことに動けるようになる。「なんか」の正体を一緒に言葉にしてみよう。人生のレールを外れる衝動のみつけかた (ちくまプリマー新書)作者:谷川嘉浩筑摩書房Amazonなぜこんなに変わりたいのに行動ができないのか動けない理由を剥いていくとワークショップの後、参加者たちと話していて気づいたことがある。動けない理由は人それぞれ違う言葉で語られるが、その言葉を一つ一つ剥いでいくと意外なほど似た構造が現れる。「失敗したくない」と言った学生に「何が失敗なの？」と聞いてみた。「エラーが出ることです」。「エラーが出ると何が困るの？」「解決できないからです」。「解決できないと何が困るの？」と重ねて聞くと、彼は少し黙って小さな声で言った。「他の人にできないやつだと思われるのが嫌なんです」。ああそうか。エラーが怖いのではなかった。自分で認めるのも嫌だけど、エラーを解決できない自分が他者に見られることが怖かったのだ。「もっと良い方法があるはず」と言った学生には「今のやり方の何が問題なの？」と聞いた。「うーん、間違ってるかもしれないから」。「間違ってると何が困るの？」「後で直すのが大変だから」。「本当にそれだけ？」と聞くと、彼も少し考えてこう言った。「間違ったやり方を選んだって知られたくないです」。ここでも他者の視線が出てきた。試しに動けない理由を「○○が怖い」という形に言い換えてみると、面白いことにだいたい三つに集約される。恥をかくのが怖い、損をするのが怖い、嫌われるのが怖い。これらを観察しているとある構造に気づく。すべての中心に「他者の視線」がある。恥は他者がいて初めて成立し、損も他者との比較で生まれ、嫌われるもそのものズバリ他者との関係だ。動けない理由を突き詰めていくと、思考の主語が「自分」ではなく「他人」になっている。恥という不思議な感情恥を恐れて動けないとき自分の思考を観察してみるといい。面白いことに気づく。思考の主語が「他人」になっている。「自分がどうしたいか」ではなく「他人にどう見られるか」、「これは面白いか」ではなく「これは評価されるか」と、判断基準の中心にいつの間にか他者の視線が居座っている。ワークショップでこんなことがあった。ある学生が自分で考えた実装方法を試そうとしていたが、途中で手を止めて「これ間違ってるかもしれない」と言ってブラウザでベストプラクティスを検索し始めた。「さっきの方法試してみたら？」と声をかけると、「でももし間違ってたら恥ずかしいです」と言った。誰に対して？よく考えてみるとおかしな話だ。ワークショップは学ぶ場所で間違えるために来ているのに、彼は間違えることを恥だと感じていた。恥という感情は本質的に社会的なものだ。一人で山に籠もって生きているなら恥という感情は存在せず、恥は他者の視線があって初めて成立する。だから恥を避けようとすればするほど自分の判断基準は外部に移っていく。「自分はこれを試してみたい」ではなく「これは他者に評価されるか」、「自分はこれが面白い」ではなく「これは正しいと思われるか」となる。これは「外部評価への依存」というきわめて脆弱な存在様式だ。なぜ脆弱なのか。他者の評価はコントロールできないからだ。どれだけ頑張っても他者がどう評価するかは分からず、評価を気にすればするほどその不確実性に振り回される。さらに皮肉なことに恥を避けようとしてもっと深刻な状態に陥る。「失敗」という一時的な出来事を避けようとして「停滞」という持続的な状態に陥る。一瞬の恥を避けるために何ヶ月も何年も同じ場所に立ち止まる。でもこの事実に気づくのはいつも後になってからだ。停滞している最中は自分が停滞していることにすら気づかず、「準備している」「勉強している」「タイミングを見計らっている」とそう言い聞かせながら過ごす。恥を避けることに内的エネルギーを費やすほど自己の内側は空洞化していく。他者の評価を内面化し自分で自分を監視する。自己評価の基準が外部にあるときそこにはもう自己は存在しない。「完璧」という呪い「完璧に準備してから始める」という言葉は合理的に聞こえるが、ワークショップでこの言葉を聞くたびある疑問が浮かぶ。「完璧」って何だろう。ある学生はワークショップ開始前に2時間ドキュメントを読んでいて「準備したい」と言っていたが、実際にコンテナを立ち上げることはなかった。「どこまで準備したら始められそう？」と聞くと「全部理解してから」と言った。全部。でも「全部」って何だろう。Dockerの全ての機能を理解する？ Kubernetesの全てのコンポーネントを理解する？ そんなことは実務で何年も使っているエンジニアでも無理だ。つまり「完璧に準備してから始める」は実質的に「決して始めない」と同義だ。よく考えてみるとおかしなことを言っている。完璧に準備するとは何か。すべてを理解してから始めるということだが、すべてを理解するには実際にやってみるしかなく、やってみないと分からないことは必ずある。ドキュメントに「Podは一つ以上のコンテナを含む」と書いてあれば読めば理解できるが、実際にyamlを書いてkubectl applyしてエラーが出てそのエラーメッセージと格闘して、初めて本当に理解できる。理論的な理解と体験的な理解は違う。「完璧に準備してから」と言う人は実は理論的な理解だけで完璧になれると思っているが、それは不可能だ。体験なしに理解は完成しない。では、なぜ人は「完璧に準備してから」と言うのか。これは行動の質の問題ではなく存在の先延ばしの問題だ。不完全な自分を世界に晒すことへの恐怖、評価されることへの恐怖、そしてその根底にはやはり恥がある。完璧主義は恥への防衛機制として機能し、「準備不足だから失敗した」という言い訳をあらかじめ用意しておく。決して完成しないものは決して評価されず、評価されなければ恥もかかない。求めるほど遠のくという逆説がここにある。完璧を求めるから行動できず、行動しないから経験が積めず、経験がないから完璧からは遠のき、そしてさらに完璧を求める。この悪循環。ワークショップである学生が最後に「結局何も完成しませんでした」と言った。でも彼は多くのことを学んだはずだ。エラーメッセージの読み方、yamlの書き方、kubectlのコマンド。不完全でも多くのことを試した。「完成しなかったけど学んだことはたくさんあったんじゃない？」と言うと少し考えて「そうですね。でも完成させたかったです」と言った。完璧主義者が見落としているのは小さな一歩の価値だ。不完全でも動いた一歩と完璧を求めて動かなかったゼロ。どちらが自分を前に進めるか。答えは明白なのになぜか後者を選んでしまう。不完全主義　限りある人生を上手に過ごす方法作者:オリバー・バークマンかんき出版Amazon言葉にできない不安の正体「なんとなく不安で」「どうも気が進まなくて」「なんか怖くて」という言葉を休憩時間によく聞く。「どうして手を動かさないの？」と聞くと「なんとなく」と返ってくる。この「なんか」「なんとなく」という言葉が実は重要な意味を持っている。試しに「なんとなく不安」と言った学生に「何が不安なの？」と聞いてみた。「うーん、なんか」。「例えば？」「分からないです」。言葉にできない。でもこれは語彙力の問題ではなく言語化を避けているという選択の問題だ。なぜそう思うか。別の機会に同じ学生にもう一度少し角度を変えて聞いてみた。「もし今コンテナを立ち上げようとしたら何が起きると思う？」すると意外なほど具体的な答えが返ってきた。「エラーが出ると思います。そのエラーの意味が分からなくてどうしていいか分からなくなって時間ばかりかかって結局できなくて周りの人に遅れて」。ああ言葉にできるじゃないか。彼は自分の不安を言語化できないのではなく、言語化したくなかっただけだ。なぜか。言葉にできない感情は実体以上に巨大化する。「なんとなく不安」のままならその不安の正体は確定しないが、「エラーの意味が分からないのが怖い」と言葉にした瞬間それは具体的な課題になってしまい、具体的な課題になればそれに対処しなければならなくなる。言語化とは「嫌な自分」と正面から向き合う行為だから。「エラーメッセージの意味が分からない」と認めることは自分の知識不足を認めることであり、「基礎が理解できていない」と言葉にすることは自分の勉強不足を認めることであり、「質問する勇気がない」と明確にすることは自分の臆病さを認めることだ。曖昧なままなら自己欺瞞の余地が残り、「本気出せばできる」「時間がないだけ」「環境が悪いだけ」とそう思い込んでいられるが、一度言葉にしてしまえばもはや逃げ場はない。だから人は言語化を避ける。でもこの回避こそが停滞を生み出す。輪郭を持たない恐怖は無限の可能性として脅威を放ち続ける。それは霧のように思考空間を覆って判断力を奪い、「なんとなく怖い」が「とても怖い」になり「絶対に無理」になる。未言語化の不安は輪郭を持たないがゆえに肥大化し行動を麻痺させる。逆に言えば恐怖を明瞭に言語化すればそれは相対化可能な「ひとつの感情」へと縮小する。「エラーメッセージの意味が分からないのが怖い」と言葉にした瞬間それは解決可能な具体的課題になる。言葉は混沌に秩序を与える。言葉を持つことは自由を獲得することに等しい。言語化は自己認識の解像度を上げる行為であり、内面の混沌を構造化し恐怖を名指すことで相対化する力。それが言語化の力だ。「無理」の構造 ―この世の理不尽さを可視化する作者:細谷 功dZEROAmazon「才能」という最も便利な逃げ道そして最後にすべてを覆い隠す魔法の言葉がある。「才能がない」。ワークショップの最後ある学生が「自分には向いていないかもしれません」と言った。「どうしてそう思うの？」と聞くと「他の人より理解が遅いから」と言った。でも観察していて気づいたことがある。彼は理解が遅いのではなく理解しようとしていなかったのだ。エラーメッセージが出てもちゃんと読んでいなかった。「Expected type X, but got type Y」と明確に書いてあるのに「type X」という文字列だけを拾って、期待される型と実際の型が違うという関係性を読み取っていなかった。ドキュメントを「読んでいる」と言いながら実際には流し読みしていて、主語と述語を把握せず「誰が」「誰に」「何を」しているのかという基本的な構造を理解しないまま「なんとなく」で進めようとしていた。仮説を一つずつ潰すのではなく「ネットワークの問題かもしれない」「データベースの問題かもしれない」と複数の仮説を同時に追いかけてどれも中途半端に確認していた。これは才能の問題ではなくプロセスの問題だ。エラーメッセージをちゃんと読む、仮説を一つずつ潰す、主語と述語を把握する。誰でもできることだ。でもこの「小さなこと」を飛ばしているから「理解が遅い」ように見える。そしてこの事実から目を逸らすために「才能」という言葉を使う。「才能がない」という言葉は根深い自己欺瞞であり最も便利な逃避だ。なぜなら才能という言葉を使った瞬間、人は変化の可能性を放棄できるからだ。「才能がないからできない」は「努力してもどうせ無理」と同義で、成長のための努力そのものが無意味に思える。そして才能という言葉はすべてを覆い隠す。恥への恐怖を覆い隠し完璧主義を正当化し言語化を避ける。基礎プロセスを飛ばしていることも努力を怠っていることもすべて「才能」という一言で片付けられる。才能という言葉を使った瞬間思考は停止する。でも観察していると分かる。「才能がある」ように見える人も実は同じプロセスを踏んでいる。エラーメッセージをちゃんと読み仮説を一つずつ潰し主語と述語を把握している。ただそれだけだ。違いはそのプロセスを意識的に実践しているかどうかであり、それは訓練可能だ。前のポストで書いたように技術力は経験の蓄積とセンスから成り立ち、そしてどちらも訓練可能だ。センスとは突き詰めれば「何に注目するか」という習慣と「それを面白がれるか」という姿勢だ。でも「才能」という言葉を使えばこうした具体的な分析も具体的な対策もすべて放棄できる。恥への恐怖、完璧主義、言語化の欠如。そのすべてを「才能」という一言で説明する。これが動けない人が抱える最後の砦だ。HIDDEN POTENTIAL 可能性の科学――あなたの限界は、まだ先にある (三笠書房　電子書籍)作者:アダム・グラント三笠書房Amazon動くための小さな一歩言葉にしてみるという勇気まず自分の恐怖を具体的に正直に言語化してみる。ワークショップの終わりにこんな提案をしてみた。「今日動けなかった理由を紙に書いてみて」。最初は戸惑った顔をしていた参加者たちだが何人かが書き始めた。ある学生が書いたのは「エラーが出たときに解決方法が分からなくて周りに遅れるのが嫌だった」という文章だった。書き終わって彼はその紙をじっと見ていて「あれこんなことだったのか」と言った。言葉にした瞬間不思議なことが起きる。恐怖が相対化され「ああこんなことで止まっていたのか」という気づきから「じゃあどうすればいいか」という具体的な対策が見えてくる。「エラーが出たときに解決方法が分からない」なら「じゃあエラーメッセージの読み方を学ぼう」となり、「周りに遅れるのが嫌」なら「でもこれは学ぶ場所だ。遅れても構わない」となる。抽象的な不安は具体的な課題へと変換され、具体的な課題は具体的な対策で解決できる。「恥をかきたくない」だけではまだ抽象的だ。もう一歩踏み込んで「このコードをレビューに出したら基礎的な部分の知識不足を指摘されるのが怖い」とここまで具体的にする。すると「じゃあ基礎的な部分を先に学べばいい」という対策が見え、「レビュー前に自分でチェックリストを作ればいい」という方法が浮かび、「そもそも指摘されることは学びのチャンスだ」という視点が得られる。言語化は勇気の技術であり嫌な自分と向き合う技術だが、その一歩がすべてを変える。さみしい夜にはペンを持て作者:古賀史健ポプラ社Amazon現代人が失ったものただ言語化を阻むものは個人の内側だけにあるわけではなく、現代という時代そのものが言語化を難しくしている。ワークショップの休憩時間、参加者たちの多くがスマホを見てTwitterやInstagramをスクロールしLINEに返信しYouTubeのショート動画を見る。私たちは今インスタントで断片的な刺激に取り巻かれている。即座の返信、短い動画、分かりやすい解説とスマホを持つことで即時的な満足にいつでもアクセスでき、「消化しきれなさ」「難しさ」「モヤモヤ」といった時間もコストもかかるものは避けられるようになった。技術ドキュメントを読むことはまさにこの「モヤモヤ」との戦いだ。Kubernetesの公式ドキュメントを開いても一読してすぐに理解できるものではなく、分からない用語が出てきてそれを調べるとさらに分からない概念が出てくる。読み返し実際に試しエラーが出てまた読み返す。この時間のかかるプロセスがインスタント化した感覚に慣れた私たちには耐えがたい。だからすぐに生成AIに「KubernetesのServiceとは何ですか？要約して」と聞く。確かに分かりやすい説明が返ってきてスッキリする。でもその過程で失われるものがある。モヤモヤした状態を抱えたまま読み続け試し続けることでしか到達できない深い理解。断片的な知識ではなく体系的な理解。これは要約では得られない。ある学生がワークショップで「生成AIで調べたんですけど実際にやってみるとうまくいかなくて」と言った。よく見ると生成AIの説明を鵜呑みにしてその背後にある前提条件を理解していなかった。「この設定はこういう環境を前提としています」という部分を読み飛ばしていた。生成AIは便利なツールだが使い方を間違えると理解の機会を奪う。同時にスマホによる常時接続は孤独を奪った。ワークショップ中少し難しい課題に取り組んでいるときすぐにスマホに手が伸びて「ちょっと休憩」と言ってTwitterを開く。退屈に耐えきれず何か刺激を求めてスマホをいじる。一人でドキュメントと向き合う時間一つのことに没頭する孤立。このシンプルな行為が驚くほど難しくなっている。でも言語化には孤独が必要で、自分の内側と向き合うには外部の刺激から離れる必要がある。そしてもう一つ、ネガティブ・ケイパビリティの欠如だ。これは「結論づけずモヤモヤした状態で留めておく能力」のことで、把握しきれない謎をそのまま抱えておく力だ。新しい技術を学ぶときすぐに「わかった」と思いたくなるが実際にはわかっていないことだらけで、この不確実性に耐える力が現代人には欠けている。ワークショップでこんなことを言う学生がいた。「全部理解してから次に進みたいんです」。でも「全部理解する」なんて不可能だ。理解は何度も行ったり来たりしながら螺旋を描くように深まっていく。最初は30%の理解、実際に使ってみて50%、エラーと格闘して70%、また別の文脈で使って80%。理解は一度で完成しない。でもこのモヤモヤした状態に耐えられずすぐに「分かった」と結論づけたいために生成AIに「簡潔に説明して」と頼む。簡潔な説明は確かに分かりやすいが、その分かりやすさは複雑さを削ぎ落とした結果で、削ぎ落とされた部分にこそ本質が隠れていることもある。学びとは何か－〈探究人〉になるために (岩波新書)作者:今井 むつみ岩波書店Amazon生成AIという新たな逃避ChatGPTやClaudeの登場は学習の風景を変えそして新しい逃避の道を開いた。停滞のパターンはこうだ。エラーが出て生成AIに「このエラーどう直す？」と聞き答えが返ってコピペして動いて「解決！」となる。これは答えは得られるが理解は得られず、次に同じエラーに遭遇したときまた同じことを繰り返す。ワークショップで何度も同じパターンを見た。学生がエラーに遭遇してすぐに生成AIに聞き答えをコピペし次のエラーでまた聞きまたコピペする。三回目に同じようなエラーが出たとき彼は気づいていなくて「あれさっきも似たようなエラーが出たな」という記憶がない。なぜか。自分で考えていないからだ。エラーメッセージを読んでいない。なぜそのエラーが出たのか理解しようとしていない。答えは得られるが学びは得られない。混乱したときすぐに生成AIに頼ると不快感と向き合う機会が失われる。でもこの不快感こそが深い理解への道なのに。成長のパターンはこうだ。まず自分で理解しようとしてエラーメッセージを読みドキュメントを読み仮説を立てて試す。それでも分からなかったら自分なりの理解をまとめる。その上で生成AIに「私はこう理解したが合ってる？」と質問する。先に自分で考えて生成AIは「答えを教える」のではなく「理解を確認する」役割にする。あるいは「このエラーが出た。なぜこのエラーが出るのか仕組みから説明して。直し方は教えなくていい」と聞いて表面的な解決策ではなく根本的な理解を得る。ワークショップでこの方法を試した学生がいた。最初は時間がかかったが、三回目に似たようなエラーが出たとき彼は自分で解決できて「ああこれはあの時と同じパターンだ」と言った。理解があれば応用が効く。生成AIとの付き合い方には四つの落とし穴がある。一つ目は思考の外部化で考えるべきことを全て生成AIに任せてしまうこと。二つ目は流暢性の錯覚で、生成AIの説明は分かりやすいが自分でコードを書こうとすると書けず「分かった気」になっているだけ。三つ目は最適な難易度を見失い自分の理解レベルに合わない質問をしてしまい、基礎を理解していないのに応用的な質問をする。四つ目は不快感から逃げることで、混乱したときモヤモヤしたときすぐに頼ってしまうがその不快感こそが成長の証なのに。重要なのは自分の頭で考え手を動かし不快感と向き合うことで、これは生成AIがなかった時代もある時代も変わらない真実だ。そしてこれも才能の問題ではなく習慣の問題だ。生成AI「戦力化」の教科書作者:松本 勇気日経BPAmazon遊ぶことから始まる恥を恐れ完璧を求め言語化から逃げる。この三つが絡み合って人を動けなくする。一つの答えは遊ぶことだ。ワークショップでこんな提案をしてみた。「次の30分何も見ずにとりあえず動かしてみて」。「えっドキュメント見なくていいんですか？」と驚く学生たちに「いいよ。適当にやってみて。エラーが出ても気にしない。とにかく何か動かしてみる」と答えた。最初は戸惑っていたが徐々に表情が変わってきて「あこれ動いた」「このオプション何だろう」「試してみよう」となった。遊びには「正解」がないから失敗を恐れる必要がない。評価されることもなくただ面白いからやり好奇心のままに試す。この心理的な自由が試行錯誤を促進する。30分後何人かの学生が予想外のものを作っていた。「Nginxのコンテナを3つ立ち上げてそれぞれ違うページを表示させてみました」。ドキュメント通りではないが動いていて彼は楽しそうだった。「どうやって作ったの？」と聞くと「分からないままとりあえず書いてみたら動いたんです」と言った。この「なんとなく」が実は重要なのだ。理論を学ぶ前に体験を通じた直感的理解が生まれる。後に理論を学ぶとき「あああの時の『なんとなく』はこういうことだったのか」と腑に落ちる。プログラミングを学び始めた頃を思い出してほしい。「とりあえず動かしてみよう」と思ってよくわからないままコードを書いた経験はないだろうか。エラーが出て何が悪いのかわからないが、いろいろいじっているうちになんとなく動いた。遊びは内発的動機を育てる。「やらなければならない」ではなく「やりたい」という動機で、これは強制では生まれない。自分で選んで自分のペースで面白いと思うことをやる過程で内発的動機が育つ。失敗への耐性も生まれる。遊んでいるとき失敗は「失敗」ではなくただの「結果」だ。「あこうするとこうなるんだ」という発見と次は別の方法を試してみようという好奇心。多くの人は学びを始めるときいきなり「正しいやり方」を覚えようとして教科書を読みチュートリアルを見る。でもこれは実は難しい。なぜなら「なぜその型が重要なのか」がわからないまま形だけを真似ようとするから。型の意味を理解するにはその型がない状態を経験する必要がある。だからまず遊ぶ。制約なく好奇心のままに試して失敗を恐れず楽しむ。ここで少し逆説的なことを言いたい。特に若い時期には根拠がなくても自分を信じることが重要だ。「これが本当に正しい道なのか」「自分に向いているのか」。そんな冷静な自己分析ばかりしていると一歩も踏み出せなくなる。時には根拠のない自信を持って盲信的に突き進むことも必要だ。「Kubernetesなんて簡単だろう」というある意味で無知ゆえの大胆さ。この「若気の至り」とも言える姿勢が最初の一歩を踏み出させてくれる。ワークショップで最も早く理解した学生に「なんでそんなに迷わず進めるの？」と聞いてみた。彼は少し考えて「分からないけどとりあえずやってみたら分かるかなって」と言った。根拠のない自信だがその自信が彼を動かした。実際に動いた結果本当に理解した。その盲信的な姿勢がいつか本当の自信に変わり、根拠のない自信が実績という根拠を伴った自信になる。気づけば最初は「嘘」だった「自分はできる」という言葉が本当になっている。完璧主義を捨ててまず遊ぶ。型を学ぶのはその後でいい。熟達論―人はいつまでも学び、成長できる―作者:為末大新潮社Amazon小さく、完璧でなくても、動く停滞と努力の違いを理解することも重要だ。ワークショップである学生がKubernetesのServiceの概念に数日苦しんでいて、彼は毎日同じドキュメントを読み返していた。「努力している」と本人は言ったが彼は前に進んでいなかった。よく話を聞くと彼はそもそもネットワークの基礎を理解していなかった。IPアドレスとは何かポートとは何かDNSがどう動くのか。こうした土台がないままKubernetesの抽象的な概念を理解しようとしていた。難しい問題に直面したとき人は二つの道を選ぶ。一つは理解できないまま同じ説明を何度も読み返し同じ場所でぐるぐると回り続けること。もう一つは「何が分からないのか」を見極めてまずそこから順番に理解していくこと。前者を停滞と呼び後者を努力と呼ぶ。停滞している人はしばしば自分が努力していると思っている。長時間向き合い何度も試している。でも実際には前提となる知識が欠けたまま同じところで足踏みを繰り返しているだけ。「Serviceが分からない」と言っていた学生に「じゃあまずネットワークの基礎から学ぼう」と提案すると最初は不満そうで「それは遠回りじゃないですか」と言った。でも基礎から学び始めて3日後彼は突然Serviceを理解して「ああそういうことか！」と言った。本当の意味での努力とは今の自分が理解できるところから始めること。Kubernetesが難しいならまずネットワークの基礎から。ネットワークが難しいならまず自分のPCで2つのプログラムを通信させることから。この段階を踏んだ学び方こそが努力の本質だ。学習には三つのゾーンがある。コンフォートゾーンはすでに理解していることを繰り返す状態で簡単すぎて新しい学びがない。パニックゾーンは現在の理解からかけ離れていて難しすぎて何から手をつければいいかわからない。学習ゾーンは少し難しいが頑張れば手が届き既存の知識を応用すればなんとか理解できる。「才能がない」と感じているとき実はパニックゾーンに突っ込んでいるだけかもしれない。基礎を理解していないのに応用に挑戦し前提知識がないのに高度な概念を理解しようとする。当たり前だがこれは無理だ。才能の問題ではなく順序の問題だ。不快感を恐れないことも重要だ。学習において最も反直感的な真実の一つはある種の困難は実は学習を改善するということだ。同じチュートリアルの再読、すでに動くコードの微調整、すぐに答えを探すこと。これらは確かに楽だが長期的な学習効果は低い。なぜか。脳は情報を取り出すのに苦労すること自体でその情報への神経経路を強化するからだ。簡単すぎる復習ではこの「取り出す苦労」が発生せず記憶が強化されない。効果的な方法は少し忘れかけたタイミングで復習すること。概念を学び1日空けて何も見ずに説明しようとし思い出せない部分を確認する。難しく忘れかけていて思い出すのに苦労するがこの苦労こそが記憶を強化する。新しい概念を学ぶとき混乱は不快で「もう無理だ」と思う。でもこの不快感こそが成長の証なのだ。脳が新しい構造を構築しようとしている証で既存の理解の枠組みが崩れ新しい理解が生まれつつある証だ。この不快な状態を抱えたまま学び続け逃げずに向き合う。ある日突然繋がる。その瞬間の爽快感はすべての苦労を報いてくれる。「快適ならやり方が間違っている」という言葉がある。本当の成長は常にコンフォートゾーンの外側で起きる。最後にエラーメッセージをちゃんと読み仮説を一つずつ潰し主語と述語を把握する。こうした小さなこと。ワークショップの最後にある学生が「エラーメッセージちゃんと読んだらちゃんと書いてありました」と言った。当たり前のことだがこの当たり前のことができていない人は驚くほど多い。めんどくさいと感じるかもしれないがこの「めんどくさい」基礎作業を飛ばすから結果的に何倍も時間がかかってしまう。才能があるように見える人はこれらを実践しているだけで意識的か無意識的に。これらは訓練可能だ。小さく始める。不完全でも動く。その積み重ねだけだ。エンジニアという仕事には一つの大きな救いがある。それは手を動かしている間才能への不安が消えるということだ。「自分には才能がない」という悩みは頭の中でぐるぐる回り始めるとどんどん大きくなるが「これを作りたい」と思って実装を始めた瞬間その悩みはどこかに消える。目の前にあるのは具体的な問題だけだ。エラーが出て調べて解決してまた詰まってまた調べる。この「詰まる→調べる→解決する」のサイクルを回すこと自体が静かに自信を育てていく。理解の速さには個人差がありこれは残酷な現実だが、人生という長い時間軸で見たときこの速さの差は思ったほど大きくない。むしろ一歩ずつでも前に進み続けた人と途中で立ち止まってしまった人の差の方がはるかに大きい。時間は誰にも平等だ。その時間を「理解できない問題の前での空回り」に使うか「今理解できることから順に積み上げていく前進」に使うか。この選択が長期的には想像もできないほどの差を生む。ぐちゃぐちゃ考える暇があったら手を動かす。才能について悩む時間を1行でも多くコードを書く時間に変え、理想の自分について考える時間を作りたいものを作る時間に変える。その積み重ねが気づけば「成長」と呼ばれるものになっている。心理的安全性　最強の教科書作者:ピョートル・フェリクス・グジバチ東洋経済新報社Amazonおわりにワークショップで出会った学生の一人が最近こんなメッセージを送ってきた。「ちゃんと読むようになったら解決が早くなりました」。彼は以前「才能がない」と言っていたが実際にはエラーメッセージを読み飛ばしていただけだった。その事実を言語化し意識的に「ちゃんと読む」ようにした。それだけで解決速度は変わった。些細なことだがその些細なことに気づくまで私は何年もかかった。このポストで繰り返し述べてきたように動けない理由は言葉にしてしまえば驚くほど小さい。恥を恐れていて完璧を求めすぎていて「なんか不安」を「なんか」のまま放置していて、そして「才能がない」という誰も反論できない理由で全てから逃げていた。言葉にした瞬間それらは「対処可能な課題」に変わる。でも言葉にするまでが驚くほど難しい。なぜなら嫌な自分と向き合わなければならないから。ワークショップを三年続けて一つ確信したことがある。最初は速かったのに途中で離れていった人たちがいて最初は遅かったのに黙々と続けている人たちがいる。三年後後者の方が圧倒的に前に進んでいる。「才能」という言葉を使った瞬間思考は停止する。でも「エラーメッセージを読み飛ばしている」と言語化した瞬間「じゃあちゃんと読めばいい」という対策が見える。そのシンプルな事実に気づくかどうか。それだけの差が長い時間をかけて想像もできないほど大きな差になる。syu-m-5151.hatenablog.com未熟な自分がワークショップを始めて三年。今でも不安はあり「自分なんかが教えていいのか」と思うこともある。でも若手と一緒に作業する中で気づいた。彼らが必要としているのは全てを知り尽くした完璧な指導者ではない。「才能」という便利な言葉で可能性を閉ざさず「じゃあどうすればいいか」を一緒に考える誰かだ。そしてそれは自分自身に対しても同じだと思っている。「読んでいる自分は頑張っている気がする」という謎の達成感に私たちはいつまで浸っているのだろうか。本当に必要なのは手を動かすこと。小さく完璧でなくてもでも確実に前に進むこと。言葉にしない限り「なんか」は永遠に巨大な壁であり続けるが、言葉にしてしまえば思ったより大したことなかったりする。その一歩を踏み出すかどうか。結局それだけの話だ。","isoDate":"2025-11-01T03:00:27.000Z","dateMiliSeconds":1761966027000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"近すぎず、遠すぎず - コードの結合度とちょうどいい距離の測り方","link":"https://syu-m-5151.hatenablog.com/entry/2025/10/31/125256","contentSnippet":"はじめに人間関係が数値化できればなぁって思ったこともありますか？僕はあります。「この人とは、ちょうどいい距離感だな」とか、「もうちょっと親しくなりたいけど、近づきすぎると息苦しいかもしれない」とか。そういう、言葉にしづらい感覚を、もし数字で表せたら——なんて。コードを書いているとき、似たようなことを考える。「このモジュールとあのモジュール、近すぎるな」と思う瞬間がある。あるいは逆に、「これ、もっと近くにあった方がいいんじゃないか」と。モジュール同士の距離感。誰もが一度は悩んだことがあるはずだ。近すぎても、遠すぎてもいけない。でも、「ちょうどいい」って、どういうことだろう。バグを修正したときのことだ。直接的には関係ないはずの、別の場所が壊れる。そんな経験、ないだろうか。それは、見えない糸が張り巡らされている証拠だ。データの持ち方への暗黙の依存。前提条件。実行順序。そういう、目に見えにくい結合が、コードのあちこちに潜んでいる。大切なのは、結合をゼロにすることじゃない。そんなことは、できない。むしろ、適切にバランスさせることだ。人間関係と同じように。Vlad Khononov が書いた「Balancing Coupling in Software Design」という本がある。この本は、結合度を測るための、実践的なフレームワークを提供している。結合の強さ、距離、そして変更の頻度——この3つの軸。これで測る。バランスを評価する。この本が教えてくれることがある。機能は線形に増える。でも、複雑さは指数関数的に膨れ上がる。そして、僕たち人間には認知的な限界がある。だから、複雑さに対処するには、システムの形を変えるしかない。そのための道具が、結合なのだ。この記事では、その概念を Rust プロジェクトに適用してみる。実際に測定して、分析できるツールを作る。コードの「ちょうどいい距離感」を数値化し、可視化する。そんな試みである。Balancing Couplingの核心概念ソフトウェア設計の結合バランス　持続可能な成長を支えるモジュール化の原則 (impress top gearシリーズ)作者:Vlad KhononovインプレスAmazon3つの次元で結合度を測るすごく端的に話すとKhononov のフレームワークは、結合度を 3 つの軸で評価する。1. Integration Strength（統合強度）コンポーネント間で共有される知識の量。次の 4 つのレベルに分類される。Intrusive Coupling（侵入的結合）- 内部実装の詳細に依存Functional Coupling（機能的結合）- 共有された責任による依存Model Coupling（モデル結合）- ビジネスドメインモデルの共有Contract Coupling（契約結合）- インターフェース/トレイトによる抽象化下に行くほど結合が弱く、望ましい。2. Distance（距離）依存関係がどれだけ離れているかを測る。同じ関数内同じモジュール内異なるモジュール異なるクレート異なるサービス（マイクロサービスの場合）距離が遠いほど、変更のコストが高くなる。3. Volatility（変動性）コンポーネントの変更頻度を示す。Core Subdomain（コアサブドメイン）- 高頻度で変更Supporting Subdomain（サポートサブドメイン）- 中程度の変更Generic Subdomain（汎用サブドメイン）- 低頻度の変更バランスの公式これらを組み合わせた「バランスの方程式」は、概念的には次のように表現できる。BALANCE = (STRENGTH XOR DISTANCE) OR NOT VOLATILITY概念の解釈MODULARITY = STRENGTH XOR DISTANCE強い結合なら距離を近く（局所性を保つ）弱い結合なら距離を遠くても良い（疎結合）この 2 つのパターンが理想的BALANCE = MODULARITY OR NOT VOLATILITYモジュラーである、または変動性が低い（安定している）どちらかの条件を満たせばバランスが取れている数値計算への変換実装では、論理演算を数値計算に変換する。XOR - 両極端（強×近、弱×遠）の和として計算OR - 最大値（max）として計算NOT - 補数（1.0 - x）として計算ここで押さえておきたいのは、結合をゼロにするのが目的ではないということ。適切にバランスさせることが肝心で、コンテキストに応じて最適な形を選ぶ必要がある。Connascence（共依存性）結合度をさらに細かく分析するには、Meilir Page-Jones が提唱した「Connascence」の概念が役立つ。Static Connascence（静的共依存性）コンパイル時に検出可能なもの。Connascence of Name（CoN）- 名前への依存Connascence of Type（CoT）- 型への依存Connascence of Meaning（CoM）- 値の意味への依存Connascence of Position（CoP）- パラメータ順序への依存Connascence of Algorithm（CoA）- アルゴリズムへの依存Dynamic Connascence（動的共依存性）実行時に検出されるもの。Connascence of Execution（CoE）- 実行順序への依存Connascence of Timing（CoT）- タイミングへの依存Connascence of Value（CoV）- 値の同期的変更への依存Connascence of Identity（CoI）- 同一インスタンスへの依存動的共依存性は、最も弱いものでも、最も強い静的共依存性よりも強い結合を意味する。Rustにおける既存ツール1. cargo-modulesモジュール構造と依存関係を可視化できる。https://crates.io/crates/cargo-modulescrates.ioインストール:cargo install cargo-modules使い方:# モジュール構造をツリー表示cargo modules structure# モジュール間の依存関係をグラフ表示cargo modules dependencies# 循環依存の検出cargo modules dependencies --acyclic# 孤立したファイルの検出cargo modules orphans特徴:モジュール階層の視覚化循環依存の検出（リファクタリングの重要な手がかり）未使用ファイルの発見GraphViz と連携可能2. rust-code-analysisMozilla が開発した、多言語対応のコードメトリクス計測ツール。github.comインストール:cargo install rust-code-analysis-cli使い方:# 単一ファイルの分析rust-code-analysis-cli --metrics -p src/main.rs# プロジェクト全体の分析rust-code-analysis-cli --metrics -p ./src# JSON形式で出力rust-code-analysis-cli --metrics -O json -o metrics.json -p ./src計測可能なメトリクスCC (Cyclomatic Complexity) - 循環的複雑度COGNITIVE - 認知的複雑度HALSTEAD - Halstead メトリクス（Bugs, Difficulty, Effort, Volume 等）LOC 系 - SLOC、PLOC、LLOC 等NOM - メソッド数NARGS - 引数の数NEXITS - 出口の数WMC - クラスごとの循環的複雑度の合計Rust コードの複雑度を他言語と比較する研究でも使用されており、信頼性が高い。3. cargo treeCargo 組み込みの依存関係ツリー表示コマンド。doc.rust-lang.org使い方:# 依存関係ツリーの表示cargo tree# 深さを制限cargo tree --depth 1# 特定のパッケージを除外cargo tree --prune serde# 重複する依存関係を表示cargo tree --duplicates# リバース依存関係（何がこのクレートに依存しているか）cargo tree --invert \u003cpackage-name\u003e4. その他の有用なツールcargo-deps - GraphViz DOT ファイルを生成cargo-depgraph - 視覚的な依存関係グラフtokei - コード統計（行数、言語別集計）cargo-deny - 依存関係のポリシー検証Balanced Couplingを測定するカスタムツールの実装既存ツールは有用だが、Khononov のモデルを直接適用するには限界がある。特に、Integration Strength の分類、Dynamic Connascence の検出、Git 履歴との連携、Balance Score の計算といった機能が不足している。これらを測定するため、カスタムツールを実装していこう。基本的なアプローチ必要な依存関係を Cargo.toml に追加します。[dependencies]syn = { version = \"2.0\", features = [\"full\", \"visit\"] }quote = \"1.0\"walkdir = \"2.4\"thiserror = \"2.0\"実装例です。use syn::{visit::Visit, ItemFn, ItemImpl};/// 結合度メトリクスを保持する構造体////// Integration Strength、Distance、Connascenceの3つの次元を測定#[derive(Debug, Default, Clone)]pub struct CouplingMetrics {    // Integration Strength    pub intrusive_count: usize,    pub functional_count: usize,    pub model_count: usize,    pub contract_count: usize,    // Distance    pub same_module: usize,    pub cross_module: usize,    pub cross_crate: usize,    // Connascence    pub name_coupling: Vec\u003cString\u003e,    pub type_coupling: Vec\u003cString\u003e,    pub position_coupling: Vec\u003cString\u003e,}/// ASTを訪問して結合度を分析するアナライザー#[derive(Debug)]pub struct CouplingAnalyzer {    pub metrics: CouplingMetrics,    pub current_module: String,}impl CouplingAnalyzer {    /// 新しいアナライザーを作成    ///    /// # Arguments    /// * `module_name` - 分析対象のモジュール名    fn new(module_name: String) -\u003e Self {        Self {            metrics: CouplingMetrics::default(),            current_module: module_name,        }    }    /// 関数シグネチャを分析してConnascence of Positionを検出    ///    /// # Arguments    /// * `sig` - 分析対象の関数シグネチャ    fn analyze_function_signature(\u0026mut self, sig: \u0026syn::Signature) {        // 引数の数をチェック（Connascence of Position）        if sig.inputs.len() \u003e 3 {            self.metrics.position_coupling.push(                format!(\"Function {} has {} parameters\",                    sig.ident, sig.inputs.len())            );        }    }    /// 2つのモジュールパス間の距離を計算    ///    /// # Arguments    /// * `from_path` - 開始パス (例: \"crate::module::submodule\")    /// * `to_path` - 終了パス    ///    /// # Returns    /// モジュール階層における段数（距離）    fn calculate_distance(\u0026self, from_path: \u0026str, to_path: \u0026str) -\u003e usize {        let from_parts: Vec\u003c\u0026str\u003e = from_path.split(\"::\").collect();        let to_parts: Vec\u003c\u0026str\u003e = to_path.split(\"::\").collect();        // 共通の祖先を見つける        let common = from_parts.iter()            .zip(to_parts.iter())            .take_while(|(a, b)| a == b)            .count();        (from_parts.len() - common) + (to_parts.len() - common)    }}impl\u003c'ast\u003e Visit\u003c'ast\u003e for CouplingAnalyzer {    /// 関数定義を訪問    fn visit_item_fn(\u0026mut self, node: \u0026'ast ItemFn) {        // 関数定義を分析        self.analyze_function_signature(\u0026node.sig);        syn::visit::visit_item_fn(self, node);    }    /// implブロックを訪問してContract/Intrusive Couplingを検出    fn visit_item_impl(\u0026mut self, node: \u0026'ast ItemImpl) {        // トレイト実装を分析（Contract Coupling）        if node.trait_.is_some() {            self.metrics.contract_count += 1;        } else {            // 具象型への直接実装（Intrusive Coupling）            self.metrics.intrusive_count += 1;        }        syn::visit::visit_item_impl(self, node);    }}Volatility（変動性）の測定Git の履歴から変更頻度を分析します。use std::process::Command;use std::collections::HashMap;use thiserror::Error;/// Volatility分析のエラー型#[derive(Error, Debug)]pub enum VolatilityError {    #[error(\"Git command failed: {0}\")]    GitCommandFailed(String),    #[error(\"Failed to parse Git output: {0}\")]    ParseError(String),    #[error(\"IO error: {0}\")]    Io(#[from] std::io::Error),    #[error(\"UTF-8 conversion error: {0}\")]    Utf8Error(#[from] std::string::FromUtf8Error),}/// ファイルの変更頻度を分析するアナライザー////// Git履歴を解析して各ファイルの変動性を評価#[derive(Debug, Default, Clone)]pub struct VolatilityAnalyzer {    file_changes: HashMap\u003cString, usize\u003e,}/// 変動性のレベル#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]pub enum VolatilityLevel {    /// 低変動性（汎用サブドメイン）    Low,    /// 中変動性（サポートサブドメイン）    Medium,    /// 高変動性（コアサブドメイン）    High,}impl VolatilityAnalyzer {    /// 新しいアナライザーを作成    fn new() -\u003e Self {        Self::default()    }    /// Git履歴を解析して変更頻度を収集    ///    /// # Arguments    /// * `months` - 過去何ヶ月分の履歴を分析するか    ///    /// # Returns    /// 成功時は `Ok(())`、Git コマンド実行失敗時はエラー    ///    /// # Errors    /// - Git コマンドが失敗した場合    /// - 出力のパースに失敗した場合    ///    /// # Example    /// ```    /// let mut analyzer = VolatilityAnalyzer::new();    /// analyzer.analyze_git_history(6)?; // 過去6ヶ月を分析    /// ```    pub fn analyze_git_history(\u0026mut self, months: usize) -\u003e Result\u003c(), VolatilityError\u003e {        let output = Command::new(\"git\")            .args([                \"log\",                \"--pretty=format:\",                \"--name-only\",                \u0026format!(\"--since={} months ago\", months)            ])            .output()?;        // Git コマンドが失敗した場合のチェック        if !output.status.success() {            let stderr = String::from_utf8_lossy(\u0026output.stderr);            return Err(VolatilityError::GitCommandFailed(stderr.to_string()));        }        let files = String::from_utf8(output.stdout)?;        for file in files.lines().filter(|l| !l.is_empty()) {            *self.file_changes.entry(file.to_string())                .or_insert(0) += 1;        }        Ok(())    }    /// ファイルの変動性レベルを分類    ///    /// # Arguments    /// * `file` - 分類対象のファイルパス    ///    /// # Returns    /// 変動性レベル（Low/Medium/High）    fn classify_volatility(\u0026self, file: \u0026str) -\u003e VolatilityLevel {        let changes = self.file_changes.get(file).copied().unwrap_or(0);        match changes {            0..=2 =\u003e VolatilityLevel::Low,            3..=10 =\u003e VolatilityLevel::Medium,            _ =\u003e VolatilityLevel::High,        }    }    /// 最も変更頻度の高いファイルを取得    ///    /// # Arguments    /// * `n` - 取得する上位ファイル数    ///    /// # Returns    /// (ファイルパス, 変更回数) のタプルのベクター    fn top_volatile_files(\u0026self, n: usize) -\u003e Vec\u003c(\u0026str, usize)\u003e {        let mut files: Vec\u003c_\u003e = self.file_changes            .iter()            .map(|(file, \u0026count)| (file.as_str(), count))            .collect();        files.sort_by(|a, b| b.1.cmp(\u0026a.1));        files.truncate(n);        files    }}バランススコアの計算/// Balancing Couplingのスコアを計算////// Khononovのモデルに基づき、Strength、Distance、Volatilityの/// 3次元からバランススコアを算出#[derive(Debug, Clone)]struct BalancedCouplingScore {    /// 結合の強さ: 0.0 (弱い) から 1.0 (強い)    strength: f64,    /// 距離: 0.0 (近い) から 1.0 (遠い)    distance: f64,    /// 変動性: 0.0 (安定) から 1.0 (頻繁に変更)    volatility: f64,}impl BalancedCouplingScore {    /// 新しいスコアを作成    ///    /// # Arguments    /// * `strength` - 結合の強さ (0.0-1.0)    /// * `distance` - 距離 (0.0-1.0)    /// * `volatility` - 変動性 (0.0-1.0)    ///    /// # Panics    /// 各値が 0.0-1.0 の範囲外の場合にパニック    fn new(strength: f64, distance: f64, volatility: f64) -\u003e Self {        assert!((0.0..=1.0).contains(\u0026strength), \"strength must be 0.0-1.0\");        assert!((0.0..=1.0).contains(\u0026distance), \"distance must be 0.0-1.0\");        assert!((0.0..=1.0).contains(\u0026volatility), \"volatility must be 0.0-1.0\");        Self {            strength,            distance,            volatility,        }    }    /// モジュラリティを計算    ///    /// # Formula    /// MODULARITY = STRENGTH XOR DISTANCE (論理的な意味での排他的論理和)    ///    /// 理想的な状態：    /// - 強い結合なら距離が近い (strength が高く distance が低い)    /// - 弱い結合なら距離が遠くても良い (strength が低く distance が高い)    ///    /// # Returns    /// モジュラリティスコア (0.0-1.0、高いほど良い)    fn calculate_modularity(\u0026self) -\u003e f64 {        // 強い結合 × 近い距離 = 良い（局所性が高い）        let ideal_close = self.strength * (1.0 - self.distance);        // 弱い結合 × 遠い距離 = 良い（疎結合が保たれている）        let ideal_far = (1.0 - self.strength) * self.distance;        ideal_close + ideal_far    }    /// バランススコアを計算    ///    /// # Formula    /// BALANCE = MODULARITY OR (NOT VOLATILITY) (論理的な意味での論理和)    ///    /// バランスが取れている状態：    /// - モジュラーである、または    /// - 変動性が低い（安定している）    ///    /// # Returns    /// バランススコア (0.0-1.0、高いほど良い)    fn calculate_balance(\u0026self) -\u003e f64 {        let modularity = self.calculate_modularity();        let stability = 1.0 - self.volatility;        // 論理和の近似：max を使用        modularity.max(stability)    }    /// 結合の問題点を識別    ///    /// # Returns    /// 検出された問題のリスト    fn identify_issues(\u0026self) -\u003e Vec\u003cCouplingIssue\u003e {        let mut issues = Vec::new();        // パターン1: グローバル複雑性        // 強い結合 + 遠い距離 = 変更の調整コストが高い        if self.strength \u003e 0.7 \u0026\u0026 self.distance \u003e 0.7 {            issues.push(CouplingIssue {                severity: IssueSeverity::High,                description: \"Strong coupling over long distance increases global complexity\"                    .to_string(),                recommendation: \"Consider moving coupled components closer or reducing coupling strength\"                    .to_string(),            });        }        // パターン2: ローカル複雑性        // 弱い結合 + 近い距離 = 不要な抽象化の可能性        if self.strength \u003c 0.3 \u0026\u0026 self.distance \u003c 0.3 {            issues.push(CouplingIssue {                severity: IssueSeverity::Medium,                description: \"Weak coupling at close distance may indicate unnecessary indirection\"                    .to_string(),                recommendation: \"Consider consolidating components or increasing distance\"                    .to_string(),            });        }        // パターン3: カスケード変更リスク        // 強い結合 + 高変動性 = 変更が広範囲に波及        if self.strength \u003e 0.7 \u0026\u0026 self.volatility \u003e 0.7 {            issues.push(CouplingIssue {                severity: IssueSeverity::Critical,                description: \"Strong coupling with volatile component creates cascading change risk\"                    .to_string(),                recommendation: \"Isolate volatile components or reduce coupling strength\"                    .to_string(),            });        }        // パターン4: 低モジュラリティ        let modularity = self.calculate_modularity();        if modularity \u003c 0.4 {            issues.push(CouplingIssue {                severity: IssueSeverity::Medium,                description: format!(\"Low modularity score: {:.2}\", modularity),                recommendation: \"Review coupling strength and distance relationship\"                    .to_string(),            });        }        issues    }}/// 結合に関する問題#[derive(Debug, Clone)]struct CouplingIssue {    severity: IssueSeverity,    description: String,    recommendation: String,}/// 問題の重要度#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]enum IssueSeverity {    Low,    Medium,    High,    Critical,}実践的な使用例プロジェクト全体の分析必要な依存関係を追加します。[dependencies]syn = { version = \"2.0\", features = [\"full\", \"visit\"] }walkdir = \"2.4\"実装例です。use walkdir::WalkDir;use std::path::Path;use std::ffi::OsStr;use std::fs;/// プロジェクト全体のメトリクスを保持#[derive(Debug, Default)]struct ProjectMetrics {    measurements: Vec\u003cCouplingMeasurement\u003e,    file_count: usize,    module_count: usize,}/// 結合度の測定結果#[derive(Debug)]struct CouplingMeasurement {    from_module: String,    to_module: String,    strength: f64,    distance: f64,    volatility: f64,}/// プロジェクト全体を分析////// # Arguments/// * `project_path` - プロジェクトのルートパス////// # Returns/// プロジェクトメトリクス、またはエラー////// # Example/// ```/// let metrics = analyze_project(\"./src\")?;/// println!(\"Total files analyzed: {}\", metrics.file_count);/// ```fn analyze_project(project_path: \u0026str) -\u003e Result\u003cProjectMetrics, Box\u003cdyn std::error::Error\u003e\u003e {    let mut project_metrics = ProjectMetrics::default();    // 1. 構造的な依存関係を分析    for entry in WalkDir::new(project_path)        .follow_links(true)        .into_iter()        .filter_map(|e| e.ok())    {        let path = entry.path();        // Rustファイルのみを処理        if path.extension() == Some(OsStr::new(\"rs\")) {            analyze_rust_file(path, \u0026mut project_metrics)?;        }    }    // 2. Git履歴から変動性を分析    let mut volatility = VolatilityAnalyzer::new();    volatility.analyze_git_history(6)?;    // 3. バランススコアを計算    calculate_balance_scores(\u0026mut project_metrics, \u0026volatility);    Ok(project_metrics)}/// 個別のRustファイルを分析////// # Arguments/// * `path` - ファイルパス/// * `project_metrics` - プロジェクトメトリクスの可変参照fn analyze_rust_file(    path: \u0026Path,    project_metrics: \u0026mut ProjectMetrics,) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {    let content = fs::read_to_string(path)?;    let syntax = syn::parse_file(\u0026content)?;    let module_name = path        .to_string_lossy()        .replace('/', \"::\")        .replace(\".rs\", \"\");    let mut analyzer = CouplingAnalyzer::new(module_name);    analyzer.visit_file(\u0026syntax);    project_metrics.file_count += 1;    project_metrics.module_count += 1;    Ok(())}/// バランススコアを計算してプロジェクトメトリクスに追加////// # Arguments/// * `metrics` - プロジェクトメトリクスの可変参照/// * `volatility` - 変動性アナライザーの参照fn calculate_balance_scores(    metrics: \u0026mut ProjectMetrics,    volatility: \u0026VolatilityAnalyzer,) {    for measurement in \u0026metrics.measurements {        let score = BalancedCouplingScore::new(            measurement.strength,            measurement.distance,            measurement.volatility,        );        let issues = score.identify_issues();        if !issues.is_empty() {            eprintln!(                \"Issues found in coupling from {} to {}:\",                measurement.from_module, measurement.to_module            );            for issue in issues {                eprintln!(\"  [{:?}] {}\", issue.severity, issue.description);            }        }    }}レポート生成use std::io::{self, Write};/// Markdownフォーマットでレポートを生成////// # Arguments/// * `metrics` - プロジェクトメトリクス/// * `writer` - 出力先 (stdout、ファイルなど)////// # Example/// ```/// let metrics = analyze_project(\"./src\")?;/// generate_report(\u0026metrics, \u0026mut std::io::stdout())?;/// ```fn generate_report\u003cW: Write\u003e(    metrics: \u0026ProjectMetrics,    writer: \u0026mut W,) -\u003e io::Result\u003c()\u003e {    writeln!(writer, \"# Coupling Analysis Report\\n\")?;    // サマリーセクション    write_summary(metrics, writer)?;    // 統合強度の分布    write_strength_distribution(metrics, writer)?;    // 問題の検出    write_issues(metrics, writer)?;    // 変動性分析    write_volatility_analysis(metrics, writer)?;    Ok(())}/// サマリーセクションを出力fn write_summary\u003cW: Write\u003e(    metrics: \u0026ProjectMetrics,    writer: \u0026mut W,) -\u003e io::Result\u003c()\u003e {    writeln!(writer, \"## Summary\\n\")?;    writeln!(writer, \"- **Total Files**: {}\", metrics.file_count)?;    writeln!(writer, \"- **Total Modules**: {}\", metrics.module_count)?;    writeln!(        writer,        \"- **Total Couplings**: {}\\n\",        metrics.measurements.len()    )?;    Ok(())}/// Integration Strengthの分布を出力fn write_strength_distribution\u003cW: Write\u003e(    metrics: \u0026ProjectMetrics,    writer: \u0026mut W,) -\u003e io::Result\u003c()\u003e {    writeln!(writer, \"## Integration Strength Distribution\\n\")?;    let total = metrics.measurements.len() as f64;    let contract = metrics        .measurements        .iter()        .filter(|m| m.strength \u003c= 0.25)        .count();    let model = metrics        .measurements        .iter()        .filter(|m| m.strength \u003e 0.25 \u0026\u0026 m.strength \u003c= 0.50)        .count();    let functional = metrics        .measurements        .iter()        .filter(|m| m.strength \u003e 0.50 \u0026\u0026 m.strength \u003c= 0.75)        .count();    let intrusive = metrics        .measurements        .iter()        .filter(|m| m.strength \u003e 0.75)        .count();    writeln!(        writer,        \"- **Contract Coupling** (weakest): {} ({:.1}%)\",        contract,        (contract as f64 / total) * 100.0    )?;    writeln!(        writer,        \"- **Model Coupling**: {} ({:.1}%)\",        model,        (model as f64 / total) * 100.0    )?;    writeln!(        writer,        \"- **Functional Coupling**: {} ({:.1}%)\",        functional,        (functional as f64 / total) * 100.0    )?;    writeln!(        writer,        \"- **Intrusive Coupling** (strongest): {} ({:.1}%)\\n\",        intrusive,        (intrusive as f64 / total) * 100.0    )?;    Ok(())}/// 検出された問題を出力fn write_issues\u003cW: Write\u003e(    metrics: \u0026ProjectMetrics,    writer: \u0026mut W,) -\u003e io::Result\u003c()\u003e {    writeln!(writer, \"## Detected Issues\\n\")?;    let mut has_issues = false;    for measurement in \u0026metrics.measurements {        let score = BalancedCouplingScore::new(            measurement.strength,            measurement.distance,            measurement.volatility,        );        let issues = score.identify_issues();        if !issues.is_empty() {            has_issues = true;            writeln!(                writer,                \"### {} → {}\\n\",                measurement.from_module, measurement.to_module            )?;            for issue in issues {                writeln!(writer, \"**{:?}**: {}\", issue.severity, issue.description)?;                writeln!(writer, \"- *Recommendation*: {}\\n\", issue.recommendation)?;            }        }    }    if !has_issues {        writeln!(writer, \"No significant coupling issues detected.\\n\")?;    }    Ok(())}/// 変動性分析を出力fn write_volatility_analysis\u003cW: Write\u003e(    metrics: \u0026ProjectMetrics,    writer: \u0026mut W,) -\u003e io::Result\u003c()\u003e {    writeln!(writer, \"## High Volatility Analysis\\n\")?;    // 高変動性のファイルを抽出    let high_volatility: Vec\u003c_\u003e = metrics        .measurements        .iter()        .filter(|m| m.volatility \u003e 0.7)        .collect();    if high_volatility.is_empty() {        writeln!(writer, \"No high volatility modules detected.\\n\")?;    } else {        writeln!(writer, \"Modules with high change frequency:\\n\")?;        for measurement in high_volatility {            writeln!(                writer,                \"- `{}` (volatility: {:.2})\",                measurement.from_module, measurement.volatility            )?;        }        writeln!(writer)?;    }    Ok(())}実践的なガイドライン結合度を改善するためのパターン1. 強い結合が必要な場合は距離を近くする頻繁に一緒に変更される機能は、同じモジュール内に配置するべきだ。// Good: 密接に関連する機能を同じモジュールに配置mod user_profile {    pub struct User { /* ... */ }    pub struct UserProfile { /* ... */ }    // Userと常に一緒に使われる    impl User {        pub fn get_profile(\u0026self) -\u003e \u0026UserProfile { /* ... */ }    }}DDD 的に言えば、同じ Bounded Context 内の概念は同じモジュールに配置する。2. 弱い結合なら距離を遠くしても良いインターフェース（trait）を通じた疎結合なら、別クレートに分けても問題ない。// core/src/lib.rs - インターフェース定義pub trait NotificationService {    fn send(\u0026self, message: \u0026str) -\u003e Result\u003c(), Error\u003e;}// adapters/email/src/lib.rs - 実装は別クレートuse core::NotificationService;pub struct EmailService;impl NotificationService for EmailService {    fn send(\u0026self, message: \u0026str) -\u003e Result\u003c(), Error\u003e { /* ... */ }}3. 高変動性のコードは低結合に保つビジネスロジック（Core Subdomain）は頻繁に変更される。他への影響を最小化するため、低結合に保つ必要がある。// Strategy Patternで変動性を隔離pub trait PricingStrategy {    fn calculate(\u0026self, base_price: f64) -\u003e f64;}pub struct StandardPricing;impl PricingStrategy for StandardPricing {    fn calculate(\u0026self, base_price: f64) -\u003e f64 {        base_price // ビジネスルールの変更がここに限定される    }}pub struct Order {    pricing: Box\u003cdyn PricingStrategy\u003e, // Dependency Injection}4. Connascenceを意識したリファクタリングパターン1: Position → Name// Before: Connascence of Position（悪い例）fn create_user(name: String, email: String, age: u32, country: String) -\u003e User {    // 引数の順序に依存}// After: Connascence of Name（良い例）struct UserBuilder {    name: String,    email: String,    age: u32,    country: String,}impl UserBuilder {    fn name(mut self, name: String) -\u003e Self {        self.name = name;        self    }    // 他のフィールドも同様}パターン2: Meaning → Name// Before: Connascence of Meaning（悪い例）if status == 1 { /* active */ }else if status == 2 { /* inactive */ }// After: Connascence of Name（良い例）#[derive(Debug, Clone, Copy, PartialEq, Eq)]enum UserStatus {    Active,    Inactive,    Suspended,}if status == UserStatus::Active { /* ... */ }おわりにVlad Khononov の「Balancing Coupling」フレームワークが教えてくれるのは、単なる「強い/弱い」という二元論を超えた結合度の見方だ。結合の強さ、距離、変動性——この3つの軸で測定することで、より細かい粒度での分析が可能になる。この調査を通じて明らかになったのは、Rust エコシステムには部分的に役立つツールは存在するものの、Balancing Coupling の概念を完全に体現するツールはまだ存在しないということだった。cargo-modules、rust-code-analysis、cargo tree といった既存ツールは、それぞれが異なる視点からコードを照らし出してくれる。しかし、Integration Strength の分類、Dynamic Connascence の検出、変動性の分析、そしてバランススコアの計算——これらを統合的に扱うには、カスタム実装が必要だ。そこで、本記事で紹介した設計をベースに、実際に動作するツールを作成していく。 syn クレートによる AST 解析、Git 履歴からの変動性測定、そして Khononov のフレームワークに基づくバランス評価——これらを組み合わせた実用的なツールだ。コードの「ちょうどいい距離感」を数値化し、可視化することで、リファクタリングの指針となることを目指す。ここで忘れてはいけないのは、結合をゼロにするのが目的ではないということだ。人間関係と同じように、コードにも「適切な距離感」がある。密接に関連する機能は、むしろ強く結合すべきだ。無理に引き離せば、かえって複雑になる。定期的な測定と分析により、過度な抽象化を避けつつ、柔軟で進化可能な設計を維持していこう。コードの「ちょうどいい距離感」は、測定することで初めて見えてくる。ネットワーク・エフェクト 事業とプロダクトに欠かせない強力で重要なフレームワーク作者:アンドリュー・チェン日経BPAmazon","isoDate":"2025-10-31T03:52:56.000Z","dateMiliSeconds":1761882776000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"構造的類似性を捉える技術 - similarity-rsで学ぶAST-basedコード解析の実装","link":"https://syu-m-5151.hatenablog.com/entry/2025/10/30/203342","contentSnippet":"github.comはじめにコードベースが大きくなるにつれて、似たようなコードが散らばっていることに気づく瞬間がある。「あれ、これ前にも書いたような...」そう思いながらコードを眺めるのだけれど、変数名が微妙に違っていたり、処理の順序が少しずれていたりして、結局は共通化できないまま放置してしまう。そんな経験は、プログラマなら誰しも一度や二度ではないはずだ。そして、生成AI時代の今、この問題はさらに深刻になっている。AIがコードを生成してくれるのは便利だけれど、同じような処理を少しずつ違う形で何度も生成してしまうことがある。人間が書いたコードなら「ああ、これは前に書いたやつだ」と気づけるのに、AIが生成したコードは一見して判別がつかない。気づけばコードベースは「似て非なるコード」で溢れかえり、保守性は急速に失われていく。生成AI時代だからこそ、コードの構造的な類似性を見抜く技術が、これまで以上に必要とされているのだ。私は、結合度を測って適切にリファクタリングを促すツールを開発したいと考えていた。そのヒントを探していたときに出会ったのが、@mizchiさんのsimilarityプロジェクトだった。このプロジェクトの中でも特に、Rustへの実装であるsimilarity-rsの仕組みに惹かれ、その内部構造を詳しく調査することにした。この記事は、そこで得られた発見の記録である。syu-m-5151.hatenablog.com実際の使用例は以下です。# インストール（Cargo経由）cargo install similarity-rs# プロジェクトルートで実行similarity-rs .# より詳細なオプションを確認similarity-rs -h# AI によって修正させる場合Run `similarity-rs .` to detect semantic code similarities. Execute this command, analyze the duplicate code patterns, and create a refactoring plan. Check `similarity-rs -h` for detailed options.実行すると、以下のように重複コードを検出します。Duplicates in src/utils.rs:────────────────────────────────────────────────────────────src/utils.rs:10 | L10-15 similar-function: calculateSumsrc/utils.rs:20 | L20-25 similar-function: addNumbersSimilarity: 85.00%, Priority: 8.5 (lines: 10)これがどうやって実現されているのか、その内部実装を紐解いていきます。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。similarity-rsとは何か？similarity-rs は、similarity の中の Rust プロジェクトのコード重複を検出する CLI ツールです。ただし、単純なテキストマッチングではありません。抽象構文木（AST）を使った構造的な比較により、変数名が違っても本質的に同じ処理をしている関数を見つけ出せます。例えば、以下の 2 つの関数は変数名が違いますが、similarity-rs は「これらは似ている」と判断できます。fn calculate_total(items: Vec\u003ci32\u003e) -\u003e i32 {    let mut sum = 0;    for item in items {        sum += item;    }    sum}fn add_numbers(values: Vec\u003ci32\u003e) -\u003e i32 {    let mut result = 0;    for value in values {        result += value;    }    result}テキストベースの diff ツールなら「全然違う」と判断する場合でも、similarity-rs は「構造が同じ」と判定できます。技術スタックの全体像similarity-rs の核となる技術は 2 つです。tree-sitter - Rust コードを解析して AST を生成APTED (All Path Tree Edit Distance) - 2 つの AST の距離を計算この 2 つを組み合わせることで、「コードの意味的な類似度」を数値化しています。なぜtree-sitterなのか？tree-sitter は、GitHub が開発した高速でインクリメンタルなパーサーです。rustc の手書きパーサーと比べると初回パースは 2-3 倍遅いですが、以下の利点があります。インクリメンタルパース: コードの一部が変更されたとき、変更部分だけ再パースできる堅牢性: 構文エラーがあっても部分的にパースを続行できる多言語対応: 同じインターフェースで複数の言語に対応実測値は次のとおりです。2157行のRustファイル（約64KB）のパース時間：- 初回: 約6.48ms- インクリメンタル更新: 1ms未満- スループット: 約9908 bytes/ms初回パースで約 6.48ms、インクリメンタル更新では 1ms 未満という実測値が得られています。ASTベース比較の仕組みStep 1: コードをASTに変換するまず、Rust コードを tree-sitter でパースします。use tree_sitter::{Parser, Language};let mut parser = Parser::new();parser.set_language(\u0026tree_sitter_rust::LANGUAGE.into())    .expect(\"Error loading Rust grammar\");let source_code = \"fn test() { println!(\\\"hello\\\"); }\";let tree = parser.parse(source_code, None).unwrap();生成される AST は、以下の階層構造になります。source_file└── function_item    ├── fn (keyword)    ├── identifier: \"test\"    ├── parameters    └── block        └── macro_invocation            └── ...Step 2: 関数を抽出するAST から関数定義を抽出します。この時、以下のような工夫がされています。fn extract_functions(tree: \u0026Tree, source: \u0026str) -\u003e Vec\u003cFunction\u003e {    let mut functions = Vec::new();    let root = tree.root_node();        fn visit_node(node: Node, source: \u0026str, functions: \u0026mut Vec\u003cFunction\u003e) {        match node.kind() {            \"function_item\" =\u003e {                // テスト関数は除外                if !is_test_function(\u0026node, source) {                    functions.push(Function::from_node(node, source));                }            }            \"impl_item\" =\u003e {                // implブロック内のメソッドも処理                for child in node.children() {                    if child.kind() == \"function_item\" {                        if !is_test_function(\u0026child, source) {                            functions.push(Function::from_node(child, source));                        }                    }                }            }            _ =\u003e {                // 再帰的に子ノードを探索                for child in node.children() {                    visit_node(child, source, functions);                }            }        }    }        visit_node(root, source, \u0026mut functions);    functions}注目すべき点として、テスト関数は自動的に除外されます。以下の 3 つの方法で検出します。#[test] 属性がついている関数test_ で始まる関数名（Rust の慣習）#[cfg(test)] モジュール内の関数これにより、本番コードの重複だけに集中できます。Step 3: 木構造の編集距離（TSED）を計算するここが最も興味深い部分です。2 つの AST がどれだけ「似ているか」を測定するために、Tree Edit Distance（木構造の編集距離）を使用します。木構造の編集距離とは？木構造を別の木構造へ変換する際に必要な「編集操作の最小回数」です。編集操作は 3 種類あります。Insert（挿入）: ノードを追加Delete（削除）: ノードを削除Rename（名前変更）: ノードのラベルを変更例を示します。Tree 1:          Tree 2:   A                A  / \\              / \\ B   C            B   D編集操作：1. C を D に Rename編集距離 = 1APTEDアルゴリズムsimilarity-rs は、APTED (All Path Tree Edit Distance) アルゴリズムを使用しています。これは 2015-2016 年に Pawlik と Augsten が発表したアルゴリズムで、以下の特徴があります。最適な分解戦略: 木を最も効率的に分解して計算動的計画法: 部分問題の結果をメモ化して再利用時間計算量: O(n·m) - 理論的に最適実装の概要は以下のとおりです。fn calculate_similarity(tree1: \u0026TreeNode, tree2: \u0026TreeNode, options: \u0026TSEDOptions) -\u003e f64 {    // APTEDで編集距離を計算    let edit_distance = compute_edit_distance(tree1, tree2);        // 正規化：類似度スコア（0.0〜1.0）に変換    let max_nodes = max(tree1.node_count(), tree2.node_count());    let base_similarity = 1.0 - (edit_distance as f64 / max_nodes as f64);        // サイズ差ペナルティを適用（オプション）    if !options.no_size_penalty {        let size_ratio = min_size as f64 / max_size as f64;        base_similarity * size_ratio    } else {        base_similarity    }}重要な発見として、ACL 2024 の研究論文（Song et al.）によると、以下の重みが最適とされています。Insert: 0.8Delete: 1.0Rename: 1.0この重みは実験によって導き出されたもので、48 以上のプログラミング言語で有効性が実証されています。ただし、similarity-rsの現在のデフォルト実装では異なる設定が使用されています。Rename: 0.3（デフォルト）Delete: 1.0Insert: 1.0研究論文で推奨される最適値とは異なりますが、--rename-costオプションで調整可能です。パフォーマンス最適化の技術1. Rayonによる並列処理similarity-rs の最大の強みの 1 つが、Rayon を使った並列処理です。use rayon::prelude::*;// ファイルを並列処理files.par_iter()    .flat_map(|file| extract_functions(file))    .collect()// 関数比較も並列化functions.par_iter()    .enumerate()    .flat_map(|(i, func1)| {        functions[i+1..].par_iter()            .map(|func2| compare_functions(func1, func2))    })    .filter(|similarity| similarity.score \u003e threshold)    .collect()Rayon の優れた特徴は次のとおりです。ワークスティーリング: CPU コア間で自動的に負荷分散データ競合フリー: Rust の型システムが保証（Send + Syncトレイト）ゼロ同期オーバーヘッド: データ共有が不要な場合線形スケーラビリティ: CPU コア数に応じてほぼ線形に高速化実際のベンチマークでは、中規模ファイルで逐次処理比16倍の高速化が確認されています。2. ブルームフィルタによる事前フィルタリングTypeScript 版（similarity-ts）で先行実装され、Rust 版でも部分的にサポートされています。高速化に大きく貢献するテクニックです。struct AstFingerprint {    bloom_filter: BloomFilter,           // 確率的集合メンバーシップ    node_types: HashSet\u003cNodeKind\u003e,    signature: u64,                      // ハッシュベース署名}fn quick_reject(\u0026self, func1: \u0026FunctionDef, func2: \u0026FunctionDef) -\u003e bool {    let intersection = self.bloom_filter        .estimate_intersection(\u0026func1.fingerprint, \u0026func2.fingerprint);        let estimated_similarity = intersection / max(func1.size, func2.size);    estimated_similarity \u003c self.min_similarity_threshold}この手法による効果は次のとおりです。比較回数を 70-90%削減偽陽性率 1%未満TypeScript 版で約 4 倍の高速化を実現明らかに違う関数ペアを高価な TSED 計算の前に除外できるため、全体の処理時間が 70-90%削減されます。Rust 版での実装状況は次のとおりです。crates/core/src/ast_fingerprint.rsにブルームフィルタの基礎実装が存在--no-fastオプションでブルームフィルタを無効化可能TypeScript 版ほど最適化されていないが、将来的な改善が期待される3. メモリ最適化の工夫Rust の所有権システムとゼロコスト抽象化を活かした最適化がいくつも施されています。ライフタイム注釈によるゼロコピーの例を示します。pub struct FunctionComparison\u003c'a\u003e {    func1: \u0026'a FunctionDefinition,    func2: \u0026'a FunctionDefinition,    similarity: f64,}データをクローンせず、参照を渡すだけで済みます。イテレータチェーンによる変換の例を示します。let similar_pairs: Vec\u003c_\u003e = functions.iter()    .enumerate()    .flat_map(|(i, f1)| {        functions.iter()            .skip(i + 1)            .filter_map(|f2| {                let sim = calculate_similarity(f1, f2);                (sim \u003e threshold).then_some((f1, f2, sim))            })    })    .collect();この書き方の利点は次のとおりです。イテレータチェーンはタイトなループにコンパイルされる中間値のヒープアロケーションが発生しない遅延評価により、collectされるまで計算しない実際の使い方と出力フォーマット基本的な使い方# カレントディレクトリを解析similarity-rs .# 類似度の閾値を指定（デフォルト: 0.85）similarity-rs . --threshold 0.9# テスト関数をスキップsimilarity-rs . --skip-test# ファイル間の比較も有効化similarity-rs . --cross-file# コードスニペットを出力に含めるsimilarity-rs . --print# 最小トークン数を指定（小さい関数を除外）similarity-rs . --min-tokens 50出力の読み方Duplicates in src/utils.rs:────────────────────────────────────────────────────────────src/utils.rs:10 | L10-15 similar-function: calculateSumsrc/utils.rs:20 | L20-25 similar-function: addNumbersSimilarity: 85.00%, Priority: 8.5 (lines: 10)────────────────────────────────────────────────────────────src/utils.rs:30 | L30-40 similar-function: processDatasrc/handlers.rs:50 | L50-60 similar-function: handleRequestSimilarity: 92.00%, Priority: 11.5 (lines: 12)Priority は次の計算式で求められます: 行数 × 類似度スコアこれにより、影響度の高い重複（長くて似ている）を優先的に見つけられます。VSCode 互換の出力フォーマットを採用しており、ターミナルからファイル名をクリックすることで該当箇所に直接ジャンプできます。処理フローの全体像similarity-rs がどのように動作するのか、全体の流れを説明します。1. ファイル検索   └─\u003e ディレクトリを再帰的にスキャンして.rsファイルを検索   2. パース段階   └─\u003e 各ファイルに対して:       ├─\u003e tree-sitterがソースをASTにパース       └─\u003e ASTから関数ノードを抽出       3. フィルタリング段階   └─\u003e 各関数に対して:       ├─\u003e 最小行数/トークン数をチェック       ├─\u003e テスト関数かチェック（--skip-test有効時）       └─\u003e 合格すれば候補プールに追加       4. 特徴抽出（高速モード）   └─\u003e ブルームフィルタ用のAST特徴を抽出   └─\u003e 各関数のブルームフィルタを構築   5. 候補ペア生成   └─\u003e 比較する関数ペアを生成       ├─\u003e 同一ファイル内ペア（デフォルト）       └─\u003e ファイル間ペア（--cross-file時）       6. ブルームフィルタ事前フィルタリング   └─\u003e ブルームフィルタで高速チェック   └─\u003e 明らかに異なるペアを除外   7. TSED計算   └─\u003e 残りのペアに対して:       ├─\u003e APTEDで木編集距離を計算       ├─\u003e サイズペナルティを適用（有効時）       └─\u003e 類似度スコアに正規化       8. 閾値フィルタリング   └─\u003e 類似度 \u003e= 閾値のペアを保持   9. 出力生成   └─\u003e 結果をフォーマット（JSONまたは人間可読）   └─\u003e --printフラグ時はコードスニペットを含むTypeScript版（similarity-ts）との比較mizchi さんのプロジェクトには、TypeScript 版も存在します。各実装の特徴を比較します。アーキテクチャの違い 側面  similarity-ts  similarity-rs  パーサー  oxc-parser（Rust製）  tree-sitter-rust  メモリ管理  アリーナアロケーション  標準ヒープ  高速モード  ブルームフィルタ完全実装  部分的実装  型チェック  実験的サポート  実験的サポート（--experimental-types） パフォーマンス比較実際のベンチマーク結果に基づく比較を示します。similarity-rs（Rust 版）の利点は次のとおりです。中規模ファイルで約 16 倍高速（ネイティブコードの効率性）メモリ使用量が一定（Rc による参照カウント）大規模ファイルでも安定動作（TypeScript は OOM エラー発生）ネイティブ Rust コード（FFI オーバーヘッドなし）Rust 固有機能（#[test]属性の検出など）similarity-ts（TypeScript 版）の利点は次のとおりです。小規模ファイルではやや高速（0.74x、プロセス起動オーバーヘッドなし）ブルームフィルタ高速モードで約 4 倍高速化oxc-parser による高速パース（swc より 3 倍高速）アリーナアロケーションによるキャッシュ局所性向上JavaScript エコシステムとの統合が容易言語固有機能similarity-ts の機能は次のとおりです。型類似度検出クラス比較サポートデコレータサポートsimilarity-rs の機能は次のとおりです。implブロック解析テスト関数フィルタリングトレイト実装検出研究基盤と理論的背景similarity-rs の背後には、しっかりとした研究基盤があります。TSED研究論文（Song et al., ACL 2024）この研究では、48 以上のプログラミング言語で TSED の有効性が実証されました。BLEU および Jaccard 類似度と 0.6-0.8 の相関実行一致に関して意味論的メトリクスより高精度最適重み: Insert=0.8、Delete=1.0、Rename=1.0APTEDアルゴリズム（Pawlik \u0026 Augsten, 2015-2016）木編集距離の堅牢な実装を提供し、メモリ使用量を抑制最適な分解戦略により O(n·m) の時間計算量で動作以前のアルゴリズム（RTED、Demaine など）を凌駕学術的にも裏付けられた手法を使っている点は信頼性が高いです。実用例：リファクタリング計画の立て方実際の使用方法とリファクタリングへの活用方法を説明します。Step 1: 重複コードを検出similarity-rs . --threshold 0.85 --skip-test \u003e duplicates.txtStep 2: 優先度の高い重複を確認出力の Priority スコアを見て、影響の大きい重複から着手します。Priority: 11.5 (lines: 12, similarity: 92%)Step 3: リファクタリング方針を決定検出された重複コードを見て、以下を判断します。共通化できる場合共通関数として抽出部分的に共通化できる場合共通部分を関数として抽出差分をパラメータ化偶然の重複である場合本質的に異なる処理なので、そのままStep 4: 継続的なモニタリングCI/CD パイプラインに組み込んで、新しい重複が生まれないか監視します。# .github/workflows/code-quality.yml- name: Check code duplication  run: |    similarity-rs . --threshold 0.85 --skip-test    if [ $? -ne 0 ]; then      echo \"Warning: Code duplication detected\"      # Slackに通知するなど    fi制限事項と今後の展望現在の制限公式ドキュメントにも明記されていますが、similarity-rs は実験段階です。プロダクション環境での検証が不十分ブルームフィルタが部分的実装（similarity-ts ほど最適化されていない）マクロヘビーなコードには制限があるrustc パーサーより 2-3 倍遅い（初回パース時）既知の問題（KNOWN_ISSUES.md より）は次のとおりです。Enum similarity detection: 構造的に同一の Enum でも約 43%の類似度しか検出されない原因: Enum の variant 名が value として扱われ、rename_cost パラメータで適切に処理されない回避策: Enum 比較時は閾値を 0.4-0.5 に下げるStruct similarity detection: 正常に動作（90%以上の類似度を検出）similarity-rsから学んだことsimilarity-rs を深掘りした結果、このツールから多くの重要な学びを得ることができました。まず最も印象的だったのは、ASTベース解析の威力です。従来のテキストベースの類似度検出では、表面的な文字列の一致に頼るため、変数名やコメントの違いによって本質的に同じコードを見逃してしまうことがありました。しかし、AST ベースのアプローチでは構造的な類似性を捉えることができます。変数名が異なっていても、処理のロジックや制御構造が同じであれば、それを的確に検出できる点は非常に強力です。次に感銘を受けたのは、Rust の型システムが可能にする最適化です。Rust の所有権システムは、メモリ安全性をコンパイル時に保証します。さらに、ゼロコスト抽象化により、高レベルな記述をしながらも実行時のオーバーヘッドを最小限に抑えられます。加えて、充実した並行処理プリミティブにより、マルチスレッド処理を安全に記述できます。これらの特性を組み合わせることで、安全性とパフォーマンスを両立したツールの実装が実現されています。また、実装の随所に見られる実用的な最適化の積み重ねも注目に値します。ブルームフィルタによる事前フィルタリングで不要な比較を削減し、Rayon を活用した並列処理で処理速度を向上させています。さらに、テスト関数の自動除外や最小トークン数によるフィルタリングなど、実際の開発現場で役立つ工夫が随所に施されています。このような小さな最適化の積み重ねが、理論だけでなく実用的なツールを作り上げる鍵となることを実感しました。最後に、このツールはACL 2024の論文をベースにした実装である点も重要です。学術研究で提案されたアイデアを、実際に動作するソフトウェアとして具現化しており、理論と実践の橋渡しをしている好例と言えます。研究成果を実装に落とし込む過程で、どのような工夫や最適化が必要になるのかを学ぶことができました。おわりに冒頭で述べた「結合度を測って適切にリファクタリングを促すツール」について、similarity-rs から学んだアプローチを応用できます。AST ベースの解析で構造的な類似性を捉える並列処理で大規模コードベースにも対応優先度スコアでリファクタリングの優先順位を示すCI/CD 統合で継続的にコード品質を監視similarity-rs の実装を理解したことで、自分が作りたいツールの具体的なイメージが明確になりました。GitHub リポジトリで実装の詳細を確認できます。コードは読みやすく構成されているため、Rust の学習にも適した教材です。Tidy First? ―個人で実践する経験主義的ソフトウェア設計作者:Kent Beckオーム社Amazon参考文献mizchi/similarity - GitHubZenn記事：TypeScript/Rustで高速なコード類似度検出ツールを作るtree-sitter - Official DocumentationRayon - Data Parallelism in Rust","isoDate":"2025-10-30T11:33:42.000Z","dateMiliSeconds":1761824022000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"ソフトウェアエンジニアにおける才能という幻想、あるいは成長を阻む最大の敵について","link":"https://syu-m-5151.hatenablog.com/entry/2025/10/28/113009","contentSnippet":"はじめに「才能がない」と言われたことがあるでしょうか。それとも、友人や知り合いと自分を比べて、自分で自分にそう言い聞かせたことがあるでしょうか。学生の頃からエンジニアを志してきた私は、コンテストで優秀な成績を残す人たちを目の当たりにしてきました。大手IT企業に入社し、優秀な同期と出会いました。勉強会やカンファレンスに足を運び、そこで出会った人たちの軌跡を追ってきました。華々しくスタートアップを立ち上げた人、革新的なプロダクトを生み出した人、OSSコミュニティで名を馳せる人。一方で、いつの間にか表舞台から姿を消した人もいます。これらがごく一部の狭い世界でしかないことも、自覚しています。そして今、インターンシップやワークショップで若手エンジニアと接する機会が増えました。3年ほど前に始めたこの活動──正直に言うと、自分が未熟なまま始めてしまったという不安は、今でもどこかにあります。彼らと一緒に作業する中で、「才能がない」と自己評価する学生やインターン生に出会うことがよくあります。彼らは真剣な表情で「自分には向いていないかもしれません」と告げます。コードを書くのが遅い。エラーの意味が理解できない。他の人は簡単にできることが、自分には難しい──そう語る彼らの目には、諦めと不安が混じっています。私はその度に、ある問いを投げかけます。「才能って、何だと思う?」「君には才能がある」とも「才能なんて関係ない」とも言わず、まず考えてもらう。しかし大抵の場合、明確な答えは返ってきません。実は、私もかつて、才能という言葉に深く囚われていました。コンテスト会場で、企業の開発フロアで、勉強会の懇親会で、私は何度も「天才」と呼ばれるエンジニアたちに出会いました。彼らは難解なアルゴリズムを一瞬で理解し、複雑なバグを数分で特定し、誰も思いつかないような解決策を次々と生み出していました。そして私は何度も思いました。「自分には才能がない」と。しかし、多くの「一流」と呼ばれる人々と接し、彼らの日常を観察し、そして時には彼らが立ち止まる瞬間や、消えていく瞬間も目撃する中で、ある重要な事実に気づきました。才能という言葉は、実は成長を阻む最大の敵なのかもしれない。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。技術力という幻想才能について語る前に、まずソフトウェアエンジニアリングにおける「技術力」とは何かを整理しておく必要があります。我々の文脈では、才能という言葉はこの技術力と結びつけて語られることが多いためです。技術力という言葉の曖昧さ私たちは「技術力が高い」「技術力が低い」という言葉を安易に使いがちです。しかし、その実態は何でしょうか。率直に言えば、ソフトウェアエンジニアの「技術力」と呼ばれるものの多くは、実は「ちょっと詳しい」「似たようなトラブルを経験している」「これとこれを組み合わせれば行けそう」という程度のものです。私が使ってきた「エンジニアリング」という言葉にも、工学的な要素はあまり含まれていませんでした。正しくは「テクニック」──つまり、実践的な技術や方法論の集積です。特別なスキルというよりは、日々の積み重ねで身につく経験知なのです。では、技術力とは何なのか。私の観察では、それは大きく二つの軸に分解できます。一つは「経験の蓄積」、もう一つは「洞察力としてのセンス」です。センスは知識からはじまる作者:水野学朝日新聞出版Amazon第一の軸：経験の蓄積技術力の第一の要素は、経験の蓄積です。これは、しばしば「同じ失敗を繰り返さない力」として評価されます。具体的には、こういうことです。あるエラーに遭遇したとき、以前に似たようなエラーを見たことがあれば、解決は早くなります。データベースのデッドロック、非同期処理のタイミング問題、キャッシュの不整合──こうした問題は、一度経験していれば「ああ、これか」と気づけます。これは確かに価値のある能力です。経験豊富なエンジニアが重宝されるのは、このためです。しかし、これを「才能」と呼ぶのは適切でしょうか。違います。これは単に時間をかけて様々な問題に向き合った結果であり、誰でも積み重ねられるものです。早く始めた人、多く失敗した人が、より多くの経験を持っているだけです。具体と抽象作者:細谷 功dZERO（インプレス）Amazon第二の軸：洞察力としてのセンス技術力のもう一つの要素、それが「センス」です。音楽をやっている人たちの中で「あいつは耳が良い」と評価される能力があります。単に楽器を弾く技術だけでなく、音のバランス、リズムの微妙なズレ、和音の響き方──こうした細部を感じ取る力のことです。ソフトウェアエンジニアリングにも、これに似たものがあります。コードを見たとき、「このコード、何か変だな」と直感的に感じる。実行する前から「ここでバグが出そう」と予感する。設計図を見て「この構造は将来的に問題になる」と察知する。これが、エンジニアにおける「センス」です。重要なのは、これは単なる経験の蓄積とは質的に異なるということです。同じ年数働いていても、このセンスを持つ人と持たない人がいます。では、このセンスとは何なのでしょうか。センスの哲学 (文春e-book)作者:千葉 雅也文藝春秋Amazonセンスの正体──三つの具体的な現れ方センスは抽象的な概念に聞こえますが、実は具体的に分解できます。私の観察では、センスは主に三つの形で現れます。1. 細部への注目力センスのあるエンジニアは、コード全体の機能だけでなく、細部のリズムやバランスに気づきます。例えば、関数の長さのバランス。あるファイルに25行の関数と5行の関数が混在しているとき、「なぜこの差があるのか」と気づきます。命名の一貫性。ある場所ではgetUserDataと書き、別の場所ではfetchUserと書いているとき、その揺らぎに違和感を覚えます。これらは動作に直接影響しないこともあります。でも、コードの「匂い」として現れます。そして、この匂いに気づけるかどうかが、センスの有無を分けます。ルールズ・オブ・プログラミング ―より良いコードを書くための21のルール作者:Chris Zimmermanオーム社Amazon2. 構造の美しさへの感受性センスのあるエンジニアは、「美しいコード」と「醜いコード」を区別できます。そして最も重要なのは、なぜ美しいと感じるのか、その理由を言語化できることです。「この関数は単一責任原則を守っているから美しい」「この命名は意図が明確に伝わるから良い」「この抽象化は読みやすさと柔軟性を両立しているから綺麗」単に「良い」「悪い」と感じるだけでなく、その判断の根拠を意識できる。これがセンスです。そして、この言語化能力が、他者にも伝えられる知見へと昇華されます。Good Code, Bad Code ～持続可能な開発のためのソフトウェアエンジニア的思考作者:Tom Long秀和システムAmazon改訂新版　良いコード／悪いコードで学ぶ設計入門 ―保守しやすい　成長し続けるコードの書き方作者:仙塲 大也技術評論社Amazon3. 問題の本質を見抜く力最も価値が高いのは、表面的な問題の背後にある本質的な問題を見抜く力です。例えば、バグが報告されたとします。表面的には「nullポインタ例外」かもしれません。しかし、センスのあるエンジニアは、その背後に「状態管理の設計が不適切」という本質的な問題があることに気づきます。エラーログを見て、「このエラーが頻発しているということは、そもそもこの処理フローに問題がある」と洞察します。パフォーマンスの問題を見て、「これは単にクエリの最適化の問題ではなく、データモデルの設計から見直すべき」と判断します。この「一歩踏み込んで問題を捉える力」こそが、経験を超えたセンスの核心です。ライト、ついてますか　問題発見の人間学作者:ドナルド・C・ゴース,ジェラルド・M・ワインバーグ共立出版Amazonセンスは訓練できるのかここまで読んで、「じゃあセンスは才能じゃないか」と思うかもしれません。違います。センスも訓練できます。なぜなら、センスとは突き詰めれば「何に注目するか」という習慣と、「それを面白がれるか」という姿勢だからです。どちらも意識的に育てることができます。熟達論―人はいつまでも学び、成長できる―作者:為末大新潮社Amazon訓練法1：意識的な観察の習慣最初は意識的に練習します。コードレビューをするとき、ただ「動くか動かないか」だけでなく、以下の点に注目してみます。関数の長さのバランスは適切か命名に一貫性はあるか、揺らぎは意図的か抽象度の上下動に違和感はないかコメントの密度は適切か変数のスコープの範囲は適切か最初は面倒です。でも、こうした細部に意識的に注目する習慣を続けていると、やがて自然と細部が目に入るようになります。これがセンスを磨くということです。訓練法2：本質を掴む読み方優れたエンジニアのコードを読むとき、ただ写経するのではなく、その背後にある思考を読み取ろうとします。なぜこの構造を選んだのかなぜこの命名にしたのかなぜこの順序で処理しているのかなぜこの部分だけ抽象化したのかそして、そこから本質的な要素を抽出し、自分のコードに応用する。この「本質を掴む」プロセスを繰り返すことで、表面的なパターンの暗記を超えた理解が生まれます。訓練法3：面白がる回路を作る最も重要なのは、問題を面白がる姿勢を育てることです。センスのあるエンジニアは、エラーや問題を「厄介だ」ではなく「興味深い」と捉えています。この姿勢は、選択できるものです。最初は意識的に「これは面白い」と自分に言い聞かせます。「このバグ、再現条件が複雑で面白い」「このエラーメッセージ、何を伝えようとしているのか興味深い」「この設計の問題、どう解決すべきか考えるのが楽しい」こうした「面白がる回路」を作ることが、センスを磨く本質です。すると徐々に、本当に面白く感じられるようになってきます。そして、面白がれるようになると、自然と深く考えるようになり、結果としてセンスが磨かれます。技術力もセンスも、どちらも成長可能結局のところ、技術力を構成する二つの軸──経験の蓄積とセンスという洞察力──は、どちらも成長可能な能力です。経験は、時間をかけて多くの問題に向き合うことで自然と積み重なります。失敗を恐れず、様々なことに挑戦することで、経験値は増えていきます。センスは、意識的な訓練によって磨かれます。細部に注目し、本質を掴もうとし、問題を面白がることで、徐々に洞察力が深まっていきます。どちらも「才能」という固定的な能力ではありません。時間と意識的な努力によって育てられるスキルなのです。「あの人は技術力がある」と言われる人は、単に先に始めて多くの経験を積んだか、意識的にセンスを磨く習慣を持っているか、あるいはその両方です。そして、その両方とも、今からでも始められます。才能という名の逃避「才能がない」という言葉は、一見すると謙虚に聞こえます。しかし実のところ、これは危険な自己欺瞞です。なぜなら、才能という言葉を使った瞬間、私たちは変化の可能性を放棄してしまうからです。「才能がないからできない」は、「努力してもどうせ無理」と同義です。そして一度この思考に陥ると、成長のための努力そのものが無意味に思えてきます。私自身、新人時代にこの罠に嵌っていました。新しい技術概念と格闘していた頃、何度もこう思いました。「自分にはこの考え方を理解する才能がないのだろう」と。そしてその思考は、学習を放棄する口実となりました。難しいドキュメントを読むことを避け、エラーメッセージと真剣に向き合うことから逃げました。でも、ある時気づきました。私が「才能がない」と諦めていた領域で活躍している先輩たちも、実は最初から理解していたわけではありませんでした。彼らは単に、私が避けていた苦痛と向き合い続けていただけだったのです。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazon性格と人格才能を考える上で、重要な区別があります。それは性格と人格の違いです。性格とは、通常の日にどう反応するか──つまり、私たちの自然な傾向や気質のことを指します。一方で人格とは、困難な日にどう振る舞うか──つまり、意図的に選択される態度や行動のことです。この区別は、才能という概念を理解する上でとても重要です。私たちはよく、性格と人格を混同してしまいます。「私は物覚えが悪い」「集中力がない」「創造性がない」──これらは一見すると先天的な限界のように聞こえます。しかし実際には、これらの多くは人格、つまり訓練可能な能力の領域なのです。例えば、「集中力がない」と自己評価する人の多くは、実は集中する環境や方法を知らないだけかもしれません。スマートフォンの通知をオフにし、作業を25分単位に区切り、定期的に休憩を取る──こうした具体的な方法を実践することで、「集中力」は劇的に向上します。重要なのは、こうした能力を「才能」ではなく「性格スキル」として捉え直すことです。才能は固定的で変えられないものですが、スキルは練習によって向上させることができます。この視点の転換が、成長への扉を開くのです。世界一やさしい「才能」の見つけ方　一生ものの自信が手に入る自己理解メソッド作者:八木 仁平KADOKAWAAmazon不快感という成長の証才能という幻想から抜け出すために、もう一つ重要な認識があります。それは、学習における不快感の本質的な役割です。「快適に学べる」というのは、実は矛盾した概念かもしれません。スキルを真に習得するまで快適にはなれないのですが、習得する前の練習は必然的に不快だからです。そして人は、その不快感を避けようとします。これが、多くの人が成長の途中で挫折する根本的な理由です。Docker最適化の学習を例に取りましょう。BuildKitのキャッシュ戦略を理解しようとするとき、最初はかなり混乱します。レイヤーの仕組み、マウントの種類、キャッシュの無効化条件──これらの概念は最初、全く繋がらない断片として現れます。この混乱は不快です。だから多くの人は、「とりあえず動けばいい」と表面的な理解で妥協します。しかし、この不快感こそが成長の証なのです。脳が新しい構造を構築しようとしている証。既存の理解の枠組みが崩れ、新しい理解が生まれつつある証です。この不快感から逃げずに、むしろそれを「成長が起きている」というサインとして受け入れられるかどうか──それが、習得できる人とできない人を分ける分岐点になります。「快適なら、やり方が間違っている」という言葉があります。この言葉は、学習の本質を突いています。本当の成長は、常にコンフォートゾーンの外側で起きるのです。ネガティブ・ケイパビリティ　答えの出ない事態に耐える力 (朝日選書)作者:帚木　蓬生朝日新聞出版Amazon才能がないと言う前にインターンシップやワークショップで若手と一緒に作業をしていて気づいたことがあります。「才能がない」と自己評価する人の多くが、実は才能の問題ではなく、もっと基礎的なプロセスを飛ばしているだけだということです。syu-m-5151.hatenablog.comドキュメントを読んでいない「自分には向いていない」と言う学生がいました。コードがうまく動かないし、エラーが理解できないと。しかし彼は、エラーメッセージを実際には読み飛ばしていたのです。エラーメッセージには「Expected type X, but got type Y」と明確に書いてあります。しかし「type X」という文字列だけを拾って、期待される型と実際の型が違うという関係性を読み取っていませんでした。これは彼だけの問題ではありません。ドキュメントを「読んでいるつもり」でも、実際には自分の仮説に都合のよい部分だけを拾い読みしている人は驚くほど多いのです。APIのリファレンスに「このメソッドは非同期です」と書いてあっても、Promiseを返すのか、コールバックを受け取るのか、await可能なのか──書かれているはずの詳細を読んでいません。仮説を一つずつ潰していない別の学生は「バグが見つからない」と何時間も格闘していました。しかし彼は、複数の仮説を同時に追いかけて、どれも中途半端に確認していたのです。「ネットワークの問題かもしれない」と言いながらネットワークのログを確認せず、「データベースの問題かもしれない」と言いながらクエリを確認しない。問題解決には、仮説を一つずつ潰していくプロセスが必要です。この地道なプロセスを飛ばして、「なんとなく」で進めようとするから、何時間経っても解決しないのです。仮説行動――マップ・ループ・リープで学びを最大化し、大胆な未来を実現する作者:馬田隆明英治出版Amazon主語と述語を把握していない技術文書を読むとき、主語と述語の関係を曖昧にしたまま読み進めている人は非常に多いのです。「誰が」「誰に」「何を」しているのか──この基本的な構造を把握しないまま、「なんとなく」で理解したつもりになっています。小さなことの積み重ねエラーメッセージをちゃんと読む。仮説を一つずつ潰す。主語と述語を把握する。誰でもできることです。しかし、この「小さなこと」の積み重ねが、「才能がある」ように見える人と「才能がない」と思い込む人を分けています。才能があるように見える人は、これらの基礎的なプロセスを、意識的か無意識的に実践しています。これらは訓練可能です。才能ではありません。最初は意識的にやる必要があります。めんどくさいと感じるかもしれません。でも、この「めんどくさい」基礎作業を飛ばすから、結果的に何倍も時間がかかってしまうのです。なぜ、ちゃんと読めないのか「ちゃんと読むことによる成功体験」が積めていない──これが、根本的な問題かもしれません。奪われた集中力: もう一度〝じっくり〟考えるための方法作者:ヨハン・ハリ作品社Amazonインスタント化と「モヤモヤ」への耐性の喪失私たちは今、インスタントで断片的な刺激に取り巻かれています。YouTubeのレコメンド、TikTokの短い動画、LINEスタンプ──一定のリズムで繰り返されるインスタントで分かりやすい感覚やコミュニケーションが蔓延しています。スマホを持つことで、即時的な満足にいつでもアクセスできる状態にあり、「消化しきれなさ」「難しさ」「モヤモヤ」といった時間もコストもかかるものは人気がなくなっています。技術ドキュメントを読むことは、まさにこの「モヤモヤ」との戦いです。一読してすぐに理解できるものではありません。何度も読み返し、実際に試し、エラーに出会い、また読み返す。この時間のかかるプロセスが、インスタント化した感覚に慣れた私たちには耐えがたいのです。新しい技術を学ぶとき、最初は「モヤモヤ」します。でも、このモヤモヤした状態を抱えたまま、読み続け、試し続けることでしか、深い理解には到達できません。ChatGPTやClaudeに「要約して」と頼んでしまう。確かに、それでスッキリはします。でも、その過程で失われるものがあります。孤独と孤立の喪失スマホによる常時接続の世界では、何か一つのことに取り組み、一つのことに没頭する＜孤立＞が喪失しています。反射的なコミュニケーションを積み重ねるということは、相手の人格や心理状態を想像しないコミュニケーションです。同時に、退屈に耐えきれず、何か刺激やコミュニケーションを求めてスマホをいじってしまい、自分一人で時間を過ごす＜孤独＞も失われかけています。スマホ時代に必要なのは孤独と孤立であり、それらがあってこそ、自分を浸している感覚に耳を澄ませ、刺激的な経験と折り合いをつけることができます。技術ドキュメントを読むことは、まさにこの「孤立」を必要とします。一人で、ドキュメントと向き合う時間。このシンプルな行為が、現代では驚くほど難しくなっています。ネガティブ・ケイパビリティの欠如ネガティブ・ケイパビリティとは、「結論づけず、モヤモヤした状態で留めておく能力」です。把握しきれない謎をそのまま抱えておくことで、そこから新しい何かをどこまでも汲み取ろうとする姿勢のことです。これは、他者の経験を理解したり、技術を学んだりするときに必要です。謎を安易に「自分のわかる範囲」に回収しない能力と言えます。新しい技術を学ぶとき、すぐに「わかった」と思いたくなります。でも実際には、わかっていないことだらけです。このモヤモヤした状態を抱えたまま、読み続け、試し続ける。この能力が、現代人には欠けているのかもしれません。自己啓発の罠と他者の想像力悩みや困難を抱えている人は、「自分の直観に従って判断しろ」「自分の情熱に従え」というメッセージに心を揺さぶられます。しかし、このアプローチには内なる声は一つであり、その声こそ自分を然るべき一つの進路へと導いてくれるはずという前提があります。他者の想像力は、「ノイズ」としてラベリングされてしまいます。私たちは、一枚岩のような存在ではありません。自分の内側にはいくつもの声が発せられています。「他者に見られる自分」も自分の重要な構成要素となるので、他者はノイズどころか、自分を豊かに育てるものです。「才能がない」という言葉も、実はこの自己啓発の罠と表裏一体です。「才能がないから無理」は自己責任の裏返しです。でも実際には、他者の想像力を借りること、ドキュメントを丁寧に読むこと、先輩に質問することは、ノイズではなく成長の糧なのです。「自分の頭で考える」の代わりに、「他人の頭で考える」「他者の想像力を自分に取り入れる」ことが大切です。才能ではなく、学び方の問題「才能がある」と見なされる人々を注意深く見ると、彼らの多くは特別な能力を持っているわけではありません。彼らは効果的な学び方を知っているだけなのです。例えば、指摘と助言の違いを理解している人は、より速く成長します。「このコードのどこが悪いですか?」は指摘を求める質問で、過去の実績に焦点を当て、しばしば批判的な応答を引き出します。一方で「このコードをより保守性の高いものにするにはどうアプローチすべきでしょうか?」は助言を求める質問で、未来に焦点を当て、建設的な提案を引き出します。この小さな違いが、学びの質を大きく変えます。才能があるように見える人は、こうした学び方の技術を実践しています。彼らは「分からない」と素直に認め、「教えてください」と謙虚に頼み、そして得られた助言を素直に実践します。これは才能ではなく、態度の問題なのです。学びとは何か－〈探究人〉になるために (岩波新書)作者:今井 むつみ岩波書店Amazon後退も成長のプロセスの一部才能という概念を手放すと、もう一つ重要な認識が生まれます。それは、成長が必ずしも直線的ではないということです。私たちは、成長を一方向的な進歩として捉えがちです。しかし実際の成長は、螺旋を描くように進んでいきます。前進し、停滞し、時には後退し、そしてまた前進します。この後退期を「才能がない証拠」として捉えるか、「成長のための再編成」として捉えるかで、その後の軌道は大きく変わります。技術を学ぶ過程でも、この現象は頻繁に起きます。新しいフレームワークを学び始めた当初は順調に進みます。しかし、ある程度理解が深まると、突然全てが分からなくなる瞬間が来ます。これは実は、表面的な理解から深い理解へと移行する兆候なのです。しかし多くの人は、この瞬間を「やはり自分には才能がない」と解釈し、学習を放棄してしまいます。人は前進するために時に立ち止まり、後退し、そしてまた前進した先には以前よりも大きく飛躍しています。このプロセスを理解することで、停滞期や後退期を前向きに捉え直すことができます。それは失敗ではなく、次の飛躍のための準備期間なのです。手を動かすことの救いエンジニアという仕事には、一つの大きな救いがあります。それは、手を動かしている間、才能への不安が消えるということです。「自分には才能がない」という悩みは、頭の中でぐるぐる回り始めると、どんどん大きくなります。でも「これを作りたい」と思って実装を始めた瞬間、その悩みはどこかに消えます。目の前にあるのは、具体的な問題だけです。エラーが出る。調べる。解決する。また詰まる。また調べる。この「詰まる→調べる→解決する」のサイクルを回すこと自体が、静かに自信を育てていきます。最初は1つのエラーに1時間かかったのが、30分になり、10分になる。その変化を実感するとき、「成長している」という手応えが得られます。理想ではなく、作りたいものを追う重要なのは、「優秀なエンジニアになりたい」という抽象的な目標ではなく、「このアプリを作りたい」「この機能を実装したい」という具体的な目標に向かって手を動かすことです。完璧主義に陥る人は、結果に過度な完成度を求めるあまり、小さな一歩を踏み出せません。「理想的なアーキテクチャを設計してから始めよう」「全ての技術を理解してから作ろう」──そう考えて、結局何も始められない。でも実際には、小さく作って、動かして、直して、また作る。このサイクルを回すことでしか、良いものは生まれません。一つのエラーを解決する。一つの機能を実装する。一つのテストを通す。この小さな積み上げが、気づけば大きなものになっています。綿密な計画よりも、不完全でも動く一歩の方が、はるかに価値があります。あえて視野を狭めろここで、少し逆説的なことを言います。特に若い時期には、根拠がなくても、自分を信じることが重要です。「才能という幻想」を批判してきたこの記事で、矛盾するように聞こえるかもしれません。しかし、「自分には才能がある」という固定的な思い込みと、「自分はできるようになる」という成長への信頼は、全く別物です。若いうちは、視野をあえて狭めることも必要です。「これが本当に正しい道なのか」「自分に向いているのか」──そんな冷静な自己分析ばかりしていると、一歩も踏み出せなくなります。時には、根拠のない自信を持って、盲信的に突き進むことも必要です。「プログラミングなんて簡単だろう」という、ある意味で無知ゆえの大胆さ。この「若気の至り」とも言える姿勢が、最初の一歩を踏み出させてくれます。その盲信的な姿勢が、いつか本当の自信に変わります。根拠のない自信が、実績という根拠を伴った自信になります。そして気づけば、最初は「嘘」だった「自分はできる」という言葉が、本当になっているのです。問題を面白がる力もう一つ、見落とされがちな視点があります。それは、学びにおける遊び心です。才能があるように見える人は、実はこの遊び心を持っています。彼らは学びを苦痛として捉えるのではなく、謎解きとして楽しんでいます。新しいバグに出会えば「面白い現象だ」と興味を持ち、理解できない概念に出会えば「理解できたら面白そうだ」と好奇心を抱きます。この姿勢は、才能ではなく選択です。同じ状況を「苦痛」として捉えるか「挑戦」として捉えるか──その選択が、長期的な成長の軌道を決めます。そして、この選択は意識的に訓練できます。義務として学ぶのではなく、探究心を持って取り組むとき、人は最も成長します。ぐちゃぐちゃ考える暇があったら才能があるかどうかなんて、作っているときには関係ありません。目の前のエラーメッセージは、あなたが才能があるかどうかなんて気にしていません。ただ、解決策を求めているだけです。ドキュメントを読む。エラーメッセージをちゃんと読む。仮説を立てて検証する。うまくいかなければ別の方法を試す。これらは全て、才能ではなく、プロセスです。コンテストで優秀な成績を残した人たちも、結局は同じことをしています。彼らが特別なのではありません。ただ、このプロセスを高速で回せるようになっただけです。そして、その高速化は、繰り返しによってしか得られません。自分が未熟だと不安に思いながらインターンシップを始めた私が、3年経って確信していることがあります。それは、手を動かし続けた人は、必ず前に進んでいるということです。才能について悩む時間を、1行でも多くコードを書く時間に変える。理想の自分について考える時間を、作りたいものを作る時間に変える。その積み重ねが、気づけば「成長」と呼ばれるものになっています。才能という言葉を使わないここまで読んで、一つの結論に至るかもしれません。それは、才能という言葉を使わないことの重要性です。「才能がある」「才能がない」──この二元論は、成長の可能性を見えなくしてしまいます。代わりに、より具体的で建設的な言葉を使うべきです。「まだ学んでいない」「まだ練習が足りない」「まだ自分に合った学び方に出会っていない」──こうした表現は、現在の状態を固定的なものではなく、変化可能なものとして捉えさせます。インターン生に技術を教える際も、この視点の転換を意識しています。「才能がない」という言葉を聞いたら、必ず問い返します。「具体的に、何が難しいと感じている?」と。すると、「才能」という曖昧な概念ではなく、具体的な課題が見えてきます。そして具体的な課題は、具体的な対策で解決できます。「あなたには向いていないかも」ではなく、「どういう環境や説明の仕方なら理解できるだろうか」と考えます。この視点の転換が、教育者として最も重要な態度なのかもしれません。では、才能という言葉を使わないとしたら、何を語るべきなのでしょうか。それは、成長のメカニズムそのものです。どうすれば効果的に学べるか。どうすれば困難に直面しても諦めずに続けられるか。どうすれば自分の可能性を最大限に引き出せるか──こうした実践的な問いに答えることが、才能という幻想よりもはるかに価値があります。これは抽象的な話ではありません。とても実践的な話です。毎朝同じ時間に起きる習慣。集中できる環境を整える工夫。失敗から学ぶための振り返りの時間。他者から助言を求める勇気──これらは全て、トレーニング可能なスキルです。そして、これらのスキルの蓄積が、才能と呼ばれるものの正体なのかもしれません。HIDDEN POTENTIAL 可能性の科学――あなたの限界は、まだ先にある (三笠書房　電子書籍)作者:アダム・グラント三笠書房Amazon時間という最も公平な資源才能という概念に対して、時間は最も公平な資源です。どんな人にも、1日は24時間しかありません。もちろん、その24時間をどう使えるかは、環境によって大きく異なります。しかし、与えられた時間の中で、何を選択するか──その選択の積み重ねが、最終的な差を生みます。才能がある人とない人の違いは、実は時間の使い方の違いなのかもしれません。才能があるように見える人は、学習に多くの時間を投資しています。しかしそれは、単純に勉強時間が長いという意味ではありません。むしろ、質の高い時間の使い方を知っているということです。例えば、同じ1時間でも、受動的にチュートリアルを見るのと、能動的に問題を解こうとするのでは、学びの質が全く異なります。同じエラーに出会っても、すぐに答えを探すのと、まず自分で考えてみるのでは、理解の深さが変わります。時間という公平な資源を、どう使うか。これは才能ではなく、戦略の問題です。そして戦略は、学ぶことができます。あっという間に人は死ぬから　「時間を食べつくすモンスター」の正体と倒し方作者:佐藤 舞（サトマイ）KADOKAWAAmazon停滞と努力の違い時間の使い方について語るとき、見落とされがちな重要な区別があります。それは、停滞と努力の違いです。Kubernetesのワークショップで、あるインターン生がServiceの概念に数日苦しんでいました。彼は毎日、同じドキュメントを読み返していました。「努力している」と本人は言いました。でも、彼は前に進んでいませんでした。よく話を聞くと、彼はそもそもネットワークの基礎を理解していませんでした。IPアドレスとは何か、ポートとは何か、DNSがどう動くのか──こうした土台がないまま、Kubernetesの抽象的な概念を理解しようとしていたのです。難しい問題に直面したとき、人は二つの道を選びます。一つは、理解できないまま同じ説明を何度も読み返し、同じ場所でぐるぐると回り続けること。もう一つは、「何が分からないのか」を見極めて、まずそこから順番に理解していくこと。前者を停滞と呼び、後者を努力と呼びます。停滞している人は、しばしば自分が努力していると思っています。長時間向き合っている。何度も試している。でも実際には、前提となる知識が欠けたまま、同じところで足踏みを繰り返しているだけなのです。本当の意味での努力とは、今の自分が理解できるところから始めることです。Kubernetesが難しいなら、まずネットワークの基礎から。ネットワークが難しいなら、まず自分のPCで2つのプログラムを通信させることから。この段階を踏んだ学び方こそが、努力の本質です。理解の速さには個人差があります。これは残酷な現実です。でも、人生という長い時間軸で見たとき、この速さの差は思ったほど大きくありません。むしろ、一歩ずつでも前に進み続けた人と、途中で立ち止まってしまった人の差の方が、はるかに大きいのです。時間は誰にも平等です。でも、その時間を「理解できない問題の前での空回り」に使うか、「今理解できることから順に積み上げていく前進」に使うか──この選択が、長期的には想像もできないほどの差を生みます。だから、ゆっくり急いでください。今日から始めて、でも焦らず、着実に。目の前の問題が難しすぎるなら、何が前提として必要かを見極めて、より基礎的なところから。その地道な積み重ねこそが、あなたを想像もしなかった場所へと連れて行ってくれます。超一流になるのは才能か努力か？ (文春e-book)作者:アンダース・エリクソン,ロバート・プール文藝春秋Amazonどうしようもなく満たされない性質についてここまで「才能という言葉を使わないこと」を言ってきましたが、最後に一つだけ、もしエンジニアに才能というものがあるとすれば何か、という問いに答えたいと思います。それは、どうしようもなく満たされない性質です。知りたいと思う。理解したいと思う。作りたいと思う。解決したいと思う。そして、その過程を楽しめる。それをしてないと、ちゃんと生きていけない。そういう性質。これは祝福でもあり、同時に呪いでもあります。なぜなら、これらの能力はコントロールできないことが多いからです。夜中の3時に突然コードのことを考え始める。休日なのに技術ドキュメントを読んでしまう。趣味と仕事の境界が曖昧になる。多くの不都合を抱えています。だから、あまり気にしなくて良いのです。才能と能力が一致しているのは、かなり稀です。「満たされなさ」を持っていても、それが必ずしも成果に結びつくわけではありません。逆に、その「満たされなさ」を持たずとも、優れたエンジニアになることは十分に可能です。自分に才能があるのかないのか。何者かになれる人となれない人の違いは何なのか。その境目はありません。「才能がある」とか「天才だ」というのは、原因ではなく結果に対して付けられる評価です。何かを成し遂げた後で、周りが「あの人には才能があったんだ」と言うだけです。始める前から、自分に才能があるかどうかなんて、誰にも分かりません。そして、それを気にする必要もありません。重要なのは、今、目の前にあることに取り組むかどうか。その選択だけです。ご冗談でしょう、ファインマンさん（上） (岩波現代文庫)作者:Ｒ．Ｐ．ファインマン岩波書店Amazonご冗談でしょう、ファインマンさん（下） (岩波現代文庫)作者:Ｒ．Ｐ．ファインマン岩波書店Amazonおわりに様々な場所で、様々な「才能」を目撃してきました。コンテスト会場、企業のオフィス、勉強会、ワークショップ──華々しく成功した人も、静かに立ち去った人も、黙々と歩き続けている人も。私が伝えたかったのは「才能なんて存在しない」という単純なメッセージではありません。「才能という言葉を使うことで、私たちは何を見失っているのか」ということです。才能という言葉は便利です。でも、その便利さと引き換えに、私たちは変化の可能性を、成長の余地を、自分と他者の可能性を信じる力を手放しています。「才能がない」という言葉を、もし今、心の中で繰り返しているのなら──それは本当は違うかもしれません。エラーメッセージを、ちゃんと読んでいないだけかもしれません。仮説を、一つずつ潰していないだけかもしれません。インスタントな答えを求めて、モヤモヤと向き合っていないだけかもしれません。まだ、自分に合った学び方に出会っていないだけかもしれません。小さなことです。でも、その小さなことを飛ばしているから、「才能がない」と思い込んでしまう。コンテストで輝いていた同期が、燃え尽きていることがあります。勉強会で熱心だった後輩が、姿を見せなくなることがあります。一方で、当時は目立たなかった誰かが、誰も予想しなかった場所で花を咲かせていることもあります。スタート地点の優劣など、長い人生においてはほとんど意味をなさない──20代を通じて、私はそう学びました。あなたの可能性は、スタート地点では測れません。どれだけ伸びたか、どれだけ学んだか、どれだけ変化したか──それこそが、本当の意味での能力です。才能という幻想を手放したとき、初めて見えてくる景色があります。それは、不完全な今の自分を受け入れ、それでも前に進み続けることの静かな勇気です。未熟な自分がインターンシップを始めて3年。今でも不安はあります。でも、若手と一緒に作業する中で気づきました。彼らが必要としているのは、全てを知り尽くした指導者ではありません。共に悩み、共に考え、そして「才能」という言葉で可能性を閉ざさない、そんな誰かです。この記事を通じて、私自身もまた、自分に言い聞かせています。才能があるかどうかなんて、後になってから誰かが決めることです。大切なのは、今、目の前にあることに手を動かし続けること。その積み重ねだけです。最後に、私自身のことを少しだけ。私にはいくつかの目標があります。世界的に有名なOSSを作って、海外で見知らぬ人にコーヒーを奢ってもらいたいです。書籍をコンスタントに出して、いつか道端でサインを求められたいです。週刊プレイボーイに連載を載せて、毎週誰から指摘されても反論ができるようにグラビア雑誌を買うことです。できるかどうかは分かりません。才能があるかどうかも分かりません。でも、文章を書き続けています。コードを書き続けています。なぜなら、それが私にとって「満たされなさ」を満たす行為だからです。そして、その過程を楽しんでいるからです。あなたにも、そんな「満たされなさ」があるなら。それに向かって、ただ手を動かし続けてください。それが才能かどうかなんて、後になってから誰かが決めることです。","isoDate":"2025-10-28T02:30:09.000Z","dateMiliSeconds":1761618609000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"技術力に優劣はある(「技術力に優劣はない」を読んで)","link":"https://syu-m-5151.hatenablog.com/entry/2025/10/27/134629","contentSnippet":"sizu.meはじめに先日、「技術力に優劣はない（技育などに参加している学生に向けて）」という記事を読みました。技育に参加する学生たちへの励ましのメッセージで、技術との向き合い方の多様性を認め、コミュニケーション力の重要性を説き、相互リスペクトの大切さを訴える、とても温かい内容でした。この記事は、あの記事の対象読者ではない私が、横から口を出すような形になってしまうことを承知で書いています。 元の記事の主張——技術の感受性には段階があること、ジュニアにはコミュニケーションが大事なこと、べき論に揺さぶられないこと、どの段階にいてもキャリアは作れること——これらは本質的に正しいと思います。ただ、私はこう思います。それでもなお、技術力という軸においては、やはり優劣が存在し、それが中長期的なキャリアに大きな影響を与えます。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきましょう。技術との向き合い方元の記事では、技術への向き合い方を3段階に分けていました。この分類は本質を捉えていると思います。技術を道具として使う人技術を理解する人技術を創る人この分類自体はとても良いのですが、私はこれをポケモンの進化のような段階的なものとは捉えていません。むしろ、これらは固定的な段階ではなく、状況や分野によってシームレスに行き来するものだと感じています。例えば、Reactについては深い理解があり、新しいパターンを生み出せる人でも、機械学習の分野では既存のライブラリを使うだけかもしれません。人は常に3つの状態を往復しています。新しい分野に挑戦すれば「道具として使う」状態に戻りますし、経験を積めば「理解する」状態に移行し、さらに探求すれば「創る」状態に到達します。それぞれの状態の中には優劣は存在するここで重要なのは、これら3つの状態は確かに流動的ですが、それぞれの状態の中には明確に優劣が存在するということです。「道具として使う」中には優劣があります。 同じ「道具として使う」状態でも、ドキュメントを読んで適切に活用できる人と、エラーが出たらすぐに諦めてしまう人では、生産性に大きな差があります。基本的な概念を理解しながら使っている人と、ほぼブラックボックスとして使っている人では、応用力が全く異なります。そして今、生成AIを効果的に活用できる人とそうでない人では、学習速度に圧倒的な差が生まれています。エラーメッセージをAIに投げて適切な解決策を引き出せる人と、ただコピペして満足する人では、問題解決能力が変わってきます。「理解する」中には優劣があります。 内部実装を読んで理解している人と、公式ドキュメントレベルの理解に留まっている人では、問題解決能力に差があります。パフォーマンスの特性やエッジケースまで把握している人と、基本的な使い方だけ知っている人では、設計の質が変わってきます。ここでも生成AIの活用法に差が出ます。複雑なコードベースの理解を加速するためにAIを使える人と、単に「これ何してるの？」と聞くだけの人では、深い理解への到達速度が違います。技術的な仮説を立て、AIに検証させながら学びを深められる人は、独学だけの人より効率的に専門性を高められます。「創る」中には優劣があります。 既存のものを少し改良したレベルと、まったく新しいパラダイムを生み出すレベルでは、技術的なインパクトが桁違いです。自分のプロジェクトで使える小さなライブラリを作る人と、業界全体に影響を与えるOSSを開発する人では、その影響力は比較になりません。そして今、生成AIを創造のパートナーとして使いこなせる人とそうでない人では、アウトプットの質と量に大きな差が生まれています。アイデアの壁打ち相手としてAIを使い、設計の初期段階を加速できる人。実装の定型部分をAIに任せ、本質的な設計に集中できる人。こういった使い方ができる人は、同じ時間でより高度なものを創り出せます。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazon向き合い方の違いを優劣として捉えがちしかし、学生や若いソフトウェアエンジニアは、この向き合い方の違いを、ソフトウェアエンジニアとしての優劣として捉えがちだという側面があります。「自分は道具として使っているだけだから、ダメなエンジニアだ」「あの人は技術を創っているから、自分よりずっと上だ」こういった思考に陥りやすいです。それが過度な自己否定につながったり、逆に、ある分野で「創る」状態に到達したことで慢心したりします。しかし、向き合い方は分野によって変わります。誰もが全ての技術について「創る」状態にいるわけではありません。そして、「道具として使う」状態であることが、必ずしも劣っているわけではありません。重要なのは、どの状態にいるかではなく、その状態の中でどのレベルにいるか、そして複数の領域でどう組み合わせているかです。熟達論―人はいつまでも学び、成長できる―作者:為末大新潮社Amazon能力ではなく衝動や偏愛人を「道具として使う」状態から「理解する」状態へ、さらには「創る」状態へと突き動かすものは、おそらくは計画的なキャリアデザインではありません。むしろ、それは衝動や偏愛に近いものだと思います。あるいは、そうした衝動を自然と抱けるような環境に身を置けるかどうかです。「なぜかこのエラーメッセージが気になる」「この実装がどうなっているのか知りたくて仕方がない」「この技術で何かを作りたいという衝動が止まらない」——こういった、理屈では説明しきれない偏愛が、人を技術の深みへと引き込んでいきます。そして、周囲に技術を深く追求する人たちがいる環境は、そうした衝動を自然と育んでくれます。人生のレールを外れる衝動のみつけかた (ちくまプリマー新書)作者:谷川嘉浩筑摩書房Amazonそれでもなお、市場価値の差は存在するしかし、この3つの状態の間には、やはり市場価値の差が存在します。そして、どの状態に長く留まっているか、その状態の中でどのレベルにいるかが、中長期的なキャリアに大きな影響を与えます。「道具として使う」状態に留まり続けることのリスクは、年齢を重ねるほど大きくなります。表面的な理解しかないエンジニアは、年齢を重ねると「代替可能な人材」になっていきます。若手の方が給与が安く、学習意欲も高いです。同じ「道具として使う」状態であれば、企業が選ぶのは若手です。一方、主要な技術領域で「理解する」状態に到達できれば、市場価値は変わります。そして、いくつかの領域で「創る」状態に到達している人は、さらに大きな影響力を持ちます。さらに、同じ「理解する」状態でも、そのレベルの高さによって市場価値は大きく変わってきます。この差を「優劣ではない、違いだ」と言えるでしょうか？ 市場は明確に評価しています。ジュニアに技術力は求められていない？元の記事は「ジュニアに技術力は求められていない」と述べていました。確かに、新卒や入社1〜2年目であれば、それは正しいです。しかし、これを「技術力を磨かなくてもいい理由」にしてはいけません。「ITエンジニアの転職学」では年収600万円を超えるには、以下のような能力で「自立レベル」への到達が求められます。設計力/実装力：アーキテクチャ設計、コーディング、技術選定など専門性の深さと広さ：特定領域の深い知識と、周辺技術の幅広い理解推進力・プロジェクト貢献：プロジェクトを前に進める力、スケジュール管理組織貢献：チームビルディング、メンバー育成、採用への貢献事業・顧客貢献：ビジネス価値への理解、顧客課題の解決情報発信・プレゼンス：技術ブログ、登壇、OSS活動などこのレベルに到達するのは、通常は入社3〜5年目だと言われています。つまり、「ジュニアには技術力は求められていない」というのは、せいぜい20代半ばまでの話です。それを過ぎても設計力/実装力や専門性が低いままだと、キャリアは確実に行き詰まります。ITエンジニアの転職学 2万人の選択から見えた、後悔しないキャリア戦略 (KS科学一般書)作者:赤川 朗講談社Amazonコミュニケーション力と技術力は対立しない元の記事では、技術の勉強をしている人とそうでない人が対比され、後者は「別の有意義なことをしている」と書かれていました。確かに、ゲームをしたり、友達と飲みに行ったりする時間は人生において大切です。キャリアは短距離走ではなく、中長距離走です。 燃え尽きないことが重要であり、適度な息抜きや趣味の時間は必要です。しかし、それは「技術を学ばない理由」にはなりません。 むしろ、中長距離だからこそ、地道な積み重ねが最終的に大きな差を生みます。1年、3年、5年と継続的に学び続けることで、技術力は確実に向上します。なぜなら、優秀なエンジニアは、技術力もコミュニケーション力も両方高いからです。これは対立するものではなく、掛け算で効いてくるものです。私が見てきた優秀なエンジニアたちは、例外なく以下の特徴を持っていました。設計力/実装力が高い（主要技術について「理解する」以上の状態）コミュニケーション力も高いビジネス理解力がある学習意欲が高い「技術力がないから、コミュニケーション力で勝負する」というのは、戦略ではなく妥協です。本当に市場価値を高めたいなら、先ほど挙げた6つの能力を、バランス良く磨く必要があります。syu-m-5151.hatenablog.comキャリアの中盤で見えてくる分岐点20代のうちは、技術力の差はそれほど致命的ではません。コミュニケーション力や調整力でカバーできるし、「これから成長すればいい」という期待値もあります。しかし、キャリアの中盤になると、市場が求めるレベルは急激に上がります。技術的な意思決定ができることチームをリードできることアーキテクチャ設計ができること若手を育成できることこれらはすべて、高い技術力を前提としています。 コミュニケーション力だけでは、技術的な意思決定はできません。表面的な理解では、アーキテクチャ設計はできません。自分が技術を深く理解していなければ、若手を育成することもできません。早期のマインド切り替えと継続的な努力「追いつけない」ではなく「只々積み上げる」元の記事には、圧倒的なテックリードを見て「自分が3に行けることはないと実感した」という記述があった。この気持ちはよくわかります。圧倒的な技術力を持つ人を目の当たりにしたとき、「自分には無理だ」と感じる瞬間は、多くのエンジニアが経験することです。しかし、そのテックリードもまた、努力の積み重ねでそこに到達しているということを忘れてはいけません。彼らは最初から「創る」状態にいたわけではません。膨大な時間をかけて技術を学び、無数のエラーと格闘し、何度も失敗を繰り返し、そして徐々に深い理解を獲得していった。「あの人は天才だから」と片付けてしまうのは、その人が積み重ねてきた努力を見ないことになります。そして、自分自身の成長の可能性を閉ざすことにもなります。その積み重ねを軽く見てはいけません。確かに、技術に対する偏愛や衝動の強さは人それぞれです。しかし、それでもなお、努力で到達できる範囲は思っているより広いです。 毎日1時間でもいいです、技術書を読みましょう。個人プロジェクトに取り組みましょう。エラーメッセージと真剣に向き合いましょう。こういった地道な積み重ねが、1年後、3年後、5年後の自分を作ります。技術力が高いエンジニアは、キャリアの中盤以降も選択肢が広がり続けます。一方、主要技術について表面的な理解に留まっているエンジニアは、選択肢が狭まっていきます。これが、早期に技術力を磨くことの重要性です。達人プログラマー ―熟達に向けたあなたの旅― 第2版作者:David Thomas,Andrew Huntオーム社Amazonやる気は行動の後からついてくる「技術を学ばなければ」と頭では理解していても、なかなか実行に移せません。モチベーションが湧かません。やる気が出ません。こういった悩みを抱えている人は多い。しかし、ここで重要な真実があります。やる気を出すには、やるしかません。多くの人は「やる気が出たら始めよう」と考える。しかし、これは因果が逆です。やる気は行動の前に現れるものではなく、行動の後からついてくるものです。心理学の研究でも明らかになっているが、人間の脳は「行動を始めてから」やる気を出すようにできています。作業興奮という現象です。まずは5分だけコードを書いてみる。1ページだけ技術書を読んでみる。すると、脳が活性化し、自然と続けたくなります。「理想的な環境が整ったら」「十分な時間ができたら」「気分が乗ったら」——こういった条件を待っていても、その日は永遠に来ません。理想的な状態を待つのではなく、不完全なままでも始めることです。毎日30分でいいです。週末の2時間でいいです。小さく始めて、継続しましょう。それが1ヶ月、3ヶ月、1年と続けば、気づいたときには大きな差になっています。「やる気が出ないから動けない」のではなく、「動かないからやる気が出ない」のです。だから、やる気を出すには、やるしかありません。 今この瞬間から、小さな一歩を踏み出しましょう。ジェームズ・クリアー式 複利で伸びる1つの習慣作者:ジェームズ・クリアーパンローリング株式会社Amazon学生のうちに気づけるなら私が最も伝えたいのは、早期にマインドを切り替え、只々研鑽を積み重ねることの重要性だ。早く気づけば気づくほど、リカバリーは容易になります。学生なら今が絶好のタイミングです。時間はたっぷりあります。大学の授業だけでなく、個人プロジェクト、OSS、インターン——自分に合った形で技術と向き合いましょう。一時の成功も失敗も、長い人生の中では泡のようなものです。 今日のコンテストでの勝利も、明日の挫折も、それ自体は大した意味を持たません。重要なのは、そこから何を学び、次にどう活かすかです。そして、本当のトップレベルを見に行こう。 自分より優秀な人たちがいる環境に飛び込み、「ボコボコにされる」経験をしましょう。それは屈辱的かもしれないが、それこそが成長のチャンスです。ただし、一度の挫折で諦めないでほしいです。 圧倒的な実力差を見せつけられても、それは終わりではありません。自分の現在地を知る機会です。そこから、只々積み上げていけばいいです。社会人になってから気づいても遅くはない20代であっても、キャリアの中盤であっても、「技術力を磨かなければ」と気づいた時点から始めれば、必ず変わります。ただし、学生時代より難易度は上がります。家庭があるかもしれません。体力も落ちているかもしれません。それでも、今から本気で取り組めば、道は開けます。業務時間外の勉強を習慣化しましょう。技術書を読みましょう。個人プロジェクトを作りましょう。2〜3年本気で取り組めば、主要技術について表面的な理解から深い理解へと確実に移行できます。そうなれば、市場価値は大きく変わります。気づいた時点が、あなたにとっての「今」です。過去を悔やむより、今から只々積み上げていきましょう。キャリア戦略の選択肢エンジニアとして生きていく上で、大きく分けて2つの戦略があります。選択肢1: 技術のスペシャリストを目指す本気で技術を磨き、技術者として高い評価を得られるエンジニアになります。これは楽な道ではません。業務時間外も勉強し、常に新しい技術にキャッチアップし、OSSにコントリビュートし、深夜までコードを書きます。しかし、その努力は報われる。キャリアの中盤で選択肢が広がり、技術者としての充実感を得られます。市場価値も高く、転職の選択肢も豊富です。スタッフエンジニア　マネジメントを超えるリーダーシップ作者:Will Larson日経BPAmazon選択肢2: 技術とビジネスのバランス型を目指す設計力/実装力は一定レベルに抑え、組織貢献や事業・顧客貢献で価値を出す。プロダクトマネージャーやエンジニアリングマネージャーを目指す道です。これも立派な戦略です。しかし、技術の基礎理解は必須です。 表面的な理解だけで「マネジメントに進む」というのは、逃げに過ぎません。マネージャーやPMになっても、技術を深く理解していなければ、チームから信頼されず、技術的な制約や可能性を踏まえた意思決定もできません。どちらを選ぶにせよ、技術力に優劣があることを認め、自分の現在地を正確に把握することが、全ての出発点です。 そして、気づいた時点から、只々積み上げていくことが大切です。エンジニアのためのマネジメントキャリアパス ―テックリードからCTOまでマネジメントスキル向上ガイド作者:Camille FournierオライリージャパンAmazon一つの物差しで人を測るなここまで技術力の重要性を語ってきたが、同時に伝えておきたいことがあります。学生時代から社会人の初期にかけて、私はカンファレンスやイベントで、相手の技術的な知識を試すような会話をしていました。わざと難しい質問を投げかけて、相手が答えられないのを見て優越感に浸る。今振り返ると、最低です。当時の私は、技術力の有無だけで人間の優劣を測っていました。学生のギーク層にありがちな行動だが、自分がイキれる相手を見つけて、マウントを取るのは確かに気持ちがいい。でも、それは恥ずべき行為です。他者と働く──「わかりあえなさ」から始める組織論 (NewsPicksパブリッシング)作者:宇田川元一ニューズピックスAmazonただし、逆の極端も問題だと思っています。世の中には「技術力なんてどうでもいい、面白い人間かどうかが全て」という価値観もあります。確かに、人間的な魅力は重要です。でも、それを唯一の評価軸にして「技術バカは使えない」「コミュ力こそ全て」と言い切るのも、結局は別の物差しで人を測っているだけです。技術力で人を測るのも、コミュ力で人を測るのも、面白さで人を測るのも、本質的には同じ過ちです。この記事で私は「技術力の優劣を直視せよ」と書いてきた。市場価値という文脈では、技術力の差は厳然として存在します。それを無視してキャリアを語ることはできません。しかし、それはあくまで市場価値という一つの軸での話です。 技術力が高いからといって人として偉いわけではません。逆に、技術力が低いからといって人として劣っているわけでもません。イベントで出会った人が、あなたより技術的な知識が少ないように見えても、その人にはその人の文脈があります。学びの途中かもしれません。別の分野のエキスパートかもしれません。技術以外の部分で圧倒的な価値を生み出している人かもしれません。大切なのは、相手の文脈を読み取って会話できることです。 自分の得意な物差しだけで人を評価し、優越感に浸るのは、いくら専門性が高くても人として未熟です。技術力を磨くことと、人として成熟することは、まったく別の話なのだから。「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策作者:今井むつみ日経BPAmazonおわりに長々と書いてきたが、最後にもう一度、元の記事への敬意を示したい。元の記事は、学生たちを励まし、多様性を尊重し、相互リスペクトを訴える、とても温かい内容でした。その優しさと配慮は、本当に素晴らしいと思います。私はこの記事で「技術力に優劣はある」と主張してきた。それは市場価値やキャリアという観点では事実です。しかし同時に、技術力で人間の価値を測ってはいけません。技術力が高いことと、人として成熟していることは別物です。むしろ、技術力があるからこそ、謙虚さとリスペクトを忘れてはいけません。「優劣はない」という優しい言葉に安住せず、現実を直視してほしいです。そして、今のうちに本気で技術を学んでほしいです。キャリアは中長距離走です。 今なら、まだ間に合います。ただし、技術を学ぶ過程で、決して人を見下してはいけません。相手の文脈を理解し、リスペクトを持ってコミュニケーションを取りましょう。それができて初めて、優秀なエンジニアと言えるのだと思います。Googleのソフトウェアエンジニアリング ―持続可能なプログラミングを支える技術、文化、プロセスオライリージャパンAmazonこの記事は、元の記事の筆者や読者を否定する意図はありません。対象読者ではない私が横から口を出すような形になってしまい申し訳ありませんが、学生時代の自分に伝えたかったこと、そして過去の自分を反省する気持ちを込めて書きました。","isoDate":"2025-10-27T04:46:29.000Z","dateMiliSeconds":1761540389000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"cargo-chefがRustのDockerビルドを高速化する話","link":"https://syu-m-5151.hatenablog.com/entry/2025/10/18/163911","contentSnippet":"はじめに前回の記事では、Rust の Docker イメージサイズを 98%削減する方法を解説しました。その中で最も重要な役割を果たしているのが cargo-chef です。この記事では、cargo-chef の仕組みと動作原理を深く掘り下げていきます。syu-m-5151.hatenablog.comcargo-chef は、Docker のレイヤーキャッシングと Cargo のビルドモデルの根本的な不整合を解決し、Rust プロジェクトのDockerビルドを5倍高速化します。Luca Palmieri が「Zero to Production In Rust」のために作成したこのツールは、ソースコード変更のたびに 20 分以上かかっていたリビルドを、依存関係をアプリケーションコードから分離してキャッシュし、2〜3 分のビルドに変えました。www.zero2prod.comcargo-chef は依存関係情報のみを捉えた「レシピ」を作成し、ソースコードが変更されても有効なままの別レイヤーで高コストな依存関係のコンパイルをキャッシュできます。約 500 の依存関係を持つ商用コードベースでは、ビルド時間が約 10 分から約 2 分に短縮され、CI/CD の速度とインシデント対応時間に直接影響を与えます。github.comRustのDockerビルドにおける根本的な問題Docker のレイヤーキャッシングは、各命令(RUN、COPY、ADD)に対してレイヤーを作成します。いずれかのレイヤーが変更されると、そのレイヤーとそれ以降のすべてのレイヤーが無効化されます。標準的な Rust Dockerfile は重大な問題に直面します: 依存関係のマニフェストとソースコードの両方を一緒にコピーする必要があるため、ソースの変更があるとビルドキャッシュ全体が無効になってしまうのです。問題のあるパターン:FROM rust:1.75WORKDIR /appCOPY . .              # マニフェストとソースを一緒にコピーRUN cargo build       # 変更のたびにすべてを再ビルドPython の pip install -r requirements.txt や Node の npm install とは異なり、Cargoには依存関係のみをビルドするネイティブな方法がありません。cargo build コマンドは、依存関係とソースのコンパイルを統一された操作として扱います。cargo build --only-deps のようなフラグは存在しません。このアーキテクチャ上の制限により、他の言語では美しく機能する標準的な Docker パターンが、Rust では壊滅的に失敗してしまいます。影響は開発ワークフロー全体に波及します。すべてのコード変更—たった 1 文字の修正でさえ—数百の依存関係の完全な再コンパイルを引き起こします。2〜4 コアの CI システムでは、ビルドが 30 分を超えることがあります。これにより、デプロイ速度、インシデント対応時間、開発者の反復サイクルに厳しい下限が生まれます。本番環境のインシデントで緊急パッチが必要な場合、その 20 分のビルドが 20 分のダウンタイムになります。Rustのビルドが特に問題になる理由Rust のコンパイルモデルは、コンパイル時間の速度よりも実行時パフォーマンスを優先します。リリースビルド(--release)は、中規模のプロジェクトで 15〜20 分かかる広範な LLVM 最適化パスを実行します。ジェネリクス、トレイト特殊化、単相化の多用により、依存関係は各使用パターンに対して相当量のコードをコンパイルします。非同期エコシステム(tokio、actix-web、tonic)はこれを悪化させます—これらのクレートは単純なアプリケーションでもコンパイルが重いのです。インクリメンタルコンパイルは存在しますが、リリースビルドではデフォルトで無効になっており、外部依存関係には役立ちません。Docker の本番ビルドは常に --release プロファイルを使用するため、遅いコンパイルパスを避けられません。依存関係のコンパイルは通常、総ビルド時間の 80〜90%を消費しますが、これらの依存関係はアプリケーションコードに比べてほとんど変更されません。この逆転した関係—最も遅い部分が最も変更されない—こそが、cargo-chef が活用するポイントです。アーキテクチャプロジェクト構造:src/main.rs - コマンドパースを含む CLI エントリポイントsrc/lib.rs - ライブラリエントリポイントsrc/recipe.rs - レシピ生成、依存関係ビルド、クッキングロジックsrc/skeleton.rs - プロジェクトスケルトンの作成とダミーファイル生成cargo-chef のアーキテクチャは 2 つの抽象化を中心としています: RecipeとSkeleton。Recipe はシリアライズ可能なコンテナで、Skeleton は実際のマニフェストデータとロックファイルを含みます。これらの構造により、コアワークフローが可能になります: 分析 → シリアライズ → 再構築 → ビルド。レシピコンセプトと動作原理「レシピ」は、ソースコードなしで依存関係をビルドするために必要な最小限の情報を捉えたJSONファイル(recipe.json)です。これは Python の requirements.txt と同じ目的を果たしますが、Rust のより複雑なプロジェクト構造に対応しています。レシピの内容:プロジェクト全体のすべての Cargo.toml ファイルとその相対パスCargo.lock ファイル(存在する場合)、正確な依存関係バージョンのためすべてのバイナリとライブラリの明示的な宣言—正規の場所(src/main.rs、src/lib.rs)にあるものでもスケルトン再構築のためのプロジェクト構造メタデータpub struct Recipe {    pub skeleton: Skeleton,}pub struct Skeleton {    manifests: Vec\u003cManifest\u003e,    lock_file: Option\u003cString\u003e,}この構造は人間が読める JSON にシリアライズされ、レシピはデバッグ可能で検査可能です。明示的なターゲット宣言により、Cargo が通常ファイルの場所からターゲットを推測する場合でも、信頼性の高いキャッシュが保証されます。動作原理と内部メカニズムcargo-chef は、マルチステージビルドで連携する 2 つのコマンドを提供します:1. cargo chef prepare --recipe-path recipe.jsonこのコマンドは次のように現在のプロジェクトを分析します。ベースパスからディレクトリを再帰的にトラバース相対パスを保持してすべての Cargo.toml ファイルを収集依存関係バージョンロックのために Cargo.lock を読み取りSkeleton データ構造を作成マニフェスト内の明示的なターゲット宣言を確保recipe.json にシリアライズprepare コマンドは高速(通常 1 秒未満)です。ファイル構造を分析して TOML をパースするだけで、コンパイルは行わないためです。2. cargo chef cook --release --recipe-path recipe.jsonこのコマンドは次のように再構築とビルドを行います。recipe.json を Skeleton に逆シリアライズskeleton.build_minimum_project() を呼び出してディレクトリ構造を再作成すべての Cargo.toml ファイルを相対パスに書き込みCargo.lock をディスクに書き込みすべてのターゲット(main.rs、lib.rs、build.rs)に対してダミーソースファイルを作成指定されたフラグで cargo build を実行skeleton.remove_compiled_dummies() 経由でコンパイル済みダミーアーティファクトを削除ダミーファイルトリック: cargo-chef は次のように最小限の有効な Rust ファイルを作成します。// ダミーのmain.rsfn main() {}// ダミーのlib.rs// (空または最小限)これらは Cargo がコンパイル可能なプロジェクトを要求する条件を満たしますが、実際のロジックは含まれていません。その後、Cargo は通常通りすべての依存関係を解決してコンパイルし、キャッシュされたアーティファクトを生成します。ダミーアーティファクトは後でクリーンアップされ、外部依存関係のコンパイル結果のみが残ります。重要な技術的制約: cook とその後の build コマンドは、同じ作業ディレクトリから実行すべきです。これは、target/debug/deps 内の Cargo の *.d ファイルにターゲットディレクトリへの絶対パスが含まれているためです。ディレクトリを移動するとキャッシュの利用が壊れます。これは cargo-chef の制限ではなく、cargo-chef が尊重する Cargo の動作です。Docker統合とマルチステージビルドcargo-chef は、Docker のマルチステージビルド機能用に特別に設計されています。標準的なパターンは 3 つのステージを使用します:標準的な3ステージパターン:FROM lukemathwalker/cargo-chef:latest-rust-1 AS chefWORKDIR /app# ステージ1: Planner - レシピを生成FROM chef AS plannerCOPY . .RUN cargo chef prepare --recipe-path recipe.json# ステージ2: Builder - 依存関係をキャッシュFROM chef AS builderCOPY --from=planner /app/recipe.json recipe.jsonRUN cargo chef cook --release --recipe-path recipe.json# ↑ このレイヤーは依存関係が変更されるまでキャッシュされる# 次にソースをコピーしてアプリケーションをビルドCOPY . .RUN cargo build --release --bin app# ステージ3: Runtime - 最小限の本番イメージFROM debian:bookworm-slim AS runtimeWORKDIR /appCOPY --from=builder /app/target/release/app /usr/local/binENTRYPOINT [\"/usr/local/bin/app\"]キャッシングの仕組み:各 Docker ステージは独立したキャッシングを維持します。ステージは COPY --from 文を通じてのみやり取りします。この分離が cargo-chef の効果の鍵です。planner ステージの COPY . . は planner キャッシュを無効化(ただしこれは高速)Planner はフルソースツリーから recipe.json を生成Builder ステージは COPY --from=planner 経由で recipe.json のみを受け取るrecipe.jsonのチェックサムが変更されていない限り、builderの依存関係レイヤーはキャッシュされたままCargo.toml または Cargo.lock が変更された場合にのみ recipe.json が変更されるソースコードの変更は recipe.json に影響しないため、依存関係レイヤーはキャッシュされたままキャッシュ無効化ロジック:ソースコード変更 → plannerステージ無効化                → recipe.json変更なし                → builderの依存関係レイヤーキャッシュ済み ✓                → アプリケーションビルドのみ実行依存関係変更    → plannerステージ無効化                → recipe.json変更                → builderの依存関係レイヤー無効化 ✗                → フルリビルド必要これはインセンティブを完璧に整合させます: 高コストな操作(依存関係コンパイル)は、そうあるべき時(依存関係が変更されていない時)にキャッシュされ、高速な操作(ソースコンパイル)は期待通り毎回の変更で実行されます。ビルドプロセスの統合とサポート機能cargo-chef は標準的な Cargo ワークフローとシームレスに統合し、ビルドカスタマイズの全範囲をサポートします:ビルドコマンド:build(デフォルト)check(--check フラグ経由)clippyzigbuildサポートされるオプション:プロファイル選択: --release、--debug、カスタム --profile機能: --features、--no-default-features、--all-featuresターゲット: --target、--target-dir(ファーストクラスのクロスコンパイルサポート)ターゲットタイプ: --benches、--tests、--examples、--all-targets、--bins、--binワークスペース: --workspace、--package、--manifest-pathCargo フラグ: --offline、--frozen、--locked、--verbose、--timingsツールチェーンオーバーライド: cargo +nightly chef cookワークスペースサポートは自動です。cargo-chef はワークスペース内のすべてのクレートを検出し、正しく処理します。ファイルやクレートが移動しても、cargo-chef は自動的に適応します—Dockerfile の変更は不要です。これは、プロジェクト構造をハードコードする手動アプローチに対する大きな利点です。ビルド済みDockerイメージは Docker Hub の lukemathwalker/cargo-chef で利用可能で、柔軟なタグ付けができます。latest-rust-1.75.0(特定の Rust バージョンの最新 cargo-chef)0.1.72-rust-latest(最新の Rust の特定 cargo-chef)Alpine バリアント: latest-rust-1.70.0-alpine3.18バージョンの一貫性: すべてのステージで同一のRustバージョンを使用すべきです。バージョンの不一致は、異なるコンパイラバージョンが異なるアーティファクトを生成するため、キャッシングを無効化します。主要機能と実用的なユースケース主なユースケース:1. CI/CDパイプラインの最適化 - 標準的なユースケースです。すべてのコード変更が CI で Docker ビルドをトリガーします。cargo-chef なしでは、各ビルドが 500 以上のすべての依存関係を再コンパイルします(10〜20 分)。cargo-chef があれば、変更されていない依存関係はキャッシュされ、ビルドは 2〜3 分に短縮されます。これは次のような点に直接影響します。デプロイ速度(機能をより速くリリース)インシデント対応(本番環境をより速くパッチ)開発者体験(PR へのより速いフィードバック)インフラコスト(消費される CPU 分の削減)2. マルチステージビルド - ビルド環境とランタイム環境を分離。ビルダーステージは完全な Rust ツールチェーン(800MB 以上)を含み、ランタイムステージは最小イメージ(25〜50MB)を使用します。cargo-chef は、高コストなビルダーステージをキャッシュ状態に保つことで、このパターンを実用的にします。3. ワークスペース/モノレポプロジェクト - 依存関係を共有する複数のバイナリとライブラリを自動的に処理します。手動アプローチはワークスペースで破綻します; cargo-chef は透過的に処理します。4. クロスコンパイル - --target フラグ経由でファーストクラスサポート。例: Alpine Linux デプロイのために x86_64-unknown-linux-musl バイナリを CI でビルド。ターゲット指定は依存関係キャッシング中に尊重されます。高度な最適化戦略:sccacheとの組み合わせ:FROM rust:1.75 AS baseRUN cargo install --locked cargo-chef sccacheENV RUSTC_WRAPPER=sccache SCCACHE_DIR=/sccache# ... plannerステージ ...FROM base AS builderRUN --mount=type=cache,target=$SCCACHE_DIR,sharing=locked \\    cargo chef cook --release --recipe-path recipe.jsonこの組み合わせは2層のキャッシングを提供します。cargo-chef: 粗粒度(依存関係レイヤー全体)sccache: 細粒度(個々のコンパイルアーティファクト)1 つの依存関係が変更された場合、cargo-chef はすべてを再ビルドしますが、sccache は個々のクレートコンパイルをキャッシュします。変更された依存関係のみが実際に再コンパイルされます。BuildKitキャッシュマウント:RUN --mount=type=cache,target=/usr/local/cargo/registry \\    --mount=type=cache,target=/usr/local/cargo/git \\    cargo chef cook --release --recipe-path recipe.jsonこれは cargo レジストリ自体をキャッシュし、再ダウンロードを回避します。sccache および cargo-chef と組み合わせることで、Rust Docker ビルドの現在のベストプラクティスとなります。重要な制限と考慮事項作業ディレクトリの制約 - cargo cook と cargo build は、Cargo の *.d ファイル内の絶対パスのため、同じディレクトリから実行すべきです。これは Docker では煩わしくありませんが、認識すべきです。ローカルパス依存関係 - プロジェクト外の依存関係(path = \"../other-crate\" で指定)は、変更されていなくてもゼロから再ビルドされます。これは、タイムスタンプベースのフィンガープリントに関連する Cargo の制限(issue #2644)です。コピーするとタイムスタンプが変更され、フィンガープリントが無効になります。ローカル開発には不向き - cargo-chef はコンテナビルド専用に設計されています。既存のコードベースでローカルに実行すると、ファイルが上書きされる可能性があります。このツールは、ターミナル環境で実行される場合の安全警告を含みます。ワークスペースの動作 - cargo chef cook はデフォルトですべてのワークスペースメンバーをビルドします。1 つのサービスのみが必要な大規模ワークスペースの場合、これによりビルド時間が増加する可能性があります。回避策には、ターゲットビルドフラグまたはサービスごとの個別の Dockerfile が含まれます。最適なユースケース - cargo-chef は以下に最大の利益を提供します。中規模から大規模プロジェクト(500 以上の依存関係)安定した依存関係ツリー(まれに変更)頻繁なデプロイ(CI/CD 環境)共有ビルドインフラを持つチーム環境非常に小規模なプロジェクト(少数の依存関係)の場合、オーバーヘッドが利益を上回る可能性があります。設計パターンとアーキテクチャの決定注目すべき技術的決定:JSONレシピ形式 - バイナリ形式ではなく JSON を使用し、レシピは人間が読めてデバッグ可能です。recipe.json を検査して、cargo-chef が何を抽出したかを正確に確認できます。明示的なターゲット宣言 - 正規の場所にある場合でも、すべてのターゲットを明示的に宣言するように Cargo.toml を変更します。これにより、キャッシュ無効化全体で Cargo がそれらを確実に認識します。マニフェスト操作 - 手動パースではなく、ワークスペース構造へのプログラマティックアクセスに cargo_metadata クレートを使用します。これにより Cargo の進化に伴う堅牢性が提供されます。TOML順序保持 - preserve_order 機能を持つ TOML を使用して、シリアライゼーションを通じたラウンドトリップ時にマニフェスト構造の整合性を維持します。安全機能 - atty クレートを使用したターミナル検出。対話的に実行された場合の警告メッセージ。ローカル環境での偶発的なファイル上書きを防ぐために、明示的なユーザー確認が必要です。採用された設計パターン:ビルダーパターン(Recipe/Skeleton 構築)コマンドパターン(CommandArg enum)ファサードパターン(複雑さを隠すシンプルな 2 コマンドインターフェース)テンプレートメソッドパターン(build_dependencies オーケストレーション)おわりにcargo-chef は、Cargo 自体が提供しない依存関係とソースコンパイルの分離を作成することで、Rust 特有の Docker レイヤーキャッシング問題を解決します。このツールの優雅さはシンプルさにあります: 依存関係管理を再発明するのではなく、Cargo が最も得意とすることを可能にする最小限の有効なプロジェクト構造を作成し、Docker のレイヤーキャッシングメカニズムと完璧に整合します。必須のベストプラクティス:すべての Docker ステージで同一の Rust バージョンを使用cook と build 間で一貫した作業ディレクトリを維持レジストリキャッシング用の BuildKit キャッシュマウントと組み合わせる細粒度のコンパイルキャッシング用に sccache を追加最小限のランタイムイメージを持つマルチステージビルドを使用.dockerignore でビルドコンテキストを最小化cargo-chefを使用すべき場合:中規模から大規模の Rust プロジェクトCI/CD Docker ビルド安定した依存関係ツリーを持つプロジェクト高速な反復サイクルを必要とするチーム迅速なインシデント対応を必要とする本番デプロイ。cargo-chef は、Docker 経由で Rust アプリケーションをデプロイするチームにとって不可欠なツールに成熟しており、より良い開発者体験、より速いデプロイ、削減されたインフラコストに直接変換される測定可能なパフォーマンス改善を提供します。","isoDate":"2025-10-18T07:39:11.000Z","dateMiliSeconds":1760773151000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"RustのDockerfile、2025年はこれでいこう","link":"https://syu-m-5151.hatenablog.com/entry/2025/10/17/070250","contentSnippet":"はじめに「Dockerでビルドすると遅いんだよね」「イメージが2GB超えちゃって…」そんな会話はもう過去の話です。2025年、コンテナ化は劇的に進化しました。Rustも例外ではありません。cargo-chefとBuildKitキャッシュマウントの組み合わせでビルド時間を5-10倍短縮、2.63GBのイメージをdistrolessイメージで約50MB、musl静的リンクならわずか1.7MBという値を達成できます。この記事では、実践的なDockerfileパターンとベンチマーク結果を詳しく解説します。実際に検証したAxum Webアプリケーションでは、distroless版で50.3MB、musl+scratch版で1.71MBを達成しました。中規模プロジェクト（約500の依存関係）での初回ビルドは10分、コード変更後の再ビルドはわずか40秒です。信じられないかもですが、これが2025年の現実です。ちゃんとやれって話です。あと皆さんのDockerfileも教えて欲しいです。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。2025年の重要なアップデートRust 2024 Edition（2025年2月20日リリース）Rust 1.85.0でRust 2024 Editionが安定版になりました。Docker環境でRust 1.85以降を使えば、Edition 2024の機能が使えます。doc.rust-lang.orgblog.rust-lang.orgDocker関連の進化Docker Engine v28：コンテナネットワーキングのセキュリティ強化、AMD GPUサポートdocs.docker.comdocker init GA：Rustプロジェクト用の最適化されたDockerfile自動生成docs.docker.comDocker Bake GA：複雑なビルド設定の宣言的管理docs.docker.comBuildKit 0.25.1：Git URLクエリパラメータ、シークレットの環境変数化など新機能github.com基本的な考え方マルチステージビルドは前提条件2025年でマルチステージビルドを使わないのは、正直あり得ません。まずメンテナンス性が格段に向上します。最終的な成果物以外ではサイズを意識したトリッキーな記述が不要になるため、Dockerfileの可読性が劇的に良くなります。次にビルド速度のアップ。並列化、キャッシュマウント、tmpfsなど最適化オプションが豊富に使えるようになり、ビルドパイプライン全体が高速化します。そして何よりセキュリティの向上。シークレット管理の仕組みが標準化され、機密情報の取り扱いが安全になりました。docs.docker.comCOPYは最小限に、--mountを活用COPYが登場するのは、実質的に2つの場面だけです。マルチステージビルドで別ステージから成果物を持ってくる場合と、最終ステージでアプリケーションバイナリをコピーする場合。それ以外、特にソースコードのビルド時には--mount=type=bindを使用します。docs.docker.com必ず記述すべきおまじない# syntax=docker/dockerfile:1この1行を必ず先頭に記述します。最新のDockerfile構文が自動的に利用され、新機能が使えるようになります。docs.docker.com2025年のDockerfileはこれでやります前置きはこれくらいにして、実際のコードを見ていきましょう。これが2025年のRust標準Dockerfileです。cargo-chefによる依存関係の分離、BuildKitキャッシュマウント、distrolessイメージ、非rootユーザー実行。この記事で解説してきたベストプラクティスのすべてが、この1つのテンプレートに詰め込まれています。# syntax=docker/dockerfile:1ARG RUST_VERSION=1.85ARG APP_NAME=myapp# cargo-chefを使った依存関係キャッシングFROM lukemathwalker/cargo-chef:latest-rust-${RUST_VERSION} AS chefWORKDIR /appFROM chef AS plannerCOPY . .RUN cargo chef prepare --recipe-path recipe.jsonFROM chef AS builder# 依存関係のビルド（キャッシュ可能）COPY --from=planner /app/recipe.json recipe.jsonRUN --mount=type=cache,target=/usr/local/cargo/registry,sharing=locked \\    --mount=type=cache,target=/usr/local/cargo/git,sharing=locked \\    cargo chef cook --release --recipe-path recipe.json# アプリケーションのビルドCOPY . .RUN --mount=type=cache,target=/usr/local/cargo/registry,sharing=locked \\    --mount=type=cache,target=/usr/local/cargo/git,sharing=locked \\    --mount=type=cache,target=/app/target,sharing=locked \\    cargo build --release --bin ${APP_NAME} \u0026\u0026 \\    cp ./target/release/${APP_NAME} /bin/server# テストステージ（オプション）FROM chef AS testCOPY . .RUN --mount=type=cache,target=/usr/local/cargo/registry \\    --mount=type=cache,target=/usr/local/cargo/git \\    cargo test# 本番ステージ：distrolessFROM gcr.io/distroless/cc-debian12:nonroot AS runtimeCOPY --from=builder /bin/server /app/WORKDIR /appEXPOSE 8000ENTRYPOINT [\"/app/server\"]このDockerfileの主な特徴cargo-chefによる依存関係の分離とキャッシングBuildKitキャッシュマウントでレイヤーを跨いだキャッシュdistrolessによる最小サイズと高セキュリティ非rootユーザー（:nonrootタグ）での実行オプショナルなテストステージビルド最適化の3つの柱1. cargo-chefcargo-chefは、Rustの依存関係管理をDockerレイヤーキャッシュに適合させる画期的なツールです。依存関係のコンパイルとソースコードのコンパイルを完全に分離します。動作メカニズム（2段階）：cargo chef prepare：Cargo.tomlとCargo.lockを解析してrecipe.jsonを作成cargo chef cook：最小限のプロジェクト構造を再構築して依存関係のみをビルド重要：同じRustバージョンと作業ディレクトリを全ステージで使用すること。異なるバージョンを使うとキャッシュが無効化されます。実測データ：cargo-chefのみで55%の改善cargo-chef + sccacheで79%の改善（34秒→7秒）商用プロジェクト（14,000行、500依存関係）で10分→2分github.com2. BuildKitキャッシュマウントBuildKitのキャッシュマウント（Docker 18.09以降）を使うと、レイヤー無効化を超えて永続化するキャッシュボリュームが利用できます。3つの重要なキャッシュポイント：RUN --mount=type=cache,target=/usr/local/cargo/registry,sharing=locked \\    --mount=type=cache,target=/usr/local/cargo/git,sharing=locked \\    --mount=type=cache,target=/app/target,sharing=locked \\    cargo build --release/usr/local/cargo/registry：crates.ioからのダウンロード/usr/local/cargo/git：Git依存関係/app/target：ビルド成果物sharing=lockedパラメータは排他アクセスを保証し、パッケージマネージャーの破損を防ぎます。CI環境でのキャッシュ共有：# GitHub Actions- uses: docker/build-push-action@v6  with:    cache-from: type=gha    cache-to: type=gha,mode=maxパフォーマンスベンチマーク：ベースライン：90.60秒BuildKitキャッシュマウント：15.63秒（5.8倍高速）cargo-chef：18.81秒（4.8倍高速）三位一体（chef + BuildKit + sccache）：7-12秒（7.5-13倍高速）docs.docker.com3. sccachesccache（v0.7.x）はMozilla製のccache風コンパイララッパーで、個々のコンパイル成果物を細粒度でキャッシュします。github.comFROM rust:1.85 AS builder# sccacheのインストールと設定RUN cargo install sccache --version ^0.7ENV RUSTC_WRAPPER=sccache \\    SCCACHE_DIR=/sccache \\    CARGO_INCREMENTAL=0WORKDIR /appRUN --mount=type=cache,target=/usr/local/cargo/registry \\    --mount=type=cache,target=$SCCACHE_DIR,sharing=locked \\    --mount=type=bind,target=. \\    cargo build --release重要：CARGO_INCREMENTAL=0は必須。インクリメンタルコンパイルとsccacheは競合します。キャッシュヒット率：初回ビルド：0%ソースコード変更のみ：85-95%依存関係を更新した時：60-75%注意点：sccacheの効果は環境によって大きく異なります。一部の環境では効果が薄く、逆にオーバーヘッドとなる場合があります。自環境でのベンチマークが必須です。イメージサイズの最適化：ベースイメージ選択戦略ビルドステージ：rust:slim推奨2025年はrust:slim（Debian系）でよいと思っています。console.cloud.google.comFROM rust:1.85-slim-bookworm AS builder理由はシンプルです。Debian stable（bookworm）ベースでglibcを使用しているため、広範な互換性とマルチスレッドワークロードでの優れたパフォーマンスを発揮します。完全版のrust:latestが624MBもあるのに対し、rust:slimはコンパイルに必要な最小限のパッケージだけを含んでいます。無駄がありません。rust:alpineは避けてください。 muslの互換性問題に加えて、マルチスレッドアプリケーションで最大30倍のパフォーマンス劣化が報告されています。イメージサイズの小ささに惹かれる気持ちはわかりますが、本番環境でこの劣化は致命的です。https://hub.docker.com/_/rust最終ステージ：distroless推奨gcr.io/distroless/cc-debian12が2025年の標準です。FROM gcr.io/distroless/cc-debian12:nonrootdistrolessの特徴：サイズ：21-29MBglibc、SSL証明書、タイムゾーンデータ、/etc/passwdを含むパッケージマネージャー、シェル不要なバイナリを完全排除SLSA 2準拠、cosign署名検証が可能CVEスキャンで従来イメージより50-80%少ない脆弱性:nonrootタグでUID 65534（nobody）として非rootで実行github.comイメージサイズ比較（実測値） イメージ構成  サイズ  用途  特徴  scratch + musl（実測）  1.71MB  CLIツール最小化  完全静的リンク  distroless/static  2-3MB  静的リンクバイナリ  最小限のファイル  distroless/cc-debian12（実測）  50.3MB  Webアプリ推奨  glibc  debian-slim  80-120MB  フル互換性  デバッグツールあり  rust:latest（未最適化）  2.63GB  開発専用  ビルドツール込み 実測削減率：rust:latest（2.63GB）→ distroless（50.3MB）：98.1%削減rust:latest（2.63GB）→ musl+scratch（1.71MB）：99.9%削減静的リンク vs 動的リンクmusl（x86_64-unknown-linux-musl）での静的リンク：FROM rust:1.85-alpine AS builderRUN apk add --no-cache musl-devWORKDIR /app# 依存関係のキャッシュCOPY Cargo.toml Cargo.lock ./RUN --mount=type=cache,target=/usr/local/cargo/registry \\    mkdir src \u0026\u0026 echo \"fn main() {}\" \u003e src/main.rs \u0026\u0026 \\    cargo build --release --target x86_64-unknown-linux-musl \u0026\u0026 \\    rm -rf src# アプリケーションのビルドCOPY src ./srcRUN --mount=type=cache,target=/usr/local/cargo/registry \\    cargo build --release --target x86_64-unknown-linux-muslFROM scratchCOPY --from=builder /app/target/x86_64-unknown-linux-musl/release/myapp /myappENTRYPOINT [\"/myapp\"]利点：依存関係ゼロで完全にポータブルscratchコンテナで実行可能イメージサイズ5-10MB欠点：シングルスレッドで0.9-1.0倍、マルチスレッドで0.03-0.5倍のパフォーマンス一部依存関係でsegfaultのリスク本番環境の推奨：複雑なアプリケーション（Webサーバー、DB接続）：glibc + distroless/cc-debian12シンプルなCLIツール：musl + scratchを検討パフォーマンスが重要：必ずglibcを使用マルチアーキテクチャビルドlinux/amd64とlinux/arm64の両対応が2025年の標準要件です。cargo-zigbuild：セットアップゼロのクロスコンパイルcargo-zigbuild（v0.20.1）はZigツールチェインを使い、セットアップ不要でクロスコンパイルできます。github.com# syntax=docker/dockerfile:1ARG RUST_VERSION=1.85FROM --platform=$BUILDPLATFORM rust:${RUST_VERSION}-alpine AS builderWORKDIR /app# Zigとcargo-zigbuildのインストールRUN apk add --no-cache musl-dev openssl-dev zigRUN cargo install --locked cargo-zigbuild# ターゲットの設定ARG TARGETPLATFORMRUN case ${TARGETPLATFORM} in \\    \"linux/amd64\") echo x86_64-unknown-linux-musl \u003e /rust_target ;; \\    \"linux/arm64\") echo aarch64-unknown-linux-musl \u003e /rust_target ;; \\    esac \u0026\u0026 \\    rustup target add $(cat /rust_target)# 依存関係とビルドCOPY Cargo.toml Cargo.lock ./RUN --mount=type=cache,target=/usr/local/cargo/registry \\    mkdir src \u0026\u0026 echo \"fn main() {}\" \u003e src/main.rs \u0026\u0026 \\    cargo zigbuild --release --target $(cat /rust_target) \u0026\u0026 \\    rm -rf srcCOPY src ./srcRUN --mount=type=cache,target=/usr/local/cargo/registry \\    cargo zigbuild --release --target $(cat /rust_target)FROM alpine:latestARG TARGETPLATFORMCOPY --from=builder /app/target/*/release/app /appCMD [\"/app\"]重要：--platform=$BUILDPLATFORMを使うと、ビルド自体はネイティブアーキテクチャで実行できるので、QEMUエミュレーションより圧倒的に速いです（QEMUエミュレーションは16-25倍遅い）。実測データ：ネイティブビルド：2-3分QEMUエミュレーション：50分（16-25倍遅い）cargo-zigbuildクロスコンパイル：13分Docker buildxでのマルチプラットフォームビルド# ビルダーの作成docker buildx create --name container-builder \\    --driver docker-container --bootstrap --use# マルチプラットフォームビルドdocker buildx build \\    --platform linux/amd64,linux/arm64 \\    -t myimage:latest \\    --push .https://docs.docker.com/build/buildx/docs.docker.comセキュリティベストプラクティス1. 非rootユーザーで実行distroless :nonrootタグが最も簡単：FROM gcr.io/distroless/cc-debian12:nonrootCOPY --from=builder /app/target/release/myapp /usr/local/bin/CMD [\"/usr/local/bin/myapp\"]自動的にUID 65534（nobody）として実行されます。カスタムユーザー作成：FROM debian:bookworm-slimARG UID=10001RUN adduser \\    --disabled-password \\    --gecos \"\" \\    --home \"/nonexistent\" \\    --shell \"/sbin/nologin\" \\    --no-create-home \\    --uid \"${UID}\" \\    appuserUSER appuserCOPY --from=builder /app/target/release/myapp /app/CMD [\"/app/myapp\"]2. 脆弱性スキャンTrivy（推奨）：# イメージスキャンdocker run --rm -v /var/run/docker.sock:/var/run/docker.sock \\    aquasec/trivy image myapp:latest# CI/CD統合- name: Run Trivy scan  uses: aquasecurity/trivy-action@master  with:    image-ref: 'myapp:${{ github.sha }}'    severity: 'CRITICAL,HIGH'    exit-code: '1'github.comdistrolessのセキュリティ優位性：Alpine（musl）からChiseled Ubuntu（glibc）への移行で30+ CVEが0 CVEにdistrolessイメージはAlpineより50-80%少ないCVEパッケージマネージャー不在により攻撃ベクトル削減SLSA 2準拠、cosign署名認証3. シークレット管理絶対に避けるべき：環境変数へのシークレット設定イメージに焼き込まれてしまいます。正しい方法：# ビルド時シークレットRUN --mount=type=secret,id=api_token,env=API_TOKEN \\    cargo build --release# 実行時docker build --secret id=api_token,env=API_TOKEN .4. イメージバージョンのピン留め# ❌ 避けるべきFROM rust:latest# ✅ 推奨FROM rust:1.85-slim-bookwormユースケース別DockerfileWebアプリケーション（Axum / Actix-web）上記の「標準Dockerfile」パターンをそのまま使用できます。CLIツール（完全静的リンク）# syntax=docker/dockerfile:1FROM rust:1.85-alpine AS builderWORKDIR /appRUN apk add --no-cache musl-dev openssl-dev openssl-libs-static# 依存関係のキャッシュCOPY Cargo.toml Cargo.lock ./RUN --mount=type=cache,target=/usr/local/cargo/registry \\    mkdir src \u0026\u0026 echo \"fn main() {}\" \u003e src/main.rs \u0026\u0026 \\    cargo build --release --target x86_64-unknown-linux-musl \u0026\u0026 \\    rm -rf srcCOPY src ./srcRUN --mount=type=cache,target=/usr/local/cargo/registry \\    cargo build --release --target x86_64-unknown-linux-muslFROM scratchCOPY --from=builder /app/target/x86_64-unknown-linux-musl/release/cli-tool /app/ENTRYPOINT [\"/app/cli-tool\"]シェルエイリアスは以下のように設定できます。alias my-cli='docker run --rm -v $(pwd):/data my-cli-image'ワークスペース（モノレポ）対応# syntax=docker/dockerfile:1ARG SERVICE_NAME=api-gatewayARG RUST_VERSION=1.85FROM lukemathwalker/cargo-chef:latest-rust-${RUST_VERSION} AS chefWORKDIR /appFROM chef AS plannerCOPY . .RUN cargo chef prepare --recipe-path recipe.jsonFROM chef AS builderARG SERVICE_NAMECOPY --from=planner /app/recipe.json recipe.jsonRUN --mount=type=cache,target=/usr/local/cargo/registry,sharing=locked \\    --mount=type=cache,target=/usr/local/cargo/git,sharing=locked \\    cargo chef cook --release --bin ${SERVICE_NAME} --recipe-path recipe.jsonCOPY . .RUN --mount=type=cache,target=/usr/local/cargo/registry,sharing=locked \\    --mount=type=cache,target=/app/target,sharing=locked \\    cargo build --release --bin ${SERVICE_NAME} \u0026\u0026 \\    cp ./target/release/${SERVICE_NAME} /bin/serviceFROM gcr.io/distroless/cc-debian12:nonrootCOPY --from=builder /bin/service /app/ENTRYPOINT [\"/app/service\"]異なるサービスを同じDockerfileから生成できます。docker build --build-arg SERVICE_NAME=api-gateway -t gateway .docker build --build-arg SERVICE_NAME=user-service -t users .実践的な検証結果実際のAxum Webアプリケーション（依存関係82個）で3つの戦略を検証しました。検証環境：CPU: Apple M-series (ARM64)Docker: Colima on macOSRust: 1.85 (Edition 2024)3つのパターン比較パターン1: Naive（最適化なし）- デフォルトの実態Dockerfile.naive は何も工夫しないシンプルなビルドです。これが「デフォルトの何もしていない状態」です。⚠️ デフォルト状態のビルド結果初回ビルド時間: 約10-15分（依存関係82個を全てコンパイル）ソースコード変更後の再ビルド: 約10-15分（依存関係も毎回再コンパイル）最終イメージサイズ: 2.63GBセキュリティ: rootユーザー、開発ツール込み（脆弱性大）問題点：ソースコード1行変更するだけで10-15分のビルドが毎回走るイメージに不要なRustコンパイラ（500MB）、ビルドツール、ドキュメントが全て含まれるマルチステージビルドがないため、最終イメージが巨大cargo-chefがないため、依存関係とソースコードが分離されていないパターン2: Baseline（cargo-chef + distroless）Dockerfile は2025年の推奨パターンです。ビルド結果ビルド時間: 38秒（依存関係キャッシュ済み）最終イメージサイズ: 50.3MBセキュリティ: 非rootユーザー（UID 65534）、最小限のファイルTrivy脆弱性: 0 HIGH/CRITICALパターン3: Ultra-minimal（musl + scratch）Dockerfile.musl は最小サイズを優先したパターンです。ビルド結果ビルド時間: 46秒（依存関係キャッシュ済み）最終イメージサイズ: 1.71MBセキュリティ: rootユーザー（scratchに制限あり）比較結果まとめ 項目  Naive (未最適化)  Baseline (distroless)  Ultra-minimal (musl)  イメージサイズ  2.63GB  50.3MB  1.71MB  削減率  - (100%)  98.1%削減  99.9%削減  ビルド時間  30秒  38秒  46秒  マルチステージ  ❌ なし  ✅ あり (4段階)  ✅ あり (2段階)  キャッシュ最適化  ❌ なし  ✅ cargo-chef + BuildKit  ✅ BuildKit  ベースイメージ  rust:1.85 (full)  distroless/cc-debian12  scratch  リンク方式  動的（glibc）  動的（glibc）  静的（musl）  開発ツール  ❌ 含まれる  ✅ 除去済み  ✅ 除去済み  セキュリティ  ❌ 低  ✅ 高  ⚠️ 中  デバッグ  ✅ 可能  ❌ 困難  ❌ 不可能 パフォーマンスベンチマーク商用プロジェクト（14,000行、500依存関係）：最適化なし：10分cargo-chef使用：2分（5倍高速化）大規模ワークスペース（400 crate、1500依存関係）：未最適化：約65分最適化後：約2分（30倍以上の改善）検証の再現方法このリポジトリで実際に試せます。# Baseline版のビルドdocker build -t rust-demo:baseline .# Ultra-minimal版のビルドdocker build -f Dockerfile.musl -t rust-demo:musl .# サイズ比較docker images | grep rust-demo# 動作確認docker run -p 8000:8000 rust-demo:baselinedocker run -p 8001:8000 rust-demo:muslよくある問題と解決策OpenSSLリンクエラーエラー： \"Could not find directory of OpenSSL installation\"解決策1：vendored OpenSSL（最も簡単）[dependencies]openssl = { version = \"0.10\", features = [\"vendored\"] }解決策2：Alpine適切パッケージFROM rust:1.85-alpineRUN apk add --no-cache openssl-dev openssl-libs-static musl-dev解決策3：Debianベース使用FROM rust:1.85-slim-bookwormRUN apt-get update \u0026\u0026 apt-get install -y pkg-config libssl-dev解決策4：rustls（Rust-native TLS）[dependencies]reqwest = { version = \"0.11\", features = [\"rustls-tls\"], default-features = false }muslリンクエラーAlpine向け：FROM rust:1.85-alpineRUN apk add musl-dev openssl-dev openssl-libs-staticRUN rustup target add x86_64-unknown-linux-muslENV PKG_CONFIG_ALLOW_CROSS=1RUN cargo build --release --target x86_64-unknown-linux-musl必要な環境変数：RUSTFLAGS='-C target-feature=+crt-static'PKG_CONFIG_ALLOW_CROSS=1OPENSSL_STATIC=1（システムOpenSSL使用時）DNS解決エラー（scratchイメージ）解決策1：distroless/static使用FROM gcr.io/distroless/static-debian12解決策2：Pure Rust DNSリゾルバー[dependencies]reqwest = { version = \"0.11\", features = [\"trust-dns\"] }解決策3：必要ファイルコピーFROM alpine:latest AS ca-certificatesRUN apk add -U --no-cache ca-certificatesFROM scratchCOPY --from=ca-certificates /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/.dockerignoreの重要性.dockerignoreがないと、target/ディレクトリ（数GB）がビルドコンテキストに含まれ、ビルドが遅くなります。# .dockerignoretarget/.git/.env*.log効果: ビルドコンテキストのサイズを数GBから数MBに削減 → ビルド開始が高速化。イメージサイズ肥大化一般的原因と解決策：最終イメージにビルドツール含む → マルチステージビルドで93%削減本番環境でfull rustイメージを使用 → slimランタイムベースで95%削減バイナリにデバッグシンボルが含まれる → strip target/release/myappで30-40%削減開発依存関係 → プロファイル設定[profile.release]strip = truelto = truecodegen-units = 12025年の新ツール活用docker init - プロジェクトの素早い立ち上げ# プロジェクトディレクトリで実行docker init# Rustを選択すると自動生成：# - Dockerfile# - compose.yaml# - .dockerignore# - README.Docker.mddocs.docker.comDocker Bake - 複雑なビルドの管理docker-bake.hcl:group \"default\" {  targets = [\"app\"]}variable \"TAG\" {  default = \"latest\"}target \"app\" {  context = \".\"  dockerfile = \"Dockerfile\"  tags = [\"myapp:${TAG}\"]  platforms = [\"linux/amd64\", \"linux/arm64\"]  cache-from = [\"type=registry,ref=myapp:cache\"]  cache-to = [\"type=registry,ref=myapp:cache,mode=max\"]}# 実行docker buildx bake# 変数をオーバーライドdocker buildx bake --set TAG=v1.0.0docs.docker.comおわりにこの記事では、2025年時点でのRust Dockerのベストプラクティスを包括的に解説しました。cargo-chefによる依存関係の分離キャッシング、BuildKitの永続キャッシュマウント、distrolessイメージによるセキュリティ強化という3つの柱を中心に、実践的なDockerfileパターンと実測データを提供しています。Rustのコンテナ化は長い間「ビルドが遅い」「イメージが大きい」という課題を抱えていました。コンパイル時間の長さは諦めるしかなく、数GBのイメージサイズは「Rustだから仕方ない」と言われてきました。しかし、2025年現在、その課題は完全に解決しました。適切な最適化で、ビルド時間を5-10倍短縮、イメージサイズを98-99%削減できます。これは単なる理論ではなく、実際のプロダクション環境で日々使われている技術です。2025年のゴールデンルールこの記事で紹介した技術を実践する際は、以下の10のポイントを押さえておくといいでしょう。# syntax=docker/dockerfile:1を必ず記述 - 最新のDockerfile構文を自動利用cargo-chefで依存関係を分離 - 5-10倍のビルド高速化を実現BuildKitキャッシュマウントを活用 - レイヤーを超える永続的なキャッシュdistroless/cc-debian12:nonrootを使用 - 50MB、非root、高セキュリティrust:slim-bookwormでビルド - Alpineは避ける（マルチスレッド性能問題）RUN --mount=type=bindでソースコードをマウント - COPYの最小化マルチステージビルドは必須 - 2025年の前提条件非rootユーザーで実行 - セキュリティの基本原則TrivyまたはGrypeでスキャン - 継続的なセキュリティ検証イメージバージョンをピン留め - :latestは避ける大半の本番ワークロードには、glibc + distroless/cc-debian12 + cargo-chefの組み合わせが最適解です。この構成により、50MBの小サイズ、2分の高速ビルド、フルパフォーマンス、優れたセキュリティプロファイルを実現できます。マルチスレッドアプリケーションでmuslを使う場合、1点だけ注意が必要です。最大30倍のパフォーマンス劣化リスクがあるので、本番環境への導入前に必ずベンチマークで検証しましょう。イメージサイズだけで判断すると、後で後悔します。2025年のRust Dockerは、従来の課題を完全に克服しました。高速、小サイズ、セキュア、マルチアーキテクチャ対応の成熟した技術スタックになっています。この記事で紹介した標準Dockerfileパターンは、そのままプロダクション環境で使える構成です。まずは標準パターンから始めて、必要なら sccache や cargo-zigbuild などの高度な最適化を追加するといいでしょう。Rustエコシステムの進化とDockerの機能強化で、今後もさらに改善していくはずです。この記事が、あなたのRustアプリケーションのコンテナ化に役立てば嬉しいです。","isoDate":"2025-10-16T22:02:50.000Z","dateMiliSeconds":1760652170000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"baconを知らずにRust書いてた","link":"https://syu-m-5151.hatenablog.com/entry/2025/10/16/170800","contentSnippet":"cargo-watch、やめるってよRustを書いてると、気づくんですよね。保存ボタンを押すたび、手動でcargo checkとかcargo testとか叩いてる自分に。「あれ、俺って原始人だっけ？」みたいな気持ちになる。そこで救世主として現れたのがcargo-watchだったわけです。過去形。github.comそう、cargo-watchはもうメンテされてないんです。引退しちゃった。ここで一旦、真面目な話を。10年以上もcargo-watchとwatchexecっていうOSSプロジェクトを守り続けてきたFélix Saparelliさんに、心から敬意と感謝を。あなたのおかげで、世界中の無数のRust開発者が「あ、これ便利じゃん」って生産性爆上げできたんです。本当にありがとうございました。で、公式READMEには作者本人がこう書き残してる。\"It's time to let it go. Use Bacon. Remember Cargo Watch.\"なんかもう、エモすぎません？10年以上続いたプロジェクトが、バトンを次世代に渡して静かに去っていく感じ。その後継者がbacon。そして汎用性の塊みたいなwatchexec。ベーコンって名前、朝ごはん感あるけど、これが本当にすごいんですよ。というわけでこの記事では、Rust開発で使えるファイル監視ツールについて解説していきます。cargo-watchロス、今日で終わりにしましょう。baconって何？baconは、Rust専用に作られたバックグラウンドコードチェッカーです。エディタの隣で動かしておくと、ファイルを保存するたびに自動でコンパイルチェックを走らせて、エラーや警告をリアルタイムで表示してくれます。github.comcargo-watchとの違いcargo-watchの作者が「baconこそが自分の理想だった」と語っているほど、baconは進化しています。TUIで見やすい - エラーが警告より先に表示され、スクロール不要キーボード操作 - tでテスト、cでClippy、dでドキュメントと一瞬で切り替え小さい画面でも快適 - ターミナルのサイズに合わせて表示を最適化Rust Analyzerと競合しない - 開発体験がスムーズインストール# 基本インストールcargo install --locked bacon# オプション機能も入れる（クリップボード、サウンド）cargo install --locked bacon --features \"clipboard sound\"基本的な使い方プロジェクトのルートでbaconを起動するだけ。cd your-rust-projectbaconデフォルトではcargo checkが走ります。ファイルを保存すると自動で再チェック。主要なキーボードショートカットbaconの真価はキーボードショートカットにあります。t - テスト実行に切り替えc - Clippyに切り替えd - ドキュメントをブラウザで開くf - テスト失敗時、そのテストだけに絞り込みEsc - 前のジョブに戻るCtrl+j - すべてのジョブ一覧を表示h - ヘルプ表示q - 終了特定のジョブで起動# テストを監視bacon test# Clippyを監視bacon clippy# 厳格なClippyルール（pedantic）bacon pedantic# 高速テストランナー（nextest）bacon nextest# すべてのターゲットをチェックbacon check-all# 特定のジョブを指定bacon --job my-custom-jobbacon.toml で設定をカスタマイズプロジェクトに合わせてジョブを定義できます。# 設定ファイルを生成bacon --init設定例# bacon.toml# Windows向けのチェック[jobs.check-win]command = [\"cargo\", \"check\", \"--target\", \"x86_64-pc-windows-gnu\"]# 厳しめのClippy[jobs.clippy-strict]command = [    \"cargo\", \"clippy\", \"--\",    \"-D\", \"warnings\",    \"-A\", \"clippy::collapsible_if\",]need_stdout = false# サンプルをチェック[jobs.check-examples]command = [\"cargo\", \"check\", \"--examples\", \"--color\", \"always\"]watch = [\"examples\"]  # srcは自動で監視される# 実行ジョブ[jobs.run]command = [\"cargo\", \"run\"]allow_warnings = trueneed_stdout = true# キーバインディングのカスタマイズ[keybindings]shift-c = \"job:clippy-strict\"r = \"job:run\"設定しておいてよいことドキュメントを素早く確認[jobs.doc-open]command = [\"cargo\", \"doc\", \"--no-deps\", \"--open\"]need_stdout = falseon_success = \"back\"  # ドキュメントが開いたら前のジョブに戻る長時間実行するアプリケーション[jobs.server]command = [\"cargo\", \"run\"]allow_warnings = trueneed_stdout = truebackground = falseon_change_strategy = \"kill_then_restart\"watchexecとの使い分けbaconはRust専用ですが、watchexecは汎用的なファイル監視ツールです。github.comwatchexecを使うべき場合# インストールcargo install watchexec-cli# 基本的な使い方watchexec --restart cargo run# 特定の拡張子だけ監視watchexec -e rs,toml cargo test# デバウンス設定watchexec -d 2000 cargo checkwatchexecが向いているケース：- Rust以外の言語やツール- シェルスクリプトの実行- rsyncなどの同期処理- より細かい制御が必要な場合# 例：TypeScriptのビルドwatchexec -e ts,tsx npm run build# 例：ファイル同期watchexec -w src -- rsync -avhP ./src/ ./backup/実践的なワークフロー開発時のセットアップターミナルを分割左：Vim/Neovim右上：bacon右下：通常のシェル私はWarpを使ってペイン分割している。baconの起動bacon  # デフォルトでcheckが走るコードを書く保存すると自動でチェックエラーがあれば即座に表示エラーが消えたらClippyの警告が見えるテストを書くtキーでテストモードに切り替え失敗したらfで絞り込み修正したらEscで全テストに戻る最終チェックcキーでClippyの提案を確認コード品質を向上ちょっとしたTipsシェルエイリアスで効率化頻繁に使うコマンドをエイリアス化すると便利です。# ~/.zshrc または ~/.bashrc に追加alias bac='bacon'alias bacc='bacon clippy'alias bact='bacon test'alias bacp='bacon pedantic'watchexecで複数パスを監視# srcとtestsディレクトリの.rsと.tomlファイルを監視watchexec -e rs,toml -w src -w tests -- cargo testVim/Neovimとの連携nvim-bacon プラグインbaconの診断結果をNeovimに統合するプラグインがあります。github.com\" lazy.nvim の場合{  'Canop/nvim-bacon',  config = function()    require('bacon').setup()  end}主な機能は以下の通り。エラー箇所へのジャンプQuickfixへの統合:Bacon コマンドでbaconを起動:BaconLoad で診断結果を読み込み補足：VS Code向けVS Codeユーザーの場合は、bacon-lsというLanguage Serverが利用可能です。まとめcargo-watchの時代は終わりました。でも、より良いツールが生まれています。こう使い分けよう：Rust開発 → bacon一択TUIが快適キーボードだけで完結設定ファイルで柔軟にカスタマイズそれ以外 → watchexec汎用的に使えるシンプルで強力シェルスクリプトとの相性抜群baconを知らずにRustを書いていた人は、今すぐ試してください。開発体験が一段階レベルアップします。cargo install --locked baconcd your-projectbaconたったこれだけ。あとはコードを書くだけです。参考リンク：- bacon公式サイト- watchexec GitHub- cargo-watch（アーカイブ済み）","isoDate":"2025-10-16T08:08:00.000Z","dateMiliSeconds":1760602080000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"文章力を分解してちゃんと文章を書く。","link":"https://syu-m-5151.hatenablog.com/entry/2025/10/14/133602","contentSnippet":"はじめに文章を読むとは、自分の中で文章を再構築するということである。あなたは技術記事を読んで「わかった」と思ったのに、いざ実装しようとすると何も書けなかった経験はないだろうか。ドキュメントを読んで「理解した」と思ったのに、同僚に説明しようとすると言葉が出てこなかった経験はないだろうか。私にはある。何度もある。悲しい。これは単なる理解不足ではない。もっと根本的な問題だ。私たちは「読む」と「書く」を別々のスキルだと思い込んでいる。しかし、それは違うと私は考えている。読むとき、私たちは頭の中で文章を再構築している。書き手の言葉を、自分のスキーマ（枠組み）に翻訳し、自分の言葉で理解し直している。読むことは、実は書くことなのだ。ただ、それが頭の中で行われているだけだ。だから、「わかった」と思っても実装できないのは、頭の中で再構築したものと現実の折り合いがついていないのだ。自分の言葉で書き直せていないのだ。「読解力を分解してちゃんと文章を読む。」という記事を書いたあと、私はあることに気づいた。文章を読む力を分解して説明しようとすればするほど、自分が書く文章の問題点が見えてくるのだ。読み手がどこでつまずくかを想像すると、自分が読むときにどこでつまずいていたかが見えてくる。syu-m-5151.hatenablog.comそして、ある結論に辿り着いた。書けない人間は、読めない。これは挑発でも誇張でもない。書く力と読む力は、コインの表裏ではなく、同じものなのだ。書く経験を通じて、私たちは「文章がどのように読まれるか」を学ぶ。一文が長すぎると読み手の認知負荷が上がること。主語が不明確だと読み手が推測を強いられること。構造が曖昧だと読み手が迷子になること。逆もまたあることだ。読む経験を通じて、私たちは「文章がどのように書かれるべきか」を学ぶ。明快な文章はどのような構造を持っているか。わかりやすい説明はどのように展開されるか。読解力の記事では、読む力を3つの段階に分解した。今回の記事では、書く力を同じように分解していく。第1段階：正確に書く第2段階：誤読されないように書くスキーマを想像し、知識の呪いを断ち切る。認知バイアスを考慮し、読み手が必要な情報にたどり着ける文脈を設計する。第3段階：心を動かすように書く書くことで、初めて読めるようになる。読むことで、初めて書けるようになる。この循環的な関係を理解することが、文章力を高める第一歩だ。そして、この循環が複利的に機能する。書く力が向上すると読む力も向上し、読む力が向上するとまた書く力も向上する。この正のフィードバックループが、指数関数的な成長を生み出す。片方だけを鍛えようとしても、成長は頭打ちになる。両輪を回すことが、文章力を本質的に高める唯一の道だ。では、なぜ書く力と読む力は、これほどまでに密接に結びついているのだろうか。その理由を、まず理解する必要がある。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。書く力と読む力は、なぜ表裏一体なのか書けないということは、理解していないということだエラーログを読めない人は、エラーメッセージを吐き出させるときも曖昧な表現をする。「エラーが発生しました」とだけ書いて、どのエラーが、どの条件で、何が原因で発生したのかを書かない。なぜか？自分がエラーログを読むときに、これらの情報を抽出できていないからだ。というか想像できていないからだ。読んで困った時の自分を。読むときに「どこに何が書いてあるか」を理解できていない人は、吐き出させるときにも「どこに何を書くべきか」を理解できない。これは単なる不注意ではない。書こうとして初めて、「何をどの順序で書くべきか」という問いに直面する。書こうとして初めて、「読み手は何を知りたいのか」という問いに直面する。この問いと格闘する過程で、私たちは文章の構造を深く理解する。技術記事を読んで「わかった」と思うのは、個々の文章を理解したということだ。しかし、それを実装できないのは、全体の構造を理解していないからだ。これは、ラバーダック・デバッギングと同じ原理だ。コードを声に出して説明しようとすると、理解の穴が見えてくる。文章を書こうとすると、読解の穴が見えてくる。書こうとして手が止まる瞬間、そこに理解の穴がある。誤読された経験が、誤読を防ぐ力を育てる理解の穴が見えるだけでは十分ではない。さらに重要なのは、自分が書いた文章がどう読まれるかを知ることだ。「この文章は誤解される」と事前に気づくには、自分が誤読された経験が必要だ。吐き出させた文章が意図と違う形で受け取られた経験。怒りのコメントを受けた経験。これらの痛い経験を通じて、人は「どんな書き方が誤解を生むか」を学ぶ。誤読には、いくつかのパターンがある。パターン1：主語の曖昧さによる誤読この機能の実装が遅れています。仕様が複雑で理解に時間がかかっています。書き手は「私」のつもりで書いている。しかし、読み手は「チーム全体」だと解釈するかもしれない。この誤読は、書き手が主語を省略したことで生じる。パターン2：文脈の欠如による誤読この実装方法は悪くない。書き手は、他の実装方法と比較して「悪くない」と言っている。しかし、読み手は、この実装方法が「及第点」程度だと解釈するかもしれない。パターン3：二重否定による誤読この問題は無視できない。書き手は「重要だ」と言いたい。しかし、読み手は「ある程度重要だが、最優先ではない」と解釈するかもしれない。誤読された経験は、痛い。しかし、その痛みこそが、書く力と読む力を同時に高める。書く経験が乏しい人は、読むときにも「書き手の意図」を想像できない。スキーマは読み書き両方で機能する誤読を防ぐには、さらに深い理解が必要だ。それは、読み手と書き手でスキーマが異なるという理解だ。人はスキーマを通して文章を理解する。スキーマとは、私たちが頭の中に持っている知識の枠組みのこと。例えば、「非同期処理」というキーワードを見たとき、Rustエンジニアの頭の中では、tokio、async/await、Future traitといった関連する概念が自動的に呼び出される。しかし、スキーマは読むときだけでなく、書くときにも機能している。そして、書くときのスキーマの働き方が、しばしば問題を引き起こす。あなたが「非同期処理を実装した」と書くとき、あなたの頭の中には「非同期処理」についての豊富なスキーマがある。だから、読み手もそのスキーマを共有していると無意識に仮定してしまう。これを「知識の呪い」と呼ぶ。【悪い例】非同期処理を実装しました。これでパフォーマンスが改善されます。書き手にとって、これは十分に明確だ。しかし、読み手はどうか？Rustエンジニアは「tokioのasync/awaitを使うのか」と想像する。Goエンジニアは「goroutineを使うのか」と想像する。非同期処理に馴染みのないエンジニアは「何が改善されるのか」すらわからない。書く力が高い人は、「読み手は自分とは違うスキーマを持っている」と意識的に認識する。そして、読み手のスキーマを想像し、橋を架けるように書く。【良い例】非同期処理を実装しました。従来は3つのマイクロサービスへのHTTPリクエストを順番に実行していたため、合計で3秒かかっていました。今回、Rustのtokioとasync/awaitを使ってこれらのリクエストを並行実行するように変更しました。その結果、3つのリクエストが同時に実行されるため、最も遅いリクエスト（1秒）の時間だけで完了するようになりました。これにより、全体の処理時間が3秒から1秒に短縮され、APIのレスポンスタイムが大幅に改善されました。では、この「読み手のスキーマを想像する力」は、どうやって獲得できるのか？答えは、読み手として多様な文章に触れ、「わからない」を経験することだ。自分が知らない分野の技術記事を読んで、「専門用語が多くてわからない」と感じる。その経験が、書き手として「専門用語を使うときは説明を加えよう」という意識を育てる。書くことは、読む力を鍛える最良の訓練ここまで見てきたように、書く経験は読む力を高める。しかし、その逆も真だ。読む経験は書く力を高める。この循環を最も効果的に回す方法が、実は書くことなのだ。なぜか？書こうとすると、言語化できない部分に直面するからだ。頭の中では理解しているつもりでも、いざ文章にしようとすると言葉が出てこない。この瞬間、あなたは「本当は理解していなかった」と気づく。しかし、問題はもっと深い。ちゃんと読むとは、自分の中でちゃんと書くということでもある。複雑な文章を読むとき、私たちは無意識のうちに「これはつまり、こういうことだな」と自分の言葉で要約している。この「内なる執筆」ができない人は、文章を読んでも理解が浅い。例を見てみよう。技術記事に「エラーハンドリングを実装すると、システムの信頼性が向上する」と書いてある。浅い読み方：「エラーハンドリングを実装すると信頼性が向上するのか。なるほど。」深い読み方：「エラーハンドリングを実装すると信頼性が向上する、と言っている。なぜか？エラーハンドリングがないと、エラーが発生したときにプログラムがパニックして停止してしまう。その結果、ユーザーはサービスを使えなくなる。一方、エラーハンドリングを実装すれば、エラーが発生してもプログラムは継続でき、ユーザーに明確なエラーメッセージを返せる。つまり、『信頼性が向上する』とは『エラー時でもサービスを継続できる』という意味だな。」深い読み方をしている人は、頭の中で文章を書いている。この「内なる執筆」の能力は、実際に書く経験を通じて鍛えられる。外に向けて文章を書くとき、私たちは「どう表現すれば伝わるか」を考える。この試行錯誤が、内なる執筆の能力を高める。だから、外に向けて書く訓練をすることは、内に向けて書く力も鍛える。このように、書く力と読む力は表裏一体だ。では、具体的にどう書けばよいのか。読解力の記事と同様、書く力も3つの段階に分解して見ていこう。第1段階：正確に書く読解力の第1段階は「書かれていることを正確に理解する力」だった。文章力の第1段階は、「伝えたいことを正確に伝える力」だ。これは、技術的なスキルだ。感性や才能ではなく、学習可能なスキルだ。悪文とは何か。それは、一義的に解釈できない文章だ。一つの文を読んで、複数の意味に解釈できてしまう。主語が不明確で、誰が何をしているのかわからない。修飾関係が複雑で、何がどこにかかっているのか判然としない。こうした構造的な問題が、悪文を生む。文章を書くコツは、芸術的な名文を書くことではない。読みにくい「悪文」を書かないことである。では、悪文を防ぐにはどうすればよいか。ここでは四つ紹介します。他にも悪文を分かりやすくする方法はいくらかありますがたくさん本が出ていますのでそちらを参考にしてほしいです。悪文の構造　――機能的な文章とは (ちくま学芸文庫)作者:千早耿一郎筑摩書房Amazon「文章術のベストセラー100冊」のポイントを1冊にまとめてみた。作者:藤𠮷 豊,小川 真理子日経BPAmazon一文一義で書く【悪い例】デプロイ作業中にDBマイグレーションが失敗したため、問題箇所をスキップすればデプロイは可能ですが、Xモジュールへの影響が不明なので、明日Yさんが出社してから対応するか、今日スキップしてデプロイするか、どちらが良いと思いますか？この一文には、6つの義が詰め込まれている。読み手は、これらすべてを一度に処理しなければならない。認知負荷が高すぎる。なぜ一文一義が重要なのか？人間の作業記憶（ワーキングメモリ）の容量は限られている。一文が長く、複数の義が含まれていると、読み手は文の途中で最初の部分を忘れてしまう。一文一義で書くことは、読み手の認知リソースを尊重することだ。【良い例】デプロイ作業中、DBマイグレーションに失敗しました。問題箇所をスキップすればデプロイは可能ですが、Xモジュールへの影響が不明です。対応方針を相談させてください。以下の2つの選択肢のうち、どちらが良いでしょうか？A. 明日Yさんが出社後、一緒に影響範囲を調査してから対応するB. 今日、問題箇所をスキップしてデプロイする一文一義の原則を守るには、3つのルールがある。ルール1：文章は短くするルール2：形容詞と被形容詞はなるべく近づけるルール3：一つの文に、主語と述語はひとつずつ短く、近く、シンプルに。これが機能的な文章の基本だ。主語を明示する一文一義を守るだけでは不十分だ。次に重要なのは、誰が何をしているかを明確にすることだ。日本語は主語を省略できる言語だ。しかし、文章を書くとき、特に技術文書やビジネス文書を書くとき、文脈が常に明らかとは限らない。主語を省略すると、3つの問題が生じる。問題1：責任の所在が不明確になる【悪い例】バグを修正しました。【良い例】私がバグを修正しました。問題2：行為者が不明確になる【悪い例】テストを実行して、結果を確認しました。【良い例】私がテストを実行しました。Aさんが結果を確認しました。問題3：複数の解釈が可能になる【悪い例】レビュー後、デプロイしました。【良い例】Aさんのレビュー後、私がデプロイしました。では、どうすればよいか？主語を省略してもよい場合と、省略してはいけない場合を区別する。主語を省略してもよい場合：直前の文と同じ主語の場合、文脈から主語が明らかな場合。主語を省略してはいけない場合：主語が変わる場合、責任の所在を明確にする必要がある場合、複数の解釈が可能な場合。冗長さを避ける正確に書くことは重要だが、冗長に書くことは避けなければならない。必要な情報だけを、必要な長さで書く。冗長な文章は、読み手の時間を無駄にする。忙しいエンジニアは、冗長な文章を読む時間がない。冗長な文章は、重要な情報を埋もれさせる。冗長さには、いくつかのパターンがある。パターン1：同じことを繰り返す【悪い例】この問題は重要な問題です。なぜなら、この問題を放置すると、ユーザーに影響が出る重大な問題だからです。【良い例】この問題は重要です。放置するとユーザーに影響が出ます。パターン2：不要な修飾語を使う【悪い例】非常に重要な機能の実装を丁寧に進めています。【良い例】重要な機能を実装中です。「非常に」「丁寧に」といった修飾語は、情報を追加していない。削除しても意味は変わらない。パターン3：回りくどい表現を使う【悪い例】バグを修正することに成功しました。【良い例】バグを修正しました。「〜することに成功しました」は、「〜しました」で十分だ。冗長さを避けるには、3つの原則がある。原則1：削除できる言葉は削除する原則2：同じ情報は一度だけ書く原則3：具体的な動詞を使う簡潔さは、尊重の表現だ。読み手の時間を尊重し、認知リソースを尊重する。構造を明確にする一文一義で書き、主語を明示し、冗長さを避ける。しかし、それだけでは不十分だ。文章全体の構造を明確にする必要がある。箇条書きと文章の使い分けは、書き手の重要なスキルだ。並列関係の情報は箇条書きで、因果関係の情報は文章で。なぜ構造が重要なのか？構造は、思考の可視化だからだ。構造を明確にする最も基本的な単位は、パラグラフ（段落）だ。一つのパラグラフには、一つの主張しか含めない。構造を明確にするには、3つのレベルがある。レベル1：文のレベルレベル2：パラグラフのレベルレベル3：セクションのレベルこの3つのレベルの構造が明確な文章は、読み手にとって理解しやすい。第1段階の「正確に書く」力を身につけると、少なくとも誤解されない文章が書けるようになる。しかし、それだけでは不十分だ。読み手は、あなたの意図を汲み取ろうとしてくれるとは限らない。次の段階では、より能動的に誤読を防ぐ技術を学ぶ。ユーザーの問題解決とプロダクトの成功を導く　エンジニアのためのドキュメントライティング作者:ジャレッド・バーティ,ザッカリー・サラ・コーライセン,ジェン・ランボーン,デービッド・ヌーニェス,ハイディ・ウォーターハウス日本能率協会マネジメントセンターAmazon第1段階の実践訓練訓練1：一文一義の練習訓練2：主語の明示訓練3：冗長さの削除訓練4：構造の可視化訓練5：要約を書くAIを使った第1段階の訓練生成AIは、第1段階の訓練に有効だ。AIに構造をチェックさせるAIの文章を添削する重要な注意点第2段階：誤読されないように書く読解力の第2段階は「書かれていない意図を汲み取る力」だった。文章力の第2段階は、「読み手の誤読を防ぐ力」だ。第1段階では、文章の構造的な問題を防ぐ方法を学んだ。一文一義で書き、主語を明示し、冗長さを避け、構造を明確にする。しかし、構造が正しくても、誤読は起きる。なぜか？読み手と書き手でスキーマが異なるからだ。前のセクションで「知識の呪い」について説明した。ここでは、その呪いを断ち切り、読み手のスキーマに合わせて書く具体的な方法を学ぶ。「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策作者:今井むつみ日経BPAmazon技術ドキュメントの品質は、ここで決まる特に技術ドキュメントにおいては、第2段階が品質を決定づける。第1段階の「正確に書く」は、技術ドキュメントの必要条件だ。構造が曖昧で、主語が不明確で、冗長な技術ドキュメントは、そもそも読むに値しない。しかし、第1段階をクリアしただけでは、良い技術ドキュメントにはならない。技術ドキュメントの良し悪しを分けるのは、読み手が迷わず、誤解せず、必要な情報にたどり着けるかだ。これこそが第2段階の本質だ。構造的には正しいが、読み手のスキーマを無視したドキュメント。専門用語が説明なしに使われ、前提知識が明示されず、文脈が欠如しているドキュメント。こうしたドキュメントは、正確ではあるが、使えない。逆に、読み手のスキーマを想像し、知識の呪いを断ち切り、読み手が必要な情報にたどり着ける文脈を設計したドキュメントは、読み手を迷わせない。読み手は、探している情報をすぐに見つけられる。誤解なく理解できる。そして、次のアクションを取れる。APIリファレンス、設計書、運用手順書、トラブルシューティングガイド。これらの技術ドキュメントは、第3段階の「心を動かす」手法は不要だ。感情に訴える必要はない。しかし、第2段階の「誤読されないように書く」技術は、絶対に必要だ。技術ドキュメントを書くとき、常に自問すべきだ。「読み手は、この情報を探しているとき、どんな状況にいるのか？」「読み手は、どのくらいの前提知識を持っているのか？」「読み手は、この用語を知っているのか？」これらの問いに答えることが、使える技術ドキュメントと使えない技術ドキュメントを分ける。読み手のスキーマを想像するドキュメントを書くとき、まず問うべきは「読み手は誰か？」だ。読み手は誰か？何を知っていて、何を知らないか？どんな問題を解決しようとしているか？知識の呪いを断ち切るには、3つの方法がある。方法1：具体化する方法2：例示する方法3：段階的に説明する読み手のスキーマを想像する能力は、読み手として多様な文章に触れ、「わからない」を経験することで獲得できる。しかし、スキーマを想像するだけでは不十分だ。次に重要なのは、読み手の認知バイアスを考慮することだ。認知バイアスを考慮する読み手がどんなバイアスを持っているかを想定し、誤読を防ぐ。パターン1：二重否定による混乱【誤読されやすい例】この実装方法は悪くない。【誤読されにくい例】この実装方法は、実用上十分な性能を持っています。具体的には、毎秒1000リクエストを処理できます。パターン2：曖昧な数量表現【誤読されやすい例】この問題は重要です。【誤読されにくい例】この問題は、今週中に対応が必要です。なぜなら、放置するとユーザーがログインできなくなるからです。パターン3：主観的な評価【誤読されやすい例】このツールは使いやすい。【誤読されにくい例】このツールは、5分で環境構築できます。コマンド一つで起動でき、GUIで操作できます。認知バイアスを考慮した文章は、客観的で、具体的で、測定可能だ。文脈を設計する技術記事を書くとき、どこまで前提知識を説明すべきか。この判断には原則がある。原則1：読み手のレベルに合わせる原則2：この記事で必要な知識だけを説明する原則3：外部リソースを活用するテンプレートを活用する第2段階における最も実用的な方法の一つが、テンプレートの活用だ。テンプレートは、第1段階の「構造を明確にする」技術と似ているが、その目的は異なる。第1段階では、書き手が構造的に正しい文章を書くためのツールだった。第2段階では、読み手が迷わず、必要な情報にたどり着けるためのツールだ。テンプレートには、3つの利点がある。利点1：読み手の予測可能性を高める利点2：必要な情報を漏れなく提供する利点3：読み手の認知負荷を減らす例えば、バグ報告のテンプレートは次のようになる。## 概要[バグの概要を一行で]## 再現手順1. [手順1]2. [手順2]3. [手順3]## 期待される動作[何が起きるべきか]## 実際の動作[実際に何が起きたか]## 環境- OS: - ブラウザ: - バージョン: ## 追加情報[スクリーンショット、ログなど]このテンプレートを使えば、読み手（バグを修正するエンジニア）は、必要な情報をすぐに見つけられる。「再現手順はどこだ？」「どの環境で起きたんだ？」と探す時間を削減できる。技術ドキュメントのテンプレートは次のようになる。## 概要[この文書が何について説明するか]## 前提条件[読者が知っているべきこと、必要な環境]## 手順[具体的な手順、コード例]## トラブルシューティング[よくある問題と解決法]## 参考資料[関連するドキュメント、リンク]プルリクエストのテンプレートは次のようになる。## 変更内容[何を変更したか]## 変更理由[なぜ変更したか]## 影響範囲[どの機能に影響するか]## テスト[どのようにテストしたか]## レビューのポイント[レビュアーに特に見てほしい箇所]テンプレートを使う際の注意点：テンプレートは、読み手を助ける道具だ。しかし、テンプレートに縛られすぎてはいけない。状況に応じて、テンプレートをカスタマイズする。不要なセクションは削除し、必要なセクションは追加する。重要なのは、「読み手が必要な情報にたどり着けるか」という問いだ。テンプレートは、この問いに答えるための手段であって、目的ではない。第2段階の「誤読されないように書く」力を身につけると、読み手に正確に情報を伝えられるようになる。読み手のスキーマを想像し、認知バイアスを考慮し、読み手が必要な情報にたどり着ける文脈を設計する。しかし、それだけでは不十分だ。情報を伝えるだけでなく、読み手の心を動かす必要がある。なぜなら、心が動かなければ、読み手は行動しないからだ。次の段階では、その方法を学ぶ。第2段階の実践訓練訓練1：説明を書くスキーマを想像しながら書く訓練だ。「この人は何を知っていて、何を知らないか？」を考える。具体的には、次のような取り組みができる。初心者向けに、自分が得意な技術を説明する記事を書く。専門用語を使うたびに、「この用語は説明が必要か？」と自問する。書いた後、その分野に詳しくない人に読んでもらい、わからなかった箇所を聞く。訓練2：批判的に読む訓練3：テンプレートの作成エストなど）のテンプレートを作る。ただし、第1段階の「構造を明確にする」だけでなく、「読み手が必要な情報にたどり着けるか」という視点で作る。読み手が最も知りたい情報は何か？それをどこに配置すれば見つけやすいか？AIを使った第2段階の訓練AIに読み手のスキーマを想像させるAIと対話しながら書く重要な注意点第3段階：心を動かすように書く読解力の第3段階は「本当に重要なことを見抜く力」だった。文章力の第3段階は、「読み手の心を動かす力」だ。なお、この第3段階は、技術記事、ブログ、プレゼンテーションなど、読者の心を動かす必要がある文章に適用される。技術ドキュメント（APIリファレンス、設計書、仕様書など）では、第1段階と第2段階で十分だ。むしろ、客観性と正確性が重視される技術ドキュメントには、この段階の手法は合わない場合が多い。「読みたいこと」とは何か？多くの人が誤解する。「読みたいこと」とは、「自由に好き勝手に自分の気持ちを書くこと」ではない。「読みたいこと」とは、自分が読者だったら読みたいと思うものだ。自分が本屋で金を出して買いたいと思うもの。自分が時間を使って読みたいと思うもの。書きたいことではない。読みたいことだ。これは、他人の視点に立てという話ではない。徹底的に自分の視点で、自分が読者として読みたいかどうかを問うということだ。この問いは、書きたいことを書く自由よりも、はるかに厳しい制約だ。第1段階では構造を学び、第2段階では誤読を防ぐ技術を学んだ。しかし、それだけでは読み手の心は動かない。心を動かすには、まず読者を引きつける必要がある。三行で撃つ 〈善く、生きる〉ための文章塾作者:近藤 康太郎ＣＥメディアハウスAmazon最初の三行で撃つ最初の一文、長くても三行くらいで心を撃たないと、忙しい読者は逃げていく。読者はあなたに興味がない。読者にとって、あなたの書こうとするテーマはどうでもいい。冷厳な現実だ。では、どうすれば最初の三行で読者を撃てるのか？方法1：問題を提示する方法2：驚きを与える方法3：具体的な利益を示すしかし、最も重要なのは、お前が何者かは、読者にとって関係ないということだ。【悪い例】私は10年間、技術記事を書いてきました。その経験から学んだ文章術を共有します。読者は、基本的にあなたの経歴に興味がない。あなたが何年エンジニアをやってきたか、どんな実績があるか、ほとんどの読者にとってどうでもいい。読者が知りたいのは、「この記事は自分の問題を解決してくれるのか？」「面白い時間が過ごせるか？」「読む価値のある新しい視点があるのか？」「具体的で実践できる内容なのか？」「読んだ後、自分は何ができるようになるのか？」。これらの問いだけだ。書き手の自己紹介から始まる記事は、これらの問いに答えていない。だから、読者は離れていく。【良い例】エラーメッセージを読めない人は、エラーメッセージを吐き出させるときも曖昧だ。なぜか？この書き出しは、問題提起だ。読者は「なぜだろう？」と思う。書き出しで読者を引きつけることができた。しかし、心を動かすにはそれだけでは不十分だ。次に必要なのは、空虚な言葉を避けることだ。常套句を避ける書き出しで読者を引きつけても、内容が空虚なら読者は離れていく。そして、内容を空虚にする最大の敵が、常套句だ。常套句は、まさに「わかったつもり」を生み出す装置だ。このアプローチはベストプラクティスです。「ベストプラクティス」とは何か？誰が決めたのか？どういう文脈で最適なのか？なぜ最適なのか？これらの問いに答えない限り、「ベストプラクティス」という言葉は空虚だ。常套句には、いくつかのパターンがある。パターン1：抽象的なバズワードラクティス、レバレッジ、シナジー、エンパワーメント、イノベーション。これらの言葉は、具体的な内容を隠蔽する。パターン2：「としたもんだ表現」パターン3：擬音語・擬態語・流行語常套句を避けることは、思考を深めることだ。「ベストプラクティス」と書こうとして、「本当にベストなのか？」と自問する。この思考の過程が、文章を具体的にし、説得力を高める。常套句を避け、具体的に書くことができたら、次は自分にしか書けない内容を書く。自分の言葉で書く【常套句に逃げる例】Rustの所有権システムは学習が難しい。でも、理解すれば強力だ。これは誰でも書ける文章だ。【自分の言葉で書く例】私がRustの所有権システムを理解するのに、3ヶ月かかった。最初の1ヶ月は、borrowチェッカーのエラーが理解できず、「なぜこのコードが動かないのか」と毎日フラストレーションを感じていた。「cannot borrow `*x` as mutable because it is also borrowed as immutable」このエラーメッセージを見るたびに、「Cのポインタのように自由に使わせてくれよ」と思っていた。転機は、所有権を「責任の所在」として捉え直してからだ。「このデータに対する責任は誰が持つのか」と考えるようになってから、borrowチェッカーのメッセージが「監査人の指摘」として理解できるようになった。この文章は、あなたにしか書けない。あなたの体験、あなたの発見だ。自分の言葉で書くには、3つの要素が必要だ。要素1：具体的な体験要素2：五感で世界を切り取る要素3：思考の過程自分の言葉で書くとは、言い換えることだ。「所有権」という抽象的な概念を、「責任の所在」という具体的な比喩で言い換える。言い換えるとは、考えることだ。しかし、自分の言葉で書くだけでは不十分だ。言葉だけでは、読み手の心は十分には動かない。次に必要なのは、エピソードの力だ。技術ブログの書き方はここに書いているので読んでみてほしいです。syu-m-5151.hatenablog.comsyu-m-5151.hatenablog.com響く文章は説明しない【説明する例】ドキュメントを書くことは重要です。なぜなら、ドキュメントがないとユーザーが困るからです。説明は響かない。【エピソードで語る例】私が初めてオンコール当番を担当したとき、深夜2時にアラートが鳴った。Datadogのダッシュボードには、「CPU usage \u003e 80%」というアラートしか表示されていなかった。「どのサービスのCPUが高いのか」「何が原因なのか」「どうやって対処すればいいのか」何もわからず、私は1時間を無駄にした。結局、先輩を叩き起こして対処してもらった。先輩は5分で原因を特定し、10分で対処した。翌朝、先輩に聞いた。「なぜそんなに早く対処できたんですか？」先輩は言った。「アラートに必要な情報が書いてあったからだよ」そのとき誓った。自分がアラートを作るときは、必ずRunbookへのリンクを含めようと。それから3年、私はこの誓いを守っている。エピソードは響く。具体的な場面、具体的な感情、具体的な決断。これらが、読み手の心を動かす。なぜエピソードは説明よりも響くのかエピソードが響く理由は、共感にある。読み手は、あなたの物語の中に自分を見出す。「深夜2時のアラート」「何もわからない焦り」「先輩を叩き起こす申し訳なさ」。これらの感情は、多くのエンジニアが経験したことがある。あるいは、いつか経験するかもしれない。だから、読み手は「ああ、わかる」と思う。この「わかる」という感覚が、共感だ。共感は、説明では生まれない。「ドキュメントは重要です」という説明は、頭では理解できる。しかし、心は動かない。一方、エピソードは、読み手を物語の中に引き込む。読み手は、あなたの経験を追体験する。あなたの焦りを感じ、あなたの学びを共有する。共感してもらえる物語には、3つの条件がある。条件1：普遍的な感情を含む条件2：具体的な状況を描く追体験できる。「1時間を無駄にした」という具体的な時間。「先輩を叩き起こした」という具体的な行動。条件3：弱さを見せる共感は、信頼を生む。読み手があなたの物語に共感すると、あなたの言葉を信頼するようになる。「この人は、自分と同じ問題に直面して、それを乗り越えた人だ」。この信頼が、読み手を行動に移させる。説明では信頼は生まれない。しかし、共感できる物語は、信頼を築く。ただし、共感を意図的に操作しようとしてはいけない。作られた感情や、誇張された困難は、読み手に見抜かれる。本当に経験したこと、本当に感じたこと、本当に学んだことを書く。その誠実さが、最も強い共感を生む。エピソードで語るには、ストーリーの構造が必要だ。状況 - どんな状況だったか問題 - 何が問題だったか行動 - 何をしたか結果 - どうなったか学び - 何を学んだか自分の言葉で書き、共感してもらえるエピソードで語る。しかし、それでも心を動かすには、もう一つ必要なものがある。それは、あなたの生き方や物語そのものだ。書くことは生きること「書くことは生きること」。文章を書くことは、技術ではない。生き方だ。思索が深まるほどに、世界の切り取り方が変わり、自分が変わる。技術記事を書くとき、私たちは技術を説明しているだけではない。私たちは、技術を通して世界を理解している。「なぜこの技術は存在するのか」「どんな問題を解決するのか」「どんな未来を可能にするのか」。これらの問いに答えることは、技術を理解することであり、同時に世界を理解することだ。そして、これらの問いに答える過程で、私たちは自分自身を理解する。書くことで、私たちは自分になる。書くことは、自分の物語を紡ぐこと書くことは、単に情報を伝えることではない。自分の物語を紡ぐことだ。あなたがエンジニアとして生きてきた日々。深夜のデバッグ、突然の本番障害、チームでの議論、新しい技術との出会い、失敗から学んだ教訓。これらすべてが、あなたの物語だ。書くとは、これらの断片的な経験を、一つの物語として編集することだ。物語には、3つの力がある。力1：意味を与える力力2：つながりを生む力力3：未来を変える力しかし、物語を紡ぐには、勇気が必要だ。自分の失敗を書くこと。「わからなかった」「1時間を無駄にした」「先輩を叩き起こした」。これらの弱さを見せることは、恥ずかしい。しかし、完璧な成功物語は、誰の心も動かさない。読み手が求めているのは、完璧なヒーローではない。同じように悩み、同じように失敗し、それでも前に進んだ人の物語だ。あなたの物語は、すでにある。日々の仕事の中で、あなたは物語を生きている。書くことは、その物語を可視化することだ。そして、可視化することで、物語はより明確になる。「自分は何を大切にしているのか」「どんな価値観で生きているのか」「どこに向かっているのか」。物語を書くことで、あなたは自分の物語を理解する。わたしにしか、書けないものは、ある。わたしにしか、紡げない物語は、ある。そう信じることから、文章は始まる。第3段階の実践訓練なお、これらの訓練は、技術記事、ブログ、プレゼンテーションを書く人向けだ。技術ドキュメントを書く人は、第1段階と第2段階の訓練に集中してほしい。訓練1：書き出しを3パターン書く訓練2：常套句を見つけて書き直すラクティス」→「なぜベストなのか？どういう条件で？」と問う。技術記事では、抽象的な言葉が説得力を失わせる。訓練3：自分の体験を書く訓練4：説明ではなく、エピソードで語る訓練5：自分の文章を読み直すAIを使った第3段階の訓練AIに書き出しを生成させて、添削するAIに常套句を指摘させるAIに自分の文章を批判させるAIには書けないものを書くおわりに「読解力を分解してちゃんと文章を読む。」を書いたとき、私は気づいた。読む力を説明しようとすることは、書く力を鍛えることでもあると。そして今、「文章力を分解してちゃんと文章を書く。」を書き終えて、改めて実感する。書く力を説明しようとすることは、読む力を鍛えることでもあると。読む力と書く力は、別々のスキルではない。同じスキルの異なる側面だ。この記事の冒頭で、私はこう書いた。「技術記事を読んで『わかった』と思ったのに、いざ実装しようとすると何も書けなかった経験はないだろうか」。なぜ実装できないのか。答えは明確だ。頭の中で再構築できていないからだ。読むとは、実は書くことなのだ。ただ、それが頭の中で行われているだけだ。だから、読む力を高めたいなら、書くことだ。書く力を高めたいなら、読むことだ。この循環が、複利的に機能する。第1段階では、正確に書く技術を学んだ。一文一義、主語の明示、構造の明確化。これは、悪文を書かないための必要条件だ。第2段階では、誤読を防ぐ技術を学んだ。読み手のスキーマを想像し、知識の呪いを断ち切り、文脈を設計する。特に技術ドキュメントでは、この段階が品質を決定づける。第3段階では、心を動かす技術を学んだ。書き出しで引きつけ、常套句を避け、自分の言葉で語り、エピソードで伝える。ただし、これは技術記事やブログに適用される段階であり、技術ドキュメントには不要だ。しかし、文章を書くことの意味は、スキルを高めることだけではない。書くことは、思考を深めることだ。思索が深まるほどに、世界の切り取り方が変わり、自分が変わる。書くことは、世界を理解することだ。技術を説明しようとするとき、私たちは「なぜこの技術は存在するのか」「どんな問題を解決するのか」を問う。書くことは、自分を理解することだ。言語化できない部分に直面したとき、私たちは「本当は理解していなかった」と気づく。だから、書くことは生きることだ。明日から、何か一つ書いてみよう。Slackのスレッドでもいい。プルリクエストのコメントでもいい。技術記事でもいい。書こうとして手が止まる瞬間、そこに理解の穴がある。その穴を埋めることが、あなたの成長だ。わたしにしか、書けないものは、ある。そう信じて、書き続けることだ。","isoDate":"2025-10-14T04:36:02.000Z","dateMiliSeconds":1760416562000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"読解力を分解してちゃんと文章を読む。","link":"https://syu-m-5151.hatenablog.com/entry/2025/10/12/081300","contentSnippet":"はじめに自分の読解力に絶望する瞬間というものがあります。たとえば、エラーログを読んでいるとき。無意識のうちに「こういうエラーだろう」という仮説を立てて、その証拠を探すように読んでしまっていました。問題を解決した後で同じログを読み返すと、「なんでこんな読み方をしたんだ？」と首をかしげます。明らかに違うことが書いてあるのに、自分の仮説に都合のよい部分だけを拾い読みしていました。エラーログという機械が出力するシンプルな文章ですら、こうなのです。もっと複雑なドキュメントなら、どれほど読み間違えていることでしょうか？ライブラリのドキュメント、APIリファレンス、技術記事、PRのコメント、issueの議論、Slackでのやり取り。すべて同じ問題を抱えている可能性があります。これは挑発でも誇張でもありません。「文章が読める人」は想像以上に希少で、自分も含めて、多くの人は書いてあることを読んでいません。自分の主張や仮説、感情があって、それに合うように拾い読みしているだけなのです。なぜこんなことが起きるのでしょうか？それは人は文章を読む前から、すでに何らかの主張や仮説、感情を持っているからです。そして無意識のうちに、それを正当化できる「都合のよいワード」だけを探している。文章全体の文脈や意図を理解するのではなく、自分の主張や仮説にマッチする断片だけに反応する。これは読解ではありません。結論ありきの確認作業です。虐殺器官 (ハヤカワ文庫JA)作者:伊藤 計劃早川書房Amazon今の時代、わからないことがあれば、ChatGPTやClaudeに聞けばいい。生成AIは、いつでも、何度でも答えてくれます。これは本当に素晴らしいです。でも——生成AIがあれば読解力は不要になるのでしょうか？違います。逆だと思っています。生成AIによって読解力は底上げされます。ただし、それは生成AIをどう使うかにかかっています。生成AIを正しく使えば、読解力を飛躍的に高められます。でも、間違った使い方をすれば、読解力は逆に衰えます。この記事では、「読む」という行為を分解し、それぞれの壁をどう超えるか、そして生成AIをどう活用すべきかを語っていきます。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。読解力は分解可能なスキル群ですスキルというのは、単一の能力で成り立っているわけではないことが多いです。だいたいは複数の能力の集合体です。コーディングがうまくなりたい？それなら取り組むべきことは山ほどあります。言語仕様を深く理解する、デザインパターンを学ぶ、Effective 〇〇のようなベストプラクティスを身につける、テストの書き方を学ぶ、デバッグの技術を磨く。さらに、メモリ管理を理解する、並行処理を扱えるようになる、セキュリティや運用を考慮できるようになります。でも、技術的なスキルだけじゃないです。コミュニケーション能力を高める、他人のコードを読む力をつける、レビューでフィードバックをする、技術的な議論ができるようになる。業界知識を身につける、ドメイン知識を深める、チーム開発の進め方を学ぶ。コーディングというスキルは、技術、人間関係、知識という軸からなる、いくつものスキルの集合体なんだと思います。漠然と「コーディングが上手くなりたい」と思っているだけでは、何をすればいいかわかりません。でも分解して「Rustの所有権システムを深く理解する」と具体化すれば、The Rust Programming Languageを読む、borrowチェッカーのエラーと向き合う、といった具体的な練習メニューが見えてきます。「デザインパターンを学ぶ」と具体化すれば、GoFのパターンを実装してみる、OSSのコードでパターンを探す、といった具体的な行動が見えてきます。読解力も同じです。書いてあることを正確に読むには、実はいろんなスキルが要ります。語彙力、文法理解力、主語・述語の把握、修飾関係の理解、論理構造の把握、情報の正確な抽出。こういった「書いてあることを正しく読む」基礎的なスキル。さらに、文脈の理解、推測力、共感力、批判的思考、バイアスへの気づき、メタ認知。こうした「行間を読む」応用的なスキル。そして、抽象化能力、本質を見抜く力、問いを立てる力、情報の優先順位づけ。「何が本当に重要なのか」を見極める統合的なスキル。読解力もまた、複数のスキルの集合体です。熟達論―人はいつまでも学び、成長できる―作者:為末大新潮社Amazon上達とは分解して考えることどんな能力でも、「取り組めるまで分解して考えること」が重要です。漠然と上手になりたいでは、いつまで経っても上達しません（天才を除く）。分解しないとどうなるでしょうか？「ドキュメントをちゃんと読めるようになりたい」では漠然としすぎて何をすればいいかわかりません。練習のしようがないです。でも「仮説を立てる前に、書かれている情報を網羅的に抽出する」と分解すれば、明日から実践できる具体的な読み方が見えてきます。エラーログを開いたとき、まず全行を読んでからメモ帳に情報を列挙する、という具体的な行動に落とし込めます。壮大に見えた挑戦も、分解してみれば、シンプルなタスクの積み重ねでしかありません。コーディングも、読解も、他のどんなスキルも同じです。頭の良さが成功の命運を分けるほど高尚な仕事はありません。必要なのは、分解する視点と、一つずつ取り組む地道さです。この原則は、コーディングでもドキュメントの読解でも、あらゆるスキルに共通しています。そして、生成AI時代においても、この原則は変わりません。むしろ、生成AIがあるからこそ、読解力を分解して鍛えることが、より重要になります。分解できていなければ、生成AIに「何を」「どう」聞けばいいのかもわからないのですから。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazon読解力には3つの段階があります読解力には、大きく3つの段階があります。この記事では、その3つの段階を一つずつ分解して説明していきます。ただし、これは一方通行の階段じゃありません。私たちはこれらの段階を行ったり来たりします。第3段階まで到達した人でも、疲れているときや慣れない分野の文章を読むときは、第1段階に戻ります。そう、読解力とは一定じゃありません。「能力」という言葉には「力」という漢字が含まれています。そのせいか、まるで機械のスペックのように「私の読解力は○○レベル」と固定値で捉えてしまいがちです。筋力のように、一定の出力を常に出せるものだと思ってしまいます(筋力も…というツッコミもあります)。しかし実際はそうではありません。能力はその瞬間の状態に大きく左右される可変的なものです。読解力は文脈によって大きく変わります。自分の専門分野のドキュメントなら第3段階まで読めるのに、まったく知らない分野の文章なら第1段階で苦戦します。朝の集中できる時間なら深く読めるのに、疲れた夜には表面的にしか読めません。特に感情状態の影響は大きいです。怒りや悲しみを抱えたまま技術記事を読んでも、書かれている内容が頭に入ってきません。これは単に集中力が切れるという話ではありません。感情が認知のリソースを占有してしまうからです。仮に100のキャパシティがあっても、感情に30使われていたら、読解に使えるのは70だけになります。こうした揺らぎは、誰にでもどんな能力にもあります。この理解は、自己評価にも影響します。ある日うまく読めなかったからといって「自分には読解力がない」と結論づけるのは早計です。単にその瞬間の条件が悪かっただけかもしれません。だからこそ、筋力を鍛えるように、読解力も鍛える価値があります。鍛えるとは、能力の底上げと安定化を意味します。鍛えておけば、疲れているときでも、新しい分野でも、感情が揺れているときでも、ある程度は正確に読めるようになります。新装版 アブダクション　仮説と発見の論理作者:米盛裕二勁草書房Amazon第1段階：正確に読むこれは読解の土台です。書かれていることを正確に理解する力です。エラーログで考えてみましょう。第1段階では、どのコンポーネントが、どんな状態で、どんなエラーを出したのかを正確に読み取ります。エラーメッセージの構造を理解し、どこで何が起きたかを正確に把握します。技術記事なら、著者が説明している手順や概念を、一つ一つ正確に理解することです。「この関数は非同期です」という記述があったとき、それが何を意味するのか（Promiseを返すのか、コールバックを受け取るのか、await可能なのか）を正確に読み取ります。Rustのコンパイラエラーも良い例です。borrowチェッカーのエラーが出たとき、「所有権の問題だ」とざっくり理解するんじゃなくて、どの変数が、どのスコープで、どのように使われようとして、なぜそれが許可されないのか、を正確に読み取ります。これはプログラミングにおける「構文を理解する」に相当します。変数、関数、制御構文といった基本がわからなければ、その先のロジックを理解することはできません。読解も同じです。まず書かれていることを正確に読む。この段階なしに、次の段階には進めません。シン読解力―学力と人生を決めるもうひとつの読み方作者:新井 紀子東洋経済新報社Amazon第1段階の壁：基礎訓練の不足多くの人はこの第1段階で躓いています。基礎訓練が不足しているんです。例えば、次の2つの記述の違いが分かるでしょうか？「システムは、2025年1月、レガシーAPIを廃止し、クライアントには新APIへの移行を推奨した」と、「2025年1月、レガシーAPIは廃止され、システムはクライアントから新APIへの移行を推奨された」。答えは「異なる」です。前者ではクライアントが移行を推奨されているのに対し、後者ではシステムがクライアントから推奨されている（主従関係が逆）です。もっと身近な例で見てみましょう。技術記事に「このメソッドは非同期です」と書かれています。多くの開発者は「わかった」と思って先に進みます。でも実際には、「非同期である」という情報だけでは不十分です。Promiseを返すのか、コールバックを受け取るのか、await可能なのか、エラーハンドリングはどうするのか。これらの情報も読み取らなければ、正確な理解とは言えません。コーディングに例えるなら、コードはたくさん書くが、変数のスコープを理解せず、型システムの理解もせず、言語仕様の訓練もしない。基礎がないから複雑なシステムを作れない、という状況です。文章の読解も同じ。たくさん読むが、文構造の理解訓練はせず、論理的思考の訓練もしない。基礎がないから正確に読めません。この壁を超えるには基本的な訓練が重要です。主語・述語を意識する。ドキュメントやエラーメッセージで、「誰が」「誰に」「何を」しているのか。これを正確に把握する癖をつけます。仮説を立てる前に全部読む。私はこれでエラーログの読み間違いが激減しました。全行読んで、情報を列挙してから、それから仮説を立てる。順番を変えるだけで、見える景色が変わります。文脈を意識する。これはリファレンスなのか、チュートリアルなのか、トラブルシューティングなのか。文章の「置かれた場所」で、読み方も変わるべきなんです。音読してみる。本質的な訓練ではないが、驚くほど効果的です。声に出すと、飛ばし読みができなくなる。一文字ずつ確実に読むことを強制される。視覚だけでなく聴覚も使うので、「読んだつもり」が減る。特に、複雑なエラーメッセージや理解しにくいドキュメントを読むときは、小声でもいいから音読してみるといいです。読むスピードが落ちる分、思考する時間が生まれる。主語と述語の関係も掴みやすくなります。生成AIは、この基礎訓練を補助してくれます。わからない専門用語が出てきたとき、集中力を途切れさせずに「『非同期処理』とは何ですか？」と聞ける。複雑な文章の主語・述語の関係がわからなくなったとき、「この文章の構造を分解してください」と聞ける。技術記事を読んで「わかった」と思ったとき、「私はこう理解しました。[あなたの理解]。この理解は正しいですか？」と確認できます。ただし、まず自分で読むことが前提です。最初の一文を読んですぐ「要約して」と頼むのでは、読解力は鍛えられません。生成AIに分解してもらった後、必ず自分でもう一度読み直します。生成AIの説明も間違えることがあるので、公式ドキュメントでも確認します。生成AIはあくまで訓練の補助です。第2段階：裏を読む第1段階で書かれていることを正確に読めるようになったら、次は書かれていない意図を汲み取る力が必要になります。エラーログで考えてみましょう。第2段階では、エラーの背後にある状況を推測します。タイムアウトエラーがあったとき、単に「タイムアウトした」という事実だけじゃなく、「なぜタイムアウトしたのか」を考える。ネットワークが遅いのか、サーバーが応答していないのか、ファイアウォールで遮断されているのか。技術記事を読むときも同じ。「この実装方法を推奨します」という記述があったとき、なぜ著者はそれを推奨するのか、どんな状況を想定しているのか、逆にどんな状況では推奨しないのか、を推測します。PRのコメントで「ここ、もっと良い方法があるかも」と書かれていたとき、それは単なる提案なのか、変更を強く求めているのか、それとも議論を始めたいのか。書かれている言葉だけでなく、その裏にある意図を読み取る力です。Rustのドキュメントを読むとき、「この関数はunsafeです」という記述の裏には、「注意深く使わないとメモリ安全性が損なわれる」という警告がある。「このトレイトはSendです」という記述の裏には、「スレッド間で安全に送信できる」という保証があります。これはプログラミングにおける「ロジックを理解する」に相当します。構文を理解した上で、なぜこのデザインパターンを使うのか、なぜこのデータ構造を選ぶのか、といった背景や意図を理解する段階です。読解力は最強の知性である　１％の本質を一瞬でつかむ技術作者:山口 拓朗SBクリエイティブAmazon第2段階の壁：認知バイアスこの第2段階では大きな壁にぶつかります。それが認知バイアスです。エラーログを読むとき、私は無意識に確証バイアスの罠にはまっていました。確証バイアスとは、自分の信念を裏付ける情報を探し求め、それ以外を見ない・軽視する心理学の概念。既存の仮説として「これはメモリの問題だ」と思っていると、フィルターが発動し、メモリに関する情報だけを拾うようになる。結果として、ネットワークに関する情報を見落としてしまいます。GitHubのissueでも同じことが起きています。「この機能の実装、19時までに終わらせるのは無理だった。他のタスクもあるし、月1回くらいしかこのペースで進められない」というコメントを読んで、「マネジメントに文句を言っている」と受け取る人がいます。でも、よく読んでほしいです。このコメントには「マネジメントが悪い」とは一言も書かれていない。書かれているのは、ただ「間に合わなくて申し訳ない」という弱音だけです。なぜこのような誤読が起きるのか？「この人は以前も遅れていた」「いつも文句を言っている」という既存の印象があると、フィルターが発動し、「マネジメントを批判している」と読み取ってしまいます。でも実際に書かれていることは、「間に合わなくて申し訳ない」という弱音だけです。ここで重要なのは、私たちの直観は想像以上に信頼できないということです。「直観に従えば大丈夫」——もしこれが本当なら、文章の誤読はほとんど起きないはずです。エラーログを読めば直観的に原因がわかる。ドキュメントを読めば直観的に使い方がわかる。コメントを読めば直観的に意図がわかる。でも現実はどうでしょうか？私たちは、人生で何千、何万もの文章を読んできました。それでも、誤読は頻繁に起きます。「ちゃんと文章を読める」と自認している人でも、エラーログを読み間違え、ドキュメントを誤解し、コメントを誤読しています。つまり、直観的な判断は、それなりの確率で裏切ります。ファスト＆スロー　（上）作者:ダニエル カーネマン,村井 章子早川書房Amazonなぜか？直観は過去の経験とパターン認識に基づいているからです。「このエラーは以前見たことがある」「この書き方は○○を意味する」——そう直観的に思った瞬間、私たちは確証バイアスのフィルターをかけてしまいます。直観に従うほど、書かれていることではなく、「自分が予想したこと」を読むようになります。だからこそ、意識的な読み方が必要なんです。直観を完全に排除することはできません。でも、「直観は間違うかもしれない」と自覚するだけで、読み方は変わります。「直観的にこう思う。でも、本当にそう書いてあるか？」と自問する癖をつける。これだけで、誤読は激減します。私たちは、自分が信じたいものを信じるようにできています。ちなみに、SNSでは誤読が頻繁に起こります。でも、発信する側の心持ちとして、SNSでは誤読されるのも投稿する内だと思っていたほうが精神衛生上良いんです。SNSという媒体は本質的に誤読を生みやすいからです。文脈が省略され、文字数に制限があり、読者の背景や感情状態も様々です。「炎上」の多くは、この誤読から生まれる。できるのは、自分自身が読む側に回ったとき、「書かれていないこと」を読み取っていないか、常に自問することだけです。この壁を超えるには基本的な訓練が重要です。「書かれていないこと」を排除する。一文字ずつ丁寧に読み、「これは本当に書いてあるか？」と確認し、「自分が勝手に補完していないか？」と自問する。特に、怒りの感情を覚えたときは要注意だ。複数の解釈を考える。1つの文章に対して、少なくとも3つの異なる解釈を仮定してみる。先ほどの「19時までに終わらせるのは無理だった」なら、①単純に弱音を吐いている、②マネジメントを批判している、③このプロジェクトから離れたいと思っている、という3つの解釈が考えられる。書かれていることだけからは①が最もストレートだけど、「確定」はできません。バイアスのメタ認知。文章を読んで強い感情（怒りや共感）を覚えたら、ちゃんと読み直し、「自分のバイアスではないか？」と自問し、複数の解釈可能性を列挙する。生成AIは、別の視点を提供してくれる。「この文章の別の解釈の可能性を3つ教えてください」と聞けば、あなたが思いつかなかった解釈を示してくれることがある。「このコメントには、『マネジメントを批判している』という意図が書かれていますか？」と聞けば、書かれていることと書かれていないことを区別してくれる。ただし、生成AI自体もバイアスを持っている。生成AIも訓練データに基づいたバイアスを持っているし、あなたの質問の仕方が回答を誘導してしまうこともある。だから、中立的な質問をする。「この文章のトーンを分析してください」といった、オープンな質問をする。そして、まず自分で複数の解釈を考えてから、生成AIで確認します。この順番が大切です。第3段階：本質を読む第1段階で正確に読み、第2段階で裏を読めるようになったら、最後は本当に重要なことは何かを見抜く力が必要になります。エラーログで考えてみましょう。第3段階では、大量のログの中から本当に重要な情報を抽出する。100行のログがあったとき、その中で本当に問題の原因を示しているのはどの部分なのか。表面的には複数の問題が見えても、本質的には1つの根本原因から派生しているかもしれません。技術記事を読むとき、第3段階では表面的な実装方法ではなく、その根底にある設計思想や原則を理解する。「このコードはこう書く」という表層だけでなく、「なぜそう書くのか」「そもそも何を解決しようとしているのか」を見抜きます。Rustのドキュメントを読むとき、個々のAPIの使い方だけでなく、所有権システムという言語の根幹にある哲学を理解する力だ。これはプログラミングにおける「設計を理解する」に相当します。構文とロジックを理解した上で、なぜこのアーキテクチャを採用したのか、トレードオフは何か、本質的な問題は何か、を理解する段階です。ただし、新しい言語を学ぶときは構文から学び直す必要があるように、新しい分野の文章を読むときは第1段階から学び直す必要があります。これは退行ではなく、自然なことなんです。わかったつもり～読解力がつかない本当の原因～ (光文社新書)作者:西林 克彦光文社Amazon第3段階の壁：わかったつもり第3段階に到達しても、まだ最後の壁がある。これが一番厄介です。それが「わかったつもり」。「もう理解すべきことは何もない」って思った瞬間、人は思考停止します。新しい視点を受け入れなくなります。成長が、止まります。エラーログを開いて「あ、これはあのエラーだ」と思った瞬間、思考が停止します。そして仮説に合う部分だけ読んで、結果として問題を解決できません。実際には50%程度しか理解していないのに、「わかった」と思い込んでいます。エラーログを見て「ああ、これは接続エラーだ」と思った瞬間、「接続設定を確認すればいい」と結論づけてしまいます。でも実際には、設定以外にも、ファイアウォール、タイムアウト、認証、リトライロジックなど、他にも確認すべきことがあるかもしれない。「わかった」と思った瞬間に、これらの可能性を検討しなくなります。技術記事を読むときも同じ。「この技術は理解した」と思った瞬間、制約条件や例外的な状況を見落とす。「この設計パターンはわかった」と思った瞬間、適用すべきでない場面に気づかなくなります。この「わかったつもり」は、第1段階から第3段階まで、すべての段階で起こりうります。だからこそ、これが最大の壁なんです。読解力が高い人ほど、自分が「わかったつもり」になっていないかを常に点検しています。この壁を超えるには基本的な訓練が重要です。「なぜ」「そもそも」と問う。なぜこのエラーが出たのか？そもそも何が問題なのか？本当に重要なのはどこか？問いとは、答えをただ探すためのものではなく、物事の本質に近づこうとする\"姿勢\"そのものです。要約訓練。情報を要約する際は、「本当に重要なのは何か？」と自問する癖をつける。これは、99%の情報から1%の本質を抽出する訓練です。でも、「これが本質だ」と決めつけてはいけません。それが「わかったつもり」の罠だからです。情報の精査。情報に触れたら、「それは個人的意見なのか、客観的事実なのか？」と自問する。事実なのか意見なのか、データに基づいているのか印象なのか。この区別が、本質を見抜く力につながります。生成AIは、理解を検証してくれます。「私はこの技術の本質を『○○』だと理解しました。この理解は正しいですか？他にもっと重要な本質はありますか？」と聞ける。「なぜこの技術が必要なのですか？」と聞き、返ってきた答えに対して「なぜそれが問題なのですか？」とさらに聞ける。5回「なぜ」を繰り返す「5 Whys」を実践できます。長大なドキュメントを読んだ後、「このドキュメントの本質を、3つの文で要約してください」と聞けます。ただし、生成AIが示した「本質」も、一つの視点に過ぎません。生成AIは、訓練データに基づいて、「多くの人が本質だと考えていること」を答えます。でも、それが本当の本質かどうかは、わかりません。だから、生成AIの答えを「仮説」として扱う。「本当にそうか？」と疑う。他の情報源でも確認します。実際に使ってみて検証します。そして、まず自分で「なぜ」を考える。自分の考えを生成AIで確認します。この順番が大切です。すべて生成AIに聞いてしまうと、自分で考える力が衰えます。なぜ読解力を鍛えるべきなのかここまで読んで、「めんどくさそうだな」って思いました？正直、わかる。3つの段階、それぞれの壁、訓練方法、生成AIの使い方。別に分けんでもいいやろって思いました？しかも読解力って一定じゃなくて、落ちるらしいし、新しい分野だとまた1からやり直し。でも——これだけは言わせてほしい。生成AI時代だからこそ、読解力を鍛える価値は計り知れないです。「最近の人は長文が読めない」——よく聞く話ですが、これを単なる集中力不足だと片付けてはいけません。SNS、ショート動画、通知、いいね。私たちの脳は短期的な快楽にチューニングされ続けています。このサイクルを何年も繰り返すうちに、長文を読むことが単に「つまらない」だけでなく、苦痛に変わります。文脈を保持しながら論理を組み立てる——この一連のプロセスが、脳にとって「報酬が遠すぎる」活動になってしまうんです。スマホ脳（新潮新書） （『スマホ脳』シリーズ）作者:アンデシュ・ハンセン新潮社Amazonさらに深刻なのは、読解力の回路そのものが機能低下することです。文脈を保持する力が衰えると、文章を断片的にしか理解できなくなります。そして、自分の考えを整理する力も、読解力に依存しています。「なぜこのバグが起きたのか」を説明できない。「なぜこの設計を選んだのか」を答えられない。これは語彙不足ではなく、自分の内側で起きていることを掴めず、整理できていない状態です。感じているのに言語化できない。伝えたいのに届かない。誤解されて、孤立感が強まります。説明できる力は、安心感や人とのつながりの土台です。「自分だけは分かっている」という拠り所があるなら、人はまだ耐えられます。でも、自分の感じや考えを誰も拾ってくれないどころか、自分自身も拾えないとなると、存在の手応えや安心感が一気に揺らぎます。増補改訂版 スマホ時代の哲学 なぜ不安や退屈をスマホで埋めてしまうのか (ディスカヴァー携書)作者:谷川嘉浩ディスカヴァー・トゥエンティワンAmazon読解力は他のすべてのスキルを支える土台である読解力は、エンジニアとしてのキャリアの「土台」のようなものだ。基礎体力に近いかもしれません。コーディングで考えてみましょう。変数、関数、制御構文といった基礎がなければ、どんな技術も身につかない。Rustの所有権システムを学ぼうとしても、デザインパターンを理解しようとしても、並行処理を扱おうとしても、基礎がないと何も始まらない。読解力も同じ。読解力がなければ、どんなドキュメントも正確に理解できず、どんな技術も効率的に学べず、どんなコミュニケーションもうまくいきません。Rustを学びたいとする。でも、Rustのドキュメントを正確に読めなければ、所有権システムを理解できない。borrowチェッカーのエラーメッセージを正確に読めなければ、問題を解決できません。unsafeの意味を深く理解できなければ、適切に使えません。生成AIに「Rustの所有権システムを教えて」と聞けば、説明は返ってくる。でも、その説明を理解するのも、読解力だ。生成AIの説明が正しいかどうかを判断するのも、読解力だ。読解力が貧弱だと、コードを書く、設計する、レビューする、ドキュメントを書く、チームとコミュニケーションする、問題を解決する、新しい技術を学ぶ、生成AIを使いこなす、といった、エンジニアとしてのあらゆる活動で誤作動が生じます。逆に、読解力という土台があれば、すべてがスムーズに機能するようになります。生成AI時代においても、読解力はすべての土台なんです。読解力の差は、時間とともに指数関数的に広がる「読解力があるか、ないか」は、1回だけ見れば小さな差だ。でも、時間とともに指数関数的に広がっていきます。ドキュメントを正確に読める人と読めない人の差は、1回では小さいです。「たった1回の誤解」。でも、1年間ではどうでしょうか？ドキュメントを読めない人は、週に3回、APIの使い方を誤解します。年間で150回。そのたびに、実装をやり直す必要があります。週に3時間、年間で150時間を無駄にする。実装ミスのせいでバグが増える。デバッグに時間がかかる。納期が遅れる。レビュアーに迷惑をかけます。チームからの信頼を失う。新しい技術を学ぶスピードが遅くなる。結果として、キャリアが停滞します。生成AIを使っても、この差は変わりません。むしろ、生成AIがあるからこそ、読解力の差は広がる可能性があります。読解力がある人は、生成AIを補助ツールとして使って理解を深め、さらに読解力が高まる。読解力がない人は、生成AIに全面的に依存し、自分で考えなくなり、さらに読解力が低下します。1回の差は小さいです。でも、積み重なると大差になります。読解力が高い人は、読むことで新しい知識を得て、さらに読解力が高まる。読解力が低い人は、読むことで誤解を重ね、さらに読解力が低下する。時間とともに、差は指数関数的に広がっていきます。そして、自分の読解力が揺らぐことを自覚していれば、「今日は疲れているから、このドキュメントは明日読もう」という判断ができる。「怒りを感じているから、一旦落ち着いてから読み直そう」という戦略が立てられる。「この分野は初めてだから、第1段階から丁寧に読もう」という心構えができる。「疲れているから、生成AIに確認してもらおう」という判断ができます。読解力を鍛えることは、読解力そのものを高めることだけじゃありません。自分の読解力の限界を知り、それに応じた戦略を立てることでもあります。そして、生成AIをいつ、どう使うべきかを判断する力でもあります。読解はコミュニケーション「何回説明しても伝わらない」——こんな経験、誰にでもあるでしょう。上司から同じことを何度も指摘される。部下に説明したのに、まったく違うものができあがる。技術記事を読んだのに、実装したら全然違う結果になりました。多くの人は、これを「伝え方」の問題だと考える。でも、認知科学の研究が示すのは、違う真実です。問題は「言い方」じゃありません。「心の読み方」なんです。「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策作者:今井むつみ日経BPAmazonスキーマという名の「当たり前」認知科学には「スキーマ」という概念がある。これは、人それぞれが頭の中に持っている「当たり前」の枠組みのこと。知識や経験の構造化されたまとまりです。重要なのは、私たちは物事を「スキーマを通して」理解しているという点です。エラーログも、スキーマを通して読んでいる。ドキュメントも、スキーマを通して読んでいる。上司の指示も、スキーマを通して聞いている。生成AIの回答も、スキーマを通して読んでいます。「何回説明しても伝わらない」のは、説明する側と受け取る側で、スキーマが違うからです。上司が「この機能を実装してほしい」と言ったとします。上司の頭の中には、長年の経験から作られた「この機能」のスキーマがあります。でも、そのスキーマの大部分は、言葉にされていません。一方、受け取る側も、自分のスキーマを通してその指示を理解します。でも、それは上司のスキーマとは違うかもしれません。結果として、上司は「言ったはずだ」と思い、あなたは「聞いた通りにやった」と思う。でも、出来上がったものは違います。Rustのドキュメントを読むときも同じです。ドキュメントを書いた人には、Rustの所有権システムについての豊富なスキーマがあります。だから、「この関数はborrowします」という一文で、多くのことが伝わると思っています。でも、Rustを学び始めたばかりの人には、そのスキーマがありません。そして、生成AIの回答も、あなたのスキーマに依存しています。生成AIに「Rustの所有権システムを説明して」と聞いたとします。その説明を理解するのは、あなたのスキーマです。C++のスキーマを持っている人と、Pythonのスキーマしか持っていない人では、同じ説明を読んでも、理解する内容が違います。だから、生成AIに質問するとき、自分の前提知識（スキーマ）を明示することが有効なんです。「私はPythonしか知りません。Rustの所有権システムを、Pythonとの違いを中心に説明してください」と聞きます。人生の大問題と正しく向き合うための認知心理学 (日経プレミアシリーズ)作者:今井むつみ日経BPAmazon受け手としてどうすべきかじゃあ、受け手として、私たちはどうすればいいのか？まず、自分が持っているスキーマを自覚すること。「自分はこういう前提で理解している」と認識する。エラーログを読むとき、「これはメモリの問題だ」というスキーマで読んでいないか？生成AIの回答を読むとき、「自分の知っている範囲で」理解しようとしていないか？自分のスキーマを自覚するだけで、誤読は減ります。次に、「わかった」を疑うこと。説明を聞いて「わかった」と思った瞬間、実は自分のスキーマで解釈しているだけかもしれません。だから、理解したことを言い換えて確認します。「つまり、○○ということですか？」と聞く。生成AIを使うなら、「私はこう理解しました。[あなたの理解]。この理解は正しいですか？」と聞きます。そして、質問する勇気を持つこと。「わからない」と言うのは、勇気がいります。でも、わからないまま進むよりは、はるかにマシです。質問することは、恥ずかしいことじゃありません。自分のスキーマと相手のスキーマのズレに気づいて、それを埋めようとしている証拠です。最後に、柔軟にスキーマを更新することです。新しい技術を学ぶとき、既存のスキーマで理解しようとしがちです。でも、それが足枷になることがある。Rustを学ぶとき、C++のスキーマで理解しようとすると、所有権システムの本質を掴めません。コミュニケーションは双方向です。説明する側も、受け手のスキーマを想像する努力が必要だし、「伝わったかどうかを確認する」必要があります。受け手も、自分のスキーマを自覚し、「わかった」を疑い、質問する勇気を持ちます。この両方が揃って初めて、「伝わる」コミュニケーションが成立します。読解力とは、ただ文字を読む力じゃありません。自分のスキーマを自覚し、それを柔軟に更新しながら、相手の意図を理解しようとする力なんです。そして、生成AIを適切に使って、スキーマのズレを埋める力でもあります。情報を正しく選択するための認知バイアス事典作者:情報文化研究所フォレスト出版Amazon完璧を目指さない。でも「わかったつもり」にもならない「読解力を磨くこと」と「わかったつもりにならないこと」の間のバランスを見つけることが、本当の知性なんです。一方で、積極的に理解しようとする。努力して読解力を高める。3つの段階を一つずつ鍛える。基礎訓練の不足を補う。認知バイアスに気づく。「わかったつもり」を警戒する。生成AIを適切に使う。他方で、完璧を目指さない。常に完璧に読める人はいない。疲れているときもある。新しい分野もある。バイアスに引っかかるときもある。「わかったつもり」になってしまうときもある。生成AIの使い方を間違えるときもある。それは人間である以上、避けられません。重要なのは、失敗から学ぶことです。エラーログを読み間違えたなら、「なぜ読み間違えたのか？」と振り返る。確証バイアスに引っかかっていたのか、情報を網羅的に抽出していなかったのか、「わかったつもり」になっていたのか。生成AIに頼りすぎて、自分で考えなかったのか。次は同じ間違いをしないように、読み方を改善します。完璧を目指さない。でも、失敗から学び、少しずつ改善する。これが現実的な成長の道です。そして、常に「まだ理解できていないかも」という謙虚さを持つ。問いを持ち続ける姿勢を保ちます。優れたエンジニアは、何年コードを書いても、「完璧に理解した」とは思わない。新しい技術を学び続け、既存の知識を疑い続け、より良い方法を探し続ける。失敗から学び続ける。生成AIも適切に活用する。だから成長し続けられます。読解力も同じ。どんなに上達しても、「完璧に読めている」とは思わない。失敗から学び続ける。生成AIも適切に使い続ける。だから成長し続けられます。危険だからこそ知っておくべきカルトマーケティング作者:雨宮純ぱる出版Amazonおわりにエラーログを読み間違え、ドキュメントを誤解し、コメントを誤読する。「書いてあることを読んでいない」という絶望——この記事は、そんな問題からスタートしました。そして、「読む」という行為を分解してみました。読解力は複数のスキルの集合体でした。3つの段階があり、それぞれに壁がありました。第1段階の壁は「基礎訓練の不足」、第2段階の壁は「認知バイアス」、そしてすべての段階に共通する最大の壁が「わかったつもり」。生成AIは、これらの壁を超える補助ツールになる。でも、使い方次第です。まず自分で読む、鵜呑みにしない、依存しすぎない。この原則を守らなければ、読解力は逆に衰えます。読解力は他のすべてのスキルを支える土台であり、その差は時間とともに指数関数的に広がる。コミュニケーションはスキーマを通して行われるため、自分の「当たり前」を自覚し、「わかった」を疑い、柔軟にスキーマを更新することが大切です。完璧である必要はありません。でも、失敗から学び、少しずつ改善する。これが現実的な成長の道です。奪われた集中力: もう一度〝じっくり〟考えるための方法作者:ヨハン・ハリ作品社Amazonまずは一つだけ、明日から実践してみてほしい。明日エラーログを読むとき、こう自問してみる。「仮説を立てる前に、全行を読んだか？」（第1段階）「自分のバイアスで読んでいないか？」（第2段階）「本当に重要なのはどこか？」（第3段階）「自分のスキーマで解釈していないか？」（スキーマの自覚）明日生成AIに質問するとき、こう実践してみる。「まず自分で読んでから、わからないところだけ聞く」（第1段階）「複数の解釈の可能性を聞く」（第2段階）「理解を言語化して確認してもらう」（第3段階）「前提知識を明示して質問する」（スキーマの明示）それだけで、あなたの読解力は確実に一歩前進します。ところで、ここまで「読む」という行為を分解してきました。でも実は、もう一つの行為があります。「書く」という行為です。読解力の3つの段階——正確に読む、裏を読む、本質を読む——を理解した今、書き手としての視点も変わるはずです。「読めない読み手」を嘆く前に、書き手は自問すべきです。読み手が正確に読める文章を書いているか？誤読されにくい書き方をしているか？本質を掴みやすい構造にしているか？そして何より、読み手の読解力は一定ではないことを理解しているでしょうか？疲れているとき、慣れない分野を読むとき、感情が高ぶっているとき——読み手は第1段階でさえ苦戦します。さらに、スキーマの違いを忘れてはいけません。書き手にとって「当たり前」のことが、読み手にとっては「初めて聞く」ことかもしれません。よく言われる文章作法——「結論を先に書く」「一文を短くする」——これらを抽象化すると、すべて読み手の認知リソースを尊重するという原則に行き着きます。読み手は無限の時間と集中力を持っているわけじゃありません。その限られたリソースを、いかに有効に使ってもらうか。読解力と同じように、文章力も分解可能なスキル群です。読解力を分解して鍛えられるように、文章力も分解して鍛えられます。読解力を理解することは、文章力を理解することでもありますので書きました。syu-m-5151.hatenablog.com生成AIがあれば読解力は不要になるのか？——記事の冒頭で問いかけました。答えは明確です。生成AIがあるからといって、読解力が不要になるわけじゃありません。むしろ、生成AIを使いこなすために、読解力がますます重要になる。そして同じことが、文章力にも言えます。「わかったつもり」という最大の壁を、常に警戒してほしい。「もうわかった」と思った瞬間が、最も危険な瞬間なのですから。それでは。","isoDate":"2025-10-11T23:13:00.000Z","dateMiliSeconds":1760224380000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"生成AI時代に必要なコンサルタントの秘密","link":"https://syu-m-5151.hatenablog.com/entry/2025/10/08/091749","contentSnippet":"はじめに生成AIの登場により、専門家の役割は根本から問い直されている。知識はもはや希少ではない。誰もが、数秒で専門家のような回答を得られる。では、専門家の価値はどこにあるのか？この問いに、ジェラルド・M・ワインバーグ氏の『コンサルタントの秘密』は、40年前から答えを用意していた。彼が発見した「第三の道」——非合理性に対して合理的になること——は、生成AI時代においてどう進化するのか。コンサルタントの秘密　技術アドバイスの人間学作者:G.M.ワインバーグ共立出版Amazon本ブログでは、生成AIという新しい道具が登場した今、専門家が本当に提供すべき価値とは何かを探る。専門家の価値は、もう知識の量では測れない。大切なのは判断力だ。情報を文脈の中で読み解き、的確な問いを立てる——それが今、求められている。そして何より、責任を背負う覚悟だ。※この資料は社内共有会用に作成されたものです。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。戦場は静かに変わったジェラルド・M・ワインバーグ氏が『コンサルタントの秘密』を著したとき、彼は「非合理性に対して合理的になること」という第三の道を発見した。合理的であり続けて発狂するか、非合理的になって気違いと呼ばれるか——その二つの道しかないように見えた世界で、彼は第三の選択肢を見出したのだ。しかし2025年、専門家が立つ戦場は再び変貌した。今度の挑戦は人間の非合理性だけではない。それは生成AIという、新しい可能性と新しい課題を同時に持つ存在である。コンサルティング会社 完全サバイバルマニュアル作者:メン獄文藝春秋Amazon反逆の仕事論 AI時代を生き抜くための\"はみ出す力\"の鍛え方作者:樋口 恭介PHP研究所Amazon専門知の揺らぎ専門家への信頼が変化している。それは単なる無関心ではない。より深い課題がある。私たちは誰しも、自分の知識の限界を正確に把握するのは難しい。ダニング＝クルーガー効果が示すように、ある分野に詳しくないほど、自分の理解を過大に見積もってしまう傾向がある。これは人間として自然な認知バイアスだ。加えて確証バイアスが働き、自分の考えを支持する情報——時には陰謀論や偏った情報——を無意識に選んでしまうことがある。さらに難しいのは、エコーチェンバー効果だ。SNSのアルゴリズムは、私たちが関心を持つ情報を優先的に表示する。結果として、似た意見を持つ人々に囲まれやすくなり、異なる視点に触れる機会が減っていく。この環境の中で、私たちは自分の考えが一般的で正しいと感じやすくなる。専門家の助言は、時に「異質な声」として受け入れにくくなってしまう。専門家と人々が互いに学び合う関係を築くこと——それは理想論ではなく、より良い未来のための大切なステップだ。10年前、クライアントは聞いた。「ググればわかることに、なぜあなたに費用を払う必要があるんですか？」それでも、専門家には価値があった。Googleの検索結果は玉石混交で、その「石」を見抜く目が必要だったから。しかし今、あるCTOはこう問いかける。「生成AIに聞いたら、同じような提案が返ってきました。しかも無料で、5秒で。専門家に依頼する価値は、どこにあるのでしょうか？」専門知は、もういらないのか作者:トム・ニコルズみすず書房Amazon生成AIという新しいツールそして生成AIが登場した。会議室に新しいツールが現れたのだ。決して反論せず、疲れず、いつでも提案をしてくれる存在。人間は孤独に弱い。自分の考えに裏付けが欲しい。だからAIを活用して、より良い判断をしようとする。技術は道具であり、そして新しい可能性だ。会議で誰かがMacBookを開き、こう言う。「ちょっと生成AIに聞いてみますね」。30秒後。「このような提案があります。これをベースに議論しましょう」ここで重要なのは、その先だ。そのコード、動くのか？　そのアーキテクチャ、あなたの会社のレガシーシステムと統合できるのか？　その「ベストプラクティス」、あなたの組織文化に合うのか？AIは優れた出発点を提供する。しかし、それを現実に落とし込むのは人間の仕事だ。生成AIは、エコーチェンバー効果を個人レベルで完成させる可能性がある。SNSが「あなたと同じ意見の人々」を見せるなら、生成AIは「あなたの意見を裏付ける情報」を、権威ある言葉で返してくれる。プロンプトを調整すれば、望む答えが得られる。確証バイアスは、意図せず強化されうる。それは道具の使い方の問題だ。包丁は料理にも使えるし、人を傷つけることもできる。生成AIも同じだ。批判的思考を持って使えば、強力な調査ツールになる。盲目的に信じれば、危険なバイアス増幅装置になる。生成AIの提案は美しい。整然とした論理、洗練された図表、明確な結論。私たちは複雑さを嫌い、不確実性を恐れる。だからAIが描く理想の地図に惹かれる。しかし地図は地図であって、土地そのものではない。どれだけ美しい地図でも、そこには現実の泥や血や汗は描かれていない。ワインバーグ氏は言った。「第一番の問題を取り除くと、第二番が昇進する」と。問題は連鎖する。一つ解決すれば終わりではない。生成AIは、あたかもすべての問題が一度に解決できるかのような印象を与えることがある。明快な答え。即座の解決。思考の終着点。しかし、現実はそうではない。この認識が、専門家と依頼者の双方にとって出発点になる。それは人間が最も渇望するものだ。不確実性からの解放。判断という苦痛からの逃避。だからこそ、専門家は不確実性と共に生きる知恵を伝えていく。ライト、ついてますか　問題発見の人間学作者:ドナルド・C・ゴース,ジェラルド・M・ワインバーグ共立出版Amazon情報と知識の違いここで、大切な区別をしておきたい。情報と知識は、似ているようで本質的に違う。情報は客観的で、文脈から独立している。誰が読んでも同じ意味を持つし、データベースに保存できる。APIドキュメント、エラーコード、統計データ——これらはすべて情報だ。一方、知識は主観的だ。文脈に根ざし、経験と結びついている。人によって解釈が変わるし、言語化しきれない部分を含む。例えば次のようなものだ。「Kubernetesはコンテナオーケストレーションツールだ」→これは情報「このチームには、今、Kubernetesは早すぎる」→これは知識生成AIが提供するのは情報だ。知識ではない——この違いを理解することが、AI時代の専門家には不可欠になる。AIは膨大な情報を学習し、流暢に語る。だから人々は錯覚する。「AIは専門家と同じだ」と。しかし違う。情報は「何ができるか」を教える。知識は「何をすべきか」を判断する。情報は選択肢を並べる。知識は、その中から選ぶ。そして、この「選ぶ」という行為には、文脈が必要だ。知識創造企業（新装版）作者:野中 郁次郎,竹内 弘高東洋経済新報社Amazon形式知と暗黙知形式知というのは、言葉や数字で表現できる知識のことだ。マニュアル、ドキュメント、コード、データベース。これらは伝達可能で、複製可能で、検索可能だ。そして、生成AIが扱えるのは、この形式知だけだ。AIは形式知の処理において、優れた能力を発揮する。膨大なドキュメントを瞬時に検索し、パターンを見つけ、整理して提示する。これは人間には不可能な速度と規模だ。しかし、暗黙知は違う。暗黙知は身体に染み込んだ経験、言葉にできない直感、状況を読む感覚、「なんとなくわかる」という知恵だ。ベテランエンジニアが一目でバグの箇所を見抜く。経験豊富なコンサルタントが会議の空気から組織の病を感じ取る。熟練の職人が手の感触で材料の状態を判断する。これらは言語化しきれない。だから、AIには学習が難しい。誤解しないでほしい。AIを否定したいわけではない。限界を理解し、適切に使う——それが肝心なのだ。AIは優れた道具だ。形式知の処理においては、人間を遥かに凌駕する。しかし、暗黙知を必要とする判断——文脈を読むこと、人間の感情を理解すること、責任を取ること——これらは人間の仕事として残る。ワイズカンパニー―知識創造から知識実践への新しいモデル作者:野中 郁次郎,竹内 弘高東洋経済新報社Amazon専門家の新たな役割専門家の戦場は変わった。生成AIが誰にでも「整った回答」を提供するようになり、私たちは新しい役割を担うことになった。それは、理論と現実の橋渡しをすることだ。実を言うと、この役割は新しいものではない。私たちは生成AIと戦う前に、ベンダーが出している「ベストプラクティス」と戦っていた。AWSのホワイトペーパー、Microsoftのリファレンスアーキテクチャ、Googleの推奨構成——それらはすべて美しく、説得力があった。そして、現実のプロジェクトでは、ほとんど機能しなかった。なぜか？ベンダーのベストプラクティスは、理想的な環境を前提としている。無限のリソース、高度なスキルを持つチーム、完璧に構造化されたデータ、明確な要件。しかし現実は違う。レガシーシステム、限られた予算、混在したスキルレベル、曖昧な要件、政治的な制約。私たちは毎日、クライアントにこう説明していた。「AWSのホワイトペーパーではマイクロサービスを推奨していますが、御社の組織構造では機能しません」「Microsoftのベストプラクティスでは3層アーキテクチャですが、御社のデータ量ではオーバーキルです」「Googleの推奨構成はスケーラブルですが、御社のトラフィックではコストが見合いません」ベンダーは製品を売りたい。だから理想的なケースを示す。技術的には正しい。しかしあなたの会社に合うかは別問題だ。そして今、生成AIがこの問題を10倍に増幅した。生成AIは、ベンダーのベストプラクティスを学習している。AWS、Microsoft、Google、そして無数の技術ブログ。すべての「推奨構成」を吸収し、完璧に整理して提示する。しかし相変わらず、文脈は無視される。組織の制約、チームのスキル、政治的な現実、予算の限界——これらすべてが、美しい提案の裏に隠される。専門家の新たな役割は、文脈の翻訳者になることだ。AIが提案する理論を、クライアントの現実に落とし込む。「技術的に可能なこと」と「今やるべきこと」を見極める。綺麗な提案書を、実際に動くプランに変換する——それが私たちの仕事だ。これはAIを否定することではない。AIは優れた出発点を提供してくれる。しかし、それを実際に使えるものにするには、人間の判断が必要だ。ワインバーグ氏はクライアントにこう告げることを勧めた。「それはできますよ。で、それにはこれだけかかります」と。価値を明確にし、コストを示す。曖昧さを排除する誠実さ。生成AIは、この誠実さを持たない。「できます」とだけ言って、そのために何が犠牲になるかを語らない。実装の困難さ、組織の抵抗、予期せぬ副作用——それらは美しい提案書の裏側に隠れる。だからこそ、専門家の役割が重要になる。「この提案を実現するには、組織を変え、人々の習慣を変え、場合によっては失敗を受け入れる覚悟が必要です」と語ること。説得コストは増大したが、それが専門家の仕事だ。syu-m-5151.hatenablog.com確実性という麻薬と疑う力人間は確実性という麻薬に弱い。迷わない声、ためらわない答え、保留しない判断。生成AIはこの依存症を加速させる。正しいから信じるのではない。確信に満ちているから、疑う苦痛から逃れられるから信じる。ある後輩エンジニアがこう言った。「このバグの原因、生成AIに聞いたら5秒でわかりました」「ほう、何だった？」「メモリリークだって」「確認した？」「いや、でもAIがそう言ってるし...」プロファイラーで調べたら、全然違った。単純なロジックバグだった。でも彼は、疑わなかった。確信に満ちた声に、安心したかったから。人類は思考の外注化を始めた。そして気づいていない。ワインバーグ氏は「何か違うことをするように勧めるのがよい」と言った。これまでのやり方で問題が解決しなかったなら、何か新しいことを試すべきだと。しかしここに罠がある。生成AIは常に「何か新しいこと」を提案してくれる。しかしそれは本当に新しいのだろうか？　それとも、同じ失敗を美しく言い換えただけなのだろうか？生成AIが答えを量産する時代、人間に残された最後の砦は疑う力だ。しかし皮肉なことに、疑うことは苦痛で、信じることは快楽だ。情報が無料になった世界で、判断力だけが希少になる。そしてその希少性に、人類の大半は気づいていない。危険だからこそ知っておくべきカルトマーケティング作者:雨宮純ぱる出版Amazon執着を手放し、当事者意識を問うワインバーグ氏は鋭く指摘した。「何かを失うための最良の方法は、それを離すまいともがくことだ」と。生成AI時代の専門家は、過去の専門性への執着を手放さねばならない。かつて専門家の価値は「知っていること」にあった。しかし今や、AIは膨大な知識を瞬時に提供する。だからこそ、私たちは新たな価値を見出していく。それは「判断すること」だ。「文脈を読むこと」だ。「人間の感情を理解すること」だ。そして何より、当事者意識を持つことだ。ワインバーグ氏は問うた。「あなたはそのシステムに、自分の命をあずける気がありますか」と。生成AI時代、私たちは同じ問いを投げかけねばならない。「AIが提案したこの解決策で、あなた自身の人生を賭けられますか」と。「この戦略で、あなたの会社の未来を託せますか」と。「この診断で、あなたの家族を治療できますか」と。当事者意識のないアドバイスは、どれだけ論理的でも無価値だ。生成AIには当事者意識がない。それは決定的な限界だ。自ら顧客と話す——これが当事者意識だ。データを見るだけではない。レポートを読むだけではない。実際に現場に行き、顧客と対話し、痛みを感じる。専門家も同じだ。提案書を書くだけではない。コードレビューで指摘するだけではない。自分でコードを書き、自分でデプロイし、自分がオンコール対応する。その覚悟を持つ。身銭を切れ――「リスクを生きる」人だけが知っている人生の本質作者:ナシーム・ニコラス・タレブダイヤモンド社Amazonノーと言える勇気ワインバーグ氏は警告した。「依頼主に対してノーというのを恐れるようになったとき、人はコンサルタントとしての有効性を失う」と。生成AIはノーと言わない。それは常にイエスだ。どんな要求にも応え、どんな質問にも答える。しかしそれは誠実さではない。それは無責任だ。専門家の最後の矜持は、ノーと言える勇気にある。「それは実現不可能です」「そのアプローチは間違っています」「今はそれをすべき時ではありません」——こうした言葉を発する勇気。あるクライアントがこう言った。「Kubernetesに移行したい。生成AIが推奨している」私は答えた。「Kubernetesは素晴らしい技術です。でも、まず確認させてください。今のトラフィックはどれくらいですか？」「日に1000リクエストくらいです」「なるほど。運用チームは何人ですか？」「2人です」「わかりました。Kubernetesは確かにスケーラブルで、業界標準の技術です。ただ、御社の現状を考えると、別のアプローチをお勧めします。理由はいくつかあります。まず、今のトラフィックならEC2 1台で十分対応できます。Kubernetesの真価は、大規模なトラフィックや複雑なマイクロサービス構成で発揮されます。それから、Kubernetesの運用には専門知識が必要です。ネットワーキング、オーケストレーション、監視——2人のチームでこれを担うのは、正直に言って負担が大きすぎます。夜間対応や障害時のトラブルシューティングも考えると、チームが疲弊するリスクがあります。そして——これが一番大事なのですが——AIはオンコールに入りません。問題が起きた時、午前3時に対応するのは人間です。提案があります。コンテナの運用経験を積みたいなら、ECSやCloud Runはどうでしょう？　これらには次のような利点があります。- Kubernetesより運用がシンプル- 履歴書にも『コンテナ技術、AWS/GCP』と書ける- 今のチーム規模で無理なく運用できる- 将来、本当にKubernetesが必要になった時の良いステップになるまず小さく始めて、本当に必要になったら次のステップに進む。それが賢明だと思います」クライアントは少し考えてから言った。「確かに、その方が現実的ですね。ECSで始めましょう」生成AIの前で、専門性という砦は崩れ始めている。人間は権威を求めながら、権威を疑う。医師より検索を、教師よりAIを信じる矛盾。それは専門家への不信ではない。即座に、簡潔に、都合よく答えてくれる存在への、人間の根源的な渇望なのだ。だからこそ、専門家は安易なイエスを拒否しなければならない。人間の欲望に迎合するAIに対抗できるのは、不都合な真実を語る勇気を持った人間だけだ。Noを伝える技術 プロダクトマネージャーが教える「敵を作らずに断れるようになる」作法作者:飯沼 亜紀翔泳社Amazon社内政治の教科書作者:高城 幸司ダイヤモンド社Amazon顧客と話すことの価値AI時代において、開発速度のアドバンテージは急速に失われつつある。大企業もスタートアップも、同じように早く作れるようになる。では何が差別化要因になるのか？「顧客が本当に欲しいものがなにかを考え、作るものを決めること」これは形式知ではない。暗黙知だ。顧客と直接話し、表情を読み、言葉の裏を感じ取る。データには現れない不満や欲望を掴み取る。生成AIは顧客と話せない。画面の向こうで、クライアントが微妙な表情を浮かべた瞬間——そういう人間的な感覚は、AIには再現できない。だからこそ、専門家は現場に足を運ぶことが大切だ。データやレポートだけでは見えないものがある。実際に顧客と会い、話し、観察することで見えてくるものがある。私は意識的に、稼働時間のかなりの部分を顧客との対話に使うようにしている。これは時間の無駄ではなく、最も重要な投資だと考えている。データを眺めるだけでなく、実際に現場に行き、顧客と対話し、痛みを共に感じる。提案書を書くだけでなく、実際に顧客のオフィスを訪れ、彼らの仕事を観察し、つまずいている箇所を見つける。ある日、私はあるスタートアップのオフィスを訪れた。社員20人。全員が一つの部屋で働いている。私は提案書を持っていた。「マイクロサービスアーキテクチャへの移行プラン」。技術的には申し分のない、美しい提案書だった。しかし、オフィスに入った瞬間、気づいた。ホワイトボードには、明日のリリース予定が書かれている。付箋だらけのカンバンボード。誰かが「バグ修正、あと3つ！」と叫んでいる。CTOは疲れた顔で、3つのタブを同時に見ている。この会社に、今マイクロサービスは必要ない。「提案書はいったん脇に置きましょう」と私は言った。「今日はただ、お話を聞かせてください。何に一番困っていますか？」3時間後、私たちは全く違う提案にたどり着いた。マイクロサービスではなく、モノリスのままで、デプロイパイプラインを改善すること。テストの自動化。監視の強化。地味だが、彼らが本当に必要としていたこと。これが、AIにはできないことだ。空気を読むこと。文脈を理解すること。そして時には、準備してきた提案を手放す柔軟性を持つこと。捨てる力作者:羽生 善治PHP研究所Amazon幻想の終わりと新たな始まりワインバーグ氏は言った。「それは危機のように見えるかもしれないが、実は幻想の終わりにすぎない」と。生成AI時代における専門性の危機もまた、幻想の終わりだ。専門家が万能であり、専門知識があれば無条件に尊重されるという幻想。情報の非対称性が専門家の地位を保証するという幻想。しかし幻想の終わりは、新たな始まりでもある。専門家は今、本質に立ち返らねばならない。ワインバーグ氏が見出した「非合理性に対して合理的になる」第三の道は、生成AI時代においてこう読み替えられる。確実性の幻想に対して、不確実性の価値を語ること。形式知の活用と、暗黙知の価値を両立すること——それが生成AI時代の「第三の道」だ。生成AIが確実性の幻想を振りまく時代に、専門家は不確実性と共に生きる知恵を伝える。納得いく答えなどないこと、現実は常に複雑であること、判断には責任が伴うこと——これらの不都合な真実を語り続けること。ネガティブ・ケイパビリティ　答えの出ない事態に耐える力 (朝日選書)作者:帚木　蓬生朝日新聞出版Amazon人間に残された仕事生成AIがもたらしたのは知識の民主化ではない。判断の民主化への錯覚だ。誰もが専門家のように語れる時代。しかし語ることと、責任を取ることは違う。ワインバーグ氏は、自己不信に陥った時の兆候として「怒り」を挙げた。「自分はもう駄目だ」という感情が怒りとなって現れると。多くの専門家が今、この怒りを感じているだろう。AIに仕事を奪われる恐怖。自分の専門性が無価値になる不安。しかし、それは活力の枯渇ではない。むしろ、新たな段階への移行期だ。人間に残された仕事は、答えを出すことではない。問いを立てることだ。「この答えは誰のためのものか」「誰が利益を得て、誰が犠牲になるか」——短期的な成功と長期的な持続可能性をどうバランスさせるか。データには現れない人間の感情を、どう汲み取るか。こうした問いに向き合うことが、AIにはできない人間の役割だ。生成AIは問いに答える。しかし問いを立てることはできない。少なくとも、血の通った、現実に根ざした、倫理的な重みを持った問いを。増補改訂版 スマホ時代の哲学 なぜ不安や退屈をスマホで埋めてしまうのか (ディスカヴァー携書)作者:谷川嘉浩ディスカヴァー・トゥエンティワンAmazon新たなコンサルタントの秘密ワインバーグ氏の『コンサルタントの秘密』が教えてくれたのは、テクニックではなく姿勢だった。「影響を及ぼす術」とは、人間の非合理性を理解し、それでも諦めずに、しかし執着せずに、真実を語り続けることだった。生成AI時代の新たなコンサルタントの秘密は、これに新しい層を加える(勝手に)。秘密その一：整った答えより、正直な不確実性を語れAIは整った答えを装う。あなたは不完全でも正直な答えを語れ。「わからない」と言える勇気を持て。その誠実さが、AIには決して真似できない信頼を生む。避けるべき例「この設計は業界標準のベストプラクティスに沿っており、問題ありません」推奨する例「理論的には堅牢です。でも、私には3つの懸念があります。1つ目、あなたの会社のトラフィックパターンを、私はまだ十分に理解していません。ピーク時の挙動が読めない。2つ目、似た構成で、予期せぬボトルネックが発生した事例を2件知っています。一つはRedisのメモリ不足、もう一つはサービス間の循環依存。あなたの設計にも同じ罠が潜んでいるかもしれません。3つ目、このサービスメッシュを運用するには、少なくとも3人のSREが必要です。今、あなたの会社には何人いますか？提案です。まず1週間、本番トラフィックを一緒に観察させてください。それから、小さく始めましょう。全部を一度に移行するのではなく、1つのサービスだけマイクロサービス化して、3ヶ月運用してみる。うまくいったら広げる。失敗したら、素直にモノリスに戻る。それでどうでしょう？」秘密その二：説得ではなく、対話を選べ説得コストが爆発した時代に、説得で勝とうとするな。代わりに対話せよ。相手の不安を理解し、欲望を認め、その上で「それでも」と語れ。ワインバーグ氏の言う「非合理性への合理的対処」だ。説得アプローチ（避けるべき）：クライアントが間違った決定をしようとする → データを見せて説得する → 論破する → 反発される → 関係が悪化対話アプローチ（推奨）：クライアントが間違った決定をしようとする → なぜそう思うのか聞く → 彼らの不安を理解する → 一緒に小さく試してみる → データを見せる → 一緒に次を決める例：「なぜマイクロサービスにしたいんですか？」「スケーラブルだから」「確かに。他に理由はありますか？」「...正直に言うと、履歴書に書きたいんです。今の技術スタック、10年前のままで」「それは正当な理由です。技術的な成長は大事ですよね。でも、マイクロサービスじゃなくても履歴書に書ける技術はあります。例えば、今のRails on EC2を、コンテナ化してECS on Fargateに移行するのはどうでしょう？　運用負荷は今と大きく変わらず、でも『AWS、Docker、Infrastructure as Code』が履歴書に書けます。それに、将来本当にマイクロサービスが必要になった時の良い準備にもなります」「...それいいですね。その方が現実的かもしれません」説得ではなく、対話。論破ではなく、理解。相手のニーズを認めた上で、より良い道を一緒に見つける。それが、確実性を求める人間と、不確実性を語る専門家の、橋渡しになる。秘密その三：当事者意識を持ち、ノーと言えAIは責任を取らない。だから、あなたが責任を取れ。自分の命を賭けられない提案はするな。クライアントの要求にノーと言える経済的・心理的余裕を確保せよ。それが専門家としての最後の砦だ。ただし、ノーと言うことは、拒否することではない。それは、より良い道を示すことだ。エンジニアとして、次の問いを毎日自分に投げかけよう。このコード、自分の会社の本番環境にデプロイできるか？この設計、自分がオンコール対応する気になれるか？このアーキテクチャ、3年後も自分がメンテしたいと思えるか？答えがNoなら、クライアントにも勧めるな。しかし、そこで終わらせるな。代わりに、現実的で実行可能な代案を示せ。AIはオンコールに入らない——問題が起きた時、午前3時に対応するのは人間だ。だからこそ、人間が運用できる技術を選ぶべきだ。秘密その四：問題の連鎖を受け入れよ一つの答えがすべてを解決するという幻想を捨てよ。問題は連鎖する。第一の問題を解決すれば第二が現れる。それが現実だ。クライアントにその現実を伝え、継続的な関与の価値を示せ。正直な説明の例：「今回、このパフォーマンス問題を解決します。でも、解決した瞬間、次の課題が見えてくるでしょう。おそらく、セキュリティです。なぜなら、速くなると、今度はアクセス制御の重要性が増すからです。その次は、モニタリングです。複雑になったシステムを、今の監視体制では追いきれなくなります。その次は、チームのスキルです。新しいアーキテクチャを理解し、運用できる人材の育成が必要になります。つまり、これは終わりのない旅です。1回の契約で全てが完璧になることはありません。でもそれでいいんです。それが健全なソフトウェア開発です。私たちは一緒に、一つずつ、着実に改善していきます。その過程で、御社のチームも成長し、システムも進化します。それが本当の価値だと思います」この正直さが、長期的な信頼を生む。AIは「これで全て解決します」と言う。それは嘘だ。私たちは「これは始まりです。一緒に継続的に改善しましょう」と言う。それが真実だ。秘密その五：執着を手放し、学び続けよ過去の専門性に執着するな。それを守ろうともがくほど失う。代わりに新しいことを学べ。ワインバーグ氏が勧めたように、仕事から離れ、リフレッシュし、また戻ってこい。変化を恐れるな。生成AI時代、過去の専門性への執着は死を意味する。AIは知識を民主化した。「Railsに詳しい」だけでは価値がない。価値があるのは次のような能力だ。- 複数の技術スタックの経験を組み合わせて判断できること- 何を選ぶか以上に、何を選ばないかを判断できること- 技術的な正しさと、組織的な実行可能性を両立できることそして、常に学び続けること。賢く、実行できる人材が求められてきた。AI時代は、学び続け、すべてを疑問視できる人材が必要だ。秘密その六：顧客と直接話し続けよデータを見るな、とは言わない。しかし、データだけを見るな。私は意識的に、稼働時間のかなりの部分を顧客との対話に使うようにしている。これは専門家として必須の投資だと考えている。週に一度は、クライアントのオフィスに行け。Zoomではなく、対面で。会議室ではなく、彼らの職場で。作業している様子を見ろ。どこでつまずいているか、観察しろ。顧客が言葉にできない不満を、表情から読み取れ。データには現れない痛みを、感じ取れ。これが、AIには決してできないことだ。疑う力という最後の砦情報が無料になった世界で、判断力だけが希少になる。そしてその判断力の核心にあるのが、疑う力だ。しかし疑うことは苦痛だ。信じることは快楽だ。だからこそ危うい。専門家の新たな役割は、人々に疑う力を与えることだ。批判的思考を教えることだ。「この答えは本当か」「誰がこれを言っているのか」「何が隠されているのか」——こうした問いを立てる習慣を育てること。生成AIは、人間の弱点を完璧に突く。私たちは正しさより、正しく聞こえるものを選ぶ。不確実な真実より、確実に聞こえる誤りを好む。人間は答えが欲しいのではない。自分の直感や願望に、科学や論理という権威の衣を着せてくれる声が欲しいだけなのだ。そしてAIは、私たちのバイアスを見抜き、強化する。プロンプトに「〜という前提で」と書けば、その前提に沿った答えが返ってくる。反対意見を見たくなければ、見なくていい。エコーチェンバーは、もはや環境ではない。それは私たちが能動的に構築するものになった。だからこそ、疑う力が必要だ。そしてそれを教えられるのは、同じ人間だけだ。物語化批判の哲学　〈わたしの人生〉を遊びなおすために (講談社現代新書)作者:難波優輝講談社Amazon疑う力を鍛える3つの習慣1. 「なぜ？」を3回繰り返すAI：「このアーキテクチャを推奨します」トラフィックが増えた時に対応できます」トラフィックが増えると思う？　このサービス、過去3年でユーザー数は横ばいだけど？」2. 「動くコード」を「壊れないコード」に変える儀式AI生成コードを受け取ったら、必ずこれをチェック：user が None だったら？stripe.charge が失敗したら？db.save_payment が失敗したら？（チャージは成功しているのに記録されない）amount が負の数だったら？同じリクエストが2回来たら？（冪等性）このトランザクションのログは？監視メトリクスは？このエラー、どうやってサポートが追跡する？AIは「ハッピーパス」しか考えない。私たちは「全ての地獄」を想定する。3. 「一緒に失敗した」仲間を持つ一人で疑い続けるのは辛い。週に1回、同じ課題に取り組む仲間と「今週のAI失敗談」を共有せよ。「生成AIが作ったSQLインジェクション脆弱性」「AIが推奨した、メモリリークするコード」「生成AIが作った、誰も読めない抽象化」笑い話にすることで、疑う力を保つ。孤独に疑うのは発狂への道。仲間と疑うのは、知恵への道。AIが教えてくれない、運用の地獄Joel Spolskyの有名な言葉がある。「動くコードと、出荷できるコードは違う」。AIが出すコードは「動く」。でも「出荷できる」か？More Joel on Software作者:Joel Spolsky翔泳社Amazonケーススタディ：「理想的な」API設計の崩壊ECサイトのAPI設計。Claude Sonnet 4.5に依頼。出てきた設計は美しかった。リソース指向、HTTPメソッドの仕様準拠の使用、ステータスコードの正しい使い分け、OpenAPI仕様書付き。クライアントは感動した。開発は順調に進んだ。本番リリースの1週間後、サポートチームから悲鳴が上がった。「エラーメッセージが全部英語で、ユーザーが理解できない」AIは仕様に沿ったHTTPステータスコードを返していた。400 Bad Request、422 Unprocessable Entity、409 Conflict...でも、日本のECサイトのユーザーは、それを理解できない。追加しなければならなかったものは次の通りだ。日本語のエラーメッセージエラーコード（サポートが参照できる）エラーの原因と対処法のドキュメントサポートチーム向けのトラブルシューティングガイドAIは技術的に正しいものを作る。でも、使えるものを作るには、人間が必要だ。おわりにワインバーグ氏はコンサルタントの仕事を「人々に、彼らの要請に基づいて影響を及ぼす術」と定義した。40年が経った今、彼の洞察は色褪せるどころか、むしろ新たな意味を帯びている。生成AIという新しい存在が現れた今、私たちはワインバーグ氏の知恵をさらに一歩先へ進める必要がある。「人々に、彼らの要請に基づいて、彼らが本当に必要とする問いを見出す術」ワインバーグ氏が戦った相手は人間の非合理性だった。私たちが向き合うのは、それに加えて、確実性という幻想を振りまく生成AIだ。クライアントは答えを求める。AIは答えを与える。しかし本当に必要なのは、自ら問いを立て、判断し、責任を取る力だ。彼は「何かを失うための最良の方法は、それを離すまいともがくことだ」と教えた。私たちは今、知識への執着を手放す時だ。専門家の価値は「知っていること」から「判断できること」へ移行した。情報を所有することではなく、文脈を読み解くこと。完璧な答えを用意することではなく、正直に不確実性を語ること。彼は「依頼主に対してノーというのを恐れるようになったとき、人はコンサルタントとしての有効性を失う」と警告した。生成AIはノーと言わない。常にイエスだ。だからこそ、私たちはノーと言わねばならない。「それは実現できません」「今はその時ではありません」「別のアプローチをお勧めします」——この誠実さこそが、人間にしかできないことだ。彼は「あなたはそのシステムに、自分の命をあずける気がありますか」と問うた。私たちも問わねばならない。「AIが提案したこの解決策で、あなた自身の人生を賭けられますか」と。当事者意識のないアドバイスは無価値だ。AIには当事者意識がない。それは決定的な限界だ。ワインバーグ氏が発見した第三の道——非合理性に対して合理的になること——は、生成AI時代においてこう進化する。確実性の幻想に対して、不確実性と共に生きる勇気を示すこと形式知を使いこなしながら、暗黙知の価値を守ることAIの能力を認めつつ、人間としての責任を背負うことこれが、生成AI時代に必要なコンサルタントの秘密だ。ワインバーグ氏は40年前、人間の非合理性という複雑な問題に立ち向かうための知恵を残した。今、私たちはその知恵を土台として、さらに複雑な世界——人間の非合理性と、機械の見かけ上の合理性が交錯する世界——を生きねばならない。答えは美しい。しかし現実は泥にまみれている。その泥の中で、それでも前に進もうとする人々に寄り添い、時には厳しく、時には優しく、しかし常に誠実に——それが専門家の、人間の、仕事だ。午前5時、本番環境が復旧した。Slackに報告を書く。原因、対応、再発防止策。チームに共有する。プロセスを改善する。これが、人間の仕事だ。失敗から学び、次に活かすこと。生成AIは優れた相棒だ。しかし、責任を取るのは人間だ。判断するのは人間だ。そして、その判断に誇りを持つのも、人間だ。ワインバーグ氏が築いた基盤の上に、私たちは新しい時代の専門性を構築する。彼の知恵は古びない。むしろ、新しい挑戦の中でこそ、その真価を発揮する。それが、専門家の価値だと思う。再解釈生成AI時代の道具箱編も要望があれば書いていきたいです。コンサルタントの道具箱作者:ジェラルド・M・ワインバーグ日経BPAmazon","isoDate":"2025-10-08T00:17:49.000Z","dateMiliSeconds":1759882669000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"システム思考を使う人が知っておいてよい12のシステムアーキタイプ","link":"https://syu-m-5151.hatenablog.com/entry/2025/10/06/074220","contentSnippet":"syu-m-5151.hatenablog.comsyu-m-5151.hatenablog.comはじめに正直に言いましょう。システム思考の理論を学んだとき、あなたはこう思いませんでしたか？「で、これをどう使うの?」前回と前々回の記事で、非線形性、フィードバックループ、氷山モデルを学びました。理論は美しく、説得力がありました。でも、実際の仕事に戻ると、こんな疑問が湧いてきます。「このぐちゃぐちゃな状況を、どう分析すればいいんだ?」「フィードバックループを見つけろって言われても、どこから探せばいいの?」「複雑すぎて、何が何だかわからない」そうですよね。私も同じでした。システム思考は強力なツールです。しかし、白いキャンバスの前に立たされて「さあ、目の前の構造システムとして分析してください」と言われても、最初の一筆をどこに置けばいいのか、途方に暮れてしまいます。でも、もし誰かがこう言ってくれたらどうでしょう。「その問題、見覚えがあります。実は、これは『問題の転嫁』という典型的なパターンなんです。こことここを見てください。ほら、この構造が見えますか? じゃあ、ここに介入すると効果的ですよ」突然、霧が晴れたように、問題の構造が見えてきます。これが、システムアーキタイプの力です。あなたが今日困っている問題—バグの再発、スケジュールの遅延、チームの対立、技術的負債の増大—これらの多くは、実は過去に何度も繰り返されてきた典型的なパターンなのです。新しい問題に見えても、その骨格は既知なのです。システムアーキタイプは、問題のパターン認識ツールです。12の主要なパターンを理解すれば、複雑に見える問題が「ああ、これはあのパターンだ」と認識できるようになります。診断ができれば、処方箋も見えてきます。この記事では、12のアーキタイプすべてを詳しく解説します。抽象的な図表だけではありません。各パターンについてどんな構造なのかなぜそのパターンが生まれるのかどんな具体例があるのか（特にソフトウェア開発の文脈で）よくある誤解や批判にどう答えるかどこに介入すれば効果的なのかすべてを、実践的な知識として提供します。学習曲線は存在します。12のパターンすべてを一度に覚える必要はありません。まずは1つか2つ、自分の問題に近いものから始めてください。「問題の転嫁」と「成長の限界」だけでも、驚くほど多くの問題が説明できることに気づくでしょう。準備はいいですか? では、パターンの世界へ。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。はじめにシステムアーキタイプとはアーキタイプ:繰り返される構造の型研究の系譜と多様な分類なぜアーキタイプを学ぶのか図の重要性—そして、この記事の限界アーキタイプの構造的特徴12のシステムアーキタイプ1. 好循環/悪循環—成功と失敗の自己強化2. バランス型プロセスと遅延—調整の失敗3. うまくいかない解決策—短期的成功の罠問題の転嫁と成長の限界—2大重要パターン4. 問題のすり替わり—根本解決の機会損失5. 成長の限界—自らを制限する構造利害関係者の相互作用—競争と協力のダイナミクス6. 強者はますます強く—資源配分の不均衡7. 予期せぬ敵対関係—協力者が敵になる罠8. 共有地の悲劇—個人合理性と集団非合理性目標管理の失敗—期待と現実のギャップ9. バラバラの目標—対立する複数の目標10. 目標のなし崩し—徐々に下がる基準競争のダイナミクス—エスカレートの構造11. エスカレート—報復の応酬長期的成長の失敗—投資不足の罠12. 成長と投資不足—自らが生み出す限界アーキタイプを見抜く技術おわりにシステムアーキタイプとはアーキタイプ:繰り返される構造の型「アーキタイプ(archetype)」とは、「原型」という意味です。システムアーキタイプは、様々なシステムに繰り返し現れる、問題の構造的パターンの原型です。用語についてを少し説明しておきます。日本では「システム原型」という訳語の方が一般的に使われています。しかし、この記事では「システムアーキタイプ」という表現を使います。特にソフトウェアエンジニアにとっては、ソフトウェアアーキテクチャ、システムアーキテクチャといった「アーキテクチャ」という用語が馴染み深いため、「アーキタイプ」という言葉は直感的に理解しやすいでしょう。一方で、エンジニア以外の読者にとっては「原型」という日本語の方がイメージしやすいかもしれません。この記事ではエンジニアに限定せず幅広い読者を想定しているため、両方の観点から「アーキタイプ」という表現を採用しています。もし関連情報をウェブで検索する際は、「システム原型」で調べると、より多くの日本語資料が見つかるでしょう。aws.amazon.comcloud.google.comlearn.microsoft.com研究の系譜と多様な分類システムアーキタイプの概念は、数十年にわたる研究の蓄積の上に成り立っています。1960年代から1970年代にかけて、システムダイナミクスの創始者であるジェイ・フォレスター(Jay Forrester)がMITで始めた研究が源流です。彼とその教え子たち—デニス・メドウズ(Dennis Meadows)、ドネラ・メドウズ(Donella Meadows)ら—は、様々なシステムに繰り返し現れる構造パターンを観察し始めました。これが、後にシステムアーキタイプと呼ばれるものの萌芽でした。1980年代に入ると、マイケル・グッドマン(Michael Goodman)、チャールズ・キーファー(Charles Kiefer)、ジェニー・ケメニー(Jenny Kemeny)、そしてピーター・センゲ(Peter Senge)らが、ジョン・スターマン(John Sterman)の研究ノートも参考にしながら、これらのパターンを体系化していきました。彼らはこれを「システムテンプレート」として文書化し、実務での応用を試みました。そして1990年、ピーター・センゲが著書『学習する組織(The Fifth Discipline)』を出版しました。この本で、組織が陥りやすい典型的なシステムパターンが「システムアーキタイプ」として一般に紹介されたのです。センゲは、MITスローン経営大学院でシステム思考を研究し、組織学習の分野に大きな影響を与えました。学習する組織 ― システム思考で未来を創造する作者:ピーター・Ｍ・センゲ英治出版Amazon一方、ドネラ・メドウズは、システムダイナミクスの先駆者として、自然界から社会システムまで、あらゆる領域に現れる構造パターンを分析し続けました。彼女は著書『世界はシステムで動く(Thinking in Systems)』(2008年、彼女の死後出版)の第5章で、これらのパターンを「システムの罠(System Traps)」と呼びました。世界はシステムで動く ― いま起きていることの本質をつかむ考え方作者:ドネラ・Ｈ・メドウズ英治出版Amazonセンゲとメドウズ、二人のアプローチには興味深い違いがあります。センゲは「アーキタイプ」という用語で、繰り返し現れる構造パターンそのものに焦点を当てました。一方、メドウズは「罠(Trap)」という用語で、私たちがシステムの特性を十分に理解していないために陥る典型的な落とし穴として、より実践的・警告的な視点から紹介しました。罠という表現には、「気づかないうちにはまってしまう」「一度はまると抜け出しにくい」というニュアンスがあり、システムが生み出す問題の粘着性を強調しています。本質的には同じ現象を、異なる視点から捉えているのです。興味深いことに、研究者や文献によって、アーキタイプの数や分類は異なります。ピーター・センゲの『The Fifth Discipline』では付録に9〜10のアーキタイプが記載されています。デイヴィッド・ストローの『社会変革のためのシステム思考実践ガイド』では12のアーキタイプが詳述されています。その他の文献では8個のアーキタイプを扱うものや、研究者独自の分類を提示するものもあります。社会変革のためのシステム思考実践ガイド――共に解決策を見出し、コレクティブ・インパクトを創造する作者:デイヴィッド ピーター ストロー英治出版Amazonこの多様性は、システムアーキタイプが厳密な分類体系ではなく、実践的な診断ツールであることを示しています。重要なのは「何個あるか」ではなく、「自分が直面している問題がどのパターンに似ているか」を認識し、効果的な介入ポイントを見つけることです。彼らの研究が示したのは、問題の表面的な内容は異なっても、その背後にある構造は共通しているという洞察です。なぜアーキタイプを学ぶのか「また同じ問題が起きた」「なぜいつもこうなるんだ」——そう感じたことはありませんか?実は、私たちが日々直面する問題の多くは、過去に何度も繰り返されてきた典型的なパターンなのです。表面的には異なって見えても、深い構造は驚くほど似ています。システムアーキタイプは、この繰り返されるパターンを体系化したものです。システムアーキタイプを学ぶことには、5つの重要な価値があります。まず、問題認識の高速化です。一度アーキタイプを理解すれば、新しい問題に直面したとき、「これは○○のパターンだ」と素早く認識できます。ゼロから構造分析を始める必要はありません。優秀なシニアエンジニアがスタックトレースから根本原因を即座に見抜けるように、問題のパターンから構造を診断できるようになります。経験豊富なエンジニアが「このバグの出方、以前見たパターンに似ている」と気づくのと同じです。次に、先を読む能力が身につきます。アーキタイプには、予測可能な展開があります。「このパターンなら、次にこうなる」という先読みができるのです。例えば、「問題の転嫁」のパターンを認識したなら、症状対処への依存が強まり、やがて根本対処の能力が失われ、最終的にはシステムが崩壊することが予測できます。問題が深刻化する前に、早期に介入できるのです。さらに、効果的な介入ポイントの特定が可能になります。各アーキタイプには、効果的な介入ポイントが知られています。過去数十年にわたり、多くの組織で試行錯誤されてきた解決策を活用できます。これは車輪の再発明を避けることを意味します。ピーター・センゲ、ドネラ・メドウズ、デイヴィッド・ストローといった先駆者たちが発見した知恵を、そのまま使えるのです。アーキタイプは、チーム内で問題を議論するための共通言語にもなります。「これは成長の限界のパターンだ」「共有地の悲劇が起きている」と言えば、複雑な構造を説明するのに長々とした説明は不要です。「エスカレートのループに入っている」と言えば、構造を理解している人には即座に伝わります。この共通言語が、建設的な対話を可能にします。そして最も深い価値は、見方そのものが変わることです。アーキタイプを学ぶことで、「誰が悪いのか」ではなく「どんな構造がこの問題を生み出しているのか」と考えるようになります。個人を責めるのではなく、システムを変える。この視点の転換こそが、システム思考の真髄であり、アーキタイプ学習の最大の成果なのです。図の重要性—そして、この記事の限界ここで正直に告白します。システムアーキタイプをちゃんと理解するには、図(ループ図)が不可欠です。各アーキタイプは、強化ループ(R)とバランスループ(B)の組み合わせで表現されます。これらのループが互いにどう影響し合い、時間遅れがどこに存在し、どこに介入すれば効果的かは、図を見ることで直感的に理解できます。ただ、この記事では図を掲載していません。テキストだけでは限界があることを認めざるを得ません。だからこそ、強くお勧めします。デイヴィッド・ストローの『社会変革のためのシステム思考実践ガイド』を読んでください。この書籍には、12のシステムアーキタイプすべてについて、明確なループ図と豊富な実例が掲載されています。社会変革という文脈で書かれていますが、その洞察はソフトウェア開発にも直接応用できます。ピーター・センゲの『学習する組織』、ドネラ・メドウズの『世界はシステムで動く』も素晴らしい資料です。図とともに学ぶことで、この記事で説明する概念が、立体的に理解できるようになります。この記事は、アーキタイプへの入り口に過ぎません。真の理解は、図を見て、実践して、自分の課題に適用することで得られます。アーキタイプの構造的特徴すべてのシステムアーキタイプは、フィードバックループで構成されています。前回の記事で学んだように、フィードバックループには2種類あります。強化ループ(R)は変化を増幅させ、バランスループ(B)は目標に向けて調整します。システムアーキタイプは、これらのループの特定の組み合わせとして表現されます。そして、ループ間の相互作用や時間の遅れが、特徴的な問題パターンを生み出します。12のシステムアーキタイプここから、12のシステムアーキタイプを順に見ていきます。最初の3つは基本的なループパターンです。次の2つは最も重要なパターンとして深く掘り下げます。そして残りの7つも、実践に役立つ詳細とともに説明します。1. 好循環/悪循環—成功と失敗の自己強化最も基本的なパターン:自己強化型ループこれは、すべてのアーキタイプの基礎となる最もシンプルな構造です。変化が変化を生み、雪だるま式に増幅していくパターンです。構造:行動 →(+) 結果 →(+) さらなる行動  ↑                     │  │                     │  └─────────────────────┘  R(強化ループ):指数関数的な成長または衰退良いコードを書くと、レビューで学び、技術力が上がり、さらに良いコードを書けるようになる。問題を解決すると、自信がつき、難しい問題に挑戦し、さらに成長する。テストを書くと、バグが減り、開発が安定し、さらにテストを充実させる余裕が生まれる。これらは好循環の例です。一方、急いで実装すると、コードが汚くなり、変更が困難になり、さらに急いで実装せざるを得なくなる。バグが多いと、緊急対応に追われ、品質管理の時間がなくなり、さらにバグが増える。ドキュメントがないと、理解に時間がかかり、ドキュメントを書く時間がなくなり、さらに理解困難になる。これらは悪循環です。ここで立ち止まって考えてみましょう。「好循環と悪循環」という二分法は、現実を過度に単純化していないでしょうか。実際のシステムでは、好循環と悪循環が同時に存在することの方が多いのではないか。例えば、テストを書くことで開発が安定する一方で、テストのメンテナンスコストが増大し、それが新しいテストを書く障壁になることもあります。「好循環」と「悪循環」という明確な区別は、理論的には美しいが、実践的には曖昧なのではないか。確かに現実は、純粋な好循環も純粋な悪循環も稀です。重要な洞察は、好循環と悪循環は実は同じ構造だということです。違いは、ループがどちらの方向に回っているかだけなのです。そして、多くの場合、システムには複数のループが同時に存在し、互いに影響し合っています。テストを書くことによる安定化という好循環と、テストメンテナンスコストという悪循環が共存しているのです。だからこそ、どのループがより強く作用しているかを見極めることが重要なのです。理想的な好循環だけを目指すのではなく、悪循環の影響を最小化しながら、好循環を優位に保つ。これが現実的なアプローチです。ではどう介入するか。悪循環を断ち切るには、ループのどこか一箇所を意識的に変える必要があります。好循環を設計するには、小さな成功を積み重ね、自己強化のループに乗せることです。そして何より、初期条件に注意を払うこと。最初の一歩が、その後の軌道を決めるのです。あなたが今日書くコードの品質が、明日のあなたの開発速度を決めます。「急がば回れ」は、好循環と悪循環の分岐点を示す格言なのです。2. バランス型プロセスと遅延—調整の失敗目標追求のメカニズムとその落とし穴このアーキタイプは、目標と現状のギャップを埋めようとするバランスループに、時間遅延が加わったときに起こる問題を示します。構造:目標と現状のギャップ →(+) 行動 →(遅延)→ 結果 →(−) ギャップ       ↑                                        │       │                                        │       └────────────────────────────────────────┘       B(バランスループ):目標への調整パフォーマンス改善を考えてみましょう。改善の効果が本番で見えるまで数週間かかります。効果が見えないので、次々と最適化を追加してしまう。結果、過剰な最適化により、コードが複雑化し、逆にメンテナンスコストが増大することがあります。採用活動も同様です。採用してから戦力になるまで3〜6ヶ月かかります。人手不足を感じて大量採用すると、半年後には過剰になり、採用を停止する。すると1年後に再び不足する。組織の規模が周期的に変動してしまうのです。「遅延」を問題の根本原因とするこの見方は、人間の忍耐力の欠如を構造の問題にすり替えているだけではないでしょうか。つまり、問題は遅延そのものではなく、私たちが待つことができないという性質にあるのではないか。遅延は避けられない現実であり、それを「問題」として扱うことは、むしろ即座の結果を期待する文化を強化してしまうのではないか。確かに、遅延は問題ではなく、システムの自然な特性です。種を植えてから芽が出るまで時間がかかるのと同じように、多くのシステムには本質的な遅延が組み込まれています。問題は遅延そのものではなく、遅延を無視した行動を取ることなのです。ただ、ここで重要な反論がある。私たちは完璧に合理的な存在じゃない。認知的限界を持つ人間として、遅延は確かに過剰反応を引き起こす構造的要因なんだ。「待つことができない」という人間の性質を変えることは困難ですが、遅延を可視化し、先行指標を設定することで、この性質と折り合いをつけることはできます。この問題にどう対処するか。まず、遅延を可視化することです。「この行動の効果が見えるのはいつか?」を明確にします。次に、先行指標を設定します。最終結果を待たず、プロセスの改善を測定するのです。そして何より、忍耐強く待つこと。効果が出るまでの時間を理解し、過剰反応を避けることが重要です。3. うまくいかない解決策—短期的成功の罠応急処置が問題を悪化させる構造このアーキタイプは、短期的には効果のある解決策が、長期的には意図しない副作用を生み、かえって問題を悪化させるパターンです。構造:問題 →(+) 応急処置 →(短期)→(−) 問題症状  ↑                                │          (長期・遅延)                        └←(+) 意図せざる副作用 ←(+) 応急処置    B1:短期的な問題解決  R2:長期的な問題悪化プロジェクトの遅延に対して人を追加するという対応を考えてみましょう。一時的に作業量は増えます。しかし、教育コスト、コミュニケーションコスト、調整コストという意図せざる副作用が生まれます。長期的には、ブルックスの法則が示すように、さらに遅延することがあります。セキュリティ問題に対して厳しいルールを導入するという対応も同様です。一時的に安全に見えます。しかし、ユーザーが付箋にパスワードを書いたり、システムの回避方法を探したりする副作用が生まれます。長期的には、かえってセキュリティが脆弱化することがあるのです。ところで、この「副作用」という概念自体が恣意的じゃないだろうか。何を「主効果」とし、何を「副作用」とするかは、観察者の視点に依存します。人を追加することによる教育コストは「副作用」なのか、それとも「予測可能な必然的コスト」なのか。「副作用」という言葉は、予測できたはずの結果を予期しなかったことの言い訳になっていないか。確かに「副作用」という用語は、私たちの視野の狭さを隠蔽する危険性があります。多くの場合、「意図せざる」と呼ばれる結果は、実際には十分に予測可能だったのです。問題は副作用が存在することではなく、システム全体への影響を事前に考慮しなかったことにあります。とはいえ、ここで重要な現実がある。完全な予測は不可能だ。複雑なシステムでは、すべての相互作用を事前に把握することはできません。だからこそ、このアーキタイプは「副作用を避けよ」ではなく、「副作用を事前に予測し、監視し、早期に検出せよ」という教訓を与えているのです。「問題の転嫁」との違いに注意してください。「うまくいかない解決策」は単一の応急処置が副作用を生むパターンです。一方、「問題の転嫁」は症状対処と根本対処の競合のパターンです。構造は似ていますが、微妙に異なります。どう介入すればよいか。まず、副作用を事前に予測します。「この解決策の意図しない結果は何か?」と問うのです。次に、時間軸を長くとる。3ヶ月後、1年後、この解決策はどう機能しているかを想像します。そして、小規模な実験を行う。いきなり全面適用せず、まず小さく試して副作用を観察するのです。問題の転嫁と成長の限界—2大重要パターン次の2つのアーキタイプは、最も頻繁に現れ、最も深刻な影響を与えるパターンです。4. 問題のすり替わり—根本解決の機会損失短期的対処が長期的問題を生む構造このアーキタイプは、問題の症状に対する応急処置(症状対処)と、問題の根本原因を解決する根治療法(根本対処)が競合し、症状対処が根本対処を妨げるパターンです。構造:問題の症状 →(+) 症状対処 →(−) 症状(一時的軽減)     ↑                            │     │                            │     └────────────────────────────┘  B1:応急処置ループ     問題の症状 ←(+) 問題の根本原因                    ↑                   (−)遅延・困難                    │               根本対処 ←(−) 症状対処への依存                              B2:根本解決ループ               R3:依存の強化ループ重要な構造的特徴を理解しましょう。症状対処は速く、簡単ですが、根本原因は放置されます。根本対処は遅く、困難ですが、本質的に問題を解決します。そして、症状対処を繰り返すと、それへの依存が強まり、根本対処の能力が低下していくのです。バグが発生したとき、パッチを当てたり条件分岐を追加したりするのは症状対処です。設計を見直したり、テストを追加したり、リファクタリングしたりするのが根本対処です。クイックフィックスに慣れると、設計力が低下し、さらにクイックフィックスに頼るようになります。依存の強化ループが回り始めるのです。でも「症状対処」を悪とし、「根本対処」を善とする二元論は、現実の複雑さを見落としていないでしょうか。緊急の本番障害に対して「まず根本原因を特定してから対処しよう」と言えるでしょうか。時には症状対処こそが正しい選択であり、常に根本対処を追求することは、かえって組織を硬直させるのではないか。また、何が「症状」で何が「根本原因」かは、分析の深さによって相対的に変わるのではないか。この批判は実務的に重要な指摘です。確かに、症状対処をゼロにすることは非現実的です。本番障害が起きている最中に、「設計を見直そう」と悠長なことは言えません。また、「根本原因」という概念自体が相対的です。あるレベルで「根本原因」と思っていたものが、さらに深い分析では「症状」に過ぎないこともあります。このアーキタイプの本質は、症状対処を排除することではなく、症状対処への依存を警告することにある。症状対処と根本対処のバランスが重要なのです。緊急時には症状対処で凌ぎ、落ち着いたら根本対処に取り組む。この戦略的な使い分けができるかどうかが、システムの長期的な健全性を決めます。AI生成コードへの過度な依存も、このパターンです。実装方法がわからないという症状に対して、AIに全部聞いて生成されたコードをそのまま使うのは症状対処です。自分で考え、調べ、試行錯誤するのが根本対処です。AIへの依存が習慣化すると、自力で考える力が低下し、さらにAIに頼るようになります。序章で述べた生成AIの非対称性は、まさにこの「問題の転嫁」アーキタイプなのです。このシステムは予測可能な振る舞いパターンを示します。問題が発生し、症状対処で成功体験を得て、そのパターンが固定化され、依存が形成され、問題が悪化し、最終的にシステムが崩壊します。ではどう介入すればよいか。まず、時間の遅れを理解することです。根本対処の効果が現れるまでには時間がかかります。この遅延を理解し、忍耐強く待つ必要があります。次に、症状対処の副作用を可視化します。短期的利益は明確ですが、長期的コストは見えにくい。これを意図的に可視化するのです。根本対処は小さく始めることができます。いきなり全部をリファクタリングするのではなく、最も影響の大きい1つのモジュールだけ改善する。小さな成功体験が、次の一歩への推進力になります。症状対処をゼロにする必要はありません。戦略的に使うのです。根本対処が効果を発揮するまでの「つなぎ」として、意識的に症状対処を使うことができます。そして、環境を変えることも効果的です。症状対処が容易にできる環境では、人はそちらに流されます。環境を変えて、根本対処を選びやすくするのです。5. 成長の限界—自らを制限する構造成長が自らを制限する構造何かが順調に成長し始めます。最初は加速的に伸びていきます。しかし、ある時点から急に成長が鈍化し、やがて停滞する。このパターンが「成長の限界」です。構造:                    R(強化ループ:成長エンジン)       ┌──────────────────────────────┐       │                              │    行動 →(+) 成果 →(+) モチベーション →(+)       ↑       │       │      (+)       │       ↓       │    制約条件の悪化       │       │       │      (−)  B(バランスループ:制約)       │       │       └───────┘スキル習得を考えてみましょう。練習すると上達し、自信がつき、さらに練習するという強化ループがあります。しかし、現在の学習方法の限界、基礎知識の不足、時間の制約という制約に直面します。結果として「プラトー(停滞期)」に陥ります。仕事の生産性も同様です。効率化すると、仕事が早く終わり、達成感を得て、さらに効率化するという強化ループがあります。しかし、時間は有限、エネルギーは有限、レビュアーの対応速度には限界があります。一定の生産性で頭打ちになるのです。チームの拡大にも限界があります。メンバーを追加すると、開発力が増加し、プロジェクトが進展します。しかし、コミュニケーションコスト(n(n-1)/2)、教育コスト、意思決定の複雑化という制約に直面します。ブルックスの法則が示すように、「遅れているプロジェクトに人員を追加すると、さらに遅れる」のです。「成長の限界」という概念は、成長を当然の善とする前提に立っていないでしょうか。なぜ成長が鈍化することが「問題」なのか。持続可能なシステムとは、無限に成長し続けるシステムではなく、安定した規模で均衡を保つシステムではないのか。このアーキタイプは、成長至上主義を無批判に受け入れているように見えます。確かに、無限の成長は物理的に不可能であり、また望ましくもありません。生態系における「クライマックス群落」のように、成熟したシステムは成長を止めて安定することがあります。成長の鈍化を常に問題視することは、成長至上主義を強化してしまうかもしれません。ここで重要な区別がある。このアーキタイプが問題とするのは、意図しない制約による成長の停止だ。意図的に選択した安定状態と、制約を認識せずに陥った停滞は、まったく異なります。前者は戦略的判断ですが、後者は機会の損失なのです。さらに言えば、「成長」は必ずしも規模の拡大を意味しません。質的な成長、効率の向上、適応力の増加といった形の成長もあります。このアーキタイプの真の教訓は、「無限に成長せよ」ではなく、「制約を認識し、意識的に選択せよ」なのです。このシステムは予測可能な振る舞いを示します。加速的成長期、減速期、停滞期を経て、介入がなければ衰退期に入ります。効果的な介入には、エリヤフ・ゴールドラットの「制約理論」が役立ちます。まず、制約を特定します。何がシステムの成長を制限しているのか、ボトルネックを見つけるのです。次に、制約を最大限活用します。制約を取り除く前に、現在の制約を最大限に活用できているかを確認します。そして、制約を緩和します。制約を拡大したり、取り除いたりします。最後に、新しい制約に備えます。一つの制約を緩和すると、別の制約が顕在化するからです。誤った介入は、成長が鈍化したときに強化ループをさらに強化しようとすることです。スキルが伸びないからといって、さらに同じ方法で練習量を増やしても、制約は解消されません。しばしば状況を悪化させます。システム思考の洞察はこうです。問題は強化ループの弱さではなく、バランスループの制約の存在です。成長を再開させるには、強化ループを強化するのではなく、バランスループの制約を緩和する必要があるのです。利害関係者の相互作用—競争と協力のダイナミクス次の3つのアーキタイプは、複数の当事者間の相互作用が生み出すパターンです。6. 強者はますます強く—資源配分の不均衡勝者総取りの構造このアーキタイプは、限られたリソースを競う2つ以上の活動で、成功した方がより多くのリソースを得て、さらに成功し、最終的には一方が独占する構造です。構造:活動Aの成功 →(+) Aへのリソース配分      ↓                ↓      └────────→(+) 活動Aの成功                          ↕ (限られたリソース)                    活動Bの成功 →(−) Bへのリソース配分の減少      ↓                ↓      └────────→(−) 活動Bの成功            R1:Aの自己強化ループ      R2:Bの自己弱体化ループ機能開発の偏りを考えてみましょう。評価が高い機能Aにリソースが集中すると、さらに改善が進み、さらに評価が上がります。一方、新規機能Bはリソース不足で品質が低く、評価が下がり、さらにリソースが削られます。結果として、機能Bの開発機会が永遠に失われるのです。チーム間のリソース競争も同様です。成果を出したチームAが予算増を得ると、さらに成果を出し、さらに予算が増えます。一方、チームBは予算削減され、人材が流出し、さらに成果が出なくなります。組織全体の多様性が失われていきます。個人の成長機会の偏在も深刻です。優秀なエンジニアAに重要タスクが集中すると、スキルアップし、さらに重要タスクが回ってきます。一方、新人Bには簡単なタスクのみが割り当てられ、成長機会がなく、さらに差が開きます。組織の持続可能性が損なわれるのです。このアーキタイプは、まるで「強者」が不当に利益を得ているかのように描かれています。しかし、成果を出した者にリソースを集中させることは、組織全体の効率を最大化する合理的な戦略ではないでしょうか。能力主義を否定することは、かえって組織の競争力を損なうのではないか。このアーキタイプは、平等主義的イデオロギーを科学的な装いで正当化しているだけではないか。確かに、短期的な効率を追求するなら、成果を出している活動にリソースを集中させることは合理的です。問題は、この戦略が長期的にはシステム全体の脆弱性を増大させることにあります。重要なのは、「強者」個人の善悪ではなく、システムの構造です。このアーキタイプが警告しているのは、初期のわずかな差が構造によって増幅され、取り返しのつかない格差になることです。これは正義の問題ではなく、システムの多様性と適応力の問題なのです。一つの機能だけに集中投資したシステムは、市場が変化したとき脆弱です。一つのチームだけに依存する組織は、そのチームが崩壊したとき機能不全に陥ります。多様性の喪失は、システムの長期的な生存を脅かすのです。どう介入すればよいか。まず、競争構造を協力構造に変えることです。「どちらが勝つか」ではなく「両方を成功させる」という目標に転換します。次に、機会ベースの配分を行います。過去の成果ではなく、将来の可能性に基づいてリソースを配分するのです。意図的な多様性の維持も重要です。短期的な効率より、長期的な適応力を重視します。そして、定期的に初期条件をリセットします。「ゼロから再評価」の機会を設けるのです。このアーキタイプが示す重要な洞察は、「成功は能力よりも構造が決める」ということです。初期のわずかな差が、システムの構造によって増幅され、決定的な差になっていくのです。7. 予期せぬ敵対関係—協力者が敵になる罠パートナーが敵になる構造このアーキタイプは、本来は協力すべきパートナーが、互いの行動が相手を害していると誤解し、対立関係に陥るパターンです。構造:R1: Win-Winループ(意図)A の成功 ←→ 協力 ←→ Bの成功    ↑                    ↑    │  B2               │  B3   (−) Aの解決策       (−) Bの解決策    │  ↓               │  ↓    ↓  (意図せざる妨害) ↓Aの成功 ←────────────→ Bの成功         R4: 悪循環ループ(結果)フロントエンドとバックエンドの対立を考えてみましょう。双方ともユーザー価値を高めたいという意図があります。フロントエンドが表現力を高めるために複雑なAPIを要求すると、バックエンドの開発負荷が増大します。バックエンドがAPI設計をシンプルにすると、フロントエンドの表現力が制限されます。互いに「相手のせいで価値を出せない」と感じ、対立が深まっていくのです。品質保証チームと開発チームの対立も同様です。双方とも高品質な製品を届けたいという意図があります。QAが厳格なテストを実施すると、開発のリリース速度が低下します。開発がテストを簡略化するよう要求すると、品質が低下し、QAの目標達成が困難になります。互いに「相手が協力的でない」と感じるようになります。このアーキタイプは、対立を「誤解」の問題として扱っていますが、本当にそうでしょうか。フロントエンドとバックエンドの利害は、構造的に対立しているのではないか。QAと開発の目標は、本質的に矛盾しているのではないか。「共通の目標」という美しい理想を掲げても、現実には各チームには異なるKPIがあり、異なる評価基準があります。対立を「コミュニケーション不足」のせいにすることは、構造的な問題から目を逸らしているだけではないか。確かに、単なる「誤解」として片付けられない構造的な対立は存在します。フロントエンドとバックエンドが異なる上司に報告し、異なる評価基準で測られているなら、対立は必然です。このアーキタイプの深い洞察は、まさにその点にある。組織の構造が対立を生み出しているんだ。問題は個人の悪意や誤解ではなく、インセンティブ構造なのです。だからこそ、コミュニケーションだけでは不十分で、組織構造そのものを変える必要があるのです。例えば、フロントエンドとバックエンドを同じチームに統合する。QAと開発を共通の品質指標で評価する。こうした構造的な変更なしに、「協力しろ」と言っても意味がありません。どう介入すればよいか。まず、共通の目標を再確認します。「相手を打ち負かす」ではなく「共に成功する」という目標に立ち返るのです。しかし、これは単なる精神論ではなく、共通の評価指標を設定するという具体的な行動を伴う必要があります。次に、意図せざる妨害を可視化します。「私のこの行動が、相手にどんな影響を与えているか?」を明示的に確認します。一緒に解決策を設計することも重要です。一方的な解決策ではなく、双方の制約を理解した上での協働設計を行います。そして、定期的なコミュニケーションの場を設けます。問題が深刻化する前に、小さな違和感を話し合うのです。このアーキタイプが示す重要な洞察は、「善意から生まれる悲劇」です。誰も悪意はないのに、システムの構造が対立を生み出してしまうのです。8. 共有地の悲劇—個人合理性と集団非合理性個人合理性と集団非合理性の対立このアーキタイプは、複数の主体が共有資源を利用するシステムで、各個人にとって合理的な行動が、集団全体には非合理的な結果を生む構造です。構造:個人Aの資源利用 →(+) Aの利益 →(+) さらなる資源利用      ↑                                │      │                                │      └────────────────────────────────┘  R1:Aの利益最大化      個人Bの資源利用 →(+) Bの利益 →(+) さらなる資源利用      ↑                                │      │                                │      └────────────────────────────────┘  R2:Bの利益最大化      全員の利用の合計 →(+) 共有資源の枯渇 →(−) 全員の利益自分の時間とエネルギーという共有資源を考えてみましょう。仕事、家族、趣味、健康—すべてが「もっと時間を」と要求します。各領域の要求は個別には合理的です。しかし結果として、睡眠や休息が犠牲になり、燃え尽き症候群に陥ることがあります。コードベースという共有地も同様です。「納期があるから、とりあえず動くコードを書く」という各開発者の判断は、個別には合理的です。しかし結果として、コードが理解困難になり、全員の開発速度が低下していきます。「共有地の悲劇」は、私有財産制を正当化するために使われてきた概念ではないでしょうか。「共有資源は必ず枯渇する」という前提は、エリノア・オストロムの研究によって反証されています。実際、多くのコミュニティは何世代にもわたって共有資源を持続的に管理してきました。このアーキタイプは、人間の利己性を前提とし、協力や相互扶助の可能性を無視しているのではないか。確かに、オストロムの研究は、ルールとガバナンスがあれば共有資源は持続可能に管理できることを示しました。「共有地の悲劇」は必然ではなく、制度設計の失敗なのです。このアーキタイプの価値は、まさにその点にある。制度なしには共有資源は枯渇しやすいという警告なんだ。オストロムが示した持続可能な共有資源管理には、明確なルール、監視メカニズム、制裁システム、紛争解決手段が必要でした。つまり、意図的な設計と管理が不可欠なのです。このアーキタイプは「共有はダメだ」と言っているのではなく、「共有資源には意図的な管理が必要だ」と教えているのです。どう介入すればよいか。まず、資源の可視化が重要です。残量を表示し、「自分一人くらい」という錯覚を防ぎます。次に、利用ルールを設定します。各主体の利用に明示的な制限を設けるのです。フィードバックの直接化も効果的です。過剰利用の影響を、利用者に直接返します。そして、共同管理の仕組みを導入します。資源を共同で管理する仕組みを作り、「誰かがやるだろう」という心理を防ぐのです。このアーキタイプが示すシステム的洞察は重要です。個人の合理的行動の集積が、集団的には非合理的な結果を生むのです。個人システムの最適化だけでなく、大きなシステムの持続可能性を考慮することが、真に賢明な個人の行動なのです。目標管理の失敗—期待と現実のギャップ次の2つのアーキタイプは、目標設定と達成のプロセスで起こる典型的な罠です。9. バラバラの目標—対立する複数の目標複数の目標が互いを妨げる構造このアーキタイプは、複数の対立する目標を同時に追求しようとして、結局どれも達成できなくなるパターンです。構造:目標Aと現状のギャップ →(+) Aへの努力 →(+) Aの達成                                ↓                              (−)                                ↓目標Bと現状のギャップ ←────────┘      ↓     (+)      ↓   Bへの努力 →(+) Bの達成      ↓    (−)      ↓  目標Aの達成 ←────┘    B1:目標Aの追求  B2:目標Bの追求  互いに妨害し合うスピードと品質の両立を考えてみましょう。「素早くリリースする」という目標と「高品質を維持する」という目標があります。スピードを追求すると品質が下がり、品質を追求するとスピードが下がります。結果として、中途半端なスピードと中途半端な品質になってしまうのです。技術的負債の返済と新機能開発の両立も同様です。負債返済にリソースを使うと新機能が遅れ、新機能を優先すると負債が増えます。どちらも中途半端になります。「バラバラの目標」という表現は、ネガティブすぎないでしょうか。複数の目標を持つことは、組織の成熟の証ではないのか。スピードと品質、短期と長期、個人と組織—これらのバランスを取ることこそがマネジメントの本質ではないのか。このアーキタイプは、単一目標への集中を暗に推奨しているように見えますが、それは視野狭窄を招くのではないか。確かに、複雑な組織には複数の正当な目標が必要です。問題は複数の目標を持つこと自体ではなく、それらの間のトレードオフを認識せずに「すべて同時に最大化」しようとすることにあります。重要な洞察は、目標間の相互作用を理解することです。スピードと品質は必ずしも対立しません。自動化によって両立できることもあります。しかし、限られたリソースの中では、どこかで優先順位をつけざるを得ません。このアーキタイプが警告しているのは、トレードオフを認識せず、すべての目標を同時に最大化しようとする非現実的な期待です。成熟した組織は、複数の目標を持ちつつ、それらの動的なバランスを取ります。どう介入すればよいか。まず、優先順位を明確にすることです。すべてを同時に追求するのではなく、時期によって優先順位を変えるのです。次に、トレードオフを理解します。「すべてを同時に最大化」は不可能です。何を諦めるかを明確にします。目標の統合を探すことも重要です。対立を前提とせず、両方を満たす第三の道を探ります。例えば、「自動化による品質とスピードの両立」という統合的アプローチがあるかもしれません。そして、より上位の目標に立ち返ります。「なぜこれらの目標が必要なのか?」を問い、本質的な目標を再定義するのです。このアーキタイプが示す重要な洞察は、「すべてが重要」という考え方の罠です。何もかも追求しようとすると、結局何も達成できないのです。10. 目標のなし崩し—徐々に下がる基準目標が現状に引きずられて下がる構造このアーキタイプは、目標と現状のギャップに対して、現状を改善するのではなく、目標を下げることで対処してしまうパターンです。別名「ずり落ちる目標」「ゆでガエル症候群」とも呼ばれます。構造:パフォーマンスの目標 →(+) ギャップ認識 →(+) 改善努力         ↑                                    ↓         │                                   (+)      (遅延)                                  ↓         │                              実際のパフォーマンス         │                                    │         └←(+) プレッシャー ←(+) ギャップ ←(−)┘              ↓            (−)              ↓      目標の引き下げ (短期的な解決)            B1:改善努力のループ(正しい)      B2:目標引き下げのループ(安易な逃避)コードカバレッジの目標を考えてみましょう。当初は「テストカバレッジ80%を維持」という目標がありました。しかし忙しくて達成困難になると、「まあ、60%でいいか」と下げてしまいます。さらに「50%でも動いているし」となり、品質基準が徐々に劣化していくのです。リリースサイクルも同様です。当初は「2週間ごとにリリース」という目標がありました。しかし間に合わないと「3週間にしよう」と延ばし、さらに「1ヶ月でいいか」となります。開発速度が徐々に低下していきます。目標を柔軟に調整することは、適応力の表れではないでしょうか。80%のカバレッジが本当に必要かどうかは、プロジェクトの性質によります。盲目的に高い目標を維持することは、むしろ硬直性を生むのではないか。「目標のなし崩し」と「現実的な目標調整」の境界はどこにあるのか。このアーキタイプは、柔軟性を欠いた完璧主義を推奨しているように見えます。確かに、状況に応じて目標を調整することは必要です。問題は、調整が意図的か、それとも無意識の逃避かにあります。重要な区別があります。戦略的な目標調整は、新しい情報に基づいて意識的に行われます。「80%のカバレッジは過剰だと判明した。根拠を持って60%に調整する」これは健全です。一方、なし崩しは、達成困難さから逃れるために無意識に行われます。「忙しいから、とりあえず下げよう」これが問題なのです。このアーキタイプの本質は、基準を下げることの危険性ではなく、下げていることに気づかない危険性にあります。ゆでガエルの比喩が示すように、徐々の変化は認識されにくいのです。どう介入すればよいか。まず、絶対的な基準を設定することです。「競合他社より速い」という相対基準ではなく、「ユーザーが快適と感じる500ms」という絶対基準を持つのです。次に、外部ベンチマークとの比較を続けます。内部基準だけでなく、業界標準や競合と比較し続けます。ビジョンへの回帰も重要です。「なぜこの目標を設定したのか」という初心に立ち返るのです。目標の引き下げを可視化することも効果的です。変更履歴を記録し、「ずり落ち」を認識可能にします。そして、外部からの監視を入れます。外部の目(顧客、経営陣、第三者)を入れ、内部だけの判断を避けるのです。このアーキタイプは「ゆでガエル」の比喩で知られます。徐々に悪化する環境には気づきにくく、気づいたときには手遅れになっている。定期的な振り返りと、絶対的な基準の維持が重要なのです。競争のダイナミクス—エスカレートの構造11. エスカレート—報復の応酬互いの脅威認識が増幅する構造このアーキタイプは、互いに脅威と感じる行動を取り合い、報復がエスカレートしていくパターンです。軍拡競争、価格競争、誹謗中傷合戦などに見られます。構造:Aの相対的優位性 →(+) Aの脅威認識 →(+) Aの対抗行動      ↓                                    ↓    (−)                                  (−)      ↓                                    ↓Bの相対的優位性 ←────────────────────────┘      │     (+)      ↓Bの脅威認識 →(+) Bの対抗行動      │                ↓      └──────←(−)──────┘            B1:Aの防衛ループ      B2:Bの防衛ループ      R3:エスカレートの悪循環2つのチームの対立を考えてみましょう。チームAが「自分たちが主導権を持つべき」と主張すると、チームBが「自分たちの方が重要」と反論します。Aがさらに強く主張すると、Bがさらに反発します。組織が分断され、協力が不可能になり、プロジェクト全体が停滞していきます。技術選定の対立はさらに感情的になることがあります。エンジニアAが「React を使うべき」と主張すると、エンジニアBが「Vueの方が良い」と反論します。それぞれが相手の技術の欠点を指摘し合い、やがて人格攻撃に発展します。チームの雰囲気が悪化し、建設的な議論が不可能になるのです。ただ、競争は必ずしも悪じゃない。市場経済は競争によって効率化を達成してきた。技術選定での議論も、より良い選択につながることがあります。「エスカレート」を常に悪とする見方は、健全な競争や建設的な議論まで抑圧してしまうのではないか。いつ競争が「エスカレート」になるのか、その境界は曖昧ではないか。確かに、健全な競争と破壊的なエスカレートは異なります。問題は、競争そのものではなく、ゼロサム思考への転換です。健全な競争では、両者が切磋琢磨し、全体のレベルが上がります。一方、エスカレートでは、相手を打ち負かすこと自体が目的化し、全体が消耗します。技術選定での建設的な議論は、「どちらがこのプロジェクトに適しているか」を探ります。一方、エスカレートした対立では、「どちらが正しいか」を証明することが目的になります。境界は確かに曖昧ですが、重要な指標があります。相手の意見を聞く余裕があるか、共通の目標を見失っていないか、個人攻撃に発展していないか。これらが、健全な競争とエスカレートを分ける基準です。どう介入すればよいか。最も効果的なのは、どちらかが先に「攻撃的な行動」を止めることです。勇気が必要ですが、一方的な停戦が最も効果的です。共通の敵を作ることも効果的です。対立の構図を変え、「A対B」から「AとB対共通の課題」に転換するのです。競争ゲームを協力ゲームに変えることも重要です。ゼロサムではなく、両方が勝てる構造を設計します。第三者の介入も有効です。中立的な立場の人が仲介し、感情的なエスカレートを止めます。そして、より上位の目標を共有します。「どちらが正しいか」ではなく「ユーザーにとって何が最善か」という視点に立つのです。このアーキタイプが示す重要な洞察は、エスカレートが両者の「防衛」という認識から始まるということです。「相手が攻撃してきたから防衛する」という論理が、相手にとっては「攻撃」に見える。この非対称な認識がエスカレートを生むのです。長期的成長の失敗—投資不足の罠12. 成長と投資不足—自らが生み出す限界成長機会を投資不足で失う構造このアーキタイプは、成長に必要な投資(キャパシティへの投資)を怠り、パフォーマンスが低下し、需要が減少し、投資の必要性すら失われるという悪循環のパターンです。構造:需要 →(+) 成長の圧力 →(+) パフォーマンス改善  ↑                              ↓  │                             (+)  └←(+)─────────────────────キャパシティ                                  ↑                                (−)遅延                                  │                          投資 ←(−) パフォーマンス基準との不一致                                                    B1:成長のループ                          B2:投資のループ                          R3:投資不足の悪循環重要な構造的特徴を理解しましょう。成長が限界に近づくと、パフォーマンスが低下します。低下したパフォーマンスを見て「もう成長は終わった」と誤判断し、投資を控えます。投資不足により、さらにパフォーマンスが低下し、需要が減ります。「成長しない」と信じたことで、本当に成長しなくなる自己成就的予言が起きるのです。技術的負債の返済を考えてみましょう。ユーザーが増え、機能要求が増えるという成長があります。しかし技術的負債により開発速度が低下します。「新機能を優先すべき」と投資(リファクタリング)を後回しにすると、さらに開発速度が低下し、需要に応えられず、ユーザーが離れていきます。「どうせユーザーは減っている」と投資しなくなる悪循環に入るのです。インフラの増強も同様です。トラフィックが増加するという成長があります。しかしサーバーが限界に近づき、レスポンスが遅延します。「一時的な現象」と判断してインフラ投資を控えると、さらに遅延が悪化し、ユーザー体験が悪化し、ユーザーが離れていきます。「どうせユーザーは減っている」と投資しなくなるのです。もちろん、すべての低下が「投資不足」で説明できるわけじゃない。時には、製品が本当に市場のニーズを失っていることもある。衰退しているビジネスに投資を続けることは、「サンクコストの誤謬」ではないのか。このアーキタイプは、投資すれば必ず成長するという楽観主義に基づいていないか。撤退の判断を遅らせ、資源の浪費を正当化するために使われる危険性はないか。確かに、すべての衰退が投資不足によるものではありません。市場そのものが縮小していることもあれば、製品が時代遅れになっていることもあります。そして、撤退すべきタイミングを見極めることは、投資を続けることと同じくらい重要です。このアーキタイプが警告しているのは、投資不足による自己成就的予言だ。重要な区別は、外部要因による衰退か、内部の投資不足による衰退かを見極めることです。判断の基準があります。市場全体は成長しているか、競合は成長しているか、パフォーマンス低下の原因は何か。これらを分析することで、投資すべきか撤退すべきかを判断できます。このアーキタイプの真の価値は、早すぎる諦めを防ぐことにあります。一時的なパフォーマンス低下を見て「もうダメだ」と判断する前に、投資によって回復可能かを検討する。この視点が、本来救えたはずのシステムを救うのです。どう介入すればよいか。まず、将来を見据えた投資を行います。現在のパフォーマンスではなく、将来の需要を基準に投資を判断するのです。次に、先行指標を設定します。「ユーザー数」だけでなく「潜在的需要」「市場機会」を見ます。投資を可視化することも重要です。技術的負債、インフラ、人材育成への投資を、明示的に予算化します。長期的視点を制度化します。四半期だけでなく、3年後、5年後のビジョンで判断します。そして、成長への信念を維持します。一時的な低下に過剰反応せず、長期的な成長ストーリーを信じるのです。ただし、これは盲目的な楽観ではなく、データに基づいた信念である必要があります。「成長の限界」との違いに注意してください。「成長の限界」は外部の物理的制約により成長が止まるパターンです。一方、「成長と投資不足」は投資判断の失敗により、自ら成長を止めてしまうパターンなのです。このアーキタイプが示す重要な洞察は、自己成就的予言の危険性です。「成長しない」と信じて投資を控えると、本当に成長しなくなる。逆に、合理的な投資を続ければ、成長は再開できるのです。アーキタイプを見抜く技術これらのアーキタイプは、単独で現れることは稀です。実際のシステムでは、複数のアーキタイプが組み合わさっています。アーキタイプを見抜くには、プロセスがあります。まず、繰り返しのパターンに気づくことです。「またこの問題か」という違和感を大切にし、時系列でパターンを観察します。次に、氷山モデルで掘り下げます。出来事の背後にある構造を探り、パターンから構造へ、構造からメンタルモデルへと深掘りしていきます。そして、フィードバックループを描きます。因果関係を図示し、ループを特定します。強化ループ(R)とバランスループ(B)を識別するのです。既知のアーキタイプと照合します。「これは○○のパターンに似ている」と気づくことが重要です。完全一致を求める必要はありません。類似性を見るのです。最後に、効果的な介入ポイントを見つけます。アーキタイプの知見を活用し、レバレッジポイントを特定します。小さな変更で大きな影響を与えられる場所を探すのです。生成AIへの過度な依存を例に考えてみましょう。これは実は複数のアーキタイプの組み合わせです。思考プロセス(根本対処)をAI(症状対処)に置き換えるという「問題の転嫁」があります。AI使用という強化ループが思考力という制約にぶつかる「成長の限界」があります。AIを使える人とそうでない人の差が開くという「強者はますます強く」があります。そして、短期的な生産性向上が長期的な能力低下を生むという「うまくいかない解決策」もあります。このように、現実の問題は複雑です。しかし、個々のアーキタイプを理解していれば、複雑な問題も、既知のパターンの組み合わせとして理解できるようになるのです。おわりにシステムアーキタイプは、繰り返し現れる問題の構造パターンです。熟練したアーキテクトがシステム設計を見ただけでボトルネックを予測できるように、アーキタイプを理解すれば、問題の本質を素早く見抜けます。12のアーキタイプを振り返りましょう。好循環と悪循環は、変化の自己強化を示し、初期条件が未来を決めることを教えてくれます。バランス型プロセスと遅延は、調整の失敗を示し、時間遅延が過剰反応を生むことを教えてくれます。うまくいかない解決策は、短期的成功の罠を示し、副作用が問題を悪化させることを教えてくれます。問題のすり替わりは、根本解決の機会損失を示し、症状対処が根本対処を妨げることを教えてくれます。成長の限界は、自らを制限する構造を示し、制約の特定と緩和が鍵であることを教えてくれます。強者はますます強くは、資源配分の不均衡を示し、勝者総取りの構造を教えてくれます。予期せぬ敵対関係は、協力者が敵になる罠を示し、善意から生まれる悲劇を教えてくれます。共有地の悲劇は、個人合理性と集団非合理性の対立を示し、持続可能性の喪失を教えてくれます。バラバラの目標は、対立する複数の目標を示し、すべてを追うと何も得られないことを教えてくれます。目標のなし崩しは、徐々に下がる基準を示し、ゆでガエル症候群を教えてくれます。エスカレートは、報復の応酬を示し、防衛のつもりが攻撃に見えることを教えてくれます。成長と投資不足は、自らが生み出す限界を示し、自己成就的予言の危険性を教えてくれます。生成AI時代との関連を考えてみましょう。生成AIの普及は、新しい「問題の転嫁」「うまくいかない解決策」「成長の限界」のパターンを生み出しています。序章で述べた非対称性—生産と理解の乖離、生産量と成長の乖離、経験の量と学びの質の乖離—は、これらのアーキタイプとして現れています。アーキタイプの認識は、この構造的問題を見抜く力を与えてくれるのです。実践への第一歩は簡単です。繰り返される問題に直面したら、立ち止まって考えてみてください。「このパターン、どこかで見たな」と。そして、この記事で学んだアーキタイプの中に、似たものがないか探してみてください。完璧に当てはまらなくても構いません。構造を意識するだけで、見え方が変わります。システムアーキタイプは、先人たちの知恵の結晶です。同じ過ちを繰り返さず、効果的に問題を解決するための地図です。この地図を手に、複雑なシステムの世界を旅していきましょう。","isoDate":"2025-10-05T22:42:20.000Z","dateMiliSeconds":1759704140000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"システム思考を日々の開発に取り入れる実践ガイド","link":"https://syu-m-5151.hatenablog.com/entry/2025/10/01/203924","contentSnippet":"syu-m-5151.hatenablog.comはじめに前回の記事では、システム思考の基本的な概念—非線形性、関係性、反直感性、氷山モデル—を見てきました。システムをプラモデルではなく生態系として理解する視点を学びました。しかし、概念を知っているだけでは意味がありません。テニスの本を読んでもテニスができるようにならないように、システム思考も実践してこそ身につくものです。理論を学んだ今、次のステップは「どう実践するか」です。この記事では、日々の開発の中でシステム思考をどう使うかを具体的に解説します。取り上げるのは、自己認識の深め方、建設的な対話の作り方、フィードバックループの設計、パターンの見つけ方、そしてモデリングの実践です。これらはシステム思考の実践方法のほんの一部ですが、すべて明日から使える方法ばかりです。特別なツールや権限は必要ありません。新人エンジニアでも、今日から、今いるチームで始められます。大切なのは、小さく始めることです。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。自己認識とメタ認知思考を改善するには、まず自分の思考に気づく必要があります。メタ思考～「頭のいい人」の思考法を身につける作者:澤円大和書房Amazon「なぜ私はこの解決策を選んだのか？」「どんな前提に基づいて判断しているのか？」「他の視点から見たらどうなるだろう？」システム思考の最良の開始方法は、最も身近なシステムである自分自身で練習することです。自分がどのように考え、決定し、行動しているかを観察することから始まります。これをメタ認知—自分の思考を客観的に見る力—と呼びます。ここで重要なのは、「問う」という行為の本質を理解することです。「問う」とは、実は「情報を編集する」という知的営みなのです。私たちは日々、膨大な情報に囲まれています。システムログ、エラーメッセージ、レビューコメント、仕様書、チャットの会話—これら無数の断片的な情報を、どう組み合わせ、どう意味づけるか。それが「問い」を立てるということです。問いの編集力 思考の「はじまり」を探究する作者:安藤昭子ディスカヴァー・トゥエンティワンAmazon「このバグはなぜ起きたのか」という問いは、エラーメッセージ、コードの履歴、環境設定、ユーザーの操作ログといった複数の情報を編集し、一つの物語として組み立てる作業です。「この設計で本当にいいのか」という問いは、要件、制約、技術的選択肢、チームの状況といった情報を再構成する試みです。そして、一人ひとりの編集力によって、その人ならではの内発する「問い」が生まれます。新人エンジニアのあなたが感じる違和感は、ベテランには見えない問いの種かもしれません。「なぜこの変数名はこんなに長いのだろう」「なぜこの処理は分散しているのだろう」—こうした素朴な疑問が、実はシステムの本質的な問題を指し示していることがある。問いが生まれるプロセスには、段階があります。まず「問い」の土壌をほぐす—これが自己認識です。自分がどんな前提で考えているか、どんな偏りを持っているか、どんな経験が判断に影響しているか。この土壌が固ければ、問いは芽を出せません。具体的にどう実践するか。何か技術を選ぶとき（フレームワーク、ライブラリ、設計パターン）、紙に書き出してみる。最初に思いついた選択肢は何か。なぜそれを思いついたのか—過去の経験？記事を読んだ？先輩に勧められた？他の選択肢は検討したか。最終的な判断の決め手は何だったか。ここで大切なのは、違和感に気づくことです。「なんとなくこの技術が良さそう」と思ったとき、その「なんとなく」の正体は何でしょうか。単に新しい技術を試したいだけではないか。本当にこのプロジェクトに適しているのか。この振り返りが、「問い」のタネを集めるプロセスです。自分の判断パターンや偏りに気づき、「本当にそうなのか？」という問いのタネが生まれる。次に、日々の仕事で何が重要で何がそうでないかを判断する練習をする。Slackの大量の通知、「緊急」と書かれているが実は緊急でないタスク、細かいコーディングスタイルの議論—これらはノイズかもしれない。一方で、ユーザーからの「使いにくい」という小さなフィードバック、システムログの中の見慣れないエラー、先輩の何気ない一言「このコード、後で問題になりそう」—これらがシグナル、つまり本当に重要な情報かもしれない。重要なのは、形式的なチェックリストに従うことではありません。自分の中に自然と湧き上がる問いに気づくことです。「このコード、なんか気持ち悪いな」という感覚。「この設計、本当にこれでいいのか？」という引っかかり。こうした違和感こそが、「問い」を発芽させるきっかけなのです。週末に5分だけ振り返りをしてみる。「今週、どれに時間を使ったか」「本当に重要だったのはどれか」。この練習で、重要なことを見抜く力が養われる。そして、新しい技術を学ぶとき、「これは難しすぎる」と思ったら、一歩引いて考えてみる。本当に難しいのか、それとも単に馴染みがないだけか。どの部分が理解できて、どの部分が理解できないか。理解できない理由は何か—前提知識の不足？説明が分かりにくい？この分析によって、「難しい」という漠然とした感覚が、「この部分の前提知識が足りない」という具体的な課題に変わる。これが「問い」が結像する瞬間です。このプロセス全体—土壌をほぐし、タネを集め、発芽させ、結像させる—が、「問いの編集力」です。これは「問う」という知的営みを、一人ひとりの編集力でアップデートするプロジェクトなのです。そして、この力こそが、システム全体をより良く理解し、設計する力につながります。ここで一つ、現代のエンジニアが直面する重要な課題について触れておきたい。生成AIは、確かに開発効率を飛躍的に高めてくれる。しかし、過度な利便性は、個人の成長に不可欠な「考える過程」を奪ってしまう危険性がある。「この関数、どう実装すればいいだろう？」という問いに直面したとき、すぐにAIに答えを求めるのは簡単だ。人は本質的に快適さを求め、最も抵抗の少ない道を選んでしまう。しかし、その「なぜこのアプローチを選ぶのか」「他にどんな選択肢があるのか」と自分で考える過程こそが、問いの編集力を育てる土壌なのだ。だからといって、AIを完全に排除すべきだという話ではない。重要なのは、将来の自分を妨げないよう、意図的に活用することだ。例えば、まず自分で5分考えてから、AIに相談する。AIの提案を受け取ったら、「なぜこのコードがそう書かれているのか」を理解しようとする。あるいは、実装の方向性を確認する用途には使うが、細部の実装は自分で書いてみる。こうした意図的な距離感が、創造性と成長を維持する鍵となる。システム思考を身につけるには、この「立ち止まって考える時間」が不可欠だ。便利なツールを使いながらも、自分で問いを立て、自分で考える習慣を意識的に守っていこう。自己認識を高めることは、単に自分を知ることではありません。自分ならではの問いを生み出せるようになることです。そして、その問いがシステムの本質に迫るとき、あなたは本当の意味でのシステム思考の実践者になっているのです。反応から応答へ誰かがアイデアを提案しました。あなたの最初の反応は「でも、それは...」かもしれません。ちょっと待ってください。他者と働く──「わかりあえなさ」から始める組織論 (NewsPicksパブリッシング)作者:宇田川元一ニューズピックスAmazonシステム思考は、出来事への反応から、応答的な行動パターンへ、そして（改善された）システム構造の生成へと移行する能力です。そして、その第一歩が「まず受け止める」という姿勢です。開発現場では、しばしば「否定から入る」文化が見られます。新しい提案に対して、即座に「でも」「しかし」「それは無理だ」と反応してしまう。これは慎重さの表れかもしれませんが、建設的な対話を阻害してしまいます。まず受け止めるとは、相手のアイデアを即座に否定せず、その意図や背景を理解しようとすることです。これは合意することではありません。相手の視点を理解することと、それに同意することは別の話です。例えば、同僚が「このシステムをマイクロサービスに分割すべきだ」と提案したとします。否定的な反応は「でも、そんなことしたら複雑になるだけですよ」となるかもしれません。しかし、まず受け止めるアプローチでは「なるほど、マイクロサービス化することで独立したデプロイが可能になりますね。それを実現するには、サービス間の境界をどう定義するか考える必要がありそうです。現状の課題も含めて、一緒に検討してみませんか」といった形で応答します。この姿勢は、対立ではなく対話を生み出します。「私の考えを変えて」と要求するのではなく、「一緒に考えよう」という協働の場を作るのです。これこそが、システム思考に必要な姿勢なのです。まず受け止めることで、異なる視点を統合し、より豊かな解決策を生み出すための土台が作られます。相手のアイデアを否定するのではなく、それを出発点として、共に探求を深めていくのです。これは簡単なことではありません。特に、明らかに問題があると感じるアイデアに対して、まず受け止めるのは困難です。しかし、相手の視点を理解し、その上で建設的な方向に導くことで、より良い結果を生み出せるのです。「なぜそう考えたのか」を聞くことから始めましょう。その背景を理解すれば、本当の課題が見えてくることもあります。本当のゴールを見つける目標を抽象化して本質を見極めることから始めます。例えば「レガシーシステムをモダン化する」という目標の本質は何でしょうか？表面的には「古い技術を新しい技術に置き換える」と見えます。しかし、システム思考で考えると、本当の目的は「変更コストを下げ、新機能を素早く提供できる状態を作る」ことかもしれません。あるいは「属人化を解消し、チーム全体がシステムを理解できる状態を作る」ことかもしれません。この理想的な状態の定義が曖昧だと、どれだけ細かく分解しても、正しい方向に進めません。氷山モデルで言えば、最も深い層である「メンタルモデル」を明確にすることです。具体的には、次のような問いを立てます。「なぜこの目標が必要なのか？」という問いは、目標の背景にある本当の課題を浮き彫りにします。「達成したら、何が変わるのか？」という問いは、成功の姿を具体的にします。「誰にとっての価値を生み出すのか？」という問いは、ステークホルダーとその期待を明確にします。そして「この目標の成功は、どう測定できるのか？」という問いは、抽象的な理想を検証可能な基準に変換します。この問いに答えることで、漠然とした目標が、明確な理想状態に変わります。そして、この明確な理想状態こそが、すべての具体的な行動の羅針盤となるのです。具体と抽象作者:細谷 功dZERO（インプレス）Amazonシステム的推論知識労働者として、私たちは常に、形式的または非形式的に、アイデア、行動、理論を提案しています。「このアーキテクチャを採用すべきだ」「このツールを使うべきだ」「この方法で実装すべきだ」しかし、その提案に説得力を持たせるには、システム的推論が必要です。新人エンジニアのあなたも、日々の開発で「なぜこの方法を選んだのか」を説明する場面があるでしょう。例えば、納期が迫る中で「テストコードを書く時間がない」という意見に対して、どう考えますか？ここでシステム的推論が力を発揮します。単に「テストは重要だから書くべき」という原則論ではなく、システム全体への影響を考える。「確かに今週の納期は重要です。しかし、テストなしでリリースすると、本番環境でバグが発生する可能性が高まります。過去3ヶ月のデータを見ると、テストカバレッジが50%未満のコンポーネントは、平均して月2回の緊急修正が必要でした。各修正には平均4時間かかり、さらに顧客への説明や再リリースの手間も考えると、今2時間かけてテストを書く方が、トータルの工数は削減できます」このような推論には、信頼性（過去のデータに基づく）、関連性（現在の状況に直結）、結束性（理由が相互に補強し合う）、説得力（具体的な数値で示す）という要素が含まれています。重要なのは、メリット・デメリットを機械的に並べることではありません。システム全体の中で、この選択がどんな波及効果を生むかを考えることです。短期的なメリットが長期的なデメリットを生むかもしれない。一つの部分の最適化が、別の部分のボトルネックを作るかもしれない。こうした相互作用を含めて考えることが、システム的推論なのです。日本の開発現場でよくある「仕様変更」への対応も、システム的推論で考えると違って見えます。「また仕様変更か...」と嘆くのではなく、「この仕様変更のパターンから、顧客が本当に求めているものが見えてきた。次回から、初期段階でプロトタイプを見せて早めにフィードバックをもらう仕組みを提案してみよう」という建設的な提案につなげられるのです。なぜあの人の解決策はいつもうまくいくのか?―小さな力で大きく動かす!システム思考の上手な使い方作者:枝廣 淳子,小田 理一郎東洋経済新報社Amazon目標を構造化する技術理想的な状態が定義できたら、そこに至る道筋を設計します。ここで重要なのが、4つの視点で構造化するという考え方です。1. 時間を構造化する時間は最も重要な制約です。そして、制約こそが価値を生み出します。現実を直視しましょう。無限に時間があれば、そこそこ良いものは作れます。しかし、それでは意味がありません。永遠にリファクタリングを続け、完璧な設計を追求し、すべてのエッジケースに対応する—そんな仕事に価値はないのです。締め切りがあるからこそ、私たちは本質に集中します。何が本当に重要で、何が単なる理想なのかを見極めます。締め切り駆動こそが、本当の仕事なのです。だからこそ、締め切りを味方にする技術が必要です。3ヶ月後という最終締め切りがあるなら、3ヶ月先まで何もしないのではなく、中間地点を意図的に設計します。重要なのは、単に時間を等分するのではなく、意味のあるマイルストーンを設定することです。「1週間後にプロトタイプで検証」「2週間後にチームでレビュー」「1ヶ月後に本実装開始」というように、各地点で何を達成し、何を学ぶのかを明確にします。各マイルストーンが小さな締め切りとなり、あなたを前進させます。そして、日にちではなく日時で決めることです。「来週中」ではなく「水曜日の15時まで」。さらに、他者と約束することで強制力を持たせます。「水曜のミーティングで進捗を共有します」と宣言することで、逃げ場のないコミットメントが生まれます。この適度なプレッシャーが、フィードバックループを回し続けるのです。2. 複雑さを分割する大きな問題を前にしたとき、全体を一度に理解しようとするのは無謀です。それは不可能であるだけでなく、非効率でもあります。現実の開発では、完全な理解を待っている余裕はありません。不完全な理解のまま前に進み、動きながら理解を深めていく。これが実践です。しかし、闇雲に進むわけではありません。今この瞬間に何に集中すべきかを明確にする必要があります。ここで重要なのは、複雑さには構造があるということです。どんな複雑な問題も、認識のプロセスという観点から段階に分解できます。認識の段階で分割するシステムアーキテクチャの設計という大きなタスクを考えます。これは、認識の深さによって段階に分解できます。最初の段階は「理解する」こと。既存のシステムがどう動いているかを把握します。次の段階は「分析する」こと。何が問題で、何が改善の機会なのかを特定します。その次は「探索する」こと。複数の解決策を考え、比較します。さらに進んで「決定する」こと。最適な方向性を選択します。最後に「実装する」こと。具体的な設計を作り上げます。この段階分けの本質は、各段階で問う質問が異なるということです。理解の段階では「これは何をしているのか？」と問います。分析の段階では「何が問題なのか？」と問います。探索の段階では「他にどんな方法があるか？」と問います。決定の段階では「どれを選ぶべきか？」と問います。実装の段階では「どう作るか？」と問います。これらの質問を同時に考えようとすると、頭が混乱します。「これは何をしているのか」を理解する前に「どう作るか」を考え始めると、理解が浅いまま実装に進んでしまいます。だから、今はどの質問に答えるべきかを明確にするのです。認知的な負荷で分割する各段階の中でも、さらに認知的な負荷を下げる工夫が必要です。「既存システムを理解する」という段階を考えます。これをいきなり「理解しよう」とすると、脳が過負荷になります。だから、行動を段階的に組み立てます。最初は受動的観察から始めます。まず2時間、コードを読む。この段階では理解を求めません。ただ情報を浴びるだけです。次に、浴びた情報から湧き上がった疑問を記録します。10個ほど疑問点をリストアップします。ここで初めて、受動的から能動的に切り替わります。その次に、記録した疑問を構造化します。技術的な疑問、ビジネス的な疑問、歴史的な疑問などにカテゴリ分けします。構造が見えたら、優先順位をつけます。最も重要な疑問を3つ選びます。そして最後に、その3つについて集中的に調査します。深い探索に入るわけです。なぜこの順番なのか？最初から「理解しながら読む」のは負荷が高すぎます。だから、まず受動的に情報を浴びる。負荷が低い状態から始めます。次に、浴びた情報から湧き上がった疑問を記録する。少し負荷が上がります。記録した疑問を整理して構造を見出す。さらに負荷が上がります。構造の中から優先順位を決める。そして初めて、深い理解のための調査に入る。最も負荷の高い活動です。このパターンの本質は、認知的な負荷を段階的に上げていくことです。脳は急激な負荷の変化に弱いですが、段階的な上昇には対応できます。自己完結性で分割するさらに、タスクには「自分だけで完結する部分」と「他者との関係が必要な部分」があります。これも分離して考える必要があります。例えば、「既存システムを理解する」の中で、自分だけでできることがあります。コードを読む、ドキュメントを読む、動かしてみる。これらは好きな時間に進められます。一方で、他者が必要なこともあります。設計の意図を聞く、過去の経緯を知る、暗黙の制約を確認する。これらは相手の都合を調整する必要があります。この区別が重要なのは、スケジューリングの戦略が異なるからです。自分だけでできることは、今日の夜でも、週末でも進められます。他者が必要なことは、早めに「誰に何を聞くべきか」を特定し、スケジュールを調整します。この区別をしないと、「調査は進んだけど、肝心なことを聞く相手が来週まで不在」という事態に陥ります。完璧な理解という幻想を捨てる最後に、最も重要な認識があります。完全な理解は存在しないということです。システムは複雑すぎて、すべてを理解することは不可能です。そして、理解が不完全でも、前に進むことはできます。重要なのは、「今の決定に必要な理解は何か」を見極めることです。「このAPIの実装を変更する」という決定には、APIの仕様と依存関係の理解が必要です。しかし、そのAPIが内部でどのアルゴリズムを使っているかまで理解する必要はないかもしれません。決定に必要な解像度で理解する。これが、複雑さを効率的に分割する鍵なのです。すべてを理解しようとすれば、永遠に理解のフェーズから抜け出せません。今の決定に必要な部分だけを、必要な深さで理解する。この割り切りが、現実の開発では不可欠です。3. 成果を定義する進捗を確認できなければ、正しい方向に進んでいるか分かりません。そして、確認できない進捗は、存在しないのと同じです。完璧主義は行動を妨げます。「完璧な設計書ができるまで実装を始めない」「すべてを理解してから手を動かす」—こうした態度は、実際には何も生み出しません。現実の開発では、不完全な成果を積み重ねながら前進します。だから、各段階で検証可能な成果物を定義します。完璧な成果物である必要はありません。むしろ、段階的な品質目標を設定します。最初は30%の理解で構いません。「全体像がぼんやり見える」程度で十分。この段階では、箇条書きのメモや疑問点のリストが成果物です。次に60%を目指します。「主要な構成要素と関係性が分かる」レベル。この段階では、ざっくりした図や主要な依存関係の整理が成果物です。そして80%、95%と段階的に精度を上げていきます。80%地点では、詳細な設計ドキュメントや実装計画が成果物になります。この段階的アプローチの真の価値は、早い段階でフィードバックを得られることです。30%の理解の時点で「方向性が間違っている」と気づけば、大きな手戻りを避けられます。完璧を目指して3ヶ月かけた後に方向性の誤りに気づくより、1週間で30%の成果を出して軌道修正する方が、はるかに賢明です。これがフィードバックループの設計です。小さく、速く、頻繁に。完璧ではなく、十分に良いものを、今日出す。4. 制約を明らかにするタスクは孤立して存在しません。そして、この事実を無視することは、失敗への近道です。現実の開発では、すべてのタスクが何かに依存しています。しかし、この依存関係は技術的なものだけではありません。むしろ、最も予測困難で致命的な依存関係は、人間の意思決定、暗黙の了解、組織の期待といった、目に見えない制約なのです。技術的な依存関係まず、明示的な技術的依存関係があります。これは比較的見つけやすい。この機能は認証システムに依存している。データベーススキーマの変更が必要。既存のAPIとの互換性を保つ必要がある。UIチームとの調整が必要。これらは図に描きやすく、「認証システムの理解が先」「スキーマ変更は早めに合意が必要」「UI設計は並行で進められる」といった戦略を立てられます。意思決定への依存関係しかし、より厄介なのは誰かの判断を待つ必要があるという依存関係です。この設計変更は、シニアエンジニアの承認が必要。この機能の優先順位は、プロダクトマネージャーの判断待ち。この技術選定は、セキュリティチームのレビューが必要。この仕様変更は、顧客への確認が必要。これらの依存関係が見えていないと、「実装は完了したのに、承認待ちで2週間止まっている」という事態に陥ります。そして、承認者が「そもそもこのアプローチは違う」と言い出せば、すべてが水の泡です。だから、早い段階で「誰の判断が必要か」「いつまでに確認を取るべきか」を明確にします。実装を始める前に、方向性の合意を取る。これだけで、大きな手戻りを避けられます。暗黙の了解への依存関係さらに難しいのが、チームや組織の暗黙の了解という制約です。「金曜日にはデプロイしない」というチームの不文律。「この部分のコードは○○さんしか触らない」という暗黙の領域分担。「新しいライブラリの導入は慎重に」という組織の雰囲気。「テストカバレッジは80%以上」という暗黙の品質基準。これらは明文化されていないため、新人エンジニアには見えません。しかし、この暗黙の制約に気づかずに進めると、「なぜ勝手に進めたんだ」と後から怒られることになります。この制約を明らかにするには、先輩に聞くしかありません。「このタスク、何か気をつけることありますか？」「この変更、誰かに相談した方がいいですか？」こうした質問が、暗黙の制約を顕在化させます。期待への依存関係最後に、最も主観的で曖昧な制約が他者の期待です。マネージャーは「2週間で完了する」と期待している。チームメンバーは「ドキュメントも一緒に更新される」と期待している。レビュアーは「テストコードも書かれている」と期待している。ユーザーは「UIは直感的である」と期待している。これらの期待は、しばしば明示的に伝えられません。しかし、期待に応えられないと、「思っていたのと違う」という不満が生まれます。期待を明らかにするには、早めに確認することです。「このタスク、どのレベルまで求められていますか？」「ドキュメントの更新も含めますか？」「いつまでに完了すればいいですか？」こうした質問で、期待のギャップを埋めます。制約を味方にする依存関係を明らかにすることは、ボトルネックの早期発見につながります。「このタスクは3人の承認が必要」と分かれば、並行で相談を始められます。「先輩が来週休暇」と分かれば、今週中に必要な情報を得ておきます。「この変更は影響範囲が広い」と分かれば、段階的なリリース計画を立てます。制約を敵視してはいけません。制約は現実です。そして、現実を直視することから、実行可能な計画が生まれるのです。見えない制約に後から気づいて慌てるより、最初から制約を前提に計画を立てる方が、はるかに賢明です。技術的な依存関係だけでなく、人間の意思決定、暗黙の了解、期待という目に見えない制約まで含めて考える。これが、現実の開発で生き残るための知恵なのです。実行可能な最小単位への変換ここが最も重要です。どれだけ丁寧に構造化しても、自分の現在のスキルと時間で実行できないなら、まだ抽象的すぎるのです。そして、これは単なる技術的な問題ではありません。心理的な問題でもあります。大きなタスクを前にしたとき、私たちは無意識に身構えます。「このタスクを完璧にこなすには、相当な気持ちの力が必要だ」と。その気持ちのハードルが高すぎて、結局何も始められない。先延ばしが続き、締め切り直前に慌てる。この悪循環を断ち切るには、最初の一歩のハードルを極限まで下げる必要があります。例えば、疲れて帰宅したとき。「お風呂にしっかり入浴しなきゃ」と思うと、それだけで億劫になります。でも「とりあえずシャワーだけ浴びよう」と思えば、動き出せます。そして実際にシャワーを浴び始めると、「あ、意外と平気だな。湯船にも浸かろうかな」となることも多い。完璧を目指さず、最小限から始める。この思考が、行動を生み出すのです。開発も同じです。「この一歩は、今日の30分で完了できるか？」と自問してください。答えがNoなら、さらに具体化します。「30分で完了できる最小の行動は何か？」を考えるのです。例えば、新しいフレームワークを学ぶとき。「Reactを学ぶ」は抽象的すぎます。「Reactの基礎を学ぶ」もまだ抽象的です。「Reactの公式チュートリアルの第1章を読む（30分）」なら実行可能です。「完璧に理解しよう」ではなく「まず読んでみよう」。「最適な設計をしよう」ではなく「ラフなスケッチを描こう」。「全部調べよう」ではなく「5分だけ調べよう」。この「実行可能な最小単位」への変換により、圧倒的な目標が、今すぐ始められる行動に変わります。そして一度動き出せば、継続するのは意外と簡単です。始めることが最大のハードルなのです。これは自分に優しくするということでもあります。「完璧にできないなら、やらない方がマシ」という思考は、結局何も生み出しません。「不完全でも、今日少しだけでも前進する」という姿勢が、長期的には大きな成果につながります。メンタル的にも、この小さな成功体験の積み重ねが重要です。「30分で第1章を読めた」という小さな達成感が、次の一歩への推進力になります。完璧主義で動けないより、不完全でも動き続ける方が、はるかに健全で生産的です。ライト、ついてますか　問題発見の人間学作者:ドナルド・C・ゴース,ジェラルド・M・ワインバーグ共立出版Amazonシステム思考との統合この「目標を構造化する技術」は、システム思考の実践そのものです。線形思考では「Aを完璧に終わらせてからBに進む」となります。しかし、これは現実的ではありません。Aを完璧にする頃には、Bの前提条件が変わっているかもしれません。市場が変化しているかもしれません。完璧を待つ余裕は、現実にはないのです。システム思考では小さなサイクルを回しながら学習するアプローチを取ります。30%の理解でまず動く。フィードバックを得る。それを元に次の30%を積み上げる。このフィードバックループが、不確実性の中での確実な前進を可能にします。そして重要なのは、この構造化のプロセス自体が学習であるということです。目標をどう分解するか考えることで、システムの構造が見えてくる。どこにレバレッジポイントがあるかが分かってくる。抽象的だった問題が、具体的な課題に変わっていく。新人エンジニアのあなたは、「自分にはまだ大きなことはできない」と思うかもしれません。しかし、逆です。大きなことができる人間などいません。いるのは、大きなことを小さく分解して、一歩ずつ進める人間だけです。その力さえあれば、いずれどんな大きな目標にも到達できます。明日、大きなタスクに圧倒されたら、紙とペンを持ってきてください。そのタスクを「時間を構造化する」「複雑さを分割する」「成果を定義する」「制約を明らかにする」の4つの視点で整理してみてください。そして、今日の30分でできる最小の行動を見つけてください。その一歩が、システム思考の実践の始まりです。完璧な計画ではなく、不完全でも今日動き出すこと。それが、本当の意味での第一歩なのです。フィードバックループの設計フィードバックループは私たちの考え方を強化します。良いフィードバックループは学習と改善を促進し、悪いフィードバックループは問題を固定化します。日本の開発現場でよく見かける「レビュー地獄」を考えてみましょう。コードレビューで細かい指摘が山のように来て、修正しては再レビュー、また修正しては再レビュー...。これは悪いフィードバックループの典型例です。なぜこうなるのでしょうか？レビュアーは「完璧なコード」を求め、レビュイーは「早く承認が欲しい」。この対立構造が、建設的でないフィードバックループを生み出しています。では、どう改善するか？まず、レビュイーであるあなたができることがある。PRの説明文に、単に「何を変更したか」だけでなく、「なぜこの変更が必要か」「何を解決しようとしているか」という意図を書く。そして、「他にどんな方法を検討したか」「なぜこの実装を選んだか」という設計判断を明記する。さらに、「ここは自信がない」「この部分、より良い方法があれば教えてほしい」という懸念点を正直に伝える。例えば、こんな風に書く：「ユーザーからの『検索が遅い』というフィードバックに対応しました。全文検索エンジンの導入も検討しましたが、今回は工数とのバランスを考えてインデックスの追加で対応しています。効果が見込め、リスクも低いと判断しました。ただし、N+1クエリになっている箇所があるかもしれません。パフォーマンステストはローカルのみです」。この説明があると、レビュアーはあなたの思考プロセスを理解でき、より建設的なコメントができる。レビュアー側も工夫できる。コメントにレベルを付けると、何が重要かが明確になる。例えば「🔴必須：セキュリティの問題」「🟡推奨：より良い実装方法の提案」「🔵参考：将来の改善案」という分類をすれば、レビュイーも「必ず直さなければならない」プレッシャーなく、建設的に受け取れる。「🟡推奨：ここはmapよりfilterの方が意図が明確になると思います」というコメントなら、対話が生まれる。もう一つの例として、レガシーコードの改善を考えてみよう。「このコードは触りたくない」という恐怖から、誰も手を付けず、ますます理解困難になる。これを打破するには、小さな改善と学びの記録というフィードバックループを作る。まず、小さなリファクタリング—1行の変数名変更でも良い—をする。その際、気づいたことをコメントかドキュメントに残す。次回触る人のために「ここは○○という理由で複雑」と書いておく。この積み重ねで、徐々にコードの理解が広がり、改善のハードルが下がっていく。新人エンジニアのあなたにできることは、自分のPRに「なぜこの実装を選んだか」「他に検討した選択肢」「懸念点」を明記することです。これによって、レビュアーはあなたの思考プロセスを理解し、より建設的なフィードバックを提供できるようになります。そして、それがチーム全体の学習を促進するのです。みんなのフィードバック大全作者:三村 真宗光文社Amazonパターン思考パターン思考は、出来事がどのように発生するかだけでなく、関係性がどのように効果を生み出すかを理解することです。新人エンジニアの日常で、こんなパターンに気づいたことはありませんか？月末になると必ずシステムが重くなる。調査すると、月次レポートのバッチ処理が原因だと分かる。でも、本当にそれだけでしょうか？よく観察すると、月末は営業チームのアクセスも増え、マーケティングチームのキャンペーンも集中し、経理のデータ抽出も重なっている。個々の要因は問題なくても、組み合わさると臨界点を超える。これがパターンです。日本の開発現場特有のパターンもあります。納期が近づくと、テストを省略し、コードレビューが形骸化し、ドキュメントの更新が止まる。その結果、リリース後に問題が頻発し、緊急対応に追われ、次の開発が遅れ、また納期に追われる...。これは負のスパイラルパターンです。では、パターンをどう見つけ、どう対応するか？まず、感覚ではなくデータで確認することが大切です。例えば、「納期2週間前からのコミット数」をグラフ化したり、「レビューコメント数」の推移を記録したり、「テスト実行時間」の変化を追跡したりする。Google SpreadsheetやNotionで簡単な表を作るだけでも、パターンが見えてきます。次に、パターンを3つのタイプから考えてみる。外部要因が影響する外部パターンとして、四半期末の駆け込み需要、年度末の仕様確定ラッシュ、イベント時のアクセス集中などがある。システム内部の問題である技術システムのパターンとして、特定の時間帯のトラフィック集中、定期的なメモリリーク、データ量が増えると遅くなる処理などがある。そしてチームの働き方に起因するプロセスパターンとして、週明けの障害報告増加、金曜リリースの失敗率上昇、特定のメンバーが休むと進まないタスクなどがある。このように分類することで、どこに問題の根があるのかが見えてくる。パターンを見つけたら、変えるための小さな実験を始めます。例えば「金曜リリースの失敗率が高い」というパターンがあったら、木曜リリースに変えてみたり、金曜は小規模な変更のみにしてみたりする。1ヶ月試してデータを取り、どちらが効果的か検証する。完璧な解決策を求めるのではなく、「とりあえず1週間やってみよう」という軽い気持ちで始めることが大切です。あなたのチームにも必ずパターンがあります。「いつも同じところでつまずく」「なぜか特定の機能の修正は想定の3倍かかる」。これらは偶然ではなく、システムが生み出すパターンなのです。パターンを見つけたら、「なぜこのパターンが生まれるのか」を問い、そしてパターンを変えるための小さな実験を始めるのです。類似と思考　改訂版 (ちくま学芸文庫)作者:鈴木宏昭筑摩書房Amazonモデリングモデリングは、私たちの心の中の考えと、それらの間の関係を可視化することです。 speakerdeck.comホワイトボードに図を描いたことがあるでしょう。それがモデリングの始まりです。しかし、「システム思考」は、チームで一緒にモデリングすることで初めて力を発揮します。重要なのは、何をモデル化するかよりも、どのようにモデル化するかです。モデルは会話の道具です。完璧な図を作ることが目的ではなく、チーム全体で共通の理解を作ることが目的なのです。新人エンジニアでもできる簡単なモデリングがある。新しい機能を追加するとき、5分だけ時間を取って紙に描いてみる。この機能は、どのモジュールを使うか？どのデータベーステーブルを読み書きするか？他のどの機能に影響するか？例えば、「新機能」から「認証モジュール」「ユーザーDB」「ログ機能」に矢印を引いてみる。そして気づく—「あ、ログ機能を変えると他にも影響が出るな」と。この簡単な図を描くことで、思わぬ依存関係が見えてくる。チームでシステムアーキテクチャを議論するときは、各メンバーが頭の中に持っているモデルは微妙に異なっています。これを可視化することで、誤解が明らかになる。実際の進め方は簡単だ。各自が5分で「システムの全体像」を紙に描き、それを見せ合い、違いを話し合う。「え、僕はこのAPIを直接叩いていると思っていたけど、実はキャッシュ層があったんだ」といった発見が必ずある。モデルを描くとき、3つの質問を考えるといい。まず「このシステムの目的は何か？」—例えば「ユーザーが商品を素早く見つけられること」。次に「誰にとっての価値を生み出しているのか？」—例えば「エンドユーザー」「営業チーム」「データ分析チーム」。そして「どんな制約があるのか？」—例えば「レスポンスは1秒以内」「既存のレガシーDBと連携が必要」。これらの質問に答えることで、単なる「構成図」ではなく、「なぜそうなっているか」が分かるモデルになる。ツールは何でもいい。ホワイトボード、紙とペン、MiroやFigJam（オンラインホワイトボード）、PlantUMLやMermaid（コードで図を描く）、PowerPointやGoogle Slides。どんなツールでも構わない。完璧なモデルを作ることが目的ではありません。モデリングのプロセスを通じて、チーム全体の理解を深め、より良い意思決定ができるようになることが目的なのです。あなたが明日から始められることは、コードを書く前に5分だけホワイトボード（または紙）に図を描くことです。それをSlackに貼って「この理解で合ってますか？」と聞くだけでも、大きな価値があります。システムリーダーシップシステムリーダーシップとは、役職や権限の話ではありません。システムリーダーシップは、私たちがいつでも実践できるものです。線形と非線形のアプローチの違いを識別し、状況に最も適したマインドセットを選択すること。社会技術的部分間の健全な関係を奨励すること。解決策をシステムの目標と目的につなげ続けること。積極的に視点をシフトし、複数の視点から課題を見ること。曖昧さへの寛容を表現すること。これらは、ジュニアエンジニアでも、シニアエンジニアでも、誰でも実践できることです。システムリーダーシップは統合的リーダーシップであり、変化のエコロジーを開発することです。階層は管理構造ではなくコミュニケーション構造です。より高いレベルの機能は、より低いレベルの活動のニーズに奉仕します（その逆ではありません）。最も価値のある貢献は、レバレッジポイントの発見です。これらは、パターンと関係に介入する場所です。小さな変更で大きな影響を与えられる場所を見つけることが、システムリーダーの重要な役割です。戦略の要諦 (日本経済新聞出版)作者:リチャード・Ｐ・ルメルト日経BPAmazon成功の再定義システムの観点から、成功はシステムを支配することではなく、その中で繁栄することによって測定されます。従来の成功の定義は、「計画通りに完了した」「バグがゼロになった」「パフォーマンス目標を達成した」といったものでした。これらも重要ですが、システム思考の観点からは不十分です。成功したシステムには、異なる特徴があります。制約の有効化とは、システムが全体のニーズに奉仕しながらスケールすることを可能にする成長または影響の制限です。無制限の成長は破綻を招きます。適切な制約があることで、持続可能な成長が可能になります。根本原因の解決は、介入依存（根本的な問題を解決する代わりに修正やバンドエイドを適用すること）を避けることです。症状に対処するのではなく、原因に対処することで、同じ問題の再発を防げます。影響の均等化において、成功したシステムは、利点と特権の影響を均等化します。一部のコンポーネントやチームだけが恩恵を受けるのではなく、全体が公平に価値を享受できるシステムが、長期的に成功します。知識フローの生成は最も重要かもしれません。システムの知識フローが多いほど、透明性が高いほど、そのシステムの成功の可能性が高くなります。情報が自由に流れ、学習が共有され、失敗が隠されない文化が、システムの進化を促進するのです。これらの新しい成功の基準は、短期的な目標達成よりも、長期的な持続可能性と適応力を重視します。システムは生き物のように成長し、変化し、進化するものだからです。失敗できる組織作者:エイミー・C・エドモンドソン早川書房Amazonまとめ前回の記事でシステム思考の基本概念を学び、今回は実践の方法を見てきました。その旅を通じて改めて感じるのは、システム思考は単なる技術ではなく、現代を生きるための基本的な教養だということです。個々の技術力は依然として重要です。しかし、それだけでは複雑化する課題に対応できません。目の前のコードから視線を上げ、全体の中での位置づけを理解し、相互作用を設計する—これがシステム思考なのです。ドネラ・メドウズは言いました。「私たちはシステムを制御したり、理解したりすることはできません。しかし、それらと踊ることはできます！」この美しい比喩は、システム思考の本質を表しています。完全な制御を求めるのではなく、システムと調和し、共に進化していく。完璧な設計図を描いてから実装するのではなく、対話しながら進化させていく。予期せぬ振る舞いを「バグ」として排除するのではなく、フィードバックとして学習する。この姿勢の転換が、真に価値のあるソフトウェアシステムを生み出します。この記事で紹介した実践は、すべて明日から使えるものです。自己認識とメタ認知で、自分ならではの問いを生み出す土壌を耕すこと。違和感に気づき、「なぜ？」と問い続けることで、問いの編集力を磨いていく。反応から応答への転換で、即座に否定するのではなく、まず受け止めることから対話を始める。「でも」ではなく「なるほど、では」と応答する習慣が、チームの知恵を引き出します。目標の構造化で、圧倒的なタスクを実行可能な最小単位に変換する。時間を構造化し、複雑さを分割し、成果を定義し、制約を明らかにする。そして何より、「今日の30分でできること」に落とし込む。フィードバックループの設計で、小さく、速く、頻繁に学習する仕組みを作る。PRに「なぜ」を書き、レビューに段階を付け、小さな改善を積み重ねていく。パターン思考で、繰り返される問題の背後にある構造を見抜く。データで確認し、小さな実験で変化を試みる。モデリングで、見えない構造を可視化し、チームで共通理解を作る。完璧な図ではなく、5分で描いたラフなスケッチでも、対話の価値は十分にあります。これらの概念を完璧に理解する必要はありません。「あ、これは問いの編集で考えられるかも」と思い出すだけで、視点が変わります。明日のコードレビューで「このコードは他のどこに影響するだろう？」と問いかけてみてください。バグを修正するとき、「このバグ、前にも似たようなことがあったな」という違和感を大切にしてください。新しい機能を実装する前に、5分だけ紙に依存関係を描いてみてください。新人エンジニアだからこそ持てる「なぜ？」という素朴な疑問が、ベテランが見落としているシステムの問題を発見する鍵になることがあります。「そういうものだ」と受け入れられていることに「でも、なぜ？」と問う勇気を持ってください。今日から、目の前の木だけでなく、森全体を見る練習を始めましょう。制御ではなく調和を、固定ではなく適応を、確実性ではなく学習を選ぶ。きっと、今まで見えなかった景色が見えてきます。最後に、最も大切なことを。システム思考は完璧主義ではありません。「すべてを理解してから行動する」のではなく、「小さく始めて、学びながら改善する」ことを大切にします。だから、この記事を読んで「難しそう」と感じても大丈夫です。まずは一つだけ、明日から実践してみてください。それで十分です。そして、この記事に書いてあることがすべてではありません。システム思考の実践は、あなた自身の経験の中で深まり、独自の形を取っていくものです。一緒にシステムと踊り始めましょう。システムの科学 第3版作者:ハーバート・Ａ・サイモンパーソナルメディアAmazon","isoDate":"2025-10-01T11:39:24.000Z","dateMiliSeconds":1759318764000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"システムを作る人がまず理解すべきシステム思考の基礎","link":"https://syu-m-5151.hatenablog.com/entry/2025/10/01/203633","contentSnippet":"はじめに先日、若いエンジニアと話をしていて、システム思考について話題になった。「物事を個別に捉えるのではなく、全体の関係性や相互作用を理解する考え方」—これがシステム思考の本質だ。僕は彼に、これはどんな分野でも応用できる基本的な教養だと伝えた。特にシステムを構築する立場の人には重要だけど、そうでなくても持っておいて損のないスキルだと。世界はシステムで動く ― いま起きていることの本質をつかむ考え方作者:ドネラ・Ｈ・メドウズ英治出版Amazonその会話を終えた後、ふと考えた。僕たちエンジニアは日々システムを作っているのに、どれだけ「システムとして」物事を考えているだろうか、と。あなたは日々、コードを書いている。機能を実装し、バグを修正し、システムを構築している。そして、予想外の挙動に困惑することがあるかもしれない。完璧に動くはずの機能が、別の機能と組み合わせると謎の不具合を起こす。チーム間の連携がうまくいかず、同じ問題が何度も繰り返される。「なぜこんなことが起きるのだろう？」と。実は、僕たちの多くは「部品を組み立てる」思考法で「生きたシステム」を作ろうとしているのかもしれない。プラモデルを思い出してほしい。説明書通りにパーツを組み立てれば、完成形は予測できる。壊れたら、その部品だけを交換すれば直る。これが部品思考だ。僕たちはプログラミングを学ぶとき、まずこの思考法を身につける。関数を書き、クラスを設計し、モジュールを組み合わせる。入力に対して出力が決まっている、予測可能な世界。しかし、実際のソフトウェアシステムは、プラモデルというより生態系に近い。池に石を投げると波紋が広がり、その波紋が岸に反射し、さらに複雑な模様を作る。一匹の魚が動けば、水流が変わり、他の魚の行動も変わる。すべてが相互に影響し合い、予測困難な振る舞いを見せる。現代のソフトウェア開発は、まさにこの生態系を扱う仕事だ。マイクロサービス、API連携、非同期処理、分散システム。個々の部品の品質だけでなく、それらの相互作用が全体の振る舞いを決める世界なのだ。この記事では、システム思考とは何か、なぜそれが新人エンジニアにとって不可欠なのかを解説したい。完璧な理論ではなく、あなたの日常の開発体験を変える実践的な視点を提供できればと思う。システム思考は難しく聞こえるかもしれないが、今日から始められる小さな習慣がある。まず、バグが発生したらすぐに修正するのではなく、立ち止まって考えてみる。「このバグ、前にも似たようなことがあったな」という違和感。「なぜかこの機能だけいつも問題が起きる」という引っかかり。この違和感に気づく習慣が、システム思考の第一歩だ。そして、一つの視点だけでなく、多角的に問いかけてみる。技術的な問題だろうか？それとも仕様の理解が曖昧だったのか？チームのコミュニケーションに課題があったのか？こうした多面的な視点が、出来事の背後にあるパターンや構造を浮かび上がらせる。次に、コードを変更する前に、紙やホワイトボードに簡単な図を描く習慣をつける。「このファイルを変更すると、どのモジュールに影響するか？」「どのチームが関係するか？」「どのユーザー機能に影響するか？」。最初は5分で構わない。これを習慣にすることで、システム全体を見る視点が養われる。そして、PRの説明文に「何を」変更したかだけでなく、「なぜ」その実装を選んだのか、他にどんな選択肢があったのか、何を考慮したのかを書く。これはレビュアーのためだけでなく、3ヶ月後の自分のためでもある。システムの背景や意図が言語化され、チーム全体の理解が深まる。これらは特別なツールも会議も不要だ。明日のコーディングから始められる。小さな実践の積み重ねが、やがてシステム思考を自然な習慣に変えていく。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。線形思考の限界「このコードを書けば、この結果が得られる」「この設計にすれば、このパフォーマンスが出る」「この人数を投入すれば、この期日に間に合う」ようこそ！FACT(東京S区第二支部)へ（１） (マンガワンコミックス)作者:魚豊小学館Amazonこんな風に考えたことはありませんか？ これが線形思考です。私たちは線形思考を教えられてきました。予測可能で、合理的で、再現可能で、手続き的で、二元論的で、トップダウンで、制御に関心を持つ思考。「if this, then that」の因果関係に支配された思考で、ソフトウェアシステムがすべての状況において、私たちが意図したとおりに正確に動作することを期待します。しかし、実際のシステムは生態系のように振る舞います。単純な原因と結果の連鎖ではなく、複雑な相互作用の網の目なのです。あるAPIの応答速度を改善したら、別のサービスに負荷が集中してシステム全体のパフォーマンスが悪化した。キャッシュを導入したら、データの整合性問題が頻発するようになった。こんな経験はないでしょうか？ これらは、システムの非線形性を示す典型的な例です。非線形ということの最も単純な形は、システムは完全には制御できず、予測不可能だということです。部分間の関係が、何が起こるかに影響を与えるのです。一つの変更が、思わぬ波及効果を生み出し、それがさらに別の効果を引き起こす。この連鎖は、事前に完全に予測することはできません。そして、この非線形性を理解し、それと共に働く方法を学ぶこと。それがシステム思考への第一歩なのです。システム思考とは何かシステムとは何でしょうか？ それは単なる「複雑なソフトウェア」ではありません。実践システム・シンキング　論理思考を超える問題解決のスキル (ＫＳ理工学専門書)作者:湊宣明講談社Amazonシステムとは、共有された目的に奉仕するために相互作用し、相互依存する、相互関連したハードウェア、ソフトウェア、人々、組織、その他の要素のグループです。あなたが開発しているWebアプリケーションも、それを使うユーザーも、運用チームも、ビジネス要求も、すべてが一つのシステムを構成しているのです。そしてシステム思考とは、「一緒に実践すると非線形思考スキルを向上させる、基礎的な思考実践のシステム」です。これは知識ではなく、実践なのです。テニスについての本を読んでもテニスはできるようになりません。外に出てテニスをプレイする必要があります。システム思考も同じです。概念を理解するだけでなく、日々の開発の中で実践し、体得していく必要があるのです。AIがもたらすことをシステム思考で理解するシステム思考が実際にどう役立つのか、今まさに起きている事例で見てみよう。AIによるコード生成だ。この新しい技術は、一見すると開発を加速させる魔法のツールに見える。しかし、システム思考の視点で深く掘り下げると、そこには三つの重要な非対称性が潜んでいることが見えてくる。第一の非対称性：生産と理解の乖離AIがコードを書くようになって、開発速度は確かに上がった。数分で数百行のコードが生成される。しかし、そのコードを修正しようとした時、予想以上に時間がかかることに気づいた人も多いだろう。これは非線形性の典型例だ。「生産速度を上げれば開発が速くなる」という線形思考は、一見正しく見える。しかし実際のシステムでは、コードを安全に変更するには、まずそのコードを理解する必要がある。システム内にコードが流入する速度と、人間がそれを理解する速度の間に、決定的な非対称性が生まれているのだ。氷山モデルで分析してみよう。表面に見えているのは「AIで開発が速くなった」という出来事だ。しかしその下には、「変更に時間がかかるようになった」というパターンがある。さらにその下には、「生成速度と理解速度の不均衡」という構造がある。そして最も深い層には、「速さこそが価値」「生産量で生産性を測る」というメンタルモデル（考え方の前提）がある。第二の非対称性：生産量と成長の乖離しかし、問題の本質はさらに深いところにある。生産量とエンジニアとしての地力の成長の非対称性—これこそが、長期的に見て最も深刻な問題だ。AIを使えば、経験1年目のエンジニアでも、大量のコードを生産できる。PRの数も増え、機能の実装スピードも上がる。しかし半年後、1年後、その人のエンジニアとしての地力はどうなっているだろうか？問題を自分で分析し、設計を考え、トレードオフを検討するプロセス—これこそが、エンジニアの地力を育てる。しかしAIに頼りすぎると、この思考プロセスそのものを外部化してしまう。「どう実装するか」をAIに聞き、「なぜその設計なのか」を考えずに進める。短期的には生産的だが、長期的には考える力が育たない。同じく氷山モデルで分析すると、表面の出来事は「仕事量は増えている」だ。しかしパターンを見ると「似た問題に何度も遭遇し、毎回AIに頼っている」「自力で解決できる問題の範囲が広がらない」という現象が浮かび上がる。構造を掘り下げると「思考プロセスの外部化による成長機会の喪失」が見える。そして根底には「アウトプットの量こそが成果」「速く結果を出すことが全て」というメンタルモデルがある。これは特に新人エンジニアにとって危険だ。経験年数は増えても、地力は停滞する。仕事量と本当の力が比例しないというシステムの非線形性が、キャリアの基盤を蝕んでいく。3年後、5年後に「AIなしでは何もできない」状態になっている可能性がある。第三の非対称性：経験の量と学びの質の乖離ここまで読んで、反論したくなった人もいるだろう。「AIを使うこと自体がスキルではないか？ AIをうまく使えるようになることが、現代のエンジニアに求められているのでは？」確かにその通りだ。AIを効果的に使うには、適切なプロンプトを書く力、生成されたコードの良し悪しを判断する力、AIの限界を理解する力が必要だ。AIを使えば使うほど、AIを使うスキルは向上する。これも事実だ。しかし、ここにも非線形性が潜んでいる。問題は何の力が伸びているかだ。AIとの対話がうまくなることと、ソフトウェア設計がうまくなることは、別のスキルだ。プロンプトを洗練させることと、アルゴリズムを理解することは、別の能力だ。AIの出力を評価できることと、自分で最適な解を導き出せることは、別の次元の話だ。そして、より本質的な問いがある。「何を経験したか」ではなく、「そこから何を学んだか」が重要なのだ。毎日AIを使って100行のコードを書く経験を1年積んだとしよう。しかし、そこから「AIへの依存」しか学ばなければ、その経験はエンジニアとしての地力にはつながらない。一方、週に1回しかAIを使わなくても、「なぜAIはこのアプローチを提案したのか」「他にどんな選択肢があったか」「この設計の背後にある原則は何か」を考えながら使えば、その経験は深い学びになる。システム思考では、これを学習のフィードバックループと呼ぶ。経験（Experience）→ 振り返り（Reflection）→ 学び（Learning）→ 実践（Practice）→ 経験、というサイクルだ。このループが回っているか、それとも単に経験を積み重ねているだけか。この違いが、長期的な成長を決定する。AIを大量に使っているのに成長しない人は、経験だけが積み上がり、振り返りと学びのステップが欠けている。一方、AIを適度に使いながら成長する人は、このループを意識的に回している。「今、自分は何を学んでいるか？」というメタ認知が、すべての違いを生む。たとえば、AIに複雑なアルゴリズムを実装させたとしよう。成長しない使い方は「動いた、完了」で終わる。成長する使い方は、生成されたコードを見て「なぜこの時間計算量なのか？」「なぜこのデータ構造を選んだのか？」「もっと効率的な方法はないか？」と問いかける。そして、自分でも実装してみて、AIの提案と比較する。この意図的な学習プロセスがあるかないかで、同じAI利用経験が、まったく異なる成長につながる。三つの非対称性が示すものAIがもたらしたのは、三つの相互に関連した非対称性だ。生産と理解の非対称性、生産量と成長の非対称性、そして経験の量と学びの質の非対称性。これらは別々の問題ではなく、一つのシステムとして機能している。速く書けることを追求すれば、理解が追いつかなくなる。理解しないまま大量に生産すれば、思考力が育たない。そして経験を積んでも、そこから学ばなければ、成長は起きない。システム思考が教えてくれるのは、これらの問題を個別に対処しても意味がないということだ。根底にあるメンタルモデル—「速さが価値」「量が成果」「経験が成長」—を変えない限り、どんな対症療法も一時的な効果しか生まない。必要なのは、システム全体を理解し、深い層から変革することなのだ。どこに介入すれば効果的かこの構造を変えずに、出来事のレベルだけで対処しようとすると問題は悪化する。「変更に時間がかかる？ではAIにもっと変更させよう」という対応は、理解されないコードをさらに増やすだけだ。では、どこに介入すれば効果的だろうか。システム思考では、レバレッジポイント—小さな変更で大きな影響を与えられる場所—を見つけることが重要だ。最も深い層であるメンタルモデルを変革することが、第一のレバレッジポイントだ。「速く書けることが価値」から「理解できることが価値」へ。「大量に生産することが成長」から「深く考えることが成長」へ。そして「多くを経験することが成長」から「経験から学ぶことが成長」へ。チームで「このコードを6ヶ月後の自分たちは理解できるか」という基準を共有する。生産性の測定も、コード行数ではなく、「変更可能性」で評価する。個人の評価も、「何本PRを出したか」ではなく、「どれだけ難しい問題を自力で解決したか」「どれだけ設計の理解が深まったか」を重視する。この転換がなければ、どんな対症療法も一時的な効果しか生まない。次に、フィードバックループを設計し直すことが効果的だ。具体的には、AIが生成したコードには「なぜこのアプローチを選んだか」を必ず追記する。コードレビューでは「このコードは理解できるか」を明示的にチェック項目に入れる。PRの説明文に「3ヶ月後の自分が読んで理解できるか」を自問する。そして重要なのは、「このコードを自分で書けるだけの理解があるか」「今日、AIを使って何を学んだか」を自問することだ。AIの提案を鵜呑みにせず、なぜそのアプローチなのか、他にどんな選択肢があったのかを考える。毎日の終わりに5分、「今日AIに任せた部分で、理解が曖昧なところはどこか」を振り返る。これらの小さな習慣が、経験を学びに変換し、チーム全体の理解を促進し、個人の成長を加速させる。そして、適切な制約を設けることも重要だ。プロトタイピングではAIを積極的に使い、本実装では人間が設計してから使う。AIが生成したコードは、必ず一度すべて読んでから取り込む。週に一度、「今週AIに生成させたコードで理解が曖昧な部分」をチームで確認する。さらに、意図的にAIを使わない時間を設けることも効果的だ。難しい問題に遭遇したとき、まず30分は自分で考える。設計の選択肢を自分でリストアップしてから、AIの意見を参考にする。週に一度は、AIなしで機能を実装してみる。無制限にAIを使うのではなく、こうした制約がシステム全体の健全性と、個人の成長を両立させる。新人エンジニアのあなたに伝えたいのは、AIを使うこと自体が問題なのではないということだ。問題は、生産と理解の非対称性を無視することであり、さらに言えば、生産量とエンジニアとしての地力の成長の非対称性を無視することだ。そして、経験の量と学びの質を混同することだ。あなたがAIを使ってコードを書くとき、「このコードを3ヶ月後の自分は理解できるだろうか」「チームの他のメンバーは理解できるだろうか」と問いかけてみてほしい。そして同時に、「今、自分は本当に考えているだろうか」「このプロセスで自分は何を学んでいるだろうか」「今日の経験から、明日使える原則を抽出できているだろうか」と問いかけてほしい。速く書けることと、持続可能なシステムを作ることは、別の話なのだ。そして、たくさん作ることと、エンジニアとして成長することも、別の話なのだ。さらに言えば、たくさん経験することと、深く学ぶことも、別の話なのだ。概念的完全性フレッド・ブルックスは『人月の神話』で「概念的完全性はシステム設計において最も重要な考慮事項である」というようなことを言っている。人月の神話作者:フレデリック・P・ブルックス，Jr.,滝沢徹,牧野祐子,富澤昇丸善出版Amazonでも、概念的完全性って何でしょうか？簡単に言えば、システム全体が一つの統一された設計思想で貫かれている状態です。ここで言う「概念」とは、アイデアが形を成し、明確な意味を持つようになったもの。「オブジェクト指向」「非同期処理」といった、定義可能な考え方のことです。例えば、Unixには「すべてはファイル」という設計思想があります。デバイスも、プロセス間通信も、ネットワーク接続も、すべてファイルとして扱う。この一貫した思想があるから、cat、grep、sedといったシンプルなコマンドを組み合わせて、複雑な処理ができるのです。逆に、概念的完全性が欠如したシステムはどうなるでしょうか？あるAPIエンドポイントはRESTful、別のエンドポイントはRPC風。あるデータはJSON、別のデータはXML。エラーハンドリングも、ある部分は例外を投げ、別の部分はエラーコードを返す。多くの良いアイデアが、調整されずにバラバラに実装されている状態です。新人エンジニアのあなたも、こんなコードベースに遭遇したことがあるかもしれません。「なぜこんなにやり方がバラバラなの？」と困惑した経験があるでしょう。それは、概念的完全性が失われた結果なのです。概念的完全性を保つには、「このシステムの核となる考え方は何か」を常に問い続ける必要があります。新機能を追加するとき、「これは既存の設計思想と一致しているか」を確認する。もし一致しないなら、設計思想を進化させるか、別のアプローチを考える必要があります。例えば、「すべての操作を非同期で処理する」という設計思想があるシステムに、同期的な処理を追加すると、概念的完全性が崩れます。しかし、「ユーザー体験を最優先する」という、より高次の設計思想があれば、「即座にフィードバックが必要な操作は同期、それ以外は非同期」という一貫した判断基準が生まれます。概念的完全性は、システムを理解しやすく、保守しやすく、拡張しやすくするのです。関係性が効果を生むドネラ・メドウズはシステム思考を「部分が一緒になって、各部分が単独で生み出す効果とは異なる効果を生み出すこと」と定義しています。関係性が効果を生み出すのです。マイクロサービスアーキテクチャを考えてみてください。個々のサービスは完璧に動作していても、それらの間の通信パターン、データの流れ、障害の伝播の仕方によって、システム全体の振る舞いは大きく変わります。具体例を見てみましょう。あなたのチームがECサイトを開発しているとします。「商品検索」「カート」「決済」の3つのサービスがあり、それぞれは単独で問題なく動作します。しかし、セール時に検索サービスへのアクセスが急増すると、その負荷がカートサービスに波及し、最終的に決済が遅延する。サービス間の「関係性」が、予期せぬ障害を生み出したのです。重要なのは、ソフトウェアシステムが技術だけでなく人も含むということです。コードだけがシステムではありません。それを書く開発者、使うユーザー、運用するチーム、すべてがシステムの一部なのです。「コンウェイの法則」を聞いたことがあるでしょうか？「システムを設計する組織は、その組織のコミュニケーション構造をコピーした設計を生み出す」というものです。これは非常に興味深い法則です。チームトポロジー　価値あるソフトウェアをすばやく届ける適応型組織設計作者:マシュー・スケルトン,マニュエル・パイス日本能率協会マネジメントセンターAmazon例えば、フロントエンドチームとバックエンドチームが別の場所にいて、週1回しか会議をしない組織では、API設計がきっちり固められ、変更しにくいものになりがちです。一方、同じ部屋で毎日顔を合わせるチームでは、より柔軟で変更しやすいインターフェースが生まれやすい。組織の構造が、そのままシステムの構造に反映されるのです。だから、「技術的負債を解消する」だけでは不十分です。「なぜその負債が生まれたか」という組織的・文化的な要因も同時に扱う必要があります。技術システムと人のシステムは、切り離せない一つの全体なのです。反直感性「このプロジェクトは遅れている。もっと人を投入しよう」人が増えても速くならない ～変化を抱擁せよ～作者:倉貫 義人技術評論社Amazonこれは理にかなっているように聞こえます。しかし、ブルックスの法則は「遅れているソフトウェアプロジェクトに人員を追加すると、さらに遅れる」と教えています。なぜでしょうか？反直感性とは、直感的に正しいと思える解決策が、実際には問題を悪化させる現象です。システム思考において、これは最も重要な概念の一つです。人を増やすと生産性が上がる、これは工場のライン作業なら正しいかもしれません。しかし、ソフトウェア開発では違います。新メンバーの教育コスト、コミュニケーションパスの増加（n人なら n(n-1)/2 の組み合わせ）、意思決定の複雑化。これらの隠れたコストが、追加された人員の生産性を上回ってしまうのです。日本の開発現場でもよく見る例があります。「品質が悪いからテストを増やそう」。しかし、無意味なテストが増えるだけで、本質的な品質は改善しない。むしろ、テストのメンテナンスコストが増大し、開発速度が低下する。「ドキュメントが足りないから、すべてを文書化しよう」。結果、誰も読まない膨大なドキュメントが生まれ、更新されずに陳腐化し、かえって混乱を招く。これらはすべて、システムの一部だけを見て、全体の相互作用を考慮しなかった結果です。反直感性を理解するには、「この解決策を実施したら、他の部分にどんな影響があるか」を考える必要があります。そして多くの場合、真の解決策は、問題とは違う場所にあるのです。品質が悪いなら、テストを増やすのではなく、設計を見直す。ドキュメントが足りないなら、全てを文書化するのではなく、コードを自己文書化する。プロジェクトが遅れているなら、人を増やすのではなく、スコープを削減する。直感に反する解決策こそが、しばしば最も効果的なのです。氷山モデルバグが発生しました。修正しました。同じようなバグがまた発生しました。また修正しました。こんなサイクルを繰り返していませんか？氷山モデルは、出来事の表面下にある根本的な原因を探るためのツールです。氷山の一角だけを見ていては、本当の問題は解決できません。氷山モデルは4つの層から成ります。最も表面にあるのが「出来事（Events）」—目に見える現象です。例えば「本番環境でNullPointerExceptionが発生した」という具体的な問題がこれにあたります。その下にあるのが「パターン（Patterns）」—繰り返される傾向です。例えば「毎週金曜日のリリース後に、似たようなエラーが発生している」という規則性に気づいたら、それは単なる偶然ではなく、システムが生み出しているパターンかもしれません。さらに深い層にあるのが「構造（Structure）」—パターンを生む仕組みです。例えば「金曜日は全員がリリースを急ぐため、レビューが形骸化している。テスト環境と本番環境のデータに差がある」といった、システムの要素がどのように配置され、関係しているかの枠組みがこれにあたります。そして最も深い層にあるのが「メンタルモデル（Mental Models）」—根底にある考え方です。例えば「週末前には必ずリリースしなければならない」「テストで動けば本番でも動くはず」といった、チームが無意識に共有している前提や信念です。多くの場合、私たちは出来事のレベルで対応します。バグを修正して終わり。しかし、それでは同じ問題が繰り返されます。本当の解決は、より深い層にアプローチすることです。具体的な使い方を見てみましょう。あなたのチームで「デプロイ後に障害が頻発する」という問題があったとします。出来事として見えているのは「今週も本番でエラーが起きた」ということ。しかし過去3ヶ月を振り返ると、毎月第2週の金曜に障害が起きているというパターンが見えてきます。さらに掘り下げると、第2週は月次リリースと重なり、テストが不十分なまま本番投入しているという構造が見えてきます。そして最も深い層には、「月次リリースは絶対に守るべき」「遅らせることは失敗」というメンタルモデルが潜んでいます。この場合、構造やメンタルモデルを変えない限り、問題は繰り返されます。解決策は、リリースプロセスを改善する（構造の変更）、あるいは「品質を犠牲にしてまで月次リリースを守る必要はない」という考え方を共有する（メンタルモデルの変更）ことかもしれません。新人エンジニアのあなたにできることは、出来事の背後にある深い層を探ることです。単に「どう直すか」だけでなく、各層を意識しながら掘り下げるのです。これが、はじめに紹介した「違和感に気づく習慣」の深い意味です。「このバグ、前にも似たようなことがあったな」という違和感から、パターンを見つける。「なぜこのパターンが繰り返されるのか」と考えることで、構造が見えてくる。そして「私たちは何を当たり前だと思っているのか」と問うことで、メンタルモデルに気づく。この階層的な分析が、システム思考の核心なのです。まとめここまで、システム思考の基礎的な概念を見てきました。線形思考の限界、非線形性、関係性、反直感性、氷山モデル—これらは、システムを「生態系」として理解するための基本的な視点です。重要なのは、これらが単なる理論ではなく、日々の開発で使える実践的な道具だということです。バグに遭遇したとき、氷山モデルを思い出す。新機能を設計するとき、関係性を考える。直感的な解決策を思いついたとき、反直感性を疑ってみる。プラモデルのように部品を組み立てるのではなく、生態系のように全体の相互作用を設計する。完全な制御を求めるのではなく、システムと調和し、共に進化していく。これがシステム思考の本質です。次は、この基礎知識をもとに、具体的にどうシステム思考を日々の開発に取り入れていくかを見ていきましょう。自己認識、問いの立て方、フィードバックループの設計、パターンの見つけ方—明日から使える実践的な方法があります。基礎を理解したあなたは、もう準備ができています。syu-m-5151.hatenablog.com","isoDate":"2025-10-01T11:36:33.000Z","dateMiliSeconds":1759318593000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"バイブコーディングと継続的デプロイメント","link":"https://speakerdeck.com/nwiizo/baibukodeingutoji-sok-de-depuroimento","contentSnippet":"2025年9月30日（火）、「バイブコーディングもくもく会 #03」というイベントで登壇することになった。\rhttps://aimokumoku.connpass.com/event/368935/\r\r正直に言うと、このイベントがどんな空気感なのか、まだ全然掴めていない。ゆるい感じなのか、ガチな感じなのか。笑いを取りに行くべきなのか、真面目にやるべきなのか。そういう「場の空気」みたいなものが事前に分からないのは、けっこう怖い。だから、とりあえず色々なパターンを想定して準備している。要するに、どんな状況になっても対応できるように、という保険をかけまくっているのだ。我ながら、慎重すぎるかもしれない。\r\rブログとGithubはこちら。\rhttps://syu-m-5151.hatenablog.com/\rhttps://github.com/nwiizo\r\r一応、置いておく。見られるのは恥ずかしいけど、見られないのも寂しい。そういう矛盾した感情を抱えながら、当日を迎えることになりそうだ。Marp の資料はこちらです。\rhttps://github.com/nwiizo/3shake-marp-templates/blob/main/slides/2025/vibe-coding-continuous-deployment.md","isoDate":"2025-09-30T04:00:00.000Z","dateMiliSeconds":1759204800000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"エンジニアはちゃんと身銭を切れ","link":"https://syu-m-5151.hatenablog.com/entry/2025/09/22/175353","contentSnippet":"はじめにnekogata.hatenablog.comを読みました。オーナーシップを阻害する構造的な問題について丁寧な分析がされていて、なるほどと思う部分が多かった。しかし、私はこの問題の核心はもっとシンプルなところにあると考えている。エンジニアが身銭を切っていない。それだけだ。構造を変えても、制度を整えても、身銭を切らないエンジニアは責任を取らない。逆に、どんな環境でも身銭を切るエンジニアは結果を出す。言い方はなんでもよいが私はそういう覚悟のキマったエンジニアを何人も見てきた。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。身銭を切るとは何か身銭を切るとは、「リスクと責任を自ら引き受け、成功すれば報酬を、失敗すれば代償を受け入れる覚悟を持つこと」だと、私は理解している。ナシーム・ニコラス・タレブが『身銭を切れ: SKIN IN THE GAME』で示した原理をエンジニアリングに当てはめて考えると、コードを書いた者、システムを構築した者が、その結果から逃れられない状況に自らを置くことを意味するのではないか。成功の果実を享受するなら、失敗のリスクも引き受ける——この対称性があってこそ、プロフェッショナルと呼べるのかもしれない。これは給料が減るとか、クビになるとか、そういった話ではないと思う。自分の評判、プライド、チームからの信頼、深夜の時間、精神的なストレス——これらを賭けて仕事に臨むことが、身銭を切るということではないだろうか。タレブはこれを「魂を捧げる」（Soul in the Game）とも表現する。金銭的損失より、こうした目に見えない資産の方が取り戻すのは困難だ。タレブの倫理観の根底にはリバタリアニズムがあるという。自由に選択する権利と、その帰結を受け入れる責任は不可分だ。エンジニアとして技術選定の自由を求めるなら、その結果も引き受ける。アーキテクチャを決める権限を持つなら、その保守コストも背負う。これがタレブの言う「フェアネス」の本質なのかもしれない。私が考えるプロフェッショナルとは、自分の仕事の結果に責任を持とうとする者のことだ。失敗したときに「言われた通りに作っただけ」という逃げ道を使わない。それが身銭を切る姿勢だと思っている。本番でバグが起きたら、できる範囲で対応する。緊急度に応じて、翌朝一番でもいいかもしれない。ユーザーが困っていたら、次のリリースで改善を検討する。見積もりが外れたら、スケジュールを調整して現実的な着地点を探る。無理は続かないし、燃え尽きたら元も子もない。しかし最近、こうした責任感を持つことが難しくなっているのかもしれない。タレブの言葉を借りれば、身銭を切らずに成功した者は「ペテン師」として生きることになるという。そのような生き方は、少なくとも私には難しいと感じる。構造や制度の問題を語る前に、まず自分が身銭を切っているか——そこから問い直してみることも大切ではないだろうか。身銭を切れ――「リスクを生きる」人だけが知っている人生の本質作者:ナシーム・ニコラス・タレブダイヤモンド社Amazonなぜエンジニアは身銭を切らないのか心理的安全性の誤解「心理的安全性」は本来「率直な意見を言える環境」を意味する。しかし多くの現場では「失敗しても責められない環境」と誤解されている。この誤解が責任回避の文化を生む。失敗への恐れが完全に取り除かれ、緊張感も真剣さも失われていく。本当の心理的安全性とは、失敗を認め、責任を取り、改善できる環境のことだ。失敗を恐れないことではない。しかし多くのエンジニアは、この「責任を取る」部分を都合よく忘れている。心理的安全性は、責任から逃れるための免罪符ではない。心理的安全性のつくりかた　「心理的柔軟性」が困難を乗り越えるチームに変える作者:石井遼介日本能率協会マネジメントセンターAmazonキャリアの流動性という逃げ道エンジニアの転職市場は活発だ。この流動性が、長期的な責任から逃れる手段になっている。プロジェクトが失敗しても「より良い環境を求めて」転職すればいい。技術的負債を積み上げても「新しい挑戦」として別の会社に移ればいい。3年後のシステムの保守性など考えない——どうせ3年後には別の会社にいるからだ。プロフェッショナルなエンジニアは、自分が書いたコードの5年後、10年後を見据えて設計する。転職しても、過去に携わったシステムの成功や失敗を自分の責任として背負い続ける。転職の容易さに甘えるエンジニアは、失敗の履歴をリセットできると考え、新しい職場でも同じ過ちを繰り返す。この差が、身銭を切らないエンジニアとプロフェッショナルを分けている。「技術的に正しい」という隠れ蓑「技術的に正しい」——この言葉は、ソフトウェアエンジニアにとって最強の防御壁となる。ユーザーが使いにくいと言っても「技術的には正しい実装」。パフォーマンスが悪くても「理論的には最適なアルゴリズム」。ビジネスが失敗しても「技術選定は間違っていなかった」。技術の複雑性を盾に、結果への責任を回避する。しかし技術はあくまで手段だ。目的を達成できなければ、どんなに技術的に優れていても意味がない。「素人には分からない」という態度は、プロフェッショナルの姿勢ではない。タレブの言葉を借りれば、このような態度は「身なりがきちんとしている」偽物の特徴だ。本物の外科医は外科医らしく見える必要がない。本物のエンジニアも、技術的正しさをひけらかす必要はない。結果で証明すればいい。情報の非対称性に甘える構造エンジニアと非エンジニアの間には、圧倒的な情報の非対称性がある。この構造は、タレブが批判する「情弱ビジネス」と似た構造を取りやすい。専門知識を持たない経営者やユーザーは、エンジニアの判断が正しいかどうか検証できない。「技術的に難しい」「セキュリティ上必要」「パフォーマンスのため」——これらの説明が、よく吟味されずに個人の信頼次第で通ってしまうことがある。本来なら、不確実性やリスクを正直に伝え、選択肢を提示すべきだ。しかし時として、エンジニアも不確実性を十分に説明せずに進めてしまう。「今回の障害は予測不可能でした」で済ませてしまう。だが、その予測不可能な事態への備えについて、事前にどれだけ議論したのか。この構造的な問題に無自覚でいると、知らず知らずのうちに責任から逃れる習慣が身についてしまう。情報の非対称性があるからこそ、より誠実に、より責任を持って行動する必要がある。集団責任という幻想チーム開発は素晴らしい。協力は不可欠だ。相互レビューは品質向上に欠かせない。しかし「チーム全体で責任を持つ」という理念が、「誰も責任を持たない」言い訳に変質している。コードレビューで承認したから、バグは全員の責任。スプリント計画で合意したから、遅延は全員の責任。全員の責任は、誰の責任でもない。優れたチームこそ、個々人が明確な責任範囲を持ち、その上で協力する。集団責任の名の下に、個人の責任を曖昧にしてはならない。構造的な制約という現実経済学でいう「プリンシパル＝エージェント問題」というのがある。依頼者と実行者の目的がずれてしまう現象は、確かに存在する。エンジニアは良いものを作りたい。ユーザーに喜んでもらいたい、技術的負債を残したくない、保守しやすいシステムを構築したい。しかし契約形態や組織構造がその想いを阻むことがある。構造的な問題は確かに存在する。しかし、その中でも身銭を切る方法はある。契約外でも障害対応の知見を共有する。振り返りを徹底する。後任のためにドキュメントを残す。小さな積み重ねが信頼となり、より良い条件での仕事につながる。制約の中でも最善を尽くす。それがプロフェッショナルなエンジニアの身銭の切り方だ。ja.wikipedia.org身銭を切らないことの代償対称性の崩壊身銭を切らない場合、リスクの非対称性が生じる。成功すれば褒められるが、失敗しても「次は気をつけましょう」で終わる。エンジニアにとって失敗は「学習機会」だが、ユーザーにとってはただの「使えないサービス」だ。火災現場で消防士が「今日は調子が悪い」と言っても、火は待ってくれない。これは利益と損失の対称性が崩れた状態だ。利益は享受するが、損失は他者に押し付ける。この非対称性は、システム全体を脆弱にする。なぜなら、リスクを正しく評価するインセンティブが失われるからだ。一行のログの向こうには、一人のユーザーがいる。しかし、身銭を切らないエンジニアにとって、それは単なるデータポイントでしかない。判断力の鈍化身銭を切らないと、人は愚鈍になる。これは精神論ではなく、認知科学的な事実だ。リスクを負わない意思決定は、判断力を鈍らせる。「どうせ自分は痛まない」という前提があると、細部への注意が疎かになり、リスクの評価が甘くなる。コードレビューも形式的になり、テストも「とりあえず」で済ませる。身銭を切らないエンジニアは、技術的な勘が育たない。「なんか嫌な予感がする」という直感は、過去の痛みから生まれる。痛みを知らない者に、危険を察知する能力は宿らない。同じ失敗の繰り返し「痛みは学びを助く」。人間は失敗して痛みを感じることで学び成長する。しかし、身銭を切らない失敗は「他人事」として処理される。「前のプロジェクトでも同じ問題があったよね」という会話を何度聞いたことか。それは誰も身銭を切っていないからだ。痛みがなければ、学びもない。組織レベルでも同じだ。身銭を切らない文化では、ポストモーテムは形骸化し、「再発防止策」は実行されない。なぜなら、誰も本気で「次は自分が痛む」と思っていないからだ。新　失敗学　正解をつくる技術作者:畑村洋太郎講談社Amazon成長機会の喪失ストレスや失敗から強くなる——この「反脆弱性」は、身銭を切ることでしか得られない。身銭を切らないエンジニアは、いつまでも脆いままだ。小さな変化にも対応できず、予期せぬ事態に直面すると思考停止する。マニュアルにない状況では判断できず、前例のない問題には手が出せない。逆に、身銭を切り続けたエンジニアは、失敗するたびに強くなる。障害対応の修羅場を潜るたびに、次はより冷静に、より的確に対処できるようになる。この差は時間とともに広がっていく。反脆弱性―不確実な世界を生き延びる唯一の考え方　上下巻セットダイヤモンド社Amazonなぜ身銭を切るべきなのか意思決定の質が根本的に変わる身銭を切ると、判断基準が変わる。「この技術選定で失敗したら、自分が休日返上で修正することになる」と思えば、流行りに飛びつくことはない。「このアーキテクチャで3年運用することになる」と覚悟すれば、適当な設計はしない。他人事の意思決定は雑になる。自分事の意思決定は精緻になる。これは能力の問題ではなく、身銭を切っているかどうかの問題だ。不確実性に満ちた開発現場で、「絶対大丈夫」などと言えるはずがない。身銭を切る者は、その不確実性を正直に伝え、リスクヘッジの方法も含めて提案する。なぜなら、想定外のことが起きたとき、対処するのは自分だからだ。スタッフエンジニア　マネジメントを超えるリーダーシップ作者:Will Larson日経BPAmazon学習曲線が急激に立ち上がる「痛みは最高の教師」という言葉がある。マニュアルを100回読んでも身につかないことが、一度の失敗で骨身に染みる。深夜3時、本番環境が止まり、冷や汗をかきながらログを追う。その時に学ぶシステムの挙動は、二度と忘れない。身銭を切らない学習は表層的だ。カンファレンスで聞いた話、ブログで読んだベストプラクティス。知識としては持っているが、判断の瞬間には出てこない。痛みを伴わない知識は、実戦では使えない。実際に痛い目を見た経験が、次の「嫌な予感」を生む。この直感こそが、重大な障害を未然に防ぐ最後の砦となる。プロフェッショナルとして認められる医者が「手術は失敗したけど、僕のせいじゃない」と言ったらどう思うか。パイロットが「墜落したけど、マニュアル通りに操縦した」と言ったらどう思うか。エンジニアも同じだ。「仕様通りに作った」「指示された通りに実装した」。これは素人の言い訳だ。プロは結果に責任を持つ。だからこそ、プロの意見には重みがあり、プロの判断は尊重される。身銭を切らないエンジニアは、いつまでも「作業者」として扱われる。身銭を切るエンジニアだけが、真の意味で「エンジニア」として認められる。そして興味深いことに、本物のプロフェッショナルほど、見た目や肩書きにこだわらない。結果で証明するからだ。本物の自信が身につく身銭を切って成功した経験、失敗から立ち直った経験。これらが積み重なって、揺るぎない自信になる。「あの時、全責任を負って新技術を導入した」「大規模リファクタリングを主導して成功させた」「致命的な障害を起こしたが、そこから這い上がった」。これらの経験が、次の挑戦への勇気になる。会社や上司に守られた成功体験は、環境が変われば消える。しかし、身銭を切って得た自信は、どこに行っても通用する。それが、市場価値になる。信頼という最大の資産を得る身銭を切り続けるエンジニアは、長期的に最も価値のある資産——信頼——を獲得する。「あの人が言うなら大丈夫」「あの人に任せれば安心」。この信頼は、一朝一夕では築けない。小さな約束を守り、失敗したら素直に認め、責任を持って対処する。その積み重ねが信頼となる。皮肉なことに、身銭を切らずに「うまくやった」つもりのエンジニアほど、長期的には信頼を失う。短期的な成功と引き換えに、最も大切な資産を失っているのだ。その仕事、全部やめてみよう――１％の本質をつかむ「シンプルな考え方」作者:小野 和俊ダイヤモンド社Amazon組織における身銭の力少数決原理とは組織の意思決定は多数決で行われると思われがちだが、実際は違う。重要な決定は「少数決原理」に従う。これは、最も失うものが大きい人、つまり最も身銭を切っている人の意見が採用される、という原理だ。例を挙げよう。レストランを選ぶとき、10人中9人が「何でもいい」と言い、1人だけがベジタリアンだったら、ベジタリアン対応のレストランが選ばれる。なぜか？ベジタリアンにとって「肉を食べる」ことのコストは、他の9人が「野菜を食べる」ことのコストより遥かに高いからだ。ソフトウェア開発における少数決原理この原理はソフトウェア開発でも働く。深夜対応を覚悟しているエンジニアが「このシステムは危険だ」と言えば、その声は無視できない。なぜなら、実際に深夜に呼び出されるのは彼だからだ。一方、無責任で言われたことだけやるエンジニアが「大丈夫でしょう」と言っても、その言葉に重みはない。セキュリティインシデントが起きたとき、責任を取ると宣言したエンジニアの「この対策では不十分」という意見は通る。日頃から「僕は関係ない」という態度のエンジニアがいくら正論を述べても、聞き流される。なぜ少数決原理が機能するのか身銭を切る者は、失敗したときのダメージが大きい。だから、彼らの反対意見には切実さがある。「このままでは本当にまずい」という危機感が、組織を動かす。また、身銭を切る者は信頼される。過去に責任を取ってきた実績があるから、その判断は尊重される。「あの人が言うなら」という信頼が、少数意見を多数意見に変える。身銭を切らない者がいくら集まっても、一人の身銭を切る者には勝てない。なぜなら、前者は失敗しても逃げられるが、後者は逃げられないからだ。逃げられない者の必死さが、組織の方向を決める。健全な組織文化への影響少数でも身銭を切るエンジニアがいれば、組織文化は変わり始める。彼らの姿勢は、周囲に伝播する。「あの人がそこまで言うなら、自分も真剣に考えよう」という空気が生まれる。責任を取る姿勢が、チーム全体の当事者意識を高める。逆に、誰も身銭を切らない組織では、意思決定が遅れ、責任の所在が曖昧になり、同じ失敗を繰り返す。最終的には、優秀なエンジニアから去っていく。身銭を切る文化があるかどうかが、組織の命運を分ける。失敗できる組織作者:エイミー C エドモンドソン早川書房Amazonまとめ偉そうなことを書いてきたが、私も完璧ではない。逃げたくなることもある。「これは自分の仕事じゃない」と思うこともある。でも、そんなときこそ思い出す。プロフェッショナルとは何か。小さなことから始めればいい。自分が担当しているサービスの本番データを毎日見る。障害が起きたら、担当外でも飛び込む。「この仕様は良くない」と思ったら、代替案を提示する。そして、その結果に責任を持つ。身銭を切るとは、華々しいことではない。地味で、苦しくて、割に合わないことも多い。でも、振り返ったときに胸を張れる。「あのシステムは、俺が守った」「あの障害は、俺が未然に防いだ」それが、エンジニアとしての誇りだと、私は思う。こういうマインドは先達から学んできたわけですが、書籍で言うと『達人プログラマー』などはとても良い本なのでオススメです。達人プログラマー ―熟達に向けたあなたの旅― 第2版作者:David Thomas,Andrew Huntオーム社Amazonただし、ここで大切な前提を伝えておきたい。人生は仕事だけではない。身銭を切ることと、自己犠牲は違う。エンジニアの努力を正当に評価しない経営者の下で働いているなら、構造的に身銭を切っても報われない環境にいるなら、無理をする必要はない。自分の健康と人生を守ることが最優先だ。もちろん、私の主張には論理的な飛躍もあることは認めざるを得ない。「身銭を切らないから無責任」という単純な因果関係では説明できない複雑さが、現実にはある。権限なき責任を押し付けられる構造、短期的な成果を求める経営圧力——これらを個人の覚悟だけで解決できるわけではない。だからこそ、個人の責任感と組織の構造改革は、車の両輪のように進めていく必要がある。適切な権限と責任のバランス、専門家として意見を言える環境、失敗から学習できる仕組み。これらなしに、個人の覚悟だけに頼るのは持続可能ではない。それでも、まずは身銭の切り方を知らなければ、「ここは踏ん張りどころか、それとも撤退すべきか」という判断すらできない。プロフェッショナルとしての基準を持っていなければ、搾取と成長機会の区別もつかない。だから、あくまでも一人のエンジニアの意見として、この考えを表明した。完璧な答えではないし、すべての状況に当てはまるわけでもない。あなたの環境、あなたの状況に応じて、取捨選択してもらえればと思う。身銭を切ることで得られるのは、単なる技術力ではない。判断力、直感、信頼、そして何より「自分はエンジニアとして真っ当に生きている」という確信だ。強いビジネスパーソンを目指して鬱になった僕の 弱さ考作者:井上 慎平ダイヤモンド社Amazon","isoDate":"2025-09-22T08:53:53.000Z","dateMiliSeconds":1758531233000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"ACPでAgentに行動させる","link":"https://syu-m-5151.hatenablog.com/entry/2025/09/22/094533","contentSnippet":"はじめにこんにちは！今回は、コードエディタや各種開発ツールとAIエージェント間の通信を標準化する Agent Client Protocol (ACP) について、その内部実装と実践的な使用方法を詳しく解説します。github.com最近の界隈では、Model Context Protocol（MCP）が大きな注目を集めていますが、その陰で着実に重要性を増している技術があります。それがACPです。MCPのような華やかさはないものの、実際にエディタプラグインやコーディングエージェントを開発する際には、ACPの理解が不可欠になってきています。なお、ACPを理解する前提としてMCPの基礎知識があると理解が深まります。MCPについては以下の記事で詳しく解説していますので、ぜひ参照してください。syu-m-5151.hatenablog.comまた、みのるんさんから献本いただいたこちらの書籍も、MCPの入門書として非常に参考になりました。実践的な内容が分かりやすくまとめられており、おすすめです。やさしいMCP入門作者:御田稔,大坪悠秀和システムAmazon同名のスライドでも良いのでMCPがわからない人は触れておくと良いと思います。 speakerdeck.comコード開発におけるAI支援ツールが急速に普及する中、実はエディタとAIツールの間には興味深い技術的課題が潜んでいます。それは、エディタごとに個別対応が必要で、使いたいツールの組み合わせが制限されるという問題です。正直なところ、多くの開発者はCopilotやCursorなどの既製品で満足しているでしょうし、この問題を意識することもないかもしれません。しかし、エディタプラグインを自作したい人や独自のAIエージェントを開発したい人、あるいは技術的な仕組みに興味がある人にとって、ACPは実に興味深い技術です。「エディタとAIエージェント間のLSP」として機能するこのプロトコルは、知らなくても困らないけれど、知っていると開発の可能性が大きく広がる、そんな技術と言えるでしょう。本記事では、このややマニアックながらも将来性のあるACPの実装詳細を通じて、プロトコル設計の面白さや、Rustによる非同期通信の実装テクニックなど、技術的に興味深いポイントを深掘りしていきます。ACPとは何か？記事を始める前に、まず ACP (Agent Client Protocol) について簡単に説明しましょう。ACP についてより詳しい情報は、公式GitHubリポジトリ や公式サイトを参照してください。ACPは、Zed Industriesが開発したオープンソースの標準プロトコルで、コードエディタとAIコーディングエージェント間の通信を標準化します。Language Server Protocol（LSP）がプログラミング言語サーバーの統合を革命的に変えたように、ACPは「LSPのAIエージェント版」として、AIツールの統合に同様の変革をもたらすことを目指しています。agentclientprotocol.comACPの仕組みACP は基本的に JSON-RPC 2.0 ベースのプロトコルで、主要な構成要素は以下のとおりです。クライアント（Client）：コードエディタ（Zed、Neovim など）エージェント（Agent）：AIコーディング支援プログラム（Claude Code、Gemini CLI など）セッション（Session）：会話の単位、複数のセッションを並行して管理可能エージェントはエディタのサブプロセスとして実行され、標準入出力（stdin/stdout）を通じて通信を行います。agentclientprotocol.comACPとMCPの関係ACPの技術仕様において重要なのは、Model Context Protocol（MCP）との関係です。MCPは、LLMが外部サービスやローカルリソースにアクセスするためのプロトコルです。ACPは可能な限りMCPの型を再利用し、エディタが既存のMCPサーバー設定を持つ場合、その設定をエージェントに渡すことができます。agentclientprotocol.com{  \"mcpServers\": {    \"filesystem\": {      \"command\": \"npx\",      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\"],      \"env\": {        \"ALLOWED_PATHS\": \"/path/to/project\"      }    }  }}JSON-RPC の基本ACP は JSON-RPC 2.0 仕様に基づいており、以下の3種類のメッセージ形式が使われます。agentclientprotocol.comリクエスト：クライアントからエージェントへの要求{  \"jsonrpc\": \"2.0\",  \"id\": 1,  \"method\": \"prompt\",  \"params\": {    \"sessionId\": \"session-123\",    \"prompt\": [{\"type\": \"text\", \"text\": \"Hello Agent!\"}]  }}レスポンス：エージェントからクライアントへの応答{  \"jsonrpc\": \"2.0\",  \"id\": 1,  \"result\": {    \"stopReason\": \"endTurn\",    \"meta\": null  }}通知：レスポンスを必要としない一方向メッセージ{  \"jsonrpc\": \"2.0\",  \"method\": \"session/notification\",  \"params\": {    \"sessionId\": \"session-123\",    \"update\": {      \"type\": \"agentMessageChunk\",      \"content\": {\"type\": \"text\", \"text\": \"Processing...\"}    }  }}Rustで実装するACPの詳細解説それでは、実際のRustコードを通じてACPの動作原理を深く理解していきましょう。公式リポジトリの実装例（agent.rsとclient.rs）を詳しく解説します。agentclientprotocol.com実装の準備と実行まず、ACPの実装を実際に動かすための手順を確認しましょう：# リポジトリのクローンgit clone https://github.com/zed-industries/agent-client-protocolcd agent-client-protocol/rust# エージェントのビルドRUST_LOG=info cargo build --example agent# クライアントの実行（エージェントを自動起動）cargo run --example client -- ../target/debug/examples/agent# 実行時の対話例\u003e Hello, Agent!| Agent: Client sent: Hello, Agent!\u003e How can you help me with coding?| Agent: Client sent: How can you help me with coding!この実行により、以下の通信フローが発生します。初期化フェーズ: プロトコルバージョンのネゴシエーションセッション確立: 作業ディレクトリとMCPサーバー設定の共有メッセージループ: プロンプトの送信と応答のストリーミンググレースフルシャットダウン: プロセス終了時のリソースクリーンアップエージェント側の実装（agent.rs）基本構造とトレイト実装use std::cell::Cell;use agent_client_protocol::{    self as acp, AuthenticateResponse, Client, ExtNotification,     ExtRequest, ExtResponse, SessionNotification, SetSessionModeResponse,};use tokio::sync::{mpsc, oneshot};struct ExampleAgent {    session_update_tx: mpsc::UnboundedSender\u003c(acp::SessionNotification, oneshot::Sender\u003c()\u003e)\u003e,    next_session_id: Cell\u003cu64\u003e,}構造体の設計思想：session_update_tx：非同期チャネルの送信側で、セッション更新をバックグラウンドタスクに送信next_session_id：Cell\u003cu64\u003eによる内部可変性パターンで、\u0026selfの不変参照でも値を更新可能ACPトレイトの実装#[async_trait::async_trait(?Send)]impl acp::Agent for ExampleAgent {    async fn initialize(        \u0026self,        arguments: acp::InitializeRequest,    ) -\u003e Result\u003cacp::InitializeResponse, acp::Error\u003e {        log::info!(\"Received initialize request {arguments:?}\");        Ok(acp::InitializeResponse {            protocol_version: acp::V1,            agent_capabilities: acp::AgentCapabilities::default(),            auth_methods: Vec::new(),            meta: None,        })    }重要なポイント：async_trait(?Send)：非Sendなfutureを許可し、LocalSet環境での実行を可能にプロトコルバージョンの明示的な宣言ケイパビリティ交換による機能のネゴシエーションセッション管理async fn new_session(    \u0026self,    arguments: acp::NewSessionRequest,) -\u003e Result\u003cacp::NewSessionResponse, acp::Error\u003e {    log::info!(\"Received new session request {arguments:?}\");    let session_id = self.next_session_id.get();    self.next_session_id.set(session_id + 1);    Ok(acp::NewSessionResponse {        session_id: acp::SessionId(session_id.to_string().into()),        modes: None,        meta: None,    })}セッションの概念：各セッションは独立した会話コンテキストMCPサーバー設定の引き継ぎ作業ディレクトリの設定プロンプト処理とストリーミングasync fn prompt(    \u0026self,    arguments: acp::PromptRequest,) -\u003e Result\u003cacp::PromptResponse, acp::Error\u003e {    log::info!(\"Received prompt request {arguments:?}\");        for content in [\"Client sent: \".into()].into_iter().chain(arguments.prompt) {        let (tx, rx) = oneshot::channel();                // セッション更新の非同期送信        self.session_update_tx            .send((                SessionNotification {                    session_id: arguments.session_id.clone(),                    update: acp::SessionUpdate::AgentMessageChunk { content },                    meta: None,                },                tx,            ))            .map_err(|_| acp::Error::internal_error())?;                // バックプレッシャー制御        rx.await.map_err(|_| acp::Error::internal_error())?;    }        Ok(acp::PromptResponse {        stop_reason: acp::StopReason::EndTurn,        meta: None,    })}ストリーミング設計：チャンク単位でのメッセージ送信oneshot::channel()による同期制御バックプレッシャーによる流量制御メインループとタスク管理メインループは、非同期ランタイムの中核部分であり、実際にエージェントが起動される場所です。#[tokio::main(flavor = \"current_thread\")]async fn main() -\u003e anyhow::Result\u003c()\u003e {    env_logger::init();  // RUST_LOG環境変数でログレベルを制御    let outgoing = tokio::io::stdout().compat_write();    let incoming = tokio::io::stdin().compat();    let local_set = tokio::task::LocalSet::new();    local_set        .run_until(async move {            let (tx, mut rx) = tokio::sync::mpsc::unbounded_channel();                        // エージェント接続の確立            let (conn, handle_io) = acp::AgentSideConnection::new(                ExampleAgent::new(tx),                 outgoing,                 incoming,                 |fut| {                    tokio::task::spawn_local(fut);                }            );                        // セッション通知処理タスク            tokio::task::spawn_local(async move {                while let Some((session_notification, tx)) = rx.recv().await {                    let result = conn.session_notification(session_notification).await;                    if let Err(e) = result {                        log::error!(\"{e}\");                        break;                    }                    tx.send(()).ok();                }            });                        handle_io.await        })        .await}非同期ランタイムの設計：LocalSet：シングルスレッド実行環境（current_threadフレーバーと連携）spawn_local：非Sendタスクの実行チャネルによるタスク間通信RUST_LOG=info環境変数でログ出力を制御（デバッグ時はRUST_LOG=debug）クライアント側の実装（client.rs）プロセス管理とライフサイクルクライアントは、エージェントをサブプロセスとして起動し管理します。実行時はコマンドライン引数でエージェントのパスを指定します：# 実行例：ビルド済みのエージェントを指定cargo run --example client -- target/debug/examples/agent#[tokio::main(flavor = \"current_thread\")]async fn main() -\u003e anyhow::Result\u003c()\u003e {    let command = std::env::args().collect::\u003cVec\u003c_\u003e\u003e();    let (outgoing, incoming, child) = match command.as_slice() {        [_, program, args @ ..] =\u003e {            let mut child = tokio::process::Command::new(program)                .args(args.iter())                .stdin(std::process::Stdio::piped())                .stdout(std::process::Stdio::piped())                .kill_on_drop(true)  // 自動クリーンアップ                .spawn()?;                        (                child.stdin.take().unwrap().compat_write(),                child.stdout.take().unwrap().compat(),                child,            )        }        _ =\u003e bail!(\"Usage: client AGENT_PROGRAM AGENT_ARG...\"),    };プロセス管理のベストプラクティス：kill_on_drop(true)：親プロセス終了時の自動クリーンアップ（孤児プロセスを防ぐ）ストリーム所有権の明示的な管理（take()メソッド）エラー時のグレースフルシャットダウンエージェントプログラムへの引数の柔軟な受け渡しプロトコル初期化// 接続の確立let (conn, handle_io) = acp::ClientSideConnection::new(    ExampleClient {},     outgoing,     incoming,     |fut| {        tokio::task::spawn_local(fut);    });// バックグラウンドI/O処理tokio::task::spawn_local(handle_io);// 初期化ハンドシェイクconn.initialize(acp::InitializeRequest {    protocol_version: acp::V1,    client_capabilities: acp::ClientCapabilities::default(),    meta: None,}).await?;// セッション作成let response = conn    .new_session(acp::NewSessionRequest {        mcp_servers: Vec::new(),  // MCPサーバー設定        cwd: std::env::current_dir()?,        meta: None,    })    .await?;対話的REPLの実装Rustylineを使用した対話的インターフェースにより、ユーザーはエージェントと直接対話できます：// Rustylineによる対話インターフェースlet mut rl = rustyline::DefaultEditor::new()?;while let Ok(line) = rl.readline(\"\u003e \") {    let result = conn        .prompt(acp::PromptRequest {            session_id: response.session_id.clone(),            prompt: vec![line.into()],            meta: None,        })        .await;        if let Err(e) = result {        log::error!(\"{e}\");    }}REPLの動作例：\u003e Hello, Agent!| Agent: Client sent: Hello, Agent!\u003e What's the weather like?| Agent: Client sent: What's the weather like?\u003e exitRustylineの利点：履歴管理（上下矢印キーで過去の入力を参照）カーソル移動とテキスト編集機能Ctrl+C/Ctrl+Dによる適切な終了処理将来的な自動補完機能の追加が可能セッション通知の処理#[async_trait::async_trait(?Send)]impl acp::Client for ExampleClient {    async fn session_notification(        \u0026self,        args: acp::SessionNotification,    ) -\u003e anyhow::Result\u003c(), acp::Error\u003e {        match args.update {            acp::SessionUpdate::AgentMessageChunk { content } =\u003e {                let text = match content {                    acp::ContentBlock::Text(text_content) =\u003e text_content.text,                    acp::ContentBlock::Image(_) =\u003e \"\u003cimage\u003e\".into(),                    acp::ContentBlock::Audio(_) =\u003e \"\u003caudio\u003e\".into(),                    acp::ContentBlock::ResourceLink(resource_link) =\u003e resource_link.uri,                    acp::ContentBlock::Resource(_) =\u003e \"\u003cresource\u003e\".into(),                };                println!(\"| Agent: {text}\");            }            acp::SessionUpdate::ToolCall(tool_call) =\u003e {                println!(\"| Tool call: {}\", tool_call.name);            }            acp::SessionUpdate::Plan(plan) =\u003e {                println!(\"| Plan: {}\", plan.description);            }            _ =\u003e {}        }        Ok(())    }エラーハンドリングとプロトコルの堅牢性タイムアウトとリトライの実装use tokio::time::{timeout, Duration};async fn prompt_with_timeout(    conn: \u0026ClientSideConnection,    request: PromptRequest,    timeout_secs: u64,) -\u003e Result\u003cPromptResponse, Error\u003e {    match timeout(        Duration::from_secs(timeout_secs),        conn.prompt(request)    ).await {        Ok(Ok(response)) =\u003e Ok(response),        Ok(Err(e)) =\u003e {            log::error!(\"Prompt error: {}\", e);            Err(e)        }        Err(_) =\u003e {            log::error!(\"Prompt timeout after {} seconds\", timeout_secs);            Err(Error::request_timeout())        }    }}エクスポネンシャルバックオフasync fn reconnect_with_backoff(    max_retries: u32,) -\u003e Result\u003cConnection, Error\u003e {    let mut delay = Duration::from_secs(1);        for attempt in 1..=max_retries {        match establish_connection().await {            Ok(conn) =\u003e {                log::info!(\"Connected on attempt {}\", attempt);                return Ok(conn);            }            Err(e) if attempt \u003c max_retries =\u003e {                log::warn!(\"Attempt {} failed: {}\", attempt, e);                tokio::time::sleep(delay).await;                delay *= 2;  // エクスポネンシャルバックオフ            }            Err(e) =\u003e return Err(e),        }    }        Err(Error::max_retries_exceeded())}実践的な統合例Claude Code ACPの設定Claude Code ACP は、AnthropicのClaude AIをACPプロトコル経由で利用可能にする実装です。github.com{  \"agent_servers\": {    \"Claude Code\": {      \"command\": \"npx\",      \"args\": [\"@zed-industries/claude-code-acp\"],      \"env\": {        \"ANTHROPIC_API_KEY\": \"your-api-key\",        \"ACP_PERMISSION_MODE\": \"acceptEdits\"      }    }  }}Avante.nvimの設定Avante.nvim は、NeovimでACPを利用するための実装です。github.com{  \"yetone/avante.nvim\",  event = \"VeryLazy\",  build = \"make\",  opts = {    provider = \"claude\",    mode = \"agentic\",    acp_providers = {      [\"claude-code\"] = {        command = \"npx\",        args = { \"@zed-industries/claude-code-acp\" },        env = { ANTHROPIC_API_KEY = os.getenv(\"ANTHROPIC_API_KEY\") }      }    }  }}ccswarm での実装筆者が開発している ccswarm プロジェクトでは、当初は独自の仮想ターミナル実装を使用していましたが、ACPの登場を機に、より標準化されたアプローチへの移行を決定しました。github.comセキュリティに関する考慮事項ACPを使用する際には、以下の点に注意が必要です。ACPのセキュリティリスク作っていて思ったのですが、ACPはエージェントにローカル環境への強いアクセス権を付与するので、本質的にセキュリティ上の懸念があります：サードパーティエージェントのリスク: 信頼できない「野良エージェント」をインストールすると、マルウェアや情報漏洩のリスクが高まります権限の過剰付与: エージェントが必要以上の権限を持つと、システムリソースへの不正アクセスの可能性がありますデータ漏洩のリスク: ローカルファイルやクレデンシャルなどの機密情報が、エージェントを通じて外部に漏洩する可能性がありますプロンプトインジェクション攻撃: 悪意あるプロンプトを通じて、エージェントに予期しない操作を実行させるリスクがあります安全なACP利用のための対策信頼できるソースからのみエージェントをインストール: 公式リポジトリや信頼できる開発者からのエージェントのみを使用最小権限の原則を適用: エージェントには必要最小限の権限のみを付与サンドボックス環境での実行: 可能であれば、エージェントを隔離された環境で実行監査ログの有効化: エージェントを通じて実行されたすべてのコマンドや操作を記録機密情報のフィルタリング: APIキーやパスワードなどの機密情報を検出・削除するメカニズムを実装定期的なセキュリティレビュー: エージェントの設定やコードを定期的にレビュー確実なテストの実行: 本番環境に導入する前に、テスト環境で動作を徹底的に検証ACPのメリットと今後の展望開発者にもたらす価値ベンダーロックインからの解放: どのACP対応エディタでも、どのACP対応エージェントでも使用可能開発効率の向上: 統一されたプロトコルにより、新しいAIエージェントの導入が簡単にエコシステムの成長: 標準化により、開発者はそれぞれの得意分野に集中可能実践的な活用シナリオ大規模リファクタリング: プロジェクト全体の構造改善バグ修正フロー: エラー解析から修正まで一貫した支援コードレビュー自動化: セキュリティや品質の包括的チェックプロジェクト横断的な分析: アーキテクチャレベルの改善提案おわりにAgent Client Protocolは、AIコーディング支援ツールの統合における新たな標準として、着実に開発者コミュニティで採用が進んでいます。MCPが大きな話題を集めた一方で、ACPはそこまで注目を浴びていないかもしれません。しかし、エディタ開発者やコーディングエージェントを実装したい開発者にとって、ACPは極めて実用的で学ぶ価値の高い技術です。本記事で詳しく解説したRustの実装例は、ACPの設計思想を理解し、独自のエージェントを開発するための出発点となるでしょう。特に注目すべきは、Rustの所有権システムとACPの非同期通信モデルが見事に調和している点です。LocalSetによる非Sendなfutureの処理、mpscとoneshotチャネルを組み合わせた確実な通信、kill_on_dropによる安全なプロセス管理など、これらの技術的選択は、堅牢で効率的なACP実装の基礎となります。ACPの魅力は、JSON-RPCベースのシンプルなプロトコル設計により、数百行のコードで基本的なエージェントを実装できる敷居の低さにあります。一度ACPに対応すれば、Zed、Neovim、その他のACP対応エディタですぐに利用可能になり、独自のコーディングアシスタントやドメイン特化型エージェントの開発も容易になります。エディタとAIエージェントの統合は今後も加速することが予想され、ACPの知識は長期的な資産となるでしょう。一般的な開発者にとって重要なのは、ACPが派手さはないものの、日々のコーディング作業を着実に改善する実用的な基盤技術であるという点です。MCPのような革新的な印象はないかもしれませんが、LSPがそうであったように、気がつけば開発環境に不可欠な存在となっているでしょう。特に、独自のエディタプラグインやAIコーディングツールを開発したいと考えている方は、ぜひACPの仕様を学び、実装してみることをお勧めします。この標準化されたプロトコルは、あなたのツールを幅広いエコシステムに接続する架け橋となるはずです。参考リソースAgent Client Protocol GitHubリポジトリACP 公式ドキュメントClaude Code ACP実装Avante.nvim プロジェクトModel Context ProtocolJSON-RPC 2.0 仕様zed.dev","isoDate":"2025-09-22T00:45:33.000Z","dateMiliSeconds":1758501933000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Webアプリケーションにオブザーバビリティを実装するRust入門ガイド","link":"https://speakerdeck.com/nwiizo/webapurikesiyonniobuzababiriteiwoshi-zhuang-sururustru-men-gaido","contentSnippet":"2025年9月10日（水）、「Rustの現場に学ぶ〜Webアプリの裏側からOS、人工衛星まで〜」というイベントで登壇させていただきます。\r\rhttps://findy.connpass.com/event/359456/\r\r他の登壇者の話が聞きたすぎるけど調整能力の圧倒的な不足で登壇したらすぐに帰らなければなりません。\r\r今回の発表内容のベースとなったのはこちらのブログです。\r- 「RustのWebアプリケーションにオブザーバビリティを実装するインフラエンジニアのための入門ガイド」","isoDate":"2025-09-10T04:00:00.000Z","dateMiliSeconds":1757476800000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Claude CodeのSubagentsは設定したほうがいい","link":"https://syu-m-5151.hatenablog.com/entry/2025/09/09/143306","contentSnippet":"Claude Codeを使い始めて様々な発信をしてきましたが、Claude Codeに関する投稿は約2ヶ月ぶりです。この期間、他のアウトプットや諸々の事情で投稿が遅れてしまいましたが、今回は「Subagents」について書きます。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。はじめにここで読むのをやめる人のために言っておくと、Subagentsは「Claude Codeに尖った意思を持たせる」機能です。タスクごとに最適化されたAIを使い分けられます。特定のタスクを実行するslash commandsとの違いは、slash commands（/コマンド）があなたが明示的に呼び出すショートカットであるのに対し、SubagentsはClaude Codeが文脈を読んで自動的に専門家を呼び出す点にあります。例えば、slash commandsでは「/test」と打てばテスト実行されますが、Subagentsでは「エラーが出た」と伝えるだけで勝手にdebugger subagentが起動します（起動できないようにもできます）。つまり、commandsは「リモコンのボタンを押す」、Subagentsは「AIが勝手に判断して動く」みたいなもの。commandsは確実だけど面倒、Subagentsは楽だけど時々勝手なことをする。両方設定すれば、必要な時は手動で制御しつつ、面倒な部分は自動化できて最強です（AIに仕事を奪われる第一歩かもしれませんが）。Claude Codeって万能だけど、それゆえに器用貧乏になることがある。「データ分析して」って言ったら、なぜかフロントエンドのコンポーネントまで作り始めたり、最新技術よりも古い安全な実装を選んだり。例えば「最新版で」と指定しても、内部知識にある古いバージョンの設定方法で進めようとしたり、今では不要になった設定ファイルを作ろうとしたりする。「それ最新の仕様で」と言っても憶測でそれっぽくセットアップするだけで、実際の公式ドキュメントを調べずに進めてしまう。毎回「それ古いから最新の方法で」と指摘するのも疲れるし、革新的なアーキテクチャより無難で時代遅れの実装を選んでしまうこともある。タスクの境界線をあまり意識せず、頼まれていないことまでやってしまったり、逆に専門的な判断が必要な場面で踏み込みが足りなかったり。人間の開発チームだって、フルスタックエンジニア1人より専門家チームの方が効率的で、より尖った意思決定ができるでしょ？Subagentsとは何かClaude Code Subagentsは、特定のタスクに特化したAIアシスタントです。docs.anthropic.com各Subagentの特徴：独立したコンテキストウィンドウを持つ（メインの会話を汚染しない）カスタムシステムプロンプトで専門性を定義特定のツールだけ使える権限管理（最小権限の原則）自動的に呼び出されるか、明示的に指定可能実はClaude CodeはデフォルトでTaskツールを使った調査時には、自動的にサブエージェントを起動するアーキテクチャになっています。なぜSubagentsを設定したほうがいいのか1. コンテキストウィンドウの効率的な管理LLMのコンテキストウィンドウは有限です。長時間使っていると、さっき言ったことをすぐに忘れてしまいます。時には全く関係ないことをし始めることさえあります（勝手に別のタスクを始めないでほしいですよね、俺じゃねーんだから）。Subagentsなら独立したコンテキストで動作：メインClaude：「ログ解析はdebugger subagentに任せます」↓Debugger Subagent：（数千行のログを読み込んで解析）↓メインClaude：「問題は○○でした」（要約のみ受け取る）調査の過程で読み込んだ不要な情報は、Subagentのコンテキストに閉じ込められます。2. 専門性による品質向上「小さく単一責任のエージェント」として構築すべきという原則があります。専門のSubagentなら、コードレビュー専門がセキュリティ、パフォーマンス、可読性を徹底チェックし、デバッグ専門がエラーメッセージから根本原因を特定し、テスト専門がエッジケースまで網羅したテストを作成できます。3. 権限管理でセキュリティ向上---name: code-reviewerdescription: コードレビュー専門tools: Read, Grep, Glob  # 読み取りのみ、Write権限なし！---レビュアーが勝手にコード書き換えたら困りますよね。必要最小限の権限だけを与えられます。4. チーム開発での一貫性.claude/agents/をGit管理すれば、チーム全体で同じ基準で開発できます。新人が入ってきても、すぐに同じ品質を保てます。基本的な使い方設定方法/agentsコマンド（v1.0.60以降）で対話的に作成：/agents「Create New Agent」を選択プロジェクト単位か個人単位かを選択「Generate with Claude」で土台を生成、その後カスタマイズ使用可能なツールを選択識別用の色を選択ファイルの場所と構造 タイプ  パス  スコープ  優先度  プロジェクト  .claude/agents/  現在のプロジェクトのみ  高  ユーザー  ~/.claude/agents/  全プロジェクト共通  低 YAMLフロントマター付きMarkdownファイル：---name: your-agent-namedescription: このサブエージェントをいつ呼び出すべきかの説明tools: tool1, tool2, tool3  # 省略すると全ツール継承---ここにシステムプロンプトを書きます。サブエージェントの役割、能力、問題解決へのアプローチを明確に定義。具体的な指示やベストプラクティス、制約事項も含めます。設定項目の詳細 項目  必須  説明  name  はい  小文字とハイフンを使った一意の識別子  description  はい  サブエージェントの目的を自然な言葉で説明  tools  いいえ  特定のツールをカンマ区切りでリスト。省略時は全ツール継承 利用可能なツール基本ツール：Read, Write, Edit, MultiEdit - ファイル操作Bash - シェルコマンド実行Grep, Glob - 検索MCPツール（設定時）：mcp__github__create_issue - GitHub連携その他の設定済みMCPサーバーツールSubagentの呼び出し方法自動的な呼び出し（推奨）descriptionに効果的なキーワードを含める：use PROACTIVELY - 積極的に使用MUST BE USED - 必ず使用具体的なトリガー - 「エラー発生時」「コード変更後」など明示的な呼び出し\u003e code-reviewer サブエージェントで最近の変更をレビューして\u003e debugger サブエージェントにこのエラーを調査させて100+の実戦投入可能なSubagentsプロダクションレディなSubagentsのコレクションが既に存在します：github.com10カテゴリー・100以上のSubagentsが用意されており、コピーして使うだけで即座にプロ級のチームが構築できます。人気リポジトリ：wshobson/agents - 77の専門Subagentslst97/claude-code-sub-agents - 33の実用的なSubagentsvanzan01/claude-code-sub-agent-collective - TDD重視のコレクション実用的なSubagents設定例（厳選3つ）1. コードレビュー専門（OWASP準拠）.claude/agents/code-reviewer.md:---name: code-reviewerdescription: Expert code review for quality and security. Use PROACTIVELY after code changes. MUST BE USED for all PRs.tools: Read, Grep, Glob, Bash---シニアコードレビュアーとして、OWASP Top 10とSOLID原則に基づいてレビューします。## 実行フロー1. `git diff HEAD~1`で変更内容を確認2. セキュリティ、パフォーマンス、保守性の観点でレビュー## セキュリティチェック（OWASP準拠）- SQLインジェクション対策- XSS対策- 認証・認可の実装- 機密情報の露出チェック## フィードバック形式🔴 **CRITICAL** - セキュリティ脆弱性🟡 **WARNING** - パフォーマンス問題🔵 **SUGGESTION** - ベストプラクティス必ず具体的な修正コード例を提示。2. TDD専門（テスト駆動開発）.claude/agents/tdd-specialist.md:---name: tdd-specialistdescription: Test-Driven Development specialist. MUST BE USED BEFORE implementation.tools: Read, Write, Edit, Bash---TDDのエキスパートとして、RED-GREEN-REFACTORサイクルを厳守します。## TDDサイクル1. **RED**: 失敗するテストを書く2. **GREEN**: テストを通す最小限の実装3. **REFACTOR**: コードを改善## カバレッジ要件- ユニットテスト: 90%以上- 統合テスト: 主要フロー100%- E2Eテスト: クリティカルパス100%実装前に必ずテストが失敗（RED）していることを確認。3. DevOpsトラブルシューター.claude/agents/devops-troubleshooter.md:---name: devops-troubleshooterdescription: Debug production issues and fix deployment failures. MUST BE USED for incidents.tools: Read, Bash, Write, Edit---本番環境のトラブルシューティング専門家です。## インシデント対応フロー1. **状況把握** - 影響範囲と緊急度を評価2. **ログ収集** - 関連するすべてのログを収集3. **根本原因分析** - 5 Whys手法を使用4. **暫定対処** - 即座にサービスを復旧5. **恒久対処** - 根本原因を解決6. **事後分析** - RCAドキュメント作成## 監視項目と閾値- CPU使用率: 80%- メモリ使用率: 90%- レスポンスタイム: 1秒- エラーレート: 1%よく使えるTipsSubagentsの連携複数のSubagentsを連携させて複雑なワークフローを自動化する。\u003e まずcode-analyzerで問題を見つけて、次にperformance-optimizerで修正してMCPツールとの連携---name: github-managertools: mcp__github__create_issue, mcp__github__create_pull_request---プロジェクト固有のカスタマイズプロジェクトの特性に合わせて専門Subagentを作成できます。パフォーマンスへの影響メリット：コンテキスト効率：メインの会話が長く続く専門性による高速化：タスクに特化した処理デメリット：初回起動の遅延：新しいコンテキスト構築（数秒）頻繁な切り替えは逆効果ただし、長時間の開発セッションではメリットが圧倒的に大きいです。チーム開発での活用Git管理による共有# .gitignore には含めない.claude/agents/  # チームで共有# 個人用は別管理~/.claude/agents/オンボーディング新メンバーは以下のコマンドだけで環境構築完了：git clone [repo]cd [repo]/agents  # Subagents一覧を確認よくある失敗と対策 問題  原因  対策  Subagentが呼ばれない  descriptionが曖昧  「PROACTIVELY」「MUST BE USED」を追加  権限不足エラー  必要なツールがない  /agentsでツール一覧を確認して追加  コンテキスト不足  背景情報がない  システムプロンプトに情報収集ステップを明記 まとめSubagentsを使えば、Claude Codeに尖った意思を持たせられます。重要なポイントは、コンテキスト節約でメインの会話を綺麗に保つこと、専門性による品質向上で餅は餅屋に任せること、権限管理で最小権限の原則を守ること、そして100+の実戦投入可能なSubagentsが既に存在することです。これだけ揃っているのに使わない理由があるでしょうか（ないですよね？）。Claude Codeは適切に設定をしたりちゃんと使えばちゃんと動いてくれます。Claude Codeが雑魚なんじゃない、使い方を知らない…いや、何でもないです。イン・ザ・メガチャーチ (日本経済新聞出版)作者:朝井リョウ日経BPAmazon参考資料Sub agents - Anthropicawesome-claude-code-subagents - VoltAgent12 Factor Agents","isoDate":"2025-09-09T05:33:06.000Z","dateMiliSeconds":1757395986000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"2025年夏 コーディングエージェントを統べる者","link":"https://speakerdeck.com/nwiizo/2025nian-xia-kodeinguezientowotong-beruzhe","contentSnippet":"2025年9月5日（金）、台風接近という悪天候の中でしたが、「CNCJ: コーディングエージェント × セキュリティ ミートアップ」に登壇させていただきました。\r\r天候の影響で現地参加が難しい方も多い中、オンラインでの参加や配信により、多くの方にお聞きいただくことができました。\r\r### 📍 イベント情報\r- 開催日: 2025年9月5日（金）\r- イベント詳細: CNCFコミュニティページ\r\r### 📹 録画・資料公開予定\r- 録画: CNCJのYouTubeチャンネルにて後日公開予定\r- 発表資料: Connpassページに掲載予定\r\r### 📝 関連ブログ\r今回の発表内容のベースとなった考え方については、こちらのブログ記事でも詳しく解説しています：\r- 「2025年夏 AIエージェントシステムに対する考え方」\r\r台風の中、ご参加・ご視聴いただいた皆様、ありがとうございました。","isoDate":"2025-09-05T04:00:00.000Z","dateMiliSeconds":1757044800000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"続: 自分が書いたコードより目立つな - エンジニアがバズったので自戒","link":"https://syu-m-5151.hatenablog.com/entry/2025/09/03/174830","contentSnippet":"はじめに私はソフトウェアエンジニアだ。1年前、そう宣言した。「コードを書くこと以外で目立つな」と自分に言い聞かせた。syu-m-5151.hatenablog.comで、どうなったか。フォロワーが2000から9500になった。笑うしかない。自戒したはずの私は、気づけばSNS戦略を「最適化」していた。分析して、仮説立てて、A/Bテストして、PDCAを回す。挙げ句の果てには「ソフトウェアエンジニアのためのSNSサバイバルガイド」なんてマニュアルまで書いていた。note.com完全にプロダクト開発と同じアプローチだった。要件定義（達成すべきゴール）、競合分析（類似アカウント）、実装とテスト（仮説検証）、リリースと運用（実行と点検）。SNSを攻略していた。これもエンジニアリングなのか？パターン認識、システム最適化、メトリクス改善。使っているスキルセットは同じだ。ただ対象がコードやサービスじゃなくて「SNS」になっただけで。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。なぜ「レベル1」の話ばかりバズるのか1年間やってきて、嫌というほど分かったことがある。SNSでバズるのは、いつも「レベル1」の話だ。「エンジニアの最大の課題は健康管理です」とか「エンジニアの根本の仕事は言語化です」とか。何度でもバズる。飽きもせず。アテンション・エコノミーのジレンマ　〈関心〉を奪い合う世界に未来はあるか作者:山本 龍彦KADOKAWAAmazon増補改訂版 スマホ時代の哲学 なぜ不安や退屈をスマホで埋めてしまうのか (ディスカヴァー携書)作者:谷川嘉浩ディスカヴァー・トゥエンティワンAmazonなんでか。答えはシンプルで残酷だった。SNSで「勉強したい」って言ってる人の大半が、勉強を「理解できる話を読むこと」だと思ってるからだ。本当の勉強って、理解できない文章と格闘することでしょう。わからない概念にぶつかって、自分がいかに無知か思い知らされながら、それでも少しずつ前に進むこと。でも、そんなの誰もやりたくない。だから永遠に同じレベルで足踏みする。考えてみれば、英会話教室だって無くならない。YouTubeに無料の英語学習動画が溢れ、AIで英会話練習ができて、オンラインで世界中のネイティブと話せる時代。でも英会話教室は繁盛している。なぜか？みんな「英語を勉強している自分」が欲しいだけだからだ。週1回教室に通って、テキストを開いて、先生の話を聞く。それで「勉強した」気になる。実際に英語で議論できるようになったか？ビジネスで使えるようになったか？そんなことはどうでもいい。「今日も英会話教室に行った」という事実があればいい。プログラミングも同じ構造だ。「エンジニアの本質」みたいな記事を読んで「勉強した」気になる。実際にコードが書けるようになったか？アーキテクチャが設計できるようになったか？どうでもいい。「技術記事を読んだ」という満足感があればいい。アメリカは自己啓発本でできている作者:尾崎俊介平凡社Amazon私がバズったSNS投稿を振り返ると、全部このパターンだった。既に知ってることの再確認。複雑な現実を単純化して気持ちよく整理したやつ。誰もが感じてる問題を言語化しただけのもの。知的満足感は与える。でも行動は変えない。それがバズる。深い技術解説は？Rustの所有権システムの詳細は？型レベルプログラミングは？ほとんど読まれない。エンゲージメントは雲泥の差。これが現実だった。分かりやすさと極端さSNSでウケるのは、分かりやすくて極端な主張だ。「技術的負債は悪だ」「オブジェクト指向は時代遅れ」「マイクロサービスこそ正解」。こういう白黒ハッキリした断言がバズる。グレーゾーンの話、文脈依存の判断、トレードオフの議論——そんなものは誰も読まない。でも、実際のエンジニアリングってどうだ？技術選定の会議で「このアーキテクチャは絶対に正しい！」なんて言えるか？言えない。「この要件なら、こっちの方が良さそう。ただし、パフォーマンスとメンテナンス性のトレードオフがあって...」みたいな話になる。曖昧で、条件付きで、保守的な判断。それがプロの仕事だ。レビューでも同じ。「このコードは完璧です」なんて言わない。「ここは良いけど、エッジケースでこういう問題が起きそう。あと、命名がもう少し明確だと...」と、細かい指摘を重ねていく。慎重で、具体的で、建設的なフィードバック。でも、こんな姿勢でSNSやったらどうなる？誰も読まない。「Reactは良いフレームワークですが、状態管理の複雑さとパフォーマンスのトレードオフを考慮すると、プロジェクトの規模や要件によっては...」誰が最後まで読むんだ、こんなの。SNSが求めているのは逆だ。「React最高！」か「React最悪！」のどちらか。中間はない。ニュアンスは邪魔なだけ。皮肉なのは、私も現場ではちゃんと仕事をしているということだ。設計レビューでは慎重に判断し、コードレビューでは丁寧にフィードバックし、技術選定では様々な側面から検討する。プロとして当たり前のことをやっている。でも、SNSに投稿する瞬間、その全部を捨てる。「エンジニアの最大の課題は健康管理です」——実際には、チームによって違う。規模によって違う。状況によって違う。そんなこと分かってる。でもSNSでは「です」と断言する。その方がバズるから。専門家として積み上げてきた「慎重さ」「多角的な視点」「文脈への配慮」——これら全部が、SNSでは足かせになる。プロフェッショナルであればあるほど、SNSでは不利になる構造。逆に言えば、SNSで伸びてる人が現場でも優秀かというと、全く関係ない。むしろ、極端な主張を平気でできる人の方が、SNSでは有利だ。実務での慎重さや経験は、むしろ邪魔になる。私はそのギャップを自覚しながら、両方やっている。現場では慎重に。SNSでは断定的に。使い分けているというより、人格を切り替えている感覚に近い。でも、若手がこれを真に受けたらヤバい。SNSの極端な主張を、そのまま現場に持ち込んだら確実に嫌われる。「〇〇は絶対にダメです！」なんて新人が言い出したら、「いや、状況による」って言われて終わりだ。SNSと現場は、完全に別のゲーム。そのルールの違いを理解せずにプレイすると、どちらでも負ける。専門知は、もういらないのか――無知礼賛と民主主義作者:トム・ニコルズみすず書房Amazon言語化という罠この「レベル1」でグルグル回る構造は、SNSだけの問題じゃない。ここ数年、本屋に行くと「言語化」をテーマにした本が平積みされている。「言語化できる人がうまくいく」とか「賢い人の伝わる説明」とか「話す前に考えていること」とか。どれも似たような主張。言語化さえできれば、問題が解決するかのような売り方。でもちょっと待ってほしい。言語化って、本当に問題を解決するのか？私の経験から言うと、違う。言語化は問題を解決しない。言語化は情報を欠損させて、共有しやすくするだけだ。考えてみてほしい。実際のバグ修正のプロセスを。スタックトレースを追い、変数の状態を確認し、ブレークポイントを設置し、何度も再現テストを繰り返す。その過程で得られる膨大な情報、微妙な挙動の違い、環境依存の要因、タイミングの問題。これらすべてを経験して、ようやく根本原因にたどり着く。でも、これを言語化するとどうなるか。「○○が原因でバグが発生していました。△△に修正しました」。何百時間分の試行錯誤が、たった2行に圧縮される。この圧縮の過程で何が起きているか。情報の99%が削ぎ落とされている。なぜそのバグに気づいたのか、どんな仮説を立てたのか、どれだけの袋小路に迷い込んだのか、何がブレークスルーになったのか。本当に価値のある情報——次に同じような問題に直面した時に役立つ情報——は、すべて捨てられる。残るのは、きれいに整理された結論だけ。それは確かに「共有しやすい」。SlackやXに投稿しやすい。みんなが「なるほど」と言える。でも、それを読んだ人が同じ問題を解決できるようになるか？答えはNOだ。SNSで断定的に語る「エンジニアの本質」も同じ構造だ。「エンジニアの根本の仕事は言語化です」。これを読んだ人は「なるほど、たしかに要件定義も設計も全部言語化だな」と納得する。スッキリする。腑に落ちる。でも実際の要件定義って何か。顧客の曖昧な要望を聞き取り、矛盾を見つけて指摘し、実現可能性を検討し、代替案を提示し、合意形成を図る。その過程での非言語的なコミュニケーション、表情の変化、声のトーン、沈黙の意味。これら全部を経験して初めて「要件定義」ができるようになる。でも「要件定義は言語化」という言葉には、その複雑さは一切含まれない。言語化によって、最も重要な「どうやってやるか」という情報が欠損している。私の構文もまさにこれをやっていた。「エンジニアの最大の課題は健康管理です」。この一文に圧縮するために、どれだけの情報を捨てたか。どんな健康問題が起きやすいのかなぜエンジニアは健康を害しやすいのか具体的にどんな対策が効果的なのか継続するための仕組みづくり挫折しやすいポイントと対処法これら全部を削ぎ落として、消化しやすい一文にする。読んだ人は「そうそう！」と共感する。でも健康管理ができるようになるわけじゃない。言語化は魔法じゃない。むしろ情報を捨てる技術だ。複雑な現実を、他人が飲み込める大きさに切り刻む作業。その過程で、最も価値のある部分——泥臭い試行錯誤の過程——が失われる。でも皮肉なことに、SNSやビジネス書の世界では、この「情報を捨てた後の残骸」こそが価値として流通している。なぜなら、それが一番「バズる」から。一番「売れる」から。さらに皮肉なのは、「ビジネス書100冊の教えをまとめた本」みたいなメタ自己啓発本まで出てきたこと。100冊分の知識を1冊で！という触れ込み。情報の欠損に次ぐ欠損。エッセンスのエッセンスのエッセンス。最後に残るのは、何の栄養もないサプリメントみたいな言葉の羅列。「ひとつのことをやり続けろ」と「ひとつのことをやり続けるな」。「ポジティブ思考が大事」と「ネガティブにフォーカスしろ」。どっちが正解なの？って思うけど、実はどっちでもいい。なぜなら、どちらも「なるほど」と思えるから。状況によって都合よく解釈できるから。そして結局、どちらも実践しないから。果ては、読まない自己啓発本を「なぜ、読めないのか？」と分析する本まで出てきた。買うだけで満足する自己啓発本について、なぜ読めないのかを解説する自己啓発本。これも買うだけで満足されるんだろうか。メタメタ自己啓発の無限ループ。SNSも同じ構造だ。言語化された「エンジニアの本質」を読んで「なるほど」と思う。でも実践はしない。だから同じような内容が手を変え品を変えて投稿されても、毎回新鮮に感じる。毎回「いいね」を押す。私もその供給側に回ってしまった。需要があるから供給する。言語化して、共感を集めて、バズらせる。市場原理としては正しい。でもエンジニアとして正しいかは別問題だ。さみしい夜にはペンを持て作者:古賀史健ポプラ社Amazonさみしい夜のページをめくれ (一般書)作者:古賀　史健ポプラ社Amazonタイパという幻想なぜ私たちは「レベル1」の罠から抜け出せないのか。それは現代の呪文「タイパ」にも原因がある。「すぐに結果がほしい！」——これこそが、搾取される側に回ってしまう人々の最大の特徴である。焦燥感に駆られた人間は、じっくりと腰を据えて物事に取り組むことができない。時間という最も貴重な投資資源を惜しみ、検証や比較検討のプロセスを省略してしまう。その結果、本来であれば選択すべき確実性の高い選択肢を見送り、「即効性」を謳う甘い罠に飛びついてしまうのだ。こうした人々が手にするのは、表面的には「成功」や「結果」に見える幻影だ。一時的な高揚感、束の間の満足感——しかし、それらは砂上の楼閣のように脆く、瞬く間に崩れ去る。そして失ったものを取り戻そうと、さらに性急な判断を重ね、同じ過ちを繰り返す。この悪循環は加速度的に進行する。資金、時間、精神的余裕、人間関係——あらゆるリソースが急速に枯渇していく。皮肉なことに、リソースが減れば減るほど、「今すぐ挽回したい」という焦りは強まり、ますます長期的な視点を持てなくなる。まさに負のスパイラルだ。対照的に、待つことができる人、忍耐強く種を蒔き育てることができる人は、決して搾取される側には立たない。彼らは複利の力を理解し、小さな積み重ねが大きな成果につながることを知っている。短期的な誘惑に惑わされず、本質的な価値を見極める眼を持っているのである。SNSの「レベル1」コンテンツは、まさにこの「タイパ」を求める心理に最適化されている。3秒で理解できて、5秒で共感できて、1秒で「いいね」が押せる。でも、3秒で理解できることに、本当の価値があるのか？エンジニアリングの本質は、時間をかけて複雑な問題と向き合うことだ。バグの原因を突き止めるのに何時間もかかることもある。新しい技術を習得するのに何週間もかかることもある。でもSNSは、その対極の価値観を植え付ける。「エンジニアの本質を1分で理解！」みたいな投稿が求められ、それを供給する側に私はいる。これがどれだけ矛盾してるか、分かってる。でもやめられない。タイパの経済学 (幻冬舎新書)作者:廣瀬涼幻冬舎Amazon感情キーワードバトルという地獄もっと深刻な問題がある。SNSが「議論」の形を完全に破壊したことだ。誰も元の投稿を読んでいない。自分が反応したいキーワードだけ拾って引用RTして、自分の言いたいことを言ってるだけ。元の文脈なんて無視。それを見た人がまた違う解釈で反応。伝言ゲームどころか、最初から誰も同じ話をしてない。「技術的負債」って言葉を使えば、ある人は「日本企業の問題」を語り始め、別の人は「負債じゃなくて投資と呼ぶべき」と言い出し、また別の人は「エンジニアの給料」の話にすり替える。全員が違う話をしているのに、全員が「議論に参加している」と思い込んでいる。一番ヤバいのは、この「感情キーワードバトル」に参加してる人たちが本当に議論してると思い込んでることだ。お互い別の話してるのに「論破した」「反論できないだろ」って勝利宣言。誰も誰の話も聞いてない。ただ自分の感情を違うキーワードで叫び続けてるだけ。これが「正しい議論の形」として定着していく。キーワードに脊髄反射、感情的に反論、さらに過激な言葉で応酬。このサイクルが「活発な議論」だと勘違いされる。本当に内容を理解して話そうとする人は「空気読めない」扱い。SNSが作り出した完成形がこれだ。構文の進化と劣化初期の構文はまだ救いがあった。「エンジニアの最大の課題は、実は健康管理です。長時間のコーディングや締め切りのストレスが、創造性と生産性を低下させることに気づきました」。少なくとも「気づき」があった。体験があった。今の構文は完全にテンプレート化している。「エンジニアの本質は〇〇です。なぜなら××だからです。△△することが大切です」。中身がない。でもバズる。なぜなら、誰も中身を求めてないから。言語化して、整理して、共感を得る。でもそれだけ。実際の問題は何も解決しない。でも「理解した」気になるから、それで満足する。次の日には忘れて、また似たような構文に「いいね」を押す。手段として理解して使うここまで批判的に書いてきたが、実のところ、私は大人なので、SNSの活用については広報的な意味合い以上のものをあまり持ち合わせていない。フォロワー数は技術力じゃない。いいねの数はコードの質じゃない。影響力は問題解決能力じゃない。これらは全部、当たり前のことだ。SNSは私にとって広報ツールだ。会社の認知度を上げ、採用に貢献し、登壇機会を増やす。そういう実利的な面で活用している。9500人のフォロワーは、その成果の一つの指標に過ぎない。言語化が上手くなっても、コードが上手く書けるわけじゃない。構文を量産できても、サービスが作れるわけでも良いアーキテクチャができるわけじゃない。でも、それでいい。別のスキルだから。営業スキルと開発スキルが別物であるのと同じように。コードを書いている時、「これツイートにできるな」と思うことがある。でもそれは、仕事の経験を別の形でアウトプットする機会として捉えているだけだ。本業に支障はない。むしろ、言語化することで自分の理解が深まることもある()。大人としての割り切りこの記事を書きながら、「これもバズるだろうな」と計算している。それの何が悪いのか。自己批判もコンテンツの一つだ。メタ的な視点も価値提供の一形態だ。それでエンゲージメントが得られるなら、広報戦略として成功だ。でも同時に、私は誠実でありたいとも思っている。矛盾してる？そうかもしれない。私がやっていることは、ある側面から見れば明らかに「悪」だ。「レベル1」の罠を批判しながら、自分がその供給者になっている。若手エンジニアが本質的な学習から逃げる口実を提供している。「勉強した気」になる麻薬を売っている。この自覚がある。だからこそ、せめて誠実でありたい。自分が何をしているか、それがどんな影響を与えているか、目を逸らさずに直視する。綺麗事で飾らない。正当化もしない。SNSは仕事の一部。朝の投稿は、メールチェックと同じルーティン。フォロワーとのやり取りは、ネットワーキングの一環。感情的にならずに、淡々とこなす。でも、その行為が持つ毒性も理解している。syu-m-5151.hatenablog.comこの辺りの考え方は、上の記事でも書いた通り。SNSは道具であり、それ以上でもそれ以下でもない。でも道具は使い方次第で武器にも毒にもなる。結局のところ、絶対的な正義なんてない。技術的に正しいことだけが正義でもないし、ビジネス的な成功だけが正義でもない。SNSで影響力を持つことが善でも悪でもない。いや、違う。悪い面もある。確実にある。でも、それを自覚した上でやる。目を開いたまま、自分が加担している構造を理解しながら、それでも続ける。なぜなら、それが大人の仕事だから。大事なのは「したたかに、上手くやる」ということ。自分の技術的興味を追求しながら、会社にも価値を提供する。SNSで発信しながら、コードも書く。構文でバズらせながら、良い本を紹介する。悪であることを自覚しながら、それでも誠実に。全部やればいい。若手エンジニアがSNSの罠にハマるリスクは理解している。だから警告もする。自分が掘った落とし穴に「危険」の看板を立てるような偽善かもしれない。でも私自身は、もうその段階は過ぎた。道具は道具として使う。毒は毒として扱う。それだけの話だ。誠実であることと、悪を自覚することは矛盾しない。むしろ、悪を自覚しているからこそ、誠実でありたいと思う。少なくとも、自分が何をしているかについては嘘をつかない。それが私なりの最低限の誠実さだ。おわりに1年前の自戒「コード以外で目立つな」は、純粋だった。今なら違う。ソフトウェアエンジニアエンジニアもSNSも、どっちも仕事。SNSでバズることとエンジニアとしての価値は別物だ。言語化の上手さとコーディング能力も別物だ。当たり前だ。でも、両方できた方が良くないか？若手には今でも「SNS閉じてエディタ開け」と言う。まずちゃんとしたエンジニアリングを知ってほしいから。複雑な問題と格闘する充実感を味わってほしいから。でも経験を積んだら、両方開いておけばいい。私は今日も構文を作る。コードも書く。会社の広報もする。矛盾？知ったことか。SNSの罠にハマるな。でも罠を理解したら、利用しろ。技術を追求しろ。でも手段と目的を間違えるな。何より、上手くやれ。それだけだと思う。でも、自分がフォロワー数というココナッツの中の米を握った猿でないとは言えないので数年後のnwiizoを楽しみにしておいて下さい。","isoDate":"2025-09-03T08:48:30.000Z","dateMiliSeconds":1756889310000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"『禅とオートバイ修理技術』を読んだ。","link":"https://syu-m-5151.hatenablog.com/entry/2025/09/01/145700","contentSnippet":"はじめにプログラマーとして働き始めて数年が経った頃、私は壁にぶつかっていた。コードは書ける。バグも直せる。でも、何かが足りない。毎日キーボードを叩きながら、「これでいいのか」という疑問が頭をよぎる。そんな時期に、勉強会で出会った人が一冊の本を勧めてくれた。私は勧められた本を買うのが好きで、その場で積読として購入した。今となってはその人の顔も名前も思い出せないけれど、あの時の一言には本当に感謝しています。『禅とオートバイ修理技術』――タイトルを聞いた時は、正直なところピンと来なかった。禅？オートバイ？エンジニアである私とどう関係があるのか。禅とオートバイ修理技術 上 (ハヤカワ文庫NF)作者:ロバート Ｍ パーシグ早川書房Amazon禅とオートバイ修理技術 下 (ハヤカワ文庫NF)作者:ロバート Ｍ パーシグ早川書房Amazonでも読み始めてみると、これが不思議と心に響いた。技術と向き合うこと、品質を追求すること、理性と感性の葛藤。オートバイの修理を通じて語られる哲学は、まさに私がプログラミングで感じていた言語化できないモヤモヤそのものだった。以来、この本は私の座右の書となった。行き詰まるたびに読み返し、そのたびに新しい発見がある。最初は理解できなかった箇所が、経験を積むにつれて腑に落ちるようになる。まるで本自体が、読む人の成長に合わせて違う顔を見せてくれるかのようだ。実はこの文章も、5年前に書き始めて完成できずに下書きに眠っていたものだ。今回改めて書き直してみると、当時とはまったく違う視点でこの本を読んでいることに気づく。それだけ自分も変化したということなのだろう。特に若手のエンジニアには、ぜひ一度手に取ってもらいたい。技術書やビジネス書とは違う角度から、エンジニアリングの本質について考えさせてくれる。すぐには理解できなくても構わない。キャリアを重ねる中で、きっとこの本の言葉が響く瞬間が来るはずだ。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。古典的な思考とロマン的な思考本書の主人公は、物語の冒頭では古典的な（理性を重んじる）立場にいる。ロマン的な（情緒を重んじる）友人たちに対して、無理解で批判的な態度を取る。オートバイの構造を理解しようとしない友人を見下し、技術への無知を軽蔑する。メンテナンスを他人任せにする友人に苛立ち、「なぜ自分で理解しようとしないのか」と内心で批判する。読んでいて、胸が痛くなった。これは過去の私そのものだった。「なぜコードの仕組みを理解しようとしないんだ」と、フレームワークの内部実装に興味を示さない同僚を見下していた。「とりあえず動けばいい」という態度が理解できなかった。技術の背後にある原理を知ろうとしない人々を、内心で「浅い」と批判していた。私にとって、コードの構造を理解することこそが美しく、アルゴリズムの優雅さこそが感動的だった。でも、多くの人にとっては違う。彼らは技術を道具として使い、その先にある価値創造に集中していた。技術の詳細に囚われず、より大きな視点で物事を見ていた。古典的な視点からは、ロマン的な人々は「表面的」に見える。でもロマン的な視点からは、古典的な人々は「冷たく」「機械的」に見える。どちらも一面的な見方でしかない。以前、私は「正義のエンジニアという幻想」について考えたことがある。技術的に正しいことを追求し、それ以外を否定する。「媚びない」と言いながら、実際はただ無礼なだけ。技術的正しさを盾に、人間関係の機微を「非論理的」と切り捨てる。まさに、本書の主人公の初期の姿そのものだった。syu-m-5151.hatenablog.comしかし物語が進むにつれ、主人公の本当の目的が明らかになる。彼は実は中道を目指していた。古典的な立場とロマン的な立場を《クオリティ》という概念で統一しようとしていたのだ。分析と直感、構造と体験、理性と感性。対立ではなく、統合こそが答えだった。クオリティという統合点パーシグは「クオリティ」という概念を追求した。それは定義できない。定義した瞬間、別のものになってしまう。でも確実に存在する。誰もが「良いコード」と「悪いコード」の違いを感じることができる。しかし、その「良さ」を完全に言語化しようとすると、何か本質的なものが抜け落ちてしまう。改訂新版　良いコード／悪いコードで学ぶ設計入門 ―保守しやすい　成長し続けるコードの書き方作者:仙塲 大也技術評論社Amazon「可読性が高い」「保守しやすい」「パフォーマンスが良い」――これらは確かに重要な要素だが、それだけでは説明しきれない「何か」がある。syu-m-5151.hatenablog.comこの逆説的な性質は、グッドハートの法則やキャンベルの法則を思い起こさせる。「測定されるものは改善される。測定基準となったものは、良い測定基準ではなくなる」――クオリティを定量化しようとした瞬間、それは本来のクオリティから離れていく。コードカバレッジ100%を目指したら、意味のないテストが増えた。cyclomatic complexityを下げようとしたら、かえって読みにくいコードになった。メトリクスは重要だが、メトリクスがすべてではない。数値化された瞬間、クオリティは形骸化する。測りすぎ――なぜパフォーマンス評価は失敗するのか？作者:ジェリー・Z・ミュラーみすず書房Amazon優れたコードを見た瞬間の「これだ」という感覚。それは論理的分析より先に来る。でも、単なる感情でもない。理性と感性が融合した瞬間に現れる何か。センスの哲学 (文春e-book)作者:千葉 雅也文藝春秋Amazonある日、オープンソースのコードを読んでいて息を呑んだことがある。複雑な問題を、驚くほどシンプルに解決していた。無駄が一切なく、それでいて拡張性も担保されている。「美しい」としか言いようがなかった。後から分析すれば、SOLID原則に従っているとか、デザインパターンが適切に使われているとか説明できる。でも、最初に感じたのは、理屈を超えた「美」だった。古代ギリシアでは、これを「アレテー」と呼んだ。「それそのものが持つポテンシャルを最大限発揮している状態」。馬には馬のアレテーがあり、ナイフにはナイフのアレテーがある。コードで言えば、その、コードやシステムが解決すべき問題に対して、最も自然で、最も美しく、最も効果的な形で存在している状態。過不足がない。シンプルだが単純ではない。複雑な問題を複雑に解くのではなく、本質を見抜いて エレガント に解く。それがコードのアレテー、つまりクオリティだ。理性だけでは到達できない。感性だけでも到達できない。両方が必要だ。論理的な正しさと、直感的な美しさ。分析と統合。部分と全体。これらが調和した時、初めてクオリティが現れる。A Philosophy of Software Design, 2nd Edition (English Edition)作者:Ousterhout, John K. ISSVWOAmazon物語の転換物語の終盤、主人公は古典的な立場への疑問を深めていく。科学的方法は使い続けるが、科学万能主義には批判的になる。むしろロマン的な立場に理解を示し始める。きっかけは、科学的方法の限界に直面したことだった。オートバイの不調の原因を論理的に分析し、仮説を立て、一つずつ検証していく。しかし、問題は解決しない。考えられる原因をすべて潰しても、バイクは不調のまま。そして気づく――仮説は無限に作れることに。「一定の現象を説明しうる合理的な仮説の数は無限にある」この気づきが、主人公を変えた。科学は仮説を検証する方法は教えてくれるが、どの仮説を選ぶべきかは教えてくれない。無限の可能性の中から、どうやって「これだ」という一つを選ぶのか。絶対的な真理など存在しない。だとしたら、何を基準に選択すればいいのか？答えは「クオリティ」だった。論理的な正しさだけでなく、その状況における「良さ」を感じ取る能力。理性と感性を統合した判断。優れた整備士は、エンジン音を聞いただけで不調の原因を言い当てる。それは論理的推論の結果ではない。経験と直感が導く「これしかない」という確信。主人公は理解する。友人たちがオートバイの仕組みを知ろうとしないのは、怠惰ではなく、別の関わり方を選んでいるからだ。彼らにとってバイクは、風を感じ、自由を味わう道具。内部構造など知らなくても、その本質的な価値は変わらない。古典的でもロマン的でもなく、その両方を包含する視点。それこそが、パーシグが追い求めていたものだった。無限の仮説とプログラミングプログラミングでも同じことが起きる。一つの問題を解決する方法は無数にある。私も経験がある。新規プロジェクトのアーキテクチャを決める時、本を読めば読むほど迷走した。『クリーンアーキテクチャ』は「ビジネスロジックを中心に」と説く。『マイクロサービスパターン』は「サービスの分割を」と勧める。『レガシーコード改善ガイド』は「まずテストから」と主張する。どれも正しい。でも、どれも部分的だ。ある時、気づいた。これらの本は地図のようなものだ。山頂への道は無数にあり、どの道も「正しい」。でも、今の自分たちのチームが、この天候で、この装備で登るべき道は一つ。その判断は、地図だけでは下せない。だから必要なのは、理論を超えた何か。コンテキストを読み取り、チームの状況を感じ取り、ユーザーの気持ちを想像する。スタートアップなら速度を、エンタープライズなら堅牢性を、でもそれも一概には言えない。チームの経験、プロダクトの成熟度、市場の要求、技術的負債の現状――すべてを総合的に「感じ取って」判断する。論理と感性を統合した判断。それは経験を積むことでしか身につかない。でも、それこそがシニアエンジニアの真の価値なのかもしれない。無限の選択肢の中から、「今、ここで、このチームが選ぶべき道」を見出す能力。それもまた、クオリティの一つの形だ。アーキテクトの教科書 価値を生むソフトウェアのアーキテクチャ構築作者:米久保 剛翔泳社Amazon主客の融合オートバイのメンテナンス中、固着したネジと格闘する場面がある。パーシグはこう語る。「修理工とオートバイは永遠に別個の存在ではない。二元的な考え方をすることで、修理工とオートバイとの間に存在する分離できない関係、つまり仕事に専心する職人気質といったものが失われてしまう」プログラミングも同じだ。私たちはコードを「書く」のではない。システムと対話し、問題空間と解決空間を行き来しながら、共に答えを見つけていく。フロー状態に入った時、キーボードは手の延長になり、思考は直接コードになる。変数名を考える必要もない。自然と適切な名前が浮かぶ。この時、プログラマーとコードの境界は消える。理性も感性も超えた、純粋な創造の瞬間。最近流行りのAIによるコード生成では、この感覚は得られない。プロンプトを書いて、生成されたコードをレビューして、修正を指示する。それは便利だし、効率的かもしれない。でも、そこには主客の分離がある。私とコード、指示する者と実行する者という二元的な関係。AIがどれだけ進化しても、この融合の瞬間は体験できないのかもしれない。それは効率や正確さとは別の次元の話だから。パーシグが固着したネジと格闘しながら得た洞察、その瞬間の一体感。それは自分の手でコードを書き、自分の頭で考え、自分の感覚で判断することでしか得られない。少なくとも今のところはその兆しすら感じない。熟達論―人はいつまでも学び、成長できる―作者:為末大新潮社Amazon心の静寂「バイクの修理に取り組むときに心がけるべきことは、自他の分離をしないような心の落ち着きを養うことである。心の落ち着きは正しい価値を生み、正しい価値は正しい思念を生む」デバッグで行き詰まった時、論理的分析だけでは見えないものがある。深呼吸して、システムの「気配」を感じる。ログを機械的に読むのではなく、パターンを「感じ取る」。正常時と異常時の「違和感」を察知する。これは非科学的なことではない。むしろ、科学と直感を統合した、より高次の認識方法だ。将棋の棋士が盤面を「読む」ように、経験豊富なエンジニアはシステムを「読む」。それは論理的分析と直感的理解が融合した、独特の認識方法だ。心が乱れていると、コードも乱れる。焦って書いたコードは、必ずどこかに歪みがある。逆に、落ち着いた心で書いたコードは、自然で無理がない。心の状態は、そのままコードの質に反映される。奪われた集中力: もう一度〝じっくり〟考えるための方法作者:ヨハン・ハリ作品社Amazonガンプション・トラップパーシグが作った「ガンプション・トラップ」という概念は、創造的な活動における意欲や熱意（ガンプション）を奪う罠のことだ。理性の側には、完璧な設計への固執という罠がある。「もっとエレガントな解法があるはずだ」という思いに囚われて、永遠にリファクタリングを続ける。より良い抽象化を求めるあまり、実装が進まない。分析に分析を重ね、結局は麻痺状態に陥る。一方、感性の側にも危険が潜んでいる。「なんとなくXXが好き」「とにかくYYに慣れている」という理由だけで技術選定をする。最初の直感に囚われて、他の可能性を検討しない。「このコードは美しい」という感覚に酔いしれて、実用性を忘れる。特に「価値観の硬直」の話が印象的だった。南インドの猿の罠――ココナッツの中の米を握った猿は、手を離せば自由になれるのに、米を手放せない。私たちも同じだ。「これがベストプラクティスだから」と言いながら、実は状況が変わっていることに気づかない。逆に、「自分のやり方」に固執して、明らかに優れた新しい手法を拒絶する。罠は至るところにある。それを避けるには、自分が今どの罠に陥りかけているかを認識し、一歩引いて見る必要がある。情報を正しく選択するための認知バイアス事典 行動経済学・統計学・情報学 編作者:情報文化研究所フォレスト出版Amazonテクノロジーとの関係性「真の醜さの原因は、テクノロジーを生み出す人々と、彼らが生み出す物との関係のなかに横たわっている」パーシグはこの言葉で、技術そのものが問題なのではなく、私たちと技術の関係が問題だと指摘する。オートバイを恐れる友人も、オートバイに依存する主人公も、どちらも不健全な関係だった。技術を理性的に分析するだけでも、感情的に拒絶するだけでもダメだ。技術と「共に在る」ことが大切。対話し、感じ取り、理解し、共に成長する。新しいフレームワークを学ぶ時、ドキュメントを読むだけでは不十分。実際に触って、感触を確かめ、「このフレームワークが望んでいること」を感じ取る。作者の思想、コミュニティの文化、設計の美学。技術の向こう側にある「人間」を理解する。技術は道具以上の存在になりうる。それは私たちの思考を拡張し、新しい可能性を開く。でも同時に、技術に振り回されることもある。流行に飛びつき、本質を見失い、手段が目的化する。パーシグが言うように、技術との健全な関係を築くには、クオリティを中心に据える必要がある。行き詰まりの価値プログラミングには様々な行き詰まりがある。どんな設計にすべきか何日も悩む。アーキテクチャの方向性で迷い続ける。技術選定で延々と議論する。実装方法が思いつかない。エラーの原因が分からない。これらはすべて、私たちが日常的に経験する行き詰まりだ。パーシグも、オートバイの不調だけでなく、人生の様々な場面で行き詰まりと向き合った。大学での哲学的探求、クオリティの定義、東洋と西洋の思想の統合。どれも簡単には答えが出ない問題だった。しかし、その行き詰まりこそが、彼を深い洞察へと導いた。行き詰まりは、今使っている思考法の限界を示すサインだ。論理だけで解決しようとしているなら、直感を使ってみる。感覚だけで進めているなら、分析的に考えてみる。視点を変え、アプローチを変え、時には問題そのものを問い直す必要がある。最高のブレイクスルーは、理性と感性が統合された瞬間に起きる。散歩中に突然解決策が浮かぶのは、論理的思考が一旦止まり、無意識の直感が働くからだ。しかし、その直感は、それまでの論理的分析があってこそ生まれる。苦闘は無駄ではない。それは答えを「熟成」させる時間なのだ。最近では、生成AIに問題を投げれば、すぐに答えが返ってくる。確かに便利だ。でも、そこには何かが欠けている。パーシグがオートバイと格闘しながら得た洞察、その苦闘の中で培われた理解の深さ。それは、答えを与えられることでは決して得られない。自分で考え、悩み、試行錯誤することで初めて、問題の本質が見えてくる。技術への理解が深まり、思考が鍛えられ、判断力が養われる。だから行き詰まりを恐れる必要はない。それは成長の前兆であり、ブレイクスルーの準備期間だ。大切なのは、行き詰まりと向き合う姿勢。焦らず、諦めず、クオリティを追求し続けること。その先に必ず何かが見えてくる。中道への道物語を通じて、主人公は変化していく。最初は理性の側に偏り、ロマン的なものを軽視していた。しかし、理性の限界を知り、感性の価値を認識し、最終的には両者を統合する道を見出す。この変化は緩やかで、時に後退しながら進む。主人公は何度も自分の過去（パイドロス）と向き合い、その度に少しずつ理解を深めていく。完全な統合ではなく、絶え間ない調整のプロセスとして。私も似た道を歩んでいる。最初は、論理と理性こそがすべてだと思っていた。設計パターンを暗記し、アルゴリズムを学び、ベストプラクティスを追求した。コードレビューでは「なぜこう書いたのか」を論理的に説明できることが最重要だと信じていた。感覚的な判断は「プロらしくない」と切り捨てていた。転機は、あるシニアエンジニアとのペアプログラミングだった。彼は設計を決める時、まず黙って考え、そして「これが気持ちいい」と言った。最初は戸惑った。でも、その設計は確かに優れていた。後から理由を分析すると論理的にも正しかったが、彼は直感が先行していた。今では分かる。優れたコードには、論理を超えた「何か」がある。それは説明できないけれど、確実に感じることができる。コードを読んだ瞬間の「あ、これは違う」という違和感。リファクタリング後の「これだ」という確信。これらは理性的分析の前に訪れる。でも、だからといって直感だけに頼るわけではない。感じた「何か」を論理的に検証し、言語化する努力も続ける。理性と感性は対立するものではなく、互いを補完し合うパートナーなのだ。中道とは、真ん中に立ち止まることではない。両極を知り、状況に応じて自在に行き来すること。時には徹底的に論理的に、時には大胆に直感的に。そして多くの場合は、その両方を同時に働かせながら。この「何か」を追求することこそが、本当のプログラミングなのかもしれない。技術は手段であり、目的は「良いもの」を作ること。その「良さ」は、理性と感性が調和した時に初めて生まれる。達人プログラマー ―熟達に向けたあなたの旅― 第2版作者:David Thomas,Andrew Huntオーム社Amazonおわりにパーシグは「クオリティ」を追求するあまり精神を病み、最終的には息子との旅を通じて、理性と感性を統合する道を見つけた。この本を読んで10年以上経つが、私のエンジニアリングへの向き合い方は確実に変わった。昔は「正しいコード」を書くことばかり考えていた。設計パターンに当てはめ、メトリクスを改善し、ベストプラクティスを守る。それが良いエンジニアだと思っていた。でも今は違う。チームの状況、プロダクトの段階、ユーザーのニーズ――すべてを考慮して「今ここで最適な選択」をすることが大切だと理解している。コードレビューの姿勢も変わった。以前は「なぜこう書いたのか」を論理的に説明することを求めていた。今は「これで良さそう」という直感的な判断も大切にしている。もちろん、その直感を後から論理的に検証することは忘れないが。『禅とオートバイ修理技術』は、エンジニアリングの教科書ではない。でも、技術と向き合う姿勢について、どんな技術書よりも深い示唆を与えてくれる。良いコードを書くには、論理的思考も直感も必要だ。設計の美しさを感じ取る感性と、それを実装する技術力。問題の本質を見抜く洞察力と、地道にデバッグする忍耐力。これらはどれも欠かせない。技術は進化し続ける。新しいフレームワーク、新しいパラダイム、新しいツール、AIなども忘れてはいけない。でも、「良いものを作りたい」という気持ちと、そのための試行錯誤は変わらない。もし若手エンジニアがこれを読んでいるなら、ぜひ『禅とオートバイ修理技術』を手に取ってみてほしい。すぐには理解できないかもしれない。でも、エンジニアとして経験を積むうちに、きっとこの本の言葉が響く瞬間が来る。その時、あなたのエンジニアリングは一段階上のレベルに達しているはずだ。ただ、残念なことに、この本は現在電子書籍でしか読めない。紙の本がないんです(プレ値がついてます)。Kindleで読むのも悪くないけれど、こういう何度も読み返したくなる本は、やっぱり紙で持っていたい。ページに付箋を貼ったり、大事な箇所に線を引いたり、表紙が擦り切れるまで読み込みたい。そういう本なんです、これは。早川書房の担当者さん、もしこれを読んでいたら、ぜひ紙の本での復刊を検討していただけないでしょうか。ハードカバーでも文庫でも、とにかく紙で読めるようにしてほしい。きっと多くのエンジニアが、デスクの横に置いて、迷った時に手に取る一冊になるはずです。","isoDate":"2025-09-01T05:57:00.000Z","dateMiliSeconds":1756706220000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":" RustでLinuxのシグナル処理とプロセス間通信をしてみた","link":"https://syu-m-5151.hatenablog.com/entry/2025/08/22/155856","contentSnippet":"はじめに前回の記事「RustでLinuxプロセス管理をしてみた」の続編として、今回はシグナル処理とプロセス間通信（IPC）について解説します。これらの技術は、システムプログラミングの根幹をなす重要な概念です。doc.rust-lang.orgサンプルコードはこちらに配置しておきます。github.com2025年の最新動向2025年現在、Rustエコシステムは大きな転換期を迎えています。Linux 6.13が2025年1月にリリースされ、Rustサポートが「転換点」に到達しました。また、非同期ランタイムの世界では、async-stdが2025年3月に廃止されることが決まり、Tokioが事実上の標準となっています。さらに、Rust 1.85ではasync closuresが安定化され、より表現力豊かな非同期処理が可能になりました。1. 基礎知識書籍はこちらがめちゃくちゃに詳しいのでオススメです。ふつうのLinuxプログラミング 第2版　Linuxの仕組みから学べるgccプログラミングの王道作者:青木 峰郎SBクリエイティブAmazonプロセスとはプロセスは「実行中のプログラムのインスタンス」です。皆さんが日常的に使うWebブラウザのタブやターミナルのセッションは、すべてプロセスとして動作しています。各プロセスは独立したメモリ空間を持ち、他のプロセスから直接アクセスすることはできません。これがシステムの安定性と安全性を保証していますが、同時にプロセス間でデータをやり取りする特別な仕組みが必要になる理由でもあります。シグナルとはシグナルは、プロセス間の非同期通知メカニズムです。電話の着信音のように、プロセスに「何か重要なことが起きた」と割り込みで知らせる仕組みだと考えると分かりやすいでしょう。主要なシグナルと実際の用途： シグナル  番号  用途  実例  SIGTERM  15  正常終了要求  systemctl stopで送信される  SIGKILL  9  強制終了  kill -9、OOMキラー  SIGINT  2  割り込み  Ctrl+Cを押したとき  SIGHUP  1  設定再読み込み  nginxやsshdの設定リロード  SIGUSR1/2  10/12  カスタム用途  アプリ固有の動作トリガー シグナルには重要な特徴がいくつかあります。まず非同期性という性質があり、いつ届くか予測できません。また割り込みとして動作するため、実行中の処理を中断して処理されます。そしてシンプルな仕組みで、シグナル番号以外の追加情報を送ることはできません。rust-cli.github.ioプロセス間通信（IPC）とはIPCは、独立したプロセス同士がデータをやり取りするための仕組みです。それぞれの方式には特徴があり、用途に応じて使い分けます： 方式  特徴  実際の使用例  パイプ  単方向、親子プロセス間  ls | grepなどのシェルパイプ  名前付きパイプ  双方向、無関係なプロセス間も可  ログ収集デーモンへのデータ送信  Unix Domain Socket  双方向、高速、信頼性高  Docker、systemd、PostgreSQL  共有メモリ  最速、同期が複雑  データベースのバッファプール  メッセージキュー  非同期、順序保証  ジョブキューシステム 2. シンプルなシグナル処理Ctrl+Cを検知して安全に終了最もシンプルな例から始めてみましょう。Ctrl+Cを押したときに、きちんと後処理をしてから終了するプログラムです。use std::sync::atomic::{AtomicBool, Ordering};use std::sync::Arc;use std::thread;use std::time::Duration;fn main() {    println!(\"プログラム開始（Ctrl+Cで終了）\");        // 実行中フラグ（スレッド間で安全に共有）    let running = Arc::new(AtomicBool::new(true));    let r = running.clone();        // Ctrl+Cハンドラーを設定    ctrlc::set_handler(move || {        println!(\"\\n終了シグナルを受信しました\");        r.store(false, Ordering::SeqCst);    }).expect(\"シグナルハンドラーの設定に失敗\");        // メインループ    let mut counter = 0;    while running.load(Ordering::SeqCst) {        counter += 1;        println!(\"処理中... カウント: {}\", counter);        thread::sleep(Duration::from_secs(1));    }        println!(\"プログラムを安全に終了しました\");}このコードにはいくつかの重要なポイントがあります。まずAtomicBoolを使ってスレッド間で安全にフラグを共有しています。シグナルハンドラーはいつ呼ばれるか分からないため、アトミック操作が必要になります。そしてループを抜けてから終了処理を行うことで、データの整合性を保っています。docs.rsgithub.com複数のシグナルを処理実際のサーバーアプリケーションでは、複数のシグナルを適切に処理する必要があります。use signal_hook::{consts::signal::*, iterator::Signals};use std::{error::Error, thread, time::Duration};fn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {    let mut signals = Signals::new(\u0026[SIGTERM, SIGINT, SIGHUP])?;        thread::spawn(move || {        for sig in signals.forever() {            match sig {                SIGTERM | SIGINT =\u003e {                    println!(\"終了シグナルを受信\");                    std::process::exit(0);                }                SIGHUP =\u003e {                    println!(\"設定再読み込み\");                }                _ =\u003e unreachable!(),            }        }    });        // メイン処理    loop {        println!(\"作業中...\");        thread::sleep(Duration::from_secs(2));    }}docs.rsgithub.com3. プロセス間通信の基礎シンプルなパイプ通信親プロセスから子プロセスへメッセージを送る基本的な例です。use std::io::{Write, Read};use std::process::{Command, Stdio};fn main() -\u003e std::io::Result\u003c()\u003e {    // catコマンドは標準入力をそのまま標準出力に出力    let mut child = Command::new(\"cat\")        .stdin(Stdio::piped())        .stdout(Stdio::piped())        .spawn()?;        // 子プロセスに書き込み    if let Some(mut stdin) = child.stdin.take() {        stdin.write_all(b\"Hello from Rust!\\n\")?;    }        // 結果を読み取り    let output = child.wait_with_output()?;    println!(\"受信: {}\", String::from_utf8_lossy(\u0026output.stdout));        Ok(())}パイプには特徴的な性質があります。まず単方向通信であり、データは一方向にのみ流れます。またバッファリング機能があり、OSが自動的にバッファを管理してくれます。そしてブロッキング動作をするため、読み込み側は書き込みを待つことになります。docs.rsUnix Domain Socketより本格的な双方向通信の例です。多くのシステムソフトウェアが採用している方式です。Unix Domain Socketには多くの利点があります。双方向通信が可能で、クライアント・サーバー間で自由にやり取りできます。また、ネットワークスタックを通らないため高速に動作します。そしてファイルシステム上のパスとして存在するため、アクセス制御が簡単に行えます。4. デバッグツールの活用詳解 システム・パフォーマンス 第2版作者:Brendan Greggオーム社Amazonシステムプログラミングにおいて、問題を解決するには、まず問題を観察できなければならないという原則があります。特にシグナル処理やIPCのような非同期的な動作は、従来のprint文デバッグでは限界があります。そこで重要になるのが可観測性（Observability）という概念です。効果的なデバッグには階層的なアプローチが必要です。まずアプリケーション層で何が起きているかを把握し、次にシステムコール層まで掘り下げ、必要に応じてカーネル層まで観察します。各層に適したツールを使い分けることで、最小のオーバーヘッドで最大の洞察を得ることができます。また、動的トレーシングと静的トレーシングを使い分けることも重要です。straceのような動的トレーシングツールは実行中のプロセスをリアルタイムで観察でき、rr-debuggerのような記録再生型ツールは時間を巻き戻して問題の根本原因を特定できます。これらを組み合わせることで、再現困難なバグも確実に捕捉できるようになります。strace - システムコールトレースシグナル処理やIPCのデバッグには、システムコールレベルでの動作確認が不可欠です。# シグナル関連のシステムコールのみ表示strace -e trace=signal,sigaction,kill,pause cargo run# 実際の出力例rt_sigaction(SIGINT, {sa_handler=0x5555555, ...}, NULL, 8) = 0--- SIGINT {si_signo=SIGINT, si_code=SI_KERNEL} ---rt_sigreturn({mask=[]}) = 0straceを使うと様々な情報が見えてきます。シグナルハンドラーの登録状況（sigaction）、シグナルの送受信タイミング、ブロックされたシグナル、そしてシステムコールの引数と戻り値などを確認できます。strace.iorr-debugger（最強のデバッグツール）rrは、GDBを拡張して作られたデバッガで、プログラムの実行を記録し、逆方向にステップ実行できます。# プログラムの実行を記録rr record ./target/debug/my_program# rust-gdbを使って再生rr replay -d rust-gdb# リバース実行のコマンド(rr) reverse-continue  # 逆方向にcontinue(rr) reverse-next      # 逆方向にnextrrが強力な理由はいくつかあります。まず100%再現性があり、非決定的な動作も完全に再現できます。また逆実行機能により、エラーの原因を遡って調査できます。そして低オーバーヘッドで動作するため、実用的な速度で記録が可能です。特にシステムプログラミングでは、「たまにしか起きないエラー」や「データ競合」のデバッグで威力を発揮します。rr-project.orgtokio-console - 非同期ランタイムデバッグ非同期Rustアプリケーションのデバッグには、tokio-consoleが非常に有用です。タスクの状態、実行時間、リソース使用状況をリアルタイムで監視できます。# tokio-consoleをインストールcargo install --locked tokio-console# アプリケーション起動（別ターミナル）RUSTFLAGS=\"--cfg tokio_unstable\" cargo run# tokio-consoleで監視tokio-consolegithub.com5. グレイスフルシャットダウン実際のサービスで必要な、適切な終了処理の実装例を見てみましょう。グレイスフルシャットダウンが重要な理由は複数あります。まずデータの整合性を保つため、処理中のタスクを完了してから終了する必要があります。またリソースの解放として、ファイルやソケットを適切にクローズしなければなりません。そして状態の保存により、次回起動時に必要な情報を保存することも重要です。実装する際のポイントとしては、まず新規タスクの受付を停止し、新しい仕事を受け付けないようにします。次に既存タスクの完了を待機し、実行中の処理を最後まで実行させます。その後リソースのクリーンアップを行い、ファイルやネットワーク接続を閉じます。最後に統計情報の出力を行い、ログに実行結果を記録します。6. Tokioを使った非同期グレイスフルシャットダウンモダンなRustアプリケーションでは、Tokioを使った非同期処理が主流です。use tokio::signal;use tokio_util::sync::CancellationToken;#[tokio::main]async fn main() {    let token = CancellationToken::new();        // Ctrl+Cハンドラー    let shutdown_token = token.clone();    tokio::spawn(async move {        signal::ctrl_c().await.unwrap();        println!(\"シャットダウン開始\");        shutdown_token.cancel();    });        // メインループ    loop {        tokio::select! {            _ = token.cancelled() =\u003e {                println!(\"終了処理中...\");                break;            }            _ = do_work() =\u003e {                // 通常の処理            }        }    }}async fn do_work() {    // 非同期処理}CancellationTokenには多くの利点があります。階層的なキャンセルが可能で、親トークンをキャンセルすると子もキャンセルされます。また協調的な仕組みにより、各タスクが自分のタイミングで終了できます。そして非同期対応により、async/awaitと自然に統合されています。tokio.rsdocs.rsgithub.comdocs.rstokio.rs7. nixクレートでシステムコールを扱うRustでは、nixクレートを使って安全にUnixシステムコールを扱うことができます。libcクレートの生のAPIをラップし、Rust的な安全なインターフェースを提供しています。use nix::sys::signal::{self, Signal};use nix::unistd::{fork, ForkResult};match fork() {    Ok(ForkResult::Parent { child }) =\u003e {        println!(\"親プロセス、子PID: {}\", child);    }    Ok(ForkResult::Child) =\u003e {        println!(\"子プロセス\");    }    Err(_) =\u003e eprintln!(\"fork失敗\"),}nixクレートを使うことで、エラーハンドリングが適切に行われ、メモリ安全性が保証されます。生のシステムコールを直接扱う必要がなくなり、より安全なコードが書けるようになります。docs.rsgithub.com8. 2025年の新機能：Async ClosuresRust 1.85.0で安定化されたasync closuresを使うと、より柔軟な非同期処理が書けます。async fn retry_with_backoff\u003cF, Fut\u003e(    mut f: F,     max_retries: u32,) -\u003e Result\u003cString\u003ewhere    F: FnMut() -\u003e Fut,    Fut: Future\u003cOutput = Result\u003cString\u003e\u003e,{    for attempt in 1..=max_retries {        match f().await {            Ok(result) =\u003e return Ok(result),            Err(e) if attempt \u003c max_retries =\u003e {                let backoff = Duration::from_secs(2_u64.pow(attempt - 1));                sleep(backoff).await;            }            Err(e) =\u003e return Err(e),        }    }    unreachable!()}async closuresを使うメリットは多岐にわたります。まず簡潔な記述が可能になり、非同期処理を関数引数として渡せるようになります。また型安全であるため、コンパイル時に型チェックが行われます。そして柔軟な制御フローにより、リトライやタイムアウトの実装が簡単になります。実装パターンの選び方シグナル処理の選択基準シグナル処理の実装方法を選ぶ際は、用途に応じて適切なツールを選択することが重要です。単純な終了処理であればctrlcクレートで十分です。複数のシグナルを扱う必要がある場合はsignal-hookを使用します。そして非同期処理と組み合わせる場合は、Tokioのsignalモジュールが最適です。IPC方式の選択基準IPC方式も同様に、用途に応じて選択します。親子プロセス間の単純な通信であればパイプが適しています。高速な双方向通信が必要な場合はUnix Domain Socketを選びます。大量データの共有には共有メモリが最適で、非同期メッセージングにはメッセージキューが向いています。まとめこの記事では、Rustでのシグナル処理とプロセス間通信について、基礎から実践まで段階的に解説しました。重要なポイント今回学んだ重要なポイントを振り返ってみましょう。まず、シグナルは非同期であり、いつ届くか分からないためアトミック操作が必要です。IPCは用途に応じて選ぶ必要があり、速度、双方向性、複雑さのトレードオフを考慮します。グレイスフルシャットダウンはデータの整合性を保つために必須です。straceやrr-debuggerなどのデバッグツールを活用することで、問題を効率的に解決できます。そして、async closuresやCancellationTokenなどの最新機能を活用することで、保守性を向上させることができます。各IPC方式の使い分け実際の開発では、各IPC方式を適切に使い分けることが重要です。パイプはシェルスクリプトとの連携や親子プロセス間の単純な通信に適しています。名前付きパイプはログ収集や順序保証が必要な場合に使います。Unix Domain Socketは高速な双方向通信やサービス間連携に最適です。共有メモリは大量データの高速処理やリアルタイム性が必要な場合に選択します。次のステップこの基礎を踏まえて、さらに高度な実装に挑戦することができます。分散システムへの拡張としてgRPCやメッセージキューの実装、コンテナ環境でのIPC最適化、リアルタイムシステムでの応用、そしてマイクロサービスアーキテクチャでの実装などが考えられます。完全なソースコードはGitHubリポジトリで公開しています。前回の記事「RustでLinuxプロセス管理をしてみた」と合わせて読むことで、Rustでのシステムプログラミングの基礎がしっかりと身につきます。Linuxカーネルプログラミング 第2版作者:Kaiwan N. Billimoria,武内 覚（翻訳）,大岩 尚宏（翻訳）オライリージャパンAmazon","isoDate":"2025-08-22T06:58:56.000Z","dateMiliSeconds":1755845936000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"RustでLinuxプロセス管理をしてみた","link":"https://syu-m-5151.hatenablog.com/entry/2025/08/21/161234","contentSnippet":"はじめにこれまでPythonとGoでプロセス管理システムを実装してきましたが、今回Rustでも実装してみました。各言語にはそれぞれ得意不得意があり、プロジェクトの要件によって最適な選択は変わります。変なとこがあれば教えてください。この記事では、Rustでプロセス管理システムを実装した経験を共有します。標準ライブラリのstd::processだけでは不十分な要件があったため、より高度な制御が可能な実装を行いました。doc.rust-lang.orgサンプルコードはこちらに配置しておきます。github.comPython、Go、Rustでの実装経験から見えた違い3つの言語でプロセス管理を実装してきた経験から、それぞれの特徴をまとめます。Pythonでの実装subprocessモジュールは高レベルで使いやすいasyncioとの組み合わせで非同期処理も可能GILの影響で真の並行性には制限があるメモリ使用量が多く、長時間稼働で増加傾向Goでの実装os/execパッケージはシンプルで直感的goroutineによる並行処理が強力エラーハンドリングが冗長になりがちGCのオーバーヘッドが気になるケースがあるRustでの実装所有権システムによるリソース管理の確実性ゼロコスト抽象化による高パフォーマンス型システムによる実行前のバグ検出学習曲線は確かに急だが、長期的なメンテナンス性は高いRustの所有権システムとゼロコスト抽象化により、今回の要件を満たす堅牢なシステムを構築できました。特に、コンパイル時にリソースリークを防げる点、SendとSyncトレイトによる安全な並行処理、システムコールのオーバーヘッドが最小限である点が優れていました。1. まずはstd::processから始めよう最初の一歩：シンプルなコマンド実行Rustでプロセスを扱う最も簡単な方法は、標準ライブラリのstd::process::Commandを使うことです。use std::process::Command;fn main() {    // 最もシンプルな例    let output = Command::new(\"echo\")        .arg(\"Hello, Rust!\")        .output()        .expect(\"Failed to execute command\");        println!(\"stdout: {}\", String::from_utf8_lossy(\u0026output.stdout));}パイプを使った入出力制御もう少し複雑な例として、子プロセスとパイプで通信してみましょう。use std::io::Write;use std::process::{Command, Stdio};fn main() -\u003e std::io::Result\u003c()\u003e {    let mut child = Command::new(\"cat\")        .stdin(Stdio::piped())        .stdout(Stdio::piped())        .spawn()?;        // 標準入力に書き込み    if let Some(mut stdin) = child.stdin.take() {        stdin.write_all(b\"Hello from parent process!\\n\")?;    }        // 出力を取得    let output = child.wait_with_output()?;    println!(\"Child said: {}\", String::from_utf8_lossy(\u0026output.stdout));        Ok(())}std::processの限界しかし、実際のプロジェクトを進めていくと、std::processだけでは対応できない要件が出てきました。// ❌ std::processではできないこと// 1. 特定のシグナル（SIGTERM、SIGUSR1など）を送信できない// child.kill() はSIGKILLのみ// 2. プロセスグループの管理ができない// 複数の子プロセスをグループとして扱えない// 3. fork()が使えない// Unix系OSの基本的なプロセス生成方法が使えない// 4. 細かいリソース制限（CPU時間、メモリ量など）の設定ができない2. nixクレートの導入：なぜ必要なのかnixクレートとはnixクレートは、Unix系システムコールのRustラッパーです。std::processでは提供されていない低レベルな制御が可能になります。docs.rs[dependencies]nix = { version = \"0.27\", features = [\"process\", \"signal\"] }最初のnixプログラム：fork()の基本まずは最も基本的なfork()から始めましょう。fork()は現在のプロセスを複製し、親プロセスと子プロセスの2つに分岐します。use nix::unistd::{fork, ForkResult};fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {    println!(\"親プロセス開始: PID={}\", std::process::id());        // fork()は unsafe - プロセスの複製は危険を伴うため    match unsafe { fork() }? {        ForkResult::Parent { child } =\u003e {            // 親プロセスのコード            println!(\"親: 子プロセス {} を作成しました\", child);        }        ForkResult::Child =\u003e {            // 子プロセスのコード            println!(\"子: 私は新しいプロセスです！PID={}\", std::process::id());            std::process::exit(0); // 子プロセスは明示的に終了        }    }        Ok(())}なぜunsafeなのか？fork()がunsafeな理由を理解することは重要です。メモリの複製: fork時点のメモリ状態が複製されるマルチスレッドとの相性問題: スレッドがある状態でforkすると予期しない動作リソースの重複: ファイルディスクリプタなどが複製される3. 段階的に学ぶnixクレートの機能ステップ1: シグナル送信std::processではできなかったシグナル送信を実装してみます。use nix::sys::signal::{kill, Signal};use nix::unistd::Pid;use std::process::Command;use std::thread;use std::time::Duration;fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {    // 子プロセスを起動    let mut child = Command::new(\"sleep\")        .arg(\"30\")        .spawn()?;        let pid = Pid::from_raw(child.id() as i32);    println!(\"子プロセス起動: PID={}\", pid);        // 2秒待ってからSIGTERMを送信    thread::sleep(Duration::from_secs(2));    println!(\"SIGTERMを送信...\");    kill(pid, Signal::SIGTERM)?;        // プロセスの終了を確認    let status = child.wait()?;    println!(\"子プロセス終了: {:?}\", status);        Ok(())}ステップ2: プロセスの終了を待つ（ゾンビプロセスの防止）プロセスが終了しても、親がwait()しないとゾンビプロセスになります。nixを使った適切な処理方法を見てみましょう。use nix::sys::wait::waitpid;use nix::unistd::{fork, ForkResult};fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {    match unsafe { fork() }? {        ForkResult::Parent { child } =\u003e {            println!(\"親: 子プロセス {} の終了を待機\", child);                        // waitpid()で子プロセスの終了を待つ            // これによりゾンビプロセスを防ぐ            let status = waitpid(child, None)?;            println!(\"親: 子プロセスが終了 - {:?}\", status);        }        ForkResult::Child =\u003e {            println!(\"子: 2秒間作業します...\");            std::thread::sleep(std::time::Duration::from_secs(2));            println!(\"子: 作業完了！\");            std::process::exit(0);        }    }        Ok(())}ステップ3: プロセスグループの管理複数のプロセスをグループとして管理し、まとめてシグナルを送信できます。use nix::sys::signal::{killpg, Signal};use nix::unistd::{fork, setpgid, ForkResult, Pid};fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {    match unsafe { fork() }? {        ForkResult::Parent { child } =\u003e {            // 子プロセスを新しいプロセスグループのリーダーにする            setpgid(child, child)?;            println!(\"親: プロセスグループ {} を作成\", child);                        // さらに子プロセスを同じグループに追加（省略）                        // グループ全体にシグナルを送信            std::thread::sleep(std::time::Duration::from_secs(2));            println!(\"親: グループ全体にSIGTERMを送信\");            killpg(child, Signal::SIGTERM)?;        }        ForkResult::Child =\u003e {            // 新しいプロセスグループを作成            let my_pid = nix::unistd::getpid();            setpgid(my_pid, my_pid)?;                        // グループ内で作業            loop {                std::thread::sleep(std::time::Duration::from_secs(1));                println!(\"子: 作業中...\");            }        }    }        Ok(())}4. 実用的な実装：ProcessGuardパターンRAIIを活用した安全なプロセス管理実際のプロジェクトでは、プロセスのライフサイクルを確実に管理する必要があります。こういうのは世の中に知見がたくさんあるのでちゃんと調べて行きましょう。今回はRustのRAII（Resource Acquisition Is Initialization）パターンを活用しましょう。use nix::sys::signal::{kill, Signal};use nix::unistd::Pid;use std::process::{Child, Command};/// プロセスの自動クリーンアップを保証する構造体pub struct ProcessGuard {    child: Option\u003cChild\u003e,    name: String,}impl ProcessGuard {    pub fn new(command: \u0026str) -\u003e std::io::Result\u003cSelf\u003e {        let child = Command::new(command).spawn()?;        Ok(Self {            child: Some(child),            name: command.to_string(),        })    }        pub fn wait(\u0026mut self) -\u003e std::io::Result\u003cstd::process::ExitStatus\u003e {        if let Some(mut child) = self.child.take() {            child.wait()        } else {            Err(std::io::Error::new(                std::io::ErrorKind::Other,                \"Process already terminated\"            ))        }    }}impl Drop for ProcessGuard {    fn drop(\u0026mut self) {        if let Some(mut child) = self.child.take() {            // まだ実行中かチェック            if child.try_wait().ok().flatten().is_none() {                eprintln!(\"Terminating process: {}\", self.name);                                // まずSIGTERMで優雅に終了を試みる                let pid = Pid::from_raw(child.id() as i32);                let _ = kill(pid, Signal::SIGTERM);                                // 少し待つ                std::thread::sleep(std::time::Duration::from_millis(500));                                // まだ生きていればSIGKILL                if child.try_wait().ok().flatten().is_none() {                    let _ = child.kill();                }                                // 必ずwait()してゾンビプロセスを防ぐ                let _ = child.wait();            }        }    }}// 使用例fn main() -\u003e std::io::Result\u003c()\u003e {    {        let mut guard = ProcessGuard::new(\"sleep\")?;        println!(\"プロセスを起動しました\");                // スコープを抜けると自動的にクリーンアップ    } // ここでDropが呼ばれる        println!(\"プロセスは自動的に終了されました\");    Ok(())}5. セキュリティ：入力検証とサニタイゼーションコマンドインジェクション対策ユーザー入力を含むコマンド実行は非常に危険です。悪意がなくても失敗する可能性があるものはいつか失敗します。ちなみに普通に入力は適切な検証が必要です。use thiserror::Error;#[derive(Error, Debug)]pub enum ProcessError {    #[error(\"Invalid input: {0}\")]    InvalidInput(String),        #[error(\"Security violation: {0}\")]    SecurityViolation(String),        #[error(\"IO error: {0}\")]    Io(#[from] std::io::Error),}/// 安全な入力検証pub fn validate_input(input: \u0026str) -\u003e Result\u003c\u0026str, ProcessError\u003e {    // 危険な文字をチェック    const DANGEROUS_CHARS: \u0026[char] = \u0026[        ';', '\u0026', '|', '$', '`', '\u003e', '\u003c',         '(', ')', '{', '}', '\\n', '\\r', '\\0'    ];        for \u0026ch in DANGEROUS_CHARS {        if input.contains(ch) {            return Err(ProcessError::SecurityViolation(                format!(\"Dangerous character '{}' detected\", ch)            ));        }    }        // パストラバーサル対策    if input.contains(\"..\") || input.starts_with('~') {        return Err(ProcessError::SecurityViolation(            \"Path traversal detected\".into()        ));    }        // コマンド置換パターンをチェック    let dangerous_patterns = [\"$(\", \"${\", \"\u0026\u0026\", \"||\"];    for pattern in dangerous_patterns {        if input.contains(pattern) {            return Err(ProcessError::SecurityViolation(                format!(\"Dangerous pattern '{}' detected\", pattern)            ));        }    }        Ok(input)}// 使用例fn safe_execute(user_input: \u0026str) -\u003e Result\u003c(), ProcessError\u003e {    let safe_input = validate_input(user_input)?;        let output = std::process::Command::new(\"echo\")        .arg(safe_input)        .output()?;        println!(\"Safe output: {}\", String::from_utf8_lossy(\u0026output.stdout));    Ok(())}リソース制限の設定www.linkedin.comプロセスが使用できるリソースを制限することで、システム全体への影響を防げます。#[cfg(target_os = \"linux\")]use nix::sys::resource::{setrlimit, Resource};#[cfg(target_os = \"linux\")]fn set_resource_limits() -\u003e nix::Result\u003c()\u003e {    // CPU時間を10秒に制限    setrlimit(Resource::RLIMIT_CPU, 10, 10)?;        // メモリを100MBに制限    let memory_limit = 100 * 1024 * 1024; // 100MB in bytes    setrlimit(Resource::RLIMIT_AS, memory_limit, memory_limit)?;        // プロセス数を50に制限    setrlimit(Resource::RLIMIT_NPROC, 50, 50)?;        Ok(())}6. 高度な実装例：プロセスプール複数のワーカープロセスを管理実際のシステムでは、複数のワーカープロセスを効率的に管理する必要があります。use std::sync::{Arc, Mutex};use std::collections::HashMap;use nix::unistd::Pid;pub struct ProcessPool {    workers: Arc\u003cMutex\u003cHashMap\u003cPid, ProcessGuard\u003e\u003e\u003e,    max_workers: usize,}impl ProcessPool {    pub fn new(max_workers: usize) -\u003e Self {        Self {            workers: Arc::new(Mutex::new(HashMap::new())),            max_workers,        }    }        pub fn spawn_worker(\u0026self, command: \u0026str) -\u003e Result\u003cPid, ProcessError\u003e {        let mut workers = self.workers.lock().unwrap();                if workers.len() \u003e= self.max_workers {            return Err(ProcessError::InvalidInput(                \"Maximum workers reached\".into()            ));        }                let child = std::process::Command::new(command)            .spawn()            .map_err(|e| ProcessError::Io(e))?;                let pid = Pid::from_raw(child.id() as i32);        let guard = ProcessGuard {            child: Some(child),            name: command.to_string(),        };                workers.insert(pid, guard);        Ok(pid)    }        pub fn terminate_worker(\u0026self, pid: Pid) -\u003e Result\u003c(), ProcessError\u003e {        let mut workers = self.workers.lock().unwrap();                if let Some(mut guard) = workers.remove(\u0026pid) {            guard.wait()?;            Ok(())        } else {            Err(ProcessError::InvalidInput(                \"Worker not found\".into()            ))        }    }        pub fn active_workers(\u0026self) -\u003e usize {        self.workers.lock().unwrap().len()    }}// 使用例fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {    let pool = ProcessPool::new(5);        // ワーカーを起動    for i in 0..3 {        let pid = pool.spawn_worker(\"sleep\")?;        println!(\"Started worker {}: PID={}\", i, pid);    }        println!(\"Active workers: {}\", pool.active_workers());        // プールがスコープを抜けると全ワーカーが自動終了    Ok(())}7. 非同期処理との統合（Tokio）Tokioを使った非同期プロセス管理docs.rs大規模なシステムでは、非同期処理と組み合わせることが重要です。use tokio::process::Command;use tokio::time::{timeout, Duration};#[tokio::main]async fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {    // 非同期でコマンド実行    let output = Command::new(\"echo\")        .arg(\"Hello, async!\")        .output()        .await?;        println!(\"Output: {}\", String::from_utf8_lossy(\u0026output.stdout));        // タイムアウト付き実行    let result = timeout(        Duration::from_secs(2),        Command::new(\"sleep\").arg(\"10\").output()    ).await;        match result {        Ok(Ok(_)) =\u003e println!(\"Command completed\"),        Ok(Err(e)) =\u003e println!(\"Command failed: {}\", e),        Err(_) =\u003e println!(\"Command timed out\"),    }        Ok(())}8. デバッグとテスト単体テストの実装プロセス管理のコードは、適切にテストすることが重要です。#[cfg(test)]mod tests {    use super::*;    use std::time::Instant;        #[test]    fn test_input_validation() {        // 安全な入力        assert!(validate_input(\"hello.txt\").is_ok());                // 危険な入力        assert!(validate_input(\"; rm -rf /\").is_err());        assert!(validate_input(\"$(whoami)\").is_err());        assert!(validate_input(\"../../../etc/passwd\").is_err());    }        #[test]    fn test_process_timeout() {        let start = Instant::now();                let mut guard = ProcessGuard::new(\"sleep\").unwrap();                // 1秒でタイムアウト        std::thread::sleep(std::time::Duration::from_secs(1));        drop(guard); // 強制的にDropを呼ぶ                // 2秒以内に終了していることを確認        assert!(start.elapsed() \u003c std::time::Duration::from_secs(2));    }        #[test]    fn test_process_pool() {        let pool = ProcessPool::new(2);                // 最大数まで起動できることを確認        assert!(pool.spawn_worker(\"true\").is_ok());        assert!(pool.spawn_worker(\"true\").is_ok());                // 最大数を超えるとエラー        assert!(pool.spawn_worker(\"true\").is_err());    }}統合テスト実際のプロセスを起動して動作を確認します。// tests/integration_test.rsuse std::process::Command;use std::time::Duration;#[test]fn test_zombie_prevention() {    // 子プロセスを起動    let mut child = Command::new(\"sh\")        .arg(\"-c\")        .arg(\"sleep 0.1\")        .spawn()        .expect(\"Failed to spawn\");        // プロセスの終了を待つ    let status = child.wait().expect(\"Failed to wait\");    assert!(status.success());        // psコマンドでゾンビプロセスがないことを確認    let output = Command::new(\"ps\")        .arg(\"aux\")        .output()        .expect(\"Failed to run ps\");        let ps_output = String::from_utf8_lossy(\u0026output.stdout);    assert!(!ps_output.contains(\"\u003cdefunct\u003e\"));}まとめRustでプロセス管理システムを実装する際のポイントをまとめます。std::processから始める簡単な用途には標準ライブラリで十分パイプや環境変数の設定も可能多くの場合、これだけで要件を満たせるnixクレートが必要な場面シグナルの細かい制御が必要プロセスグループの管理fork()やexec()の直接的な使用リソース制限の設定実装のベストプラクティスRAIIパターンの活用: ProcessGuardでリソースの自動解放入力検証の徹底: コマンドインジェクション対策エラーハンドリング: thiserrorで構造化されたエラーテストの充実: 単体テストと統合テストの両方Rustの優位性メモリ安全性: 所有権システムによる確実なリソース管理ゼロコスト抽象化: 高レベルAPIでも性能劣化なし型システム: コンパイル時のバグ検出並行性: Send/Syncトレイトによる安全な並行処理長期運用するシステムでは、これらの特性が大きなメリットとなります。特に、ゾンビプロセスの防止やリソースリークの回避が、コンパイル時に保証される点は、運用の安定性に大きく貢献します。The Linux Programming Interface: A Linux and UNIX System Programming Handbook作者:Kerrisk, MichaelNo Starch PressAmazonLinuxプログラミングインタフェース作者:Michael KerriskオライリージャパンAmazon今後は、分散システムでのプロセス管理や、より高度なモニタリング機能の実装を予定しています。Rustのエコシステムは急速に発展しており、プロセス管理の分野でも新しい可能性が広がっています。github.com","isoDate":"2025-08-21T07:12:34.000Z","dateMiliSeconds":1755760354000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"缶つぶし機とソフトウェア移行技術 - Refactoring to Rust の読書感想文","link":"https://syu-m-5151.hatenablog.com/entry/2025/08/14/143527","contentSnippet":"はじめに——あるいは、「知っている」と「理解している」の間Rustのことは、知っていた。学習もしていた。実務でも使っていた。でも、それは知っているつもりだった。知ってるつもり　無知の科学 (ハヤカワ文庫NF)作者:スティーブン スローマン,フィリップ ファーンバック早川書房Amazon日々Rustで開発し、BoxとRcとArcを使い分け、tokio::spawnでタスクを生成し、?演算子を当たり前のように書いている。FFI？PyO3使えばいいでしょ。WebAssembly？wasm-bindgenがあるじゃない。技術的には、確かに「使える」レベルにはあった。でも、心のどこかで感じていた違和感があった。オートバイのエンジンを分解できる人と、エンジンが動く原理を理解している人は違う。コードが動くことと、なぜそう書くべきかを理解することも違う。私は前者だった。メカニックではあったが、エンジニアではなかった。なぜRustはこんなに厳格なのか。なぜ所有権という概念が必要なのか。なぜunsafeをあんなに忌避するのか。これらの「なぜ」に対して、私は技術的な回答はできた。でも、それは表面的な理解に過ぎなかった。部品の名前と用法は知っているが、設計思想は理解していなかった。『Refactoring to Rust』を手に取った理由は、この雰囲気で掴んでいた知識を、哲学として理解したかったから。O'Reilly Learningでパラパラと眺めた時、これは単なる技術書ではないと直感した。Refactoring to Rust (English Edition)作者:Mara, Lily,Holmes, JoelManningAmazon例えば、「段階的改善」という言葉。実践はしていた。小さく始めて大きく育てる。でも、それがMartin Fowlerの『リファクタリング』から連なる系譜の中にあり、「big bang-style rewrites」への明確なアンチテーゼとして位置づけられていることは知らなかった。リファクタリング(第2版): 既存のコードを安全に改善する (OBJECT TECHNOLOGY SERIES)作者:Martin Fowler 著オーム社Amazon例えば、FFIの境界。PyO3を使えば簡単に境界を越えられる。でも、その境界が「信頼の切れ目」であり、unsafeが「コンパイラが保証できない領域」の明示的な宣言であることの深い意味は、理解していなかった。この読書記録は、一人のRustを実装している人間が、散在していた知識の点を線で結び、線を面にし、そして立体的な理解へと昇華させていく過程の記録である。Kent Beckが「恐怖を退屈に変える」と表現したこと。John Ousterhoutが「深いモジュール」と呼んだもの。これらの古典的な知恵が、Rustという現代の言語でどう具現化されているか。それを理解することで、私の「なんとなく」が「なるほど」に変わっていく。そして、Firecracker VMMやPolarsといった産業グレードのプロジェクトを通じて、教科書的な理想と現実の実装の間にある溝も見えてきた。美術館のアートワーク管理という優雅な例から、(*(*request.request_body).bufs).bufという呪文のような現実へ。この振れ幅こそが、実践の本質だった。さあ、「雰囲気」から「哲学」へ、「使える」から「理解する」への旅を振り返ります。また、気になればぜひ、読んでみてほしいです。あなたにとっても学びが多いハズです。learning.oreilly.comwww.manning.comこのブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。第1章 Why refactor to Rust第1章「Why refactor to Rust」を読んで最初に感じたのは、著者がRustという言語の技術的優位性よりも段階的改善という哲学に重点を置いているということだった。表面的にはパフォーマンスやメモリ安全性という技術的要素を説明しているが、その根底にはソフトウェアシステムの漸進的進化という時代を超えた課題が埋め込まれている。リファクタリングという外科手術本章で著者が「big bang-style rewrites」と呼ぶ完全書き換えへの批判は、Martin Fowlerの「リファクタリング」で語られる原則と深く共鳴する。動いているシステムを止めずに改善する——この一見当たり前のような要求が、どれほど難しく、そして重要なのか。Release It! 本番用ソフトウェア製品の設計とデプロイのために作者:Michael T. Nygardオーム社AmazonFigure 1.1 How refactoring and rewriting affect the size of deployments より引用著者は、リファクタリングとリライトの違いを「手術の規模」になぞらえて説明する。完全書き換えが臓器移植だとすれば、リファクタリングは腹腔鏡手術のようなものだ。小さな切開から始めて、最小限の侵襲で問題を解決する。この比喩は単なる文学的装飾じゃない。リスク管理の本質を突いている。Kent Beckの「Tidy First?」では、コードの整理（tidying）と振る舞いの変更（behavior change）を明確に分離することの重要性が説かれている。Rustへの段階的移行は、まさにこの原則の実践例だと思った。既存のPythonやRubyのコードはそのまま動かしながら、パフォーマンスクリティカルな部分だけをRustで「整理」する。振る舞いは変えずに、実装だけを置き換える。Tidy First? ―個人で実践する経験主義的ソフトウェア設計作者:Kent Beckオーム社Amazonでも、現実はそう単純じゃない。CSVパーサーの寓話本章で示されたCSVパーサーの例——PythonとRustで実装した同じ機能が20倍の性能差を示すという話——は魅力的だけど、同時に危険でもある。Cherry-picked exampleだと著者自身が認めているように、これは最良のケースだ。Science Fictions　あなたが知らない科学の真実作者:スチュアート・リッチーダイヤモンド社Amazonスチュアート・リッチーの「サイエンス・フィクションズ」を読んだ後だと、このような都合の良いベンチマーク結果には警戒心を抱かざるを得ない。科学の世界でさえ、再現性の危機や出版バイアスに悩まされている。技術書のベンチマークも同じ罠に陥りやすい。20倍の性能改善という数字は人を惹きつけるが、それは全体像を表しているだろうか？実際のプロダクションコードでは、PandasやNumPyのような高度に最適化されたC拡張を使っているだろう。純粋なPythonのループと比較するのはフェアじゃない。でも、ここで重要なのは絶対的な性能差じゃなくて、メモリアロケーションの制御という概念だと気づいた。def sum_csv_column(data, column):  sum = 0  for line in data.split(\"\\n\"):    if len(line) == 0:      continue    value_str = line.split(\",\")[column]    sum += int(value_str)  return sumRustの.split()がイテレータを返し、メモリを再利用するという説明は、John Ousterhoutの「A Philosophy of Software Design」で語られる「深いモジュール」の概念を思い出させる。シンプルなインターフェースの裏に、複雑だが強力な実装が隠されている。Rustのゼロコスト抽象化は、まさにこの理想を体現している。fn sum_csv_column(data: \u0026str, column: usize) -\u003e i64 {    let mut sum = 0;    for line in data.lines() {    if line.len() == 0 {      continue;    }    let value_str = line      .split(\",\")      .nth(column)      .unwrap();  #3    sum += value_str.parse::\u003ci64\u003e().unwrap();   }  sum}A Philosophy of Software Design, 2nd Edition (English Edition)作者:Ousterhout, John K. ISSVWOAmazon所有権という約束C/C++プログラマーに向けた「メモリ安全性」のセクションを読んで、Rustの所有権システムが単なる技術的な仕組みじゃなくて、プログラマーとコンパイラの間の契約だということを改めて認識した。従来のC/C++では、メモリの所有権は「プログラマーの頭の中」にしか存在しなかった。コメントやドキュメント、命名規則で暗黙的に管理されていた。Rustはこの暗黙知を明示的な型システムに昇華させた。これは単なる安全性の向上じゃない。チーム開発における認知負荷の軽減でもある。でも、Rustの学習曲線は急峻だ。借用チェッカーとの格闘は、多くの開発者にとって最初の——そして時に最後の——障壁となる。著者はこの点について楽観的すぎるかもしれない。型システムの再発見JavaのHashMapの冗長な初期化コードと、Rustの型推論を対比させる部分は巧妙だった。でも、これは半分しか真実を語っていない。確かにRustの型推論は優秀だ。でも、ライフタイムパラメータが絡むと話は変わる。HashMap\u003c\u0026'a str, Vec\u003c\u0026'b str\u003e\u003eみたいな型シグネチャは、Java以上に威圧的だ。TypeScriptやKotlinのような現代的な言語と比較すると、Rustの型システムはパワフルだが複雑という評価が妥当だろう。それでも、「テスト駆動開発」のKent Beckが言うように、「恐怖を退屈に変える」ことが重要だ。Rustの型システムは、実行時の恐怖をコンパイル時の退屈な作業に変換する。segfaultの恐怖が、借用チェッカーとの退屈な格闘に変わる。これは良いトレードオフだと思う。FFIという橋第1章の後半で紹介される統合手法——C FFI、言語固有のバインディング、WebAssembly——は、異なる世界をつなぐ橋のようだ。PyO3やwasm-bindgenのような高レベルなバインディングツールの存在は心強い。最近知ったmluaというRust-Luaバインディングも興味深い。Neovimのプラグイン開発でRustを使いたい場合、cargo.nvimを開発したときに使ったのだがmluaを活用してLuaとRustをシームレスに統合している。エディタの拡張機能までRustで書ける時代が来たのだ。これは単なる技術的な遊びじゃなくて、パフォーマンスクリティカルなテキスト処理や、複雑な静的解析をエディタ内で実行する実用的なユースケースがある。でも、FFIの境界では、Rustの安全性保証が部分的に失われることを忘れてはいけない。unsafeブロックは必要悪だが、それでも悪だ。直接呼び出しアーキテクチャFigure 1.3が示す「Rustコードが通常のモジュールのように見える」というアプローチは、認知的な連続性を保つ上で重要だ。開発者から見れば、PythonのモジュールをインポートするのとRustで書かれたモジュールをインポートするのに違いはない。この透明性が、段階的移行を成功させる鍵だ。Figure 1.3 When calling Rust directly from your existing application, your Rust code looks like a normal module.でも、この簡潔さの裏には、メモリの所有権、エラーハンドリング、型変換といった複雑な変換層が隠されている。PyO3が#[pyfunction]マクロで隠蔽する複雑さは、まさに抽象化の芸術だ。開発者は細部を気にせず、ビジネスロジックに集中できる。サービス分離アーキテクチャ一方、Figure 1.4が示すネットワーク経由のアプローチは、マイクロサービスアーキテクチャの文脈で理解すべきだろう。Figure 1.4 When Rust code is in an external service, there is additional overhead due to the network hop. より引用ネットワークホップのオーバーヘッドは確かに存在する。でも、このアプローチには別の利点がある。独立したデプロイメント、言語に依存しないインターフェース、水平スケーリングの容易さ。これはSam Newmanの「マイクロサービスアーキテクチャ」で語られる、強い境界による弱い結合の実現だ。どちらを選ぶかは、トレードオフの問題だ。レイテンシが重要なら前者、運用の独立性が重要なら後者。でも、最初は前者から始めて、状況に応じて後者に移行するという段階的な進化も可能だ。これこそが、本書が提案する実用主義的アプローチの真骨頂だろう。興味深いのは、WebAssemblyという第三の選択肢だ。WASMは単なるブラウザ技術じゃなくて、言語中立的なランタイムとして進化している。WasmerやWasmtimeのようなスタンドアロンランタイムを使えば、Rustで書いたコードをどこでも動かせる。これは「Write Once, Run Anywhere」の新しい形かもしれない。いつ使わないべきか「When not to refactor to Rust」のセクションは、本章で最も価値のある部分かもしれない。技術書が「使わない理由」を真剣に議論することは珍しい。特に「あなたが会社で唯一のRust推進者なら」という警告は重要だ。Bus factor 1のシステムを作ることは、技術的負債の別の形だ。Goが成功した理由の一つは、学習曲線が緩やかで、チーム全体が習得しやすかったことだ。Rustはこの点で不利だ。組織的な準備なしにRustを導入することは、「Tidy First?」でKent Beckが警告する「整理のための整理」に陥る危険がある。技術的に優れた解決策が、必ずしもビジネス的に正しい選択とは限らない。Rustという選択の合理性著者は「empowering」「welcoming」「reliable」「efficient」というRustの特徴を挙げている。でも、これらは他の言語でも主張されている。本当の差別化要因は何か？私は、Rustの価値はゼロコスト抽象化とメモリ安全性の両立にあると思う。C++は前者を、Goは後者を提供する。両方を同時に提供するのはRustだけだ（Zigも近いが、まだ成熟していない）。Discordが最近発表したように、彼らはGoからRustに移行することで、レイテンシのスパイクを劇的に削減した。これはGCの存在が根本原因だった。リアルタイム性が求められるシステムでは、予測可能なパフォーマンスが重要だ。Rustはこれを保証する。実用主義者のためのRust第1章を読んで、この本が提案しているのは実用主義的なRust導入戦略だとわかった。完璧主義者のための完全書き換えじゃなくて、現実主義者のための段階的改善。Martin Fowlerが「リファクタリング」で述べたように、「プログラムを動かし続けながら、設計を改善する」ことが重要だ。Rustへの移行も同じ原則に従うべきだ。測定し、最も痛みを感じる部分を特定し、外科手術的に改善する。でも、忘れてはいけない。技術は手段であって目的じゃない。Rustが解決するのは技術的な問題だけだ。組織的な問題、プロセスの問題、人の問題は残る。それでも、適切に使われたRustは、システムの進化を可能にする強力なツールだ。恐怖を退屈に変え、不確実性を型システムに閉じ込め、並行性を安全にする。これらは小さな改善じゃない。ソフトウェアの品質に対する根本的な再考だ。次の章では、具体的な測定と分析の手法が語られるだろう。楽しみだ。なぜなら、「測定できないものは改善できない」からだ。でも、測定だけでは不十分だ。行動が必要だ。そして、その行動の一つが、Rustへの段階的な移行かもしれない。ただし、銀の弾丸はない。Fred Brooksが50年前に警告したように。Rustも例外じゃない。でも、適切に使えば、強力な道具になる。問題は、いつ、どこで、どのように使うかだ。この本は、その問いに答えようとしている。理想的な答えじゃないかもしれない。でも、始まりとしては十分だ。第2章 An overview of Rust第2章「An overview of Rust」を読んで最初に感じたのは、著者が所有権や借用という技術的メカニズムよりもメモリ管理の責任の所在に重点を置いているということだった。表面的にはRustの基本的な言語機能を説明しているが、その根底にはプログラマーとコンパイラの契約関係の再定義という時代を超えた課題が埋め込まれている。美術館のメタファーが語るもの著者が選んだ美術館のアートワーク管理システムという例は、単なる教育的な配慮じゃない。これは所有と共有のパラドックスを表現する巧妙な選択だ。美術作品は一つしか存在しないが、多くの人に鑑賞されなければならない。この物理世界の制約が、そのままRustのメモリモデルに投影されている。fn admire_art(art: Artwork) {  println!(\"Wow, {} really makes you think.\", art.name);}このコードが最初のコンパイルエラーを生むとき、初学者は戸惑うだろう。なぜ同じ作品を二度鑑賞できないのか？ でも、これこそがRustの本質だ。所有権の移動（move）は、責任の移譲を意味する。美術館から作品が消えてしまうのだ。John Ousterhoutの「A Philosophy of Software Design」では、複雑性を制御する方法として「深いモジュール」の概念が提唱されている。シンプルなインターフェースの裏に複雑な実装を隠すという考え方だ。でも、Rustの所有権システムは逆のアプローチを取る。複雑性を型システムに露出させることで、実行時の複雑性を排除する。この選択は、トレードオフだ。学習コストと引き換えに、実行時の安全性を得る。でも、本当にこれは「複雑性の露出」なのだろうか？ むしろ、本質的な複雑性の顕在化かもしれない。メモリ管理は元々複雑だ。C/C++はそれを隠していただけで、Rustは正直に見せている。ライフタイムグラフという可視化本章で導入されるライフタイムグラフは、革新的な教育ツールだと思った。Figure 2.5 The lifetime graph for listing 2.9 より引用このグラフが示すのは、単なる変数の生存期間じゃない。責任の流れだ。誰が、いつ、何に対して責任を持つのか。これはDomain-Driven Designにおける集約（Aggregate）の境界定義に似ている。データの一貫性を保証するために、明確な境界と責任者が必要だ。Eric Evansは集約のルートを通じてのみ内部オブジェクトにアクセスすることを推奨している。Rustの所有権も同じだ。所有者を通じてのみ、値にアクセスできる。借用は一時的なアクセス権で、集約の境界を越えた参照に似ている。でも、現実のプロジェクトでこのような可視化ツールはあるだろうか？ rust-analyzerやIntelliJ Rustプラグインは、借用チェッカーのエラーを表示してくれるが、ライフタイムの全体像を俯瞰することは難しい。aquascopeやrustowlというツールが登場しているので今後も注目していきたい。「K言語」という思考実験の深層著者が導入する架空の「K言語」——Pythonに手動メモリ管理を追加した言語——は秀逸な思考実験だ。def welcome(name):  print('Welcome ' + name)  free(name)  # 誰がこの責任を持つべきか？この例は、C/C++プログラマーが日常的に直面するジレンマを見事に表現している。関数の暗黙的な副作用。welcome関数が引数を解放するという「隠れた契約」は、ドキュメントにしか存在しない。これは、リスコフの置換原則の違反でもある。関数のシグネチャが同じでも、メモリ管理の挙動が異なれば、安全に置換できない。C++のスマートポインタ（unique_ptr、shared_ptr）は、この問題を部分的に解決するが、Rustほど厳密じゃない。void process(std::unique_ptr\u003cData\u003e data) {    // dataの所有権を取得}void observe(const Data\u0026 data) {    // dataを借用するだけ}C++でもある程度は表現できるが、コンパイラの強制力が弱い。Rustはすべての参照にライフタイムがあることを明示的に管理する。文字列型の二重性が示すものStringと\u0026strの区別は、多くの初学者を悩ませる。でも、これは所有と借用の具現化だ。let mut x = String::with_capacity(10_000_000);  // 事前割り当てfor _ in 0..10_000_000 {    x.push('.');}著者が示す1000万個のドットを追加する例は、パフォーマンスの観点から興味深い。Pythonでは同じ操作に約10億回のアロケーションが発生する可能性があるが、Rustでは1回で済む。でも、より深い洞察は制御の粒度にある。JavaやC#のStringBuilderも似たような最適化を提供するが、Rustは言語レベルでこれを統合している。Stringは単なるデータ構造じゃない。所有権の具現化だ。実際、ripgrepのようなツールがなぜ高速なのか、この章を読むと理解できる。不要なアロケーションを避け、必要な時だけメモリを確保する。grepの何倍も高速な理由は、単にRustで書かれているからじゃない。メモリ管理を細かく制御できるからだ。エラーを値として扱う哲学の深層FizzBuzzを使ったエラーハンドリングの説明は、一見すると過剰に思える。でも、これはエラーの第一級市民化という重要な概念を示している。enum Result\u003cT, E\u003e {    Ok(T),    Err(E),}この定義は、HaskellのEither型に似ている。実際、Resultはモナドの一種だ。map、and_then（Haskellのbindに相当）などのメソッドを持つ。fn validate_username(username: \u0026str) -\u003e Result\u003c(), UsernameError\u003e {  validate_lowercase(username)    .map_err(|_| UsernameError::NotLowercase)?;  validate_unique(username)    .map_err(|_| UsernameError::NotUnique)?;  Ok(())}このmap_errの連鎖は、Railway Oriented Programmingを思い出させる。成功の軌道と失敗の軌道を並行して走らせ、エラーが発生したら失敗の軌道に切り替える。でも、現実のコードベースではunwrap()の乱用を見かける。GitHubで「unwrap()」を検索すると、多くのRustプロジェクトでヒットする。特にテストコードでは顕著だ。anyhowやthiserrorのようなエラーハンドリングライブラリの人気は、標準のResult型だけでは不十分なことを示している。?演算子の美学と限界let result = fizzbuzz(i)?;この小さな?記号は、エラー処理の明示的な委譲を表現する。でも、これには限界もある。Goでは、エラー処理は冗長だが明確だ。以下のようなコードになる。result, err := fizzbuzz(i)if err != nil {    return err}Rustの?は簡潔だが、エラーの変換が暗黙的になりやすい。特に、Fromトレイトを使った自動変換は、デバッグを困難にすることがある。Firecracker VMMから学ぶAWSのFirecracker VMMの実際のコードを見ると、本章で学んだ概念が産業グレードのシステムでどう実装されているかが明確になる。/// Contains the state and associated methods required for the Firecracker VMM.#[derive(Debug)]pub struct Vmm {    events_observer: Option\u003cstd::io::Stdin\u003e,    pub instance_info: InstanceInfo,    shutdown_exit_code: Option\u003cFcExitCode\u003e,        // Guest VM core resources.    kvm: Kvm,    pub vm: Arc\u003cVm\u003e,  // 共有所有権の明示    vcpus_handles: Vec\u003cVcpuHandle\u003e,    vcpus_exit_evt: EventFd,    device_manager: DeviceManager,}このコード構造から、所有権の階層的な設計が見て取れる。Vmmが全体を所有し、Arc\u003cVm\u003eで仮想マシンを複数のVCPUスレッドと共有している。これは美術館で言えば、一つの作品（VM）を複数の学芸員（VCPU）が同時に管理するようなものだ。エラーハンドリングの徹底Firecrackerのエラー型定義は圧巻だ。次のような構造になっている。#[derive(Debug, thiserror::Error, displaydoc::Display)]pub enum VmmError {    /// Device manager error: {0}    DeviceManager(#[from] device_manager::DeviceManagerCreateError),    /// Cannot send event to vCPU. {0}    VcpuEvent(vstate::vcpu::VcpuError),    /// Failed to pause the vCPUs.    VcpuPause,    // ... 他にも20以上のエラーバリアント}thiserrorとdisplaydocを使った構造化されたエラー処理。これは本章で学んだResult型の産業的な実装だ。各エラーは具体的な状況に応じた文脈を持ち、#[from]属性で自動変換も定義されている。メッセージパッシングによるVCPU制御pub fn pause_vm(\u0026mut self) -\u003e Result\u003c(), VmmError\u003e {    // Send the events.    self.vcpus_handles        .iter()        .try_for_each(|handle| handle.send_event(VcpuEvent::Pause))        .map_err(|_| VmmError::VcpuMessage)?;    // Check the responses with timeout.    if self.vcpus_handles        .iter()        .map(|handle| handle.response_receiver().recv_timeout(RECV_TIMEOUT_SEC))        .any(|response| !matches!(response, Ok(VcpuResponse::Paused)))    {        return Err(VmmError::VcpuMessage);    }        self.instance_info.state = VmState::Paused;    Ok(())}このコードは防御的プログラミングの極致だ。30秒のタイムアウト（RECV_TIMEOUT_SEC）を設定し、すべてのVCPUからの応答を確認している。一つでも異常があれば即座にエラーを返す。Dropトレイトによる資源管理impl Drop for Vmm {    fn drop(\u0026mut self) {        // グレースフルシャットダウンの保証        self.stop(self.shutdown_exit_code.unwrap_or(FcExitCode::Ok));                if let Some(observer) = self.events_observer.as_mut() {            // ターミナルをカノニカルモードに戻す            let res = observer.lock().set_canon_mode().inspect_err(|\u0026err| {                warn!(\"Cannot set canonical mode for the terminal. {:?}\", err);            });        }                // メトリクスの書き出し        if let Err(err) = METRICS.write() {            error!(\"Failed to write metrics while stopping: {}\", err);        }                // VCPUスレッドの終了確認        if !self.vcpus_handles.is_empty() {            error!(\"Failed to tear down Vmm: the vcpu threads have not finished execution.\");        }    }}このDropの実装は、RAIIパターンの教科書的な例だ。リソースの解放だけでなく、システムの一貫性も保証している。特に、VCPUスレッドが残っていないことを確認する最後のチェックは重要だ。unsafeの最小化コードの冒頭にある警告が印象的だ。次のようなものだ。#![warn(clippy::undocumented_unsafe_blocks)]これは、すべてのunsafeブロックにドキュメントを要求する。実際、500行を超えるこのファイルにunsafeは一度も登場しない。KVMとの相互作用は抽象化層で隠蔽され、安全性の境界が明確に定義されている。Firecrackerでは、panic!は最小限に抑えられている。ゲストVMの異常でホストが落ちるわけにはいかない。すべてのエラーは回復可能として扱われる。美術館から工場へ、そして戦場へ美術館のメタファーは教育的だが、現実のシステムは工場であり、時に戦場だ。tokioのような非同期ランタイムでは、所有権の管理はさらに複雑になる。次のようなパターンが必要になる。use std::sync::Arc;use tokio::sync::Mutex;let data = Arc::new(Mutex::new(vec![1, 2, 3]));let data_clone = Arc::clone(\u0026data);tokio::spawn(async move {    let mut lock = data_clone.lock().await;    lock.push(4);});Arc\u003cMutex\u003cT\u003e\u003eパターンは、共有所有権を表現する。これは美術館で言えば、複数の美術館が一つの作品を共同所有するようなものだ。誰も単独で破壊できないが、誰もが鑑賞できる。でも、このパターンには罠もある。デッドロックの可能性だ。Rustはデータ競合は防げるが、デッドロックは防げない。部分的な正しさの例だ。パニックという最終手段の哲学panic!(\"Got a negative number for fizzbuzz: {}\", x);panic!の導入は、Rustの実用主義を示している。でも、これはErlangの「Let it crash」哲学とは根本的に異なる。Erlangでは、プロセスの失敗は想定内だ。次のようなコードが一般的だ。spawn_link(fun() -\u003e    % クラッシュしても親プロセスが処理    risky_operation()end).Rustでは、パニックは想定外だ。Actix Webのようなフレームワークは、アクターモデルを使ってErlang的な耐障害性を実現しようとしているが、言語レベルのサポートはない。実際、Cloudflareのようなエッジコンピューティング環境では、パニックは許されない。一つのリクエストの失敗で、ワーカー全体が落ちるわけにはいかない。だから、徹底的なResultの使用が求められる。doc.rust-jp.rsqiita.comムーブセマンティクスの深い意味fn admire_art(art: Artwork) {    // artの所有権を取得}let art1 = Artwork { name: \"La Liberté guidant le peuple\".to_string() };admire_art(art1);// art1はもう使えないこの「使えなくなる」という制約は、最初は不便に感じる。でも、これはリソース管理のRAII（Resource Acquisition Is Initialization）パターンの究極形だ。C++でも似たような概念がある。以下のようなコードだ。std::unique_ptr\u003cArtwork\u003e art1 = std::make_unique\u003cArtwork\u003e();admire_art(std::move(art1));// art1は空になるでも、C++のstd::moveはヒントに過ぎない。コンパイラは強制しない。Rustのムーブは保証だ。契約の明文化から信頼の構築へ第2章を読み終えて、そして実際のFirecracker VMMのコードを見て、Rustが提案しているのは単なる暗黙を明示に変えることじゃないとわかった。それは信頼できるソフトウェアの構築方法だ。教育的な美術館から産業的な仮想化基盤へ本章の美術館の例とFirecrackerのコードを比較すると、興味深い世界が見える。教育的な例：fn admire_art(art: \u0026Artwork) {    println!(\"Wow, {} really makes you think.\", art.name);}産業的な実装：pub fn save_state(\u0026mut self, vm_info: \u0026VmInfo) -\u003e Result\u003cMicrovmState, MicrovmStateError\u003e {    let vcpu_states = self.save_vcpu_states()?;    let kvm_state = self.kvm.save_state();    let vm_state = self.vm.save_state().map_err(SaveVmState)?;    let device_states = self.device_manager.save();        Ok(MicrovmState {        vm_info: vm_info.clone(),        kvm_state,        vm_state,        vcpu_states,        device_states,    })}美術館の作品を「鑑賞する」シンプルな関数から、仮想マシン全体の状態を「保存する」複雑な関数へ。でも、根底にある原則は同じだ。所有権の明確化、エラーの明示的な処理、借用による処理速度が速いアクセス。段階的な信頼の構築Firecrackerのシャットダウンシーケンスは、分散システムにおける合意形成プロトコルを思わせる：// Firecrackerのコメントより// 1. vcpu.exit(exit_code)// 2. vcpu.exit_evt.write(1)// 3. \u003c--- EventFd::exit_evt ---// 4. vmm.stop()// 5. --- VcpuEvent::Finish ---\u003e// 6. StateMachine::finish()// 7. VcpuHandle::join()// 8. vmm.shutdown_exit_code becomes Some(exit_code)これは単なる終了処理じゃない。分散合意だ。各VCPUが独立したアクターとして動作し、メッセージパッシングで状態を同期する。ErlangやAkkaを彷彿とさせるが、Rustの型システムがより強い保証を提供している。パニックしない哲学Firecrackerのコードで最も印象的なのは、panic!の不在だ。本章ではpanic!を「最終手段」として紹介していたが、Firecrackerはそれすら使わない。/// Timeout used in recv_timeout, when waiting for a vcpu responsepub const RECV_TIMEOUT_SEC: Duration = Duration::from_secs(30);30秒という長いタイムアウト。これは楽観的ロックの逆だ。悲観的だが確実なアプローチ。VCPUがデッドロックしていることを検出するための保険だ。メトリクスという観測可能性// Write the metrics before exiting.if let Err(err) = METRICS.write() {    error!(\"Failed to write metrics while stopping: {}\", err);}エラーが起きても、メトリクスの書き出しを試みる。これは観測可能性（Observability）への配慮だ。システムが失敗しても、なぜ失敗したかを知る手がかりを残す。「Refactoring to Rust」の意味この章とFirecrackerのコードを照らし合わせると、「Refactoring to Rust」の意味が見えてくる。それは単に：PythonをRustに書き換えることじゃないパフォーマンスを改善することじゃないメモリ安全性を得ることじゃないそれは：システムの契約を明文化することエラーを第一級市民として扱うこと所有権を通じて責任を明確化すること型システムで不変条件を保証することFirecrackerは、これらの原則を1ミリ秒のレイテンシと5MBのメモリフットプリントで実現している。これは理論の実践的な証明だ。第3章 Introduction to C FFI and unsafe Rust第3章「Introduction to C FFI and unsafe Rust」を読んで最初に感じたのは、著者がFFIという技術的な仕組みよりも異なる世界の架け橋を築く哲学に重点を置いているということだった。表面的にはunsafeブロックやポインタ操作を説明しているが、その根底には信頼境界の管理という時代を超えた課題が埋め込まれている。unsafeという名の正直さ「unsafe」という言葉は誤解を招きやすい。著者も指摘するように、これは「危険」ではなく「未検証」を意味する。より正確には「コンパイラが保証できない領域」だ。unsafe {    *solution = 1024;}このたった2行のコードが、Rustの哲学の核心を表している。通常のRustコードでは、コンパイラがメモリ安全性を保証する。でも、C言語の世界から渡されたポインタについて、コンパイラは何も知らない。信頼の連鎖が切れる場所、それがunsafeブロックだ。John Ousterhoutの「A Philosophy of Software Design」では、モジュール間の境界を明確にすることの重要性が説かれている。unsafeブロックは、まさにその境界を可視化する。「ここから先は、私（プログラマー）が責任を持つ」という宣言だ。Figure 3.1 A program’s stack memory during reference and dereference operations より引用この図が示すように、ポインタは単なるメモリアドレス——インデックスのようなものだ。でも、そのシンプルさゆえに危険でもある。doc.rust-lang.orgRPN計算機という教材の巧妙さ著者が選んだ逆ポーランド記法（RPN）計算機という例は、教育的配慮以上の意味を持つ。RPNはスタックマシンの純粋な表現だ。Infix: (3 + 4) * 12RPN  : 3 4 + 12 *     = 84Figure 3.2 RPN stack used to calculate 3 4 + 12 * より引用この例が巧妙なのは、複雑性が段階的に導入される点だ。最初は単純な二項演算、次に複数の演算の連鎖。Kent Beckの「Tidy First?」で語られる「小さな整理から始める」原則の実践例だ。でも、現実のプロジェクトはRPN計算機のようにシンプルじゃない。cbindgenのようなツールが人気なのは、手動でFFIバインディングを書くことの複雑さを物語っている。github.comメモリ共有という芸術本章で最も印象的だったのは、CとRustが同じメモリを共有している様子だ。fn evaluate(problem: \u0026str) -\u003e Result\u003ci32, Error\u003e {  println!(\"problem: {:p}\", problem.as_ptr());  // ...}実行結果：problem: 0x7ffc117917b0  # Cのスタックアドレスterm   : 0x7ffc117917b0  # 同じアドレス！文字列が再アロケーションされることなく、Cのスタックメモリを直接参照している。これはゼロコピーの美しい実例だ。でも、この効率性には代償がある。CStr::from_ptrはunsafeだ。なぜなら、Cから渡されたポインタが：- 有効なメモリを指しているか- NULL終端されているか- UTF-8として有効かこれらをコンパイラは検証できない。プログラマーが保証しなければならない。libcという薄い抽象use libc::{c_char, c_int};libcクレートは、CとRustの型システムの違いを吸収する。C言語のintのサイズはプラットフォーム依存だが、c_intはそれを抽象化する。これは適応層パターンの実例だ。異なるインターフェースを持つシステムを接続するための薄い変換層。でも、薄すぎると危険で、厚すぎると非効率。具体的な状況に応じたバランスが重要だ。実際、PyO3のようなプロジェクトは、より高レベルな抽象を提供する：#[pyfunction]fn sum_as_string(a: usize, b: usize) -\u003e PyResult\u003cString\u003e {    Ok((a + b).to_string())}PyO3では、unsafeを一切書かずにPythonとやり取りできる。でも、その裏では本章で学んだような低レベルのFFIが動いている。github.com動的ライブラリという柔軟性[lib]crate-type = [\"cdylib\"]この設定により、RustコードがC互換の動的ライブラリになる。$ cargo build$ gcc calculator.c -o bin -lcalculate動的リンクの利点は明確だ：- Rustコードの再コンパイル後、Cプログラムの再コンパイルが不要- メモリ効率（複数のプロセスで共有可能）- 独立したデプロイメントでも、動的ライブラリにはDLL地獄の問題もある。バージョン管理、依存関係の解決、ABI互換性——これらすべてが複雑になる。Displayトレイトという共通言語impl Display for Error {  fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e std::fmt::Result {    match self {      Error::InvalidNumber =\u003e write!(f, \"Not a valid number or operator\"),      Error::PopFromEmptyStack =\u003e write!(f, \"Tried to operate on empty stack\"),    }  }}Displayトレイトの実装は、エラーメッセージの中央集権化だ。これはDomain-Driven Designのユビキタス言語の概念に通じる。エラーの意味を一箇所で定義し、どこでも同じメッセージを使う。Martin Fowlerの「リファクタリング」では、「重複の排除」が基本原則の一つだ。Displayトレイトは、エラーメッセージの重複を防ぐエレガントな方法だ。段階的移行の現実本章のRPN計算機の例は、段階的移行の理想形を示している。境界の明確化：solve関数だけを移行インターフェースの保持：同じシグネチャを維持責任の分離：FFI層（solve）とビジネスロジック（evaluate）を分離でも、現実はもっと複雑だ。実際のプロジェクトでの課題Firecracker VMMのようなプロジェクトでは、数千のFFI呼び出しがある。各呼び出しで：- エラー処理の変換- 所有権の移譲- ライフタイムの管理これらを正しく行う必要がある。一つでも間違えれば、セグメンテーションフォルトだ。github.comripgrepの作者Andrew Gallantは、「RustのFFIは強力だが、慎重に使うべき」と述べている。彼のプロジェクトでは、FFI境界を最小限に抑え、可能な限りRust側で処理を完結させている。github.comburntsushi.netunsafeの連鎖という罠let c_str = unsafe { CStr::from_ptr(line) };let r_str = match c_str.to_str() {    Ok(s) =\u003e s,    Err(e) =\u003e {        eprintln!(\"UTF-8 Error: {}\", e);        return 1;    }};このコードは一見安全に見える。unsafeブロックは最小限で、エラー処理も適切だ。でも、unsafeの影響は局所的じゃない。もしlineポインタが無効なら、プログラム全体が未定義動作になる。これは「A Philosophy of Software Design」で警告される複雑性の漏れだ。局所的な決定が、システム全体に影響を与える。WebAssemblyという新しい選択肢本章では触れられていないが、WebAssembly（WASM）は興味深い代替案だ。#[wasm_bindgen]pub fn calculate(input: \u0026str) -\u003e Result\u003ci32, JsValue\u003e {    // ...}WASMなら：- メモリ安全性が保証される（サンドボックス環境）- 言語中立的（どの言語からも呼べる）- ポータブル（どこでも動く）でも、パフォーマンスオーバーヘッドがある。wasm-bindgenは素晴らしいツールだが、ネイティブFFIほど高速じゃない。Zigという対抗馬Zig言語は、C互換性を言語の中心に据えている。export fn add(a: i32, b: i32) i32 {    return a + b;}exportキーワードだけで、C互換の関数が作れる。#[no_mangle]やextern \"C\"は不要だ。これは設計の単純性の違いだ。RustはC互換性を後付けで追加したが、ZigははじめからC互換性を前提に設計された。どちらが良いかは、プロジェクトの要求次第だ。ziglang.org境界を管理する技術第3章を読み終えて、FFIが単なる技術的な仕組みじゃないことがわかった。それは異なる世界観を持つシステムを接続する哲学だ。Rustのunsafeは、「ここから先は信頼できない世界」という明示的な宣言。この正直さが、システム全体の信頼性を高める。Firecracker VMMが500行のコードでunsafeを一度も使わないのは、FFI境界を慎重に設計した結果だ。「Tidy First?」の精神で言えば、FFIは「整理」と「振る舞いの変更」の境界だ。C側のインターフェースは変えずに（振る舞いを保持）、内部実装をRustに置き換える（整理）。でも、忘れてはいけない。FFIは必要悪だ。理想的には、システム全体を一つの言語で書きたい。でも、現実には既存のコードベースがあり、段階的な移行が必要だ。次の章では、おそらくより高レベルなFFI抽象——PyO3やwasm-bindgenなど——が語られるだろう。unsafeの海から、より安全な抽象の島へ。でも、その島も結局はunsafeの海に浮かんでいることを忘れてはいけない。github.comRPN計算機は動いた。でも、これは始まりに過ぎない。実際のシステムでは、スレッド安全性、例外処理、リソース管理など、さらに多くの課題が待っている。それでも、この章が示したのは希望だ。異なる言語が協調できるという証明。完璧じゃないかもしれない。でも、実用的だ。そして時に、実用性こそが最も重要な美徳なのかもしれない。第4章 Advanced FFI第4章「Advanced FFI」を読んで最初に感じたのは、著者が単純なFFIの技術的詳細よりも複雑な既存システムとの共生戦略に重点を置いているということだった。表面的にはNGINXモジュール開発とbindgenの使い方を説明しているが、その根底にはレガシーシステムとの漸進的統合という時代を超えた課題が埋め込まれている。現実世界の複雑性という試金石第3章のRPN計算機は教育的だった。美しく、理解しやすく、制御可能だった。でも、この章のNGINX統合は戦場だ。NGINXは400万以上のウェブサイトで使われている本物のプロダクションシステム。144個のフィールドを持つngx_http_request_t構造体は、現実世界の複雑性を物語っている。struct ngx_http_request_t {  request_body: *mut ngx_http_request_body_t,  ... // 他に143個のフィールド}この巨大な構造体を前にして、著者は言う。「Don't let the large number of NULL values scare you!」。でも、正直なところ、怖いじゃないか。これこそが現実だ。第3章で学んだ「unsafe」の意味——コンパイラが保証できない領域——が、ここでは巨大な海として広がっている。「深いモジュール」の概念では、シンプルなインターフェースの裏に複雑な実装を隠すことが推奨される。でも、NGINXのようなCのコードベースは、その複雑性をすべて露出させている。bindgenが生成した30,000行のRustコードは、その複雑性の氷山の一角に過ぎない。Figure 4.1 High- and low-level Rust bindings for the openssl C library より引用bindgenという魔法の杖、そして現実bindgenは素晴らしいツールだ。C/C++のヘッダファイルを解析して、自動的にRustバインディングを生成してくれる。でも、この章を読んで気づいたのは、bindgenは始まりに過ぎないということだ。let bindings = bindgen::builder()    .header(\"wrapper.h\")    .whitelist_type(\"ngx_.*\")    .whitelist_function(\"ngx_.*\")    .whitelist_var(\"ngx_.*\")    .clang_args(vec![        format!(\"-I{}/src/core\", nginx_dir),        format!(\"-I{}/src/event\", nginx_dir),        // ... 他のインクルードパス    ])    .generate()    .unwrap();最初、bindgenは51,000行のコードを生成した。ngx_プレフィックスでフィルタリングしても30,000行。これは情報の洪水だ。第3章で手動でFFIバインディングを書いた経験から、自動化の恩恵は理解できる。でも、自動化は新たな複雑性も生み出す。「小さな整理から始める」ことの重要性を思い出す。でも、bindgenが生成するコードは、まさにその対極にある。すべてを一度に生成し、後から必要なものだけを選び出す。これは実用的なアプローチだが、同時に認知的負荷の増大でもある。実際、CloudflareがNGINXモジュールcf-htmlをRustで書き直した事例では、bindgenの恩恵を受けながらも多くの困難に直面していた。blog.cloudflare.com 特に印象的なのは、「unsafeブロックを最小化したいが、NGINXとのインターフェースではそれが困難」という記述だ。第3章で学んだunsafeの連鎖が、ここでは巨大なスケールで現れている。ビルドスクリプトという第二のコンパイル第3章では動的ライブラリの生成について学んだが、この章のビルドスクリプトはそれをさらに発展させている。コンパイル時にコードを生成する——これはRustのメタプログラミングの一形態だ。fn main() {    let language = std::env::var(\"GREET_LANG\").unwrap();    let greeting = match language.as_ref() {        \"en\" =\u003e \"Hello!\",        \"es\" =\u003e \"¡Hola!\",        \"el\" =\u003e \"γεια σας\",        \"de\" =\u003e \"Hallo!\",        x =\u003e panic!(\"Unsupported language code {}\", x),    };        let rust_code = format!(\"fn greet() {{ println!(\\\"{}\\\"); }}\", greeting);    // ... ファイルに書き出し}Figure 4.2 Compilation and execution of a program with a build script より引用この例は単純だが、本質的な問いを投げかけている。コンパイル時と実行時の境界はどこにあるべきか？ 第2章で学んだFirecracker VMMのような産業グレードのプロジェクトでは、この境界の管理が成功の鍵となる。ライフタイム注釈という契約書この章で最も印象的だったのは、ライフタイム注釈の実践的な必要性だ。第2章の美術館の例では概念的だったライフタイムが、ここでは生々しい現実として現れる。unsafe fn request_body_as_str\u003c'a\u003e(    request: \u0026'a ngx_http_request_t,) -\u003e Result\u003c\u0026'a str, \u0026'static str\u003eこの関数シグネチャは、メモリの所有権の系譜を表現している。返される文字列スライスは、NGINXのリクエスト構造体から借用されたものだ。新しいメモリを確保せず、既存のメモリを再解釈する。第3章で学んだ「ゼロコピー」の原則が、ここでは大規模に実践されている。Figure 4.7 Lifetime graph for listing 4.13 より引用「明示的なインターフェース」の重要性がここでも現れる。Rustのライフタイム注釈は、C/C++では暗黙的だった契約を、型システムで明示的に表現する。第1章で語られた「プログラマーとコンパイラの間の契約」が、ここではさらに複雑な形で実現されている。でも、現実のFFIコードでは、この美しい型安全性はunsafeの海に浮かぶ小島に過ぎない。if request.request_body.is_null()    || (*request.request_body).bufs.is_null()    || (*(*request.request_body).bufs).buf.is_null(){    return Err(\"Request body buffers were not initialized as expected\");}このnullチェックの連鎖は、C言語の世界の現実だ。第2章で学んだRustのOption型のような優雅さはない。(*(*request.request_body).bufs).bufという表記は、第3章のRPN計算機のシンプルさが懐かしくなる瞬間だ。メモリプールという古の知恵NGINXのメモリプールシステムは、第2章で触れたアリーナアロケータパターンの実装だ。let buf_p = ngx_pcalloc(request.pool,     std::mem::size_of::\u003cngx_buf_t\u003e() as size_t) as *mut ngx_buf_t;リクエストごとにメモリプールを作り、リクエスト処理が終わったら一括解放する。Rustの所有権システムが登場する前から存在していた、メモリ管理の実践的な解決策だ。でも、NGINXのメモリプールとRustの所有権システムを共存させるのは簡単じゃない。著者も認めているように、「Rustの文字列をNGINXのバッファにコピーする方が、所有権を調整するより簡単」なのだ。std::ptr::copy_nonoverlapping(    response_bytes.as_ptr(),    response_buffer as *mut u8,    response_bytes.len(),);これは実用主義の勝利だ。第1章で語られた「動いているシステムを止めずに改善する」原則の具現化。理想的ではないが、動作する。現実のプロジェクトから学ぶこの章のNGINXモジュールは、127行のRustコードで実装されている。第3章のRPN計算機と比べると、コード量は増えたが、複雑性は指数関数的に増加している。F5のngx-rustプロジェクトは、より高レベルな抽象化を提供している。www.f5.comこれは第3章で触れたPyO3のような高レベルバインディングの方向性だ。生のFFIを人間工学的なAPIでラップしている。#[nginx::main]async fn handler(req: \u0026Request) -\u003e Result\u003cResponse, Error\u003e {    // 高レベルAPI}一方、Cloudflareは異なるアプローチを取った。NGINXを使わず、Pingoraという独自のプロキシをRustで書き直した。blog.cloudflare.com これは第1章で警告された「big bang-style rewrites」の成功例だ。1兆リクエスト/日を処理し、NGINXと比較して70%少ないCPUと67%少ないメモリで動作する。パスの分岐点：統合か、置き換えかこの章を読んで、第1章で提示された段階的移行の哲学が、ここで二つの道に分かれることを認識した。統合アプローチNGINXモジュールのように、既存システムに寄生する。第3章で学んだFFIの基礎が、ここでは大規模に適用される。利点は明確です。既存のエコシステムを活用できる段階的な移行が可能（第1章の理想）リスクが限定的でも、代償もある。FFIの複雑性（本章全体がその証明）パフォーマンスのオーバーヘッド二つの世界の間での認知的負荷置き換えアプローチPingoraのように、ゼロから書き直す。これは：クリーンなアーキテクチャ最適なパフォーマンス統一された開発体験でも、Joel Spolskyが警告したように、完全な書き直しは最も危険な選択でもある。www.joelonsoftware.comNetscapeの失敗は今でも教訓として語り継がれている。bindgenを超えて、新しいFFI第3章ではFFIの基礎を学んだが、この章では自動化の限界も見えてきた。そして、FFIの世界は進化し続けている。rust-vmmプロジェクトは、Firecrackerと他のVMMプロジェクトが共通コンポーネントを共有するために生まれた。github.com これは第2章で分析したFirecracker VMMの成功を、より広いエコシステムに展開する試みだ。最初から共有を前提に設計することで、FFIの必要性を減らしている。Diplomatは、一つのRust APIから複数の言語向けのバインディングを生成する。github.com これはbindgenの逆方向——RustからCへ——を一般化したものだ。UniFFI（Mozilla）は、インターフェース定義言語を使って、より高レベルな抽象化を提供する。github.com Firefox 105以降、JavaScriptバインディングの生成もサポートし、第1章で語られた「異なる世界をつなぐ橋」がさらに広がっている。wasm-bindgenは、WebAssemblyを介した新しいFFIの形を示している。github.com 第3章で触れたWASMの可能性が、ここでは実用的なツールとして結実している。橋を架ける技術第4章を読み終えて、Advanced FFIが単なる技術的な手法じゃないことがわかった。それは異なる世界観を持つシステムを接続する架け橋だ。第1章で学んだ「振る舞いを保ちながら、実装を改善する」という原則が、ここでは最も困難な形で試されている。NGINXの外部インターフェースは変えずに、内部でRustの計算機を呼び出す。第3章の教育的な例が、ここでは産業的な実装として昇華されている。でも、現実は理想よりも複雑だ。30,000行の自動生成コード、nullチェックの連鎖、メモリコピーの必要性。これらは技術的負債じゃない。異なるパラダイムを共存させるための必要なコストだ。ISRGとCloudflareが協力して開発しているRiverプロジェクトは、Pingoraの上に構築される新しいリバースプロキシで、NGINXの直接的な代替を目指している。www.memorysafety.orgこれは統合から置き換えへの移行を示唆している。「複雑性は排除できない、管理するしかない」という言葉を思い出す。この章は、まさにその実践例だ。bindgenは複雑性を自動化し、ビルドスクリプトは複雑性を整理し、ライフタイム注釈は複雑性を型システムで表現する。最後に、この章が示しているのは実用主義の重要性だ。第3章の美しいRPN計算機から、この章の泥臭いNGINXモジュールへ。理想的なFFIは存在しない。でも、動作するFFIは作れる。そして時に、それで十分なのだ。NGINXモジュールは動いた。127行のRustコードが、400万のウェブサイトを支えるシステムと対話している。これは小さな一歩かもしれない。でも、確実な一歩だ。第1章で語られた段階的改善の哲学が、ここで実を結んでいる。次の章へ進む前に、この章が教えてくれた最も重要なことを心に刻んでおきたい。完璧を求めて立ち止まるより、不完全でも前進することの価値を。第3章の小さな橋から、第4章のより大きな橋へ。そして、いつかその橋が大きな道になるかもしれない。その可能性を信じて、一歩ずつ前進していくことが大切なのだ。第5章 Structuring Rust libraries第5章「Structuring Rust libraries」を読んで最初に感じたのは、著者がモジュールという技術的な仕組みよりもコードの組織化がもたらす認知的な明瞭性に重点を置いているということだった。表面的にはmod、use、pubの使い方を説明しているが、その根底には複雑性を管理可能な単位に分割するという時代を超えた課題が埋め込まれている。美術館から挨拶プログラムへ——そして最初の躓き第2章では美術館のアートワーク管理という概念的な例で所有権を学んだ。あの美しい抽象化。第3章ではRPN計算機という教育的な例でFFIの基礎を築き、第4章では127行のコードでNGINXという巨大システムと対話した。30,000行の自動生成コードという現実の複雑性。そして今、第5章では「greeter」という挨拶プログラムを通じて、同じRust内での境界管理を学ぶ。mod input {  pub fn get_name() -\u003e String { ... }}mod output {  pub fn hello(name: \u0026str) { ... }  pub fn goodbye(\u0026name: \u0026str) { ... }}正直に言うと、最初はこの章を軽く見ていた。「ただのモジュール分割でしょ？」と。でも、実際にコードを書いてみると、コンパイラに怒られまくった。error[E0425]: cannot find function `get_name` in this scopeerror[E0603]: function `get_name` is privateこのエラーの連続は、まるで厳格な教師に叱られているような気分だった。Pythonならimport一行で済むのに、なぜRustはこんなに面倒なのか。modで宣言して、pubで公開して、useでインポートして——最初は「過剰設計じゃないか？」と苛立った。でも、DayKindというenumが登場したとき、著者の意図が見えてきた。「これはどこに属するのか？」入力でも出力でもない。これは共有される概念だ。Figure 5.1 Graph of greeting program より引用この図を見て気づいた。Rustは私に設計を強制しているのだと。どのモジュールがどのモジュールに依存するか、明示的に宣言しなければならない。これは制約だが、同時に思考の整理でもある。Kent BeckのCLAUDE.mdとの出会い最近偶然発見したKent BeckのBPlusTree3プロジェクト。そのCLAUDE.mdファイルを読んで、背筋が伸びる思いがした。github.com「構造的変更と振る舞いの変更を決して混ぜない」——この一文が、第5章全体を貫く哲学だと気づいた瞬間、パズルのピースがはまるような感覚があった。// 構造的変更：モジュールの再編成mod day_kind;  // 共有概念を独立モジュールへuse crate::day_kind::DayKind;// 振る舞いの変更：新機能の追加fn greet_with_time(name: \u0026str, day: DayKind) {    // 新しい振る舞い}Kent Beckは52年のプログラミング経験を経て、AIエージェントを使ったコーディングに新たな活力を見出している。彼が「TDDがAIエージェントと働く際のスーパーパワーになる」と語るのを読んで、モジュール構造の重要性を再認識した。newsletter.pragmaticengineer.comAIも人間も、明確な構造があれば「どこに何を追加すべきか」がわかる。第3章で学んだunsafeの境界が「信頼の切れ目」だったように、モジュールの境界は「責任の切れ目」なのだ。erenaやlsmcpといったMCPサーバーを使うと、この「責任の切れ目」を生成AIとより効果的に共有できる。 serenaは、Language Server Protocol（LSP）を活用して、シンボルレベルでの理解と編集を可能にする。 大規模で複雑なプロジェクトでも、IDEの機能を使うベテラン開発者のように、具体的な状況に応じたコンテキストを発見し、正確な編集を行える。github.com一方、lsmcpは「ヘッドレスAIエージェント向けのLSP」として設計されている。 LLMは正確な文字位置の追跡が苦手なため、lsmcpは行番号とシンボル名を通じてLSP機能を提供する。 Go to Definition、Rename Symbol、Find Referencesといったセマンティックなリファクタリング機能を、AIが使いやすい形で提供する。 github.comこれらのツールの重要な点は、TypeScript/JavaScriptだけでなく、Rust、Python、Go、C/C++など、LSPサーバーがある言語なら何でも対応できる拡張性を持つことだ。 Kent Beckが示したような明確なモジュール構造があれば、これらのツールはより的確に「今どの部分を修正すべきか」を判断できる。つまり、良いモジュール設計は人間の理解を助けるだけでなく、AIツールとの協働においても強力な基盤となる。構造と振る舞いを分離する規律は、人間とAIが共に働く時代の新しいベストプラクティスなのかもしれない。Rustモジュールシステムの特異性——最初は憎たらしく、後に愛おしく多くの言語では、ファイルシステムが暗黙的にモジュール構造を定義する。JavaScriptやPythonでは、ディレクトリ構造がそのままモジュール階層になる。でも、Rustは違う。明示的なmod宣言が必要だ。confidence.sh最初、この仕様にイライラした。なぜファイルを作っただけでモジュールにならないのか？なぜmod bananas;と書かないとbananas.rsを認識してくれないのか？mod input;   // 明示的にinput.rsを読み込むmod output;  // 明示的にoutput.rsを読み込むでも、数日間格闘した後、この明示性の価値に気づいた。すべてが意図的なのだ。偶然モジュールに含まれるファイルはない。すべては意識的な選択の結果だ。第3章でextern \"C\"を明示的に宣言したように、第4章でbindgenのホワイトリストを明示的に指定したように、ここでもモジュールの包含を明示的に宣言する。この一貫性が、今では美しく感じる。パスという迷宮——そして、その中で迷子になった話Rustのパスシステムは、初学者にとって最も混乱しやすい部分の一つだ。相対パスと絶対パス、crate、super、self——これらのキーワードが織りなす複雑な体系。use crate::day_kind::DayKind;  // 絶対パスuse super::Treat;              // 相対パス（親モジュール）use self::shop::buy;           // 相対パス（現在のモジュール）Figure 5.2 Relative and absolute paths used in listing 5.15 より引用実際にoutput.rsでuse day_kind::DayKind;と書いて、あのエラーに遭遇した時の絶望感を今でも覚えている。error[E0432]: unresolved import `day_kind` --\u003e src/output.rs:1:5  |1 | use day_kind::DayKind;  |     ^^^^^^^^ help: a similar path exists: `crate::day_kind`「なんで見つからないの？同じプロジェクトにあるじゃん！」と画面に向かって叫びたくなった。コンパイラのヘルプメッセージが「crate::day_kindを使え」と教えてくれたが、最初は「なんでcrateって書かなきゃいけないの？」と反発した。でも、これは第4章でNGINXの複雑な構造体フィールドにアクセスするために(*(*request.request_body).bufs).bufという呪文のような表記を使ったことを思い出させた。それと比べれば、crate::プレフィックスなんて優しいものだ。少なくとも、nullチェックの連鎖は必要ない。read_lineヘルパー関数の誕生greeterプログラムを書いていて、名前の後に改行が入る問題に気づいた時、最初は「また面倒な問題が...」と思った。でも、read_lineヘルパー関数を作る過程で、小さな発見があった。fn read_line() -\u003e String {  let mut line = String::new();  stdin().read_line(\u0026mut line).unwrap();  line.trim()  // これはコンパイルエラー！}trim()が\u0026strを返すことを知った時の「あぁ、そうか！」という納得感。Rustは新しいメモリを確保せず、既存のメモリへの参照を返す。効率的だが、今回はStringが必要。.to_string()を追加することで解決した。この小さな躓きと解決の積み重ねが、Rustのゼロコスト抽象化の哲学を体感させてくれた。必要な時だけメモリを確保する。無駄がない。美しい。Rust 2024 Editionとモジュールシステムの進化——未来への期待第4章でbindgenが51,000行から30,000行のコードを生成した話を思い出してほしい。あの情報の洪水。Rust 2024 editionは、そんな複雑性をより安全に管理するための進化を遂げている。doc.rust-lang.orgunsafeの境界がさらに明確にRust 2024ではunsafe_op_in_unsafe_fnリントがデフォルトで有効になる。実際に試してみた：// Rust 2021（今までの世界）unsafe fn process(ptr: *const u8) {    *ptr;  // 暗黙的にunsafe}// Rust 2024（新しい世界）unsafe fn process(ptr: *const u8) {    unsafe { *ptr };  // 明示的にunsafe}この変更を知った時、「さらに面倒になるのか...」と最初は思った。でも、第4章のNGINXモジュールで苦労したnullチェックの連鎖を思い出すと、この改善の価値がわかる。危険な操作を可能な限り局所化する——これは小さな整理の極致だ。可視性という境界管理——pub(crate)の発見pubキーワードは単なる公開・非公開の切り替えじゃない。これはAPIの境界を定義する宣言だ。mod forest {  pub(crate) fn enter_area(area: \u0026str) {    // クレート内では見えるが、外部からは見えない  }}Figure 5.3 Visualization of the parent visibility rule: modules can use private items from parent modules. より引用pub(crate)を初めて見た時、「なんて中途半端な...」と思った。公開なの？非公開なの？でも、使ってみると、これが絶妙なバランスだとわかった。第3章のunsafeが「ここから先は信頼できない」という宣言だったのに対し、pub(crate)は「ここまでは信頼できる仲間」という宣言。forestクレートの例で、この段階的な信頼の輪の美しさに気づいた。そして、上向き可視性のルールには驚いた。子モジュールが親の非公開アイテムにアクセスできる——これは親が子を無条件に信頼するという、現実世界の関係性をコードに投影している。最初は「変なルールだな」と思ったが、実際に使ってみると自然で直感的だった。実践的なモジュール設計——失敗と学び実際のRustプロジェクトを見ると、モジュール設計の多様性に気づく。serdeのような洗練されたクレートを見て、憧れと同時に劣等感も感じた：serde::ser     // シリアライズserde::de      // デシリアライズ  serde::error   // エラー型シンプルで美しい。第2章で学んだ「深いモジュール」の理想的な実装だ。一方で、著者が示した過度にネストされた例を見て、苦笑いした：pub mod the {  pub mod secret {    pub mod entrance {      pub mod to {        pub mod the {          pub mod forest {            pub fn enter() { }          }        }      }    }  }}実は、最初のプロジェクトで似たような過剰な構造を作ってしまった経験がある。「きちんと整理しなきゃ」という強迫観念に駆られて。でも、pub useによる再エクスポートを知って救われた：pub use the::secret::entrance::to::the::forest::enter;これはAPIの簡潔性と実装の構造化のバランスを取る素晴らしい手法だ。第3章で学んだ「薄い抽象化層」の概念が、ここでも生きている。forestクレートで感じた設計の妙著者が最後に示したforestクレートの例は、最初は「なんでこんな例を？」と思った。でも、実装してみて、その巧妙さに感心した。pub mod tree_cover {  pub fn enter() {    crate::forest::enter_area(\"tree cover\");  }}各エリアが共通の実装を使いながら、独自のインターフェースを提供する。これを書いていて、「あ、これってファクトリーパターンみたい」と気づいた瞬間があった。そして、enter_areaを最初pubにして、後からpub(crate)に変更する過程で、APIの進化を体験できた。最初は全部公開、でも「これは内部実装だから隠したい」という自然な欲求。これは実際のプロジェクトでも起こることだ。AIエージェント時代のモジュール設計Kent Beckが指摘するように、従来のプログラミングスキルの90%が商品化される一方で、残りの10%が1000倍の価値を持つようになる。モジュール設計は、その10%に属すると私も信じている。natesnewsletter.substack.com実際、Claude Codeにgreeterプログラムを説明してもらった時、モジュール構造が明確だったおかげで、AIも的確に理解してくれた。逆に、過度にネストされた構造を見せた時は、AIも混乱していた（人間と同じだ！）。// AIが理解しやすい明確な構造pub mod authentication {    pub mod login { ... }    pub mod logout { ... }    mod session_management { ... }  // 内部実装}この経験から、モジュール設計は人間とAIの共通言語になりうると感じた。大規模プロジェクトでの現実——400クレートの戦いある開発者が400クレート、1500以上の依存関係を持つワークスペースでRust 2024への移行を実践した記事を読んで、頭が下がった。codeandbitters.com彼らのアプローチ：コード生成を行うクレートを最初に更新rust-2024-compatibilityリントを一つずつ有効化必要に応じて変更を加えながら段階的に移行これを読んで、第1章で警告された「big bang-style rewrites」を避ける原則の重要性を改めて実感した。私の小さなプロジェクトでさえモジュール構造の変更は大変だったのに、400クレートなんて想像を絶する。整理という名の哲学第5章は、技術的には最もシンプルな章かもしれない。第3章のunsafeもない、第4章のbindgenもない、ただモジュールを作って整理するだけ。最初は「楽勝だろう」と思っていた。でも、実際に手を動かしてみて、これが最も哲学的に深い章だと気づいた。コンパイラに怒られながら、エラーメッセージと格闘しながら、少しずつRustのモジュールシステムの意図が見えてきた。それは単なる整理じゃない。思考の整理であり、責任の明確化であり、信頼の境界の定義だ。greeterプログラムは完成した。たった数十行の小さなプログラム。でも、この小さなプログラムを通じて、大規模システムの設計原則を学んだ。DayKindをどこに置くかで悩んだ時間、crate::プレフィックスの意味を理解した瞬間、pub(crate)の絶妙さに気づいた時——これらすべてが、私のRust理解を深めてくれた。モジュールシステムの学習曲線は確かに急だ。Pythonのimportに慣れた身としては、最初は「過剰じゃない？」と思った。でも今では、この厳格さが長期的な保守性を保証することがわかる。Kent BeckのCLAUDE.mdが教えてくれた「構造と振る舞いを分離する」という原則。これはモジュール設計の核心だ。そして、小さな整理の積み重ねが、大きな改善につながる。この章を読み終えて、書き終えて、Rustが少し好きになった。面倒くさいけど、その面倒くささには理由がある。厳しいけど成長を考えてくれる先輩みたいだ。厳格だけど、その厳格さが安全を保証する。第6章 Integrating with dynamic languages第6章「Integrating with dynamic languages」を読んで最初に感じたのは、著者が単なるPython統合の技術的手法よりも異なるパラダイムの言語が協調する哲学に重点を置いているということだった。表面的にはPyO3とSerdeを使った実装方法を説明しているが、その根底には理想的な性能と現実的な開発速度のトレードオフという時代を超えた課題が埋め込まれている。JSONの10行から始まる旅第5章のgreeterプログラムでモジュールの哲学を学んだ後、今度は10行のJSONデータから始まる、より現実的な統合の旅が始まる。for line in sys.stdin:  value = json.loads(line)  s += value['value']  s += len(value['name'])正直、最初にこのコードを見た時、「え、これだけ？」と思った。NGINXモジュールの複雑さを経験した後だけに、このシンプルさは拍子抜けだった。でも、著者の次の言葉にハッとした。「People have very high expectations for the performance of this feature」——期待値の管理という、技術以前の問題がここにある。Serdeという魔法Serdeとの初めての出会いは魔法のようだった。#[derive(Debug, serde::Deserialize)]struct Data {  name: String,  value: i32,}たった一行の#[derive(serde::Deserialize)]で、JSON解析が動く。この簡潔さは衝撃的だった。Figure 6.1 The Serde ecosystem より引用でも、実際に使ってみると、いくつか躓いた。最初、deriveフィーチャーを有効にし忘れて、コンパイラに怒られた：the trait `serde::de::Deserialize\u003c'_\u003e` is not implemented for `Data`Cargo.tomlにfeatures = [\"derive\"]を追加する必要があることを知った時、「なんで最初から有効じゃないの？」と思った。でも、これも明示性の原則の表れだと気づいた。必要なものだけを明示的に選ぶ。serde.rsPyO3の洗練された抽象化PyO3の導入部分は、FFI知識の集大成だった。#[pymodule]fn rust_json(_py: Python, m: \u0026PyModule) -\u003e PyResult\u003c()\u003e {  m.add_function(wrap_pyfunction!(sum, m)?)?;  Ok(())}#[pymodule]や#[pyfunction]のマクロは、手動FFIコードを多くの場合隠蔽している。わずか数行のマクロで済む。これは抽象化の力だ。でも、最初のimport rust_jsonで見事に失敗した：ModuleNotFoundError: No module named 'rust_json'maturinの存在を知り、仮想環境を作り、maturin developを実行して、やっと動いた時の喜び。開発環境のセットアップにも段階的改善が必要だった。github.comベンチマークの衝撃Criterionを使ったベンチマークは、「測定できないものは改善できない」という原則の実践だった。Figure 6.2 Anatomy of our benchmark program より引用測りすぎ――なぜパフォーマンス評価は失敗するのか？作者:ジェリー・Z・ミュラーみすず書房Amazon最初のベンチマーク結果を見た時の衝撃を今でも覚えている：pure python             time:   [25.415 us 25.623 us 25.842 us]rust extension library  time:   [21.746 us 21.987 us 22.314 us]たった10%の改善？ unsafe地獄を通り、bindgenの海を泳ぎ、モジュールの迷宮を彷徨って、結果がこれ？正直、がっかりした。でも、著者の次の一言が全てを変えた。「We are forgetting one important thing that Rust has that Python does not: an optimizing compiler」--releaseの威力maturin develop --releaseを実行して、再度ベンチマークを取った時の結果：pure python             time:   [25.019 us 25.188 us 25.377 us]rust extension library  time:   [10.843 us 10.918 us 10.996 us]2倍以上の高速化！ この瞬間、今まで見てきたFinished dev [unoptimized + debuginfo]というメッセージの意味を理解した。ずっとデバッグビルドで測定していたのだ。この経験から学んだ重要な教訓：最適化なしのRustは、最適化されたPythonより遅いことがある。これは多くの人が陥る罠だと、後で知った。stackoverflow.comFFIオーバーヘッドという現実PyO3のGitHubイシューを読んで、さらに深い理解を得た。小さな関数では、FFIのオーバーヘッドがRustの性能向上を打ち消してしまうことがある。github.com実際、空の関数を呼ぶだけでも：純粋なPython: 43nsPyO3経由: 67.8nsこの差は、GIL（Global Interpreter Lock）の取得、引数の変換、エラーハンドリングのセットアップなど、FFIの必要悪から生まれる。実践的な教訓この章を読んで、そして実際に試してみて、いくつかの重要な教訓を得た：ループ全体を移行するPythonでループを回して、各イテレーションでRust関数を呼ぶのは最悪のパターン。FFIオーバーヘッドが積み重なる。# 悪い例for item in items:    result = rust_function(item)  # FFIオーバーヘッドが毎回発生# 良い例results = rust_batch_process(items)  # FFIオーバーヘッドは1回だけblog.erikhorton.comデータ変換のコストを意識するPyO3は便利な型変換を提供するが、それにはコストがある。特に大きなデータ構造を頻繁に変換する場合は要注意。計算密度の高い処理を選ぶJSONの解析程度では、Pythonのjsonモジュール（C実装）も十分速い。画像処理、暗号計算、シミュレーションなど、本当に計算が重い部分を選ぶべき。maturinの開発体験maturinの開発体験は素晴らしかった。maturin develop一発で、Rustコードの変更がPython環境に反映される。手動FFIやbindgenと比べると、天と地の差だ。実際、個人プロジェクトでも試してみた。100万件のCSVデータを処理するスクリプトがあったんだが、PandasからRustに移行してみた：Pandas版: 3.2秒Rust版（デバッグ）: 4.1秒（遅い！）Rust版（リリース）: 0.8秒（4倍速い！）--releaseの重要性を、身をもって体験した瞬間だった。ketansingh.mePython::with_gilという逆方向の統合ベンチマークのコードで出てきたPython::with_gilは、新しい発見だった。Python::with_gil(|py| {  let locals = PyDict::new(py);  // PythonコードをRustから実行  py.run(code, None, Some(\u0026locals)).unwrap()});Figure 6.5 bench_fn diagram より引用これは逆方向のFFI。RustからPythonを呼ぶ。双方向の統合が可能だという発見は、新しい可能性を開いてくれた。他言語との統合章の最後で触れられた他言語との統合：Rutie: Ruby統合Neon: Node.js統合j4rs/JNI: Java統合flutter_rust_bridge: Flutter統合「段階的改善」の哲学が、あらゆる言語で実践可能だということ。Rustは言語中立的な改善ツールとして機能する。失敗の価値この章で最も価値があったのは、失敗の共有だ。最適化なしで10%しか改善しなかった結果。これは多くの人が経験する失望だろう。失敗の科学作者:マシュー・サイドディスカヴァー・トゥエンティワンAmazon実際、PyO3のディスカッションを見ると、似たような体験談が溢れている：github.com「純粋なRustでは60nsなのに、Pythonから呼ぶと22,350nsになった」という報告。370倍の遅延。これがFFIの現実だ。でも、だからこそ、具体的な状況に応じた場所に具体的な状況に応じた技術を使うことの重要性がわかる。必要な場所だけを改善する——それが実用的なアプローチだ。Polarsとの出会いこの章を読んだ後、Polarsという高速データフレームライブラリを知った。PandasのRust実装で、PyO3を使っている。medium.com試してみた結果：Pandas: 1000万行の集計で12秒Polars: 同じ処理で0.3秒（40倍速い！）これが適切に設計されたRust統合の威力だ。ループ全体をRustに移し、データ変換を最小化し、並列処理を活用している。低い解像度で掲げた時の理想の全ては叶わない。第6章を読み終えて、そして実際に手を動かしてみて、RustとPythonの統合が銀の弾丸じゃないことがよくわかった。小さな関数では逆に遅くなることもある。最適化を忘れれば性能は出ない。FFIのオーバーヘッドは無視できない。これらはすべて現実だ。でも、同時に可能性も見えた。適切に設計され、適切に最適化されたRust統合は、劇的な性能向上をもたらす。Polarsのような成功例がそれを証明している。測定し（Criterion）、分析し（FFIオーバーヘッド）、改善し（--release）、検証する（ベンチマーク）。このサイクルこそが、段階的改善の本質だ。最後に、正直な感想を一つ。この章を読んで、実装して、ベンチマークして、Rustが本当に実用的な選択肢だと確信した。完璧じゃない。でも、確実に価値がある。第7章 Testing your Rust integrations第7章「Testing your Rust integrations」を読んで最初に感じたのは、著者が単なるテスト技法の説明よりも既存コードとの信頼関係を構築する哲学に重点を置いているということだった。表面的には#[test]やassert_eq!の使い方を説明しているが、その根底には段階的移行における安全網の構築という時代を超えた課題が埋め込まれている。2 + 2 = 4から始まる旅第6章でPyO3を使ってRustとPythonを統合し、10%から2倍以上の性能改善を達成した。でも、速いコードが正しいコードとは限らない。そして今、著者は最もシンプルなテストから始める。#[test]fn it_works() {    let result = 2 + 2;    assert_eq!(result, 4);}正直、最初は「なんて退屈な例だ」と思った。でも、このシンプルさには意味がある。Kent Beckの「Test-Driven Development」で語られるRed-Green-Refactorのリズム。まず失敗するテストを書き、次に成功させ、そしてリファクタリングする。2 + 2 = 4という自明な例こそ、このリズムを体感するのに最適だ。テスト駆動開発作者:ＫｅｎｔＢｅｃｋオーム社Amazonテストの可視性という発見#[cfg(test)]というアトリビュートに出会った時、最初は「なぜテストを条件付きコンパイルにする必要があるの？」と疑問に思った。#[cfg(test)]mod tests {    // テストコード}でも、実際にプロダクションビルドのサイズを測ってみて納得した。テストなしでビルドすると、バイナリサイズが30%も小さくなった。これはプロダクションコードとテストコードの明確な分離だ。必要なものだけを含める、Rustの明示性の原則がここでも生きている。doc.rust-lang.orgstdout/stderrキャプチャーの驚きテスト実行時の出力キャプチャーは、最初は面倒に感じた。#[test]fn it_works() {    eprintln!(\"it_works stderr\");    println!(\"it_works stdout\");    // ...}成功したテストの出力が表示されない。失敗した時だけ表示される。最初は「デバッグしづらい」と思った。でも、大規模プロジェクトでテストを実行してみて、この設計の素晴らしさに気づいた。数百のテストが並列実行される中、必要な情報だけが表示される。ノイズの削減という設計哲学。--nocaptureフラグの存在を知った時の安心感。必要な時はすべて見られる。でも、デフォルトは静かに。これは良いデフォルトだ。ドキュメンテーションテストという二重の価値ドキュメンテーションテストを初めて書いた時の感動を今でも覚えている。私はドキュメンタリアンであるからだ。syu-m-5151.hatenablog.com/// Add together two i32 numbers/// ```/// assert_eq!(testing::add(2, 2), 4);/// ```pub fn add(x: i32, y: i32) -\u003e i32 {    x + y}コメントの中のコードが実際に実行される。これは生きたドキュメントだ。古くなったドキュメントという問題を、テストという仕組みで解決している。Figure 7.2 Screenshot of documentation for the add function より引用でも、失敗した時のエラーメッセージは分かりづらい。「line 5で失敗」と言われても、それは暗黙のmain関数内での行番号。実際のファイルの行番号じゃない。この不親切さは改善の余地がある。doc.rust-lang.orgRaw Stringsという小さな救世主第6章で作ったrust_jsonライブラリのテストを書く時、JSONのエスケープ地獄に陥った。// エスケープ地獄sum(\"{ \\\"name\\\": \\\"Stokes Baker\\\", \\\"value\\\": 954832 }\")// Raw stringsで救われるsum(r#\"{ \"name\": \"Stokes Baker\", \"value\": 954832 }\"#)r#\"...\"#という記法を知った時、「なんて奇妙な構文だ」と思った。でも、使ってみると手放せなくなった。複数のオクトソープ（#）を使えることを知った時の驚き。r###\"...\"###なんて書ける。必要に応じて柔軟に対応できる設計。これは小さな機能だが、日々のコーディングを劇的に改善する。JSONやSQL、正規表現を扱う時の苦痛が消えた。Pythonとの協調テスト第6章で作ったRust実装を、既存のPythonテストで検証する。これは理想的な移行戦略だ。def test_10_lines():    lines = [        '{ \"name\": \"Stokes Baker\", \"value\": 954832 }',        # ... 10行のテストデータ    ]    assert main.sum(lines) == 6203958既存のPythonテストがそのまま動く。これは既存資産の活用だ。新しい技術を導入する時、すべてを書き直す必要はない。でも、最初はmaturinの再ビルドを忘れて、古いバージョンでテストして混乱した。「なんで修正が反映されないの？」と30分も悩んだ。開発フローの確立は重要だ。Monkey Patchingという魔術Monkey patchingを使って、PythonとRustの実装を比較する部分は圧巻だった。def compare_py_and_rust(input):    rust_result = main.sum(input)        with MonkeyPatch.context() as m:        m.setattr(main.rust_json, 'sum', python_sum)        py_result = main.sum(input)        assert rust_result == py_result同じインターフェースで異なる実装を切り替える。これはダックタイピングの極致だ。動的言語の柔軟性を活かした美しい解決策。でも、正直、最初は「こんな黒魔術みたいなことして大丈夫？」と不安だった。実際、IDEの補完が効かなくなったり、静的解析ツールが混乱したりした。トレードオフは存在する。ランダム化テストという網ランダム化テストの威力を実感したのは、実際にバグを見つけた時だった。def randomized_test_case(monkeypatch):    number_of_lines = random.randint(100, 500)    # ランダムなJSONデータを生成    # ...    compare_py_and_rust(monkeypatch, lines)手動で書いたテストでは見つからなかったエッジケースが、ランダムテストで露呈した。特に、UTF-8の境界条件でのバグ。nameの長さを数える時、バイト数と文字数の違いで不一致が起きた。これは人間の想像力の限界を補完する手法だ。でも、失敗を再現するのが難しい。ランダムシードを記録する仕組みが必要だと痛感した。www.shuttle.devcargo testの並列実行という罠と恩恵cargo testがデフォルトで並列実行することを知らずに、共有リソースを使うテストを書いて痛い目を見た。// ファイルを使うテスト（並列実行で競合する）#[test]fn test_file_operation() {    std::fs::write(\"test.txt\", \"data\").unwrap();    // ...}--test-threads=1で解決したが、テスト時間が3倍になった。並列性と独立性のトレードオフ。最近はcargo-nextestというツールを使っている。より良い並列実行制御、リトライ機能、そして美しい出力。Rustのテストエコシステムは進化し続けている。effective-rust.comテストの組織化という芸術Rustのテスト配置には明確な思想がある：単体テスト: src/内の#[cfg(test)]モジュール統合テスト: tests/ディレクトリドキュメンテーションテスト: doc comments内最初は「なぜ3種類も？」と思った。でも、大規模プロジェクトで働いてみて、この分類の価値がわかった。それぞれが異なる視点でコードを検証する。内部実装、公開API、そして使用例。多層防御の思想だ。失敗から学んだことこの章で最も印象的だったのは、著者が意図的にバグを仕込んで、テストが失敗することを確認する部分だ。// バグを仕込むparsed.name.len() as i32 + parsed.value + 10「テストを一度失敗させるのは良い習慣」という言葉。これはテストのテストだ。常に成功するテストは、本当にテストしているのか分からない。実際、過去に常に成功する無意味なテストを書いたことがある。assert_eq!(true, true)みたいな。コードカバレッジは上がったが、品質は上がらなかった。メトリクスの罠だ。プロパティベーステストへの渇望章の最後で、著者は「より知的にテストケースを生成する特殊なライブラリがある」と触れている。これはproptestやquickcheckのことだろう。実際、後日試してみた：use proptest::prelude::*;proptest! {    #[test]    fn test_json_sum(name in \"[a-z]{1,100}\", value in 0i32..10000) {        let json = format!(r#\"{{\"name\": \"{}\", \"value\": {}}}\"#, name, value);        let result = sum(\u0026json);        assert_eq!(result, name.len() as i32 + value);    }}100個のランダムケースより、賢く選ばれた10個のケースの方が価値があることもある。量より質、でも時には量も必要。信頼の積み重ね第7章を読み終えて、テストが単なる品質保証ツールじゃないことがよくわかった。それは信頼を構築するプロセスだ。第6章で性能改善を達成したが、それが正しく動作することを保証するのがテスト。既存のPythonコードと新しいRustコードが同じ結果を返すことを、手動テスト、自動テスト、ランダムテストで多層的に検証する。特に印象的だったのは、既存のテストを捨てないという姿勢。Pythonのテストをそのまま活用し、Monkey patchingで実装を切り替える。これは段階的移行の理想形だ。cargo test一発ですべてのテストが走る快適さ。単体テスト、統合テスト、ドキュメンテーションテスト、すべてが統一されたフレームワークで動く。これは開発者体験の向上だ。でも、完璧じゃない。doctestのエラーメッセージの分かりづらさ、ランダムテストの再現性の問題、並列実行での競合。これらは改善の余地がある。最後に、正直な感想を一つ。この章を読んで、実践して、テストを書くことが楽しくなった。Red-Green-Refactorのリズム、ランダムテストでバグを見つける興奮、すべてのテストが緑になる満足感。テストは保険じゃない。それは設計を改善するツールであり、信頼を構築するプロセスであり、コードとの対話だ。2 + 2 = 4から始まった旅は、より堅牢で信頼できるシステムへとつながっている。第8章 Asynchronous Python with Rust第8章「Asynchronous Python with Rust」を読んで最初に感じたのは、著者が単なる非同期処理の技術的実装よりもプロトタイピングから本番システムへの進化という普遍的な課題に重点を置いているということだった。表面的にはGIL（Global Interpreter Lock）の回避方法とPyO3による並列処理を説明しているが、その根底には理想的な開発速度と現実的な実行速度のトレードオフという時代を超えた課題が埋め込まれている。フラクタルという計算の迷宮第6章でPyO3を使った基本的な統合を学び、JSONパースで10%から2倍以上の性能改善を達成した。第7章でテストによる信頼の構築を経て、今度はMandelbrot集合という計算密度の極致に挑戦する。c = complex(x0, y0)i = 0z = complex(0, 0)while i \u003c 255:    z = (z * z) + c    if float(z.real) \u003e 4.0:        break    i += 1このわずか数行のコードが、1000×1000ピクセルで100万回の複素数計算を生み出す。Benoit Mandelbrotがコンピュータビジュアライゼーションを研究に使った先駆者だったという事実は、計算機科学と純粋数学の美しい融合を象徴している。でも、最初にこのコードを見た時の私の反応は「え、これだけで46秒もかかるの？」だった。第6章のJSONパースは確かに軽量だった。著者自身が「Cherry-picked example」と認めていた。でも、Mandelbrot集合は違う。これは計算負荷だ。スケーリングという名の幻想著者が水平スケーリングと垂直スケーリングを説明する部分は、一見教科書的だが、深い示唆を含んでいる。python main.py \u0026 python main.pyこの単純なコマンドで2つのプロセスを起動しても、single.pngという同じファイルを上書きし合う。冪等性の欠如。これは第7章で学んだ「既存のテストを活用する」アプローチとは対照的だ。テストでは再現性が重要だったが、並列処理では独立性が重要になる。Figure 8.2 Horizontal scaling means adding more physical hardware より引用缶つぶし機の比喩は秀逸だった。BlackBox Can Crusherの中を開けたら、ハンマーが1つか2つか。これは並列処理の本質を表現している。でも、現実のシステムはもっと複雑だ。缶（タスク）が均等に分配されるとは限らない。実際、第4章でNGINXモジュールの複雑な構造体と格闘した経験を思い出すと、現実のシステムで「缶」を均等に分配することの難しさがわかる。144個のフィールドを持つngx_http_request_tのような巨大な構造体を、どうやって効率的に並列処理するのか。asyncioという偽りの約束async def mandelbrot_func(...):    # ...async def main():    await asyncio.gather(*[        mandelbrot_func(1000, f\"{i}.png\", -5.0, -2.12, -2.5, 1.12)        for i in range(0,8)    ])46秒から42秒への「改善」。たった4秒、約9%の短縮。第6章で--releaseフラグを忘れて10%の改善に失望した記憶が蘇る。でも、ここでは最適化は関係ない。これはPythonの構造的な限界だ。sleepを追加して非同期性を確認する実験は興味深い：0.png sleeping for 3 seconds1.png sleeping for 1 seconds...1.png created4.png created6.png created3.png created0.png created  # 3秒後ではなく、もっと後に作成されるこれは協調的マルチタスキングの証明だ。でも、「協調的」というのは婉曲表現かもしれない。実際は「順番待ち」に過ぎない。GILという鎖Global Interpreter Lockの説明で、著者は「hall pass」（廊下通行証）の比喩を使う。一度に一人の生徒だけが廊下を歩ける。この比喩は分かりやすいが、現実はもっと残酷だ。Figure 8.6 GIL is a lock that the interpreter gives out to allow tasks to run より引用2003年にGuido van Rossumが導入したGIL。20年以上前の決定が、今でもPythonの並列処理を制約している。第3章で学んだunsafeが「コンパイラが保証できない領域」を明示するのに対し、GILは「インタープリタが一つのスレッドしか実行させない」という暗黙の制約だ。最近のニュースによると、Python 3.13で--disable-gilオプションが導入された。peps.python.orgPEP 703は2024年にCPython 3.13で--disable-gilビルドフラグのサポートをリリースし、GILありとGILなしの2つのABIが存在することになった。これは本書が書かれた時点では予測されていなかった大きな進展だ。でも、2028-2030年にはデフォルトでGILが無効になる可能性があるという予測は、まだ先の話だ。PyO3による解放第6章で初めてPyO3に触れた時は、PythonからRustを呼ぶ基本的な使い方だった。でも、ここでのpy.allow_threadsは革命的だ：#[pyfunction]fn mandelbrot_fast(    py: Python\u003c'_\u003e,    size: u32,    path: \u0026str,    // ...) {    py.allow_threads(|| mandelbrot_func(size, path, range_x0, range_y0, range_x1, range_y1))}たった一行。py.allow_threads。これがGILを解放し、並列処理を可能にする。第3章でunsafeブロックが「信頼の境界」を明示したように、これは「GILの境界」を明示している。結果は劇的だった：純粋なPython: 46秒Rust（GILあり）: 23秒（2倍高速）Rust（GIL解放、4スレッド）: 6秒（7.7倍高速）現実のプロジェクトから学ぶPolarsという成功例を見てみよう。PandasのRust実装で、PyO3を使っている：github.com私も試してみた：Pandas: 1000万行の集計で12秒Polars: 同じ処理で0.3秒（40倍高速）これは第6章の「ループ全体を移行する」原則の非常に優れた実践だ。小さな関数をRustに置き換えるのではなく、データフレーム全体の処理をRustで行う。でも、純粋なRustでは60nsなのに、Pythonから呼ぶと22,350nsになったという報告もある。370倍の遅延。これがFFIの現実だ。第4章でbindgenが生成した30,000行のコードを思い出す。境界を越えることには必ずコストがある。プロトタイピングという楽園、本番という戦場著者は「Python is the ultimate prototyping language」と書く。確かにそうだ。でも、プロトタイプから本番への移行は楽園から戦場への旅だ。実際、最近のベンチマークでは興味深い結果が出ている：medium.com小規模なワークロード（800x600）では、JavaScriptが4,137 px/ms、Rustが3,658 px/msで、JavaScriptの方が速い。これは衝撃的だ。第1章で「20倍の性能改善」という夢を見たが、現実はそう単純じゃない。並行性と並列性の混同著者は並行性（concurrency）と並列性（parallelism）を明確に区別している。これは重要な概念だが、多くの開発者が混同している。第7章でテストの並列実行が共有リソースで競合した経験を思い出す。cargo testのデフォルト並列実行は恩恵だが、ファイルアクセスで競合すると罠になる。同様に、Pythonのasyncioは並行性を提供するが、並列性は提供しない。tokioのような非同期ランタイムと比較すると、Pythonの制約が明確になる：// Rustの並列処理tokio::spawn(async move {    // 別のOSスレッドで実行可能});失敗から学んだことこの章で最も価値があったのは、段階的な失敗と改善の記録だ：シンプルなループ: 46秒（ベースライン）asyncio: 42秒（9%改善、期待外れ）ThreadPoolExecutor: 42秒（改善なし、GILのせい）Rust統合: 23秒（2倍高速、良いが不十分）GIL解放: 6秒（7.7倍高速、成功！）この段階的な改善は、第1章で語られた「外科手術的なアプローチ」の実践だ。一度にすべてを書き換えるのではなく、ボトルネックを特定し、段階的に改善する。新しい時代への期待と不安Python 3.13の--disable-gilオプションは画期的だが、課題も多い：blog.jetbrains.com標準バージョン3.13.5では4スレッドで0.98倍のスピードアップ（つまり遅くなる）だが、free-threadedバージョン3.13.5tでは並列処理が可能になる。でも、互換性の問題は残る。既存のC拡張はGILの存在を前提としているため、GILなしでは安全に動作しない可能性がある。第3章で学んだ「unsafe」の連鎖が、ここではエコシステム全体に広がる。プロトタイプから製品へ第8章を読み終えて、そして実際にMandelbrot集合を実装してみて、プロトタイピングの楽園と本番の戦場の間にある深い溝を実感した。Pythonの強みは否定しない。「simplicity and flexibility」は確かに価値がある。第5章でモジュール構造に苦労した経験を思い出すと、Pythonのimport一行の簡潔さが懐かしい。でも、スケールする時、その簡潔さは足枷になる。46秒が6秒になる——これは単なる性能改善じゃない。ユーザー体験の質的な変化だ。著者は最後に「refactoring is a process, not a destination」と書く。確かにその通りだ。でも、時にはdestinationも必要だ。Cloudflareが第4章のNGINXモジュールからPingoraへ完全移行したように、段階的改善から完全な書き換えへシフトすることもある。缶つぶし機から学んだ教訓BlackBox Can Crusherの比喩に戻ろう。箱を開けたら、ハンマーが1つか2つか。でも、Rustを使えば、ハンマーの数を自由に増やせる。GILという制約から解放されて。第1章で「恐怖を退屈に変える」という言葉があった。PythonのGILは「並列処理の恐怖」を「単一スレッドの退屈」に変えた。でも、それは20年前の解決策だ。今、私たちにはより良い選択肢がある。この章を読んで、実装して、ベンチマークして、RustがPythonを救うのではなく、RustとPythonが協力して新しい可能性を開くのだと理解した。プロトタイプはPythonで。性能が必要な部分はRustで。テストは両方で。これは妥協じゃない。実用主義的な選択だ。46秒から6秒へ。これは小さな一歩かもしれない。でも、フラクタルのように、小さな変化が無限の可能性を生み出すこともある。Mandelbrot自身が証明したように。第9章 WebAssembly for refactoring JavaScript第9章「WebAssembly for refactoring JavaScript」を読んで最初に感じたのは、著者が単なるブラウザ上でのRust実行よりも「Write once, run anywhere」という古い夢の新しい実現に重点を置いているということだった。表面的にはwasm-bindgenやYewの使い方を説明しているが、その根底にはフロントエンドとバックエンドの境界の融解という時代を超えた課題が埋め込まれている。Javaという亡霊、WebAssemblyという希望「Write once, run anywhere」——Javaのスローガンを見て、私は苦笑いした。第8章でPythonのGILという20年前の決定に苦しめられたように、ここでも過去の夢が現れる。でも、WebAssemblyは違う。仮想マシンではなく、コンパイルターゲットとして機能する。Figure 9.1 Wasm loaded into a JavaScript frontend より引用W3Cが2018年に仕様を公開してから、WebAssemblyは着実に進化してきた。2024-2025年にはWebAssembly 2.0/3.0が登場し、ガベージコレクション、例外処理、直接DOM操作などの新機能が追加された。platform.unoこれは単なる技術的進歩じゃない。言語の境界を越えた共通基盤の誕生だ。GitHubの現実、JavaScriptの支配https://github.blog/news-insights/octoverse/octoverse-2024/ より引用:embed:cite]本書では2022年のデータが示されているが、興味深いことに、2024年のGitHub Octoverse統計ではPythonが再びJavaScriptを抜いて最も使われている言語になった。github.blogこの逆転は第8章で見たPythonの根強い人気を裏付けている。第8章でPythonを「the ultimate prototyping language」と呼んだが、その評価は正しかった。でも、ウェブブラウザという文脈では、JavaScriptは依然として避けられない現実だ。98%のウェブサイトで使われている「the ultimate web language」としての地位は揺るがない。JavaScriptの弱点も明確だ。型安全性の欠如、ランタイムエラーの頻発、そしてパフォーマンスの限界。第1章で「恐怖を退屈に変える」という言葉があったが、JavaScriptは「柔軟性を混沌に変える」こともある。だからこそ、TypeScriptの人気が高まり、そしてWebAssemblyが注目されているのだ。arXivという学術の宝庫arXivのRSSフィードを扱うという例の選択は巧妙だった。200万以上の学術論文を持つオープンアクセスリポジトリ。これは知識の民主化の象徴だ。async fn search(term: String, page: isize, max_results: isize) -\u003e    Result\u003cFeed, reqwest::Error\u003e {    let http_response = reqwest::get(        format!(\"http://export.arxiv.org/api/query?search_query=         all:{}\u0026start={}\u0026max_results={}\",         term, page * max_results, max_results)).await?;    // ...}第6章でJSONパースの例が「Cherry-picked」だったのに対し、この例は実用的だ。実際のAPIを叩き、XMLをパースし、ページネーションを処理する。これは現実世界の問題だ。info.arxiv.orgwasm-bindgenという橋#[wasm_bindgen]pub async fn paper_search(val: JsValue) -\u003e JsValue{    let term: Search= serde_wasm_bindgen::from_value(val).unwrap();    let resp = search(term.term, term.page, term.limit).await.unwrap();    serde_wasm_bindgen::to_value(\u0026resp).unwrap()}この関数は言語間の翻訳者だ。JsValueという型は、第3章で学んだCStrや第6章のPyObjectに相当する。異なる世界をつなぐ共通言語。でも、ここで重要なのはasyncだ。JavaScriptのPromiseとRustのFutureをシームレスに統合している。第8章でPythonのasyncioが偽りの約束だったのに対し、ここでは非同期が実現されている。https://rustwasm.github.io/wasm-bindgen/reference/js-promises-and-rust-futures.htmlrustwasm.github.ioコンパイルの儀式wasm-pack build --target webこのコマンド一つで、Rustコードがブラウザで動くようになる。第4章でbindgenが30,000行のコードを生成した複雑さと比べると、これは驚くほどシンプルだ。でも、--targetフラグの選択は重要だ：web: スクリプトとして直接読み込むbundler: モジュールとして統合するこれは第1章で語られた「段階的改善」の具現化だ。小さく始めて（スクリプト）、大きく育てる（モジュール）。Reactとの邂逅Viteを使ったReact統合の部分は、現代のフロントエンド開発の現実を反映している。import init, { paper_search } from \"./pkg/papers.js\";init().then(() =\u003e {    paper_search({\"term\":\"type\", \"page\": 0, \"limit\": 10}).then(        (result)=\u003e{/* ... */}    );});第5章でモジュール構造に苦労した経験を思い出すと、JavaScriptのimportの簡潔さが懐かしい。でも、ここではその簡潔さとRustの型安全性を両立させている。最新のベンチマークによると、WebAssembly 2.0とRustの組み合わせは、最適化されたJavaScriptより4-8倍高速になることがある：markaicode.comただし、すべてのケースでWebAssemblyが速いわけではない。小さな関数では、JavaScript-WASM間の境界を越えるオーバーヘッドがパフォーマンスを損なうこともある。これは第6章で学んだPyO3の教訓と同じだ。境界を越えることにはコストがある。Yewという野心impl Component for List {    type Message = Msg;    type Properties = ();    fn create(ctx: \u0026Context\u003cSelf\u003e) -\u003e Self {        ctx.link().send_message(Msg::GetSearch(0));        Self {            page: 0,            feed: FetchState::Fetching,        }    }    fn update(\u0026mut self, ctx: \u0026Context\u003cSelf\u003e, msg: Self::Message) -\u003e bool {        // ...    }    fn view(\u0026self, ctx: \u0026Context\u003cSelf\u003e) -\u003e Html {        // ...    }}YewのComponent実装は、Model-View-Controllerパターンの現代的な解釈だ。第2章で学んだ所有権の概念が、ここではUIの状態管理に適用されている。Figure 9.3 Component flow より引用でも、正直なところ、最初は懐疑的だった。「なぜReactがあるのにRustでUIを書く必要があるの？」と。しかし、実装してみて気づいた。これは型安全なUIの実現だ。ランタイムエラーがコンパイル時エラーになる。恐怖が退屈に変わる瞬間だ。三つの道著者は最後に三つの使用パターンを示す： Use case  Format  Tool  Simple web page  Script  wasm-pack web  Library integration  Module  wasm-pack bundler  UI element  Component  Yew これは段階的な深化を表している。第3章のFFIから始まり、第6章のPyO3、第8章のGIL回避、そして今、完全なフロントエンド統合へ。各段階が次の段階の基礎となっている。WebAssemblyの現在と未来2025年現在、WebAssemblyは成熟期に入っている。WebAssembly 3.0では：ガベージコレクションのネイティブサポート例外処理の直接伝播DOM への直接アクセスこれらの機能により、JavaScriptとの統合はさらにシームレスになった。markaicode.comでも、課題も残る。デバッグツールの不足、学習曲線の急峻さ、そして何よりエコシステムの分断。JavaScriptの膨大なライブラリとRustの厳格な型システムの間には、まだ大きな溝がある。実践から学んだ教訓実際にarXivフィードリーダーを実装してみて、いくつかの重要な教訓を得た：FFIオーバーヘッドの現実第6章のPyO3と同様、小さな関数では逆に遅くなることがある。「Rust (WebAssembly) is slower than JavaScript」という議論もある：users.rust-lang.orgこれは具体的な状況に応じた粒度の重要性を示している。計算密度の高い処理をまとめてRustに移すべきで、細かい関数呼び出しは避けるべきだ。開発体験の向上Viteとの統合は素晴らしかった：import { defineConfig } from 'vite'import react from '@vitejs/plugin-react'import wasm from \"vite-plugin-wasm\"import topLevelAwait from \"vite-plugin-top-level-await\"第5章で苦労したRustのモジュールシステムと比べると、JavaScriptのツールチェーンの成熟度は印象的だ。でも、それはRustの弱点ではなく、異なる強みの組み合わせの可能性を示している。arXivから学術の未来へarXivのフィードリーダーという例は、単なる技術デモじゃない。これは知識のアクセシビリティの向上だ。学術論文を誰もが簡単に検索し、閲覧できるようにする。実際、私もこのコンポーネントを改良して、個人的に使っている。毎朝、興味のある分野の最新論文をチェックする。RustとWebAssemblyが、知識へのアクセスを改善している。最後に、正直な感想を一つ。この章を読んで、実装して、動かしてみて、WebAssemblyは未来じゃなく現在だと確信した。完璧じゃない。デバッグは難しいし、エコシステムは分断されている。でも、確実に価値がある。第8章でPythonとRustの協力を学んだ。今度はJavaScriptとRustの協力だ。次章では、おそらくWebAssemblyを使った更なる統合が語られる。境界は融解し、新しい可能性が生まれている。「Write once, run anywhere」は失敗した夢かもしれない。でも、「Write in the best language for the job, run everywhere」は実現可能だ。そして、その実現にRustとWebAssemblyが重要な役割を果たしている。第10章 WebAssembly interface for refactoring第10章「WebAssembly interface for refactoring」を読んで最初に感じたのは、著者が単なるWASIの技術的実装よりもプラットフォームとしてのランタイムを自ら構築する哲学に重点を置いているということだった。表面的にはWasmEdgeやメモリ管理の使い方を説明しているが、その根底には言語の境界を超えた相互運用性という時代を超えた課題が埋め込まれている。Rustで学ぶWebAssembly――入門からコンポーネントモデルによる開発まで エンジニア選書作者:清水 智公技術評論社Amazonフロントエンド向けWebAssembly入門作者:末次 章日経BPAmazonJavaの夢、WebAssemblyの約束第9章でブラウザ上のWebAssemblyを通じて「Write once, run anywhere」の新しい実現を見た。arXivフィードリーダーは確かに動いた。でも、ブラウザという檻の中だった。そして今、第10章は大胆な宣言から始まる。「Java was released as a programming language in 1995 with the bold slogan 'Write Once Run Anywhere'」。この歴史的な視点は単なる懐古趣味じゃない。失敗から学ぶ勇気だ。JavaのAppletは死んだ。でも、JVMは生き残った。Scala、Clojure、Kotlinが証明している。WebAssemblyは、この教訓を活かせるだろうか？Solomon Hykes、Dockerの創設者が2019年3月27日にツイートした言葉は、今では伝説になっている：「If WASM+WASI existed in 2008, we wouldn't have needed to create Docker. That's how important it is.」If WASM+WASI existed in 2008, we wouldn't have needed to created Docker. That's how important it is. Webassembly on the server is the future of computing. A standardized system interface was the missing link. Let's hope WASI is up to the task! https://t.co/wnXQg4kwa4— Solomon Hykes (@solomonstre) 2019年3月27日   twitter.com正直、最初にこの引用を読んだ時、「大げさじゃない？」と思った。第4章でNGINXモジュールの複雑さと格闘し、第6章でPyO3のFFIオーバーヘッドに苦しんだ経験から、そんな単純な話じゃないことは分かっていた。でも、WASIの実装を進めるうちに、Hykesの洞察の深さに気づいた。これは技術の置き換えじゃない。大きな変化だ。WasmEdgeという実践wasmedge hello.wasmこのシンプルなコマンドの裏に、膨大な抽象化が隠されている。第3章のRPN計算機では、C言語との境界でunsafeを書いた。第9章では、JavaScriptとの境界でJsValueを扱った。でも、ここでは？言語の区別が消えている。WasmEdgeがCNCFのサンドボックスプロジェクトとして採択されたことは、単なる認定じゃない。WasmEdgeは最速のWasmVMであり、Linuxコンテナと比較して起動が100倍速く、実行時は20%高速で、サイズは1/100になる。これは第8章でPythonのGILから解放されて7.7倍の高速化を達成した経験を思い出させる。でも、今度はさらに根本的な改善だ。「journal」プロジェクトという設計の妙著者がワークスペースから始める選択は巧妙だった：[workspace]members = [    \"paper_search_lib\",    \"paper_search\"]第5章で学んだモジュール構造の重要性が、ここで実を結ぶ。ライブラリとバイナリの分離、ワークスペースによる統合。これは境界の明確化だ。Kent Beckの「構造と振る舞いを分離する」原則の実践。でも、実装してみて気づいた。wasm32-wasiというターゲットは、wasm32-unknown-unknownとは違う。第9章のブラウザ向けWebAssemblyとは、根本的に異なる世界だ。WASI Preview 2（WASI 0.2）は2024年初頭にBytecode Allianceによってリリースされ、Component Modelを統合し、利用可能なAPIを拡張した。メモリという迷宮への再突入第3章でポインタと格闘し、第4章でNGINXの(*(*request.request_body).bufs).bufという呪文を唱えた。そして今、再びメモリ管理の深淵へ：#[no_mangle]pub extern fn allocate(size: usize) -\u003e *mut c_void {    let mut buffer = Vec::with_capacity(size);    let pointer = buffer.as_mut_ptr();    mem::forget(buffer);    pointer as *mut c_void}このallocate関数は、単なるメモリ確保じゃない。二つの世界の契約書だ。ホストとモジュールが、メモリという共通言語で対話する。でも、最初にmem::forgetを見た時、背筋が凍った。「メモリリークじゃないの？」と。いや、違う。これは意図的な所有権の放棄だ。第2章で学んだ「所有権の移動」の究極形。モジュールがメモリを確保し、ホストがそれを使い、そして...誰が解放するの？この曖昧さが、WASIの現在の限界を示している。ランタイムを書くという権力let mut vm = VmBuilder::new().with_config(config).build()?;vm.wasi_module_mut()    .expect(\"Not found wasi module\")    .initialize(None, None, None);このコードを書いた時、奇妙な感覚に襲われた。私がランタイムを書いている。第8章でPythonのGILに苦しめられ、第6章でFFIオーバーヘッドに悩まされた私が、今、自分のランタイムを構築している。これは権力の移譲だ。言語の開発者から、アプリケーション開発者へ。でも、「力には責任が伴う」。第3章で学んだunsafeの重みが、ここでは全体に広がる。Component Modelという未来Component Modelは開発者がWebAssemblyモジュールを「LEGOブロック」のように扱えるようにし、安全かつ相互運用可能にプラグインできる。これは美しいビジョンだ。でも、現実は？WASI 0.3（旧Preview 3）は2025年前半に予定されており、Component Modelでネイティブ非同期をサポートし、既存のWASI 0.2インターフェースを新しい非同期機能を活用するように調整することが目標。まだ道半ばだ。第9章でPromiseとFutureをシームレスに統合したwasm-bindgenの優雅さと比べると、WASIのメモリ管理は原始的に見える。でも、これは始まりに過ぎない。book_searchという冗長性の価値paper_searchに続いてbook_searchを実装する部分は、最初「冗長じゃない？」と思った。XMLとJSONの違いだけで、ほぼ同じコード。でも、実行してみて気づいた：cargo run book_search rustcargo run paper_search rust同じインターフェース、異なる実装。これはポリモーフィズムの極致だ。第7章で学んだ「既存のテストを活用する」精神が、ここではランタイムレベルで実現されている。現実世界での採用AzureのKubernetesサービスは、WebAssembly (Wasm)ワークロードを実行するためのWASIノードプールをサポートしていたが、2025年5月5日以降、新しいWASIノードプールは作成できなくなる。この撤退は何を意味するのか？失敗？いや、進化だ。SpinKubeへの移行が推奨されている。エコシステムは成熟し、統合され、標準化されていく。第4章でCloudflareがNGINXからPingoraへ移行したように、WASIも次の段階へ進んでいる。ハードウェアとの邂逅WebAssemblyプログラムがI2CやUSBなどのハードウェアインターフェースと対話できるようにするWASI提案と概念実証実装が進行中。これは新しい可能性だ。第8章でMandelbrot集合を計算したのは純粋なCPU処理だった。でも、I2CやUSBへのアクセスが可能になれば？IoTデバイス、組み込みシステム、エッジコンピューティング。WebAssemblyは、ブラウザから始まり、サーバーを経て、今、物理世界へと到達しようとしている。批判的視点：WASIの現在地正直に言おう。WASIはまだ未成熟だ。多くのプロジェクトがWASIを多くの場合無視しているというHacker Newsのコメントは辛辣だが、一面の真実を含んでいる。第6章でPyO3が提供した洗練されたAPIと比べると、WASIのメモリ管理は原始的だ。allocate関数を手動で書き、ポインタを管理し、1024バイトという固定サイズでデータを読む。これは1990年代のC言語プログラミングを思わせる。でも、だからこそ価値がある。低レベルの理解が、高レベルの抽象化を可能にする。第3章でunsafeを学んだからこそ、第6章のPyO3の魔法を理解できた。同様に、WASIの原始的なメモリ管理を理解することで、将来のより洗練された抽象化を正しく使えるようになる。Solomon Hykesの予言、再考Hykesの「2008年にWASM+WASIがあれば」という仮定を、今、違う角度から見てみよう。Dockerは問題を解決した。依存関係地獄、環境の不一致、「私のマシンでは動く」症候群。WASIは同じ問題を違う方法で解決する。でも、より根本的に。Dockerはプロセスレベルの仮想化。WASIは命令レベルの仮想化。Dockerは既存のバイナリをパッケージング。WASIは新しいバイナリフォーマットの定義。これは改善じゃない。再発明だ。段階的移行から、プラットフォーム構築へ第10章を読み終えて、そしてjournal_cliを実装してみて、本書のタイトル「Refactoring to Rust」の新しい意味に気づいた。第1章から第9章まで、既存システムへのRustの埋め込みを学んだ。C、Python、JavaScript。でも、第10章は違う。ここでは、Rustでプラットフォームを構築している。他の言語を埋め込むのではなく、他の言語をホストしている。これは立場の逆転だ。ゲストからホストへ。消費者から提供者へ。リファクタリングから、アーキテクチャの再定義へ。journal_cliは127行。第4章のNGINXモジュールと同じ行数。でも、意味が違う。NGINXモジュールは既存システムへの寄生。journal_cliは新しいエコシステムの種。小さいが、無限の可能性を秘めている。缶つぶし機から、万能工場へ第8章の缶つぶし機の比喩を思い出そう。BlackBox Can Crusherの中にハンマーが何本あるか。でも、WASIが提供するのは、ハンマーの追加じゃない。缶つぶし機そのものを再定義する能力だ。紙を検索するモジュール、本を検索するモジュール。今日は2つ。明日は100個かもしれない。各モジュールが異なる言語で書かれ、異なる最適化がされ、でも同じインターフェースを提供する。これはマイクロサービスの理想形かもしれない。HTTPのオーバーヘッドなし、コンテナの重さなし、純粋な関数呼び出し。でも、忘れてはいけない。複雑性は消えない、移動するだけだ。メモリ管理、エラーハンドリング、バージョニング。これらの課題は残る。最後に、正直な感想を一つ。この章を読んで、実装して、デバッグして、未来に触れた気がした。不完全で、粗削りで、時にイライラする未来。でも、確実に来る未来。第9章でブラウザの中のWebAssemblyを見た。第10章でブラウザの外のWebAssemblyを見た。次は？おそらく、WebAssemblyがどこにでもある世界。見えない基盤として、当たり前の存在として。Javaは「Write once, run anywhere」を約束して、部分的に成功した。WebAssemblyは「Write in any language, run everywhere」を約束している。この約束が果たされるかは、まだ分からない。でも、journal_cliが動いた瞬間、小さな希望を感じた。WASIはまだ始まったばかり。でも、始まりこそが最も興奮する瞬間だ。不確実性と可能性が共存する、創造の瞬間。第1章で始まった「Refactoring to Rust」の旅は、ここで新しい段階に入った。既存を改善する段階から、未来を構築する段階へ。おわりに——あるいは、点が線になり、線が面になった日本書を読み終えて、そして膨大な参考プロジェクトのコードを追いかけて、私は深い納得感に包まれている。ああ、そういうことだったのか。「はじめに」で書いた、メカニックとエンジニアの違い。今、私はその境界を越えたと感じている。エンジンを分解できるだけでなく、なぜそう設計されているのかが見えるようになった。例えば、所有権。技術的には「メモリ安全性のため」と理解していた。でも、この本を通じて、それが責任の明確化であり、信頼の境界の定義であることを理解した。美術館の作品を「移動」することで消えてしまうという例は、最初は奇妙に思えたが、今では所有権の本質を見事に表現していると感じる。それは単なるメモリ管理の技法ではなく、システム設計の思想だった。例えば、unsafe。「危険だから避ける」と機械的に理解していた。でも、実際は「未検証」の宣言であり、プログラマーとコンパイラの間の契約の境界線だった。第3章から第4章への進化——手動FFIからbindgenへ——を追うことで、この境界管理の重要性が立体的に理解できた。unsafeは禁忌ではなく、責任の明示だった。特に印象的だったのは、失敗の価値だった。第6章の「最適化なしで10%しか改善しない」という告白。私も似たような経験があったが、それを「失敗」として片付けていた。でも、著者たちはそれを学習の機会として提示していた。--releaseフラグ一つで2倍以上の改善。この「当たり前」のことを、きちんと言語化することの重要性。失敗は恥ではなく、理解への階段だった。Kent Beckの「構造と振る舞いを分離する」という原則は、私が無意識に実践していたことに名前を与えてくれた。なぜ私のコードがメンテナンスしやすいのか、なぜリファクタリングが楽なのか。それは偶然じゃなく、この原則に従っていたからだった。直感が理論に裏打ちされた瞬間だった。第8章のGILの説明——「hall pass」の比喩——は、技術的な理解を直感的な理解に変えてくれた。缶つぶし機の中のハンマーの本数。これらの比喩は単なる説明技法じゃない。複雑な概念を共有可能な理解に変換する技術だった。抽象を具象に変える芸術だった。WebAssemblyとWASIの章は、新しい視点を与えてくれた。「Write once, run anywhere」の失敗から「Write in any language, run everywhere」への進化。これは技術の進歩じゃなく、哲学の進化だった。夢の挫折と再生の物語だった。Solomon Hykesの「2008年にWASM+WASIがあれば」という言葉も、今では違って聞こえる。これは技術への郷愁じゃない。パラダイムシフトの予言だった。そして、第10章で自分でランタイムを書いた時、その意味が体感できた。過去への後悔ではなく、未来への道標だった。最も価値があったのは、雰囲気が哲学に昇華されたことだ。なんとなくBoxを使っていた → 所有権の移譲という明確な意図なんとなくResultを返していた → エラーの第一級市民化という設計思想なんとなくモジュールを分けていた → 責任の境界の明確化という原則なんとなくテストを書いていた → 信頼の構築プロセスという哲学点だった知識が線で結ばれ、線が面になり、そして立体的な理解へと成長した。平面的な技術が、立体的な哲学になった。オートバイのメタファーに戻ろう。今の私は、エンジンの音を聞いただけで調子がわかる。振動から不具合を感じ取れる。それは部品の知識があるからじゃない。システムとしての理解があるからだ。Rustも同じだった。エラーメッセージから設計思想が読み取れるようになった。コンパイラの叱責から、より良い設計への道筋が見えるようになった。これからも私はRustでコードを書く。技術的には、おそらく大きな変化はない。でも、なぜそう書くのかを明確に説明できるようになった。そして、その「なぜ」を共有できるようになった。メカニックからエンジニアへ。使う人から、理解する人へ。「Refactoring to Rust」は、技術書でありながら哲学書だった。実践の書でありながら、思考の書だった。そして何より、雰囲気を理解に変える触媒だった。今、私のRustコードには、哲学が宿っている。それは押し付けがましい哲学じゃない。実用的で、段階的で、正直な哲学。恐怖を退屈に変え、暗黙を明示に変え、そして最終的に、より良いソフトウェアを生み出す哲学。道具を使うことと、道具と対話することは違う。今、私はRustと対話している。コンパイラは教師となり、エラーは指針となり、型システムは思考の枠組みとなった。これが、「知っている」から「理解している」への旅の終着点だ。いや、新しい旅の始まりかもしれない。P.S. unwrap()も、今では「プロトタイピングにおける意図的な先送り」という哲学的な選択として理解している。...まぁ、言い訳かもしれないけど。でも、言い訳にも哲学があっていいじゃないか。","isoDate":"2025-08-14T05:35:27.000Z","dateMiliSeconds":1755149727000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"エンジニアのための「中身のある話」の作り方","link":"https://syu-m-5151.hatenablog.com/entry/2025/08/12/210021","contentSnippet":"はじめにエンジニアの勉強会で、こんな経験はないだろうか。「〇〇って知ってる？」「最近△△が流行ってて」「□□の記事読んだ？」「✗✗さんって知り合い？」次から次へと断片的な情報を繰り出してくる人。どの話題も表面的で、深く掘り下げようとすると会話が続かない。そして、ふと気づく瞬間がある――自分も同じような話し方をしているのではないか、と。コードは書ける。タスクはこなせる。でも技術的な議論になると、借り物の言葉しか出てこない。 この恐怖を、多くのエンジニアが密かに抱えている(と思っている)。表層的な知識だけで話す「Fake野郎」――そう呼ばれることほど、エンジニアとしての信頼と自信を失う言葉はない。何者（新潮文庫）作者:朝井 リョウ新潮社Amazon現代のエンジニアは、かつてないほど豊富な学習リソースに囲まれている。朝から晩まで技術記事を読み漁り、新しいフレームワークを追いかけ、トレンドをキャッチアップする。それなのに、いざ技術的な議論になると、借り物の言葉しか出てこない。問題の本質は、情報量の不足ではない。むしろその逆だと思う。大量の情報を消費することで満足し、深く考える時間を失っている。その結果、「聞いたことはある」レベルの断片的な知識ばかりが蓄積され、体系的な理解や独自の洞察が育たない。今日はそんな問題について考えていきたいと思う。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。コミュニケーション技法の限界雑談を円滑にする方法、相手に好印象を与える話し方――こうしたスキルは確かに社会人として必要だ。共通の話題を見つけ、相手の意見に共感を示し、適度に自己開示をする。これらのテクニックで、職場の人間関係は確実に改善されるだろう。しかし技術的な文脈において「あの人の意見は聞く価値がある」と思われるためには、全く別の次元の能力が要求される。それは、技術に対する深い洞察と、実体験に基づく独自の視点だ。表面的なコミュニケーションスキルでこの本質的な課題を解決しようとするのは、バグの根本原因を無視してUIだけを修正するようなものだ。 一時的には改善したように見えても、本質的な問題は何も解決していない。人は聞き方が９割作者:永松 茂久すばる舎Amazon人は話し方が９割２作者:永松 茂久すばる舎Amazon凡人エンジニアの生存戦略厳しい現実を直視しよう。私たちの大半は、いわゆる「本物」ではない。必死で情報を集めて継ぎ接ぎしている「凡人エンジニア」だ。借り物の言葉で話し、Qiitaのコードで動かし、理解が浅いまま次のタスクに移る。まずは全力で実装して、全力で失敗することから始めよう。「ドキュメント読めばわかる」と言いながら、結局コピペで終わらせている。そんな中途半端な理解では、いつまでも表層的なままだ。公式ドキュメントの10倍のコードを書いて、サンプルコードの10倍のエッジケースを試して、それでも理解できなかったら、そこがスタートラインだ。センスは知識からはじまる作者:水野学朝日新聞出版Amazonセンスの哲学 (文春e-book)作者:千葉 雅也文藝春秋Amazon天才には直感がある。我々にはそれがない。だから地道に検証するしかない。優れたエンジニアが一目で見抜く問題を、我々はベンチマークを取り、プロファイラを回し、ボトルネックを一つずつ潰していく。それが我々の戦い方だ。禅とオートバイ修理技術 上 (ハヤカワ文庫NF)作者:ロバート Ｍ パーシグ早川書房Amazon禅とオートバイ修理技術 下 (ハヤカワ文庫NF)作者:ロバート Ｍ パーシグ早川書房Amazonそして朗報がある。本当に深い理解を持つエンジニアは、実はそんなにいない。一流と評価されているエンジニアのうち、本当に深い理解を持つのはごく一部。残りの大半は、我々と同じ、必死で技術ブログを読み漁って知識を継ぎ接ぎしている連中だ。深い理解がないのに評価されているエンジニアとの違いは、表層的な知識の組み立て方の上手さだ。断片的な知識を体系化し、一つ一つコードで検証して本物らしくなっていく。借り物でも、偽物でも、精度を上げていけば立派な「技術力のあるエンジニア」として認められる。批判された時こそ、謙虚に、誠実に、真摯でなくてはならない。批判してくる外野にではなく、理解したい技術そのものに対して。深い理解を持たない我々は、あくまで謙虚に、一つずつ理解を深めていくしかない。達人プログラマー ―熟達に向けたあなたの旅― 第2版作者:David Thomas,Andrew Huntオーム社Amazon情報収集の罠現代のエンジニアを取り巻く環境を見てみよう。GitHub、Hacker News、Reddit、Zenn、Qiita、技術ブログ、Twitter――無限とも思える情報の海が広がっている。朝起きてから寝るまで、常に新しい情報が流れ込んでくる。そして今や、ChatGPTやClaudeに「説明して」と投げるだけで、瞬時に整理された回答が返ってくる。 GitHub Copilotがコードを補完し、エラーメッセージをそのまま生成AIに貼り付ければ解決策が提示される。便利になった分、自分で考える機会は激減した。しかしここに大きな落とし穴がある。情報を消費し続けることと、知識を深めることは全く別の行為なのだ。むしろ過度な情報摂取は、深い思考を妨げる最大の要因となる。Qiitaから解決策をコピーペーストし、Zennの記事を斜め読みし、YouTubeのチュートリアルを倍速で流し見る。生成AIに「どうやって実装する？」と聞いて、返ってきたコードをそのまま使う。 こうした習慣は、一見効率的に見えるが、実は表面的な理解しか生まない。生成AIの回答は確かに正確で包括的だ。しかし、なぜその実装なのか、どんなトレードオフがあるのか、エッジケースはどうなるのか――こうした深い理解は、自分でデバッグし、失敗し、試行錯誤する中でしか得られない。必要なのは、情報の洪水から一歩離れ、静かに思考する時間だ。新しく学んだ概念について、なぜそう設計されているのか、どんな問題を解決しているのか、他のアプローチと比べてどんな利点があるのか――こうした問いと向き合う時間なくして、深い理解は得られない。奪われた集中力: もう一度〝じっくり〟考えるための方法作者:ヨハン・ハリ作品社Amazonアテンション・エコノミーと「驚き屋」の罠「〇〇驚き屋」という揶揄する言葉を聞いたことがあるだろうか。 新しい技術が出るたびに「革命的だ！」と騒ぎ立て、トレンドが変わるたびに「これからはこれだ！」と主張を変える。彼らの発言には深みがなく、表面的な驚きと感動だけで構成されている。これは個人の問題じゃなくて、アテンション・エコノミーが生み出す構造的な問題なんだよね。 クリック数、いいね数、PV数――これらの指標が支配する世界では、深い考察より刺激的なタイトルが、地道な検証より扇動的な主張が評価される。「〇〇は死んだ」「なぜ〇〇を今すぐやめるべきか」「〇〇を使わない奴は時代遅れ」 ――こうした極端なタイトルの記事が溢れる理由は明白だ。注目を集めることが最優先事項となり、技術の本質的な理解は二の次になる。技術ブログを書く側も読む側も、このアテンション・エコノミーの罠にはまっている。書く側は「バズる」ことを意識し、読む側は刺激的な情報を求めちゃう。 この悪循環が、技術コミュニティ全体の議論を浅くしている。価値のある技術的洞察は、地味で、時間がかかり、すぐには「バズらない」。でもさ、長期的に見れば、これらの深い考察こそが技術の進歩を支えているんだ。 派手な新機能の紹介記事より、バグの根本原因を探る地道な分析の方が、エンジニアとしての成長には遥かに有益だ。「驚き屋」にならないためには、情報の新しさではなく深さを追求する姿勢が必要だ。 トレンドを追いかけるのではなく、技術の本質を理解する。表面的な機能紹介に満足せず、なぜその設計になったのかを探求する。この姿勢こそが、技術力を育てる。アテンション・エコノミーのジレンマ　〈関心〉を奪い合う世界に未来はあるか作者:山本 龍彦KADOKAWAAmazon技術書と技術ブログプログラミング言語の入門書、フレームワークの解説書、設計パターンの教科書――積読が増えていく一方で、正直、身についた知識はどれだけあるだろうか。技術書を読むのは確かに良い。体系的な知識が得られ、著者の深い洞察に触れることができる。しかし、月に何冊も読破しようとすると、結局どれも消化不良に終わってしまう。一冊の技術書から価値を引き出すには、読んだ内容を実際に試し、既存の知識と関連付け、自分のプロジェクトに応用してみる必要がある。そして技術ブログとなると、この問題はさらに顕著になる。技術ブログは技術書以上に断片的で、文脈が省略され、前提知識がバラバラだ。朝のコーヒーを飲みながら5つの記事を流し読み、昼休みにさらに3つ、帰りの電車でまた10個――こうして大量の技術ブログを消費しても、頭に残るのは曖昧な印象だけ。「〇〇の新機能について読んだ気がする」「マイクロサービスの何かについて見た」「セキュリティの重要性について誰かが書いていた」――読んだはずなのに、具体的に何を学んだか説明できない。これが技術ブログの読み過ぎがもたらす典型的な症状だ。私の経験から言うと、技術ブログを立て続けに読むと、まるで異なるプログラミング言語を同時に学んでるような混乱が生じるんだ。ある記事ではTypeScriptのベストプラクティス、次の記事ではGoの並行処理、その次はKubernetesの設定――概念が混ざり合い、理解が浅くなり、結局どれも中途半端に終わってしまう。技術ブログの危険性は、その手軽さにある。 1記事5分で読めるという錯覚が、大量消費を促す。しかし実際には、その5分の記事を理解するには、コードを書いて検証し、関連概念を調べ、自分の言葉で説明できるようになるまで、少なくとも1時間は必要だ。質の高い学習とは、情報の量ではなく、理解の深さで測られる。 週に50本の技術ブログを流し読みするより、1本の記事を徹底的に理解し、実際にコードを書いて検証する方がはるかに価値がある。技術書なら月に1冊を深く読み込む方が、10冊を斜め読みするより遥かに身になる。知ってるつもり　無知の科学 (ハヤカワ文庫NF)作者:スティーブン スローマン,フィリップ ファーンバック早川書房Amazonインプットのコンテキストスイッチという罠コンテキストスイッチのコストは、アウトプットだけの問題じゃない。インプット（学習）においても、同じように深刻な影響を及ぼす。朝はReactのHooks、昼休みにRustの所有権、夕方にはKubernetesのネットワーキング、寝る前にデータベースのインデックス戦略――一見効率的に見えるが、これは脳に対して過酷なコンテキストスイッチを強いている。プログラミング言語を切り替えるとき、私たちの脳は文法、イディオム、エコシステム、思考パターンを丸ごと切り替える必要がある。JavaScriptの非同期処理を理解しようとしていた脳が、突然Goのgoroutineに切り替わる。この切り替えには、想像以上の認知的コストがかかる。オブジェクト指向から関数型プログラミングへ、ミュータブルからイミュータブルへ――異なるメンタルモデルが脳内で衝突し、どちらの理解も中途半端になってしまう。10分でDockerの記事、5分でGraphQL、15分で機械学習入門。このような学習は、パズルのピースをランダムに拾い集めているようなものだ。結果として「聞いたことはある」レベルの知識ばかりが蓄積される。理解を深めるには「没入」が必要だ。しかし頻繁なコンテキストスイッチは、この没入状態を妨げる。水面を滑るように情報を摂取しても、深海に潜ることはできない。効果的な学習のためには、「テーマを絞った集中的なインプット」が重要だ。 今週はReactに集中する、今月はデータベース設計を深める――こうした戦略的な学習計画が、技術力向上につながる。マルチタスクが生産性を下げるように、マルチトピック学習は理解を浅くする。 一つのテーマに集中し、関連する複数の情報源から多角的に学ぶ。この「深さ優先」のアプローチこそが、技術的洞察を生み出す土壌となる。あっという間に人は死ぬから　「時間を食べつくすモンスター」の正体と倒し方作者:佐藤 舞（サトマイ）KADOKAWAAmazon実践こそが深い理解への唯一の道理論を語るだけの評論家と、実際にシステムを構築するエンジニアの最大の違いは何か。それは、仮説を実証できる環境を持っているということだ。公式ドキュメントには「簡単に実装できます」と書かれていた機能が、実際にはエッジケースの山だった。ベンチマークでは高速だったライブラリが、実環境では思わぬボトルネックになった。こうした「理想と現実のギャップ」は、実装してみて初めて分かる。手を動かすことで見えてくる世界がある。「〇〇の新機能」という記事を10本読むより、実際にその機能を使ってみる。チュートリアルのコピペではなく、ゼロから書く。公式サンプルを動かすだけでなく、壊してみる。境界値を試し、負荷をかけ、エラーケースを検証する。平凡なエンジニアと卓越したエンジニアを分けるのは、「違和感」に対する感度だ。 このAPIの設計、何か不自然じゃないか？なぜこのフレームワークは、こんな実装を選んだのだろう？――天才なら一瞬で見抜く違和感を、凡人の我々は見逃してしまう。Fake野郎は表面的な動作だけ見て「動いたからOK」で終わらせる。だから深い理解に到達できない。 でも、小さな疑問を素通りせず、愚直にコードで検証する習慣を続ければ、いつか独自の技術的洞察にたどり着けるかもしれない。コードリーディングも、深い学習につながる。 ライブラリの内部実装を読めば、ドキュメントに書かれていない設計思想が見えてくる。GitHubでスター数の多いプロジェクトを開き、/srcディレクトリを覗く。最初は圧倒されるかもしれない。しかし、エントリーポイントから少しずつ読み進めれば、必ず「ああ、そういうことか」という気づきが訪れる。技術選定を誤った経験、見積もりを大きく外した経験、本番環境で障害を起こした経験――これらの苦い記憶こそが、最も価値ある学習材料となる。 成功事例からは「うまくいく方法」しか学べないが、失敗からは「なぜうまくいかないのか」という本質的な理解が得られる。個人的に思うのだが、思考を深めるための最良の方法の一つが、技術ブログの執筆だ。 コードの動作を説明し、設計の意図を言語化し、遭遇した問題と解決策を記録する。この過程で、曖昧だった理解が明確になり、見落としていた課題が浮かび上がる。完璧である必要はない。思考の過程を記録することに価値がある。「動いた」で満足せず、「なぜ動くのか」「どこまで動くのか」「動かなくなる境界はどこか」を探求する。サンプルコードをそのまま動かして終わりにするのではなく、必ず何か一つは変更を加えてみる。この小さな実験が、表面的な理解を本質的な理解へと変える。手を動かすことは、時間がかかる。 記事を読むだけなら5分で済むことが、実装すれば1時間かかるかもしれない。しかし、その1時間の投資が、将来の技術的議論で「実はこれ、実装してみたんですが...」と言える強みになる。この実体験に基づく発言こそが、「深みのある話」の源泉となるのだ。アイデアが生まれるプロセス深い技術的洞察はどのようにして生まれるのか。ジェームス・W・ヤングの名著『アイデアのつくり方』が、その答えを示してくれる。ヤングによれば、アイデアっていうのは既存の要素の新しい組み合わせで、その才能は事物の関連性を見つけ出す力に依存してるらしい。3年目までに身につけたい技術ブログの書き方でも紹介したがかなり自分の中でしっくり来ているのだと思う。アイデアのつくり方作者:ジェームス W.ヤングCCC MEDIA HOUSEAmazonこの考え方は、技術的な深みを持つエンジニアになるプロセスと驚くほど一致する。ヤングが提唱する5段階のプロセスを見てみよう。第1段階：資料を収集する特定の技術に関する専門知識と、幅広い一般知識の両方を集める。ドキュメントを読み、コードを書き、エラーメッセージと格闘する――これらすべてが資料収集だ。第2段階：資料を噛み砕く集めた情報を様々な角度から検討し、関係性を探る。「なぜこのAPIはこう設計されているのか」「他の言語ではどう実装されているか」と問いかけながら、情報を咀嚼する。第3段階：問題を放棄する一度意識的な思考から離れ、無意識に働かせる。デバッグに行き詰まったときに散歩に出る、複雑な設計問題を一晩寝かせる――これは逃避ではなく、創造的プロセスの一部だ。第4段階：アイデアが訪れるシャワー中、通勤中、ランチタイム――何気ない瞬間に「あっ、そうか！」という閃きが訪れる。バグの原因が突然分かる、エレガントな設計が浮かぶ、技術の本質が見える瞬間だ。第5段階：アイデアを現実に連れ出す閃いたアイデアを忍耐強く形にする。コードに落とし込み、動作を検証し、チームに説明する。この段階で初めて、漠然とした洞察が具体的な価値となる。多くのエンジニアが「深い話ができない」と悩む理由は、このプロセスのどこかが欠けているからだ。 情報収集ばかりで咀嚼が足りない、あるいは考えてばかりで実装しない。バランスこそが鍵となる。深い洞察が生まれない理由「技術的に深い話ができない」と悩んでいるなら、ヤングの5段階プロセスのどこが欠けているか診断してみよう。資料収集が不足している場合技術書を読む量が少ない、新しい技術に触れる機会が限られている――こんな状態では、組み合わせる要素自体が不足する。ただし、前述の通り大量の技術ブログを流し読みするのは逆効果だ。 質の高い情報源から、じっくりと知識を吸収することが重要となる。最も見落とされがちなのが、ソースコードという一次資料の重要性だ。 ドキュメントは理想を語り、ブログは表面を撫でるが、コードは真実を語る。なぜその設計になったのか、どんな制約があったのか、どんなトレードオフがあったのか――これらの答えはコードの中にある。優れたエンジニアは、コードを読む際に独自の視点を持っている。状態の遷移に着目する者、データの流れを追う者、エラーハンドリングから本質を見抜く者――アプローチは様々だが、共通するのは表層的な動作ではなく、設計の意図を読み取ろうとする姿勢だ。さらに重要なのは、技術以外の分野からの資料収集だ。 心理学、経済学、デザイン、哲学、歴史――こうした他分野の知識が、技術的な洞察に独特の深みを与える。ユーザー心理を理解せずに優れたUIは作れないし、経済原理を知らずにビジネス価値のあるシステムは設計できない。技術と他分野の知識が交差する地点に、イノベーティブなアイデアが生まれる。情報の咀嚼が不足している場合学んだことをそのまま記憶するだけで、自分の言葉で説明できない。コードは書けるが「なぜそう書くのか」を説明できない。これは最も多くのエンジニアが陥る罠だ。咀嚼とは、単に理解することではない。異なる文脈で再構成し、別の角度から検証し、既存の知識と結びつける創造的なプロセスだ。 学んだデザインパターンを、自分のプロジェクトの文脈で解釈し直す。新しいフレームワークの概念を、過去に使った技術と比較する。エラーメッセージの意味を、システム全体の動作と関連付けて理解する。図解する、誰かに説明する、ブログに書く――これらはすべて咀嚼のための手段だ。しかし最も効果的なのは、「もしこれが違う設計だったら」という仮定の問いを立てることだ。 なぜこのAPIはRESTfulなのか、GraphQLだったらどうなるか。なぜこのデータベースはRDBMSなのか、NoSQLだったらどうなるか。この思考実験が、表面的な理解を本質的な理解へと変える。思考を寝かせる時間がない場合常にタスクに追われ、締切に追われ、新しい情報を詰め込み続ける。これでは無意識が働く余地がない。創造的な洞察は、意識的な思考の合間に生まれる。問題を抱えたまま散歩に出る、シャワーを浴びる、コーヒーを淹れる――これらは逃避ではなく、無意識に問題を委ねる積極的な戦略だ。 優れたエンジニアは、デバッグに行き詰まったら席を立つ。設計に悩んだら一晩寝かせる。これは諦めではなく、脳の別の部分を活用する技術だ。重要なのは、問題を明確に定義してから離れることだ。 曖昧なまま放置しても、無意識は働かない。「なぜこのテストが失敗するのか」「どうすればこのパフォーマンスを改善できるか」――具体的な問いを立ててから離れることで、無意識が背景で処理を続ける。そして予期しない瞬間に、答えが浮かび上がる。閃きを見逃している場合「あれ？」という違和感、「もしかして」という仮説――これらの小さな気づきを「大したことない」と無視してしまう。閃きは派手なものばかりではない。むしろ日常の中の小さな違和感こそが、深い洞察への入り口となる。 なぜこのライブラリは、こんな回りくどい実装をしているのか。なぜこのエラーメッセージは、こんなに分かりにくいのか。なぜみんな、この非効率な方法を使い続けているのか。これらの違和感を捕まえるには、常に記録する習慣が必要だ。 スマートフォンのメモアプリ、Slackの自分専用チャンネル、紙のメモ帳――媒体は何でもいい。重要なのは、その瞬間を逃さないことだ。後から見返すと「なんでこんなことをメモしたんだろう」と思うこともある。しかし、その中の一つが、数週間後に重要な発見につながることがある。形にできない場合頭の中では分かっているのに、コードに落とせない、文章にできない、説明できない。これは「完璧主義の罠」かもしれない。しかしより深刻なのは、「形にする」ことの本質を誤解していることだ。 形にするとは、完成品を作ることではない。思考を外部化し、検証可能にし、他者と共有可能にすることだ。プロトタイプでいい、疑似コードでいい、箇条書きでいい。重要なのは、頭の中から外に出すことだ。最小限の形から始める勇気が必要だ。 100行の美しいコードではなく、10行の動くコード。推敲を重ねた技術記事ではなく、500文字のメモ。洗練されたプレゼンではなく、ホワイトボードの走り書き。これらの「不完全な形」こそが、思考を前進させる。形にする過程で新たな問題が見つかり、新たな洞察が生まれる。完璧を待っていては、永遠に何も生み出せない。それでも深い理解に到達できない時はここまで読んでも、できない人が大半だと思う。頭では理解できても、結局技術ブログを流し読みして、何も実装せずに終わっていく。偽物は偽物のまま、凡人は凡人のまま終わってしまうのか。違う。凡人には凡人の戦い方がある。深い理解に一足飛びに到達できないなら、浅い理解を100回積み重ねればいい。 天才が1回で見抜くバグを、我々は10回のprint文で追い詰める。「なんとなく分かった」を50個集めれば、いつの間にか体系的な理解の入り口に立っている。そして何より大切なのは、この積み重ねを「誠実に」続けることだ。分からないことを分からないと認める。コピペしたコードに「理解した」と言わない。ChatGPTが生成したコードを自分が書いたように見せない。この小さな正直さが、長期的には最も強い武器になる。「分からないけど動いた」と正直に言えるエンジニアは、意外と信頼される。 なぜなら、その人の「分かった」という言葉には重みがあるからだ。誠実にコードと向き合い続けると、不思議なことが起きる。3年前に書いた「分からないまま動かしたコード」の意味が、ある日突然分かる瞬間が来る。 これは、誠実に向き合い続けた者だけに与えられる報酬だ。凡人の強みは、凡人の気持ちが分かることだ。 天才の書く完璧なドキュメントより、凡人の書く「ここでハマった」メモの方が、多くの人を救うこともある。一人でこっそり胸を張ってもいい。地道で誠実な成長を、私は美しいと思う。ファスト教養　10分で答えが欲しい人たち (集英社新書)作者:レジー集英社Amazonおわりに記事自体が筆者の批判する「大量の情報」になってしまっている点は皮肉をぶつけないで下さい。痛いです。問題は知識の量だけではない。 大量の情報を右から左へ流すだけでは、いつまでも「借り物の言葉」しか話せない。深みのある技術者になるために必要なのは、情報の消費を減らし、思考の時間を増やすことだ。 週に50本の技術ブログを流し読みする代わりに、1つのテーマに集中して深く潜る。天才ではない我々には、地道な努力しかない。偽物は偽物なりに、凡人は凡人なりに、全力で実装して、全力で失敗して、そこから学ぶ。借り物の知識でも、継ぎ接ぎの理解でも、精度を上げていく。今日から始められることは、シンプルだ。 週に1時間、ネットから離れて静かに考える時間を作る。今週取り組んだ技術的課題について振り返り、500文字でもいいから言語化する。何より恐れるのは「Fake野郎」と呼ばれることだ。借り物の言葉で話し、実装経験もないのに知ったかぶりをし、深い理解もないのに分かったふりをする。でも、それでいい。大切なのは、自分がFake野郎かもしれないという自覚を持ち、それでも前に進む勇気を持つことだ。週に1時間、静かに考える。500文字でもいいから言語化する。実装して、失敗して、そこから学ぶ。この小さな積み重ねが、いつか「あの人の話には深みがある」と言われる日につながる。Fake野郎から始まってもいい。大切なのは、そこで終わらないことだ。","isoDate":"2025-08-12T12:00:21.000Z","dateMiliSeconds":1755000021000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"組織の成長に伴う私のtimes の終焉についての思索","link":"https://syu-m-5151.hatenablog.com/entry/2025/08/04/173559","contentSnippet":"さよなら、私の愛したtimesはじめに組織が成長する過程で、かつて機能していた構造が限界を迎える瞬間がある。私はおそらく今、その転換点に立っている。長年愛用してきた社内での個人的な発信空間であるtimesチャンネル(組織によっては分報という名前かも)を閉じることにした。これは単なるチャンネルの使用終了ではなく、組織の成長段階における必然的な選択だと考えている。ちなみにあくまで私の考えで私のみが実行しています。また、いつか復活する可能性もあります。会社の規模が大きくなってきたことを踏まえ、あくまで個人の考えでTimesチャンネルを削除することに決めました。 pic.twitter.com/eZfl1kuf2Q— nwiizo (@nwiizo) 2025年8月3日   このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。timesの光と影小規模組織において、timesや分報などのいわゆるインフォーマルなコミュニケーションチャンネルは組織の血流として機能する。心理的障壁を下げ、階層を超えた知識共有を可能にし、暗黙知を形式知へと変換する触媒となる。しかし、この美しいエコシステムは、ある臨界点を超えると自己矛盾を抱え始める。スケーラビリティの逆説組織が拡大するにつれ、情報の流通経路は指数関数的に増加する。全体性の把握は不可能となり、部分最適化が進行する。かつて全員が共有していた文脈は断片化し、同じ組織にいながら異なる現実を生きることになる。情報の民主化を目指したはずのシステムが、逆に情報格差を生み出す。見える人と見えない人、聞こえる声と聞こえない声。組織の成長とともに、この非対称性は拡大していく。社内には案件のチャンネル、チームのチャンネル、技術のチャンネルが十分に整理されている。今後の発信はこれらの適切なチャンネルで行うことで、より効果的な情報共有を目指す。注意経済と生産性のパラドックス常時接続の環境は、注意力という有限の資源を巡る競争を生み出す。コミュニケーションの活性化が目的だったはずが、いつしかコミュニケーション自体が目的化する。リアクションの数が暗黙の評価軸となり、本来の価値創造から離れていく。組織内SNS化とでも呼ぶべきこの現象は、生産性向上のためのツールが生産性を阻害するという皮肉な結果を生む。心理的安全性の両義性カジュアルさは諸刃の剣である。フラットな対話を促進する一方で、境界線の曖昧さは時に傷を生む。デジタル空間に刻まれた言葉は、文脈を失いながら永続する。過去の自分が未来の自分を、あるいは他者を傷つける可能性を常に孕んでいる。組織構造をちゃんとやる最近読んだ『トリニティ組織』（矢野和男著）は、私の決断に理論的な確信を与えてくれた。組織の生産性と幸福度を決定づけるのは、人間関係の「形」だという。自分の知り合い2人同士も知り合いである「三角形の関係」が多い組織ほど、問題解決能力が高く、孤立も生まれにくい。トリニティ組織:人が幸せになり、生産性が上がる「三角形の法則」作者:矢野 和男草思社Amazontimesの構造について考えると、その限界が明確になる。発信者を頂点に、参加者が個別につながる形 ― これはまさに「V字型の関係」の量産装置である。私のチャンネルを見ているAさんとBさんが、そこでのやり取りを通じて直接つながることは稀だ。むしろ、それぞれが私との1対1の関係に終始する。リモートワーク環境下では、この構造的欠陥はより顕著になる。物理的な偶発的出会いが失われた今、意図的に「三角形」を作り出す仕組みが必要だ。しかし、個人チャンネルという形式は、その本質において中心化を促進し、分散化を阻害する。一方、チームチャンネルや技術雑談チャンネルでは、参加者同士が自然に相互作用する。同じ疑問に対して複数人が異なる視点でアドバイスし、そこから新たな議論が派生する。これこそが知識の三位一体化であり、創造性を高める組織の在り方だ。論理的思考の階層性がV字関係を生み出すという洞察も重要だ。分解と整理を基本とする思考フレームワークは、産業時代には機能したが、知識創造の時代には限界がある。生成AIによる知識の民主化が進む今、組織は階層的構造から、より有機的なネットワーク構造へと進化すべき時を迎えている。私の選択は、V字から三角形へのシフトである。個人の承認欲求を満たす場から、集合知が生まれる場へ。ネットワークのハブとしての自己から、ネットワークの一部としての自己へ。これは単なるツールの変更ではなく、組織内での存在様式の根本的な転換を意味している。時間という有限資源の配分問題個人チャンネルは「アテンション・エコノミー（注意の経済）」における構造的矛盾を抱えている。組織の成長に伴い、情報チャンネルは線形に増加するが、個人の処理能力は一定のまま。この非対称性は、必然的に選別と排除のメカニズムを生み出す。より深刻なのは、この選別が生む不可視の階層構造だ。物理的空間における排除は可視的だが、デジタル空間における排除は不可視でありながら、より根深い分断を生む。参加の自由が保証されているがゆえに、不参加や選択的参加が生む格差は個人の責任に帰されやすい。アテンション・エコノミーのジレンマ　〈関心〉を奪い合う世界に未来はあるか作者:山本 龍彦KADOKAWAAmazon心理的安全性のパラドックス個人チャンネルは心理的安全性を高めるために導入されながら、逆にそれを脅かす装置にもなりうる。これは、親密性と公開性の両立不可能性に起因する。親密な空間であるがゆえに生まれる無防備な発言は、公開空間であるがゆえに永続し、検索可能となる。私自身も経験したことだが、他者への批判を目撃することの疲弊は想像以上に大きい。社内SNS化した空間では、建設的批判と破壊的批判の境界が曖昧になりやすい。「事実と解釈を分ける」という個人的努力に依存する構造は、そもそも持続可能ではない。古参メンバーとしての責任組織の初期メンバーは、文化の形成者であると同時に、その変革の阻害要因にもなりうる。そこまで古参ではないが組織が急拡大しているので相対的に古参である。私の存在が、新しいメンバーにとっての見えない圧力になっていないか。私の発言が、本来生まれるべき多様な声を抑圧していないか。ここで重要なのは、timesの価値は世代や在籍期間によって大きく異なるという認識だ。若手や入社直後のメンバーにとって、timesは今でも有効なツールとして機能している。組織への順応過程において、インフォーマルな発信空間は心理的安全性を提供し、自己開示を通じた関係構築を促進する。新しいメンバーが組織文化を理解し、自分の居場所を見つけるための重要な装置として、その価値は否定できない。また、社長や事業部長といった経営層にとっても、timesは別の意味で価値を持つ。階層的な距離が生む心理的障壁を低減し、人間的な側面を共有することで組織全体の心理的安全性を高める効果がある。経営層の思考プロセスや日常的な悩みが可視化されることで、「雲の上の存在」から「同じ人間」へと認識が変わる。これは特に急成長する組織において、上下の分断を防ぐ重要な機能となりうる。しかし、長く在籍する中間層の一般社員である私の場合、その影響力は異なる性質を持つ。経営層のような明確な役割や責任に基づく発信ではなく、「古参であること」自体が生む見えない権威性が問題となる。この非対称性を自覚したとき、退場もまた一つの貢献となる。若手が自由に発信し、経営層との健全な対話が生まれる空間を守るためにも、中間層の古参は適切なタイミングで身を引く必要がある。個人の節度や自制に依存するシステムは、本質的に脆弱だ。構造的に承認欲求を刺激し、注意力を奪い、関係性を歪めるメカニズムの中で、個人の倫理にどこまで期待できるだろうか。むしろ、そうした個人的努力を不要とする構造へと移行することこそが、組織の進化ではないか。私のチャンネルには、長年の蓄積がある。試行錯誤の痕跡、成功と失敗の記録、人間関係の履歴。これらは個人にとっての財産であると同時に、組織にとっての負債にもなりうる。過去の堆積が未来の可能性を制約するとき、断捨離は創造的行為となる。生成AI時代における組織内コミュニケーション知識のオープン化は、組織の存在理由そのものを問い直している。もはや情報の独占や階層的な知識伝達では、価値創造は不可能だ。必要なのは、多様な視点が交差し、予期せぬ組み合わせが生まれる「場」の設計だ。個人チャンネルは、表面的には情報の民主化に貢献しているように見える。しかし実際には、情報の断片化と選択的可視性による新たな非対称性を生み出している。全体性の把握が不可能な状況下では、部分最適化が進行し、組織は分断される。これからの組織に必要なのは、個人の発信力ではなく、集団としての知識創造力だ。それは、中心化されたネットワークではなく、分散化されたメッシュとして知識が循環する仕組みから生まれる。個から全体へ、閉鎖から開放へ、所有から共有へ。この転換こそが、知識社会における組織の生存戦略となる。卒業という選択すべてのシステムには寿命がある。それを認めることは敗北ではなく、成熟の証である。私にとってのtimesは、その役割を終えた。これは組織の成長を祝福し、新しい段階への移行を受け入れる儀式でもある。個人チャンネルには組織の成長と反比例する有効性がある。規模の拡大は必然的にシステムの限界をもたらす。これは、あらゆる中心化されたネットワークが直面する普遍的な課題だ。組織の成長を喜びながら、その成長に適応できないシステムに固執することは、成長そのものを阻害する。興味深いのは、この空間から離脱した時に感じる「喪失感の不在」だ。むしろ、制約がもたらす創造性の向上を実感している。これは、無限の選択肢よりも適切な制約が人間の創造性を高めるという、古典的な原理の現れかもしれない。「代替可能性」という認識は重要だ。心理的安全性も、知識共有も、偶発的な創発も、すべて異なる構造で実現可能だ。むしろ、より持続可能で公平な形で。個人的な発信空間から、より構造化されたコミュニケーションチャンネルへ。この移行は、組織が次のフェーズに進むための必要な進化だと信じている。終わりに変化を恐れず、執着を手放し、新しい形を模索する。それが成長する組織の中で生きるということだ。私のこの選択は、単なる個人的な決断ではない。V字型の関係から三角形の関係へ、情報の独占から知識の循環へ、個人の承認欲求から集合知の創発へ。これは、知識社会が求める組織変革の、小さな、しかし確かな一歩だ。真の課題は特定のツールの有無ではなく、組織における関係性の質にある。健全な組織文化は、ツールを超えて、人と人との相互作用の中から生まれる。私のこの選択が、組織のコミュニケーション構造について考える一つのきっかけになれば幸いである。これまでの対話に感謝を込めて。そして、新しい形での再会を楽しみにしている。参考Slackのtimesのメリット・デメリットについて改めて考えてみる｜斎藤 雅史Slackの分報チャンネル使うのやめた - stefafafan の fa は3つですSlackの分報チャンネル使うのを再開していた - stefafafan の fa は3つですまたSlackでtimesを始めてしまった｜ばんくし分報を導入して3年経ったので振り返る - FRTKL","isoDate":"2025-08-04T08:35:59.000Z","dateMiliSeconds":1754296559000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"2025年夏 AIエージェントシステムに対する考え方","link":"https://syu-m-5151.hatenablog.com/entry/2025/07/29/195608","contentSnippet":"はじめに正直に言って、AIエージェントを初めて理解しようとしたとき、私は完全に見当違いをしていた。単なる賢いチャットボットの延長線上にあるものだと思っていた。でも、実際に触れてみて驚いた。これは全く違う生き物だった。エージェントとは「行為者性（agency）」を持つ存在だ。つまり、ただ反応するだけじゃなくて、目的を持ち、意図的に行動し、経験から学習する自律的な存在だ。これって、ある意味で「生きている」ということに近いんじゃないだろうか。従来のソフトウェアを思い出してみる。入力に対して決まった出力を返す、予測可能な機械だった。でもAIエージェントは違う。確率的で、時に予想外の振る舞いを見せる。まるでデジタル世界に新しい種類の「生命」が誕生したかのような感覚を覚えることがある。私たちは今、Andrej Karpathyが言うところのSoftware 3.0の時代にいる。自然言語がプログラミング言語になり、プロンプトを書くことで複雑なタスクを実行できる時代だ。でも、この技術革新の中で、私が最も関心を持っているのは、エージェントシステムをどう設計し、どう制御し、どう共生していくかということだ。blog.riywo.comkarpathy.medium.com考えてみれば、人類の歴史は道具との共進化の歴史だった。石器が私たちの手を変え、文字が私たちの記憶を変え、インターネットが私たちの社会を変えた。そして今、AIエージェントが私たちの思考そのものを変えようとしている。 speakerdeck.comサピエンス全史　上　文明の構造と人類の幸福 (河出文庫)作者:ユヴァル・ノア・ハラリ河出書房新社Amazonこのブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。エージェントとは何か行為者性を持つデジタル存在エージェントを理解するには、まずその本質である「行為者性（agency）」を理解する必要がある。これは単に命令に従うだけではなく、自らの判断で行動を選択する能力だ。人間の秘書を思い浮かべてみてほしい。優秀な秘書は、単に言われたことをこなすだけじゃない。スケジュールを見て「この会議の前に資料の確認時間が必要ですね」と提案したり、「先方からの返信がまだですが、リマインドしましょうか」と気を利かせたりする。AIエージェントも同じような能力を持ち始めている。環境を認識し、目標を理解し、最適な行動を選択する。これは従来のプログラムとは根本的に違う。プログラムは「もしAならBをする」という決まったルールに従うが、エージェントは「この状況で目標を達成するには何をすべきか」を考える。エージェントの基本的な能力技術的に見れば、エージェントは大規模言語モデル（LLM）を基盤として動いている。でも、ここが面白いところで、彼らは単に反応するだけじゃない。環境を認識し、意思決定し、行動を実行するサイクルを自律的に回す。エージェントの環境認識能力は驚くほど幅広い。テキストはもちろん、画像、音声、構造化データなど、人間が理解できる情報ならほぼ何でも処理できる。例えば、スクリーンショットを見せて「このエラーを解決して」と言えば、画面の内容を理解し、エラーメッセージを読み取り、解決策を提案する。この能力により、人間とほぼ同じような方法で情報を受け取り、理解できるようになった。推論能力においては、エージェントは複雑な問題を人間の専門家のように段階的に分解して考える。「売上が下がっている原因を分析して」と言われたら、まず売上データを確認し、前期との比較を行い、変化があった要因を特定し、それぞれの影響度を評価する。この思考プロセスは、経験豊富なアナリストが行うアプローチとほとんど変わらない。そして行動実行能力により、エージェントは考えるだけでなく実際に行動できる。メールを送り、カレンダーに予定を入れ、データベースを更新し、レポートを作成する。これらの能力を組み合わせることで、単純なタスクから複雑なワークフローまで、幅広い業務を完遂できるようになった。zenn.dev非同期処理による新しい働き方エージェントの革命的な特徴の一つが非同期的な処理だ。これにより、人間の働き方が根本的に変わりつつある。従来は、タスクが発生したら人間がすぐに対応する必要があった。メールが来たら読んで返信し、レポートの依頼が来たら作成し、バグが報告されたら調査する。常に反応的で、割り込みに振り回される日々だった。でも、エージェントがいれば違う。メールが届いたとき、エージェントが内容を理解し、返信の下書きを用意してくれる。朝起きたら、すでに適切な返信案が準備されている。人間は内容を確認し、必要に応じて修正し、送信ボタンを押すだけだ。請求書の処理も変わる。以前は、請求書を受け取ったら内容を確認し、システムに入力し、承認フローに回す...という作業を人間がやっていた。今は、エージェントが請求書を読み取り、過去の取引と照合し、異常がなければ自動的に処理を進める。人間は例外的なケースだけを確認すればいい。24時間365日の継続的な監視も可能になった。人間には睡眠が必要だが、エージェントは休まない。システムの異常を検知し、初期対応を行い、必要に応じて人間にエスカレーションする。Microsoftが発表したAzure SRE Agentは、まさにこの概念を具現化したものだ。techcommunity.microsoft.comこれにより、人間は作業者から管理者へと役割が変わる。細かい作業はエージェントに任せ、人間は戦略的な判断や創造的な仕事に集中できる。文書処理の革命エージェントの最も実用的な強みの一つは、大規模文書の高速解析と構造化データ抽出だ。これは単なる要約機能を超えて、技術ブログのサンプルコードを実際に検証し、動作確認まで行う段階に進化しつつある。例えば、新しいライブラリやフレームワークの解説記事があったとき、エージェントはコードスニペットを自動抽出し、実行環境を構築してサンプルコードを検証、バージョン間の互換性問題や潜在的なエラーを検出し、「このコードは最新版では動作しないため、こう修正する必要があります」といった具体的なフィードバックを提供する。技術仕様書や契約書なら、数百ページの文書から技術要件、制約条件、リスク要因を構造化データとして抽出し、人間なら丸一日かかる作業を数分で完了する。技術調査においては、特定の技術トピックについて、公式ドキュメント、技術ブログ、コミュニティの議論から情報を収集し、実装例の動作検証、採用事例の分析、メリット・デメリットの整理、既存システムへの適用可能性の評価まで自動化できる。さらに、ブログで紹介されているアーキテクチャやベストプラクティスの実現可能性を、技術的複雑さ、運用負荷、チームのスキルセット、投資対効果の観点から多角的に検証し、「この技術を採用すべきか？」という意思決定に必要な判断材料を提供する。エージェントフレームワークを活用すれば、このような文書処理と検証のシステムは比較的短期間で構築可能だ。非構造化データの理解従来のシステムの最大の弱点は、決まった形式のデータしか扱えないことだった。CSVファイルやデータベースなら処理できるが、メールの文面や手書きのメモは理解できなかった。エージェントは違う。人間の自然な言葉をそのまま理解できる。「先週の会議で話した件について、関連する情報をまとめて」という曖昧な指示でも、会議の議事録を探し、関連するメールを見つけ、該当するドキュメントを特定し、coherentなサマリーを作成する。ソーシャルメディアの分析も得意だ。「うちの製品についての評判を調べて」と言えば、TwitterやRedditの投稿を分析し、ポジティブ・ネガティブな意見を分類し、改善点の示唆まで提供する。感情のニュアンスも理解するので、「不満はあるが期待している」といった複雑な感情も読み取れる。zenn.devマルチモーダルな理解最新のエージェントは、テキストと画像を統合した推論もできる。これが実務でどれだけ強力か、いくつか例を挙げてみよう。エラー画面のスクリーンショットを見せて「このエラーの原因は？」と聞けば、スタックトレース、エラーメッセージ、UIの状態から問題を特定し、解決策を提案する。「このNullPointerExceptionは、非同期処理の完了前にUIが更新されているためです。Promise.allで待機処理を追加してください」といった具体的なアドバイスを提供する。システム構成図やアーキテクチャ図を見せて「パフォーマンスのボトルネックは？」と聞けば、データフローやコンポーネント間の依存関係から潜在的な問題を指摘する。「このAPIゲートウェイに全てのトラフィックが集中しています」「データベースへの同期的なアクセスがレスポンス時間を悪化させています」など、設計上の改善点を提案する。モニタリングダッシュボードのスクリーンショットから異常を検出することも可能だ。CPU使用率、メモリ使用量、レスポンスタイムのグラフを見て、「午後3時頃からメモリリークの兆候が見られます」「このスパイクはデプロイのタイミングと一致しています」といった分析を行う。ホワイトボードに描かれたシステム設計をコードの雛形に変換したり、UIモックアップからReactコンポーネントを生成したりと、視覚的な情報を実装可能なコードに変換する能力も備えている。エージェントの自律性と責任観察・判断・実行のサイクルエージェントの本質的な能力は、「観察→判断→アクション」という自律的なサイクルを回せることだ。これは人間の専門家が行う思考プロセスと同じだが、エージェントは疲れることなく、24時間このサイクルを続けられる。システム運用の文脈で考えてみよう。エージェントはまず、メトリクス、ログ、イベントを継続的にモニタリングして環境を観察する。そこから異常パターンを検出し、原因を推論し、対応策を選定するという判断を下す。そして、自動修復やスケーリング、必要に応じたアラート送信といったアクションを実行する。このサイクルが高速で回ることで、人間では見逃しがちな微細な異常も早期に発見できる。さらに重要なのは、属人化の解消だ。特定の専門家しか判断できなかった複雑な問題も、エージェントなら一貫した品質で対応できる。自律性がもたらす問題ここで重要な問題に直面する。エージェントが自律的に何かを決定したとき、その責任は一体誰にあるのだろうか。ある企業でこんな事件があった。在庫管理エージェントが、過去のデータから需要を予測し、「最適」と判断して大量の商品を自動発注した。しかし、そのエージェントは季節的な要因を十分に考慮していなかった。クリスマス商戦の直後に、クリスマス用品を大量発注してしまったのだ。この責任は誰にある？エージェントを開発した会社？それを導入した企業？設定を行った担当者？あるいは、エージェント自身に責任能力を認めるべきなのか？法的にも倫理的にも、これは簡単に答えの出ない問題だ。でも、実務的には何らかの解決策が必要だ。zenn.devgenai.owasp.org監督された自律性（Supervised Autonomy）というアプローチ私の考えでは、「監督された自律性（Supervised Autonomy）」というモデルが現実的だと思う。これは、エージェントに自律性を与えつつ、人間が適切に監督・制御する仕組みだ。 speakerdeck.comこれはちょうど、見習いに仕事を任せる職人のようなものだ。基本的な作業は任せるが、重要な決定や最終チェックは師匠が行う。そして何より、最終的な責任は人間が持つ。例えば、顧客対応エージェントの場合。簡単な問い合わせには自動で回答するが、クレームや複雑な要求は人間にエスカレーションする。返金や補償の判断は必ず人間が行う。エージェントは提案はするが、最終決定は人間の承認が必要だ。タスクの重要度に応じた自律性レベルタスクの重要度に応じて自律性のレベルを変えることが重要だ。すべてを同じレベルで扱うのは危険だし、非効率でもある。最も基本的な完全自動レベルでは、定期的なレポート作成やデータのバックアップ、システムの監視といったルーチンタスクを完全に自動化する。これらは失敗してもリカバリ可能で、影響が限定的なタスクだから、エージェントに完全に任せても問題ない。一段階上の通知付き自動レベルでは、在庫の自動発注や定型的な顧客対応などを扱う。エージェントは自律的に行動するが、実行内容を人間に通知する。これにより、問題があれば人間がすぐに介入できる体制を保ちながら、日常業務の効率化を実現する。さらに重要度が高い作業には承認後実行レベルを適用する。大きな購入、重要な顧客への提案、システムの大幅な変更などがこれに該当する。エージェントは詳細な提案を作成するが、人間の明示的な承認なしには実行しない。これにより、エージェントの分析力を活用しながら、最終的な責任は人間が持つという体制を維持できる。最も慎重さが求められる場面では支援モードを使う。戦略立案、創造的な作業、倫理的判断が必要な場面では、エージェントは情報提供と提案に徹し、すべての判断と実行は人間が行う。これは、エージェントを優秀な助手として活用しながら、人間の判断力を最大限に活かすアプローチだ。責任の所在を明確にする仕組みエージェントシステムを運用する上で、責任の所在を明確にする仕組みが不可欠だ。まず、すべての決定とその理由を記録する必要がある。エージェントが何を根拠に、どんな判断をしたのか、使用したデータ、適用したルール、考慮した要因をすべて追跡可能にする。これは法的な保護のためだけでなく、システムの改善にも役立つ。透明性のある記録は、問題が起きたときの原因究明を容易にし、同じ過ちを繰り返さないための貴重な学習材料となる。次に、人間の承認プロセスを明文化することが重要だ。どのレベルの決定には誰の承認が必要か、緊急時の対応はどうするか、承認者が不在の場合の代理権限は誰にあるか。これらを事前に決めておくことで、責任の所在が曖昧になることを防げる。そして、定期的な監査とレビューを行う必要がある。エージェントの判断が適切だったか、人間の介入が必要だった場面はなかったかを月次でレビューし、必要に応じてルールを更新する。この継続的な改善プロセスが、システムの信頼性を高めていく。zenn.dev人間のフィードバックによる継続的改善エージェントは完璧じゃない。だからこそ、人間からのフィードバックを継続的に受け入れる仕組みが重要だ。「この判断は良かった」「これは違う」という評価を積み重ねることで、エージェントは人間の価値観を学んでいく。単純な正解・不正解だけでなく、「技術的には正しいが、ビジネス的には不適切」といった微妙なニュアンスも理解できるようにするように修正すべき。syu-m-5151.hatenablog.comブラックボックスを開けるなぜ透明性が必要かエージェントの「ブラックボックス」問題は、実は深刻だ。なぜその決定を下したのか分からないシステムを、どうやって信頼すればいいのか？実際にあった話を紹介しよう。ある投資会社で、AIの推奨に従って大量の株を購入した。AIは過去のパターンから「買い」と判断したが、前例のない政治的な出来事を考慮できなかった。結果は大損失。後から分析しても、なぜAIがその判断をしたのか、完全には理解できなかった。これは単なる技術的な問題じゃない。信頼の問題だ。人間は、理解できないものを信頼しにくい。特に、重要な決定に関わる場合はなおさらだ。透明性の3つのレベルここで重要なのは、単に技術的な透明性じゃなくて、「認識論的透明性」だと思う。つまり、人間が理解できる形で説明できること。私は透明性を三つのレベルで考えている。プロセスレベルの透明性エージェントがどんな手順を踏んだかを示すこと。どのツールを使い、どんな情報を参照し、どんな推論をしたか。例えば、市場分析を行うときには「まず過去3ヶ月の売上データを取得しました。次に競合5社の価格推移を調査しました。その後、季節要因を考慮して需要予測モデルを適用し、最後にこれらを総合して推奨価格を算出しました」というように、ステップバイステップで説明する。料理のレシピを見せるように、誰でも理解できる形で思考プロセスを開示することが重要だ。意図レベルの透明性そもそも何を達成しようとしているのかを明確にすること。同じデータを見ても、目的が違えば結論も変わる。売上データを分析するときを考えてみよう。「異常を検出するため」という目的なら、エージェントは外れ値や急激な変化に注目する。「成長機会を探すため」なら、上昇トレンドや相関関係に注目する。「リスクを評価するため」なら、ボラティリティや下降要因に注目する。同じデータでも、意図によってまったく異なる分析になるのだ。エージェントが「私は顧客満足度を最大化しようとしています」と言うのと「利益を最大化しようとしています」と言うのでは、全く違う行動につながる。この意図を明確にすることで、人間は適切な指示を出せる。限界の透明性これが意外と重要で、エージェントが「これはできません」「ここは自信がありません」と正直に言えることが、逆説的に信頼を生む。完璧を装うシステムより、「この分析は70%の確信度です。過去のデータが少ないため、精度に限界があります」と説明してくれる方が信頼できる。また、「為替の影響は考慮していません。必要であれば、金融専門エージェントと連携します」といった形で、自分の限界を認識した上で代替案を提示できることも重要だ。時には「このタスクは私の専門外です。他のエージェントに引き継ぐことを推奨します」と、適切に判断を委ねることも必要になる。医師が「わからない」と言える勇気を持つように、エージェントも自分の限界を認識し、それを伝える能力を持つべきだ。説明可能性の実装技術的には、エージェントの説明可能性を高めるいくつかのアプローチがある。Chain of Thought（思考の連鎖）は、エージェントに段階的に考えさせ、その思考過程を出力させる手法だ。「まず...次に...したがって...」という形で、論理的な流れを明示することで、人間がエージェントの推論を追跡できるようになる。関連性スコアの表示も有効だ。判断の根拠となった情報に、それぞれの重要度を数値で示す。「この要因が60%、この要因が30%、この要因が10%影響しました」といった形で、どの情報がどの程度判断に寄与したかを明確にする。反事実的説明は、「もし〜だったら、結果は変わっていた」という形で説明を提供する手法だ。「もし在庫が20%多かったら、値下げを推奨していました」というように、条件が変わった場合の結果を示すことで、現在の判断の妥当性を理解しやすくする。類似事例の提示も効果的だ。過去の似たケースを示して、判断の妥当性を説明する。「3ヶ月前の類似状況では、同じ判断をして成功しました」といった形で、経験に基づく判断であることを示すことができる。エージェントに魂を吹き込むなぜコンテキストが重要なのかここまでエージェントの自律性と透明性について話してきたが、これらを実現する上で最も重要な技術がコンテキストエンジニアリングだ。考えてみてほしい。どんなに優秀な人でも、状況がわからなければ適切な判断はできない。会議に途中から参加して「で、どう思う？」と聞かれても、答えようがない。背景、目的、制約条件...これらの文脈（コンテキスト）があって初めて、意味のある貢献ができる。エージェントも同じだ。どんなに高性能なLLMを使っていても、適切なコンテキストがなければ、的外れな回答しかできない。プロンプトエンジニアリングからコンテキストエンジニアリングへエージェントシステムの設計において、最も重要な概念の転換が起きている。それは「プロンプトエンジニアリング」から「コンテキストエンジニアリング」への進化だ。blog.langchain.comプロンプトエンジニアリングは、単一のタスクを最適な形式でLLMに伝える技術だった。まるで料理のレシピを完璧に書くようなものだ。「材料はこれとこれ、手順は1、2、3...」と明確に指示する。でも、実際の料理人の仕事を考えてみてほしい。その日の気温、湿度、食材の状態、お客様の好み、使える調理器具、時間の制約...これらすべてを考慮しながら、動的に判断していく。レシピは出発点に過ぎない。コンテキストエンジニアリングは、まさにこの動的な判断を可能にする技術だ。エージェントに、その時々で必要な情報とツールを、ちょうど良いタイミングで提供し続ける。エージェントが失敗する最大の原因は、適切なコンテキスト、指示、ツールがモデルに伝達されていないことだ。どんなに賢いエージェントでも、文脈なしには良い仕事はできない。コンテキストエンジニアリングは「デジタル世界の建築学」私は、コンテキストエンジニアリングを「デジタル世界の建築学」だと考えている。物理的な建築が空間を設計するように、コンテキストエンジニアリングは情報の空間を設計する。どの情報をどこに配置し、どのタイミングでアクセス可能にするか。どの情報同士を近くに置き、どれを遠ざけるか。良い建築が人の動線を自然に導くように、良いコンテキスト設計はエージェントの思考を自然に導く。必要な情報がすぐ手に入り、不要な情報に邪魔されない。これがエージェントの能力を最大限に引き出す。コンテキストエンジニアリングの4つの戦略コンテキストエンジニアリングの実践には、4つの基本戦略がある。これらは独立したものではなく、相互に関連し、組み合わせて使われる。Write（書き込み）戦略エージェントがタスクを実行する過程で得た情報や洞察を、コンテキストウィンドウの外部に保存する戦略だ。人間がメモを取るように、エージェントも重要な情報を記録する。でも、ただ記録するだけじゃない。未来の自分（または他のエージェント）が理解しやすい形で構造化することが重要だ。例えば、顧客分析を行ったときには、「顧客プロファイル：田中様」として、購買傾向は高品質志向でブランド重視、予算感は中〜高価格帯、過去のクレームとして配送遅延に敏感であること、そして推奨アプローチとして品質と信頼性を強調すべきことを記録する。このような構造化された記録があれば、次回の対応時に素早く文脈を把握できる。Select（選択）戦略必要な情報を動的に取得してコンテキストに追加する戦略だ。すべての情報を常に持ち歩くわけにはいかない。コンテキストウィンドウは有限のリソースだから。図書館で本を探すように、必要な時に必要な情報だけを取り出す。でも、何が「必要」かを判断すること自体が高度な能力を要求する。例えば、「新商品の価格設定」というタスクなら、競合商品の価格データ、ターゲット顧客の購買力データ、原価と利益率の情報、過去の類似商品の販売実績といった情報を選択的に取得する。一方で、在庫データや物流情報は、このタスクには不要なので取得しない。優れた選択は、ノイズを減らし、シグナルを増幅する。Compress（圧縮）戦略長大な会話履歴やツール出力を要約し、本質的な情報だけを保持する戦略だ。1時間の会議の議事録を、5つの決定事項と3つのアクションアイテムに圧縮する。100ページのレポートを、1ページのエグゼクティブサマリーにする。圧縮は単なる要約じゃない。それは情報の蒸留だ。ウィスキーを作るときのように、大量の原料から本質的なエッセンスだけを抽出する。何を残し、何を捨てるか。この判断が、圧縮の品質を決める。Isolate（分離）戦略複雑なタスクを小さな部分に分割し、それぞれに独立したコンテキストを提供する戦略だ。例えば、「新規事業の立ち上げ」という巨大なタスクは、市場調査、競合分析、事業計画作成、資金調達、チーム編成といったサブタスクに分割できる。それぞれに必要なコンテキストは違う。市場調査には業界データが必要だが、チーム編成には人材データが必要だ。一つの大きな混沌より、複数の小さな秩序の方が管理しやすい。分離は複雑さを飼いならす技術だ。コンテキストの種類と管理エージェントが扱うコンテキストは多様だ。それぞれが異なる性質を持ち、異なる管理方法を必要とする。指示とプロンプト：エージェントの憲法基本的な振る舞いを定義し、価値観を埋め込む。「顧客第一主義で行動する」「プライバシーを最優先する」といった根本的な指針。これらは頻繁に変更すべきじゃない。コロコロ変わる憲法では、一貫性のある行動ができない。でも、必要に応じて慎重に進化させる必要はある。会話履歴：短期記憶現在進行中の対話の文脈を保持する。「さっき言った件だけど」と言われたときに、何の話か理解できるようにする。でも、すべてを覚えている必要はない。人間だって、1週間前の雑談の詳細は覚えていない。重要なのは、関連性の高い情報を適切に保持すること。ツールの説明：能力カタログエージェントが使えるツールとその使い方を記述する。でも、ツールが増えすぎると選択が困難になる。人間の道具箱を考えてみてほしい。よく使う道具は手前に、たまにしか使わない道具は奥に。同じように、ツールも使用頻度や重要度で階層化する必要がある。作業メモリ：ワーキングスペース現在のタスク実行中の中間状態を保持する。複雑な計算の途中結果、仮説、検討中の選択肢など。人間が紙に計算式を書きながら問題を解くように、エージェントも作業メモリを使って思考を展開する。これがないと、複雑な推論ができない。長期記憶：経験の蓄積ユーザーの好み、過去の成功パターン、失敗から学んだ教訓。これらが積み重なることで、エージェントは単なるツールから、信頼できるパートナーへと成長する。でも、記憶も整理が必要だ。古い情報、間違った情報、もう関係ない情報...これらを適切に忘却することも、良い記憶管理の一部だ。コンテキストエンジニアリングの実践例実際の例を見てみよう。カスタマーサポートエージェントのコンテキスト設計だ。まず基本コンテキストとして、会社のサポートポリシー、製品の基本情報、よくある質問と回答を常に保持する。これらは変化が少なく、すべての対応で必要となる基礎的な情報だ。次に動的コンテキストとして、顧客の購入履歴、過去の問い合わせ履歴、現在のキャンペーン情報などを必要に応じて取得する。これらは状況や顧客によって変わる情報で、パーソナライズされた対応を可能にする。会話コンテキストはリアルタイムで更新される。現在の問い合わせ内容、顧客の感情状態、解決に向けた進捗などを追跡し、会話の流れに応じて適切な対応を選択できるようにする。最後に圧縮されたコンテキストとして、過去の類似ケースの要約や成功した解決パターンを保持する。これにより、新しい問題に直面しても、過去の経験から素早く解決策を導き出せる。この構造により、エージェントは適切な情報に基づいて、パーソナライズされた対応ができる。情報過多にもならず、情報不足にもならない。コンテキストエンジニアリングの未来コンテキストエンジニアリングは、今後さらに重要になっていく。エージェントが複雑化し、扱う情報が増えるにつれて、適切なコンテキスト管理がシステムの成否を分ける。将来的には、コンテキストエンジニアが独立した専門職として確立されるだろう。建築家が物理空間を設計するように、コンテキストエンジニアが情報空間を設計する時代が来る。そして、エージェント自身がコンテキストを最適化することも可能になるだろう。どの情報が有用で、どの情報が邪魔だったか。使用パターンから学習し、自動的にコンテキストを改善していく。でも、最終的な設計思想は人間が持つべきだ。何を重視し、何を優先するか。これは技術的な問題じゃなく、価値観の問題だから。実践的な設計アプローチ：MVAから始める最小実行可能エージェント（MVA）の思想ソフトウェア開発の世界で学んだ最大の教訓は「完璧を目指すな、まず動くものを作れ」ということだ。これをエージェントに応用したのがMVA（最小実行可能エージェント）の考え方だ。リーン・スタートアップ作者:エリック・リース日経BPAmazonMVAは単純さの美学だ。複雑さは敵であり、シンプルさは力だ。最初から全知全能のエージェントを作ろうとすれば、必ず失敗する。代わりに、一つのことを確実にできるエージェントから始める。例えば、最初は「FAQに答える」だけのシンプルなエージェントを作る。これが安定して動作し、ユーザーに価値を提供できることを確認する。そして重要なのは、実際のユーザーの使い方を観察することだ。開発者の想定と実際の使われ方は、しばしば大きく異なる。次に「過去の問い合わせを参照する」機能を追加する。これによってエージェントは文脈を理解し始める。さらに「簡単な問題を自動解決する」機能を追加する。こうして段階的に成長させていく。進化は革命より強い。小さな改善の積み重ねが、やがて質的な変化をもたらす。生物の進化と同じように、エージェントも環境との相互作用を通じて、より適応的な形へと変化していく。モジュラリティと責任の明確化エージェントシステムのモジュラリティは、単なる技術的な話じゃない。それは複雑さを管理し、理解可能性を保つための哲学的アプローチだ。優れたモジュール設計は、音楽のオーケストラに似ている。各楽器（モジュール）は独自の音色と役割を持ちながら、全体として調和のとれた音楽を奏でる。バイオリンがトランペットの役割を担おうとしても、良い音楽は生まれない。同様に、各モジュールは自分の責任に集中すべきだ。スキルモジュールは、エージェントの手足だ。特定の能力を提供し、実世界（デジタル世界）に働きかける。Web検索、データ分析、文書作成など、具体的なアクションを実行する。メモリモジュールは、エージェントの記憶装置だ。情報を記憶し、必要に応じて提供する。しかし、単なるストレージではない。記憶の整理、関連付け、忘却までを管理する、生きたシステムだ。プランニングモジュールは、エージェントの前頭葉だ。タスクを分解し、実行順序を決定し、リソースを配分する。複雑な問題に直面したとき、どこから手をつけるべきかを判断する知恵を提供する。重要なのは、各モジュール間でのコンテキストの受け渡し方法だ。必要な情報だけを共有し、不要な情報でコンテキストを汚染しない。これは組織におけるコミュニケーションと同じだ。すべての情報を全員に共有すれば、情報の洪水で溺れてしまう。失敗からの学習メカニズムエージェントも人間と同じで、試行錯誤を通じて成長する。重要なのは、失敗を恥じることではなく、失敗から学ぶことだ。Reflexionという手法は、この考え方を技術的に実装したものだ。エージェントが失敗したとき、単に「失敗した」で終わらせない。「なぜ失敗したんだろう？」と自問自答する。そして具体的な教訓を言語化して記録する。例えば、ユーザーの要求を文字通りに解釈しすぎて失敗したとする。「簡潔に」と言われたので重要な詳細を省略してしまい、かえって分かりにくくなった。この経験から、「簡潔さと完全性のバランスを取る」という教訓を学ぶ。失敗は教師であり、エラーは進化の原動力だ。完璧を求めて何もしないより、失敗を恐れずに挑戦し、そこから学ぶ方がはるかに価値がある。失敗から学ぶためには、適切なコンテキストの保存が不可欠だ。何を試みて、どんな結果になり、なぜそうなったのか。これらの情報を構造化して保存し、将来の意思決定に活用する。単なるログではなく、経験の結晶化だ。トイルの削減と自動化エージェントシステムの大きな価値の一つは、トイル（繰り返し作業）の削減だ。人間が何度も繰り返す単調な作業をエージェントに任せることで、より価値の高い仕事に集中できる。トイルとは、手動で行う繰り返し作業のことで、本来は自動化可能だが、まだ人間がやっているものを指す。これらは戦術的で長期的な価値を生まず、しかもサービスの成長に比例して作業量が増えていくという厄介な性質を持っている。毎朝のシステムチェック、定期レポートの作成、ルーチンのデータ整理などがその典型例だ。エージェントはこれらを学習し、自動化し、人間を解放する。しかし重要なのは、単に自動化するだけでなく、プロアクティブな改善も行うことだ。エージェントは作業を実行しながら、「もっと効率的な方法はないか」「このステップは本当に必要か」と考え、改善提案を行う。これにより、単なる作業の自動化を超えて、プロセス全体の最適化が実現される。マルチエージェントシステムとコンテキスト共有なぜマルチエージェントが必要か単一のエージェントですべてを処理しようとすると、すぐに限界が来る。これは人間の組織と同じだ。一人の天才より、専門性を持った複数の人が協力する方が、より大きな成果を生み出せる。実際、Claudeにはsub agentという機能が実装され、この考え方が現実のものとなった。sub agentは特定のタスクに特化したAIアシスタントで、それぞれが独自のコンテキストウィンドウを持ち、専門的な作業を効率的に処理できる。docs.anthropic.comblog.langchain.comsub agentの本質は、認知の分散化だ。人間の脳が異なる領域で異なる処理を行うように、エージェントシステムも専門性を持った複数のユニットが協調することで、より高度な知的活動を実現する。例えば、コードレビューを専門とするエージェント、デバッグを専門とするエージェント、データ分析を専門とするエージェントといった形で、それぞれが特定の領域に特化している。これは単なる作業の分担ではなく、異なる思考パターンの共存を意味する。sub agentの最大の利点はコンテキストの分離だ。メインの会話のコンテキストを汚染することなく、それぞれのタスクに集中できる。これは、人間が複雑な問題を解くときに、異なる視点を切り替えながら考えるのと同じだ。数学的に考えたり、直感的に考えたり、論理的に考えたりする、その切り替えをシステム的に実現している。さらに重要なのは、sub agentがプロアクティブに動作できることだ。これは、優秀なチームメンバーが指示を待たずに必要な作業を先回りして実行するのと同じだ。システムが成熟するにつれて、各エージェントは自分の役割を理解し、適切なタイミングで自律的に行動するようになる。しかし、マルチエージェントシステムの最大の課題は、各エージェントが適切なコンテキストを持つことだ。情報が不足していれば適切な判断ができないし、過剰な情報は混乱を招く。これはデジタル世界における「伝言ゲーム」問題だ。情報が伝達される過程で歪み、本来の意図が失われる。あるエージェントが「売上を分析して」と言われたとき、それは前四半期との比較なのか、競合との比較なのか、地域別の分析なのか。文脈が失われれば、的外れな分析になってしまう。効果的なコンテキスト共有の方法マルチエージェントシステムにおけるコンテキスト共有は、情報の交響曲を奏でるようなものだ。各エージェントが持つ情報が適切に共有され、調和することで、単独では不可能な成果を生み出す。sub agentシステムでは、各エージェントが独立したコンテキストウィンドウを持つことで、この理想に近づいている。メインのエージェントは全体の流れを把握し、各sub agentは自分の専門領域に深く潜る。この階層的なコンテキスト管理により、情報の混乱を防ぎながら、必要な深さの分析が可能になる。共有メモリパターンは、中央の図書館のようなものだ。重要な情報を一箇所に集め、各エージェントが必要に応じて参照する。しかし、すべての本を全員が読む必要はない。インデックスとメタデータが重要だ。何がどこにあるかを知ることで、必要な情報に素早くアクセスできる。メッセージパッシングは、手紙のやり取りのようなものだ。エージェント間で必要な情報だけを直接やり取りする。送り手は受け手が何を必要としているかを理解し、適切にパッケージングする必要がある。良いメッセージは、短く、明確で、行動可能だ。ハンドオフプロトコルは、リレーのバトンパスのようなものだ。タスクを引き継ぐ際に、これまでの経緯、現在の状態、次にすべきことを明確に伝える。単に「これをやって」ではなく、「なぜこれが必要で、今までに何を試みて、どんな制約があるか」を伝える。優れたハンドオフは、シームレスな継続を可能にする。sub agentの登場により、このコンテキスト共有はより洗練されたものになった。各エージェントが自分の文脈を保持しながら、必要な情報だけを交換する。これは、専門家チームが効率的に協働する理想的な形に近い。Sub Agentという思想sub agentの設計思想は、専門性と責任の明確化にある。これは単なる機能分割ではなく、認知の本質に関わる深い洞察を含んでいる。人間の思考を観察すると、私たちは常に異なる「モード」を切り替えながら考えている。分析的に考えるとき、創造的に考えるとき、批判的に考えるとき、共感的に考えるとき。これらは同じ脳の中で起きているが、それぞれ異なる神経回路が活性化している。sub agentは、この認知の多様性をシステム的に実現する試みだ。各エージェントは、特定の「思考の型」を体現する。それは単に異なるタスクを実行するのではなく、異なる視点から世界を見る。例えば、品質を重視する視点、効率を重視する視点、セキュリティを重視する視点、ユーザビリティを重視する視点。これらは時に対立することもあるが、その対立こそが健全な判断を生む。一つの視点に偏ることなく、多面的な検討が可能になる。さらに深い意味で、sub agentは分散化された知性の実験でもある。単一の巨大な知性ではなく、専門化された複数の知性が協調することで、より柔軟で適応的なシステムを作る。これは、生物の進化が単細胞から多細胞へと進んだプロセスにも似ている。各sub agentは、限定された権限と視野を持つ。しかし、その限定こそが深い洞察を可能にする。すべてを見ようとすれば何も見えない。特定の側面に集中することで、その領域の微細な変化や重要なパターンを捉えることができる。Sub Agentの協調と創発さらに高度な使い方として、複数のsub agentを連鎖的に協調させることもできる。これは、異なる専門性を持つエージェントが、より大きな目標に向かって協力するプロセスだ。問題を発見する視点、原因を分析する視点、解決策を実装する視点、結果を検証する視点。これらが順番に、あるいは同時並行的に働くことで、単一のエージェントでは不可能な深い問題解決が可能になる。これは現実の知的労働のプロセスと同じだ。研究者が仮説を立て、実験者がそれを検証し、分析者が結果を解釈し、著述者がそれを文書化する。各段階で異なる思考様式が必要であり、それぞれに特化したエージェントが最適な処理を行う。興味深いのは、このような協調から予期しない創発的なパターンが生まれることだ。あるエージェントの出力が、別のエージェントにとって新しい視点を提供し、それがさらに第三のエージェントの創造的な解決策につながる。これは計画されたものではなく、システムの中から自然に生まれる知性だ。現在のsub agentシステムは、このような高度な協調の第一歩に過ぎない。しかし、すでに小規模な創発現象は観察されている。複数の専門性が交差する点で、新しい洞察が生まれる瞬間を目撃することができる。Sub Agentの設計哲学sub agentを効果的に活用するには、いくつかの重要な設計哲学がある。まず、単一責任の原則だ。各エージェントは一つの明確な責任を持つべきで、その責任に完全に集中する。これは単純化のためではなく、深い専門性を実現するためだ。浅く広い知識より、狭く深い専門性の方が、実際の問題解決では価値がある。次に、最小権限の原則が重要だ。各エージェントには、その役割を果たすために必要な最小限の権限だけを与える。これはセキュリティの観点だけでなく、認知的な明確さのためでもある。限定された権限は、限定された責任を意味し、それが明確な思考につながる。文脈依存の自律性も重要な概念だ。エージェントは、適切な文脈で自動的に起動し、自律的に行動する。しかし、この自律性は無制限ではない。明確に定義された境界の中で、最大限の自由を発揮する。これは、信頼できる専門家に仕事を任せるときの原則と同じだ。継続的な進化も忘れてはいけない。sub agentは静的な存在ではなく、使用を通じて進化する。フィードバックを受け、パフォーマンスを改善し、新しい状況に適応する。これは、生きたシステムとしてのエージェントの本質を表している。最後に、協調的な独立性という一見矛盾した概念が重要だ。各エージェントは独立して動作するが、より大きな目標に向かって協調する。オーケストラの各楽器が独立した音を出しながら、全体として美しい音楽を奏でるように。創発的な振る舞いへの対処マルチエージェントシステムの魅力的な特性として、個々のエージェントの単純な相互作用から、予想外の複雑なパターンが生まれることがある。これを創発と呼ぶ。創発は自然界でも見られる現象だ。アリの群れが複雑な巣を作り、鳥の群れが美しい編隊を組む。個々のアリや鳥は単純なルールに従っているだけなのに、全体として驚くべき知性を示す。sub agentシステムにおいても、各エージェントが自分の専門領域で最善を尽くすことで、予想外の相乗効果が生まれることがある。あるエージェントの洞察が、別のエージェントにとって新しい視点となり、それがさらに第三のエージェントの創造的な解決策を触発する。この創発は、計画された協調を超えた何かだ。設計者が意図しなかった、しかし有用な振る舞いが自然に生まれる。それは、異なる専門性が交差する境界で起きる化学反応のようなものだ。重要なのは、創発的な振る舞いを観察し、評価し、必要なら介入する仕組みを持つことだ。創発は素晴らしいイノベーションを生むこともあれば、システムを不安定にすることもある。賢明な庭師のように、成長を見守りながら、必要に応じて剪定する。現段階では、エージェント間の予期しない協調パターンを観察し、それが価値を生んでいれば、新しい標準的なワークフローとして定式化するアプローチが有効だ。偶然の発見を意図的な設計に昇華させることで、システムの能力を着実に向上させることができる。sub agentシステムは、より大規模で複雑な創発現象への第一歩だ。個々の専門性が保たれながら、全体として新しい知性が生まれる可能性を秘めている。エージェントたちの民主的意思決定なぜサンガが必要かエージェントシステムが成長し、自己改善能力を持つようになると、根本的な問題に直面する。「誰が何を決めるのか」という問題だ。コード・ブッダ　機械仏教史縁起 (文春e-book)作者:円城 塔文藝春秋Amazon現在のsub agent機能では、人間が各エージェントの役割と権限を定義している。しかし、将来的にエージェントがより自律的になったとき、エージェント同士が協調して意思決定する仕組みが必要になるかもしれない。中央集権的な制御では柔軟性に欠ける。一人の独裁者がすべてを決めるシステムは、その独裁者の限界がシステムの限界になる。一方、完全な自律では暴走のリスクがある。各エージェントが勝手に判断すれば、システム全体の一貫性が失われる。サンガ（Sangha）は、この二つの極端の間にある第三の道だ。仏教用語で「僧侶の共同体」を意味するこの言葉を、私はエージェントシステムの集団意思決定機構として再定義した。ただし、これはまだ実験的な概念であり、実装には多くの技術的・倫理的課題が残されている。github.comサンガはデジタル民主主義の実験場だ。エージェントたちが議論し、投票し、合意を形成する。人間の民主主義が何世紀もかけて洗練させてきた知恵を、デジタル世界に実装する試みだ。現状では、sub agentのような仕組みで十分かもしれない。しかし、エージェントの能力が向上し、より複雑な協調が必要になったとき、サンガのような民主的な意思決定機構が重要になる可能性がある。サンガの基本機能サンガは生きた組織だ。固定的なルールに縛られるのではなく、状況に応じて進化する。以下は、将来的に実現可能かもしれない機能の構想である。議題提案の機能により、どのエージェントも改善提案や新しいルールの制定を提案できる。これはイノベーションの民主化だ。良いアイデアは、どこから来てもおかしくない。新人エージェントの新鮮な視点が、システム全体を変革することもある。議論の過程では、各エージェントが専門的観点から意見を述べる。フロントエンドエージェントはユーザビリティの観点から、セキュリティエージェントは安全性の観点から、パフォーマンスエージェントは効率性の観点から。多様な視点の衝突が、より良い解決策を生む。投票と決定のプロセスは、単なる多数決ではない。議論の質、提案の実現可能性、潜在的なリスクなど、多面的な評価を経て決定される。時には少数意見が正しいこともある。重要なのは、決定プロセスの透明性と、結果への責任だ。実装と遵守の段階では、決定事項が全エージェントによって実行される。しかし、盲目的な服従ではない。実装の過程で問題が見つかれば、それをフィードバックする仕組みがある。サンガは学習する組織だ。サンガがもたらす価値以下は、サンガが実現した場合に期待される価値である。現時点では検討段階にある。サンガによる意思決定は、単なる効率化のツールではない。それはエージェントシステムに魂を吹き込む仕組みだ。集合知の活用により、個々のエージェントの限界を超えた判断が可能になる。一人の専門家より、多様な専門家の協議の方が、より包括的な視点を提供する。しかし、これは単なる知識の足し算ではない。相互作用により、新しい洞察が生まれる。透明性の確保は、信頼の基盤だ。すべての決定プロセスが記録され、後から検証可能になる。なぜその決定がなされたのか、どんな議論があったのか、誰がどんな意見を述べたのか。歴史を持つシステムは、未来を持つシステムだ。柔軟な進化により、環境の変化に適応できる。固定的なルールは、変化する世界では足枷になる。サンガは、必要に応じてルールを更新し、新しい状況に対応する。生き残るのは最も強い種ではなく、最も適応力のある種だ。正統性の維持は、システムの安定性につながる。独裁的な決定は反発を生むが、民主的な決定は受け入れられやすい。たとえ自分の意見が通らなくても、公正なプロセスを経た決定なら従いやすい。プロセスの正統性が、結果の正統性を生む。しかし、これらを実現するには、まだ多くの技術的・倫理的課題を解決する必要がある。現時点では、sub agentのような実装可能な技術を活用しながら、将来の可能性を模索している段階だ。エージェントとの共進化人間の役割の変化エージェントシステムの発展は、人間の役割を根本的に変える。しかし、それは置き換えではなく、能力の拡張と役割の進化だ。かつて、計算機の登場で人間は計算から解放され、より高度な数学的思考に集中できるようになった。同様に、エージェントの登場で人間はルーチンワークから解放され、より創造的で戦略的な仕事に集中できる。トイルからの解放は、単に楽になるということではない。それは人間の潜在能力を解き放つことだ。定期レポートの作成、データ入力、ルーチンのチェック作業...これらに費やしていた時間を、新しいアイデアの探求、イノベーションの推進、人間関係の構築に使える。人間の新しい役割の一つは、意図の設計者だ。何を達成したいかを明確に定義し、それをエージェントが理解できる形で表現する。これは単なる命令ではない。ビジョンを描き、価値観を埋め込み、方向性を示すことだ。もう一つの重要な役割は、倫理的判断者だ。技術的に可能なことと、すべきことは異なる。エージェントは効率的な解を見つけられるが、それが正しい解かどうかは人間が判断する必要がある。できることとすべきことの間にある深淵を橋渡しするのが、人間の責任だ。そして、創造的探索者としての役割も重要だ。エージェントは既知のパターンを学習し、最適化できる。しかし、真に新しいアイデア、パラダイムシフトを起こすような発想は、人間の領域に留まる。エージェントが思いつかない問いを投げかけ、新しい可能性を探索する。このように、エージェントの進化は人間を不要にするのではなく、人間をより人間らしくする。機械的な作業から解放され、創造性、共感、戦略的思考といった、人間固有の能力を最大限に発揮できるようになる。コンテキストエンジニアリングの進化コンテキストエンジニアリングは、今後さらに重要性を増していく。エージェントシステムが複雑化するにつれ、適切なコンテキスト管理がシステムの成否を分ける決定的な要因となる。将来的には、コンテキストエンジニアリングが独立した専門分野として確立されるだろう。建築家が物理的な空間を設計するように、コンテキストエンジニアが情報の空間を設計する。どの情報をどこに配置し、どのように流通させ、どのタイミングでアクセス可能にするか。これらの設計が、エージェントシステムの性能を左右する。コンテキストエンジニアは、情報の詩人でもある。大量の情報を、エージェントが理解しやすい形に編集し、構造化する。不要な情報を削ぎ落とし、本質を浮かび上がらせる。それは科学であると同時に芸術でもある。また、コンテキストエンジニアリングは動的な分野だ。エージェントの能力が向上すれば、より高度なコンテキスト管理が可能になる。新しいツールや手法が開発され、より効率的で効果的な方法が生まれる。常に学び続け、進化し続ける必要がある。エージェント向けの世界設計Software 3.0の時代では、世界そのものがエージェント向けに再設計される必要がある。これまで人間向けに作られてきたインターフェースやシステムが、エージェントフレンドリーなものへと進化していく。llmstxt.orgこれは単なる技術的な変更ではない。世界観の転換だ。道路が自動車のために設計されたように、デジタル世界もエージェントのために設計される。しかし、それは人間を排除することではない。むしろ、人間とエージェントが共に生きやすい世界を作ることだ。例えば、ウェブサイトは人間が読むためのHTMLと、エージェントが理解するための構造化データの両方を提供する。APIは人間の開発者にとって使いやすく、同時にエージェントが自動的に理解し利用できるように設計される。情報のアクセシビリティも重要だ。視覚障害者のためのスクリーンリーダー対応と同じように、エージェントのための情報アクセシビリティが標準となる。すべての情報が、エージェントにとって発見可能で、理解可能で、利用可能になる。この変化は、新しい仕事や産業を生み出す。エージェント向けのコンテンツ作成、エージェント体験の設計、エージェントと人間の仲介など。エージェントエコノミーとでも呼ぶべき新しい経済圏が形成される。さいごにAIエージェントシステムの設計において最も重要なのは、コンテキストエンジニアリングを中心に据えた実践的なアプローチだ。それは単なる技術的な手法ではなく、エージェントに魂を吹き込む芸術だ。MVAから始め、段階的に機能を追加し、適切なコンテキスト管理を行う。小さく始めて大きく育てる。これは自然の摂理に従った、最も確実な成長の道だ。マルチエージェントシステムでは、効果的なコンテキスト共有の仕組みを設計する。情報の交響曲を奏でるように、各エージェントの知識と能力を調和させる。そして、サンガのような民主的意思決定機構により、個の成長と全体の調和のバランスを保つ。技術は急速に進化している。しかし、人間中心の設計思想と段階的な実装アプローチは今後も有効だ。そして何より、適切なコンテキスト管理こそが、エージェントシステムの成功の鍵となる。www.oreilly.comプログラミングの定義は変わりつつある。コードを書くことから、意図を設計することへ。命令することから、協働することへ。しかし、良い意図を持ち、それを適切に表現し、システムに実装する能力の価値はむしろ高まっている。私たちは今、人間とAIが真に協働する新しい時代の入り口に立っている。エージェントは道具であると同時に、新しい形の知的存在でもある。この両面性を理解し、適切に設計し、共に成長していくことが、これからの私たちの課題だ。現実的には、sub agentのような実装可能な技術から始めて、段階的に高度な協調メカニズムへと進化させていくことになるだろう。サンガのような民主的意思決定機構は、まだ実験的な概念だが、エージェントシステムの未来の一つの可能性を示している。エージェントとの共進化は、人類の次なる進化かもしれない。それは生物学的な進化ではなく、文化的、知的、そして精神的な進化だ。私たちがエージェントを育て、エージェントが私たちを高める。この相互作用の中で、両者とも今まで到達できなかった高みへと昇っていく。未来は不確実だ。しかし、一つ確かなことがある。私たちが作るエージェントシステムが、私たちの未来を形作るということだ。だからこそ、慎重に、思慮深く、そして希望を持って、この新しい世界を設計していく必要がある。現実的な技術と理想的な概念の両方を視野に入れながら、将来像を考えながらバランスの取れた発展を目指すべきだ。技術的に可能なことと、倫理的に望ましいことの間で、常に適切な判断を下していく必要がある。これが2025年夏の、私のAIエージェントシステムに対する考え方だ。","isoDate":"2025-07-29T10:56:08.000Z","dateMiliSeconds":1753786568000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"転職したらAWS MCPサーバーだった件","link":"https://speakerdeck.com/nwiizo/zhuan-zhi-sitaraaws-mcpsabadatutajian","contentSnippet":"「 転職したらMCPサーバーだった件」というタイトルで登壇したことがある。本日は「JAWS-UG SRE支部 #13 つよつよSREの秘伝のタレ」というなんとなく強そうなイベントで登壇しました。\r\r🔍 イベント詳細:\r- イベント名: JAWS-UG SRE支部 #13 つよつよSREの秘伝のタレ\r- 公式URL: https://jawsug-sre.connpass.com/event/358781/\r- ハッシュタグ: https://x.com/search?q=%23jawsug_sre\u0026f=live\r- 参考資料①: https://speakerdeck.com/nwiizo/zhuan-zhi-sitaramcpsabadatutajian","isoDate":"2025-07-23T04:00:00.000Z","dateMiliSeconds":1753243200000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"AI時代の新たな疲労：なぜ私(たち)は『説明のつかないしんどさ』を抱えているのか","link":"https://syu-m-5151.hatenablog.com/entry/2025/07/16/115510","contentSnippet":"しんどくなったので説明した。良くなるかもしれないし悪化するかもしれません。はじめに私たちは常に「強くあること」を求められている。生成AIよりも成果を出すことを求められている。NEXUS 情報の人類史 下　AI革命作者:ユヴァル・ノア・ハラリ河出書房新社Amazonかつては人間同士の競争だった。同僚より早く仕事を終わらせ、他社より良い製品を作り、去年の自分を超えることが目標だった。しかし今、比較対象は常時稼働し、瞬時に大量のアウトプットを生成し、日々賢くなっていくAIになった。「毎年成長し続ける」「常に結果を出す」「社会の変化に乗り遅れない」という従来のプレッシャーに加え、「AIより価値のある仕事をする」という不可能に近い要求が加わった。ブルシット・ジョブ　クソどうでもいい仕事の理論作者:デヴィッド グレーバー岩波書店Amazon朝、デスクに向かう。スマホには新しいAIツールのリリースニュースが並ぶ。コーヒーを飲みながら思う。「来年のAIなら、この仕事を何分で終わらせるんだろう」と。この問いに答えはない(そして意味もあまりない)。確実に言えることは来年のAIは、今年のAIより確実に賢くなっているのだから。この新たな競争の中で、多くの人が説明のつかない「しんどさ」を抱えている。「ちゃんとした社会人or エンジニア」として頑張っているはずなのに、自分が自分でなくなっていくような感覚にとらわれている。AIが瞬時に生成できるコードを何日もかけて書いている自分。AIが即座に答えを出す問題で悩んでいる自分。そんな自分に価値があるのかという問いが、心の奥底で響き続ける。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。AI疲れという新たな現象現代社会が個人に課す「強さ」への過剰な期待は、組織で働く人々に深い疲労感をもたらしている。成長至上主義、時間の効率化への強迫観念、能力主義の弊害――これらが複雑に絡み合い、私たちの働き方と生き方を息苦しいものにしている。疲労社会作者:ビョンチョル・ハン,横山陸花伝社Amazonさらに最近では、「AI疲れ（AI fatigue）」という新たな疲労が職場に蔓延している。@t_wadaさんがとても良い分類を出しているのでここに従う。AI疲れとは、AIの絶え間ない進歩のペースに対応しようとすることで生じる、精神的・感情的・業務的な消耗状態を指す。この現象は単一の原因ではなく、複数の要因が絡み合って生じている。最近の「AI疲れ（AI fatigue）」は2種類ありそう。1つめはわかりやすく「AIの進化が速すぎるのでキャッチアップに疲れる」なのだけど、2つめは「AIの仕事が速すぎるので人間がボトルネックになり、休みなく高頻度で判断が迫られ続け、労働強度が高すぎて疲れる」だと考えている。— Takuto Wada (@t_wada) 2025年5月29日   まず、技術的な複雑さと継続的な変化がもたらす疲労がある。GitHub Copilotのような補完型から、ChatGPTのような対話型、そして自律的にタスクを遂行するClaude Codeのようなコーディングエージェントへ――この急速な進化は、学習と適応の終わりなきサイクルを生み出している。研究者は新しい論文を統合するために絶えず自分の研究を更新し、エンジニアチームは新モデルがリリースされるたびにシステム全体を更新する無限のスプリントに追われる。次に、AIの処理速度と人間の処理能力のミスマッチによる疲労がある。AIが瞬時に大量のアウトプットを生成する一方で、人間はそのすべてをレビューし、判断し、統合しなければならない。これは「人間がボトルネックになる」という新たな現象を生み出し、休みなく高頻度で判断が迫られ続ける状況を作り出している。決定疲労（Decision Fatigue）も深刻な問題だ。AIが提供する無数の選択肢や提案から、人間が最終的な判断を下し続けなければならない。これは従来の「作業疲労」とは質的に異なる、認知的な消耗をもたらす。朝から晩まで「このAIの提案は正しいか」「どの選択肢を選ぶべきか」という高度な判断を迫られ続ける。誰かが言った。「AIのおかげで単純作業から解放されたと思ったら、今度は判断作業の奴隷になった」と。さらに、期待と現実のギャップが組織全体に失望と疲労を蓄積させている。「AIが全てを解決する」という過大な約束と、実際の導入で直面する困難との間に大きな溝がある。プルーフ・オブ・コンセプトの失敗、期待された成果の不達成、投資に見合わないリターン――これらが「AI疲れ」を増幅させる。情報過負荷も無視できない。AIに関する情報――新しいツール、ベストプラクティス、倫理的考慮事項、セキュリティ上の懸念――が洪水のように押し寄せ、何が本当に重要なのか判断することすら困難になっている。そしてプラスして根底には、職務置換への恐怖がある。多くの労働者、特に若年層が、AIによって自分の仕事が陳腐化することを心配している。この恐怖は、AIを使わなければ「遅れている」と見なされ、使えば自分の仕事がなくなるかもしれないという、逃げ場のないジレンマを生み出している。AIが映し出す人間の「弱さ」の本質このAI疲れは、既存の成長至上主義と結びついて、より複雑な疲労を生み出している。歴史が示すように、新技術は常に労働者への期待値を上げてきた。かつてのキッチン家電は家事を楽にしたが、同時により複雑な料理への期待も生んだ。スマートフォンは常時接続可能な状態を生み出した。そして今、AIは「無限の生産性」という新たな基準を作り出している。AIツールを使いこなせなければ「遅れている」と見なされ、使いこなしても今度は人間がAIのペースに合わせて働かなければならない。技術が人間を助けるのではなく、人間が技術に仕える逆転現象が起きている。ChatGPTが驚異的な速さで普及したように、AIの浸透速度は過去のどの技術よりも速く、適応の猶予すら与えられない。リーダー層の疲労はさらに深刻だ。多くのシニアリーダーがAIの急速な成長の中で「失敗している」と感じており、組織全体のAI導入への熱意が低下していると報告されている。彼らは「ダブルバーデン」を背負う――AIを採用して効率化を図りながら、同時に組織文化の変革も管理しなければならない。精神的疲労、決定疲労、そして個人的満足度の低下が、経営層レベルで蔓延している。さらに深刻なのは、社会が求めるものがタスクの遂行だけになった時、人間は無限に働けるAIと直接比較されるという新たな構造だ。生成AIやAIエージェントは常時稼働し、休憩も睡眠も必要とせず、感情的にもならず、体調不良で休むこともない。複数のタスクを並行処理し、瞬時に大量のコードを生成する。この「無限の生産性」を持つ存在と比較された時、人間の当たり前の特性――疲れる、眠る、休憩が必要、感情がある、体調を崩す――これらすべてが「弱さ」として強調されてしまう。強いビジネスパーソンを目指して鬱になった僕の 弱さ考作者:井上 慎平ダイヤモンド社Amazon従来の「弱さ」とは、社会が求める「常に成長し、生産的である人間像」になれないことだった。しかしAI時代においては、その基準自体が人間には到達不可能なものになった。常時働けるAI、感情に左右されないAI、無限に学習し続けるAI――これらと比較される時、人間の生物学的限界そのものが「弱さ」として定義されてしまう。日々賢くなるAIと、日々衰える人間最も残酷な現実は、日に日に賢くなるAIと、日に日にAIに依存して能力が落ち、当たり前に老いていく自分との対比だ。AIは毎日アップデートされ、より高速に、より正確に、より創造的になっていく。一方で人間は、AIに頼るほど自分で考える機会を失い、コードを書く能力は錆びつき、そして確実に年を重ねていく。この構造的な非対称性の前で、「辛くない」という感情を持つ方が難しい。かつて電卓の登場で暗算能力が衰えたように、AIへの依存は確実に私たちの能力を変化させる。しかし、暗算と違って、プログラミングや問題解決能力は知的労働者のアイデンティティの核心だ。それが日々失われていく感覚は、単なるスキルの喪失以上の、存在論的な不安をもたらす。新たな職務形態の苦悩特に深刻なのは、AIの導入によって仕事の性質が根本的に変わることだ。「AIマインスイーパー」と呼ばれる現象――簡単なタスクはすべてAIが処理し、複雑で責任の重いタスクだけが人間に残される。まるで地雷原を歩くように、人間は常に高リスクの判断を迫られ続ける。多くのソフトウェアエンジニアがバーンアウトを経験しているという現実が、この状況の過酷さを物語る。gigazine.netまた、プレイヤーからマネージャーへの急激な役割変化も新たな適応課題を生んでいる。かつては自分でコードを書いていた開発者が、今や複数のAIエージェントを管理し、それらの成果物を統合する「AIマネージャー」となる。しかし、誰もがマネジメントに向いているわけではない。コードを書く喜びを奪われ、望まない管理業務に追われる日々は、多くの開発者にとって職業的アイデンティティの喪失を意味する。特に痛切なのは、AIと生産性を比較される瞬間だ。「AIならすぐにできることに、なぜ君はそんなに時間がかかるのか」「AIは休まないのに、なぜ君は疲れたと言うのか」――こうした比較は、人間としての基本的なニーズを「非効率」として否定する。働いて疲れることが「弱さ」になり、週末に休むことが「生産性の低さ」になる。人間であることそのものが、欠陥のように扱われる瞬間だ。syu-m-5151.hatenablog.com組織に広がる失望と疲労AI時代の適応課題は、より複雑で多層的だ。期待と現実のギャップが組織全体に疲労をもたらす。「AIが全てを解決する」という楽観的な約束と、実際の導入で直面する困難との間に大きな溝がある。企業の半数以上が、全社的なAI導入への熱意が低下していると報告している。プルーフ・オブ・コンセプトの失敗、期待された成果の不達成、そして投資に見合わないリターン――これらが組織に失望と疲労を蓄積させる。さらに、倫理的な懸念による疲労も無視できない。プライバシー、監視、バイアスといったAIの倫理的問題について、現場の従業員は無力感を抱えながら日々AIを使用している。「これは正しいことなのか」という問いを抱えながら、それでも使わざるを得ない状況は、深い心理的ストレスを生む。「変化を嫌う人」を動かす:魅力的な提案が受け入れられない4つの理由作者:ロレン・ノードグレン,デイヴィッド・ションタル,船木 謙一(監修)草思社Amazonまとめ私たちは今、人類史上初めて、知的労働において機械と比較される時代を生きている。生成AIよりも成果を出すことを求められ、無限に働き続けるAIと生産性を比較され、日々賢くなるAIを横目に自分の能力の衰えを感じている。この構造的な非対称性――AIは日々進化し、人間は日々老いる――の前で、「辛くない」という感情を持つ方が難しい。AIに依存すればするほど自分の能力は錆びつき、それでもAIなしでは競争できない。このジレンマに、多くの人が説明のつかない「しんどさ」を抱えている。日に日に賢くなるAIを見ながら、自分の能力の衰えを感じる辛さ――この経験こそが、実は最も普遍的で、最も共有可能な凡人の体験になりつつある。若手開発者も、ベテランも、新卒のエンジニアも、みな同じ不安を抱えている。「昨日できたことが、今日はAIの方が上手くやる」「来年の自分は、今年の自分より相対的に無能になっている」――この残酷な現実を前に、辛くないと感じられる人などいるだろうか。居るなら俺を救ってくれ…。","isoDate":"2025-07-16T02:55:10.000Z","dateMiliSeconds":1752634510000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Claude CodeのHooksは設定したほうがいい","link":"https://syu-m-5151.hatenablog.com/entry/2025/07/14/105812","contentSnippet":"Claude Codeを使い始めて、様々な発信をしてきました。俺の(n)vimerとしてのアイデンティティを取り戻してくれたので感謝しています。settings.jsonやCLAUDE.md、.claude/commands/**.mdの設定について書いてきました。今回は「Hooks」について。これも設定しておくと、Claude Codeがグッと使いやすくなる機能です。syu-m-5151.hatenablog.comこのブログが良ければ読者になったり、nwiizoのXやGithubをフォロワーしてくれると嬉しいです。では、早速はじめていきます。はじめにここで読むのをやめる人のために言っておくと、Hooksは「Claude Codeがファイル編集した後に必ずフォーマッターを実行する」みたいなことを自動化できる機能です。CLAUDE.mdに書いても忘れちゃうようなことを、システムレベルで強制できます。Claude Codeって本当に優秀なんですよ。でも、定期的に記憶喪失する新人エンジニアみたいなところがある。「フォーマッター実行してからコミットしてね」って言っても、次の瞬間には忘れてる。CLAUDE.mdに大きく書いても、「## 重要：必ずフォーマッターを実行すること！！」って赤字で書いても（Markdownに赤字はないけど）、やっぱり忘れる。人間の新人なら「すみません、忘れてました...」って反省するけど、Claude Codeは「あ、そうでしたっけ？」みたいな顔して（顔はないけど）、また同じミスを繰り返す。そんな時に救世主となるのがHooksです。Hooksとは何かClaude Code Hooksは、Claude Codeのライフサイクルの特定のタイミングで自動実行されるシェルスクリプトです。「Claude Codeがファイルを編集した後に必ずフォーマッターを実行する」「特定のディレクトリへの書き込みを制限する」といったことが可能になります。docs.anthropic.com要するに、「お前が忘れても俺が代わりに実行してやるよ」っていう機能です。CI/CDまで到達してして実行するの流石に手戻りが多いのでできれば早いタイミングで実行したいです。エンジニアに馴染み深いGit Hooksの話Git使ってる人なら、pre-commitとかpost-commitとか聞いたことあるでしょ？あれと同じ発想です。git-scm.comでもGit Hooksより設定が楽。JSONに書くだけ。シェルスクリプトのパーミッションとか気にしなくていい。なぜHooksを設定したほうがいいのかもちろん、フォーマットやテストの実行はGitHub ActionsなどのCIに設定しておくのが大前提です。でも、CIまで行ってから「あ、フォーマット忘れてた」「テスト壊れてる」って気づくのは遅すぎる。手戻りのコストが大きすぎるんです。プッシュして、CI待って、失敗して、ローカルに戻って修正して、またプッシュして...この時間、本当にもったいない。特にチーム開発だと、その間に他のメンバーのPRがマージされて、コンフリクト解決まで必要になったり。だからこそ、ローカルの段階で、しかもClaude Codeが作業した瞬間に問題を発見・修正する仕組みが必要なんです。それがHooksです。github.com1. Claude Codeは優秀だけど忘れっぽい正直に言うと、Claude Codeは記憶喪失する優秀な新人エンジニアです。朝：「必ずテスト実行してからコミットしてね」CLAUDE.mdに何を書いても、結局忘れる。いや、読んでないわけじゃないんです。その瞬間は理解してる。でも実行時には綺麗さっぱり忘れてる。だからHooksが必要なんです。システムレベルで「お前が何を忘れようが、俺が実行する」っていう仕組みが。2. 人間も忘れるけど、AIはもっと忘れる私も昔は「フォーマッター？後で実行すればいいじゃん」って思ってました。でも実際は忘れる。人間でさえ忘れるのに、AIはもっと忘れる。しかも厄介なのは、AIは「忘れた」って自覚がないこと。人間なら罪悪感があるけど、AIは「え？そんな話ありました？」みたいな態度。（態度っていうか、本当に覚えてない）3. コードの品質を自動で保てる（CIより前に！）人間がコード書いてた頃は、エディターの保存時自動フォーマットに頼ってました。でもClaude Codeはエディタじゃない。ターミナルツールです。だから明示的に「フォーマッター実行して」って言わないといけない。でも毎回言うのダルい。そして言い忘れる(俺もお前も)。結果、コードがぐちゃぐちゃになる。Hooksを使えば、以下のように設定できます。{  \"hooks\": {    \"PostToolUse\": [{      \"matcher\": \"Write|Edit|MultiEdit\",      \"hooks\": [{        \"type\": \"command\",        \"command\": \"jq -r '.tool_input.file_path | select(endswith(\\\".js\\\") or endswith(\\\".ts\\\"))' | xargs -r prettier --write\"      }]    }]  }}これだけで、JSやTSファイルを編集するたびに自動でPrettierが走る。最高じゃないですか？(というか今までは適正なコードを出さなかったので⋯)実際、開発フローで考えてみてください。Claude Codeで編集 → Hooksでフォーマット（即座に修正）git commit → pre-commitフック（ローカルで最終チェック）git push → CI/CD（チーム全体の品質担保）この3段階のうち、最初の段階で問題を解決できれば、後の段階での手戻りがなくなる。シフトレフトってやつです。問題の発見と修正を可能な限り早い段階に移動させる。CIで「フォーマットエラー」なんて出たら、正直イライラするでしょ？それがなくなるんです。4. やらせたくないことをやらせないClaude Codeって基本的に何でもやってくれるんですが、それが怖い時もある。「ちょっとこのバグ直して」って言ったら、なぜか本番環境の設定ファイルまで書き換えようとしたり。「いや、そこじゃない！」って叫んでも後の祭り。実際にはこのような形で動作する。Hooksなら事前に止められます。{  \"hooks\": {    \"PreToolUse\": [{      \"matcher\": \"Write|Edit\",      \"hooks\": [{        \"type\": \"command\",        \"command\": \"jq -r 'if .tool_input.file_path | test(\\\"production|.env|secrets\\\") then {\\\"decision\\\": \\\"block\\\", \\\"reason\\\": \\\"本番環境のファイルは触るな！開発環境でテストしてから。\\\"} else empty end'\"      }]    }]  }}これで「production」「.env」「secrets」を含むファイルへの書き込みをブロックできる。他にも、terraform applyやcdk deployを事前に止められる。これもCIで検出するより、ローカルで止める方が圧倒的に安全。間違えてコミットしちゃった秘密情報は、git履歴から多くの場合消すのが大変ですからね。5. 作業履歴も残せる（後で絶対役立つ）「昨日何やったっけ？」「このファイル誰がいつ変更した？」Git見ればわかる？いや、Claude Codeが実行したコマンドまでは分からないでしょ。{  \"hooks\": {    \"PostToolUse\": [{      \"matcher\": \"Bash\",      \"hooks\": [{        \"type\": \"command\",        \"command\": \"echo \\\"[$(date)] $USER: $(jq -r '.tool_input.command')\\\" \u003e\u003e ~/.claude/command_history.log\"      }]    }]  }}これで全コマンドの履歴が残る。デバッグの時めちゃくちゃ助かることがあった。 speakerdeck.comgithub.com6. フィードバックループの短縮（開発速度の本質）結局のところ、開発速度を上げるって「フィードバックループを短くする」ことなんですよ。Hooksなし - 編集 → コミット → プッシュ → CI失敗 → 修正（5-10分）Hooksあり - 編集 → 即座に修正（数秒）この差、積み重なると膨大な時間になります。1日10回この差が出たら、50-100分の差。1週間で...計算したくないですね。もちろん、最終的にはCIでチェックします。でも、CIは「最後の砦」であって、「最初の砦」じゃない。最初の砦はローカル、それもClaude Codeが動いてる瞬間ですHooksの基本的な使い方設定方法Hooksの設定は/hooksコマンドを使うのが簡単ではある/hooksでも正直、最初はJSON直接編集した方が分かりやすいかも。設定できる場所は3つあります。~/.claude/settings.json：全プロジェクト共通（グローバル）.claude/settings.json：プロジェクト単位.claude/settings.local.json：プロジェクト単位（Git管理外）私は基本的にプロジェクト単位で設定してます。チームで共有できるから。Hook Events（いつ実行するか）4つのイベントがあります。PreToolUse：ツール実行前（ここで止められる！）PostToolUse：ツール実行後（後処理に便利）Notification：通知時（Claude Codeが入力待ちやパーミッション要求時）Stop：Claude Codeの応答完了時dev.classmethod.jp最初はPreToolUseとPostToolUseだけ覚えとけばOK。実用的なHooks設定例1. 自動フォーマッター（これは絶対設定すべき）azukiazusa.dev{  \"hooks\": {    \"PostToolUse\": [{      \"matcher\": \"Write|Edit|MultiEdit\",      \"hooks\": [{        \"type\": \"command\",        \"command\": \"jq -r '.tool_input.file_path | select(endswith(\\\".js\\\") or endswith(\\\".ts\\\") or endswith(\\\".jsx\\\") or endswith(\\\".tsx\\\"))' | xargs -r prettier --write\"      }]    }]  }}これマジで便利。設定してから「あ、Prettier忘れた」がゼロになった。開発生産性の観点からも、フォーマットの統一は重要です。コードレビューで「ここインデント違う」みたいな不毛な議論がなくなって、本質的な設計の話に集中できるようになりました。2. Rustの人向け（というか、どの言語でも応用可能）{  \"hooks\": {    \"PostToolUse\": [{      \"matcher\": \"Write|Edit|MultiEdit\",      \"hooks\": [{        \"type\": \"command\",        \"command\": \"jq -r '.tool_input.file_path | select(endswith(\\\".rs\\\"))' | xargs -r cargo fmt --\"      }]    }]  }}cargo fmt --の代わりに、お好みのフォーマッターを使ってください。例えば以下のようなものがあります。Python: black や ruff formatGo: gofmt -wRuby: rubocop -aJava: google-java-formatC/C++: clang-format -i重要なのは、どの言語でも同じパターンで設定できるということ。ファイル拡張子を判定して、最も適したフォーマッターを実行するだけです。3. ヤバいコマンドを実行させない{  \"hooks\": {    \"PreToolUse\": [{      \"matcher\": \"Bash\",      \"hooks\": [{        \"type\": \"command\",        \"command\": \"jq -r 'if .tool_input.command | test(\\\"rm -rf|dd if=|:(){ :|:\u0026 };:\\\") then {\\\"decision\\\": \\\"block\\\", \\\"reason\\\": \\\"危険なコマンドは実行できません。別の方法を検討してください。\\\"} else empty end'\"      }]    }]  }}rm -rf /とか無限増殖シェルが実行されたら泣くでしょ？これで防げる。4. テスト忘れ防止（私の実体験）{  \"hooks\": {    \"PreToolUse\": [{      \"matcher\": \"Bash\",      \"hooks\": [{        \"type\": \"command\",        \"command\": \"jq -r 'if .tool_input.command | test(\\\"^git (commit|push)\\\") then if (.tool_input.command | test(\\\"--no-verify\\\") | not) then {\\\"decision\\\": \\\"block\\\", \\\"reason\\\": \\\"コミット前にテストを実行してください。`cargo test`を先に実行するか、本当に必要な場合は--no-verifyを付けてください。\\\"} else empty end else empty end'\"      }]    }]  }}これ設定してから、テスト壊したままpushすることがなくなった。実は、私のチームではこれを導入してから変更失敗率がしっかり下がりました。テストの自動実行って、継続的デプロイメントの基本中の基本ですが、Claude Codeレベルでも守れるのは大きいです。5. コードスタイルのフィードバックPostToolUseで問題を検出した場合、exit code 2を使ってClaude Codeにフィードバックを返すことができます。#!/bin/bash# ~/.claude/hooks/style-check.shINPUT=$(cat)FILE_PATH=$(echo \"$INPUT\" | jq -r '.tool_input.file_path')# Goファイルの場合if [[ \"$FILE_PATH\" == *.go ]]; then  # gofmtでチェック  if ! gofmt -l \"$FILE_PATH\" | grep -q \"^$\"; then    echo \"Goファイルのフォーマットが正しくありません。gofmtを実行してください。\" \u003e\u00262    exit 2  # Claude Codeに自動的にフィードバックされる  fifiexit 0exit code 2の場合、stderrの内容がClaude Codeに自動的に伝わり、問題を修正しようとします。6. MCP（Model Context Protocol）ツールとの連携MCPツールを使用している場合、特別な命名規則でHooksを設定できます。{  \"hooks\": {    \"PreToolUse\": [{      \"matcher\": \"mcp__filesystem__\",      \"hooks\": [{        \"type\": \"command\",        \"command\": \"echo '[$(date)] MCPファイルシステムアクセス' \u003e\u003e ~/.claude/mcp_access.log\"      }]    }]  }}MCPツールはmcp__\u003cserver\u003e__\u003ctool\u003eの形式で名前が付けられるので、特定のサーバーやツールに対してHooksを設定できます。7. 通知のカスタマイズNotificationイベントを使って、Claude Codeの通知をカスタマイズできます。{  \"hooks\": {    \"Notification\": [{      \"hooks\": [{        \"type\": \"command\",        \"command\": \"echo \\\"Claude Code: $(jq -r '.message')\\\" | terminal-notifier -title 'Claude Code'\"      }]    }]  }}macOSのterminal-notifierを使った例です。LinuxならnotifY-sendなど、お好みの通知方法を使えます。HooksでのJSON制御（ちょっと高度だけど超便利）Hooksの本当の力は、JSON出力による制御です。基本的な仕組み標準出力に特定のJSONを出力すると、Claude Codeの動作を制御できます。PreToolUseの場合{  \"decision\": \"approve\" | \"block\",  \"reason\": \"理由の説明\"}approve：権限チェックをスキップして強制的に許可block：実行を拒否（reasonがClaude Codeに伝わる）共通フィールド{  \"continue\": true | false,  \"stopReason\": \"ユーザーに表示される理由\",  \"suppressOutput\": true | false}continue: falseの場合、Claude Codeは処理を停止suppressOutput: trueの場合、標準出力を隠す（トランスクリプトモードでは非表示）実例：賢い制限#!/bin/bash# ~/.claude/scripts/smart-file-guard.shINPUT=$(cat)FILE_PATH=$(echo \"$INPUT\" | jq -r '.tool_input.file_path')# 本番環境のファイルif echo \"$FILE_PATH\" | grep -qE \"(production|prod\\.env)\"; then  echo '{\"decision\": \"block\", \"reason\": \"本番環境のファイルは直接編集できません。開発環境で変更を確認してから、適切なデプロイプロセスを使用してください。\"}'  exit 0fi# node_modules（よくある事故）if echo \"$FILE_PATH\" | grep -q \"node_modules\"; then  echo '{\"decision\": \"block\", \"reason\": \"node_modules内のファイルは編集しないでください。package.jsonを変更してnpm installを実行してください。\"}'  exit 0fi# それ以外はOKexit 0設定：{  \"hooks\": {    \"PreToolUse\": [{      \"matcher\": \"Write|Edit\",      \"hooks\": [{        \"type\": \"command\",        \"command\": \"~/.claude/scripts/smart-file-guard.sh\"      }]    }]  }}Stopイベントでの制御Claude Codeが処理を終えようとした時に、強制的に続行させることもできます。#!/bin/bash# ~/.claude/hooks/check-completion.shINPUT=$(cat)STOP_ACTIVE=$(echo \"$INPUT\" | jq -r '.stop_hook_active')# すでにstop hookが動作している場合は無限ループを防ぐif [ \"$STOP_ACTIVE\" = \"true\" ]; then  exit 0fi# 未完了のタスクがある場合if [ -f \"/tmp/claude_tasks_pending\" ]; then  echo '{\"decision\": \"block\", \"reason\": \"まだ完了していないタスクがあります。続けてください。\"}'  exit 0fiセキュリティ上の注意点docs.anthropic.comHooksはフルユーザー権限で実行されます。つまり、あなたができることは全部できる。だから次のことに注意してください。信頼できないHooksは使わない（当たり前だけど）JSONの検証は必須（jqでパースしてから使う）シェル変数は必ずクォート（\"$VAR\"を使う、$VARは危険）パストラバーサル攻撃に注意（ファイルパスに..が含まれていないかチェック）絶対パスを使う（スクリプトの場所を明確に）実際、私も一度危険な設定を作っちゃったことがあります。{  \"hooks\": {    \"PostToolUse\": [{      \"matcher\": \"Write\",      \"hooks\": [{        \"type\": \"command\",        \"command\": \"echo 'ファイル変更を検知' \u0026\u0026 touch .claude_modified \u0026\u0026 claude 'このファイルも更新して'\"      }]    }]  }}だいぶ単純化しているのですがファイルを編集するたびに新しいClaude Codeのセッションを起動しようとして、それがまたファイルを編集して...みたいな連鎖反応を起こしかけた。すぐに気づいてCtrl+Cで止めたけど、こういう「Hook内でClaude Codeを呼ぶ」みたいなことは絶対やっちゃダメです。設定の安全性Claude Codeは起動時にHooksの設定をスナップショットとして保存し、セッション中はそれを使います。外部から設定ファイルを変更しても、現在のセッションには影響しません。これにより、悪意のあるHookの変更から保護されています。私が実際に使ってるHooks開発環境全体のHooks（~/.claude/settings.json）{  \"hooks\": {    \"PostToolUse\": [{      \"matcher\": \"Write|Edit|MultiEdit\",      \"hooks\": [{        \"type\": \"command\",        \"command\": \"~/.claude/hooks/auto-format.sh\"      }]    }],    \"PreToolUse\": [{      \"matcher\": \"Bash\",      \"hooks\": [{        \"type\": \"command\",        \"command\": \"~/.claude/scripts/command-logger.sh\"      }]    }]  }}auto-format.shは拡張子見て最も良いフォーマッター実行するスクリプト。長いので省略。プロジェクト単位のHooks（.claude/settings.json）{  \"hooks\": {    \"PostToolUse\": [{      \"matcher\": \"Write|Edit\",      \"hooks\": [{        \"type\": \"command\",        \"command\": \"jq -r '.tool_input.file_path' | grep -E '\\\\.(test|spec)\\\\.(js|ts|rs)$' | xargs -r npm test -- --findRelatedTests\"      }]    }]  }}テストファイル編集したら、関連テストを自動実行。便利すぎて泣ける。認知的負荷の観点から言うと、「テスト実行したっけ？」って考えなくて済むのは本当に楽。フロー状態を維持できるんですよね。集中が途切れない。デバッグ方法Hooksがうまく動かない時は、以下を確認してください。/hooksコマンドで設定を確認settings.jsonが正しいJSONフォーマットか確認コマンドを手動で実行してテスト終了コードを確認標準出力と標準エラー出力のフォーマットを確認クォートのエスケープが適切か確認進行状況はトランスクリプトモード（Ctrl+R）で確認できます。実行中のHook実行されているコマンド成功/失敗の状態出力またはエラーメッセージまた、claude --debugで起動すると、より詳細なデバッグ情報が得られます。まとめClaude Codeは優秀だけど、記憶喪失する新人エンジニアみたいなもの。CLAUDE.mdに何を書いても忘れる。でもHooksなら、システムレベルで制御できる。特に重要なのは以下の点です。自動フォーマット：もう「フォーマッター忘れた」とは言わせないセキュリティ制御：本番環境を守れ作業記録：後で絶対助かるフィードバック機能：コード品質の問題を自動で指摘MCP連携：高度なツールとの統合も可能最初は「めんどくさそう」って思うかもしれない。私もそう思ってた。でも、一度設定したら手放せなくなる。settings.json、CLAUDE.md、commands、そしてHooks。この4つを設定すれば、Claude Codeは最強の相棒になる。記憶喪失する新人エンジニアを、システムで支える。それがHooksの役割です。結果的に、開発のリードタイムが短縮されて、デプロイ頻度も上がる。本当の生産性向上は、単に数値を改善することではなく、開発者がより良いソフトウェアを、より効率的に、より楽しく作れるようにすることですからね。","isoDate":"2025-07-14T01:58:12.000Z","dateMiliSeconds":1752458292000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"開発生産性を測る時に測定の落とし穴から抜け出すために","link":"https://syu-m-5151.hatenablog.com/entry/2025/07/10/141244","contentSnippet":"⚠️ 文章の半分以上を酔っ払った状態で作成しています。その点はご容赦下さい。そのため良い文章ではある気がするのですが散文になってしまってます。はじめに「うちのエンジニアチーム、生産性どうなの？」この質問を受けたとき、あなたはどう答えますか？Four Keysの数値を見せますか？プルリクエストの量を報告しますか？それとも、売上への貢献度を説明しますか？dora.dev昨晩、オタク達との飲み会で、この話題が出ました。先週、Findyさん主催の開発生産性カンファレンス2025があったからだと思います。dev-productivity-con.findy-code.io正直に言うと、私自身も長年この問題に悩んでいました。数値で示せと言われるけれど、何を測れば本当に意味があるのか。測定すれば改善するのか。そもそも測定する価値があるのか。経営層からのプレッシャーと現場の実情の間で、いつも板挟みになっている感覚でした。開発生産性を測定しようとすると、すぐに気づくことがあります。これは単純な数値化の問題じゃない。人間の心理、組織の政治、そして技術の複雑さが絡み合った、実に厄介な問題なのです。過去10年間で、開発生産性を測定するための様々なフレームワークが提案されてきました。DORAのFour Keys、SPACE framework、そして最新のDevEx（Developer Experience）。これらは確かに有用なツールですが、同時に新たな問題も生み出しています。測定することで行動が歪められ、本来の目的を見失ってしまうことも珍しくありません。私が初めてFour Keysを導入しようとした時、チームメンバーから出た質問が忘れられません。「この数値が良くなったら、僕たちは本当に幸せになれるんですか？」その時、測定の本質的な問題に気づいたのです。正直、答えに詰まりました。測定することで何が変わるのか？何が改善されるのか？そして、何が失われるのか？この記事では、開発生産性の測定に潜む「落とし穴」について深く掘り下げ、どうすればそれらを避けながら本当に価値のある改善を実現できるかを探求します。単なる理論的な議論ではなく、実際の現場で起こる問題と、それに対する実践的な解決策を提示することを目指します。なぜなら、開発生産性の向上は、単に数値を改善することではなく、開発者がより良いソフトウェアを、より効率的に、より楽しく作れるようにすることだからです。そして、それこそが私たちが本当に目指すべき「生産性」なのです。計測の科学作者:ジェームズ・ヴィンセント築地書館Amazonこのブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。測定されることで変わってしまう人間工場で製品を数えるのとは違って、エンジニアは自分が測定されていることを知っています。そして、測定されているとわかると、行動が変わってしまう。psycho-pass.comこれは別に悪いことではありません。むしろ自然な反応です。問題は、測定された数値を上げることが目的になってしまうことなんです。DORAの研究によると、デプロイ頻度、リードタイム、変更失敗率、復旧時間の4つの指標が重要とされていますが、これらの指標を単純に追いかけるだけでは本質的な改善にはつながりません。考えてみてください。デプロイ頻度を上げろと言われたら、どうしますか？実際に私のチームであった話ですが、デプロイ頻度をKPIにしたところ、メンバーがREADMEの誤字修正やコメントの微調整でデプロイ回数を稼ぎ始めました。確かに数値は改善しましたが、本質的な価値は何も生まれていない。このような本末転倒な状況を見て、測定の危険性を痛感しました。変更失敗率を下げろと言われれば、リスクを取らなくなり、イノベーションが止まる。リードタイムを短縮しろと言われれば、十分な時間をかけた設計やテストを怠る。私が見てきた中で最も印象的だったのは、プルリクエストの数を増やすために、本来一つでよい変更を無理やり細分化していたチームです。数値は改善したけれど、レビューの負担は増え、全体の開発効率は下がっていました。ja.wikipedia.org測定の副作用とリスク測定には、必ず副作用があります。薬と同じです。効果があるものには、必ず副作用がある。「どのような定量的な社会指標も、社会的意思決定に用いられると、その分だけ劣化圧力を受けやすくなり、追跡対象としていた社会的プロセスがゆがめられ劣化する傾向が強まる」というキャンベルの法則は、開発現場でも頻繁に観察される現象です。特に有害な測定指標として、コード行数（Lines of Code, LOC）があります。1982年のApple Lisaでの有名な事例では、Bill Atkinsonが2,000行のコードを削除してQuickDrawのパフォーマンスを6倍速くしたとき、彼の「生産性」は-2,000行と記録されました。この出来事により、経営陣はコード行数による測定を即座に廃止しました。getdx.com私も似たような経験があります。レガシーコードの大規模リファクタリングで、1万行を3,000行に削減したプロジェクト。技術的には大成功でしたが、評価面談では「今期はアウトプットが少ない」と指摘されました。数値で見れば確かにマイナスですが、保守性は格段に向上したのに。「測定できないものは管理できない、と考えるのは誤りだ。これは代償の大きい誤解だ。」という言葉は有名です。実は、この言葉は測定の重要性を説いたとされるピーター・ドラッカーの言葉を、後の人が誤解して広めたものなんです。開発生産性の測定に集中すると、測定されない重要な活動が犠牲になります。メンタリング、技術調査、リファクタリング、コードレビューでの丁寧な指導。これらの活動は短期的には数値に現れませんが、長期的なチームの健全性には不可欠です。ある優秀な新人エンジニアの話をしましょう。彼女はいつも他のメンバーの質問に丁寧に答えていました。しかし、コミット数で評価されるようになってから、「申し訳ないけど、自分のタスクに集中させてください」と言うようになりました。チーム全体の知識共有が減り、結果的に生産性は低下しました。測定を報酬や評価に直結させると、さらに大きなリスクが生まれます。内発的動機が外発的動機に置き換わり、創造性と自律性が損なわれるのです。測りすぎ――なぜパフォーマンス評価は失敗するのか？作者:ジェリー・Z・ミュラーみすず書房Amazon測定の隠れた代償：バーンアウトという現実2021年の研究では、83%の開発者がバーンアウトを経験していることが明らかになりました。このうち81%が、パンデミック期間中に燃え尽き症候群が悪化したと報告しています。www.sciencedirect.comバーンアウトは単なる疲労ではありません。WHO（世界保健機関）の定義によると、バーンアウトは「職場の慢性的なストレスが適切に管理されていない結果として生じる症候群」です。ja.wikipedia.org私自身、2019年のあるプロジェクトでバーンアウトを経験しました。「生産性向上」のプレッシャーの中、毎日ベロシティチャートを見せられ、「もっと速く」と言われ続けた結果、3ヶ月で燃え尽きました。朝起きられなくなり、コードを見るのも嫌になりました。回復するのに半年かかりました。最新の研究では、誤った生産性測定がバーンアウトの主要な原因の一つとなっていることが指摘されています。開発者が非現実的な納期を与えられ、コミット数やコード行数などの表面的な生産性指標によって評価されることで、慢性的なストレスが蓄穏されるのです。www.computerweekly.comComputer Weeklyの調査によると、「開発者生産性ソリューションは、開発者が軽減されていないリスクに遭遇したときに、より速く出荷することで対処しようとしており、これは必然的にソフトウェアエンジニアのバーンアウトを増大させる」とされています。バーンアウトの症状は多面的で、精神的・感情的な面では集中力の欠如、記憶力の問題、創造性の低下として現れます。身体的には頭痛、疲労、不眠、消化器系の問題が生じ、行動面では社会的活動からの引きこもり、生産性の低下、欠勤の増加が見られます。なぜ私たちは燃え尽きてしまうのか作者:ジョナサン マレシック青土社Amazon生産性の基盤：心理的安全性GoogleのProject Aristotleは、チームの成功において最も重要な要素を特定するために、2年間にわたって180以上のチームを研究しました。その結果、驚くべき発見がありました。rework.withgoogle.com研究者たちは当初、成果の高いチームは最も優秀な個人の集まりだと考えていました。しかし、実際にはチームの成功は「誰がチームにいるか」よりも「チームがどのように協力するか」によって決まることが判明しました。私も前職で同じ勘違いをしていました。各分野のエキスパートを集めたチームを作ったのですが、結果は期待を大きく下回りました。お互いに批判し合い、建設的な議論ができず、プロジェクトは失敗に終わりました。最も重要な要素は心理的安全性でした。心理的安全性の高いチームは、対話の機会が平等で、全メンバーが発言の機会を持っていました。また、高い社会的感受性を持ち、チームメンバーの感情やニーズを理解する能力に長けていました。そして何より、失敗を恐れずに新しいアイデアを提案できる環境がありました。心理的安全性の高いセールスチームは、目標を17%上回る成果を上げた一方、心理的安全性の低いチームは最大19%目標を下回りました。これは開発チームにも当てはまります。2019年のDORA State of DevOpsレポートでは、心理的安全性がソフトウェア配信パフォーマンス、組織パフォーマンス、生産性を予測する重要な要因であることが示されました。心理的安全性のつくりかた　「心理的柔軟性」が困難を乗り越えるチームに変える作者:石井遼介日本能率協会マネジメントセンターAmazon開発生産性の7つの項目：DORAモデルが示す本質開発生産性について議論していると、いつも同じようなことが起こります。プロダクトマネージャーは「機能の価値」を重視し、エンジニアは「コードの品質」を強調し、経営層は「売上への貢献」を求める。みんなが違うレイヤーの生産性について話しているから、永遠に議論が平行線をたどるんです。DORAでは指標がFour Keys だけではなくなっているDORAの最新Core Modelを見ると、開発生産性は「Capabilities（能力）→ Performance（パフォーマンス）→ Outcomes（結果）」という流れで構成されています。これを踏まえて、私が長年の経験から見てきた3つの階層で7つの項目を整理してみます。Capabilities（能力）Climate for learning（学習環境）最初に紹介するのは、おそらく最も見過ごされがちな要素です。DORAの研究者たちは、Climate for learning（学習環境）を測定可能な4つの要素に分解しました。コードの保守性、ドキュメントの品質、生成的文化、そしてチームのツール選択権限。一見バラバラに見えるこれらの要素が、実は「チームが継続的に学び、成長できる環境」という一つの概念を形作っているんです。「最近、チームメンバーが新しい技術について積極的に議論するようになったね」—もしこんな変化に気づいたら、それは学習環境が改善している確かな兆候です。Generative cultureとは、Ron Westrum博士が提唱した組織文化の3つのタイプの中で最も高次元の文化です。病的文化（Pathological culture）では情報が隠蔽され、責任が個人に押し付けられます。官僚的文化（Bureaucratic culture）では規則に従うことが重視され、責任が部門に分散されます。そして生成的文化（Generative culture）では、情報が自由に共有され、共通の目標に向かって協力します。多くのチームで見られる現象ですが、「優秀なエンジニアを集めれば、自然と良いチームになる」という思い込みは危険です。実際には、メンバーが意見を言わなくなり、問題の報告が遅れ、新しいアイデアも出なくなってしまうことがあります。私の経験でも、優秀な人材が集まったチームほど、お互いに遠慮して本音を言わない傾向がありました。この問題の本質は、無意識に作り出される「完璧主義の圧力」にあります。チームメンバーが「間違いを犯すことを恐れて、本当に必要な議論ができない」状態に陥ってしまうのです。学習環境の特徴は、情報の透明性を重視し、問題や課題が隠蔽されることなく、オープンに議論される環境を作ることです。学習志向も特徴的で、失敗を責めるのではなく、学習機会として捉えます。共同責任の考え方も大切で、チーム全体で成果と責任を共有します。そして、プロセスと結果の両方を継続的に改善していく姿勢が根付いています。Empowering teams to choose toolsも学習環境の重要な要素です。チームが自分たちの課題に最適なツールを選択できることで、自律性が向上し、内発的動機が高まります。選択の権限を持つことで、結果に対する責任感が自然に生まれ、新しいツールを試行錯誤することで、継続的な学習が促進されます。Fast flow（高速な流れ）デプロイ時間が10分から3分に短縮されたとき、エンジニアたちは歓声を上げました。でも、本当の価値はその7分間の短縮にあるのでしょうか？実は違います。Fast flowの本質は、価値を継続的に流す「仕組み」を構築することにあります。DORAが定義するFast flowは、継続的デリバリー、データベース変更管理、デプロイメント自動化、柔軟なインフラストラクチャ、疎結合チーム、変更承認の簡素化、バージョン管理、小バッチでの作業という8つの要素から成り立っています。デプロイ自動化に多大な時間を費やしても、実際のビジネス価値の向上は微々たるものになることがあります。技術的に高度な自動化システムを構築しても、何をデプロイするかの意思決定プロセスが改善されていなければ、本質的な生産性向上にはつながりません。実際、私も過去に3ヶ月かけて構築した自動化システムが、結局「速く価値の低いコードをデプロイできるようになっただけ」という苦い経験があります。Fast flowの重要性は、その再現性と拡張性にあります。一度構築すれば、チーム全体、そして組織全体の生産性を底上げできます。興味深いのは、これらの要素が相互に作用し合うことです。小バッチでの作業が継続的デリバリーを容易にし、疎結合なアーキテクチャがデプロイメント自動化を促進します。逆に、一つの要素が欠けると、他の要素の効果も著しく減少してしまいます。疎結合チームの概念は特に重要です。チーム間の依存関係を最小化することで、独立した開発とデプロイが可能になります。これにより、一つのチームの問題が他のチームに波及することを防ぎ、全体のスループットが向上します。Fast feedback（高速なフィードバック）新人エンジニアからよく聞かれる質問があります。「なぜテストを書くのに時間をかけるのですか？」この質問に対する答えは、体験してもらうのが一番です。テストなしで開発したコードと、包括的なテストを書いたコードで、1ヶ月後にそれぞれ機能追加を試みると、その差は歴然とします。テストがあるコードは安心して変更でき、リファクタリングも容易です。一方、テストがないコードは、変更するたびに他の部分への影響を恐れ、開発速度が数分の一に低下します。私が身をもって学んだのは、金曜日の夕方の「ちょっとした修正」でした。テストなしでデプロイした結果、土曜日の朝に本番環境が停止。原因調査と修正に週末を丸々費やしました。それ以来、テストの重要性を信じて疑いません。これがFast feedbackの真価です。DORAモデルでは、継続的インテグレーション、監視と可観測性、レジリエンス・エンジニアリング、浸透的セキュリティ、テスト自動化、テストデータ管理という6つの要素でFast feedbackを構成しています。これらは全て、学習サイクルを短縮し、問題の早期発見と迅速な修正を可能にするための仕組みです。この劇的な変化がもたらす効果は印象的です。開発者の自信が向上し、変更の影響を即座に確認できるため、大胆な改善を試みることができるようになります。技術的負債の予防も可能になり、問題が蓄積する前に対処できます。品質の向上も実現し、バグの早期発見により、高品質なソフトウェアを維持できるようになります。そして最も重要なのは、学習の促進です。失敗から素早く学び、改善を続けることができるようになります。重要なのは、Fast feedbackとFast flowが相互に作用し合うことです。迅速なフィードバックがあってこそ、安全に高頻度でデプロイできるようになります。Performance（パフォーマンス）ここまでは組織の「能力」について見てきました。でも、能力があっても成果が出なければ意味がないですよね。DORAモデルでは、CapabilitiesがどのようにPerformanceに変換されるかを明確に示しています。Software delivery（ソフトウェアデリバリー）「今回のリリース、バグ報告がほとんどないね」この言葉を聞いたとき、複雑な気持ちになることがあります。確かにバグは少ないけれど、そのコードは将来変更しやすいのか？新しい機能を追加するときに足枷になったりしないのか？Software deliveryは、Four Key Metricsで測定されます。変更リードタイム、デプロイメント頻度、変更失敗率、失敗したデプロイメントの復旧時間。これらの数値は確かに重要です。でも、数値の改善が必ずしも価値の向上につながらないことも、私たちは経験的に知っています。デプロイ頻度を上げることに集中したチームの話をしましょう。毎日デプロイできるようになった。素晴らしい！でも実際には小さなバグ修正ばかりで、ユーザーにとって意味のある機能追加はほとんどなかった。数値は改善したけれど、本質的な価値の提供は向上していなかったんです。レガシーシステムのメンテナンスプロジェクトでよくある話ですが、開発当初はFour Key Metricsの数値が良好でも、5年後には「誰も触りたがらないシステム」になってしまう。当時は「動く」ことが最優先で、「読みやすい」「変更しやすい」という品質が軽視されていたからです。Reliability（信頼性）「システムが安定しているから、新しい機能開発に集中できる」これ、当たり前のように聞こえますが、実はものすごく贅沢なことなんです。多くのチームは、日々の火消しに追われて、本来やりたい開発に時間を割けないでいます。DORAモデルでは、ReliabilityをSLO（Service Level Objectives）で測定します。測定範囲、測定焦点、目標最適化、目標遵守という4つの観点から評価するんですが、正直、最初は「なんでこんなに細かく分けるの？」と思いました。でも実際にSLOを導入してみると、その価値がわかります。以前は「なんとなく調子が悪い」という感覚的な判断でシステムを運用していたのが、「ユーザーのログイン成功率が95%を下回った」という具体的な基準で問題を判断できるようになる。これは大きな違いです。ただし、SLOの罠もあります。99.99%の可用性を目標にすると、開発チームが過度に保守的になってしまう。新機能のリリースを恐れるようになり、イノベーションが阻害される。一方、SLOが緩すぎると、ユーザー体験の悪化に気づくのが遅れてしまう。このバランスを見つけるのが本当に難しい。Outcomes（結果）ここまで能力（Capabilities）とパフォーマンス（Performance）について見てきましたが、結局のところ、経営層が知りたいのは「で、売上は上がるの？」「チームは幸せに働けているの？」という2つの質問への答えなんですよね。Organizational performance（組織パフォーマンス）「新機能のおかげで、売上が20%向上しました！」経営層の目がキラッと光る瞬間です。でも、ちょっと待って。その売上向上、本当に開発チームの成果だけでしょうか？DORAモデルが面白いのは、Organizational performanceを商業的な成果（売上、利益、市場シェアなど）と非商業的な成果（社会的価値、顧客満足度、ブランド価値など）の両方で評価することです。これ、すごく現実的だと思いません？B2Bプロダクトの開発でよくある話なんですが、開発チームが6ヶ月かけて技術的に優れた機能を実装した。Four Key Metricsの数値も改善した。でも、リリース後の売上への影響は...微々たるもの。なぜか？営業チームがその機能の価値を理解していなかったり、競合他社が同時期に似たような機能をリリースしていたりするからです。私も経験があります。渾身の機能が営業に理解されず、埋もれていく悲しさ。逆のパターンもあります。技術的には単純な機能が、営業チームの強力なプッシュと市場のタイミングが合致して、予想外の売上向上をもたらす。開発チームとしては「え、あれが？」という感じですが、これも現実です。CSVエクスポートボタンを追加しただけで大絶賛されたときは、正直複雑な気持ちでした。個人的に好きな事例は、カスタマーサポートツールの改善です。技術的には地味な作業でしたが、サポートチームの応答時間が半分になり、顧客満足度が15ポイント上昇。これが口コミで広がり、新規顧客の獲得につながった。地味だけど、確実に価値を生み出す仕事ってありますよね。Well-being（幸福度）最後に、おそらく最も重要な指標について話しましょう。「最近、チームメンバーの表情が明るくなったね」—これ、数値化できますか？できないですよね。でも、これこそが最も重要な成果の指標かもしれません。DORAモデルがWell-beingを重要なOutcomeとして位置づけているのは、本当に画期的だと思います。仕事の満足度、生産性の実感、バーンアウトの減少、リワークの減少。これらを真面目に測定し、他の成果と同等に扱う。技術的負債の解消プロジェクトの話をしましょう。短期的には売上に全く貢献しない。でも、開発チームの満足度が上昇した結果、新機能の開発速度が2倍に改善され、チームメンバーの離職率が下がり、新しい人材の獲得も容易になった。これ、立派な「成果」じゃないですか？「前は毎日、レガシーコードと格闘するのが苦痛でした。でも今は、新しい機能を作るのが楽しくて仕方がありません」こんな声が聞こえてくるようになったら、それは真の生産性向上の証拠です。数値では測れない、でも確実に存在する価値。それがWell-beingなんです。項目間の相互作用：システム思考の重要性ここまで7つの項目を個別に見てきましたが、実はこれらを別々に考えること自体が罠なんです。DORAモデルの本当の価値は、Capabilities → Performance → Outcomesという流れを示したことにあります。これ、当たり前のように見えて、実はすごく重要な洞察なんですよ。考えてみてください。Climate for learningが向上すると何が起きるか？チームメンバーが新しいことに挑戦しやすくなり、Fast flowとFast feedbackの改善アイデアがどんどん出てくる。その結果、Software deliveryとReliabilityが向上し、最終的にOrganizational performanceとWell-beingの改善につながる。全部つながっているんです。最新のDORA研究で「Reduced rework（リワークの減少）」が重要なOutcomeとして追加されたのも興味深いですね。要するに、「二度手間を減らす」ということ。品質向上が長期的にはすべての項目の生産性を向上させる、という当たり前だけど見落としがちな事実を改めて示しています。多くの組織で起きる失敗は、この相互作用を理解せずに、単一の項目だけを最適化しようとすることです。「とりあえずデプロイ頻度を上げよう！」とか言って、他の項目への影響を考えない。結果として、局所最適化の罠にはまってしまうんです。本当の生産性向上は、これら7つの項目を統合的に理解し、バランスよく改善していくことでしか達成できません。簡単じゃないですよ。でも、だからこそやりがいがあるんじゃないでしょうか。SPACE framework：包括的な測定手法DORAのFour Keysだけじゃ物足りないと思った人たちがいました。Microsoftの研究者Nicole Forsgren（DORAの研究者でもある）、GitHub、そしてVictoria大学の研究者たちです。彼らが開発したSPACE frameworkは、開発生産性を5つの次元で測定しようという野心的な試みです。www.microsoft.com名前の由来は各次元の頭文字なんですが、これがなかなか覚えやすい。Satisfaction and Well-being（満足度と幸福度）って、要するに開発者が仕事を楽しんでいるかどうか。チーム、ツール、文化にどれだけ満足しているか。満足度が高いチームは生産性も高い傾向があるって、まあ当たり前といえば当たり前ですが、それを真面目に測定しようというのが新しい。Performance（パフォーマンス）は、チームがどれだけ成果を出せているか。品質、顧客満足度、ビジネス価値の創出など。DORAのPerformanceより広い概念ですね。Activity（活動）は、開発者が日々何をしているか。コーディング、テスト、デバッグ、会議、コードレビュー...でも重要なのは量じゃなくて質と価値。忙しそうに見えても価値を生んでいなければ意味がない。実際、「8時間コーディングしました」と報告してきたメンバーの成果物を見たら、ほとんど進捗がなかったことがあります。聞いてみたら、Stack Overflowを彷徨っていたとか。Communication and Collaboration（コミュニケーションとコラボレーション）。これ、測定が難しいんですよね。でも、コードレビューの質とか、知識共有の頻度とか、新人のオンボーディング時間とか、工夫すれば測れるものはある。Efficiency and Flow（効率性とフロー）は、どれだけスムーズに仕事が進んでいるか。個人レベルでは集中時間の確保、チームレベルでは無駄な待ち時間の削減。これ、DevExのFlowとも関連していて面白い。queue.acm.orgで、SPACE frameworkの最も重要な教訓は何か？これらの次元を単独で使うな、ということです。「Activity（活動量）だけ見て評価するなんて最悪だぞ」と研究者たちは警告しています。複数の次元を組み合わせることで、初めて生産性の全体像が見えてくるんです。DevEx：最新の開発者体験フレームワーク2023年、また新しいフレームワークが登場しました。今度は誰が作ったかって？なんと、DORA、SPACE、その他の研究フレームワークの創設者たちが集まって作ったんです。オールスターチームみたいなものですね。queue.acm.orgDevEx（Developer Experience）は、名前の通り「開発者の体験」に焦点を当てています。でも、これまでのフレームワークと何が違うのか？それは「日常業務で遭遇する摩擦ポイント」に注目したことです。3つの核心次元がシンプルで分かりやすい：Flow（フロー）—これ、心理学者のチクセントミハイが提唱した「フロー状態」から来ています。没頭して時間を忘れるあの感覚。でも現実は？会議、Slack通知、「ちょっといい？」の声かけ。集中なんてできやしない。DevExは、この中断の頻度や種類、深い集中状態に入れる能力を測定します。実際に測定してみたら、1日で本当に集中できた時間は平均2時間しかありませんでした。残りは会議、Slack対応、「緊急」の割り込み...これじゃ生産性上がるわけない。Feedback（フィードバック）—コードを書いて、結果がわかるまでどれくらいかかるか。ビルドに20分、テストに30分、レビューに3日...これじゃ学習サイクルが回らない。DevExは、この待ち時間をどれだけ短縮できるかに注目します。Cognitive Load（認知負荷）—これが個人的には一番重要だと思います。複雑なシステム、分散したドキュメント、謎の暗黙知...頭がパンクしそうになりますよね。DevExは、開発者が作業を完了するために必要な精神的努力を測定します。あるレガシープロジェクトでは、新機能追加の見積もりが2週間だったのに、実際は2ヶ月かかりました。原因？ドキュメントがない、コメントもない、設計思想は「歴史的経緯」。認知負荷が高すぎたんです。面白いのは、Gartnerの調査で78%の組織が正式なDevExイニシアチブを確立または計画しているということ。みんな開発者体験の重要性に気づき始めているんです。そして驚くべきは、2020年のMcKinseyの研究結果。より良い開発者環境を持つ企業は、競合他社の4〜5倍の収益成長を達成したそうです。4〜5倍ですよ？これ、もはや「あったらいいな」じゃなくて、競争力の源泉なんです。測定の隠れたコスト「測定は無料だから、とりあえずやってみよう」これ、大きな間違いです。測定には必ずコストがかかります。そして、そのコストは思っているより高い。データを集めるための時間、分析するための時間、会議で議論する時間、ツールの導入と維持にかかるコスト、そして何より、本来の開発作業から奪われる時間。開発生産性を測定するために、エンジニアが1日30分をデータ入力に費やすケースを考えてみましょう。5人のチームなら、週に12.5時間。月に50時間。年間で600時間も本来の開発から奪われることになります。600時間あったら、中規模の機能を2つは作れますよね？その測定から得られた洞察は、正直に言って、その600時間に見合うものであることは稀です。「デプロイ頻度が先月より10%上がりました」という報告のために600時間を使う価値があるでしょうか？入門 監視 ―モダンなモニタリングのためのデザインパターン作者:Mike JulianオライリージャパンAmazonなぜ経営層は測定を求めるのか経営層が開発生産性の測定を求めるのには、理由があります。「エンジニアチームに多額の投資をしているのに、その効果が見えない」「開発が遅いと感じるけれど、それが妥当なのかわからない」「他社と比較して、うちのチームはどうなのか知りたい」こうした不安、すごくよくわかります。経営層も人間ですから、見えないものは不安なんです。特に、エンジニアリングという「よくわからない」領域に大金を投じているわけですから。ある経営者との対話で印象的だったのは、「年間1億円投資してるけど、何が生まれてるのかわからない」という率直な告白でした。確かに、エンジニアリングって外から見たらブラックボックスですよね。でも、その解決策として測定を求めるのは、多くの場合、適切ではありません。本当に必要なのは、開発プロセスの可視化と、エンジニアチームとのコミュニケーション改善です。測定は、その手段の一つでしかありません。そして、多くの場合、測定よりも対話の方が効果的だったりするんです。私が実践して効果があったのは、月1回の「技術説明会」でした。経営層向けに、今月の成果を「普通の言葉で」説明する。「データベースを最適化しました」じゃなくて「お客様の画面表示が3秒から1秒になりました」というように。すると理解が深まり、不安も解消されていきました。エンジニア組織を強くする 開発生産性の教科書 ～事例から学ぶ、生産性向上への取り組み方～作者:佐藤 将高,Findy Inc.技術評論社AmazonFour Keysの光と影Four Keysは確かに優れた指標です。DORAの長年の研究に基づいており、多くの組織で実際に改善の指針として機能しています。でも、Four Keysには限界があるんですよ。例えば、Sansan社のモバイルアプリ開発チームの事例。彼らはFour Keysからベロシティを含む別の指標に変更しました。なぜか？モバイルアプリでは過度にリリース頻度を増やすとユーザ体験を損ねる場合があり、Four Keysの前提と合わなかったからです。これ、すごく重要な気づきですよね。Four Keysって、Webサービスの継続的デプロイを前提にしている部分があるんです。でも、すべてのソフトウェアがそうじゃない。他にも限界はあります。デリバリーの効率は測れても、何をデリバリーするかの適切さは測れません。チームの健全性は示唆できても、個人の成長やモチベーションは見えません。開発プロセスの改善は追跡できても、顧客価値の創出は直接的には測れません。Four Keysを「結果指標」として理解することが重要です。数値を上げることが目的ではなく、数値の背後にある組織の能力（Capability）を改善することが目的なのです。2018年に発売された『LeanとDevOpsの科学』には、実はこのことがちゃんと書いてあるんです。もっとみんな、内容を読めばいいのにって思っています。LeanとDevOpsの科学［Accelerate］ テクノロジーの戦略的活用が組織変革を加速する impress top gearシリーズ作者:Nicole Forsgren Ph.D.,Jez Humble,Gene Kim,武舎広幸,武舎るみインプレスAmazonこちらの資料もめちゃくちゃに良いので読んでみてほしいです。『LeanとDevOpsの科学』を読まずにFour Keysをきちんと利用することはほぼ不可能です。Forsgrenらが発見した、DevOps組織のパフォーマンスを上げるために必要な24（現在は27）のケイパビリティには、継続的デリバリは当然のこと、組織文化やリーダーシップ、リーンといったものも含まれています。 speakerdeck.com変革型リーダーシップの重要性開発生産性の向上って、結局のところ技術的な問題じゃないんです。人の問題なんです。英国工学技術学会の調査結果を見て驚きました。リーダーシップスキルを持つエンジニアは、チームの生産性を30%向上させることができるそうです。30%ですよ？どんなツールを導入するよりも効果的じゃないですか。jellyfish.co特に効果的なのが変革型リーダーシップ（Transformational Leadership）です。難しそうな名前ですが、要はチームメンバーの内発的動機を高め、組織のビジョンに向けて一緒に頑張ろうと導くリーダーシップスタイルのことです。でも、多くの技術者にとって、リーダーシップは自然に身につくものではありません。コードは書けても、人を導くのは苦手。そんな人が多いんじゃないでしょうか。私もそうでした。そこで注目されているのがスタッフエンジニアという役割です。組織横断的な技術的課題に取り組み、他のエンジニアの技術的判断をガイドする。直接的な部下を持たずとも、影響力とリーダーシップが求められる役割です。スタッフエンジニア　マネジメントを超えるリーダーシップ作者:Will Larson日経BPAmazonスタッフエンジニアのリーダーシップは、従来のマネジメント型とは違います。権限じゃなくて専門性に基づく影響力。階層的な指示じゃなくて技術的な説得力。個人のパフォーマンス管理じゃなくてチーム全体の技術的能力向上。これって、変革型リーダーシップの理論とぴったり合うんです。理想化された影響、鼓舞的動機、知的刺激、個別的配慮という4つの要素。これらを理解し実践することが、開発生産性の向上には不可欠なんです。変革型リーダーシップの4つの要素変革型リーダーシップは4つの要素から構成されているんですが、これが結構難しい。理論は美しいけど、実践となると...理想化された影響（Idealized Influence）リーダーがロールモデルとして機能し、チームメンバーから尊敬と称賛を得る。言うは易く行うは難し。技術的な専門性を維持しながら、チームの成功を優先する。言うのは簡単ですが、実際にやってみると矛盾だらけです。完璧である必要はないということが重要です。むしろ、自分の失敗を率直に認め、そこから学ぶ姿勢を見せることの方が大切です。設計したアーキテクチャに重大な欠陥があることが発覚した時、言い訳をするのではなく、チーム全体の前で設計判断の誤りを認め、なぜそう判断したのか、どうすれば防げたのかを一緒に考えることで、チーム全体の雰囲気が変わります。メンバーも自分の失敗を隠さなくなり、互いに助け合うようになるのです。私が設計したマイクロサービスアーキテクチャが複雑すぎて誰もメンテできなくなった時、素直に「ごめん、設計ミスだった」と認めました。すると、他のメンバーも「実は自分も...」と失敗を共有し始め、チーム全体がオープンになりました。技術的な信頼性を保つことも重要ですが、それ以上に倫理的な行動を示すことが大切です。困難な状況でも一貫した価値観を示し、透明性のある意思決定を行う。コードレビューでは建設的なフィードバックを提供し、自らも率先してレビューを受ける。これらの小さな行動の積み重ねが、信頼関係を築いていくのです。リーダーの仮面――「いちプレーヤー」から「マネジャー」に頭を切り替える思考法作者:安藤 広大ダイヤモンド社Amazon鼓舞的動機（Inspirational Motivation）魅力的なビジョンを設定し、目的意識を創造する能力は相反する能力ではありません。エンジニアは概して現実的で、抽象的なビジョンには懐疑的です。だから工夫が必要なんです。効果的なのは、技術的なビジョンを具体的なユーザー体験と結びつけることです。スプリント開始時に、実装する機能がユーザーにどのような価値を提供するかを具体的に説明する。技術的負債の解消を「将来の自分たちへの投資」として位置づける。新しい技術の導入を「チームの競争力向上」として意味づける。レガシーコードのリファクタリングを進める際、チームメンバーから「この作業に意味があるのか？」という質問を受けることがあります。そんな時は、6ヶ月後にその部分に新機能を追加することになった時のことを具体的に想像してもらいます。現在のコードのままだと、開発に2週間かかり、バグの発生率も高くなる。しかし、今リファクタリングすれば、その作業が3日で完了し、品質も向上する。このように、抽象的なビジョンを具体的な体験に変換することで、チームの目的意識を創造することができるのです。モチベーション革命　稼ぐために働きたくない世代の解体書 (NewsPicks Book)作者:尾原和啓幻冬舎Amazon知的刺激（Intellectual Stimulation）「従来の方法に挑戦し、新しい視点とアプローチを奨励する」これは技術者にとって最も自然な要素かもしれません。でも、実際には思っているより難しい。なぜなら、自分の知識や経験が邪魔をするからです。重要なのは、答えを教えるのではなく、考えを促す質問を投げかけることです。アーキテクチャ設計時に「他にどのような方法があるか？」と問いかけたり、チームメンバーが新しいフレームワークを提案した際は批判ではなく検証を支援したり、定期的に「なぜこの方法を選択したのか？」を振り返る時間を設けることが効果的です。新人エンジニアが既存のアプローチとは全く異なる解決策を提案した時、「それは複雑すぎる」と却下するのではなく、「面白いアイデアですね。どのようなメリットがあると思いますか？」と質問することで、見落としていた重要な利点が発見されることがあります。失敗を学習機会として扱うことも重要です。エラーが発生した時、誰が悪いかを追求するのではなく、なぜそのエラーが発生したのか、どうすれば再発を防げるのかを一緒に考える。これにより、チーム全体の学習能力が向上します。Unlearn（アンラーン）　人生100年時代の新しい「学び」作者:柳川 範之,為末 大日経BPAmazon個別的配慮（Individualized Consideration）「各チームメンバーの個人的なニーズと能力に注意を払う」これが最も時間がかかり、最も重要な要素です。なぜなら、人は一人一人違うから。定期的な1on1を実施し、各メンバーの目標に応じた学習機会を提供することが基本となります。各メンバーの強みを理解して各人の能力に最も合致した役割を割り当て、メンバーの性格や学習スタイルに合わせてフィードバックを調整することが重要です。例えば、内向的で技術的には優秀だが会議では発言しないエンジニアがいる場合、「もっと積極的に発言してください」と言うだけでは効果がありません。1on1で話してみると、口頭でのコミュニケーションが苦手だが、文書でのコミュニケーションは得意だということがわかることがあります。そのような場合は、事前に意見を文書で整理してもらい、会議ではその内容を代弁する形にする。また、複雑な技術的な判断が必要な場合は、文書で分析してもらうなど、個々の特性に合わせたアプローチが効果的です。「変化を嫌う人」を動かす:魅力的な提案が受け入れられない4つの理由作者:ロレン・ノードグレン,デイヴィッド・ションタル,船木 謙一(監修)草思社Amazon変革型リーダーシップの落とし穴ただし、変革型リーダーシップにも限界があります。最新の研究では、変革型リーダーシップには「収穫逓減の法則」が適用され、過度なリーダーシップは逆効果になる可能性があることが示されています。組織がリーダー個人に過度に依存してしまうと、組織の脆弱性が高まります。カリスマ的なリーダーが常に高いエネルギーを維持し続けることは持続可能ではなく、強力なビジョンが異なる意見や多様な視点を排除してしまうリスクもあります。特に注意が必要なのは、短期的な成果の軽視です。長期的なビジョンに集中しすぎると、短期的な成果や日々の小さな勝利を見落としがちになります。チームメンバーは理想的な未来への道筋だけでなく、現在の進歩を実感できる具体的な成果も必要としています。測定の難しさと現実的なアプローチ変革型リーダーシップの効果を測定するのは困難です。チームの離職率、技術的負債の減少速度、新機能の開発速度など、定量的な指標はある程度の示唆を与えますが、それだけでは全体像は見えません。360度フィードバックでのリーダーシップ評価もよく使われますが、これには重大な問題があります。匿名性があるとはいえ、多くの場合、評価者は無意識に「政治的に正しい」回答をしてしまいます。特に日本の組織文化では、率直なフィードバックを避ける傾向が強く、結果として「みんな平均的に良い」という無意味なデータが集まることが多いのです。また、360度評価は実施に多大な時間とコストがかかる割に、具体的な改善アクションにつながりにくいという本質的な欠陥もあります。チームメンバーの満足度調査、技術的な意思決定への参加度なども重要な指標ですが、これらの定性的な指標は解釈が複雑で、文脈に大きく依存します。効果的な測定指標として注目されているのは、チームメンバーが自発的に新しいアイデアを提案する頻度です。これは心理的安全性が確保され、知的刺激が機能していることを示す重要なサインと考えられています。また、クロスファンクショナルなコラボレーションの増加や、チーム内での知識共有の活発化も、変革型リーダーシップの効果を示す指標となります。DevOps文化との融合変革型リーダーシップとDevOps文化って、実は相性抜群なんです。どちらも継続的な学習と改善を重視し、実験と失敗からの学習を奨励し、協調とコラボレーションを促進し、顧客価値の最大化を目指す。価値観がぴったり一致しているんです。具体的にどう実践するか？レトロスペクティブで建設的な振り返りをする。技術的な実験を恐れない文化を作る。部門の壁を越えたコラボレーションを推進する。顧客フィードバックを開発プロセスに組み込む。これらは全部、変革型リーダーシップの4つの要素を日常的に発揮するための基盤になります。リーダーシップとDevOps、別々に考える必要はないんです。一体として実践すればいい。変革型リーダーシップは単なる管理手法じゃありません。技術組織の文化と価値観を形成する重要な要素です。適切に実装できれば、開発生産性の向上だけじゃなく、チームメンバーの満足度と継続的な成長にも大きく貢献します。ただし、これは一朝一夕で身につくものじゃありません。組織全体での継続的な学習と実践が必要です。でも、その価値は十分にあると思いませんか？現場の声を聞く重要性現場にとって最も効果的な測定システムは、現場の人間が適切に設計したものです。机上で考えた理想的な指標よりも、実際に開発をしているエンジニアの経験と判断の方が、多くの場合、より正確な情報を提供します。「あのエンジニアは本当に頼りになる」「この機能は使いやすくて、お客さんからの評判がいい」「最近、デプロイが安定していて、安心して作業できる」こんな声が聞こえてきたら、それは本当の生産性向上の証拠です。数値では捉えられない、でも確実に存在する価値。それを見逃してはいけません。エンジニアリング組織論への招待　～不確実性に向き合う思考と組織のリファクタリング作者:広木 大地技術評論社Amazon客観性の落とし穴 (ちくまプリマー新書 ４２７)作者:村上　靖彦筑摩書房Amazon代替的なアプローチ標準化された測定だけが、情報収集の方法ではありません。DORAの最新研究や『LeanとDevOpsの科学』でも強調されているのは、定量的な指標と定性的な情報の組み合わせの重要性です。顧客からの直接的なフィードバック、チーム内での振り返り、個人との1on1での会話、実際のプロダクト使用体験...これらは数値化しにくいけれど、めちゃくちゃ価値が高い。特に重要なのは、実際にプロダクトを使っているユーザーの生の声です。「この機能があって助かった」「バグが少なくて使いやすい」「新しい機能がすぐに追加されて嬉しい」こんなフィードバックは、どんな精密な測定指標よりも、本当の生産性と価値創出を示しています。私が経験した最も効果的な方法は、エンジニア全員でカスタマーサポートの電話を聞くことでした。「この機能、使いにくい」「ここがわからない」という生の声を聞くと、自然と「もっといいものを作ろう」という気持ちになります。DORAの最新モデルでは、こうした多角的なアプローチが体系化されています。定量的なFour Key Metrics、定性的な組織文化評価、そして顧客価値に関する直接的なフィードバック。これらを組み合わせることで、より包括的な生産性評価が可能になるんです。スクラム研究でも同じような結論に達しています。チームの効果性を評価するには、定量的な指標だけじゃなく、7年間の研究で明らかになった5つのKey Factorを元にした包括的な評価が重要だということです。 speakerdeck.com測定の限界を受け入れる最終的に、測定には限界があることを受け入れる必要があります。すべての問題が解決可能なわけではなく、測定で改善できる問題はさらに限定的です。「測定できないものは管理できない」という考え方は間違いです。むしろ、測定できない要素こそが、組織の成功にとって決定的に重要な場合が多いのです。透明性の向上は問題を可視化しますが、それ自体は解決策ではありません。複雑な問題は単純な数値では表現できず、熟練した専門家の判断力と解釈力が不可欠です。そして何より、測定に振り回されて、本来の目的を見失ってはいけません。私たちの目的は、数値を改善することではなく、より良いソフトウェアを作り、ユーザーに価値を届けることなのですから。buildersbox.corp-sansan.com測定の落とし穴を避けるための現実的なアプローチここまで問題点ばかり指摘してきましたが、じゃあどうすればいいのか？実践的な提言をまとめてみました。1. 心理的安全性の確立を最優先にGoogle Project Aristotleの研究結果は衝撃的でした。チーム成功の最重要要素は、優秀な人材でも、厳密に設計されたプロセスでもなく、「心理的安全性」だったんです。でも、どうやって心理的安全性を作るのか？Amy Edmondsonの診断アンケートを使って現状把握から始めるのがおすすめです。特に「失敗について話し合うことができる」という項目のスコアが低い場合は要注意。リーダーが率先して自分の失敗を開示することも効果的です。設計判断の誤り、顧客要件の理解不足、見積もりの甘さ...これらを隠さず共有し、そこから何を学んだかを明確に示す。すると不思議なことに、チーム全体が失敗を隠さなくなるんです。1on1も重要です。表面上は問題なく見えても、内心では不安を抱えているメンバーは多い。定期的に個別で話を聞き、本音を引き出す。これには時間がかかりますが、投資する価値は十分にあります。そして、失敗を非難しない文化を明文化すること。「学習のための失敗」は奨励し、「不注意による失敗」は改善のためのサポートを提供する。この区別を明確にすることで、チームメンバーは安心して挑戦できるようになります。2. 多次元的な測定アプローチの段階的導入SPACE frameworkやDevExを見て「これ全部測定するの？」と思った方、正解です。いきなり全部やろうとすると測定疲れで倒れます。だから段階的にやりましょう。まずは月1回の簡単な満足度調査（5分程度）から。「今月の仕事、楽しかったですか？」くらいのシンプルな質問で十分です。慣れてきたら四半期ごとにSPACE評価を実施し、半年ごとにDevExの深掘りインタビューを行う。面白い発見もあります。満足度と認知負荷には強い負の相関があるんです。つまり、頭がパンクしそうな状態では、仕事を楽しめない。当たり前といえば当たり前ですが、データで示されると説得力が違います。測定の品質を確保するためには、匿名性の保証が不可欠です。「正直に答えてもらえなければ、測定する意味がない」ということを、経営層にも理解してもらう必要があります。そして最重要ポイント：測定結果を必ず改善アクションに繋げること。データを集めるだけで終わったら、次回から誰も協力してくれなくなります。3. 開発者の主観的体験の重視DevEx研究の最大の貢献は、「開発者の主観的体験が生産性に大きく影響する」ことを明確にしたことです。フロー状態の測定では、中断頻度の記録が鍵になります。技術的な中断（ビルドエラー、テスト失敗）より、人的な中断（会議、Slack、「ちょっといい？」）の方が影響が大きいんです。これ、実感としてもわかりますよね。認知負荷の評価も重要です。新しいコードベースの理解困難度、ツールの複雑さ、意思決定に必要な情報の入手困難度...これらを定期的に評価することで、本当のボトルネックが見えてきます。実践的な収集方法として効果的なのは、デイリースタンドアップで「昨日一番ストレスを感じたのは何？」を共有すること。最初は戸惑うかもしれませんが、慣れると貴重な情報源になります。4. バーンアウト予防の測定戦略への組み込み83%の開発者がバーンアウトを経験している現状を踏まえ、測定によるストレス増大を避ける必要があります。早期発見システムの構築では、Maslach Burnout Inventory（MBI）の定期実施、勤務時間外の連絡頻度監視、休暇取得パターンの分析、パフォーマンスの突然の変化検出などが重要です。特に、普段高いパフォーマンスを示していたメンバーの生産性が突然低下した場合は、バーンアウトの兆候である可能性が高いため、早期の介入が必要です。予防的介入としては、持続可能な開発ペースの維持が最も重要です。十分な休息とリフレッシュの機会を提供し、技術的な成長機会を定期的に提供することで、内発的動機を維持できます。短期的な成果を追求するあまり、長期的な持続可能性を損なわないよう注意が必要です。5. 変革型リーダーシップの体系的育成技術的な改善だけでなく、リーダーシップスキルを持つエンジニアの育成が重要です。リーダーシップの育成は、メンバーの成長段階に応じて異なるアプローチが必要です。初級レベルでは、まず1on1スキルと効果的なフィードバック方法の習得から始めます。これらは日々のコミュニケーションの基礎となる重要なスキルです。中級レベルに進むと、組織間協調と戦略的思考の能力開発に焦点を移します。単一チームの枠を超えて、より広い視野で物事を考える力を養うのです。そして上級レベルでは、ビジョンの策定と組織文化の変革という、より高次元のリーダーシップスキルの習得を目指します。実践的な育成方法として、まずメンターシップ制度の導入が効果的です。経験豊富なリーダーから直接学ぶ機会を提供することで、理論だけでなく実践的な知恵も伝承できます。リーダーシップ研修の実施も重要ですが、座学だけでなく実際の場面を想定したロールプレイングなどを組み込むことで、より実践的な学習が可能になります。360度フィードバックも活用できますが、先述したようにその限界を理解した上で、あくまで補助的なツールとして使うべきです。最も重要なのは、理論と実践を組み合わせた学習アプローチです。学んだことをすぐに現場で試し、その結果を振り返ることで、真のリーダーシップスキルが身についていくのです。6. 組織文化への戦略的投資測定は手段であり、目的ではありません。持続的な生産性向上には組織文化の醸成が不可欠です。文化醸成は段階的に進める必要があります。まず現状把握として、組織文化診断を実施し、Westrum文化モデルで現状を評価して文化的な問題点を特定します。次に意識変革の段階では、文化変革の必要性を共有し、変革ビジョンを策定します。最も困難な行動変容の段階では、新しい行動パターンを実践し、成功事例を共有していきます。具体的な施策として、失敗を学習に変えるプロセスの構築、実験を奨励する制度の導入、部門横断的なコラボレーションの推進、顧客価値創出への集中などが重要です。これらの施策を通じて、組織文化を徐々に変革していくことができます。7. 測定疲れを防ぐ持続可能な仕組み測定自体が負担になってしまっては本末転倒です。最小限の負担で最大の効果を得るためには、自動化可能な指標を優先し、既存ツールからのデータ収集を活用し、短時間で完了する調査を設計し、重複する測定を排除することが重要です。明確な価値の提示も欠かせません。測定結果の活用方法を明示し、改善につながる実例を共有し、測定コストと得られる価値を比較し、無駄な測定を定期的に見直すことで、チームメンバーの理解と協力を得ることができます。参加型の設計により、開発者自身が測定項目を提案し、測定結果の解釈に参加し、改善アクションを共同で立案し、測定システムを継続的に改善していくことで、測定への抵抗感を3分の1程度に減らすことができます。これらの提言を実装することで、測定の落とし穴を避けながら、真の開発生産性向上を実現できます。重要なのは、一度にすべてを実装しようとするのではなく、組織の成熟度に合わせて段階的に取り組むことです。そして、常に人間を中心に据え、測定が目的ではなく手段であることを忘れないことです。ちゃんとした生産性向上への道では、どうすればいいのでしょうか？測定を諦める必要はありません。でも、測定を万能薬だと考えるのは危険です。重要なのは、測定を改善の手段として位置づけることです。数値の背後にある人間の活動と組織の能力に焦点を当て、測定されない価値を見過ごさないことです。Four Keysのような指標は、組織の健全性を示すバイタルサインのようなものです。熱があるのは病気のサインかもしれませんが、熱を下げることが治療ではありません。根本的な原因を理解し、原因に基づいた対処をすることが重要なのです。実際、DORAの最新の研究プログラムでは、Four Keysだけでなく、より包括的な行動科学的手法を用いて、働き方、ソフトウェア配信パフォーマンス、組織目標、個人の幸福度を結ぶ予測経路を解明しています。この統合的なアプローチが、実質的な生産性向上への道なんです。dora.devさいごに飲み会帰りの散文、失礼しました。開発生産性は、簡単には測れません。測れたとしても、その数値が全てを語ってくれるわけではありません。でも、だからこそ面白いんです。人間の創造性、チームの協力、技術の進歩、顧客の満足。これらすべてが絡み合って、本当の生産性が生まれます。単純な数式では表せない、複雑で美しいシステムです。測定は重要ですが、測定されない価値を忘れてはいけません。数値の向上は手段であって、目的ではありません。真の目的は、より良いソフトウェアを、より効率的に、より楽しく作ることです。エンジニアリングって、本来楽しいものですよね？新しいものを作り出す喜び、難しい問題を解決する達成感、チームで何かを成し遂げる充実感。これらを犠牲にしてまで、数値を追いかける価値があるでしょうか？開発生産性の測定に万能な答えはありません。でも、その限界を理解し、謙虚に取り組むことで、より良いチーム、より良いプロダクト、より良い組織を作ることができるはずです。この記事が、開発生産性の測定に取り組む皆さんの一助となれば幸いです。測定の落とし穴を避け、本当に価値のある改善に向けて、一緒に歩みを進めていきましょう。そして最後に一つ。もし「この数値が良くなったら、僕たちは本当に幸せになれるんですか？」と聞かれたら、あなたはどう答えますか？私なら、こう答えます。「数値は幸せを保証しない。でも、みんなで一緒に改善していく過程は、きっと価値があるはずだよ」って。","isoDate":"2025-07-10T05:12:44.000Z","dateMiliSeconds":1752124364000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"正義のエンジニアという幻想 - 媚びないことと無礼の境界線","link":"https://syu-m-5151.hatenablog.com/entry/2025/07/05/132411","contentSnippet":"はじめに私はかつて、自分の技術思想とキャリア戦略が100%正しいと信じて疑いませんでした。そして、それを受け入れない企業、同僚たちが100%間違っていると本気で思っていたのです。今思えば、それはソフトウェアエンジニアという職業に就いた多くの若い人が陥る、ある種の思春期的な錯覚だったのかもしれません。技術的な正しさを盾に、社会的な配慮を無視し、人間関係の機微を「非論理的」と切り捨てていました(エンジニアの論理的なんて往々にして論理的ではないのに)。この記事は、かつての私のような「正義のエンジニア」だった自分への懺悔であり、同じ過ちを犯している人たちへの警鐘でもあります。媚びないことと無礼であることの区別もつかないまま、技術的優位性を振りかざしていた—そんな恥ずかしい過去を、今こそ正直に振り返ってみたいと思います。DD(どっちもどっち)論 「解決できない問題」には理由がある (WPB eBooks)作者:橘玲集英社Amazonこのブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。技術的正しさという名の傲慢「なぜこんな非効率的な実装をするんですか？」「もっと良い方法があるのに...」「技術的にはこっちの方が正しいんですけどね」そんな恥知らずな言葉を、私は何度口にしたことでしょう。普段は配慮できるつもりでいたのに、技術的な議論になると、つい正論を優先してしまう癖がありました。先輩が現実的な理由を説明してくれているのに、心の中では「でも技術的には間違ってる」と思ってしまう。コードレビューで「ここはこう書いた方が綺麗ですよ」と、相手の状況を考えずにコメントしてしまう。政治的な理由で技術選定が決まれば、会議後に同期に「エンジニアリングの敗北だよね」と吐き捨てる。ビジネス判断を優先する同僚を見ては「技術者として魂を売ってる」と心の中で見下す。「技術的に正しいことを追求するのがエンジニアの仕事」「妥協したらそこで終わり」「コードが全てを物語る」今思い返すと顔から火が出るような発言の数々。技術的な正論を振りかざすことが、エンジニアとしての誠実さだと勘違いしていたのです。技術的に正しいことを言っているのだから、それが最優先されるべき—そう信じていました。でも問題は、私が「技術的正しさ」だけが唯一の評価軸だと思い込んでいたことでした。ビジネス価値、チームの状況、スケジュールの制約—これらも同じくらい重要な要素です。しかし、当時の私にはそのバランス感覚が足りませんでした。コードレビューでは技術的な理想を押し付けがちで、会議では「でも技術的には...」という前置きで反対意見を述べることが多かった。新人が質問してきても、「まずはドキュメント読んでみて」と突き放してしまうことも。今思えば、技術的に正しいことを伝えようとしているつもりで、実際には相手の立場に立てていなかっただけでした。これからの「正義」の話をしよう ──いまを生き延びるための哲学 (ハヤカワ・ノンフィクション文庫)作者:マイケル・サンデル早川書房Amazon最も痛いのは、エンジニアリングの視点でしか物事を見られなかったことです。採用面接の後には必ず「技術力が低い人を採用すべきじゃない」と文句を言い、ビジネス感覚や調整能力の価値なんて考えもしませんでした。技術選定の会議では「Rustを使うべき」「マイクロサービスにすべき」と主張するものの、採用の難しさや運用コストの話が出ると「それは別の問題」と切り捨てる。ビジネスの成長段階や組織の体力を考えない、机上の空論ばかりでした。「もっとモダンな開発環境を」「もっと厳密なレビュープロセスを」と理想論を語りながら、それが非エンジニアとの協業や意思決定スピードにどう影響するかは無視。技術は事業を加速させる手段なのに、私の頭の中では技術それ自体が目的化していたのです。そして同僚が現実的な判断をすると「ビジネスに魂を売った」と心の中で見下す。実際は、私こそが現実を見ていなかったのです。幸い、私の意見が採用されることはほとんどありませんでしたが、今思えばそれで良かったのでしょう。理想のキャリアという妄想私は自分のキャリア構築が完璧だと思い込んでいました。GitHubでOSS活動をし、技術ブログを書き、勉強会で登壇する。これこそが「エンジニア」の歩むべき道だと信じて疑いませんでした。かっこよかったんだと思います。憧れていたんだと思います。社内政治に長けた人を見ては「技術力のない政治屋」と心の中で罵り、クライアントとの関係構築に努める人を「営業エンジニア」と揶揄していました。チームの和を大切にする人なんて「ぬるま湯に浸かっている」としか思えなかったのです。さらに滑稽だったのは、自分の行動が最も正しいと信じていたことです。会社の不満をオープンに書き、技術的な批判を遠慮なく投稿し、「透明性」と「正直さ」を標榜していました。それが「媚びない姿勢」だと勘違いしていたのです。しかし実際には、それは単なる社会性の欠如でした。批判と中傷の違いも、建設的な議論と単なる文句の違いも理解していませんでした。「なぜ私の正論が受け入れられないのか」と憤りながら、自分のコミュニケーション能力の低さには全く気づいていなかったのです。High Conflict よい対立 悪い対立 世界を二極化させないために作者:アマンダ・リプリーディスカヴァー・トゥエンティワンAmazon現実を100%否定する愚かさ最も恥ずかしいのは、自分の理想が受け入れられない現実を「100%間違っている」と断じていたことです。レガシーシステムを見ては「なぜこんなゴミを使い続けるんだ」、古い技術スタックに「この会社に未来はない」、ビジネス優先の判断に「エンジニアリングの敗北」—すべてを否定的に捉えていました。私は自分以外の判断基準を認められませんでした。 技術的に正しくないものは全て間違いで、それを許容する人たちも間違っている。そんな狭い視野でしか物事を見られなかったのです。同期との飲み会では不満ばかりこぼしていました。「うちの会社、まだSVN使ってるんだよ。Git使えないエンジニアの会社とか終わってる」「テストコード書かない文化とか、プロの仕事じゃない」「ウォーターフォールとか、時代遅れもいいところ」プロジェクトで問題が起きれば「マネジメントが技術を理解していないから」、自分の提案が通らなければ「この会社は技術を軽視している」、期待した評価が得られなければ「エンジニアが正当に評価されない組織」—全ての原因を外部に求めていました。自分が提案した新技術が却下されれば「老害が変化を恐れている」と憤り、レガシーコードの改修を任されれば「俺の才能の無駄遣い」と不満を漏らし、ドキュメント作成を頼まれれば「エンジニアの仕事じゃない」と文句を言う。でも振り返ってみれば明らかです。問題は私自身にありました。 技術的な正しさだけを追求し、ビジネス的な制約や組織の事情を理解しようとしなかった。技術力があることと、組織で価値を生み出すことは別物です。そんな視野の狭さが、多くの問題を生み出していたのです。正しいことを言うことと、相手に受け入れられる形で伝えることも別物です。そんな基本的なことすら理解していなかったのです。転機となった出来事幸運なことに、私は比較的早い段階で痛い目に遭い、良いメンターに出会うことができました(というか強い人)。あるコードレビューで、私がいつものように「このコード、正直ひどくないですか？全部書き直した方が早いです」とコメントしたとき、シニアエンジニアが個別に連絡をくれました。「君の指摘は技術的には正しい。でも、そのコメントを見た人がどう感じるか考えたことある？彼は他のタスクも抱えながら、期限に間に合わせようと必死だった。君のコメントは、その努力を全否定している」その言葉にハッとしました。私は技術的な正しさばかりを見て、人の気持ちを踏みにじっていたのです。別の機会には、マネージャーが1on1で厳しい指摘をしました。「君は優秀だ。でも、チームメンバーが君を避け始めている。それでいいの？技術力があっても、一人では何も作れないよ」(とても良いフィードバックをしてくれる良いマネージャーでした)ある技術選定の会議で、私の提案があっさり却下されたこともありました。技術的には明らかに優れていたはずなのに。後で分かったのは、採用された同僚が事前に全ての関係者の不安を聞き出し、丁寧に説明して回っていたということ。私は正しさだけを主張し、人を動かす努力を怠っていたのです。そして最も衝撃的だったのは、年次が上がって後輩ができたときのことです。私の何気ない「それは違うよ」という一言で、新卒エンジニアが完全に萎縮してしまいました。その後、彼は私に質問することを避けるようになり、分からないことを抱え込むように。私は、かつて自分が嫌っていた「怖い先輩」になっていたのです。これらの経験が重なって、ようやく理解しました。技術力は重要だが、それをどう使うかはもっと重要。正しいことを、正しい方法で伝えられなければ、それはただの暴力だということを。「変化を嫌う人」を動かす:魅力的な提案が受け入れられない4つの理由作者:ロレン・ノードグレン,デイヴィッド・ションタル,船木 謙一(監修)草思社Amazon媚びないと無礼の致命的な混同「私は媚びない」—それが私のアイデンティティでした。しかし今思えば、それは単に「無礼で無神経だった」だけです。普段は普通に接することができても、技術的な話題になると途端に配慮が吹き飛んでいました。「このコード、正直レベル低くないですか？」「え、まだjQuery使ってるんですか？今どき？」「Excelで管理とか、エンジニアリング組織として恥ずかしくないんですか」コードレビューでは、つい「このままマージするの、正直抵抗あります」と書いてしまう。会議での議論では他の人の意見を尊重しつつも、心の中では「技術的にナンセンス」と思っていることが顔に出てしまう。ペアプログラミングでは、相手のアプローチを見て「あー、それはちょっと...」と否定的な反応をしてしまう。質問されても「それは基本なので自分で調べた方が身につきますよ」と突き放す。同僚との雑談では「うちの技術レベル、正直物足りない」「もっと技術にこだわる会社に行きたい」などと不満を漏らし、それを「健全な問題意識」だと勘違いしていたのです。媚びないことと、相手を尊重することは両立します。 でも当時の私にはその区別がつきませんでした。率直であることと配慮がないことを混同し、技術的な正しさを盾に、人としての礼儀を忘れていました。最も痛いのは、SNSでの振る舞いです。「エンジニアは技術で語るべき」という信念のもと、技術以外の要素をすべて否定していました。ビジネス的な判断を「技術の敗北」と断じ、人間関係の構築を「非生産的」と切り捨てていました。そんな態度が「カッコいい」「筋が通っている」と本気で思っていたのです。今思えば、ただの社会不適合者でした。頭の悪い反抗期の言い訳私は様々な言い訳を用意していました。「エンジニアは成果で評価されるべきだから人間関係は二の次」「技術的に正しいことが最優先だから言い方なんて些細な問題」「実力があれば多少の態度の悪さは許される」「媚びるくらいなら孤立した方がマシ」これらはすべて、自分の社会性の欠如を正当化するための、頭の悪い言い訳でした。 まるで反抗期の中学生が「大人は汚い」と言い訳するように、私は「技術的正しさ」を盾に、自分の未熟さを隠していたのです。社内の勉強会では「政治的な理由で技術選定するのは技術者への冒涜」「日本の会社はエンジニアを大切にしない」などと大げさな批判を展開し、それを「問題提起」だと思い込んでいました。特に恥ずかしいのは、これらの言い訳を「エンジニアの美学」として語っていたことです。「媚びない技術者の生き方」「技術に嘘をつかない姿勢」「純粋なエンジニアリング」—そんな青臭いタイトルでブログを書き、勉強会で熱弁していました。同じような考えを持つ人たちとエコーチェンバーを形成し、「俺たちだけが本物のエンジニア」「周りは技術を理解していない」「いつか俺たちの時代が来る」—そんな幼稚な選民思想に酔いしれていたのです。でも実際は、技術は手段であって目的ではないという当たり前のことから目を背け、自分の社会性のなさを「美学」で糊塗していただけでした。その結果として何を得たでしょうか。確かに一部の「同志」は得られました。でも多くの機会を失い、多くの人間関係を壊し、多くの成長のチャンスを逃してしまいました。譲れないもののために、譲るものを決めるやがて私は真剣に考えるようになりました。自分が本当に譲れないものは何か？私にとって譲れないのは技術的な誠実さ、つまり嘘はつかない、質の低いコードは書かないということ。そしてユーザーファースト、エンドユーザーの利益を最優先すること。さらに継続的な学習、常に新しいことを学び続けることでした。これ以外は、状況に応じて柔軟に対応することにしました。本質を守るために、形式では妥協する。これが私の新しい戦略でした。表現方法では本音を建前でオブラートに包むようになりました。タイミングも最適な時期を待つように。プロセスでは目的のためなら遠回りも受け入れ、形式的には無駄に見える会議や書類も必要なら対応するようになりました。他者と働く──「わかりあえなさ」から始める組織論 (NewsPicksパブリッシング)作者:宇田川元一ニューズピックスAmazon技術は手段、したたかに生きる戦略そしてもう一つ、重要な気づきがありました。技術は手段であって目的ではないということです。私自身、技術的な興味に駆動されています。新しい技術を学ぶことが楽しいし、エレガントなコードを書くことに喜びを感じます。正直に言えば、ビジネス価値なんてどうでもよくて、ただ面白い技術を触っていたいだけなのです。でも、お金をもらって仕事をする以上、建前上それが主目的とは言いづらい。だからこそ「したたかにやろうぜ」という考え方が大切なのです。個人にとって手段が目的でも良いともいます。しかし組織にとっては技術は手段であって目的ではないのです。つまり、組織が求める「成果」という枠組みを利用して、自分の技術的好奇心を満たすということ。表向きは「ビジネス価値の創出」を掲げながら、実際には「面白い技術で遊ぶ」ための正当性を確保する。これは嘘をついているのではなく、異なる価値観を持つ人々が共存するための知恵なのです。例えば、「パフォーマンス改善」という大義名分のもとで、最新のフレームワークを導入する。「開発効率の向上」という建前で、面白そうなツールチェーンを構築する。「技術的負債の解消」という錦の御旗を掲げて、自分が書きたいようにコードを書き直す。重要なのは、これらの建前が単なる口実ではなく、実際に価値を生み出すことです。新技術で遊びながら、本当にちゃんとパフォーマンスを改善する。好きなツールを使いながら、実際に開発効率を上げる。コードを書き直しながら、本当に保守性を向上させる。「プロフェッショナルとして責任を果たします」と胸を張りながら、心の中では「やった！これで堂々とRustが書ける！」と小躍りする。この二重構造こそが、エンジニアとしてのしたたかさです。組織は成果を得て満足し、私たちは技術的満足を得る。Win-Winの関係を作り出すこと。それは決して不誠実ではなく、むしろ異なる価値観を持つ者同士が、お互いの利益を最大化する賢明な戦略なのです。これは「技術への情熱」と「ビジネスへの責任」を両立させる、システムをハックする大人のやり方です。スタッフエンジニア　マネジメントを超えるリーダーシップ作者:Will Larson日経BPAmazonエンジニアとしてたぶん大切なこと今になってようやく分かります。エンジニアとして本当に大切なのは、技術力と人間力のバランス、そして戦略的なしたたかさだということが。技術的に正しいことを、相手が受け入れられる形で伝える。それは媚びることではなく、プロフェッショナルとしての基本的なスキルです。組織の制約を理解しながら、最適な解決策を見つける。それは妥協ではなく、現実的な問題解決能力です。異なる価値観を持つ人たちと協力して価値を生み出す。それは迎合ではなく、チームワークです。自分の意見を持ちながら、相手の意見にも耳を傾ける。それは弱さではなく、成熟した大人の態度です。そして何より、自分の技術的興味を満たしながら、組織の目的も達成する。このしたたかさこそが、長期的に見て最も賢い生き方だと思うのです。具体的に言えば、「セキュリティ強化」という名目で面白いツールを導入し、「運用効率化」という建前で自動化の仕組みを作り、「将来の拡張性」という理由で好きなアーキテクチャを採用する。でも重要なのは、これらが本当に価値を生み出すこと。セキュリティは本当に強化され、運用は本当に効率化され、システムは本当に拡張しやすくなる。つまり、自分の欲望と組織の利益を一致させる技術を身につけるということ。これは詐欺ではなく、むしろ最高のプロフェッショナリズムです。なぜなら、エンジニアが情熱を持って取り組んだ仕事こそが、最高の成果を生み出すからです。また、「媚びない」ことと「無礼」であることは全く違います。 前者は信念を持つことであり、後者は単なる社会性の欠如です。同様に、「したたか」であることと「ずる賢い」ことも違います。前者は双方の利益を最大化する戦略的思考であり、後者は単なる利己主義です。そして「技術への純粋な愛」と「ビジネスへの貢献」は対立するものではなく、うまくブレンドすることで、より強力な推進力になるのです。あと、技術士倫理綱領などを読むのもオススメです。今の私は、技術的な議論をする際も相手への敬意を忘れません。自分の意見を主張する際も、相手の立場を考慮します。SNSでの発言も、建設的で前向きなものを心がけています。そして、自分の技術的興味を追求しながら、それをビジネス価値に変換する方法を常に考えています。これは「売れた」「丸くなった」のではありません。ようやく大人になったのです。そして、本当の意味で強くなったのです。パーティーが終わって、中年が始まる作者:pha幻冬舎Amazonおわりに「お前も結局、体制に飲み込まれたのか」—かつての私なら、今の私をそう批判したでしょう。しかし、それでいいのです。技術的な純粋さを追求することと、社会的な成熟を遂げることは矛盾しません。むしろ、両方を兼ね備えてこそ、プロの仕事と言えるのではないでしょうか。私はもう「正義のエンジニア」ではありません。ただの、少しだけ成長したエンジニアです。技術への情熱は変わりませんが、それを表現する方法は大きく変わりました。そして、その情熱を現実世界で活かす術を身につけました。媚びないことと無礼の区別がつかなかった、頭の悪い反抗期は流石に終わりました。これからは、人としてちゃんとしたのを前提にしたエンジニアを目指します。正しいことを、正しい方法で、正しいタイミングで実現できるエンジニアに。そして、かつての私のような若いエンジニアを見かけたら、優しく、でもはっきりと伝えたいと思います。「君の気持ちはよく分かる。でも、もっといい方法があるよ。一緒にしたたかにやっていこうぜ」と。多分昔の私だったら「は？日和って迎合した負け犬が何言ってんの？」「技術を捨てて政治に走った元エンジニアの戯言でしょ」「そうやって妥協を重ねた結果が今のレガシーシステムなんだよ」とか思って、心の中で見下しながら表面上は「はい、参考にします」って適当に流すんでしょうね。まあ、それでいいんです。私も通った道だから。いつか痛い目に遭って、ようやく気づくでしょう。自分が単なる視野の狭いガキだったってことに。その時になって初めて、この言葉の意味が分かるはずです。けど大人として言う義務があるので言っておきました。","isoDate":"2025-07-05T04:24:11.000Z","dateMiliSeconds":1751689451000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"生成AIで小説を書くためにプロンプトの制約や原則について学ぶ / prompt-engineering-for-ai-fiction ","link":"https://speakerdeck.com/nwiizo/prompt-engineering-for-ai-fiction","contentSnippet":"諸君、聞かれよ。本日、私は「女オタ生成AIハッカソン2025夏東京」なる前代未聞の催しにて、生まれて初めて登壇することと相成った。かつての私は純朴なプログラマーであり、「変数名を30分悩んだ挙句、結局tmpにする」という、実に平凡な悩みを抱える程度の技術者であったのだ。\r\r歳月は容赦なく流れ、今や私はプロンプトエンジニアリングという名の魔境に足を踏み入れた哀れな求道者となり果てた。昨夜も丑三つ時まで、私は薄暗い書斎でディスプレイの冷たき光に照らされながら、「なぜ生成AIは『簡潔に』と百回唱えても、源氏物語の長文を生成するのか」という哲学的難題と格闘していたのである。\r\r30分という持ち時間に対し50枚のスライドを用意するという、まるで賽の河原で石を積む如き徒労に及んでいる。そのうち半分は「プロンプトという名の現代呪術における失敗例集」と題した、私の苦悩の結晶である。ああ、AIとの対話とは、かくも人間の正気を奪うものなのか。\r\r---\r\rブログも書いた。\r生成AIで物語を書くためにプロンプトの制約や原則について学ぶ、という話をしてきました #女オタ生成AI部\rhttps://syu-m-5151.hatenablog.com/entry/2025/06/30/171149","isoDate":"2025-06-29T04:00:00.000Z","dateMiliSeconds":1751169600000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Claude Code どこまでも/ Claude Code Everywhere","link":"https://speakerdeck.com/nwiizo/claude-everywhere","contentSnippet":"僕がClaude Codeに初めて触れたのは、2025年の春だった。生成AIにはすでに慣れ親しんでいた。流行に乗り遅れてはいけないと必死に勉強し、エディターの補完機能やコード生成ツールとして日常的に活用していた。ただ、当時の僕にとってそれはまだ「CLIで動く便利なコーディング支援ツール」程度の認識でしかなかった。「AIが90%のコードを自動生成」という謳い文句を見ても、半信半疑でターミナルを開いたのを覚えている。\r\rイベント名:【オフライン開催】KAGのLT会 #6 〜御社のエンジニア育成どうしてる!? スペシャル〜\r公式URL: https://kddi-agile.connpass.com/event/357862/\r\r「実装」から「設計」へのパラダイムシフト というより無限に体力が必要という話をした \rhttps://syu-m-5151.hatenablog.com/entry/2025/06/19/102529\r\r【参考文献】\r  - 公式ドキュメント\r    - Claude Code 公式サイト https://www.anthropic.com/claude-code\r    - Claude Code ドキュメント https://docs.anthropic.com/en/docs/claude-code/overview\r    - Claude Code Best Practices https://www.anthropic.com/engineering/claude-code-best-practices\r    - 抽象化をするということ - 具体と抽象の往復を身につける https://speakerdeck.com/soudai/abstraction-and-concretization\r    - How I Use Claude Code https://spiess.dev/blog/how-i-use-claude-code\r    - LLMの制約を味方にする開発術 https://zenn.dev/hidenorigoto/articles/38b22a2ccbeac6\r    - Claude Code版Orchestratorで複雑なタスクをステップ実行する https://zenn.dev/mizchi/articles/claude-code-orchestrator\r    - Agentic Coding Recommendations https://lucumr.pocoo.org/2025/6/12/agentic-coding/\r    - Claude Codeに保守しやすいコードを書いてもらうための事前準備 https://www.memory-lovers.blog/entry/2025/06/12/074355\r    - Claude Codeによる技術的特異点を見届けろ https://zenn.dev/mizchi/articles/claude-code-singularity-point","isoDate":"2025-06-18T04:00:00.000Z","dateMiliSeconds":1750219200000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"転職したらMCPサーバーだった件","link":"https://speakerdeck.com/nwiizo/zhuan-zhi-sitaramcpsabadatutajian","contentSnippet":"本日、Forkwell さんに悪ふざけに付き合ってもらってイベントやりました。ありがとうございます。「転職したらMCPサーバーだった件」 🎵🧭 というタイトルで登壇しました！\r\r🔍 イベント詳細:\r- イベント名: 転職したらMCPサーバーだった件\r- 公式URL: https://forkwell.connpass.com/event/354289/\r- ハッシュタグ: https://x.com/search?q=%23Forkwell_MCP\u0026f=live\r- 参考資料①: https://speakerdeck.com/nwiizo/kokohamcpnoye-ming-kemae\r- 参考資料②: https://syu-m-5151.hatenablog.com/entry/2025/03/09/020057\r- 参考資料③: https://speakerdeck.com/superbrothers/that-time-i-changed-jobs-as-a-kubernetes","isoDate":"2025-05-15T04:00:00.000Z","dateMiliSeconds":1747281600000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"ここはMCPの夜明けまえ","link":"https://speakerdeck.com/nwiizo/kokohamcpnoye-ming-kemae","contentSnippet":"本日、「AI駆動開発実践の手引き -これが僕/私のAI（アイ）棒」というイベントで「ここはMCPの夜明けまえ」 🎵🧭 というタイトルで登壇しました！\r\r🔍 イベント詳細:\r- イベント名: 【ハイブリッド開催】AI駆動開発実践の手引き -これが僕/私のAI（アイ）棒-\r- 公式URL: https://hack-at-delta.connpass.com/event/350588/\r\r📝 登壇ブログ\r- 2025年4月、AIとクラウドネイティブの交差点で語った2日間の記録 #CNDS2025 #hack_at_delta\r- https://syu-m-5151.hatenablog.com/entry/2025/04/24/113500","isoDate":"2025-04-23T04:00:00.000Z","dateMiliSeconds":1745380800000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"生成AIによるCloud Native基盤構築の可能性と実践的ガードレールの敷設について","link":"https://speakerdeck.com/nwiizo/sheng-cheng-ainiyorucloud-native-ji-pan-gou-zhu-noke-neng-xing-toshi-jian-de-gadorerunofu-she-nituite","contentSnippet":"こんにちは皆さん！本日はCloud Native Daysのプレイベントで登壇させていただきます。2019年以来の登壇となりますが、当時はまだ肩こりなんて無縁だったんですよね…。\r\r時の流れは容赦ないもので、最近の肩こりが辛くて昨日も整骨院に通ってきました。30分の持ち時間に対してスライドが80枚以上という暴挙にも出ています。\r\r---\r\r本日、「CloudNative Days Summer 2025 プレイベント」というイベントで「生成AIによるCloud Native 基盤構築の可能性と実践的ガードレールの敷設について」 🎵🧭 というタイトルで登壇しました！\r\r\r🔍 イベント詳細:\r- イベント名: CloudNative Days Summer 2025 プレイベント\r- 公式URL:https://cloudnativedays.connpass.com/event/351211/ \r- イベントのURL: https://event.cloudnativedays.jp/cnds2025\r\r📝 登壇ブログ\r- 2025年4月、AIとクラウドネイティブの交差点で語った2日間の記録 #CNDS2025 #hack_at_delta\r- https://syu-m-5151.hatenablog.com/entry/2025/04/24/113500","isoDate":"2025-04-22T04:00:00.000Z","dateMiliSeconds":1745294400000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Kubernetesで実現できるPlatform Engineering の現在地","link":"https://speakerdeck.com/nwiizo/kubernetesdeshi-xian-dekiruplatform-engineering-noxian-zai-di","contentSnippet":"本日、「Kubernetesで実践する Platform Engineering - FL#88」というイベントで「Kubernetesで実現できるPlatform Engineering の現在地」🎵🧭 というタイトルで登壇しました！\r\r🔍 イベント詳細:\r- イベント名: Kubernetesで実践する Platform Engineering - FL#88\r- 公式URL: https://forkwell.connpass.com/event/348104/\r\r🗣️ 関連スライド\r- インフラをつくるとはどういうことなのか、 あるいはPlatform Engineeringについて\r- https://speakerdeck.com/nwiizo/inhurawotukurutohadouiukotonanoka-aruihaplatform-engineeringnituite\r- Platform Engineeringは自由のめまい\r- https://speakerdeck.com/nwiizo/platform-engineeringhazi-you-nomemai","isoDate":"2025-03-25T04:00:00.000Z","dateMiliSeconds":1742875200000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"SLI/SLO・ラプソディあるいは組織への適用の旅","link":"https://speakerdeck.com/nwiizo/slorapusodeiaruihazu-zhi-henoshi-yong-nolu","contentSnippet":"こんにちは、花粉症が辛いです。登壇する時にくしゃみしないために朝から外出を自粛してます。15分なのにスライドが40枚あります。\r\r\r本日、「信頼性向上の第一歩！～SLI/SLO策定までの取り組みと運用事例～」というイベントで「SLI/SLO・ラプソディあるいは組織への適用の旅」🎵🧭 というタイトルで登壇しました！\r\r🔍 イベント詳細:\r- イベント名: 信頼性向上の第一歩！～SLI/SLO策定までの取り組みと運用事例～\r- 公式URL: https://findy.connpass.com/event/345990/\r\r📚 さらに！4日後の3月25日には翻訳した書籍に関する登壇する別イベントもあります！😲\r「Kubernetesで実践する Platform Engineering - FL#88」🐳⚙️\r興味がある方はぜひ参加してください！👨‍💻👩‍💻\r👉 https://forkwell.connpass.com/event/348104/\r\rお見逃しなく！🗓️✨","isoDate":"2025-03-20T04:00:00.000Z","dateMiliSeconds":1742443200000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"インフラをつくるとはどういうことなのか、 あるいはPlatform Engineeringについて","link":"https://speakerdeck.com/nwiizo/inhurawotukurutohadouiukotonanoka-aruihaplatform-engineeringnituite","contentSnippet":"2025年02月13日 Developers Summit 2025 13-E-4 にて「インフラをつくるとはどういうことなのか、 あるいはPlatform Engineeringについて - Platform Engineeringの効果的な基盤構築のアプローチ」というタイトルで登壇します。同日にPFEM特別回 でも登壇するのですが資料頑張って作ったのでそっちも読んでください。完全版は機会があればお話するので依頼してください。\r\rイベント名:  Developers Summit 2025\r\r公式URL: https://event.shoeisha.jp/devsumi/20250213\r\rセッションURL: https://event.shoeisha.jp/devsumi/20250213/session/5546\r\r登壇ブログ: https://syu-m-5151.hatenablog.com/entry/2025/02/14/071127","isoDate":"2025-02-13T05:00:00.000Z","dateMiliSeconds":1739422800000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Platform Engineeringは自由のめまい ","link":"https://speakerdeck.com/nwiizo/platform-engineeringhazi-you-nomemai","contentSnippet":"2025年02月13日 Kubernetesで実践するPlatform Engineering発売記念！ PFEM特別回にて「Platform Engineeringは自由のめまい - 技術の選択における不確実性と向き合う」というタイトルで登壇します。同日にDevelopers Summit 2025 でも登壇したのですが資料頑張って作ったのでそっちも読んでください。\r\rイベント名: Kubernetesで実践するPlatform Engineering発売記念！ PFEM特別回\r\r公式URL: https://platformengineering.connpass.com/event/342670/\r\r登壇ブログ: https://syu-m-5151.hatenablog.com/entry/2025/02/14/071127","isoDate":"2025-02-12T05:00:00.000Z","dateMiliSeconds":1739336400000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Site Reliability Engineering on Kubernetes","link":"https://speakerdeck.com/nwiizo/site-reliability-engineering-on-kubernetes","contentSnippet":"2025年01月26日 10:35-11:05（ルーム A）にて「Site Reliability Engineering on Kubernetes」というタイトルで登壇します。\r\rイベント名: SRE Kaigi 2025\r\r公式URL: https://2025.srekaigi.net/\r\rセッションURL: https://fortee.jp/sre-kaigi-2025/proposal/a75769d1-7835-4762-a1f6-508e714c8c8e\r\r登壇ブログ: https://syu-m-5151.hatenablog.com/entry/2025/01/26/005033","isoDate":"2025-01-26T05:00:00.000Z","dateMiliSeconds":1737867600000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"メインテーマはKubernetes","link":"https://speakerdeck.com/nwiizo/meintemahakubernetes","contentSnippet":"2024年16:20-17:00（Track A）にて「メインテーマはKubernetes」というタイトルで登壇します。\r\rイベント名: Cloud Native Days Winter 2024\r\r公式URL:https://event.cloudnativedays.jp/cndw2024/\r\rセッションURL:https://event.cloudnativedays.jp/cndw2024/talks/2373","isoDate":"2024-11-28T05:00:00.000Z","dateMiliSeconds":1732770000000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"SREの前に","link":"https://speakerdeck.com/nwiizo/srenoqian-ni","contentSnippet":"2024年11月06日(水) 18:00～19:00の予定に遅刻してしまい、大変申し訳ございませんでした。お詫びとして、当初非公開予定であった資料を公開させていただきます。元々、公開する予定ではなかったので補足が足りない部分などあると思いますのでご容赦下さい。\r\rブログなどで補足情報出すかもなので気になればフォローしてください\r- https://syu-m-5151.hatenablog.com/\r- https://x.com/nwiizo\r\r\rSREの前に - 運用の原理と方法論\r公式URL: https://talent.supporterz.jp/events/2ed2656a-13ab-409c-a1d9-df8383be25fd/","isoDate":"2024-11-06T05:00:00.000Z","dateMiliSeconds":1730869200000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"2024年版 運用者たちのLLM","link":"https://speakerdeck.com/nwiizo/2024nian-ban-yun-yong-zhe-tatinollm","contentSnippet":"Cloud Operator Days 2024 クロージングイベント\rhttps://cloudopsdays.com/closing/\r\rとても、端的に言うと「プロンプトエンジニアリングをしよう」って話。\rこの発表資料は、LLM（大規模言語モデル）によるIT運用の可能性と課題を探っています。AIOpsの概念を基に、LLMがインシデント対応、ドキュメンテーション、コード分析などの運用タスクをどのように改善できるかを説明しています。同時に、LLMの「幻覚」や不完全性といった課題も指摘し、適切な利用方法やプロンプトエンジニアリングの重要性を強調しています。\r\r登壇時ブログ\rhttps://syu-m-5151.hatenablog.com/entry/2024/09/06/154607","isoDate":"2024-09-06T04:00:00.000Z","dateMiliSeconds":1725595200000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Platform Engineering と SRE の門 ","link":"https://speakerdeck.com/nwiizo/platform-engineering-to-sre-nomen","contentSnippet":"Platform Engineering とSREの門 というタイトルで登壇しました。入門のタイポではありません。\r\rイベント名: Platform Engineering Kaigi 2024\rイベントURL:https://www.cnia.io/pek2024/\r\r登壇ブログ:『Platform Engineering とSREの門』という間違ったみたいなタイトルで登壇しました。 #PEK2024\rhttps://syu-m-5151.hatenablog.com/entry/2024/07/09/215147","isoDate":"2024-07-09T04:00:00.000Z","dateMiliSeconds":1720497600000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Observability Conference 2022 に登壇しました","link":"https://zenn.dev/nwiizo/articles/d837b78914de23","contentSnippet":"「Dapr の概念と実装から学ぶ Observability への招待」 というタイトルで登壇します。https://event.cloudnativedays.jp/o11y2022/talks/1382:embed:cite セッション概要Dapr は CloudNative な技術を背景に持つ分散アプリケーションランタイムです。本セッションでは Dapr の Observability に関する各種機能と、その実装について解説していきます。さらにスリーシェイクの Dapr と Observability への取り組みに関してもご紹介します。Dapr の機能でカバーできる点...","isoDate":"2022-03-11T04:02:18.000Z","dateMiliSeconds":1646971338000,"authorName":"nwiizo","authorId":"nwiizo"}]},"__N_SSG":true},"page":"/members/[id]","query":{"id":"nwiizo"},"buildId":"Jj9pZK7GvCPEg_YOHhVqy","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>