<!DOCTYPE html><html lang="ja"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon shortcut" type="image/png" href="https://blog.3-shake.com/logo.png"/><title>nwiizo | 3-shake Engineers&#x27; Blogs</title><meta property="og:title" content="nwiizo"/><meta property="og:url" content="https://blog.3-shake.com/members/nwiizo"/><meta name="twitter:card" content="summary_large_image"/><meta property="og:site" content="3-shake Engineers&#x27; Blogs"/><meta property="og:image" content="https://blog.3-shake.com/og.png"/><link rel="canonical" href="https://blog.3-shake.com/members/nwiizo"/><meta name="next-head-count" content="10"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/ca0df06cc4f85fc8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ca0df06cc4f85fc8.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-b671ab60a2eabb59.js" defer=""></script><script src="/_next/static/chunks/pages/_app-aef75d70891be704.js" defer=""></script><script src="/_next/static/chunks/983-dff3ac01648514cc.js" defer=""></script><script src="/_next/static/chunks/pages/members/%5Bid%5D-fa4563d96c58aa0a.js" defer=""></script><script src="/_next/static/pWqQdT762jR6uLoQbggIh/_buildManifest.js" defer=""></script><script src="/_next/static/pWqQdT762jR6uLoQbggIh/_ssgManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;500;700&family=Roboto:wght@300;400;500;700&display=swap">@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:normal;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0C4k.woff) format('woff')}@font-face{font-family:'Open Sans';font-style:normal;font-weight:500;font-stretch:normal;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjr0C4k.woff) format('woff')}@font-face{font-family:'Open Sans';font-style:normal;font-weight:700;font-stretch:normal;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsg-1y4k.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-stretch:normal;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFOMCnqEu92Fr1ME7kSn66aGLdTylUAMQXC89YmC2DPNWuaabWmQ.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-stretch:normal;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFOMCnqEu92Fr1ME7kSn66aGLdTylUAMQXC89YmC2DPNWubEbWmQ.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-stretch:normal;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFOMCnqEu92Fr1ME7kSn66aGLdTylUAMQXC89YmC2DPNWub2bWmQ.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-stretch:normal;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFOMCnqEu92Fr1ME7kSn66aGLdTylUAMQXC89YmC2DPNWuYjammQ.woff) format('woff')}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSKmu0SC55K5gw.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSumu0SC55K5gw.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSOmu0SC55K5gw.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSymu0SC55K5gw.woff2) format('woff2');unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTS2mu0SC55K5gw.woff2) format('woff2');unicode-range:U+0307-0308,U+0590-05FF,U+200C-2010,U+20AA,U+25CC,U+FB1D-FB4F}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTVOmu0SC55K5gw.woff2) format('woff2');unicode-range:U+0302-0303,U+0305,U+0307-0308,U+0310,U+0312,U+0315,U+031A,U+0326-0327,U+032C,U+032F-0330,U+0332-0333,U+0338,U+033A,U+0346,U+034D,U+0391-03A1,U+03A3-03A9,U+03B1-03C9,U+03D1,U+03D5-03D6,U+03F0-03F1,U+03F4-03F5,U+2016-2017,U+2034-2038,U+203C,U+2040,U+2043,U+2047,U+2050,U+2057,U+205F,U+2070-2071,U+2074-208E,U+2090-209C,U+20D0-20DC,U+20E1,U+20E5-20EF,U+2100-2112,U+2114-2115,U+2117-2121,U+2123-214F,U+2190,U+2192,U+2194-21AE,U+21B0-21E5,U+21F1-21F2,U+21F4-2211,U+2213-2214,U+2216-22FF,U+2308-230B,U+2310,U+2319,U+231C-2321,U+2336-237A,U+237C,U+2395,U+239B-23B7,U+23D0,U+23DC-23E1,U+2474-2475,U+25AF,U+25B3,U+25B7,U+25BD,U+25C1,U+25CA,U+25CC,U+25FB,U+266D-266F,U+27C0-27FF,U+2900-2AFF,U+2B0E-2B11,U+2B30-2B4C,U+2BFE,U+3030,U+FF5B,U+FF5D,U+1D400-1D7FF,U+1EE00-1EEFF}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTUGmu0SC55K5gw.woff2) format('woff2');unicode-range:U+0001-000C,U+000E-001F,U+007F-009F,U+20DD-20E0,U+20E2-20E4,U+2150-218F,U+2190,U+2192,U+2194-2199,U+21AF,U+21E6-21F0,U+21F3,U+2218-2219,U+2299,U+22C4-22C6,U+2300-243F,U+2440-244A,U+2460-24FF,U+25A0-27BF,U+2800-28FF,U+2921-2922,U+2981,U+29BF,U+29EB,U+2B00-2BFF,U+4DC0-4DFF,U+FFF9-FFFB,U+10140-1018E,U+10190-1019C,U+101A0,U+101D0-101FD,U+102E0-102FB,U+10E60-10E7E,U+1D2C0-1D2D3,U+1D2E0-1D37F,U+1F000-1F0FF,U+1F100-1F1AD,U+1F1E6-1F1FF,U+1F30D-1F30F,U+1F315,U+1F31C,U+1F31E,U+1F320-1F32C,U+1F336,U+1F378,U+1F37D,U+1F382,U+1F393-1F39F,U+1F3A7-1F3A8,U+1F3AC-1F3AF,U+1F3C2,U+1F3C4-1F3C6,U+1F3CA-1F3CE,U+1F3D4-1F3E0,U+1F3ED,U+1F3F1-1F3F3,U+1F3F5-1F3F7,U+1F408,U+1F415,U+1F41F,U+1F426,U+1F43F,U+1F441-1F442,U+1F444,U+1F446-1F449,U+1F44C-1F44E,U+1F453,U+1F46A,U+1F47D,U+1F4A3,U+1F4B0,U+1F4B3,U+1F4B9,U+1F4BB,U+1F4BF,U+1F4C8-1F4CB,U+1F4D6,U+1F4DA,U+1F4DF,U+1F4E3-1F4E6,U+1F4EA-1F4ED,U+1F4F7,U+1F4F9-1F4FB,U+1F4FD-1F4FE,U+1F503,U+1F507-1F50B,U+1F50D,U+1F512-1F513,U+1F53E-1F54A,U+1F54F-1F5FA,U+1F610,U+1F650-1F67F,U+1F687,U+1F68D,U+1F691,U+1F694,U+1F698,U+1F6AD,U+1F6B2,U+1F6B9-1F6BA,U+1F6BC,U+1F6C6-1F6CF,U+1F6D3-1F6D7,U+1F6E0-1F6EA,U+1F6F0-1F6F3,U+1F6F7-1F6FC,U+1F700-1F7FF,U+1F800-1F80B,U+1F810-1F847,U+1F850-1F859,U+1F860-1F887,U+1F890-1F8AD,U+1F8B0-1F8BB,U+1F8C0-1F8C1,U+1F900-1F90B,U+1F93B,U+1F946,U+1F984,U+1F996,U+1F9E9,U+1FA00-1FA6F,U+1FA70-1FA7C,U+1FA80-1FA89,U+1FA8F-1FAC6,U+1FACE-1FADC,U+1FADF-1FAE9,U+1FAF0-1FAF8,U+1FB00-1FBFF}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSCmu0SC55K5gw.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSGmu0SC55K5gw.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTS-mu0SC55I.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Open Sans';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSKmu0SC55K5gw.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Open Sans';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSumu0SC55K5gw.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Open Sans';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSOmu0SC55K5gw.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Open Sans';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSymu0SC55K5gw.woff2) format('woff2');unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:'Open Sans';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTS2mu0SC55K5gw.woff2) format('woff2');unicode-range:U+0307-0308,U+0590-05FF,U+200C-2010,U+20AA,U+25CC,U+FB1D-FB4F}@font-face{font-family:'Open Sans';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTVOmu0SC55K5gw.woff2) format('woff2');unicode-range:U+0302-0303,U+0305,U+0307-0308,U+0310,U+0312,U+0315,U+031A,U+0326-0327,U+032C,U+032F-0330,U+0332-0333,U+0338,U+033A,U+0346,U+034D,U+0391-03A1,U+03A3-03A9,U+03B1-03C9,U+03D1,U+03D5-03D6,U+03F0-03F1,U+03F4-03F5,U+2016-2017,U+2034-2038,U+203C,U+2040,U+2043,U+2047,U+2050,U+2057,U+205F,U+2070-2071,U+2074-208E,U+2090-209C,U+20D0-20DC,U+20E1,U+20E5-20EF,U+2100-2112,U+2114-2115,U+2117-2121,U+2123-214F,U+2190,U+2192,U+2194-21AE,U+21B0-21E5,U+21F1-21F2,U+21F4-2211,U+2213-2214,U+2216-22FF,U+2308-230B,U+2310,U+2319,U+231C-2321,U+2336-237A,U+237C,U+2395,U+239B-23B7,U+23D0,U+23DC-23E1,U+2474-2475,U+25AF,U+25B3,U+25B7,U+25BD,U+25C1,U+25CA,U+25CC,U+25FB,U+266D-266F,U+27C0-27FF,U+2900-2AFF,U+2B0E-2B11,U+2B30-2B4C,U+2BFE,U+3030,U+FF5B,U+FF5D,U+1D400-1D7FF,U+1EE00-1EEFF}@font-face{font-family:'Open Sans';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTUGmu0SC55K5gw.woff2) format('woff2');unicode-range:U+0001-000C,U+000E-001F,U+007F-009F,U+20DD-20E0,U+20E2-20E4,U+2150-218F,U+2190,U+2192,U+2194-2199,U+21AF,U+21E6-21F0,U+21F3,U+2218-2219,U+2299,U+22C4-22C6,U+2300-243F,U+2440-244A,U+2460-24FF,U+25A0-27BF,U+2800-28FF,U+2921-2922,U+2981,U+29BF,U+29EB,U+2B00-2BFF,U+4DC0-4DFF,U+FFF9-FFFB,U+10140-1018E,U+10190-1019C,U+101A0,U+101D0-101FD,U+102E0-102FB,U+10E60-10E7E,U+1D2C0-1D2D3,U+1D2E0-1D37F,U+1F000-1F0FF,U+1F100-1F1AD,U+1F1E6-1F1FF,U+1F30D-1F30F,U+1F315,U+1F31C,U+1F31E,U+1F320-1F32C,U+1F336,U+1F378,U+1F37D,U+1F382,U+1F393-1F39F,U+1F3A7-1F3A8,U+1F3AC-1F3AF,U+1F3C2,U+1F3C4-1F3C6,U+1F3CA-1F3CE,U+1F3D4-1F3E0,U+1F3ED,U+1F3F1-1F3F3,U+1F3F5-1F3F7,U+1F408,U+1F415,U+1F41F,U+1F426,U+1F43F,U+1F441-1F442,U+1F444,U+1F446-1F449,U+1F44C-1F44E,U+1F453,U+1F46A,U+1F47D,U+1F4A3,U+1F4B0,U+1F4B3,U+1F4B9,U+1F4BB,U+1F4BF,U+1F4C8-1F4CB,U+1F4D6,U+1F4DA,U+1F4DF,U+1F4E3-1F4E6,U+1F4EA-1F4ED,U+1F4F7,U+1F4F9-1F4FB,U+1F4FD-1F4FE,U+1F503,U+1F507-1F50B,U+1F50D,U+1F512-1F513,U+1F53E-1F54A,U+1F54F-1F5FA,U+1F610,U+1F650-1F67F,U+1F687,U+1F68D,U+1F691,U+1F694,U+1F698,U+1F6AD,U+1F6B2,U+1F6B9-1F6BA,U+1F6BC,U+1F6C6-1F6CF,U+1F6D3-1F6D7,U+1F6E0-1F6EA,U+1F6F0-1F6F3,U+1F6F7-1F6FC,U+1F700-1F7FF,U+1F800-1F80B,U+1F810-1F847,U+1F850-1F859,U+1F860-1F887,U+1F890-1F8AD,U+1F8B0-1F8BB,U+1F8C0-1F8C1,U+1F900-1F90B,U+1F93B,U+1F946,U+1F984,U+1F996,U+1F9E9,U+1FA00-1FA6F,U+1FA70-1FA7C,U+1FA80-1FA89,U+1FA8F-1FAC6,U+1FACE-1FADC,U+1FADF-1FAE9,U+1FAF0-1FAF8,U+1FB00-1FBFF}@font-face{font-family:'Open Sans';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSCmu0SC55K5gw.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Open Sans';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSGmu0SC55K5gw.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Open Sans';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTS-mu0SC55I.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Open Sans';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSKmu0SC55K5gw.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Open Sans';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSumu0SC55K5gw.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Open Sans';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSOmu0SC55K5gw.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Open Sans';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSymu0SC55K5gw.woff2) format('woff2');unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:'Open Sans';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTS2mu0SC55K5gw.woff2) format('woff2');unicode-range:U+0307-0308,U+0590-05FF,U+200C-2010,U+20AA,U+25CC,U+FB1D-FB4F}@font-face{font-family:'Open Sans';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTVOmu0SC55K5gw.woff2) format('woff2');unicode-range:U+0302-0303,U+0305,U+0307-0308,U+0310,U+0312,U+0315,U+031A,U+0326-0327,U+032C,U+032F-0330,U+0332-0333,U+0338,U+033A,U+0346,U+034D,U+0391-03A1,U+03A3-03A9,U+03B1-03C9,U+03D1,U+03D5-03D6,U+03F0-03F1,U+03F4-03F5,U+2016-2017,U+2034-2038,U+203C,U+2040,U+2043,U+2047,U+2050,U+2057,U+205F,U+2070-2071,U+2074-208E,U+2090-209C,U+20D0-20DC,U+20E1,U+20E5-20EF,U+2100-2112,U+2114-2115,U+2117-2121,U+2123-214F,U+2190,U+2192,U+2194-21AE,U+21B0-21E5,U+21F1-21F2,U+21F4-2211,U+2213-2214,U+2216-22FF,U+2308-230B,U+2310,U+2319,U+231C-2321,U+2336-237A,U+237C,U+2395,U+239B-23B7,U+23D0,U+23DC-23E1,U+2474-2475,U+25AF,U+25B3,U+25B7,U+25BD,U+25C1,U+25CA,U+25CC,U+25FB,U+266D-266F,U+27C0-27FF,U+2900-2AFF,U+2B0E-2B11,U+2B30-2B4C,U+2BFE,U+3030,U+FF5B,U+FF5D,U+1D400-1D7FF,U+1EE00-1EEFF}@font-face{font-family:'Open Sans';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTUGmu0SC55K5gw.woff2) format('woff2');unicode-range:U+0001-000C,U+000E-001F,U+007F-009F,U+20DD-20E0,U+20E2-20E4,U+2150-218F,U+2190,U+2192,U+2194-2199,U+21AF,U+21E6-21F0,U+21F3,U+2218-2219,U+2299,U+22C4-22C6,U+2300-243F,U+2440-244A,U+2460-24FF,U+25A0-27BF,U+2800-28FF,U+2921-2922,U+2981,U+29BF,U+29EB,U+2B00-2BFF,U+4DC0-4DFF,U+FFF9-FFFB,U+10140-1018E,U+10190-1019C,U+101A0,U+101D0-101FD,U+102E0-102FB,U+10E60-10E7E,U+1D2C0-1D2D3,U+1D2E0-1D37F,U+1F000-1F0FF,U+1F100-1F1AD,U+1F1E6-1F1FF,U+1F30D-1F30F,U+1F315,U+1F31C,U+1F31E,U+1F320-1F32C,U+1F336,U+1F378,U+1F37D,U+1F382,U+1F393-1F39F,U+1F3A7-1F3A8,U+1F3AC-1F3AF,U+1F3C2,U+1F3C4-1F3C6,U+1F3CA-1F3CE,U+1F3D4-1F3E0,U+1F3ED,U+1F3F1-1F3F3,U+1F3F5-1F3F7,U+1F408,U+1F415,U+1F41F,U+1F426,U+1F43F,U+1F441-1F442,U+1F444,U+1F446-1F449,U+1F44C-1F44E,U+1F453,U+1F46A,U+1F47D,U+1F4A3,U+1F4B0,U+1F4B3,U+1F4B9,U+1F4BB,U+1F4BF,U+1F4C8-1F4CB,U+1F4D6,U+1F4DA,U+1F4DF,U+1F4E3-1F4E6,U+1F4EA-1F4ED,U+1F4F7,U+1F4F9-1F4FB,U+1F4FD-1F4FE,U+1F503,U+1F507-1F50B,U+1F50D,U+1F512-1F513,U+1F53E-1F54A,U+1F54F-1F5FA,U+1F610,U+1F650-1F67F,U+1F687,U+1F68D,U+1F691,U+1F694,U+1F698,U+1F6AD,U+1F6B2,U+1F6B9-1F6BA,U+1F6BC,U+1F6C6-1F6CF,U+1F6D3-1F6D7,U+1F6E0-1F6EA,U+1F6F0-1F6F3,U+1F6F7-1F6FC,U+1F700-1F7FF,U+1F800-1F80B,U+1F810-1F847,U+1F850-1F859,U+1F860-1F887,U+1F890-1F8AD,U+1F8B0-1F8BB,U+1F8C0-1F8C1,U+1F900-1F90B,U+1F93B,U+1F946,U+1F984,U+1F996,U+1F9E9,U+1FA00-1FA6F,U+1FA70-1FA7C,U+1FA80-1FA89,U+1FA8F-1FAC6,U+1FACE-1FADC,U+1FADF-1FAE9,U+1FAF0-1FAF8,U+1FB00-1FBFF}@font-face{font-family:'Open Sans';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSCmu0SC55K5gw.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Open Sans';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTSGmu0SC55K5gw.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Open Sans';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/opensans/v40/memvYaGs126MiZpBA-UvWbX2vVnXBbObj2OVTS-mu0SC55I.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3GUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3iUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3CUBHMdazTgWw.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3-UBHMdazTgWw.woff2) format('woff2');unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMawCUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0302-0303,U+0305,U+0307-0308,U+0310,U+0312,U+0315,U+031A,U+0326-0327,U+032C,U+032F-0330,U+0332-0333,U+0338,U+033A,U+0346,U+034D,U+0391-03A1,U+03A3-03A9,U+03B1-03C9,U+03D1,U+03D5-03D6,U+03F0-03F1,U+03F4-03F5,U+2016-2017,U+2034-2038,U+203C,U+2040,U+2043,U+2047,U+2050,U+2057,U+205F,U+2070-2071,U+2074-208E,U+2090-209C,U+20D0-20DC,U+20E1,U+20E5-20EF,U+2100-2112,U+2114-2115,U+2117-2121,U+2123-214F,U+2190,U+2192,U+2194-21AE,U+21B0-21E5,U+21F1-21F2,U+21F4-2211,U+2213-2214,U+2216-22FF,U+2308-230B,U+2310,U+2319,U+231C-2321,U+2336-237A,U+237C,U+2395,U+239B-23B7,U+23D0,U+23DC-23E1,U+2474-2475,U+25AF,U+25B3,U+25B7,U+25BD,U+25C1,U+25CA,U+25CC,U+25FB,U+266D-266F,U+27C0-27FF,U+2900-2AFF,U+2B0E-2B11,U+2B30-2B4C,U+2BFE,U+3030,U+FF5B,U+FF5D,U+1D400-1D7FF,U+1EE00-1EEFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMaxKUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0001-000C,U+000E-001F,U+007F-009F,U+20DD-20E0,U+20E2-20E4,U+2150-218F,U+2190,U+2192,U+2194-2199,U+21AF,U+21E6-21F0,U+21F3,U+2218-2219,U+2299,U+22C4-22C6,U+2300-243F,U+2440-244A,U+2460-24FF,U+25A0-27BF,U+2800-28FF,U+2921-2922,U+2981,U+29BF,U+29EB,U+2B00-2BFF,U+4DC0-4DFF,U+FFF9-FFFB,U+10140-1018E,U+10190-1019C,U+101A0,U+101D0-101FD,U+102E0-102FB,U+10E60-10E7E,U+1D2C0-1D2D3,U+1D2E0-1D37F,U+1F000-1F0FF,U+1F100-1F1AD,U+1F1E6-1F1FF,U+1F30D-1F30F,U+1F315,U+1F31C,U+1F31E,U+1F320-1F32C,U+1F336,U+1F378,U+1F37D,U+1F382,U+1F393-1F39F,U+1F3A7-1F3A8,U+1F3AC-1F3AF,U+1F3C2,U+1F3C4-1F3C6,U+1F3CA-1F3CE,U+1F3D4-1F3E0,U+1F3ED,U+1F3F1-1F3F3,U+1F3F5-1F3F7,U+1F408,U+1F415,U+1F41F,U+1F426,U+1F43F,U+1F441-1F442,U+1F444,U+1F446-1F449,U+1F44C-1F44E,U+1F453,U+1F46A,U+1F47D,U+1F4A3,U+1F4B0,U+1F4B3,U+1F4B9,U+1F4BB,U+1F4BF,U+1F4C8-1F4CB,U+1F4D6,U+1F4DA,U+1F4DF,U+1F4E3-1F4E6,U+1F4EA-1F4ED,U+1F4F7,U+1F4F9-1F4FB,U+1F4FD-1F4FE,U+1F503,U+1F507-1F50B,U+1F50D,U+1F512-1F513,U+1F53E-1F54A,U+1F54F-1F5FA,U+1F610,U+1F650-1F67F,U+1F687,U+1F68D,U+1F691,U+1F694,U+1F698,U+1F6AD,U+1F6B2,U+1F6B9-1F6BA,U+1F6BC,U+1F6C6-1F6CF,U+1F6D3-1F6D7,U+1F6E0-1F6EA,U+1F6F0-1F6F3,U+1F6F7-1F6FC,U+1F700-1F7FF,U+1F800-1F80B,U+1F810-1F847,U+1F850-1F859,U+1F860-1F887,U+1F890-1F8AD,U+1F8B0-1F8BB,U+1F8C0-1F8C1,U+1F900-1F90B,U+1F93B,U+1F946,U+1F984,U+1F996,U+1F9E9,U+1FA00-1FA6F,U+1FA70-1FA7C,U+1FA80-1FA89,U+1FA8F-1FAC6,U+1FACE-1FADC,U+1FADF-1FAE9,U+1FAF0-1FAF8,U+1FB00-1FBFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3OUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3KUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3yUBHMdazQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3GUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3iUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3CUBHMdazTgWw.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3-UBHMdazTgWw.woff2) format('woff2');unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMawCUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0302-0303,U+0305,U+0307-0308,U+0310,U+0312,U+0315,U+031A,U+0326-0327,U+032C,U+032F-0330,U+0332-0333,U+0338,U+033A,U+0346,U+034D,U+0391-03A1,U+03A3-03A9,U+03B1-03C9,U+03D1,U+03D5-03D6,U+03F0-03F1,U+03F4-03F5,U+2016-2017,U+2034-2038,U+203C,U+2040,U+2043,U+2047,U+2050,U+2057,U+205F,U+2070-2071,U+2074-208E,U+2090-209C,U+20D0-20DC,U+20E1,U+20E5-20EF,U+2100-2112,U+2114-2115,U+2117-2121,U+2123-214F,U+2190,U+2192,U+2194-21AE,U+21B0-21E5,U+21F1-21F2,U+21F4-2211,U+2213-2214,U+2216-22FF,U+2308-230B,U+2310,U+2319,U+231C-2321,U+2336-237A,U+237C,U+2395,U+239B-23B7,U+23D0,U+23DC-23E1,U+2474-2475,U+25AF,U+25B3,U+25B7,U+25BD,U+25C1,U+25CA,U+25CC,U+25FB,U+266D-266F,U+27C0-27FF,U+2900-2AFF,U+2B0E-2B11,U+2B30-2B4C,U+2BFE,U+3030,U+FF5B,U+FF5D,U+1D400-1D7FF,U+1EE00-1EEFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMaxKUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0001-000C,U+000E-001F,U+007F-009F,U+20DD-20E0,U+20E2-20E4,U+2150-218F,U+2190,U+2192,U+2194-2199,U+21AF,U+21E6-21F0,U+21F3,U+2218-2219,U+2299,U+22C4-22C6,U+2300-243F,U+2440-244A,U+2460-24FF,U+25A0-27BF,U+2800-28FF,U+2921-2922,U+2981,U+29BF,U+29EB,U+2B00-2BFF,U+4DC0-4DFF,U+FFF9-FFFB,U+10140-1018E,U+10190-1019C,U+101A0,U+101D0-101FD,U+102E0-102FB,U+10E60-10E7E,U+1D2C0-1D2D3,U+1D2E0-1D37F,U+1F000-1F0FF,U+1F100-1F1AD,U+1F1E6-1F1FF,U+1F30D-1F30F,U+1F315,U+1F31C,U+1F31E,U+1F320-1F32C,U+1F336,U+1F378,U+1F37D,U+1F382,U+1F393-1F39F,U+1F3A7-1F3A8,U+1F3AC-1F3AF,U+1F3C2,U+1F3C4-1F3C6,U+1F3CA-1F3CE,U+1F3D4-1F3E0,U+1F3ED,U+1F3F1-1F3F3,U+1F3F5-1F3F7,U+1F408,U+1F415,U+1F41F,U+1F426,U+1F43F,U+1F441-1F442,U+1F444,U+1F446-1F449,U+1F44C-1F44E,U+1F453,U+1F46A,U+1F47D,U+1F4A3,U+1F4B0,U+1F4B3,U+1F4B9,U+1F4BB,U+1F4BF,U+1F4C8-1F4CB,U+1F4D6,U+1F4DA,U+1F4DF,U+1F4E3-1F4E6,U+1F4EA-1F4ED,U+1F4F7,U+1F4F9-1F4FB,U+1F4FD-1F4FE,U+1F503,U+1F507-1F50B,U+1F50D,U+1F512-1F513,U+1F53E-1F54A,U+1F54F-1F5FA,U+1F610,U+1F650-1F67F,U+1F687,U+1F68D,U+1F691,U+1F694,U+1F698,U+1F6AD,U+1F6B2,U+1F6B9-1F6BA,U+1F6BC,U+1F6C6-1F6CF,U+1F6D3-1F6D7,U+1F6E0-1F6EA,U+1F6F0-1F6F3,U+1F6F7-1F6FC,U+1F700-1F7FF,U+1F800-1F80B,U+1F810-1F847,U+1F850-1F859,U+1F860-1F887,U+1F890-1F8AD,U+1F8B0-1F8BB,U+1F8C0-1F8C1,U+1F900-1F90B,U+1F93B,U+1F946,U+1F984,U+1F996,U+1F9E9,U+1FA00-1FA6F,U+1FA70-1FA7C,U+1FA80-1FA89,U+1FA8F-1FAC6,U+1FACE-1FADC,U+1FADF-1FAE9,U+1FAF0-1FAF8,U+1FB00-1FBFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3OUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3KUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3yUBHMdazQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3GUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3iUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3CUBHMdazTgWw.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3-UBHMdazTgWw.woff2) format('woff2');unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMawCUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0302-0303,U+0305,U+0307-0308,U+0310,U+0312,U+0315,U+031A,U+0326-0327,U+032C,U+032F-0330,U+0332-0333,U+0338,U+033A,U+0346,U+034D,U+0391-03A1,U+03A3-03A9,U+03B1-03C9,U+03D1,U+03D5-03D6,U+03F0-03F1,U+03F4-03F5,U+2016-2017,U+2034-2038,U+203C,U+2040,U+2043,U+2047,U+2050,U+2057,U+205F,U+2070-2071,U+2074-208E,U+2090-209C,U+20D0-20DC,U+20E1,U+20E5-20EF,U+2100-2112,U+2114-2115,U+2117-2121,U+2123-214F,U+2190,U+2192,U+2194-21AE,U+21B0-21E5,U+21F1-21F2,U+21F4-2211,U+2213-2214,U+2216-22FF,U+2308-230B,U+2310,U+2319,U+231C-2321,U+2336-237A,U+237C,U+2395,U+239B-23B7,U+23D0,U+23DC-23E1,U+2474-2475,U+25AF,U+25B3,U+25B7,U+25BD,U+25C1,U+25CA,U+25CC,U+25FB,U+266D-266F,U+27C0-27FF,U+2900-2AFF,U+2B0E-2B11,U+2B30-2B4C,U+2BFE,U+3030,U+FF5B,U+FF5D,U+1D400-1D7FF,U+1EE00-1EEFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMaxKUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0001-000C,U+000E-001F,U+007F-009F,U+20DD-20E0,U+20E2-20E4,U+2150-218F,U+2190,U+2192,U+2194-2199,U+21AF,U+21E6-21F0,U+21F3,U+2218-2219,U+2299,U+22C4-22C6,U+2300-243F,U+2440-244A,U+2460-24FF,U+25A0-27BF,U+2800-28FF,U+2921-2922,U+2981,U+29BF,U+29EB,U+2B00-2BFF,U+4DC0-4DFF,U+FFF9-FFFB,U+10140-1018E,U+10190-1019C,U+101A0,U+101D0-101FD,U+102E0-102FB,U+10E60-10E7E,U+1D2C0-1D2D3,U+1D2E0-1D37F,U+1F000-1F0FF,U+1F100-1F1AD,U+1F1E6-1F1FF,U+1F30D-1F30F,U+1F315,U+1F31C,U+1F31E,U+1F320-1F32C,U+1F336,U+1F378,U+1F37D,U+1F382,U+1F393-1F39F,U+1F3A7-1F3A8,U+1F3AC-1F3AF,U+1F3C2,U+1F3C4-1F3C6,U+1F3CA-1F3CE,U+1F3D4-1F3E0,U+1F3ED,U+1F3F1-1F3F3,U+1F3F5-1F3F7,U+1F408,U+1F415,U+1F41F,U+1F426,U+1F43F,U+1F441-1F442,U+1F444,U+1F446-1F449,U+1F44C-1F44E,U+1F453,U+1F46A,U+1F47D,U+1F4A3,U+1F4B0,U+1F4B3,U+1F4B9,U+1F4BB,U+1F4BF,U+1F4C8-1F4CB,U+1F4D6,U+1F4DA,U+1F4DF,U+1F4E3-1F4E6,U+1F4EA-1F4ED,U+1F4F7,U+1F4F9-1F4FB,U+1F4FD-1F4FE,U+1F503,U+1F507-1F50B,U+1F50D,U+1F512-1F513,U+1F53E-1F54A,U+1F54F-1F5FA,U+1F610,U+1F650-1F67F,U+1F687,U+1F68D,U+1F691,U+1F694,U+1F698,U+1F6AD,U+1F6B2,U+1F6B9-1F6BA,U+1F6BC,U+1F6C6-1F6CF,U+1F6D3-1F6D7,U+1F6E0-1F6EA,U+1F6F0-1F6F3,U+1F6F7-1F6FC,U+1F700-1F7FF,U+1F800-1F80B,U+1F810-1F847,U+1F850-1F859,U+1F860-1F887,U+1F890-1F8AD,U+1F8B0-1F8BB,U+1F8C0-1F8C1,U+1F900-1F90B,U+1F93B,U+1F946,U+1F984,U+1F996,U+1F9E9,U+1FA00-1FA6F,U+1FA70-1FA7C,U+1FA80-1FA89,U+1FA8F-1FAC6,U+1FACE-1FADC,U+1FADF-1FAE9,U+1FAF0-1FAF8,U+1FB00-1FBFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3OUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3KUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3yUBHMdazQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3GUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3iUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3CUBHMdazTgWw.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3-UBHMdazTgWw.woff2) format('woff2');unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMawCUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0302-0303,U+0305,U+0307-0308,U+0310,U+0312,U+0315,U+031A,U+0326-0327,U+032C,U+032F-0330,U+0332-0333,U+0338,U+033A,U+0346,U+034D,U+0391-03A1,U+03A3-03A9,U+03B1-03C9,U+03D1,U+03D5-03D6,U+03F0-03F1,U+03F4-03F5,U+2016-2017,U+2034-2038,U+203C,U+2040,U+2043,U+2047,U+2050,U+2057,U+205F,U+2070-2071,U+2074-208E,U+2090-209C,U+20D0-20DC,U+20E1,U+20E5-20EF,U+2100-2112,U+2114-2115,U+2117-2121,U+2123-214F,U+2190,U+2192,U+2194-21AE,U+21B0-21E5,U+21F1-21F2,U+21F4-2211,U+2213-2214,U+2216-22FF,U+2308-230B,U+2310,U+2319,U+231C-2321,U+2336-237A,U+237C,U+2395,U+239B-23B7,U+23D0,U+23DC-23E1,U+2474-2475,U+25AF,U+25B3,U+25B7,U+25BD,U+25C1,U+25CA,U+25CC,U+25FB,U+266D-266F,U+27C0-27FF,U+2900-2AFF,U+2B0E-2B11,U+2B30-2B4C,U+2BFE,U+3030,U+FF5B,U+FF5D,U+1D400-1D7FF,U+1EE00-1EEFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMaxKUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0001-000C,U+000E-001F,U+007F-009F,U+20DD-20E0,U+20E2-20E4,U+2150-218F,U+2190,U+2192,U+2194-2199,U+21AF,U+21E6-21F0,U+21F3,U+2218-2219,U+2299,U+22C4-22C6,U+2300-243F,U+2440-244A,U+2460-24FF,U+25A0-27BF,U+2800-28FF,U+2921-2922,U+2981,U+29BF,U+29EB,U+2B00-2BFF,U+4DC0-4DFF,U+FFF9-FFFB,U+10140-1018E,U+10190-1019C,U+101A0,U+101D0-101FD,U+102E0-102FB,U+10E60-10E7E,U+1D2C0-1D2D3,U+1D2E0-1D37F,U+1F000-1F0FF,U+1F100-1F1AD,U+1F1E6-1F1FF,U+1F30D-1F30F,U+1F315,U+1F31C,U+1F31E,U+1F320-1F32C,U+1F336,U+1F378,U+1F37D,U+1F382,U+1F393-1F39F,U+1F3A7-1F3A8,U+1F3AC-1F3AF,U+1F3C2,U+1F3C4-1F3C6,U+1F3CA-1F3CE,U+1F3D4-1F3E0,U+1F3ED,U+1F3F1-1F3F3,U+1F3F5-1F3F7,U+1F408,U+1F415,U+1F41F,U+1F426,U+1F43F,U+1F441-1F442,U+1F444,U+1F446-1F449,U+1F44C-1F44E,U+1F453,U+1F46A,U+1F47D,U+1F4A3,U+1F4B0,U+1F4B3,U+1F4B9,U+1F4BB,U+1F4BF,U+1F4C8-1F4CB,U+1F4D6,U+1F4DA,U+1F4DF,U+1F4E3-1F4E6,U+1F4EA-1F4ED,U+1F4F7,U+1F4F9-1F4FB,U+1F4FD-1F4FE,U+1F503,U+1F507-1F50B,U+1F50D,U+1F512-1F513,U+1F53E-1F54A,U+1F54F-1F5FA,U+1F610,U+1F650-1F67F,U+1F687,U+1F68D,U+1F691,U+1F694,U+1F698,U+1F6AD,U+1F6B2,U+1F6B9-1F6BA,U+1F6BC,U+1F6C6-1F6CF,U+1F6D3-1F6D7,U+1F6E0-1F6EA,U+1F6F0-1F6F3,U+1F6F7-1F6FC,U+1F700-1F7FF,U+1F800-1F80B,U+1F810-1F847,U+1F850-1F859,U+1F860-1F887,U+1F890-1F8AD,U+1F8B0-1F8BB,U+1F8C0-1F8C1,U+1F900-1F90B,U+1F93B,U+1F946,U+1F984,U+1F996,U+1F9E9,U+1FA00-1FA6F,U+1FA70-1FA7C,U+1FA80-1FA89,U+1FA8F-1FAC6,U+1FACE-1FADC,U+1FADF-1FAE9,U+1FAF0-1FAF8,U+1FB00-1FBFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3OUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3KUBHMdazTgWw.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-stretch:100%;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v47/KFO7CnqEu92Fr1ME7kSn66aGLdTylUAMa3yUBHMdazQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><header class="site-header"><div class="content-wrapper"><div class="site-header__inner"><a class="site-header__logo-link" href="/"><img src="/logo.svg" alt="3-shake Engineers&#x27; Blogs" class="site-header__logo-img"/><span class="site-header__logo-text">3-shake<br/>Engineers&#x27; Blogs</span></a><div class="site-header__links"><a class="site-header__link" href="/feed.xml">RSS</a><a href="https://jobs-3-shake.com/" class="site-header__link">Recruit</a><a href="https://3-shake.com/" class="site-header__link">Company</a></div></div></div></header><section class="member"><div class="content-wrapper"><header class="member-header"><div class="member-header__avatar"><img src="/avatars/nwiizo.jpeg" alt="nwiizo" width="100" height="100" class="member-header__avatar-img"/></div><h1 class="member-header__name">nwiizo</h1><p class="member-header__bio">The Passionate Programmer</p><div class="member-header__links"><a href="https://twitter.com/nwiizo" class="member-header__link"><img src="/icons/twitter.svg" alt="Twitterのユーザー@nwiizo" width="22" height="22"/></a><a href="https://github.com/nwiizo" class="member-header__link"><img src="/icons/github.svg" alt="GitHubのユーザー@nwiizo" width="22" height="22"/></a><a href="https://nwiizo.github.io/" class="member-header__link"><img src="/icons/link.svg" alt="ウェブサイトのリンク" width="22" height="22"/></a></div></header><div class="member-posts-container"><div class="post-list"><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-01-29T03:04:46.000Z" class="post-link__date">2 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/01/29/120446" class="post-link__main-link"><h2 class="post-link__title">RustとYewでポモドーロタイマーを作ってみた</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a><div class="post-link__new-label">NEW</div></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-01-26T05:00:00.000Z" class="post-link__date">5 days ago</time></div></a><a href="https://speakerdeck.com/nwiizo/site-reliability-engineering-on-kubernetes" class="post-link__main-link"><h2 class="post-link__title">Site Reliability Engineering on Kubernetes</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=speakerdeck.com" width="14" height="14" class="post-link__site-favicon"/>speakerdeck.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-01-25T15:50:33.000Z" class="post-link__date">5 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/01/26/005033" class="post-link__main-link"><h2 class="post-link__title">SRE Kaigi 2025 で登壇してきます。 #srekaigi</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-01-21T03:41:30.000Z" class="post-link__date">10 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/01/21/124130" class="post-link__main-link"><h2 class="post-link__title">現代システムの三体問題「技術」「組織」「戦略」を巡る戦い - Architecture Modernization の読書感想文</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-01-15T02:08:31.000Z" class="post-link__date">16 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/01/15/110831" class="post-link__main-link"><h2 class="post-link__title">なんとなくRustで書いたNeovimプラグイン - cargo.nvim の話</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-01-12T11:21:20.000Z" class="post-link__date">18 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/01/12/202120" class="post-link__main-link"><h2 class="post-link__title">既にあるものを正しく使うあるいは、インフラストラクチャをつくるとはどういうことなのか</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-01-10T09:56:33.000Z" class="post-link__date">21 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/01/10/185633" class="post-link__main-link"><h2 class="post-link__title">年始にstarshipでプロンプトの式年遷宮を行いたい</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-01-10T04:38:52.000Z" class="post-link__date">21 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/01/10/133852" class="post-link__main-link"><h2 class="post-link__title">RustでのProtocol Buffersを学習するための図書管理システム実装</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-01-07T13:04:06.000Z" class="post-link__date">23 days ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/01/07/220406" class="post-link__main-link"><h2 class="post-link__title">NeovimをCursorのように進化させる - yetone/avante.nvim の導入</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2025-01-04T03:08:12.000Z" class="post-link__date">a month ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2025/01/04/120812" class="post-link__main-link"><h2 class="post-link__title">Rustで花火アニメーションと新年メッセージを作ろう</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-12-31T14:25:46.000Z" class="post-link__date">a month ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/12/31/232546" class="post-link__main-link"><h2 class="post-link__title">アーキテクチャ設計の民主化とADR(Architectural Decision Records)による意思決定の未来 - Facilitating Software Architecture の読書感想文</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-12-27T08:00:46.000Z" class="post-link__date">a month ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/12/27/170046" class="post-link__main-link"><h2 class="post-link__title">Clippyのすすめ - 他者の評価を気にせず何度でも指摘してくれる機械もしくは注意力の限界を超えてケアをしてくれる機械</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-12-27T05:45:09.000Z" class="post-link__date">a month ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/12/27/144509" class="post-link__main-link"><h2 class="post-link__title">「評論家気取り」という作る人の行き着く先が怖い</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-12-24T23:48:01.000Z" class="post-link__date">a month ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/12/25/084801" class="post-link__main-link"><h2 class="post-link__title">2024年 俺が愛した本たち 非技術書編(物語を除く)</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-12-23T08:47:50.000Z" class="post-link__date">a month ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/12/23/174750" class="post-link__main-link"><h2 class="post-link__title">2024年 俺が愛した本たち 技術書編</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-12-14T03:15:45.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/12/14/121545" class="post-link__main-link"><h2 class="post-link__title">初回実行が遅ければ遅延初期化でやればいいじゃない - RustのTUIアプリケーション改善</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-12-11T16:39:50.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/12/12/013950" class="post-link__main-link"><h2 class="post-link__title">Rust 再学習戦記</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-12-04T14:36:41.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/12/04/233641" class="post-link__main-link"><h2 class="post-link__title">Rustによる郵便番号検索API (yubin_api) の技術解説</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-12-03T14:00:30.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/12/03/230030" class="post-link__main-link"><h2 class="post-link__title">Rustで郵便番号・住所検索TUIツールを開発した - jposta</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-12-03T05:31:49.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/12/03/143149" class="post-link__main-link"><h2 class="post-link__title">退屈なことはRust Build Scripts にやらせよう</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-11-30T05:27:10.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/11/30/142710" class="post-link__main-link"><h2 class="post-link__title">3-shake Advent Calendar 2024 やっていきます #3SHAKE</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-11-28T05:00:00.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://speakerdeck.com/nwiizo/meintemahakubernetes" class="post-link__main-link"><h2 class="post-link__title">メインテーマはKubernetes</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=speakerdeck.com" width="14" height="14" class="post-link__site-favicon"/>speakerdeck.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-11-26T17:33:03.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/11/27/023303" class="post-link__main-link"><h2 class="post-link__title">Neovimのイベントタイミングガイド</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-11-26T15:43:09.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/11/27/004309" class="post-link__main-link"><h2 class="post-link__title">Rustでterraform plan/apply のターゲット指定を簡単にするツールを作ってみた - tfocusの仕組みと使い方</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-11-26T05:10:35.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/11/26/141035" class="post-link__main-link"><h2 class="post-link__title">RustでJSONを扱いたいのでSerde入門します</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-11-24T08:16:51.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/11/24/171651" class="post-link__main-link"><h2 class="post-link__title">私の為のNvChadのキーマッピングガイド</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-11-20T03:21:14.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/11/20/122114" class="post-link__main-link"><h2 class="post-link__title">先人の知見から学ぶ、その経験則</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-11-16T15:34:21.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/11/17/003421" class="post-link__main-link"><h2 class="post-link__title">#技育CAMPキャラバン in福岡🗣️で学生の質問に答えた。</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-11-11T02:02:23.000Z" class="post-link__date">3 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/11/11/110223" class="post-link__main-link"><h2 class="post-link__title">点でしかないものを線で見る為に - 「SREの前に」というタイトルで登壇しました。</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-11-06T05:00:00.000Z" class="post-link__date">3 months ago</time></div></a><a href="https://speakerdeck.com/nwiizo/srenoqian-ni" class="post-link__main-link"><h2 class="post-link__title">SREの前に</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=speakerdeck.com" width="14" height="14" class="post-link__site-favicon"/>speakerdeck.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-10-24T21:06:00.000Z" class="post-link__date">3 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/10/25/060600" class="post-link__main-link"><h2 class="post-link__title">技術がなければ作れない、必要がなければ存在している資格がない - Platform Engineering: A Guide for Technical, Product, and People Leaders の読書感想文</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/nwiizo"><img src="/avatars/nwiizo.jpeg" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">nwiizo</div><time dateTime="2024-10-15T01:15:16.000Z" class="post-link__date">4 months ago</time></div></a><a href="https://syu-m-5151.hatenablog.com/entry/2024/10/15/101516" class="post-link__main-link"><h2 class="post-link__title">「大規模システムの効率的運用の裏側」というイベントに登壇するのでどんなこと話すか整理する #aeon_tech_hub</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=syu-m-5151.hatenablog.com" width="14" height="14" class="post-link__site-favicon"/>syu-m-5151.hatenablog.com</div></a></article></div><div class="post-list-load"><button class="post-list-load__button">LOAD MORE</button></div></div></div></section><footer class="site-footer"><div class="content-wrapper"><p>© <!-- -->3-shake Inc.</p></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"member":{"id":"nwiizo","name":"nwiizo","role":"Software Developer","bio":"The Passionate Programmer","avatarSrc":"/avatars/nwiizo.jpeg","sources":["https://syu-m-5151.hatenablog.com/feed","https://zenn.dev/nwiizo/feed","https://speakerdeck.com/nwiizo.rss"],"includeUrlRegex":"","twitterUsername":"nwiizo","githubUsername":"nwiizo","websiteUrl":"https://nwiizo.github.io/"},"postItems":[{"title":"RustとYewでポモドーロタイマーを作ってみた","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/29/120446","contentSnippet":"はじめにイベントで定期的に登壇をしていて休日出勤したのに消化しきれなかった代休が余っていたので、3連休爆誕させて以前から興味のあったWebAssemblyの学習に時間を使ってみることにしました(いくつか本も読んだのでいつか紹介します。)。「とりあえず何か作ってみる」のが一番の近道だと考え、日々の私生活でも使えそうなポモドーロタイマーを実装することにしました。WebAssemblyのエコシステムを調べていく中で、RustのYewというフレームワークが目に留まりました。ReactライクなAPIでWebAssemblyアプリケーションが作れるとのことで、ちょっと開発することにしました。github.com使用技術の選定理由Rust：WebAssemblyのための優れたツールチェーンを持っており、学習コストは高めですが、型安全性と高いパフォーマンスが魅力でしたYew：ReactライクなAPIで、コンポーネントベースの開発が可能。フロントエンド開発者にとって親しみやすい設計になっていますTrunk：ビルドツールとして採用。trunk serveだけで開発サーバーが立ち上がる手軽さが気に入りました技術スタックRust (v1.75.0)Yew (v0.21)WebAssemblyTrunk (Bundler)プロジェクトの概要ポモドーロテクニックは25分の作業時間と5分の休憩を交互に行う時間管理手法です。今回実装したアプリケーションでは、以下の機能を提供します：基本的なタイマー機能25分のカウントダウン開始/停止/リセット制御視覚的なフィードバックタスク管理機能タスクの記録実際の作業時間の追跡完了したタスクの履歴管理データエクスポート機能マークダウン形式での出力クリップボードへのコピー機能実装の詳細プロジェクトのセットアップまず、必要なツールとターゲットをインストールします：rustup target add wasm32-unknown-unknowncargo install trunk主要なデータ構造タスクとタイマーの状態管理のための構造体：#[derive(Clone, Debug)]struct Task {    description: String,    completed_at: DateTime\u003cLocal\u003e,    duration: i32,}pub struct PomodoroTimer {    time: i32,    running: bool,    interval: Option\u003cInterval\u003e,    current_task: String,    completed_tasks: Vec\u003cTask\u003e,    initial_time: i32,    markdown_visible: bool,    markdown_content: String,}タイマー機能の実装Yewのコンポーネントシステムを利用して、タイマーの制御を実装しました：fn update(\u0026mut self, ctx: \u0026Context\u003cSelf\u003e, msg: Self::Message) -\u003e bool {    match msg {        Msg::Start =\u003e {            if !self.running {                let link = ctx.link().clone();                self.interval = Some(Interval::new(1000, move || {                    link.send_message(Msg::Tick);                }));                self.running = true;            }            true        }        // 他のメッセージハンドラ...    }}クリップボード機能の実装WebAssemblyからブラウザのクリップボードAPIを利用する実装：Msg::CopyToClipboard =\u003e {    if let Some(window) = window() {        let navigator = window.navigator();        let clipboard = navigator.clipboard();        let _ = clipboard.write_text(\u0026self.markdown_content);    }    true}開発で直面した課題と解決策WebAssemblyとブラウザAPIの連携課題：クリップボード機能の実装で型の不一致が発生解決：web-sysクレートの適切な機能を有効化し、型の変換を正しく処理状態管理とライフタイム課題：コンポーネントの状態管理でライフタイムエラーが発生解決：use_stateとuse_mut_refを適切に使い分けて実装セットアップと実行方法プロジェクトの作成：cargo new --lib yew-pomodorocd yew-pomodoro依存関係の追加（Cargo.toml）：[dependencies]yew = { version = \"0.21\", features = [\"csr\"] }gloo-timers = \"0.3\"web-sys = { version = \"0.3.64\", features = [\"console\", \"HtmlInputElement\", \"Window\", \"Navigator\", \"Clipboard\"] }wasm-bindgen = \"0.2\"chrono = \"0.4\"アプリケーションの実行：trunk serve開発を通じて学んだことWebAssemblyの基本概念JavaScriptとの連携方法パフォーマンスの最適化ポイントRustの特徴的な機能所有権システム型安全性の恩恵コンパイル時のエラーチェックの強力さフロントエンド開発での新しい視点パフォーマンスを意識したコンポーネント設計WebAssemblyならではの制約と利点所感代休を使って新しい技術に触れる時間が作れたのは、とても良い経験になりました。特に、JavaScriptで書いているような処理をRustで書き直してみることで、言語の特性や設計の違いについて深く考える機会になりました。WebAssemblyは確かにまだエコシステムが発展途上ですが、Yewのような成熟したフレームワークを使えば、実用的なアプリケーションを比較的スムーズに開発できることが分かりました。ソースコードプロジェクトのソースコードはGitHubで公開しています。コメントや改善案があれば、お気軽にIssueやPull Requestを送ってください。次のステップ今回の学習を通じて、WebAssemblyの可能性を実感できました。次は以下のような発展的な内容に挑戦してみたいと考えています：Rustの非同期処理を活用した機能拡張WebAssemblyのパフォーマンス測定と最適化より大規模なアプリケーションでの実践参考リンクRust公式ドキュメントYewドキュメントRustで始めるWebAssemblyMDN WebAssemblyガイド休暇を使って新しい技術に触れることで、普段の業務にも新しい視点を持ち込めそうです。皆さんも、空き時間を見つけて興味のある技術に触れてみてはいかがでしょうか。読んだ書籍Rustで学ぶWebAssembly――入門からコンポーネントモデルによる開発まで エンジニア選書作者:清水 智公技術評論社AmazonProgramming WebAssembly with Rust: Unified Development for Web, Mobile, and Embedded Applications (English Edition)作者:Hoffman, KevinPragmatic BookshelfAmazon","isoDate":"2025-01-29T03:04:46.000Z","dateMiliSeconds":1738119886000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Site Reliability Engineering on Kubernetes","link":"https://speakerdeck.com/nwiizo/site-reliability-engineering-on-kubernetes","contentSnippet":"2025年01月26日 10:35-11:05（ルーム A）にて「Site Reliability Engineering on Kubernetes」というタイトルで登壇します。\r\rイベント名: SRE Kaigi 2025\r\r公式URL: https://2025.srekaigi.net/\r\rセッションURL: https://fortee.jp/sre-kaigi-2025/proposal/a75769d1-7835-4762-a1f6-508e714c8c8e\r\r登壇ブログ: https://syu-m-5151.hatenablog.com/entry/2025/01/26/005033","isoDate":"2025-01-26T05:00:00.000Z","dateMiliSeconds":1737867600000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"SRE Kaigi 2025 で登壇してきます。 #srekaigi","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/26/005033","contentSnippet":"はじめにnwiizoです。2025年1月26日のSRE Kaigi 2025にて「Site Reliability Engineering on Kubernetes」というタイトルで登壇させていただきます。本イベントは「More SRE !」をテーマに、SREの知見共有と技術者の交流を目的とした技術カンファレンスです。2025.srekaigi.netこの発表資料を作成するきっかけとなったのは、私が翻訳に関わった「Kubernetesで実践する Platform Engineering」（2025年2月19日出版予定）の仕事でした。本書の翻訳作業を通じて、SREとPlatform Engineeringの密接な関係性、そしてKubernetesがこれらを実現する優れた基盤となることを改めて実感しました。Kubernetesで実践する Platform Engineering作者:Mauricio Salatino翔泳社Amazon発表資料 speakerdeck.com発表資料はSpeaker Deckで公開しています。イベントのテーマである「さらにSREを広めよう」に沿って、SREやKubernetesの未経験者でも理解しやすい実装例やアーキテクチャパターン、参考資料を用意しました。紹介したものは一例であり、これだけが唯一の正解ではありません。また、イベントにおける最初の発表なのでSREについての部分も多めに説明しています。こちら、Xでのポストなのでリポストなどしてもらえれば幸いです。👻SRE Kaigi 2025 にて「Site Reliability Engineering on Kubernetes」というタイトルで登壇します。こちら、資料になります。https://t.co/SLoohm83jy#srekaigi #srekaigi_a— nwiizo (@nwiizo) 2025年1月26日   今回の発表内容は、以下のような幅広いトピックをカバーしています：基本的な概念と実装SREの本質：システムの信頼性を制御する技術としてのSREKubernetesにおけるSRE原則の実践方法Cloud Nativeアプローチによる実装戦略具体的な実装手法包括的な可観測性の実現GitOpsを活用した変更管理の自動化と標準化Progressive Deliveryの実装と運用ノウハウインシデント対応と自動復旧の仕組み化最新ツールの活用事例CloudEventsによるイベント基盤の構築Keptn Lifecycle Toolkitを用いた品質管理Argo Rolloutsによるデプロイメント制御Crossplaneを活用したリソース管理の自動化プラットフォームの発展成熟度モデルに基づく段階的な改善開発者の認知負荷軽減に向けた取り組みデータドリブンな運用改善の実現方法手を動かすオススメハンズオン発表内容をより深く理解し、実践的なスキルを身につけるために、以下のハンズオンをお勧めします：github.comCloud Native Days主催のハンズオン教材です。KubernetesやCloud Nativeツールの基本的な使い方から応用まで、段階的に学べます。実際の運用シナリオに基づいた実践的な内容となっていますgithub.comPlatform Engineering on Kubernetesの実践的なガイドです。本書の著者が作成した、実装例とベストプラクティスを含むリポジトリです。一つ一つのコンポーネントを実際に動かしながら、プラットフォームの構築方法を学べます。これらのハンズオンを通じて、セッションで紹介する概念や技術を実際に試してみることをお勧めします。理論と実践を組み合わせることで、より深い理解と実装スキルを得ることができます。また、これらの教材は常にアップデートされているため、最新のベストプラクティスも学ぶことができます。おわりに本セッションは、かなり雑多な内容を30分に詰め込んだ欲張りな構成となっています。これは、現場によって異なるSREの課題や取り組みを幅広く共有したいという思いを反映したものです。特に強調したい点は以下の3つです：SREは単なるツールの導入ではなく、組織が信頼性を制御するための包括的な取り組みであることKubernetesは優れた基盤を提供するが、適切な設計と運用が必要不可欠であること適切なオープンソースツールを組み合わせることで、本格的なSRE実装が可能になることこのセッションが「さらにSREに関わる技術者の活躍の場を増やす」「さらにSREを理解し、興味を持っていただける技術者を増やす」という本イベントの目標に貢献できれば幸いです。セッションは2025年1月26日 10:35-11:05、ルームAで行われます。SREに関わる技術者の方々はもちろん、SREに興味を持ち始めた方々のご参加もお待ちしています。詳細は公式サイトでご確認いただけます。イベントに関する最新情報は、X（旧Twitter）の @srekaigi で発信されていますので、ぜひフォローしてください。多くの方々とSREについての知見を共有できることを楽しみにしています。","isoDate":"2025-01-25T15:50:33.000Z","dateMiliSeconds":1737820233000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"現代システムの三体問題「技術」「組織」「戦略」を巡る戦い - Architecture Modernization の読書感想文","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/21/124130","contentSnippet":"そう、どこなのか知ったら、世界が一枚の地図みたいに小さくなってしまう。どこなのか知らないほうが、世界を広く感じられる。(引用:三体 黒暗森林〈上〉P152)はじめに「Architecture Modernization」は、一見すると整然と並べられた章立てと体系的な解説を持つアーキテクチャ現代化のガイドブックのように見えます。しかし、その内実は現代のソフトウェア開発が抱える混沌とした課題に真正面から向き合い、そこから組織の持続的な競争力を構築するための、書籍です。本書は、アーキテクチャ現代化を単なる技術的な刷新を超えて、組織全体の変革を必要とする戦略的な取り組みとして位置付けています。それは時として、既存の組織構造や慣習との軋轢を生み出し、チームの価値観や働き方の根本的な見直しを迫ることにもなります。著者はそうした困難な課題に対して、EventStorming、Wardley Mapping、Team Topologiesといった手法を、その本質的な価値を深く理解した上で、実践的な知見と共に提示します。手法それぞれは、世の中で広く知られているものばかりですが、本書の真価は、これらの手法を組織の現代化という大きな文脈の中で有機的に結びつけ、包括的なアプローチを形作っている点にあります。どの章も一つの主題に対する深い考察と実践知に裏打ちされており、表面的な解説で済ませることはありません。それでいて、各章は独立した価値を持ちながら、全体として一つの強力な変革の方法論を形作っています。それは、著者がこの混沌とした現代のソフトウェア開発の課題に対して、明確な指針を示そうとする強い意志の表れでもあるのです。learning.oreilly.com現代化の重要性と課題私たちが直面するソフトウェア開発の課題は、年々複雑さを増しています。そしてシステムの複雑性は今後さらに加速度的に増大するでしょう。2024年に見られた生成AIの急速な進展は、技術革新がもたらす変化の速度と規模を如実に示しています。このような状況下で、レガシーシステムの制約は組織の存続を脅かすリスクとなり得ます。一方で、現代的なアーキテクチャは大きな競争優位性をもたらす可能性があります。新興企業の中には、最新のアーキテクチャを採用することで、わずか数ヶ月で大規模なプラットフォームを構築し、急成長を遂げた例も存在します。クラウドネイティブなアーキテクチャの採用により、市場投入までの時間を大幅に短縮し、迅速な価値提供を実現しているのです。しかし、技術革新それ自体が自動的に社会全体や組織の繁栄をもたらすわけではありません。過去1000年の歴史を振り返ると、技術革新の恩恵は往々にして一部の組織や個人に集中し、広く行き渡らないケースが多かったことがわかります。現代のソフトウェア開発においても、技術革新の成果をいかに組織全体で共有し、持続可能な価値創造につなげていくかという課題に向き合う必要があります。技術革新と不平等の1000年史　上作者:ダロン アセモグル,サイモン ジョンソン早川書房Amazon技術革新と不平等の1000年史　下作者:ダロン アセモグル,サイモン ジョンソン早川書房Amazon本書のアプローチ本書の独自性は、技術的な側面だけでなく、組織とビジネスの文脈でアーキテクチャを捉える包括的な視点にあります。特に重要なのは、Better Value Sooner Safer Happier (BVSSH)という概念を通じて、現代化がもたらす多面的な価値を評価するフレームワークを提供している点です。また、本書はDomain-Driven Design、Event Storming、Wardley Mappingなど、実践で検証された手法を効果的に組み合わせながら、組織の現代化を実現するための具体的なアプローチを提供します。特に注目すべきは、コラボレーティブな手法とチームの自律性を重視する現代的なアプローチが、今日のソフトウェア開発の最前線で求められる実践と整合している点です。読み進めていくと、一見すると「知っている」と思っていた概念や手法であっても、それらが体系的に整理され、より深い文脈の中で位置付けられていることに気づかされます。例えば、EventStormingやDDDといった手法については、多くの開発者が知っているものの、それらを組織の変革やビジネス価値の創出と結びつけて理解している人は少ないかもしれません。本書は、これらの「知っているつもりだった」内容に新しい光を当て、より実践的で戦略的な視点を提供してくれます。特筆すべきは、本書が扱う「技術」「組織」「戦略」の3つの柱のうち、「戦略」には技術戦略だけでなく、ビジネス戦略も深く含まれている点です。アーキテクチャの選択がビジネスモデルや市場での競争優位性にどのように影響するのか、という視点は、技術リーダーが経営層と建設的な対話を行う上で非常に有用です。また、本書の独自性は、技術的なベストプラクティスを単に羅列するのではなく、それらを他の文脈の中で捉え直している点にあります。読者は自身の経験を振り返りながら、「あのとき、こういう視点があれば...」という新しい発見を数多く経験することになるでしょう。以下、各章の分析を通じて、本書が提供する実践的な知見と、その現場での適用方法について詳しく見ていきましょう。Architecture Modernization: Socio-technical alignment of software, strategy, and structure (English Edition)作者:Tune, Nick,Perrin, Jean-GeorgesManningAmazon1 What is architecture modernization?第1章「What is architecture modernization?」は アーキテクチャ現代化の本質的な価値とその戦略的重要性を包括的に論じています。この章を通じて著者は アーキテクチャ現代化が単なる技術刷新ではなく ビジネスの競争優位性を確立するための戦略的な活動であることを具体的な事例とともに示しています。特に現代化への投資を躊躇することで発生する負のスパイラルと その打開策としての進化的アプローチの重要性は 実務者として強く共感できる内容です。ソフトウェアファースト第２版　あらゆるビジネスを一変させる最強戦略作者:及川 卓也日経BPAmazonアーキテクチャ現代化の必要性とリスクアーキテクチャ現代化の重要性は、ある大手航空会社の事例によって象徴的に示されています。2022年に発生した数十年前のスケジューリングシステムの障害は、1万4千便以上のフライトのキャンセルを引き起こし、ブランドに甚大なダメージを与えました。このような重大なインシデントは、時代遅れのレガシーアーキテクチャがビジネスリスクであり、競争上の不利益をもたらすことを如実に示しています。ソフトウェアアーキテクチャの基礎 ―エンジニアリングに基づく体系的アプローチ作者:Mark Richards,Neal FordオライリージャパンAmazon一方で、英国のある自動車販売スタートアップは、サーバーレスなどの現代的なアーキテクチャを採用することで、わずか90日でオンライン中古車販売プラットフォームを構築し、英国で最速のユニコーン企業となりました。この成功は、レガシーの制約がない状態で最新のテクノロジーを活用できることの価値を示しています。両社の対比は、現代的なアーキテクチャがもたらす競争優位性を鮮明に示しています。Figure 1.1 The negative cycle of declining architecture health より引用Figure 1.1は アーキテクチャ現代化への投資を先送りすることで発生する負のスパイラルを示しています。システムの健全性が低下し 現代化のコストが増大することで さらに経営層の投資判断が躊躇われるという悪循環です。この問題の深刻さは Adam TornhillとMarkus Borgの研究「Code Red: The Business Impact of Code Quality」によって定量的に示されています。彼らの調査では システムの技術的負債により開発者の時間の最大42%が無駄になっていると指摘しています。arxiv.orgさらに IoTデバイスの急増に象徴されるように システムの複雑性は年々増大しており この問題は今後さらに深刻化すると予想されます。2019年に86億台だったIoTデバイスは 2030年には300億台近くまで増加すると予測されています。このような複雑性の増大は 古いアーキテクチャの欠点と現代的なアーキテクチャの利点をさらに顕著にすると考えられます。learning.oreilly.comアーキテクチャ現代化の本質と価値創造著者は アーキテクチャの現代化を 社会技術的なアプローチとして捉えることの重要性を強調しています。これは NetflixのCTOであったAdrian Cockroftの言葉に端的に表れています。「四半期ごとのリリースしかできない企業は 日次デプロイメントを実現している競合他社に大きく引き離される」という彼の警告は 現代化の遅れが存在的な脅威となりうることを示しています。Netflixは2009年に モノリシックなアーキテクチャから数百のクラウドベースのマイクロサービスへと移行し オンラインストリーミング市場での競争優位性を確立しました。この事例は 確立された企業であっても適切な現代化戦略によって イノベーションのスピードを加速できることを証明しています。Figure 1.3 Better Value Sooner Safer Happier. (Source: Smart et al., Sooner Safer Happier: Antipatterns and Patterns for Business Agility [Portland, OR: IT Revolution 2020]) より引用Figure 1.3で示されるBetter Value Sooner Safer Happier (BVSSH)モデルは アーキテクチャ現代化が組織にもたらす価値を多面的に表現しています。Betterは品質改善による効率化と手戻りの削減 Valueは収益改善や顧客維持率の向上などのビジネス成果 Soonerは学習と価値提供の迅速化 Saferはガバナンス リスク セキュリティ コンプライアンスの確保 Happierは従業員満足度の向上を表します。このモデルは ステークホルダーのニーズをバランスよく考慮し 現代化の効果を包括的に評価するフレームワークとして機能します。独立した価値ストリームの重要性アーキテクチャ現代化の核となる概念が 独立した価値ストリーム (IVS) です。Figure 1.5は IVSの4つの主要特性を示しています。ドメイン整合性は特定のビジネスサブドメインとの整合 成果志向はビジネス成果への貢献 チームの権限委譲はプロダクトと技術の意思決定の自律性 ソフトウェアの疎結合は独立した開発・デプロイの実現を意味します。これらの特性が重要である理由は BVSSHの実現に直結するためです。適切なドメイン境界の設定は ビジネスにおける結合度を低減し 関連する概念をグループ化します。これにより ソフトウェアとチーム間の依存関係が減少し チーム間の調整や待ち時間が最小化されます。結果として 新機能の開発がより迅速になります。成果志向のアプローチは より良い価値の創出につながります。著名なプロダクトマネジメントの専門家であるMarty Caganが指摘するように「エンジニアをコーディングだけに使っているなら その価値の半分しか活用できていない」のです。チームにチューニングされた要件を与えるのではなく 達成すべき成果を示し 解決策の発見を委ねることで エンジニアの創造的な才能を最大限に引き出すことができます。著者は IVSを実現するための重要な手法として EventStorming を提唱しています。Figure 1.7は ドメインエキスパート 開発者 プロダクトマネージャー UXスペシャリストなど多様な関係者が協力してドメイン境界を特定するプロセスを示しています。このコラボレーティブなアプローチは 従来の中央集権的なアーキテクチャ設計からの大きな転換を意味します。多様な参加者の知見を活用することで より質の高いドメイン境界の特定が可能になります。進化的なアプローチとポートフォリオ思考アーキテクチャ現代化は 数年にわたる長期的な取り組みですが 著者は ポートフォリオ駆動の進化的アプローチを提唱しています。これは 現代化を単なる古いシステムの書き換えとしてではなく UX 製品機能、ビジネスプロセス、ドメインモデルを根本的に見直す機会として捉える考え方です。Figure 1.10 Identifying the optimal modernization return on investment per subdomain with the Modernization Strategy Selector より引用Figure 1.10で示される現代化戦略セレクターは 各サブドメインに対する最適な現代化投資を特定し 優先順位付けを行うためのツールです。すべてのサブドメインで同じレベルの投資が必要なわけではなく むしろそれは最高価値の現代化機会の実現を遅らせる原因となります。このツールは 各領域の特性に応じて適切な戦略を選択することを可能にします。Figure 1.11 Architecture modernization is parallel streams of work (not phases) supported by continuous learning and upskilling. より引用著者は 現代化を【発見】【設計】【実装】の3つの並行ストリームとして捉えることを提案しています。Figure 1.11は これらのストリームが相互に影響を与えながら継続的に進化していく様子を示しています。この並行性こそが進化的アプローチを可能にする要因です。あるストリームでの発見が次の四半期の実装に影響を与え 実装での学びが次の設計に反映されるという具合です。特に 継続的な学習とスキル向上を現代化の基盤として位置付けている点は注目に値します。これは チームが新しい考え方や手法を習得し 実践する時間と機会を確保することの重要性を示しています。学習と実践の機会が不足すると 古い思考パターンのまま新しいアーキテクチャを設計してしまい その欠陥が引き継がれるリスクがあります。著者は この進化的なアプローチを支援するために Architecture Modernization Enabling Team (AMET) の設置を推奨しています。AMETは従来のアーキテクチャチームとは異なり 意思決定を行うのではなく 他のチームを支援し 現代化の持続的な改善を促進する役割を担います。これは 現代化のモメンタムを維持し 現代化終了後も持続可能な改善を実現するための重要な施策です。まとめ第1章は アーキテクチャ現代化を包括的な視点で捉え その本質と実践的なアプローチを示しています。とある組織の対比を通じて現代化の重要性を示し BVSSHモデルによって現代化の多面的な価値を明確化しています。IVSという概念を通じて現代化を実現するための具体的な方法論を提供し 進化的アプローチとポートフォリオ思考の重要性を強調することで 現代化を持続可能な取り組みとして位置付けています。本章は 現代のソフトウェア開発組織がアーキテクチャ現代化に取り組む際の 実践的かつ戦略的なガイドラインを提供していると評価できます。アーキテクチャ現代化が 技術的な刷新を超えて 組織の競争力を根本的に強化する戦略的な取り組みであることを 説得力をもって示している点は 特に印象的です。また コラボレーティブな手法とチームの自律性を重視する現代的なアプローチは 今日のソフトウェア開発の最前線で求められる実践と整合しています。2 Preparing for the journey第2章「Preparing for the journey」は アーキテクチャ現代化の旅を始める前に考慮すべき重要な準備と課題について包括的に論じています。著者は 組織の準備状況の評価から新しいアーキテクチャ思考の導入 そしてリーダーシップの重要性に至るまで 現代化への取り組みを成功に導くための具体的なガイダンスを提供しています。リーダーシップの準備著者は まず リーダーシップの準備状況 を評価することの重要性を強調しています。新機能の開発を一時的に減速させてまで現代化に投資する覚悟 レガシーシステムの複雑さと変更の困難さの理解 予期せぬ遅延やコスト増加への対応 資金調達モデルや優先順位付けプロセスの変更への準備など リーダーシップチームが直面する重要な課題を詳細に説明しています。特に重要なのは 学習と能力開発への投資です。著者は 現代化が一時的なワークショップやトレーニングコースではなく 継続的な財務的・時間的投資を必要とすることを強調しています。これは 必要なスキルを持つ人材を大量に雇用することでも解決できない問題です。新しい従業員は会社のドメイン システム 文化を学ぶ必要があり それには数ヶ月を要します。スタッフエンジニア　マネジメントを超えるリーダーシップ作者:Will Larson日経BPAmazon新しいアーキテクチャ思考の導入著者は コンウェイの法則 の重要性を強調しています。システムの設計は それを設計・構築する組織のコミュニケーション構造を反映するという原則です。Figure 2.1は 緩やかに結合されたドメイン境界が緩やかに結合されたソフトウェアアーキテクチャを可能にすることを示しています。これは チームが単一のビジネスサブドメインに整合した単一のコードベースで作業できることを意味します。Figure 2.1 Fast flow requires loosely coupled software architecture, which requires loosely coupled domains. より引用コラボレーティブなアーキテクチャ実践の採用も重要な課題です。著者は イベントストーミングなどの現代的な手法を早期に導入し その受け入れ状況を理解することを推奨しています。これらの手法は 伝統的なトップダウンのアプローチとは大きく異なり あらゆる分野の関係者が協力してドメイン境界を特定し 最適なソリューションを選択します。銀の弾丸及び金槌への警告著者は 「ボルトオン現代化」への警告を発しています。これは 根本的なアーキテクチャ上の課題に取り組まず システムの表面的な部分だけを変更するアプローチです。著者は政府サービスの構築での経験を引用し レガシーシステムやデータベースとの統合が残されたままでは 真の改善が実現できないことを示しています。情報を正しく選択するための認知バイアス事典作者:情報文化研究所フォレスト出版Amazon同様に 構造とプロセスの誤謬にも注意を促しています。組織構造の変更や新しいプロセスの採用だけでは 深い変化なしには大きな改善は望めません。チームワークの促進 製品決定の権限委譲 ビジネス・IT間の壁の解消 資金調達モデルの変更 技術品質への投資など 包括的な変更が必要です。ICEの事例から学ぶ成功要因著者は ICEの現代化事例を通じて 実践的な成功要因を示しています。ICEは ドメイン駆動設計とEventStormingを活用してドメインを理解し ストラングラーパターンを用いた段階的な移行を計画しました。その結果 データ取り込み処理時間の80%削減 新規サービスプロバイダーのオンボーディング時間の大幅短縮 マッチング生産性の5倍向上など 顕著な成果を達成しました。www.iceservices.com重要なのは この成功が技術的な側面だけでなく 社会的な側面への取り組みによって実現されたことです。チームの権限委譲 クロスファンクショナルな協力 製品中心の資金調達モデルへの移行など 組織的な変革が成功の鍵となりました。リーダーシップの多層的な展開最後に著者は あらゆるレベルでのリーダーシップの重要性を強調しています。ビジネス戦略の理解と貢献 現代化戦略の定義 アーキテクチャの設計と進化 組織構造の確立 ビジョンと進捗の伝達など 現代化のリーダーには多くの責任があります。これらの責任は単一のスーパーヒーローや小グループだけでは担えません。著者は Architecture Modernization Enabling Team (AMET) の設置を提案し リーダーシップの育成と支援の具体的な方法を示しています。AMETは 組織全体の現代化能力を高め 持続的な改善を確立することに焦点を当てます。リーダーの仮面――「いちプレーヤー」から「マネジャー」に頭を切り替える思考法作者:安藤 広大ダイヤモンド社Amazonまとめ第2章は 現代化の旅を成功に導くための準備と課題を包括的に論じています。リーダーシップの準備、新しいアーキテクチャ思考の導入、銀の弾丸への警告 そして多層的なリーダーシップの重要性という4つの主要な側面から 具体的なガイダンスを提供しています。特に印象的なのは ICEの事例を通じて これらの原則が実践でどのように機能するかを示している点です。現代化は技術的な変革を超えた組織全体の取り組みであり その成功には包括的な準備と持続的な支援が不可欠であることを 説得力を持って論じています。3 Business objectives第3章「Business objectives」は アーキテクチャ現代化の投資判断とビジネス成果の関係性について包括的に論じています。本章を通じて著者は 設計の選択がビジネスの競争優位性と成長戦略にどのように影響するかを 具体的な事例とともに示しています。この章で議論されている「アーキテクチャ現代化の投資判断とビジネス成果の関係性」は、日本のIT業界ではあまり明示的に語られてこなかった文脈です。日本では技術的負債の解消や保守性の向上といった技術的な観点からの議論が中心で、ビジネスの競争優位性や成長戦略との結びつけは比較的最近になって注目され始めた領域と言えます。日本だとこの本を思い出した。みずほ銀行システム統合、苦闘の19年史　史上最大のITプロジェクト「3度目の正直」作者:日経コンピュータ,山端 宏実,岡部 一詩,中田 敦,大和田 尚孝,谷島 宣之日経BPAmazonビジネス観点からの現代化の必要性著者は現代化投資の判断基準として7つのビジネスシナリオを提示しています。市場におけるスピード競争の激化への対応や ビジネス成長の阻害要因の解消 出口戦略の実現など 経営視点に立った明確な指標が示されています。特に印象的なのは より速く動く競合他社への対応に関する指摘です。成功体験による慣性が イノベーションへの意欲を低下させる一方で 新規参入者は最新技術とアプローチを活用し 大胆なリスクテイクが可能です。この非対称性が大企業にとって脅威となることを著者は警告しています。戦略の要諦 (日本経済新聞出版)作者:リチャード・Ｐ・ルメルト日経BPAmazon金融サービス企業の事例では この課題が具体的に示されています。市場リーダーだった同社は セキュリティと安定性を重視するあまり リスクを回避する文化が定着していました。しかし 新興企業の参入により 優れたユーザー体験を持つサービスが登場し 市場シェアを脅かされる事態となりました。最終的に同社は新CTOを迎え 現代化への投資を決断しましたが その過程では多くの組織的な課題に直面しています。著者は 一度成功した企業が陥りやすい罠も指摘しています。成功体験による慣性は イノベーションへのモチベーションを低下させ 結果として技術的負債の蓄積を加速させます。これは 技術的負債の負のスパイラルと呼ぶべき状況を生み出します。一方で OpenTableの事例は この課題に対する前向きな取り組みを示しています。同社は競合の脅威を早期に認識し 全面的な現代化投資を実行することで 開発生産性の大幅な向上を実現しました。www.opentable.comUXと内部プロセスの現代化著者は 現代化の必要性がユーザー体験にも直結することを指摘しています。特に重要なのは 信頼性の欠如がブランドに与えるダメージです。レンタカー予約システムの事例では 技術的な問題が原因で同じ予約が3回重複して行われ 顧客の信頼を大きく損なう結果となりました。内部システムの非効率性も深刻な課題です。従業員が複数のレガシーシステムを使い分けざるを得ない状況は 業務効率の低下だけでなく 従業員の満足度にも悪影響を及ぼします。さらに 新規採用した従業員の教育コストも増大し 組織の成長を阻害する要因となります。成長戦略と現代化の関係性著者はマトリクスを用いて 4つの成長戦略と現代化の関係性を整理しています。既存市場での新製品開発では 共有機能の抽出とシステム統合が重要な課題となります。欧州の海洋機器メーカーの事例は この課題を端的に示しています。同社はIoTプラットフォームの開発を目指しましたが レガシーシステムの制約により 目標とする処理性能を達成できない事態に陥りました。既存製品での市場浸透では システムの最適化と運用コスト削減が焦点となります。ラテンアメリカのチャレンジャーバンクの事例は この視点からの現代化を示しています。同社は優れたUXにより市場での地位を確立しましたが 事業の拡大に伴いカスタマーサポートのコストが線形に増加する課題に直面しました。現代化は この課題を解決するための戦略的な投資として位置づけられています。戦略的指標としてのノーススター著者は戦略目標を表す指標として ノーススターメトリクス(NSM)の活用を提案しています。NSMは顧客への本質的な価値を表現し 組織の戦略と整合する数値目標です。これは単なる技術指標ではなく ビジネス成果と直結した指標である必要があります。Figure 3.2 Amplitude’s north star framework より引用Figure 3.2は Amplitudeのノーススターフレームワークを示しています。このフレームワークは インプットメトリクスからノーススターメトリクスを経て ビジネス成果に至る価値の流れを可視化します。これにより 現代化の取り組みと事業価値の関係を明確にすることが可能となります。DanseBank社の事例では このフレームワークを活用して PSD2対応の本質的な価値を「取引履歴に基づく迅速な与信判断」と定義しています。同社はエンジニアを含む横断的なチームで エンパシーマップを活用した顧客理解を進め 規制対応という表面的な目標を超えて 顧客価値の創造という本質的な目標を見出すことに成功しています。M\u0026Aと現代化の課題現代化の文脈で特に重要なのが M\u0026Aへの対応です。Salesforceの事例は この課題を端的に示しています。同社はSlackやGitHubなど 複数の大規模な買収を実行していますが それぞれの企業が異なる技術スタックとインフラを持つため システム統合に大きな課題を抱えています。このような状況では ドメイン境界の再定義が重要な課題となります。単なるシステム統合を超えて 製品やドメインの本質的な再定義が必要となるケースも少なくありません。これは技術的な課題であると同時に 組織的な挑戦でもあります。出口戦略としての現代化著者は 出口戦略を目指す企業における現代化の特殊性も指摘しています。IPOや買収を目指す企業では 2-3年という限られた時間軸での投資判断が求められます。この場合 長期的な技術的負債の解消よりも 短期的な価値の創出が優先される傾向があります。しかし著者は このアプローチにも一定の合理性があることを認めています。投資の時間軸を明確にすることで 優先順位の設定が容易になり より効果的な現代化が可能になる場合もあります。重要なのは 短期的な価値創出と長期的な技術的健全性のバランスを適切に取ることです。まとめ本章は 現代化への投資判断をビジネスの文脈で捉え 具体的な評価基準と実践方法を提示しています。特に ノーススターメトリクスの活用は 技術的な取り組みとビジネス成果を結びつける効果的な手法として注目に値します。また各種事例は 現代化が組織全体の変革として成功するための具体的なアプローチを示しています。著者の主張の本質は アーキテクチャ現代化を単なる技術刷新ではなく 組織の戦略的な変革として捉える点にあります。その成功には ビジネス戦略との整合性 投資判断の明確な基準 そして組織全体での価値共有が不可欠です。特に重要なのは 現場のエンジニアが顧客価値を深く理解し その実現に向けて主体的に取り組める環境の構築です。DanseBank社のエンパシーマップの活用は この理想的な姿を具体的に示しています。読者は 本章を通じて アーキテクチャ現代化を戦略的な投資として位置づけ その判断基準と実践方法を学ぶことができます。特に 技術的な観点とビジネス的な観点を結びつける具体的な手法は 実務での活用価値が高いと考えられます。今日のソフトウェア開発組織において アーキテクチャ現代化は避けて通れない課題となっています。本章は その取り組みを成功に導くための実践的なガイドラインを提供しているといえるでしょう。4 Listening and mapping tours第4章「Listening and mapping tours」は アーキテクチャ現代化の始め方に焦点を当てています。著者は まず聞くこと（listening）から始めるという基本姿勢を強調し その実践的なアプローチを提示しています。この章を通じて 組織全体の状況を把握し 実行可能な現代化戦略を策定するための体系的な手法が示されています。この構成は、アーキテクチャ現代化が本質的に技術的な課題である以上に、人々の協力と理解を必要とする社会的な取り組みであることを示唆しています。技術的な解決策がいかに優れていても、それを実現する人々の協力が得られなければ、現代化の取り組みは成功しないという現実を反映しています。「変化を嫌う人」を動かす:魅力的な提案が受け入れられない4つの理由作者:ロレン・ノードグレン,デイヴィッド・ションタル,船木 謙一(監修)草思社Amazonリスニングツアーの本質と準備著者は アーキテクチャ現代化の開始時に陥りがちな罠を指摘しています。多くの組織では 事前に用意した解決策を提案し その説得に注力しがちです。しかし このアプローチは組織の実態を十分に理解しないまま 表面的な解決策に走るリスクがあります。著者は この罠を回避するために リスニングツアーという手法を提案しています。リスニングツアーは 経営層から現場の開発者まで幅広い関係者と対話を行い 組織の課題と可能性を深く理解するプロセスです。特に重要なのは 単なるヒアリングではなく 関係者との信頼関係を構築し 組織の本質的な課題を浮き彫りにする点です。リスニングツアーの実施主体として 著者は AMET（Architecture Modernization Enabling Team）の設置を推奨しています。AMETは 技術とビジネスの両方を理解するメンバーで構成され 現代化のビジョン策定から実行支援までを担います。特に重要なのは チーム内で得られた知見を共有し 一貫した理解を構築する能力です。効果的なリスニングの実践リスニングツアーの成功には いくつかの重要な要素があります。最も基本的なのは 安全な対話の場の創出です。著者は 威圧的な空間ではなく 自由な対話が可能な環境づくりの重要性を説いています。これは カジュアルな場所の選択や 適切なタイミングの設定など 細かな配慮の積み重ねによって実現されます。同様に重要なのが 質問のデザインです。著者は 直接的な質問だけでなく より深い洞察を引き出すための多様な質問形式を提案しています。例えば「Complete the sentence（文章の完成）」では「私の仕事で現在最も腹が立つことは_____です」といった形式で 感情的な側面も含めた本音を引き出すことができます。問いの編集力 思考の「はじまり」を探究する作者:安藤昭子ディスカヴァー・トゥエンティワンAmazonまた「Choose an emotion（感情の選択）」では 感情のホイールから特定のトピックに対する感情を選ぶことで より深い理解を促進します。「Pick an image（画像の選択）」では 視覚的な表現を通じて 言葉では表現しにくい認識や感覚を共有することが可能になります。ツールボックスの活用効果的なリスニングツアーには 適切なツールの活用も重要です。著者は Impact Mappingを用いてビジネス目標とその実現手段の関係を可視化することを提案しています。これにより 戦略的な優先順位付けと 具体的な施策の選定が容易になります。Figure 4.4 A C4 container diagram with multiple risks identified より引用Risk Stormingは システムのリスクを特定し評価するための効果的なツールです。C4モデルをベースに システムの構造とリスクの関係を可視化することで 技術的な課題とビジネスインパクトの関連をより明確に理解できます。各リスクは 発生確率とインパクトの観点から評価され 優先度付けが行われます。グループワークショップと組織的な展開個別の対話に加えて 著者は グループワークショップの重要性も強調しています。臨床腫瘍学分野の非営利組織の事例では 参加者が自身のモダナイゼーションジャーニーを選択できるようなワークショップを設計しています。この中で ダブルダイヤモンドやデザインスクィグルといったモデルが活用され 参加者の主体的な関与を促進しています。特に興味深いのは ワークショップの段階的なアプローチです。最初にジャーニーのメタファーを選択し 次にドメインの境界を探索し 最後に具体的なアクションを計画するという流れは 参加者の理解と合意を段階的に構築する効果があります。キックスターターワークショップの実践現代化の実行フェーズへの移行には 3日間のキックスターターワークショップが効果的です。スカンジナビアの大規模企業の事例では このワークショップを通じて モノリシックなシステムからの段階的な移行戦略を策定しています。ワークショップの成功には 事前の準備が重要です。第1日目は ビジネスビジョンの共有と現状の分析に充てられ 第2日目は ドメインの探索とEventStormingによるプロセスの理解 第3日目は具体的なアーキテクチャ設計と実行計画の策定に焦点を当てます。この段階的なアプローチにより 参加者全員が共通の理解を持ちながら 具体的な行動計画を策定することが可能になります。ドメイン駆動設計をはじめよう ―ソフトウェアの実装と事業戦略を結びつける実践技法作者:Vlad KhononovオライリージャパンAmazon継続的な改善と展開著者は ワークショップの成果を継続的な改善につなげる重要性も強調しています。キックスターターワークショップで得られた勢いを維持するために AMETが重要な役割を果たします。AMETは 単なる技術支援チームではなく 組織の現代化能力を継続的に向上させるためのファシリテーターとして機能します。また 定期的なフィードバックと振り返りの機会を設けることで 現代化の取り組みを継続的に改善することが重要です。これには アンケートやフォローアップセッションの活用が効果的です。著者は これらのフィードバックを通じて 組織全体の学習と進化を促進することを推奨しています。まとめ本章は アーキテクチャ現代化の開始フェーズにおける実践的なアプローチを提示しています。特に重要なのは 聞くことから始めるという基本姿勢です。これは 単なるヒアリングを超えて 組織の本質的な課題と可能性を理解するための戦略的なアプローチです。著者が提案する手法は 理論的な枠組みと実践的なツールの巧みな組み合わせによって特徴づけられます。リスニングツアー グループワークショップ キックスターターワークショップという段階的なアプローチは 組織の現状を深く理解し 実行可能な現代化戦略を策定する上で効果的なフレームワークを提供しています。これらの手法の成功には 適切な環境作りと継続的なサポート体制が不可欠です。AMETの設置はその一つの解決策ですが より本質的には 組織全体が現代化の重要性を理解し その実現に向けて協力する体制を構築することが求められます。アーキテクトとして この組織的な側面への理解と対応が 現代化の成功に不可欠な要素といえるでしょう。5 Wardley Mapping第5章「Wardley Mapping」は ビジネス戦略とアーキテクチャ戦略を結びつけるための実践的なフレームワークとして Wardley Mappingを紹介しています。この章を通じて 著者はビジネスランドスケープの可視化と進化の理解が アーキテクチャ現代化の意思決定において重要な役割を果たすことを示しています。learnwardleymapping.com日本だと「Wardley Mapping」はあまり聞き馴染みのない言葉だと思います。実践例みたいなのもあまり聞いたことがありませんでした。blog-smatsuzaki.hatenablog.comengineer.crowdworks.jp戦略的思考とWardley MappingWardley Mappingは 単なる可視化ツールを超えて ビジネスとテクノロジーの戦略的統合を実現する手法です。この手法の特徴は バリューチェーンと進化という2つの軸で ビジネスランドスケープを表現する点にあります。これは従来の2x2マトリックスのような静的なフレームワークとは一線を画します。著者は 戦略サイクルという概念を用いて その実践プロセスを説明しています。このサイクルは 目的 ランドスケープ 気候 ドクトリン リーダーシップの5つのフェーズで構成されます。Figure 5.1は このサイクルの相互関係を示しています。特に重要なのは このサイクルが単なる一方向のプロセスではなく 継続的な学習と適応のループとして機能する点です。Figure 5.1 The Strategy Cycle (Source: Simon Wardley) より引用ただし 戦略サイクルは単なるプロセスモデルではありません。このフレームワークは 組織がどのように戦略を実践し 学習し 適応していくかという包括的な視点を提供します。例えば 目的の定義では 単なるミッションステートメントの作成を超えて 組織の存在意義と未来への展望を深く掘り下げることが求められます。マッピングの実践Wardley Mapの作成プロセスは 6つのステップで構成されます。まず目的を定義し スコープを設定し ユーザーを特定します。次にユーザーニーズを明確にし バリューチェーンを構築し 最後に各コンポーネントの進化段階を評価します。Ben MosiorのWardley Mapping Canvasは この一連のステップをガイドする効果的なツールです。特に重要なのは スコープの設定です。マッピングの範囲を適切に定義することで 意味のある議論と洞察が可能になります。スコープが広すぎると表面的な分析に終わり 狭すぎると重要な関係性を見落とす可能性があります。著者は この判断をサポートするための具体的な指針を提供しています。実際のマッピングでは オンラインフードデリバリー企業の例を用いて具体的な適用方法が示されています。このケースでは レストランと顧客をつなぐマルチサイドプラットフォームのビジネスモデルに焦点を当てています。段階的なマッピングプロセスを視覚的に示しています。この事例で特に注目すべきは バリューチェーンの構築プロセスです。コンポーネント間の依存関係を可視化することで 技術的な選択がビジネス価値にどのように影響するかが明確になります。例えば クラウドプラットフォームのような基盤的なコンポーネントが いかに上位のサービスの可能性を規定するかが理解できます。進化の理解と評価Wardley Mappingにおける進化の概念は 単なる技術的な成熟度を超えた意味を持ちます。Genesis Custom Built Product Commodityという4つのステージは それぞれ異なる特性と戦略的意味を持ちます。著者は この評価を支援するための15の基準を提示しています。例えば Ubiquity（普及度）とCertainty（確実性）は 進化段階を評価する重要な特性です。さらに 市場の成熟度やユーザーの認識など 12の一般的な特性も評価の基準として提示されています。これらの基準を用いた評価は 必ずしも一意的な結果をもたらすわけではありません。むしろ 異なる視点からの評価結果の違いが 重要な戦略的議論のきっかけとなります。著者は この曖昧性を否定的に捉えるのではなく 組織の学習機会として活用することを推奨しています。気候変動の理解と対応著者は 競争環境の変化を「気候」として捉え その重要性を強調しています。特に すべては進化するという原則は 戦略策定の基本的な前提となります。この原則は 単なる観察結果ではなく 戦略的な対応を要求する動的な状況を示しています。特に重要なのは コンポーネントの共進化という概念です。技術やビジネスモデルは単独で進化するのではなく 相互に影響を与えながら進化します。例えば リモートワークの普及は Zoom SlackなどのコラボレーションツールとWi-Fi接続性の進化が組み合わさることで可能になりました。戦略的対応のパターン著者は 環境変化への対応として アクセラレーターとデセラレーターという2つのパターンを提示しています。アクセラレーターには オープンソース化やネットワーク効果の活用が含まれます。一方 デセラレーターには 知的財産権の保護やFUDの活用があります。特に注目すべきは オープンアプローチの戦略的活用です。著者は GoogleやMicrosoftの事例を引用し オープンソース化が競争優位性の獲得につながる可能性を示しています。例えば TensorFlowのオープンソース化は 機械学習の分野でGoogleの影響力を強化することに貢献しました。組織的な実践への示唆Wardley Mappingの実践では 技術的な側面だけでなく 組織的な側面も重要です。特に チーム間のコラボレーションと共通言語としてのマッピングが重要な役割を果たします。著者は AMETなどの組織的な枠組みの活用も提案しています。この手法の導入には 段階的なアプローチが有効です。著者は まずキーとなるステークホルダーとの小規模なマッピングセッションから始め 徐々に範囲を拡大していくことを推奨しています。これにより 組織全体での理解と受容が促進されます。まとめWardley Mappingは アーキテクチャ現代化の文脈で 特に重要な3つの価値を提供します。第一に ビジネスとテクノロジーの統合的な理解を促進します。第二に 進化という視点を通じて 長期的な戦略立案を支援します。第三に 具体的な意思決定のフレームワークを提供します。本章で示された手法は 特にアーキテクチャの意思決定において実践的な価値があります。技術選択やシステム構造の決定を ビジネス戦略との整合性を保ちながら行うことが可能になります。さらに 継続的な環境変化に対応する能力も強化されます。アーキテクトとして この手法を活用する際は 単なる技術マッピングに終始せず ビジネス価値との結びつきを常に意識することが重要です。また 組織全体での共通言語としてWardley Mappingを活用することで より効果的な戦略的対話が可能になるでしょう。最後に 著者は この手法の習得には継続的な実践が不可欠であることを強調しています。理論的な理解だけでなく 実際のビジネス課題への適用を通じて その効果的な活用方法を学んでいく必要があります。特に 気候変動の理解と戦略的対応のパターンは 実践を通じて深い理解が得られる領域といえるでしょう。6 Product taxonomy第6章「Product taxonomy」は アーキテクチャ現代化の基盤となる製品分類の枠組みを提示しています。タクソノミー（taxonomy）とは もともと生物学で用いられる分類体系のことで 生物をその特徴によって分類し 体系化する方法を指します。この考え方をソフトウェア開発組織に適用したのが プロダクトタクソノミーです。著者は この枠組みを通じて 組織構造とアーキテクチャの整合性を実現するための具体的なアプローチを示しています。プロダクトマネジメントのすべて 事業戦略・IT開発・UXデザイン・マーケティングからチーム・組織運営まで作者:及川 卓也,小城 久美子,曽根原 春樹翔泳社Amazonタクソノミーの意義と基本概念プロダクトタクソノミーは 組織のアーキテクチャを製品視点で体系化するためのフレームワークです。従来の組織構造やシステム構成が必ずしも効率的な開発を実現できていない現状に対して タクソノミーという視点で再構築することで より効果的な組織とアーキテクチャの形を見出すことができます。特に重要なのは タクソノミーがただの分類ではなく 価値提供の単位を定義する点です。これは 単なる技術的な構造化ではなく ビジネス価値の創出を中心に据えた組織設計を可能にします。実際の適用では 既存の組織構造や技術的な制約との調整が必要になりますが タクソノミーという視点があることで より戦略的な判断が可能になります。独立した価値ストリームプロダクトタクソノミーの核となるのが 独立した価値ストリームという概念です。著者は Figure 6.1と6.2を用いて この概念を説明しています。価値ストリームは ユーザーニーズの特定から解決策の提供まで 一連の開発活動を表します。Figure 6.1 The high-level activities in an independent value stream より引用Figure 6.2 The four key characteristics of an independent value stream より引用価値ストリームの独立性を実現するには 4つの重要な特性が必要です。1つ目は ビジネスサブドメインとの整合性です。これは 特定のビジネス領域に焦点を当てることで 明確な価値提供を可能にします。2つ目は 明確なビジネス成果への焦点です。具体的な成果指標を持つことで チームの方向性が明確になります。3つ目は 自律的なチームによる所有権です。チームが自律的に意思決定できることで 開発のスピードと質が向上します。4つ目は デカップルされたソフトウェアアーキテクチャです。技術的な独立性が チームの自律性を支えます。スコープとドメインの階層構造著者は Ruth MalanとDana Bredemeyerのアーキテクチャスコープレベルを参照しながら 組織の階層構造に応じた3つのスコープレベルを定義しています。スコープ1は 単一のチームが所有する小規模なドメイン スコープ2は 複数のチームが必要な中規模なドメイン スコープ3は さらに大きな組織的な複雑さを持つドメインを表します。この階層構造は 組織の規模や複雑さに応じた適切な分類を可能にします。例えば 小規模な組織では スコープ1と2で十分かもしれません。一方で Salesforceのような大規模組織では より多くのスコープレベルが必要になることもあります。ドメインとプロダクトの関係性ドメインは 関連するサブドメインをグループ化したものです。Figure 6.3の例では fulfillmentドメインが availability last mile warehousing logisticsという4つのサブドメインで構成されています。各サブドメインは独立した価値ストリームを持ち それぞれが特定の業務機能に焦点を当てています。プロダクトは より広い概念として定義されています。著者は Melissa Perriの定義を引用し プロダクトを「市場に提供可能な 繰り返し可能なソリューションで 特定のニーズや要求を満たすもの」と定義しています。この定義の重要な点は プロダクトが単なる機能の集合ではなく 顧客への完全な価値提供を実現する単位だという点です。プラットフォームの戦略的活用プラットフォームは 複数のプロダクトで共有される機能を提供する重要な要素です。著者は ドメインプラットフォームと内部開発プラットフォームの2種類を定義しています。Figure 6.6は これらの関係性を視覚的に示しています。Figure 6.6 Platforms provide reuse across multiple products より引用ドメインプラットフォームは ビジネスドメインに関連する共有機能を提供します。例えば 予約システムや認証システムなどが該当します。一方 内部開発プラットフォームは チームの開発活動を支援する機能を提供します。CI/CDパイプラインやモニタリングツールなどがこれにあたります。NAVの事例は プラットフォーム戦略の実践を示す良い例です。ノルウェーの行政機関であるNAVは 内部開発プラットフォームを複数のサブプラットフォームに分解することで スケーラビリティの課題に対応しています。特に重要なのは プラットフォームをプロダクトとして扱う「Platform as a Product」というアプローチです。これにより 利用者であるチームのニーズに適切に対応できる体制を維持しています。タクソノミーの設計と進化プロダクトタクソノミーの設計には、いくつかの重要な原則があります。これらの原則は、組織の現状を踏まえながら、段階的に理想的な状態へと進化させていくためのガイドラインとなります。第一の原則：容易な部分からの段階的アプローチまず重要なのは、容易な部分から始めることです。既存の製品ラインナップを整理・分類することから着手し、現在の組織構造を出発点として活用します。特に、チームが理解しやすい領域から取り組みを開始し、小さな成功を積み重ねて徐々に範囲を拡大していくことが効果的です。このアプローチにより、組織全体の理解と受容を促進しながら、段階的な改善を進めることができます。第二の原則：適切な技術・手法の活用効果的なタクソノミー設計には、状況に応じた適切な手法の選択が重要です。EventStormingはドメインの理解と境界の特定に、Wardley Mappingは価値連鎖と進化の段階の可視化に効果的です。さらにドメインストーリーテリングは具体的なユースケースの理解を深め、インパクトマッピングはビジネス目標との整合性を確認するのに役立ちます。これらの手法を組み合わせることで、表面的な理解を超えた深い洞察を得ることができます。第三の原則：継続的な進化の実践タクソノミーは静的なものではなく、継続的に進化させる必要があります。現状のアーキテクチャと目標とする価値ストリームの差異を定期的に評価し、四半期ごとのタクソノミー見直しと更新を実施することが求められます。ビジネス環境の変化や新たな要件への適応も重要な要素です。特に重要なのは、不整合の特定から始まり、段階的な改善を経て、定期的な評価とフィードバックの収集までの一連のプロセスです。現状と目標のギャップを明確にし、優先順位付けされた課題に取り組み、進捗を確認しながら方向性を調整していきます。このような継続的な改善サイクルを通じて、組織の成長と技術の進化に適応したタクソノミーを維持することができます。実践のためのガイドライン効果的な実践のためには、定期的なレビューセッションの開催が重要です。ステークホルダーからのフィードバックを収集し、成功事例と課題を文書化します。さらに、学習した内容を組織全体で共有することで、タクソノミーを組織の実態に即した、実用的なツールとして育てていくことができます。このような体系的なアプローチにより、タクソノミーは単なる分類システムを超えて、組織の変革と成長を支える重要な基盤となります。継続的な改善と適応を通じて、組織全体の効果的な進化を支援する枠組みとして機能していくのです。ソフトウェアアーキテクトのための意思決定術　リーダーシップ／技術／プロダクトマネジメントの活用作者:Srinath Perera,島田 浩二インプレスAmazonマクロレベルの戦略的課題マクロレベルでの重要な課題として 再利用の戦略があります。Figure 6.12は この課題を視覚的に表現しています。特に グローバル企業において 各地域市場で機能を複製するか 中央集権的なプラットフォームを構築するかという選択は 重要な戦略的決定となります。この選択には いくつかの重要な考慮点があります。ユーザー体験の一貫性 優先順位付けの方法 資金モデル 依存関係の管理 効率性と市場投入速度のバランスなどです。これらの要素を総合的に評価し 組織に適した戦略を選択する必要があります。Stripeの事例は この課題への実践的なアプローチを示しています。同社は Treasury機能の開発において 最初は独立した実装を行い 市場での検証後に既存のインフラストラクチャへの統合を進めました。このアプローチは 短期的な市場投入速度と長期的な効率性のバランスを取る良い例といえます。プロダクトモードへの移行従来のプロジェクトモードが スコープ コスト 期間の制約のもとで一時的なチームが成果を出すのに対し プロダクトモードは 長期的な継続的改善にフォーカスし 安定したチームによる自律的な開発を重視します。この移行は 単なる開発プロセスの変更ではありません。資金モデル チームの責任範囲 成功の定義など 組織全体の文化とマインドセットの変革が必要です。著者は この変革が一夜にして達成されるものではないと指摘しつつ その実現がアーキテクチャ現代化の成功には不可欠だと主張しています。まとめプロダクトタクソノミーは アーキテクチャ現代化を実現するための戦略的なフレームワークです。その核となる価値ストリームの独立性と プラットフォームの適切な活用は 組織の効率性と革新性を両立させる鍵となります。特に重要なのは タクソノミーが静的な分類ではなく 継続的に進化する生きた構造だという点です。定期的な見直しと更新を通じて 組織の成長と技術の進化に対応していく必要があります。アーキテクトとして この章から学ぶべき重要な点は タクソノミーが単なる構造の定義ではなく チームの自律性と技術的な進化を支える枠組みだということです。その設計と進化を適切にガイドすることが 現代化の成功に不可欠な要素といえるでしょう。組織の規模や状況に応じて 適切なアプローチを選択し 段階的な実現を目指すことが 実践的な戦略となります。7 Big picture EventStorming第7章「Big picture EventStorming」は、アーキテクチャ現代化において最も重要な「ゆっくり考える」フェーズを実現するための手法を紹介しています。著者は性急な意思決定の危険性を指摘し、その解決策としてEventStormingというコラボレーティブな技法を提示しています。現代化プロジェクトの多くは、「すばやく考え、ゆっくり動く」というパターンに陥りがちです。予算、工期、便益の3点全てを満たすプロジェクトは例外中の例外（0.5%）であり、その主な原因は初期の理解と計画が不十分なままプロジェクトを開始してしまうことにあります。BIG THINGS　どデカいことを成し遂げたヤツらはなにをしたのか？作者:ベント・フリウビヤ,ダン・ガードナーサンマーク出版AmazonEventStormingは、この課題に対する具体的な解決策を提供します。ドメインの深い理解を得るために十分な時間を確保し、関係者全員で慎重に検討を重ねることで、後続のフェーズで迅速な実行を可能にします。これは「ゆっくり考え、すばやく動く」という成功プロジェクトに共通する特徴を体現しています。本章では、この手法の実践的な適用方法と、組織全体での価値創造について、体系的な説明を展開していきます。特に重要なのは、人の心理や組織の力学が初期の理解フェーズを軽視させがちだという点への対処です。EventStormingは、この人間的な側面も考慮に入れた、実践的で効果的なアプローチを提供します。EventStormingの本質EventStormingは 2010年代半ばにAlberto Brandoliniによって考案された ドメイン探索のための手法です。その最大の特徴は シンプルな表記法と高い包摂性にあります。ドメインイベントという概念を用いて 業務の流れを左から右への時系列で表現します。Figure 7.1は その基本的な構造を示しています。Figure 7.1 Using domain events to map out a business on a timeline from left to right より引用特に重要なのは この手法が特別なトレーニングを必要としない点です。製品開発に関わる全ての人々（開発者 テスター プロダクトマネージャー UXデザイナー カスタマーサポート担当者など）が 自然に参加できるよう設計されています。これは 組織内の知識を最大限に活用し より深いドメイン理解を得るために不可欠な特性といえます。私自身の経験でも EventStormingの価値を実感する場面は多くあります。例えば あるプロジェクトで開発者が「この機能は重要ではない」と考えていた問題について カスタマーサポート担当者から「今朝も2件の問い合わせがあった」という指摘があり 認識のズレが明らかになった事例があります。このような気づきは 個別のインタビューでは得られにくいものです。手法の実践EventStormingの実践には いくつかの重要な要素があります。まず 会場の準備です。8メートル以上の壁面スペースと 付箋やペンなどの文具が必要です。Figure 7.8が最高なのでぜひ書籍を読んでみて下さい。また、テーブルや椅子は最小限にし 参加者が自由に動き回れる環境を整えることが重要です。セッションの進め方も重要です。著者は カオス的な探索という概念を提唱しています。これは 最初から整然とした構造を求めるのではなく 参加者全員が思いつくままにドメインイベントを書き出していく方法です。Figure 7.2は この過程を視覚的に示しています。Figure 7.2 An EventStorm runs from left to right but does not need to be neatly and precisely laid out. より引用私の実践では この「カオス」の許容が非常に重要だと感じています。整然とした構造を早期に求めすぎると 重要な気づきが失われる可能性があります。特に レガシーシステムの現代化では 表面には現れていない依存関係や制約が多く存在するため この探索的なアプローチが効果的です。ファシリテーションの技術EventStormingのファシリテーションには 高度なスキルが要求されます。著者は Figure 7.17など用いて いくつかの重要な原則を示しています。特に重要なのは 抽象度のバランスです。過度に抽象的なイベントは 重要な詳細を隠してしまい 過度に具体的なイベントは 全体像の理解を妨げます。Figure 7.17 Overly abstract events より引用実践的なテクニックとして ピボットイベントの活用があります。これは タイムライン全体を適切なサイズに分割し 理解を促進するための手法です。Figure 7.11は この手法の適用例を示しています。このような構造化により 複雑なドメインでも理解しやすくなります。Figure 7.11 Using pivotal events to sort the timeline より引用私の経験では このピボットイベントの選定が セッションの成否を分ける重要な要素となることが多いです。適切なピボットイベントは ドメインの本質的な変化点を表現し より深い議論のきっかけを提供します。問題とチャンスの発見著者は EventStormingが 単なるプロセスの可視化ではなく 問題とチャンスの発見ツールとしても機能することを強調しています。Figure 7.15は ユーザーのドロップアウトポイントを示す例です。このような視覚化により 業務上の課題がより明確になります。Figure 7.15 A customer dropping out of the funnel, resulting in lost revenue より引用特に興味深いのは 知識の欠落や争点の発見です。著者は 2017年の金融アドバイス業界での事例を紹介しています。この事例では メトリクスの計算方法について 開発者とマーケティング責任者の間で認識の不一致が発見されました。このような発見は 組織の意思決定の質を向上させる重要な機会となります。リモートでの実践パンデミック以降 リモートでのEventStormingの実践が急速に広がっています。著者は この変化を単なる代替手段としてではなく 新たな可能性として捉えています。Miroなどのデジタルツールでは 物理的な制約なく無限のモデリングスペースを使用でき コピー＆ペーストなどの効率的な操作も可能です。私の実践でも リモートならではの利点を多く発見しています。例えば 複数のセッションを時間をかけて実施できることや グループワークでの素早い複製と比較が可能なことは 大きな価値です。ただし 参加者の集中力維持や 非言語コミュニケーションの制限には 十分な注意が必要です。まとめEventStormingは アーキテクチャ現代化において 不可欠なツールです。その価値は 単なるプロセスの可視化を超えて 組織の知識の統合と 深い洞察の獲得にあります。特に 現代のソフトウェア開発において重要な ドメイン駆動設計の実践を支援する強力なツールとなります。一方で この手法の効果的な活用には 適切なファシリテーションスキルと 組織文化の醸成が必要です。Discovery mindsetの確立や bikesheddingの回避など 実践上の課題にも注意を払う必要があります。アーキテクトとして この手法を活用する際は 単なるテクニックとしてではなく 組織の知識を統合し 現代化の方向性を見出すための戦略的なツールとして位置づけることが重要です。特に レガシーシステムの現代化において その価値は極めて高いといえるでしょう。8 Product and domain modernization第8章「Product and domain modernization」は、アーキテクチャ現代化における製品とドメインの重要性に焦点を当てています。この章を通じて、著者は現代化が単なる技術的な刷新を超えて、ユーザー体験、製品価値、ドメインモデルの根本的な見直しを必要とすることを示しています。DDD（Domain-Driven Design）という言葉をよく耳にしますが、「DDDって結局クリーンアーキテクチャのことですか？」といった質問を受けることも多く、その本質的な理解が十分に広まっているとは言えない状況です。本章は、DDDの核心である「ドメインモデリング」について体系だった説明を提供しており、その点だけでも大きな価値があります。特に、ドメインモデルが単なる技術的な設計パターンではなく、ビジネスの本質を理解し表現するための手法であることが、具体的な事例とともにわかりやすく解説されています。ドメイン駆動設計入門 ボトムアップでわかる！ドメイン駆動設計の基本作者:成瀬 允宣翔泳社Amazon製品現代化の本質製品現代化の本質は、単なる技術的なアップデートではありません。著者は、多くの組織が陥りがちな 古いシステムを新技術で再構築するという罠 について警鐘を鳴らしています。現代化は、長年抱えてきた問題に向き合い、不要な複雑性を排除する機会です。リファクタリング 既存のコードを安全に改善する（第2版）作者:ＭａｒｔｉｎＦｏｗｌｅｒオーム社Amazonこの点は、英国政府のデジタルサービス（GDS）の事例で端的に示されています。GDSは、政府サービスの現代化において、ユーザー中心設計と継続的デリバリーを重視する方針を採用しました。その結果、数十年にわたって変更されていなかった政策やプロセスの見直しにまで踏み込んだ改革を実現しています。Figure 8.1が示すように、現代化は製品スタック全体に影響を与えます。UIの改善はユーザーの生産性向上につながり、ソフトウェアの改善はドメインとの整合性を高めます。さらに、概念的なドメインモデルの改善は、組織全体のコミュニケーションと革新を促進します。Figure 8.1 Full-stack modernization, from business domain up to user interface より引用要件の再定義プロセス製品要件の特定において、著者は 既存コードの単純な逆エンジニアリングを避けるべきと主張します。その理由は明確です。既存システムには、もはや不要な機能や、当初から有用性の低かった機能が含まれている可能性が高いからです。Citibank社の事例は、この問題の深刻さを示す象徴的な例です。1990年代スタイルのユーザーインターフェースが原因で、5億ドルの損失を被った事例は、内部向けシステムのUX軽視がもたらすリスクを如実に示しています。特に重要なのは 継続的なディスカバリー の実践です。著者はTeresa Torresの「Continuous Discovery Habits」を引用しながら、週次でのユーザー接点を持つことの重要性を強調しています。これは単なる検証ではなく、共創のマインドセットに基づく早期フィードバックの獲得を意味します。agnozingdays.hatenablog.comドメインモデルの現代化ドメインモデルの現代化は、組織のコミュニケーションと協働に直接的な影響を与えます。著者は、同じ用語に対する異なる解釈が引き起こす問題を、North American Smart Citiesの事例で示しています。「activated」という単語の解釈の違いが、品質エンジニアとソリューションアーキテクトの間で深刻な対立を引き起こした事例は、共通言語の重要性を端的に示しています。Figure 8.3は、同じフレーズが異なるドメイン概念を指す場合に発生する問題を視覚化しています。このような曖昧性は、コラボレーションの効率低下とコードの複雑化を招く原因となります。Figure 8.3 Problems arise when the same phrase is used to describe different domain concepts. より引用プロセスモデリングの実践著者は、プロセスモデリングEventStormingを、将来のドメイン状態を設計するための効果的なツールとして提案しています。この手法の特徴は、その構造化されたアプローチにあります。Figure 8.4は、アクター、アクション、システム、ドメインイベント、ポリシー、情報という基本的な要素を示しています。Figure 8.4 Process modeling EventStorming notation and syntax より引用この手法の実践では、良い質問をすることが重要です。著者は、「この役割を担う人数は何人か」「一人が複数の役割を担えるか」といった質問を通じて、機会の規模と最適化のポイントを特定することを推奨しています。Figure 8.8は、この質問アプローチの実践例を示しています。Figure 8.8 Asking questions about people in the domain to unlock valuable conversations より引用ドメインストーリーテリングの活用ドメインストーリーテリングは、EventStormingと並ぶ重要なモデリング手法です。著者はこの手法の特徴として、「ストーリー」を中心に据えた探索的なアプローチを挙げています。Figure 8.10は、この手法の基本的な表記法を示しています。Figure 8.10 The five basic notation elements of the Domain Storytelling pictographic language より引用特に注目すべきは、この手法が 一度に一つのフローに集中する アプローチを取る点です。これはEventStormingの多面的なアプローチとは異なりますが、特定のシナリオを深く理解する上で効果的です。実践的な成果と課題英国のDepartment for Levelling Up, Housing, and Communities の事例は、これらのアプローチの実践的な価値を示しています。彼らは継続的なディスカバリーアプローチを採用し、ユーザー研究を通じて段階的な改善を実現しました。その結果、単なる規制対応を超えて、政策立案者への新たな価値提供まで実現しています。この事例で特に興味深いのは、文脈的探査（contextual inquiry）とユーザビリティテストの組み合わせです。文脈的探査によってユーザーの本質的なニーズを理解し、ユーザビリティテストで具体的な解決策を検証するという二段階のアプローチは、効果的な現代化戦略の好例といえます。まとめ製品とドメインの現代化は、アーキテクチャ現代化の中核を成す要素です。その成功は、技術的な刷新だけでなく、ユーザー体験、製品価値、ドメインモデルの包括的な見直しに依存します。特に重要なのは、現代化を単なる「古いものの置き換え」ではなく、組織の価値創造能力を根本的に強化する機会として捉えることです。この章で示された手法と事例は、現代のソフトウェア開発組織が直面する課題に対する実践的な解決策を提供しています。特に、継続的なディスカバリーとコラボレーティブなモデリング手法の組み合わせは、現代化プロジェクトの成功に不可欠な要素といえるでしょう。私たちアーキテクトは、これらの知見を活かし、技術とビジネスの架け橋となる現代化戦略を策定していく必要があります。9 Identifying domains and subdomains第9章「Identifying domains and subdomains」は、アーキテクチャ現代化における最も重要な課題であるドメインとサブドメインの識別について論じています。著者はドメイン境界の設計がチームの効果的な構造化とルースカップリングなアーキテクチャの実現に不可欠であることを示し、その実践的なアプローチを提示しています。新版　考える技術・書く技術　問題解決力を伸ばすピラミッド原則作者:バーバラ・ミントダイヤモンド社Amazonドメイン境界の本質と価値良いドメイン境界の設計は、単なる技術的な課題を超えた組織的な価値を持ちます。Figure 9.2が示すように、適切なドメイン境界は依存関係の削減による開発の高速化とチームの幸福度向上をもたらします。関連する概念のまとまりは明確な目的意識を生み、チームの動機付けと持続可能な実践を促進します。Figure 9.2 Well-designed domain boundaries maximize cohesion and minimize coupling, contributing to higher-performing teams and better products. より引用この価値は特にレガシーシステムの現代化において顕著です。私が過去に担当した金融機関のプロジェクトでは、明確なドメイン境界の欠如が開発の遅延と品質の低下を引き起こしていました。チーム間の依存関係が複雑に絡み合い、小さな変更でも多数のチームの調整が必要になる状況でした。結果として、1行のコード変更に数週間の調整期間を要することもありました。ドメイン境界設計の実践例BBCの事例は、ドメイン境界の進化を示す典型的な例です。当初BBCはニュース・スポーツ・天気予報といった垂直方向のサービスごとに境界を設定していました。各サービスは独自の発展を遂げ、週間数百万のアクセスを誇る規模に成長しました。しかしこの構造は、サービス間での一貫した体験の提供を難しくしていました。そこでBBCは、記事・検索・トピックといった水平方向のドメインへと再構成を行いました。この変更により、共通コンポーネントの再利用が促進され、パーソナライゼーションや分析といった横断的な機能の実装が容易になりました。現代化の具体的アプローチFigure 9.12は、大規模航空会社におけるドメイン分割の具体例を示しています。予約・ロイヤルティ・チェックイン・旅程管理といった明確な責任範囲を持つドメインが識別されています。各ドメインは複数のサブドメインで構成され、独立したチームによる開発を可能にしています。Figure 9.12 Domains and subdomains identified at the airline (Source: Javiera Laso) より引用この事例で興味深いのは、同じ名前のサブドメインが異なるドメインに存在する点です。一般的なアーキテクトの直感に反するこの決定は、各ドメインにおける意味的な違いに基づいています。私の経験でも、一見同じに見える概念でも、ビジネスコンテキストが異なれば別々に扱うべき場合が多々あります。評価と発展のフレームワークFigure 9.21のサブドメイン概要キャンバスは、ドメイン境界の妥当性を評価するための実践的なツールです。このキャンバスは目的・主要概念・イベント・ポリシーなど、多面的な視点からドメインを分析します。私はこのキャンバスを使って、チームとステークホルダー間の対話を促進し、境界の設定に関する合意形成を図っています。Figure 9.21 The subdomain overview canvas より引用特に重要なのは、このキャンバスを通じて見えてくる依存関係の評価です。Vlad Khononovの提案する Pain = Strength * Volatility * Distance という公式は、依存関係の問題を定量的に評価する枠組みを提供します。私のプロジェクトでは、この公式を使って優先順位付けを行い、最も問題のある依存関係から順に解消していく戦略を採用しています。継続的な進化の実践ドメイン境界の設計は一回限りの活動ではありません。新機能の追加や事業環境の変化により、継続的な見直しが必要になります。最近のプロジェクトでは、マイクロサービスへの移行過程で、想定外の依存関係が発見され、境界の再設計が必要になりました。この課題に対して私たちが採用している手法は、四半期ごとのドメインレビューです。このレビューでは、変更頻度・依存関係のコスト・チームの生産性などの指標を評価し、必要に応じて境界の調整を行います。この定期的なフィードバックループが、境界設計の持続的な改善を可能にしています。まとめドメインとサブドメインの識別は、アーキテクチャ現代化の成功を左右する重要な要素です。技術的な側面だけでなく、組織の目標達成のための戦略的な活動として捉えることが重要です。BBCや航空会社の事例が示すように、適切なドメイン境界は組織の革新能力と開発効率を大きく向上させます。今後、マイクロサービスアーキテクチャの普及とともに、この課題の重要性は更に増すでしょう。私たちアーキテクトは、この章で示された原則と手法を実践に活かしながら、組織の持続的な進化を支援していく必要があります。10 Strategic IT portfolio第10章「Strategic IT portfolio」は、アーキテクチャ現代化における戦略的なIT投資の重要性とその実践方法について論じています。著者はアーキテクチャをポートフォリオとして捉え、ビジネス価値に基づいた投資判断を行うことの重要性を示し、その具体的なアプローチを提示しています。良い戦略、悪い戦略 (日本経済新聞出版)作者:リチャード・Ｐ・ルメルト日経BPAmazon戦略的ITの本質Martin Fowlerが提唱する「Utility versus Strategic IT」の二分法は、ITの戦略的価値を評価する基本的なフレームワークを提供します。ビジネスの差別化に寄与するソフトウェアは戦略的ITとして、単なるビジネスコストとしてのソフトウェアはユーティリティITとして分類されます。私の経験でも、この分類は実践的な価値があります。ある物流企業のプロジェクトでは、貨物の積載最適化や動的なETA計算の機能は戦略的ITとして位置付けられました。これらの機能は競合他社との差別化につながり、顧客維持率と運用効率の向上に貢献しました。一方で請求システムはユーティリティITとして扱われ、より洗練された機能を追加しても市場での優位性にはつながらないと判断されました。特に重要なのは、この分類が単なる理論的な枠組みではなく、具体的な投資判断と運用モデルの指針となる点です。チームの規模、メンバー構成、コラボレーションの方法、優先順位付け、アーキテクチャの選択など、多くの実務的な意思決定に影響を与えます。私の経験では、この分類を明確にすることで、組織全体の方向性が揃い、より効果的な資源配分が可能になりました。コアドメインチャートの活用著者は戦略的ITの評価ツールとして「Core Domain Charts」を提案しています。Figure 10.4に示されるように、このツールはビジネスの差別化度とモデルの複雑性という2つの軸でドメインを評価します。特に重要なのは、この評価が単なる分類に留まらず、投資判断と運用モデルの具体的な指針となる点です。Figure 10.4 A blank Core Domain Chart より引用電子スクーター企業の事例（Figure 10.5）は、このアプローチの実践を示しています。配車計画のドメインは高い差別化可能性と複雑性を持つため、コアドメインとして位置付けられました。このドメインには長期的な投資とシニアエンジニアの配置、高度なアーキテクチャパターンの採用が必要とされました。Figure 10.5 Core Domain Chart for the hypothetical shared scooter company より引用モデルの複雑性の評価には、ユーザーニーズの発見、製品設計、ドメインモデル設計、ソフトウェアの実装と進化、運用サポートなど、多面的な要素が含まれます。私の経験では、この包括的な評価アプローチにより、技術的な観点だけでなく、ビジネス価値の創出に必要な投資の全体像を把握することが可能になりました。戦略的パターンの認識著者は、コアドメインチャート上に現れる典型的なパターンとその含意を解説しています。特に興味深いのは決定的コア（Decisive Core）と隠れたコア（Hidden Core）の概念です。決定的コアは高い差別化と複雑性を持ち、市場での決定的な優位性をもたらす可能性を持ちます。隠れたコアは、ソフトウェア外の複雑性をソフトウェア化することで戦略的価値を生み出せる可能性がある領域です。また、疑わしいサポート（Suspect Supporting）というパターンは、差別化度が低いにも関わらず高い複雑性を持つドメインを示します。このパターンは多くの場合、技術的負債の蓄積を示唆しており、複雑性の低減が必要となります。私のプロジェクトでも、このパターンの特定が技術的負債への取り組みの優先順位付けに役立ちました。継続的な進化の重要性Vintedの事例は、戦略的ITポートフォリオの継続的な進化の重要性を示しています。カテゴリー管理という一見単純な領域が、実は戦略的な価値を持つコアドメインであることが、Core Domain Chartsを通じて明らかになりました。この発見は、組織の投資判断と技術戦略に大きな影響を与えました。特に注目すべきは、この発見が製品戦略との整合性を取る過程で得られた点です。ドメインの境界や技術的な実装の選択は、より大きな戦略的文脈の中で決定される必要があります。私の経験でも、技術的な決定を製品戦略と結びつけることで、より説得力のある提案が可能になりました。まとめ第10章は、アーキテクチャ現代化における戦略的な投資判断の重要性と、その実践的なアプローチを提供しています。特に重要なのは、アーキテクチャをポートフォリオとして捉え、ドメインごとに適切な投資と運用モデルを選択する視点です。この章で示された手法と知見は、現代のソフトウェア開発組織が直面する課題に対する具体的な解決策となります。私たちアーキテクトは、これらの知見を活かし、技術的な卓越性だけでなくビジネス価値の創出を重視した戦略的な判断を行っていく必要があります。特に、Core Domain Chartsを活用した投資判断の枠組みは、組織の現代化戦略を具体化する上で重要なツールとなるでしょう。11 Team Topologies第11章「Team Topologies」は、アーキテクチャ現代化における組織とソフトウェアの共進化の重要性に焦点を当てています。著者はMatthew SkeltonとManuel Paisが提唱するTeam Topologiesのフレームワークを基に、独立した価値ストリームを実現するためのチーム設計と進化のアプローチを提示しています。チームトポロジー　価値あるソフトウェアをすばやく届ける適応型組織設計作者:マシュー・スケルトン,マニュエル・パイス日本能率協会マネジメントセンターAmazonチーム設計の基本原則効果的なアーキテクチャ現代化には組織とソフトウェアの共同最適化が不可欠です。Figure 11.1が示すように、チーム間の依存関係の最小化とフローの最大化は現代化の中核的な課題です。Figure 11.1 Refining and validating domain boundaries with Team Topologies より引用私の経験でも、チーム構造とアーキテクチャの不整合は深刻な問題を引き起こします。以前関わったある金融機関のプロジェクトでは、チーム間の境界が不明確だったため、同じコードベースに複数のチームが介入し頻繁な調整が必要になりました。結果として、小さな変更にも数週間の時間を要する状況に陥りました。Team Topologiesは持続可能な高速フローを実現するための原則を提供します。この持続可能性が重要です。私が経験した多くの組織では、短期的な速度を追求するあまり技術的負債を蓄積し、最終的にはフローが著しく低下する結果となりました。 speakerdeck.com4つのチームタイプと3つの相互作用モードFigure 11.3は、Team Topologiesが提唱する4つのチームタイプを示しています。ストリーム整合型チームは製品機能の開発に直接関わり、プラットフォームチームは共通基盤を提供します。複雑サブシステムチームは特殊な専門知識を要する領域を担当し、イネーブリングチームは他のチームの成長を支援します。Figure 11.3 The four team types of Team Topologies より引用チーム間の相互作用には3つのモードがあります。コラボレーションは共通の目標に向けて密接に協力する形態で、X-as-a-Serviceは一方のチームが他方のサービスを利用する形態です。ファシリテーションは一時的な支援を提供する形態となります。私の実践では、これらのパターンを固定的に捉えるのではなく、状況に応じて柔軟に組み合わせることが重要でした。特に、プラットフォームチームとストリーム整合型チームの関係は、初期段階では密接なコラボレーションを行い、gradually X-as-a-Serviceに移行していく例が多くありました。コグニティブロードの管理Figure 11.2は、コグニティブロードの観点からチーム境界を評価する方法を示しています。内在的認知負荷はタスクの本質的な複雑さを、外在的認知負荷は環境要因による追加の負荷を、学習的認知負荷は新しい概念の習得に関する負荷を表します。Figure 11.2 Identifying potential high cognitive load on a Core Domain Chart より引用私の経験では、特に外在的認知負荷の管理が重要です。以前参加したプロジェクトでは、レガシーコードの複雑性により、新機能の開発に必要な本質的な作業以外の負荷が大きく、チームの生産性が著しく低下していました。この問題に対し、段階的なリファクタリングと適切なドメイン境界の設定で改善を図りました。チームの進化と再編成著者は、チーム構造を静的なものではなく、継続的に進化するものとして捉えています。Figure 11.10に示されるDiscover to Establishパターンは、その典型的な例です。新しい領域での探索段階では密接なコラボレーションを行い、理解が深まるにつれて相互作用のモードを変化させていきます。Figure 11.10 The discover to establish pattern より引用Heidi HelfandのDynamic Reteamingの概念も重要です。チームの構成は固定的であってはならず、組織の成長、新しい優先順位の発生、知識の共有、学習機会の創出などの理由で適切に変化させる必要があります。私のプロジェクトでも、月次でのメンバーの交代を制度化し、知識の共有と新鮮な視点の導入を図りました。独立した価値ストリームの検証独立した価値ストリームの実現には、Independent Service Heuristics (ISH)が有効です。このツールは、ビジネスインパクト、プロダクト決定の自律性、チームの認知負荷、コスト追跡、依存関係などの観点から、価値ストリームの独立性を評価します。私の経験では、ISHは特にレガシーシステムの現代化において有効でした。ある製造業のプロジェクトでは、ISHを使用して複数の候補となる価値ストリームを評価し、最も効果的な現代化の開始点を特定することができました。コンウェイの法則への対応コンウェイの法則は、組織のコミュニケーション構造がソフトウェアアーキテクチャに反映されることを示しています。著者は、この法則を避けるのではなく、積極的に活用することを提案しています。私が経験した失敗例では、マーケティング部門とIT部門の対立関係がアーキテクチャの複雑化を招いた事例があります。両部門の協力関係の欠如が、データの同期やシステムの整合性の問題を引き起こしました。この経験から、組織構造とアーキテクチャの整合性を意識的に設計することの重要性を学びました。フロントエンドとバックエンドのチーム構成著者は、フロントエンドとバックエンドのチーム構成について、3つの主要なパターンを提示しています。一つ目は「フロントバックチーム」パターンで、各チームがUIとバックエンドの両方を担当します。このパターンでは、一つの機能に関する変更を単一のチームで完結できる利点があります。二つ目は「ドメインごとの専門チーム」パターンです。フロントエンドチームとバックエンドチームは存在しますが、特定のドメイン領域に特化しています。これにより、ドメインの専門性を維持しながら、技術的な専門性も確保できます。三つ目は「完全分離」パターンです。フロントエンド開発を担当するチームとバックエンド開発を担当するチームが完全に分かれています。このパターンでは、技術的な専門性は高まりますが、機能開発時のチーム間調整コストが増大します。私の経験では、この選択は技術的な観点だけでなく、チームメンバーのキャリア志向や組織の文化も考慮する必要があります。ある製品開発組織では、フロントエンドとバックエンドの完全な分離を採用し、専門性の向上を図りましたが、コミュニケーションコストの増大という代償を払うことになりました。特に新機能の開発時には、フロントエンド・バックエンド間のインターフェース設計に多くの時間を要することになりました。まとめTeam Topologiesは、アーキテクチャ現代化における組織とソフトウェアの共進化のための実践的なフレームワークを提供しています。特に重要なのは、チーム構造を静的なものではなく、ビジネスの進化に応じて継続的に適応させていく視点です。私たちアーキテクトは、技術的な設計だけでなく、組織の構造とその進化にも注意を払う必要があります。特に、チームの認知負荷の管理、適切な相互作用モードの選択、そして組織全体としての学習能力の向上が、現代化の成功には不可欠です。この章で示された原則とパターンは、現代のソフトウェア開発組織が直面する複雑性に対する具体的な解決策となります。ただし、これらのパターンを機械的に適用するのではなく、組織の文脈に応じて適切にカスタマイズし、継続的に改善していくことが重要です。著者の提案する「持続可能な高速フロー」という概念は、短期的な生産性と長期的な健全性のバランスを取る上で、私たちに重要な示唆を与えています。アーキテクトとして、この視点を常に意識しながら、組織とアーキテクチャの共進化を導いていく必要があるでしょう。12 Loosely coupled software architecture第12章「Loosely coupled software architecture」は 独立した価値ストリームを実現するために不可欠な疎結合アーキテクチャについて論じています。この章を通じて著者は結合度という抽象的な概念を具体的な設計原則へと落とし込み ソフトウェアアーキテクトが実践で活用できる知見を提供しています。A Philosophy of Software Design, 2nd Edition (English Edition)作者:Ousterhout, John K. Amazon改訂新版　良いコード／悪いコードで学ぶ設計入門 ―保守しやすい　成長し続けるコードの書き方作者:仙塲 大也技術評論社Amazon結合度の本質と戦略的重要性著者は結合度を「一方のコンポーネントが他方のコンポーネントについてどれだけ知っているか」という観点から整理しています。Vlad Khononovの分類によれば 結合度は強い順に「侵襲的結合」「機能的結合」「モデル結合」「契約的結合」の4種類に分類されます。この分類は従来の抽象的な結合度の議論を具体的な評価基準へと昇華させた点で 実務上極めて有用です。最も強い結合である侵襲的結合では プライベートメソッドへのアクセスやデータベーススキーマの共有など あらゆる内部詳細が露出します。この状態では変更の影響範囲が予測不可能となり リスクの高い変更を強いられます。その一方で最も弱い契約的結合では インターフェイスを介した相互作用のみが許可されます。内部の実装詳細が隠蔽されているため 変更の影響を最小限に抑えることができます。Figure 12.1 This chapter covers the software architecture aspect of independent value streams. より引用Figure 12.1 はこれらの結合タイプが価値ストリームの独立性に与える影響を視覚的に表現しています。結合度が強いほどリスクが高くなり 弱いほど安全な変更が可能になることを明確に示しています。特に注目すべきは契約的結合の効果です。インターフェイスの背後にある実装は自由に変更できるため 迅速な進化が可能となります。局所的複雑性と大域的複雑性のバランスアーキテクチャ設計において 著者は局所的な複雑性と大域的な複雑性のバランスを取ることの重要性を指摘しています。マイクロサービス開発の初期には「100行以下のシンプルなサービス」という極端な設計指針が提唱されることがありました。しかしこのアプローチは局所的な複雑性を下げる一方で システム全体の複雑性を大幅に増大させる結果となりました。Figure 12.5 Balancing local and global complexity より引用Figure 12.5 は局所的複雑性と大域的複雑性のトレードオフを示しています。サービスを小規模に保つことで理解や変更は容易になりますが その分サービス間の相互作用が増加し システム全体の複雑性は増大します。私の経験でも 極端な分割は必ずしも最適な選択ではありませんでした。あるプロジェクトでは データの同期や整合性維持のために大量のボイラープレートコードが必要となり 結果として開発者の生産性を低下させる事態となりました。著者はVlad Khononovのフレームワーク「Pain = Strength * Volatility * Distance」を用いて このトレードオフを定量的に評価することを提案しています。このフレームワークは結合の強さ 変更頻度 社会的・技術的な距離という3つの要素から結合がもたらす痛みを評価します。これにより アーキテクト間で客観的な議論が可能となります。アーキテクチャフローのモデリング手法著者は EventStorming Domain Message Flow Modeling Software Design EventStormingといった視覚的なモデリング手法を紹介しています。これらの手法は複数のサブシステム間の相互作用を可視化し 結合度を評価・改善するための効果的なツールです。Eric Evansが提唱するモデル探索の渦巻きは ドメインモデルを継続的に評価・改良するプロセスを示しています。具体的なシナリオをもとに視覚的なモデリングを行い 必要に応じてコードの検証も実施します。私は特にこのアプローチを評価しています。抽象的な議論では見落とされがちな実装上の課題が 具体的なシナリオを通じて早期に発見されるためです。Domain Message Flow Modelingの事例として オンライン車両販売プラットフォームの検査プロセスが示されています。ユーザーの行動に基づいてイベントとコマンドを特定し ドメイン概念とデータフローを可視化します。特に重要なのはイベントとコマンドの使い分けです。コマンドは送信者が次のアクションを決定するのに対し イベントは受信者が判断を行います。このように意思決定の所在を明確化することで 将来の変更容易性が向上します。サブシステム設計の実践著者は個々のサブシステムの設計を評価するためのツールとして Bounded Context Canvas を提案しています。このキャンバスは名前 説明 戦略的分類 ドメインロール コミュニケーションパターンなど 8つのセクションでサブシステムを多面的に評価します。私の実践では このキャンバスを使うことでステークホルダー間の認識の齟齬を早期に発見できました。特に「domain roles」セクションは チームの責任範囲を明確化する上で有効でした。また「inbound/outbound communication」セクションは 依存関係の可視化に役立ち 不必要な結合の特定を容易にしました。より詳細な設計フェーズでは Software Design EventStorming が効果的です。この手法は従来のEventStormingにアグリゲートという概念を追加し より実装に近いレベルでモデリングを行います。視覚的な表現により 関係者全員がドメインモデルを共有・議論することが可能となります。サブシステムの現代化戦略著者は現代化戦略を選択するためのフレームワークとして Modernization Strategy Selector を提示しています。このフレームワークは行動の変更とテクノロジーの変更という2つの軸でモダナイゼーション戦略を評価します。行動の変更は既存機能の修正や新機能の追加を テクノロジーの変更はインフラストラクチャやプログラミング言語の刷新を表します。このフレームワークにより ROIを最大化する現代化アプローチを特定することが可能となります。移行パターンとしては Strangler Fig Pattern Bubble Pattern Autonomous Bubble Pattern などが紹介されています。Strangler Fig Patternでは 新しいシステムが既存のモノリスを徐々に包み込んでいきます。ルーティングコンポーネントがリクエストを振り分け 新しい機能は現代化されたサブシステムで処理します。一方 Bubble Patternでは 新しいサブシステムを既存システムの前に配置し アンチコラプションレイヤーを通じて古いシステムと統合します。さらに進化したAutonomous Bubble Patternでは 新しいサブシステムが独自のデータストアを持ち 非同期のデータ同期で既存システムと連携します。私の経験では Strangler Fig Pattern が最も実践的でした。段階的な移行が可能なため リスクを最小限に抑えながら現代化を進めることができました。まとめ本章は疎結合アーキテクチャの理論と実践を包括的に扱っています。特に価値があるのは 抽象的な概念を具体的な評価基準とツールセットへと変換している点です。Vlad Khononovの結合度フレームワークは結合の影響を定量的に評価する基準を提供し さまざまなモデリング手法は結合度を視覚化・改善するための実践的なアプローチを示しています。アーキテクトとして私が特に注目しているのは 局所的複雑性と大域的複雑性のバランスです。極端な分割や過度の統合を避け 組織の文脈に応じた適切なバランスを見出すことが重要です。また 現代化戦略の選択においては ROIを最大化する移行パターンの特定が鍵となります。結合度の設計はソフトウェアアーキテクチャの根幹をなす課題です。本章で示された原則とツールセットは この課題に対する実践的な解決策を提供しています。今後のソフトウェア開発において これらの知見はますます重要性を増すでしょう。13 Internal developer platforms第13章「Internal developer platforms」は アーキテクチャ現代化における開発者体験の重要性から始まり 独立した価値ストリームを実現するためのプラットフォーム戦略 そして 組織全体での効果的なプラットフォーム運用に至るまで 幅広いトピックをカバーしています。この章を通じて著者は組織がいかに優れたIDPを構築し 継続的なイノベーションを実現できるかを示しています。この資料は秀逸なので読んでほしいです。 speakerdeck.com自分のブログもこちらに添えさせていただきます。syu-m-5151.hatenablog.com開発者体験の本質著者は優れた開発者体験(DX)を独立した価値ストリームの基盤として位置付けています。最も重要なのはチームが価値創造に集中できる環境を整備することです。私の経験でも 多くの組織で開発者は本質的ではない作業に時間を取られすぎています。ある企業では新しいサービスの立ち上げに数週間を要し その大半がインフラ構築やCI/CDパイプラインの設定に費やされていました。単なる開発効率の改善だけでなく イノベーションの速度も重要な指標です。ある金融機関では 新機能のリリースに数ヶ月を要していましたが その大半は手作業による検証とデプロイメントプロセスでした。IDPの導入後は これらのプロセスが自動化され リリースサイクルは週単位まで短縮されました。結果として 競合他社に先駆けた新機能の展開が可能となりました。現代の開発者体験に求められる要件は厳格です。著者は新規アプリケーションを1日以内にプロダクションまで到達させることを基準として挙げています。これはHMRCのMDTPプラットフォームの事例で示されるように 実現可能な目標です。MDTPでは60以上のチームが日次デプロイメントを実現し 新規サービスの立ち上げも数分で完了できました。私の実践では セルフサービス化が鍵となります。あるEコマース企業では 各種リソースの作成やデプロイメントに毎回プラットフォームチームへの依頼が必要でした。この非効率な状況を改善するため AWSのようなセルフサービスモデルを参考に プラットフォームを再設計しました。その結果 開発チームは必要なときに即座にリソースを利用できるようになり 生産性が大幅に向上しました。Figure 13.1 The role of IDPs in enabling independent value streams より引用Figure 13.1は開発者体験とIDPの関係性を示しています。IDPは開発者の認知負荷を軽減し 価値創造に集中できる環境を提供します。これは単なる技術的な問題ではなく 組織の競争力に直結する戦略的な課題です。プラットフォームの基本能力著者は効果的なIDPが備えるべき能力として ゴールデンパス ビルド・デプロイパイプライン 可観測性 アプリケーションカタログなどを挙げています。中でも重要なのはゴールデンパスです。これは新規アプリケーション作成のための自動化された手順を提供します。可観測性の実現も重要な要素です。私が関わった製造業のプロジェクトでは 本番環境でのトラブルシューティングに多大な時間を要していました。OpenTelemetryを活用した統合的な監視基盤を整備することで 問題の特定と解決が格段に効率化されました。さらに プロアクティブな性能改善も可能となり システムの安定性が向上しました。Figure 13.2 Paved road for creating a new microservice and pushing to production in just a few hours より引用Figure 13.2は英国のネオバンクにおけるゴールデンパスの実装例を示しています。彼らは2000以上のマイクロサービスを運用しながら 数時間でプロダクションへのデプロイを実現しています。このような俊敏性は標準化された技術スタックと自動化された開発フローによって支えられています。私の実務経験でも ゴールデンパスの価値は明らかでした。あるプロジェクトでは Spring Boot ベースのマイクロサービステンプレートを整備し デプロイメントパイプラインやモニタリングの設定を自動化しました。その結果 新規サービスの立ち上げ時間は2週間から2時間へと劇的に短縮されました。アプリケーションカタログの整備も重要です。ある大規模組織では 類似機能を持つAPIが複数存在し 運用コストの増大を招いていました。Backstageを活用したカタログ整備により APIの可視性が向上し 再利用が促進されました。結果として 開発コストの削減と品質の向上を実現できました。プラットフォーム運用の実践著者はIDPをプロダクトとして扱うことの重要性を強調しています。これは単なる技術的なインフラストラクチャではなく 継続的に進化するサービスとして捉える必要があります。La Redouteの事例は この考え方を実践的に示しています。プロダクトマインドセットの具体的な実践として 定期的なフィードバックの収集があります。私のチームでは四半期ごとに開発者満足度調査を実施し その結果をプラットフォームの改善計画に反映しています。また 月次のプラットフォームユーザー会を開催し 開発者との直接対話の機会を設けています。彼らはプラットフォーム運用において 品質 効率性 スピードの3つの指標を重視しました。特筆すべきは プラットフォームチームが開発者を顧客として扱い その体験を継続的に改善していた点です。これは私が経験した多くのプラットフォームチームとは異なるアプローチでした。セキュリティとコンプライアンスの統合も重要な課題です。ある金融機関では セキュリティ要件の充足に多大な工数を要していました。IDPにセキュリティチェックを組み込むことで この問題を解決しました。自動化されたコードスキャンと監査ログの生成により コンプライアンス対応が効率化されました。プラットフォーム運用で重要なのは標準化と柔軟性のバランスです。MDTPの事例では Scala と Play Framework への強い標準化により 高度な自動化を実現しました。一方でNetflixは より柔軟なアプローチを採用し チームの技術選択の自由度を高く保っています。プラットフォームチームの構成も成功の鍵となります。私の経験では エンジニアリングスキルとプロダクトマインドセットを併せ持つ人材が必要です。また サポート担当とプラットフォーム開発者を分離し それぞれが専門性を発揮できる体制を整えることも有効でした。投資判断の指針著者は最小限の実行可能なプラットフォーム(TVP)という概念を提示しています。これは大規模なビッグバンプロジェクトを避け 必要最小限の機能から始めることを推奨します。私も同意見です。過去に関わった大規模なプラットフォーム構築では 2年の開発期間を経ても利用率が低く 投資対効果の説明に苦慮した経験があります。プラットフォーム構築の判断基準として 著者は組織の規模だけでなく採用可能性も重視します。技術スタックの強制や既存システムからの移行コストが高い場合 プラットフォームは形骸化するリスクがあります。実践的なアプローチとして 段階的な展開が有効です。あるプロジェクトでは まずCI/CDパイプラインの標準化から着手し その価値が認められた後に他の機能を順次追加していきました。このアプローチにより 投資対効果の可視化と関係者の合意形成が容易になりました。ビルドvs購入の判断も重要です。市場には様々なプラットフォームソリューションが存在します。私の経験では 汎用的な機能は既存ソリューションを活用し 組織固有のニーズに対応する部分のみを内製する戦略が効果的でした。まとめ本章はIDPの構築と運用に関する包括的な指針を提供しています。特に価値があるのは開発者体験を中心に据えたアプローチです。プラットフォームチームは技術的な卓越性だけでなく サービスマインドセットを持つことが求められます。今日のソフトウェア開発において IDPは組織の競争力を左右する重要な要素となっています。しかしその構築には慎重な判断と継続的な投資が必要です。プラットフォーム構築を検討する組織は まず最小限の機能から始め 利用状況と価値創出を確認しながら段階的に発展させていくアプローチを採用すべきでしょう。重要なのは IDPを単なるツール群としてではなく 組織の開発生産性とイノベーション能力を高めるための戦略的資産として位置付けることです。その成功は技術的な選択だけでなく 組織文化や人材育成を含めた包括的なアプローチにかかっています。優れたIDPは 開発者が本質的な価値創造に集中できる環境を提供し 組織全体のイノベーション能力を高めます。今後も クラウドネイティブ技術の進化や開発手法の多様化に応じて IDPの重要性は増していくでしょう。アーキテクトとして この領域への深い理解と実践的な経験がますます求められています。14 Data mesh revolutionizing data engineering第14章「Data mesh revolutionizing data engineering」は データ管理の基本概念とその進化から始まり データメッシュの4つの原則とその実践 そしてデータ量子という革新的な概念の導入に至るまで データエンジニアリングの現代化に関する包括的な内容を提供しています。この章を通じて 著者は従来のデータ管理手法の限界と それを克服するためのデータメッシュアーキテクチャの可能性を示しています。syu-m-5151.hatenablog.comデータエンジニアリングの変遷と課題著者はまず データエンジニアリングの歴史的な変遷を振り返ります。1971年のCoddによるリレーショナルデータベースの提案から データウェアハウス データレイクに至る進化を辿っています。私も同様の変遷を経験してきましたが 各段階で新たな課題が生まれていく様子を興味深く見てきました。Figure 14.1 A data warehouse and some of its ingestion process より引用Figure 14.1は データウェアハウスのアーキテクチャを示しています。自動車部品小売企業の例では 顧客情報やトランザクションデータが複数のプロセスに分割され 新しい要件への対応に多大な労力を要します。例えば ロイヤリティプログラムの追加には新たなプロセスの構築が必要となり 既存のデータフローにも影響を与えます。一方 データレイクは データ取り込みの簡素化を実現しましたが 新たな課題を生み出しました。データの民主化という理想は データアクセスの複雑さという現実に直面します。私のプロジェクトでも データレイクの導入により データの取り込みは容易になりましたが データサイエンティストが必要なデータを見つけ出し 適切な形式に変換するまでに多大な時間を費やす状況が続きました。私の経験では この両者の問題は 中央集権的なチーム構造に起因することが多いです。ドメイン知識のないチームが全社的なデータパイプラインを管理するため 変更に対する柔軟性が失われていきます。あるプロジェクトでは 新しい分析要件に対応するために3ヶ月もの調整期間を要しました。この状況は データエンジニアの生産性とビジネスのアジリティを著しく低下させます。データメッシュの4つの原則著者は データメッシュを支える4つの原則として ドメイン所有権 プロダクトとしてのデータ セルフサービスプラットフォーム 連邦型計算ガバナンスを挙げています。これらは単なる技術的な原則ではなく 組織構造とアーキテクチャの共進化を促す指針です。ドメイン所有権は ビジネスドメインの専門家とデータアーキテクトを結びつけます。私のプロジェクトでも この原則の導入により データ品質が大幅に向上しました。ドメイン専門家が直接データの定義と品質基準に関与することで より適切なデータモデルの構築が可能になりました。例えば ある製造業のプロジェクトでは 工場のエンジニアと直接協働することで 生産データの品質基準を現場の実態に即して定義できました。プロダクトとしてのデータは 従来のプロジェクトベースのアプローチからの大きな転換を意味します。著者は DAUNTIVSという原則を提示し データプロダクトが持つべき特性を説明しています。これは 発見可能性 アドレス可能性 理解可能性 ネイティブなアクセス可能性 信頼性と真実性 相互運用性と組み合わせ可能性 価値 セキュリティを表します。Figure 14.4 The data quantum takes the shape of a hexagon, highlighting its multiple endpoints, allowing access to data, metadata, observability, and control. より引用Figure 14.4は データ量子という革新的な概念を示しています。これは従来のモノリシックなデータレイクとは異なり ドメイン単位で分割された最小のデプロイ可能な要素です。私の経験では この粒度の設定が成功の鍵となります。ある金融機関では 顧客データを過度に細分化したため 管理コストが増大し パフォーマンスも低下しました。適切な粒度を見出すには ビジネス要件とシステムの複雑性のバランスを慎重に検討する必要があります。データ契約の重要性著者はデータ契約をデータメッシュの中核的な要素として位置付けています。これは単なるスキーマ定義ではなく データプロダクトの振る舞いを定義する包括的な文書です。データ契約には 基本的な要素や論理・物理スキーマ データ品質ルール ガバナンスポリシー SLAなどが含まれます。私の実践では データ契約の導入により チーム間のコミュニケーションが大幅に改善されました。特にデータ品質とガバナンスの要件を明確に定義できる点は 規制要件の厳しい金融業界で重要な価値を持ちます。あるプロジェクトでは データ契約をGitで管理し 変更履歴を追跡可能にすることで コンプライアンス要件への対応も容易になりました。しかし データ契約の策定と維持には相応のコストがかかります。経験上 契約の粒度と更新頻度のバランスが重要です。過度に詳細な契約は維持コストを増大させ 逆に粗すぎる契約は価値を失います。私たちは 四半期ごとのレビューサイクルを設定し 継続的な改善を図っています。実装アプローチと経験プレーン著者は データメッシュの実装を3つの経験プレーンで構造化しています。インフラストラクチャ経験プレーンは基盤となるインフラストラクチャを提供し データプロダクト経験プレーンはデータプロダクトの管理を担当します。そしてメッシュ経験プレーンがこれらを統合し 全体としての価値を生み出します。実装において重要なのは サイドカーパターンの活用です。共通のサービスやライブラリをサイドカーとして実装することで 再利用性が高まり 開発効率が向上します。私のプロジェクトでは このアプローチにより 新規データプロダクトの開発期間を約40%削減できました。具体的には 認証 ログ収集 メトリクス収集などの共通機能をサイドカーに集約し 各データプロダクトはビジネスロジックに集中できる環境を整備しました。データ量子の実装では ディスカバリー＆ディクショナリーサービス オブザーバビリティサービス コントロールサービス データオンボーディング 相互運用可能なデータという5つのコンポーネントを適切に構成する必要があります。特に重要なのは オブザーバビリティの実現です。データの品質や可用性を継続的にモニタリングすることで 問題の早期発見と対応が可能になります。まとめデータメッシュは 単なる技術的なアーキテクチャパターンを超えて データエンジニアリングの組織的な変革を促す枠組みを提供しています。4つの原則は それぞれが相互に依存し補完し合う形で 全体としての価値を生み出します。私の経験では 最も重要なのは段階的な導入アプローチです。小規模なパイロットから始め 成功事例を積み重ねていくことで 組織全体の変革を推進できます。また データ契約の整備と標準化は 長期的な成功の鍵となります。具体的には まず重要度の高いのドメインを選定し そこでの成功体験を組織全体に展開していく戦略が効果的です。データメッシュの導入には 技術的な課題だけでなく 組織的な課題も存在します。特に重要なのは データプロダクトオーナーシップの確立です。ビジネスドメインの専門家がデータの品質と価値に責任を持つ文化を醸成することが 成功への近道となります。現代のデータ駆動型組織において データメッシュは避けては通れないトレンドとなっています。その成功は技術的な選択だけでなく 組織文化の変革とチームの自律性を含めた包括的なアプローチにかかっています。アーキテクトとして 技術的な深さと組織的な視点の両方を持ち合わせることが 今後ますます重要になっていくでしょう。データメッシュの導入を検討する組織には まず現状の課題を明確に特定し 段階的な移行計画を立てることを推奨します。特に重要なのは 早期の価値創出です。小さな成功を積み重ねることで 組織全体の変革モメンタムを維持できます。また 継続的な学習と改善のサイクルを確立し データメッシュの進化に合わせて組織も成長していく体制を整えることが 長期的な成功につながります。15 Architecture modernization enabling teams第15章「Architecture modernization enabling teams」は アーキテクチャ現代化を支援するチーム（AMET）の設立から その役割と進化 そして組織への長期的な影響に至るまで アーキテクチャ現代化のための組織的なアプローチを包括的に論じています。この章を通じて 著者は単なる技術的な改善を超えて 持続可能な組織の変革を実現するためのフレームワークを提示しています。スイッチ！作者:チップ・ハース,ダン・ハース早川書房AmazonAMETの本質と目的著者はAMETを 現代化のモメンタムを維持し 長期的な組織変革を実現するための触媒として位置付けています。私の経験でも アーキテクチャ現代化の最大の課題は技術的な側面ではなく 組織全体での持続的な改善の実現にあります。Figure 15.1 An AMET is an enabling team that facilitates stream-aligned teams (and other stakeholders) during the modernization journey. より引用Figure 15.1は AMETの基本的な役割を示しています。AMETは単なる技術指南役ではなく ストリーム整合型チームとその他のステークホルダーを支援し 組織全体の現代化能力を向上させる役割を担います。この点は極めて重要です。過去に関わったプロジェクトでは 技術的に優れたアーキテクトが指示を出すだけのケースがありましたが それでは真の組織的な成長は実現できませんでした。AMETの主要な責任は6つの課題に対応することです。取り組みの開始 モメンタムの維持 より良い設計の実現 持続的な変化の促進 ビジョンと進捗の共有 そして成功事例と学びの共有です。私の経験では 特にモメンタムの維持が重要です。ある組織では 最初の数ヶ月は順調に進んでいたものの 日常業務の圧力で現代化への取り組みが停滞しました。この事態を打開するため AMETがワークショップを開催し 現代化の価値を再確認する機会を設けました。その結果 チームの士気が回復し 取り組みを継続できました。ソフトウェアアーキテクチャメトリクス ―アーキテクチャ品質を改善する10のアドバイス作者:Christian Ciceri,Dave Farley,Neal Ford,Andrew Harmel-Law,Michael Keeling,Carola Lilienthal,João Rosa,Alexander von Zitzewitz,Rene Weiss,Eoin Woodsオーム社Amazonチームの構成と能力AMETの成功には 適切なスキルセットとマインドセットを持つメンバーの選定が不可欠です。技術的な専門性はもちろんですが それ以上に重要なのはイネーブリングマインドセットです。私はAMETのメンバー選定において この点を特に重視しています。例えば ある大規模な金融機関では 技術的に優れたアーキテクトを集めてAMETを構成しましたが うまく機能しませんでした。彼らは自身の技術的な正しさを主張することに注力し 各チームの状況や制約を理解しようとしませんでした。結果として チーム間の対立が生まれ 現代化の取り組み全体が停滞しました。一方で 成功事例もあります。ある製造業のプロジェクトでは AMETのメンバーが各チームと定期的な1on1を実施し 信頼関係の構築に注力しました。また 技術的な課題に直面したチームに対して 解決策を押し付けるのではなく 一緒に考えるアプローチを採用しました。この結果 チーム間の協力関係が強化され 現代化の取り組みが加速しました。Figure 15.5 AMET involvement decreases as the organization upskills より引用Figure 15.5は AMETの関与度が組織のアーキテクチャ能力の向上とともに変化していく様子を示しています。初期段階では強いリーダーシップを発揮し 徐々にその役割を変化させていくことが重要です。私のプロジェクトでも この段階的なアプローチが効果的でした。最初は具体的な指示を出していましたが チームの能力が向上するにつれて アドバイザリーな立場へと移行していきました。アーキテクトの教科書 価値を生むソフトウェアのアーキテクチャ構築作者:米久保 剛翔泳社Amazonアーキテクチャ運用モデルの確立AMETの重要な役割の一つは 持続可能なアーキテクチャ運用モデルの確立です。著者は4つのモデルを提示しています。善意の独裁者 第一人者 アーキテクトなしのアーキテクチャ そして囚人による運営です。これらのモデルは単なる組織構造ではなく アーキテクチャ意思決定の方法を規定する枠組みです。私はこれらのモデルを状況に応じて柔軟に組み合わせることを推奨します。例えば あるプロジェクトでは 初期段階では善意の独裁者モデルを採用し 組織の成熟度が向上するにつれてアーキテクトなしのアーキテクチャへと移行しました。このアプローチにより 初期の方向性の一貫性を保ちながら 長期的な自律性を実現できました。運用モデルの選択では 組織文化との整合性も重要です。ある組織では 高度に自律的な文化があったため 最初から第一人者モデルを採用しました。各チームに一人のアーキテクトを配置し チーム内での意思決定を重視しました。この判断により 現場での迅速な意思決定が可能になり 開発の速度が向上しました。また 意思決定プロセスの明確化も重要です。AMETは組織全体のアーキテクチャ意思決定プロセスを定義し 文書化する必要があります。私のプロジェクトでは Architecture Decision Records (ADR)の活用を推奨し 重要な意思決定の背景と理由を記録する習慣を確立しました。これにより チーム間での知識共有が促進され 一貫性のある意思決定が可能になりました。段階的な導入とスケーリング欧州の通信事業者の事例は AMETの実践的な導入方法を示しています。彼らは外部コンサルタントのJoão Rosaと協力し オペレーティングモデル探索チームを設立しました。このチームは 組織内の多様な視点を持つメンバーで構成され 現代化の方向性を探索する役割を担いました。注目すべきは 段階的なアプローチです。まず特定の領域（例：eコマースとeケア）に焦点を当て 現状の境界とその選択理由を理解することから始めました。この過程でEventStorming Capability Mapping Value Stream Mappingなどの手法を活用し 候補となるドメインとサービスの境界を特定していきました。私の経験でも このアプローチは効果的です。ある小売業のプロジェクトでは まず在庫管理システムの現代化からスタートし そこでの成功体験を基に他の領域へと展開していきました。小さな成功を積み重ねることで 組織全体の信頼を獲得し より大規模な変更への支持を得ることができました。アーキテクチャギルドの活用Comcastの事例は アーキテクチャギルドの効果的な活用を示しています。彼らは分散した技術組織において チャットツールとメーリングリストを活用した非同期のコミュニケーションを重視しました。また ワーキンググループの設立と意思決定プロセスの明確化により 大規模組織での効果的な意思決定を実現しました。私の経験では アーキテクチャギルドの成功には 明確な目的と運営ルールが不可欠です。ある組織では ギルドが単なる情報共有の場となってしまい 実質的な意思決定機能を果たせませんでした。目的とルールを明確化することで より効果的な運営が可能になります。また ギルドの進化も重要です。初期段階では標準化や技術選定に焦点を当てていたギルドが 徐々にイノベーションや知識共有の場へと発展していくケースがあります。この進化を促進するため 定期的なハッカソンや技術カンファレンスの開催を支援することも効果的です。成功のための重要要素著者は AMETの成功には リーダーシップの支援と適切な権限が不可欠だと指摘しています。私も完全に同意します。ある組織では AMETが形式的には設立されたものの 実質的な権限が与えられず 結果として現代化の取り組みが形骸化してしまいました。適切なリソースの確保も重要です。最低でも2名のフルタイムメンバーが必要です。パートタイムのみの構成では 日常業務に埋没してしまい AMETの本来の目的を達成できません。私のプロジェクトでは 3名のフルタイムメンバーと 必要に応じて参加する3名のパートタイムメンバーという構成が効果的でした。また 外部の知見の活用も検討すべきです。ただし 外部コンサルタントへの依存は避ける必要があります。私の実践では 外部の専門家を教育者として活用し 組織内の能力向上を図るアプローチが効果的でした。コミュニケーションとビジョンの共有AMETの重要な役割の一つは 現代化のビジョンと進捗の共有です。これは単なる情報発信ではなく 組織全体の方向性を合わせる重要な活動です。例えば あるプロジェクトでは 月次の全体会議で各チームの成功事例を共有し モチベーションの維持と知見の展開を図りました。また コミュニティの形成も重要です。技術ブログの開設や社内カンファレンスの開催を通じて 現代化に関する知識と経験を共有する場を作ることで 組織全体の能力向上を促進できます。私のプロジェクトでは 四半期ごとの技術カンファレンスが大きな効果を発揮しました。まとめAMETは アーキテクチャ現代化における重要な触媒として機能します。その成功には 適切なメンバーの選定 段階的なアプローチ そして持続可能な運用モデルの確立が不可欠です。ただし AMETは常に必要なわけではありません。組織の状況に応じて その必要性を慎重に判断することが重要です。特に重要なのは AMETを一時的なチームとして捉え その役割を組織に根付かせることです。最終的には AMETという足場を外しても 組織が自律的に現代化を進められる状態を目指すべきです。アーキテクトとして この移行プロセスをいかに効果的に支援できるかが 私たちの重要な責務となります。現代のソフトウェア開発において アーキテクチャの現代化は避けては通れない課題です。AMETは この課題に対する効果的なアプローチを提供します。その成功は 技術的な側面だけでなく 組織文化の変革とチームの自律性を含めた包括的なアプローチにかかっています。私たちアーキテクトは この変革の触媒として その責務を果たしていく必要があります。16 Strategy and roadmaps第16章「Strategy and roadmaps」は、アーキテクチャ現代化の戦略立案から始まり、段階的な実現アプローチ、組織全体への展開、そして継続的な評価と適応に至るまで、包括的な実践的ガイダンスを提供しています。著者は「nail it then scale it」という原則を通じて、大規模な組織変革を実現可能な形へと分解し、確実な成功へと導くアプローチを示しています。この辺は達人プログラマーにもどうようの記載があったなぁって感じています。達人プログラマー ―熟達に向けたあなたの旅― 第2版作者:David Thomas,Andrew Huntオーム社Amazon戦略構築の本質と実践効果的な現代化戦略の最重要要素は、全てのステークホルダーを巻き込む説得力のあるナラティブの構築です。著者は、技術的な負債や再構築といった工学的な用語だけでは、技術部門外の関係者の理解と支持を得ることは難しいと指摘します。この主張は極めて現実的です。私が関わった現代化プロジェクトでも、技術的な議論に終始したケースでは、経営層からの十分な支援を得ることができず、結果として現代化の範囲や速度が制限される事態に陥りました。Figure 16.2 Basic elements of a modernization strategy deck より引用Figure 16.2は戦略デッキの4つの基本要素を示しています。ビジネスコンテキスト、課題と障害、現代化の目的とイニシアチブ、優先順位とロードマップという構成は、論理的で説得力のある物語を紡ぎ出すための効果的な枠組みを提供します。特に重要なのは、これらの要素が単なる構造ではなく、全てのステークホルダーの共感を得るためのストーリーテリングのツールとして機能する点です。戦略デッキの構築で特に注目すべきは、定量的データと感情的要素の組み合わせです。CodeSceneによる技術的負債の可視化やDORAメトリクスによる業界比較といった客観的データに加え、従業員の生の声や具体的なインシデント事例を組み込むことで、より説得力のある物語を構築できます。この手法は特に経営層とのコミュニケーションで効果を発揮します。数値データは意思決定の根拠を提供し、実例や個人の声は課題の切実さを伝えることができます。初期フェーズの戦略的重要性著者は「nail it then scale it」アプローチの一環として、3-6ヶ月以内に最初のスライスを実現することを推奨しています。このタイムフレームは、価値の証明と学習の機会として適切なバランスを提供します。IgluCruise.comのCIO Scott Millettの事例は、この実践的アプローチの有効性を示す好例です。彼らは戦略を具体的な行動に落とし込み、段階的な実現を通じて組織全体の変革を達成しました。Figure 16.7 Hypothetical roadmap for delivering a first slice within six months より引用Figure 16.7は、6ヶ月以内に最初のスライスを実現するための理想的なロードマップを示しています。このアプローチの核心は、実行可能性の高い小さな成功を積み重ねることにあります。私のプロジェクト経験でも、大規模な変革を一度に実現しようとするアプローチは、多くの場合予期せぬ障害に直面し、モメンタムを失うリスクが高いことを実感しています。初期フェーズの成功には、優先順位付けのフレームワークが不可欠です。著者が提案するModernization Core Domain Chartとスコアカードは、複数の候補から最適な開始点を選定するための実践的なツールを提供します。私の実践では、この手法を用いてチーム間で優先順位の議論を行うことで、より客観的で建設的な意思決定が可能になりました。組織全体への展開と課題現代化の展開フェーズでは、プレイブックの活用が重要な役割を果たします。プレイブックは標準的なパターンやプロセスを文書化することで、知識の展開と再利用を促進します。しかし、著者は単なる技術的な手順書以上のものとしてプレイブックを位置付けています。効果的なプレイブックには、選択基準、前提条件、実例、教訓など、実践的な知恵が含まれるべきです。組織全体への展開で特に重要なのが、依存関係の管理です。依存関係の早期特定と適切な評価は、プロジェクトの遅延や追加コストを防ぐ上で重要です。私の経験では、依存関係の管理は技術的な側面だけでなく、組織的なコミュニケーションの課題としても重要です。アーキテクト定例会議やエンジニアリングオフサイトなど、定期的な情報交換の機会を設けることで、潜在的な依存関係を早期に発見できました。mobile.deの事例は、変更コストの概念を用いた投資判断の有効性を示しています。彼らは変更コストを可視化することで、技術的負債への投資の必要性を経営層に説得力を持って説明することに成功しました。この事例は、技術的な課題をビジネス価値と結びつけて説明することの重要性を示しています。継続的な評価と適応著者は、現代化の戦略とロードマップを静的なものではなく、継続的に進化する生きた文書として捉えることの重要性を強調しています。これは極めて重要な指摘です。私のプロジェクト経験でも、初期の計画通りに進まないケースが大半でした。重要なのは、この「ずれ」を失敗とせず、学習と適応の機会として活用することです。Figure 16.1 An evolutionary approach to modernization strategy and roadmaps より引用Figure 16.1が示すように、継続的な学習と適応のサイクルは、現代化の成功に不可欠です。著者は、メトリクス、パルスサーベイ、各種集会など、多様なフィードバック収集の手法を提案しています。特に注目すべきは、定量的指標と定性的フィードバックの組み合わせです。数値指標は客観的な進捗管理を可能にし、定性的なフィードバックは潜在的な課題や改善機会の発見を促進します。組織全体の学習を促進するには、効果的なフィードバックチャネルの確立が重要です。リスニングツアーやワークショップ、定期的なレトロスペクティブなど、様々な形式でのフィードバック収集を組み合わせることで、より包括的な理解と改善が可能になります。私の実践では、四半期ごとの大規模なレトロスペクティブと月次の小規模なフィードバックセッションを組み合わせることで、短期的な調整と長期的な方向性の修正のバランスを取ることができました。まとめ本章は、アーキテクチャ現代化における戦略とロードマップの重要性を、実践的な視点から包括的に論じています。特に価値があるのは、説得力のあるナラティブの構築と段階的な実現アプローチの組み合わせです。これにより、技術的な理想と組織的な現実のバランスを取りながら、持続可能な変革を実現することが可能になります。現代のソフトウェア開発組織において、アーキテクチャ現代化は避けて通れない課題です。本章で示された原則とツールセットは、この課題に対する実践的な解決策を提供しています。特に重要なのは、技術的な側面だけでなく、組織全体の変革という視点で現代化を捉えることです。私たちアーキテクトは、この包括的な視点を持ちながら、組織の持続的な進化を支援していく必要があります。最後に強調したいのは、現代化の成功は継続的な適応と学習のプロセスにあるという点です。完璧な計画を立てることは不可能ですが、早期に価値を証明し、フィードバックを基に継続的に改善していくアプローチにより、確実な成功への道を切り開くことができます。この原則を理解し、実践することが、現代のソフトウェアアーキテクトには求められています。17 Learning and upskilling第17章「Learning and upskilling」は、新しいアイデアの組織への導入から始まり、組織全体での継続的な学習文化の醸成、そして現代化プロジェクトに必要なスキル開発に至るまで、幅広いトピックをカバーしています。著者は、技術的な進歩が人類の歴史において常に重要な役割を果たしてきたという視点から、現代の組織が直面する学習と適応の課題を体系的に論じています。Unlearn（アンラーン）　人生100年時代の新しい「学び」作者:柳川 範之,為末 大日経BPAmazon新しいアイデアの導入と定着著者はシードプランティング（種まき）という比喩を用いて、新しい考え方やプラクティスの導入プロセスを説明します。この比喩は特に印象的です。私の経験でも、新しいアプローチを一朝一夕に導入できた例はほとんどありません。むしろ、小さな成功を積み重ね、組織の中で徐々に理解と支持を広げていくアプローチが効果的でした。PayFitの事例は、このアプローチの有効性を端的に示しています。彼らはDDDの導入において、まず少人数の書籍クラブから始め、その輪を徐々に広げていきました。この過程で興味深いのは、技術者だけでなく、製品やデザインの専門家も巻き込んでいった点です。私も以前、マイクロサービスアーキテクチャの導入で同様のアプローチを採用し、成功を収めました。最初は2-3人の技術リーダーと勉強会を始め、実験的なプロジェクトで成果を示し、その経験を基に組織全体への展開を図りました。プロジェクトニーズに応じたスキル開発現代化プロジェクトの成否は、チームのアップスキリング（スキル向上）にかかっています。著者は、プロジェクト開始前の早期スキル評価と、学習機会の確保の重要性を強調します。私の経験では、この点を軽視したプロジェクトの多くが失敗に終わっています。あるプロジェクトでは、新技術の導入を急ぐあまり十分な学習時間を確保せず、結果として開発の遅延と品質の低下を招きました。学習アプローチの選択では、著者は複数の選択肢を提示します。書籍、トレーニング、メンタリング、実践的な学習など、状況に応じた適切な組み合わせが重要です。私のチームでは、AWS認定試験の取得を目標にした学習プログラムを導入しました。具体的な目標があることで、チームメンバーのモチベーションが高まり、結果として組織全体の技術力向上につながりました。継続的学習環境の確立著者は、継続的な学習を組織のDNAに組み込むことの重要性を強調します。これは極めて重要な指摘です。私が経験した高パフォーマンス組織の多くは、学習を「追加の活動」ではなく「仕事の一部」として位置付けていました。例えば、あるチームでは週次の「ラーニングアワー」を設定し、新技術の調査や実験、ベストプラクティスの共有を行っていました。コミュニティ・オブ・プラクティス（実践コミュニティ）の活用も重要な要素です。著者はEmily Webberの著作を引用しながら、効果的なコミュニティ運営の4つの要件を示します。私の経験では、特に「安全な学習環境の創出」が重要でした。チームメンバーが失敗を恐れずに新しいアイデアを試すことができる環境があってこそ、真の学習と革新が可能になります。CloudSuiteの事例から学ぶ実践CloudSuiteの事例は、現代化における学習主導型アプローチの有効性を示しています。特に注目すべきは、彼らが大規模な計画を立てる前に、まず技術的エクセレンスの確立に注力した点です。私も同様のアプローチで成功を収めた経験があります。ある組織では、マイクロサービスへの移行を進める前に、まずテスト駆動開発とペアプログラミングの習慣を定着させました。これにより、後の大規模な変更をより安全に進めることができました。CloudSuiteの取り組みで特に印象的なのは、ボトムアップ型のドメイン発見プロセスです。彼らは開発者の日常的な課題から出発し、徐々にドメインの理解と境界の特定へと進んでいきました。この事例は、現代化が必ずしもトップダウンの大規模な計画から始める必要がないことを示しています。まとめ本章の最も重要な洞察は、アーキテクチャ現代化における学習とスキル開発が、単なる技術的なトレーニング以上の意味を持つという点です。それは組織文化の変革であり、持続的な改善能力の構築です。特に印象的なのは、著者が歴史的な例（印刷機の発明など）を引用しながら、技術変革における人間の学習と適応の重要性を示している点です。PayFitとCloudSuiteの事例は、現代化における二つの異なるアプローチを示しています。PayFitは書籍クラブという小さな種から組織全体の変革へと発展させ、CloudSuiteは技術的プラクティスの改善から始めて戦略的な変更へと進化させました。これらの事例は、現代化の成功には「正解」となる単一のアプローチは存在せず、組織の文脈に応じた適切な方法を選択する必要があることを示しています。私たちアーキテクトは、技術的な設計だけでなく、組織の学習能力の向上にも注力する必要があります。それは単なるスキルの向上ではなく、組織全体の適応能力と革新能力の向上を意味します。本章で示された原則と事例は、この課題に対する具体的な指針を提供しています。現代化を成功に導くには、技術とヒューマンファクターの両面からのアプローチが不可欠です。おわりに本書の真髄は、アーキテクチャ現代化における「技術」「組織」「戦略」という三つの要素の相互作用と、それらの調和を通じた組織の持続的な競争力の構築にあります。Better Value Sooner Safer Happier (BVSSH)という概念を軸に、技術的な改善、組織的な変革、そして事業戦略の実現を統合的に捉える視座を提供しています。三体問題への実践的アプローチ本書の説得力は、技術・組織・戦略の三要素に対する包括的なアプローチにあります。EventStorming、Wardley Mapping、Team Topologiesなどの手法は、それぞれが実践の場で検証された価値を持ち、三要素の効果的な統合を可能にします。内部開発プラットフォーム(IDP)やデータメッシュといった最新の概念も、この文脈で深い考察が加えられています。IoTデバイスの急増や生成AIの進展など、技術革新の加速度的な進展は、この三体問題をより複雑にしています。本書は、技術的負債による開発者の時間損失や重大なシステム障害の事業影響など、具体的な数値と事例を通じて、この課題の重要性を説得力をもって論じています。持続的な進化のためのフレームワーク「nail it then scale it」という原則に象徴される本書のアプローチは、三体問題に対する実践的な解決策を提示します。3-6ヶ月での最初の成果創出、Architecture Modernization Enabling Team (AMET)の活用、継続的な学習と能力開発の重視など、現代化を持続可能な形で実現するための具体的な方法論が示されています。本書は、アーキテクチャ現代化という課題を通じて、現代システムの三体問題に対する包括的な解答を提供しています。アーキテクトやテクニカルリーダーにとって、本書との出会いは、組織の持続的な進化への確かな指針となるでしょう。2025年もみなさん、最後まで読んでくれて本当にありがとうございます。途中で挫折せずに付き合ってくれたことに感謝しています。読者になってくれたら更に感謝です。Xまでフォロワーしてくれたら泣いているかもしれません。","isoDate":"2025-01-21T03:41:30.000Z","dateMiliSeconds":1737430890000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"なんとなくRustで書いたNeovimプラグイン - cargo.nvim の話","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/15/110831","contentSnippet":"はじめに全てのエンジニアが生成AIやAgentに夢中な2025年。私、nwiizoは今日もNeovimのプラグインを開発しています。今回は、RustのCargoコマンドをNeovimから直接実行できるプラグイン「cargo.nvim」の開発で得た知見を共有したいと思います。🦀 Built cargo.nvim - a Neovim plugin for seamless Rust development. Build \u0026 run Rust right in your editor, no terminal switching needed! ⚡️ #Rust #nvimhttps://t.co/YxVJzpYfmv pic.twitter.com/x5yIdpEdVN— nwiizo (@nwiizo) 2025年1月15日   「なぜRustなんだ？」と思われる方もいるかもしれません。正直に言うと、私もその理由を完全には説明できません。ただ、このプラグインを作るとき、「これはRustで書くべきだ」という強い直感がありました。影響ヒューリスティックというか...直感というか...。もちろん、システムプログラミング言語としての堅牢性や、非同期処理の扱いやすさといった技術的な理由もありますが...実はそれ以上に「Rustでプラグインを書くのがかっこいい」という、エンジニアとしてのロマンを追求した結果です。はい、完全にロマン駆動開発です。「なぜ今更vim？」「それAIで解決できないの？」という声が聞こえてきそうですが、私にとってvimプラグイン開発は単なるツール作りではありません。手触り感のあるエンジニアリング、そう呼びたくなる体験なのです。最新のAIが次々と登場する中で、あえて低レイヤーな開発に没頭する。それは、ある意味で技術的なロマンなのかもしれません。エンジニアの仕事はどんどんAIに寄り添うものになっていくでしょう。それは素晴らしいことだと思います。でも、だからこそ、私は基礎となる技術や職人的なクラフトマンシップを大切にしたいと考えています。そんな思いを込めて、今回はRustでvimプラグインを作ってみました。はい、かなり強引な導入ですが...。良ければGitHubでStarをつけていただけると嬉しいです。みなさんの応援が、「なんとなくRustで書いちゃった」この暴挙（？）の正当性を証明してくれる気がします。きっと...たぶん...。github.comちなみにRust のプロジェクトでこういうリポジトリも存在している。github.comプロジェクトの構造まず、cargo.nvimの基本構造を見てみましょう：.├── Cargo.toml          # Rust の依存関係と設定├── LICENSE            # ライセンス情報├── README.md          # プロジェクトの説明├── build.rs           # ビルド設定├── lua/               # Lua モジュール│   └── cargo/│       └── init.lua   # プラグインのメイン実装├── plugin/            # Neovim プラグイン│   └── cargo.lua      # プラグインのエントリーポイント└── src/              # Rust ソースコード    └── lib.rs        # Rust のコア実装この構造は、RustとLuaのハイブリッドな実装を効率的に管理するために設計されています。RustとLuaの役割分担cargo.nvimの特徴的な点は、RustとLuaを明確に役割分担していることです。この分担により、各言語の強みを最大限に活かした実装を実現しています。Rust (src/lib.rs)の役割Rust側では、プラグインの中核となる処理を担当しています。コアロジックの実装として、Cargoコマンドの実行を制御し、非同期処理を管理します。特に重要なのは、システムレベルの操作やエラーハンドリングの部分です。Rustの型システムと所有権モデルを活用することで、堅牢な実装を実現しています。また、パフォーマンスクリティカルな処理もRustの担当です。コマンド実行の最適化に加え、メモリ管理やスレッド制御など、システムリソースに直接関わる部分を効率的に処理します。これにより、プラグイン全体の実行性能を高いレベルで維持しています。Lua (lua/cargo/init.lua)の役割一方、Lua側はユーザーとの接点となる部分を担当します。UIの実装では、フローティングウィンドウの表示や制御を行い、バッファの管理やキーマッピングの設定を担います。また、シンタックスハイライトによる出力の視覚的な整理も、Luaが担当する重要な役割の一つです。さらに、Neovim APIとの連携も Luaの重要な責務です。イベントハンドリングやバッファ管理、ユーザー設定の処理など、Neovimとの緊密な連携が必要な部分を担当します。Luaの柔軟性を活かし、Neovimの機能を最大限に引き出す実装を行っています。使用している主要なパッケージRustの依存クレート (Cargo.toml)[dependencies]# Lua連携のためのクレートmlua = { version = \"0.9\", features = [\"luajit\", \"module\"] }# JSONシリアライズ/デシリアライズserde = { version = \"1.0\", features = [\"derive\"] }serde_json = \"1.0\"# 非同期処理tokio = { version = \"1.0\", features = [\"full\"] }# HTTPクライアント（将来の拡張用）reqwest = { version = \"0.11\", features = [\"json\"] }各クレートの選定理由と役割について説明します。mluaLuaとRustの橋渡しLua APIの安全な呼び出しエラー処理の統一tokio非同期処理の実装マルチスレッド制御リソース管理serde設定ファイルの読み込みJSONデータの処理型安全なデータ変換アーキテクチャの概要cargo.nvimは2層アーキテクチャを採用しています。これは、RustとLuaの特性を最大限に活かすために慎重に設計された構造です。[Rust Layer]    ↓ mlua[Lua Layer]    ↓ Neovim API[Neovim]この2層アーキテクチャの採用により、プラグインの品質と保守性を大きく向上させることができました。Rust層とLua層の責任を明確に分離することで、各レイヤーの役割が明確になり、コードの見通しが格段に良くなりました。特筆すべきは、mluaを介した層間の連携です。Rustの型安全性と高いパフォーマンスを維持しながら、Luaの柔軟性を活かしたNeovim APIの利用が可能となっています。この組み合わせにより、システムレベルの処理とユーザーインターフェースの実装を、それぞれの言語の強みを最大限に活かして実現できています。また、この構造によってパフォーマンスの最適化も容易になりました。Rustでの処理が必要な重い処理と、Luaで十分な軽い処理を適切に分離することで、全体的な実行効率を高いレベルで維持できています。加えて、今後の機能追加や修正においても、各層の独立性が高いため、変更の影響範囲を最小限に抑えることができます。開発を通じて得られた知見プラグインの開発を進める中で、いくつかの重要な気づきがありました。開発当初から意識していたのは責任分担です。RustとLuaの役割を明確に分けることで、開発の効率が大きく向上しました。Rustにはシステムレベルの処理を任せ、LuaではUI/UXの実装に専念する。この単純な原則が、結果として開発全体をスムーズにしてくれました。エラーハンドリングも大きな学びの一つでした。RustとLuaの特性を活かし、Rust側では可能な限り厳密なエラー処理を行い、Lua側ではそれらのエラーをユーザーにとって理解しやすい形で表示する。この組み合わせが、プラグインの信頼性向上に貢献しています。パフォーマンスについては、特に非同期処理の活用が効果的でした。Cargoコマンドの実行時間が長くなる場合でも、UIの応答性を維持できています。また、メモリ効率を意識した実装により、長時間の使用でもリソース消費を抑えられています。クロスプラットフォーム対応は予想以上に課題となりました。build.rsでの環境別設定や、パス処理の違いへの対応など、細かな配慮が必要でした。面倒なので自分と同じ環境のユーザーのみに対応しましたがユーザーが増えたら対応を考えます。これらの経験は、今後の開発にも活かしていきたいと考えています。Rust層の実装詳細コアストラクチャまず、プラグインの中核となるRustの実装を見ていきます。#[derive(Clone)]struct CargoCommands {    runtime: Arc\u003cRuntime\u003e,}impl CargoCommands {    fn new() -\u003e LuaResult\u003cSelf\u003e {        Ok(Self {            runtime: Arc::new(                tokio::runtime::Builder::new_current_thread()                    .enable_all()                    .build()                    .map_err(|e| LuaError::RuntimeError(e.to_string()))?,            ),        })    }}このコードの重要なポイントは：Cloneトレイトの実装によるランタイムの共有Arcによる安全な参照カウントTokioランタイムの効率的な管理非同期コマンド実行cargo.nvimの核となる機能、Cargoコマンドの実行処理です。impl CargoCommands {    async fn execute_cargo_command(\u0026self, command: \u0026str, args: \u0026[\u0026str]) -\u003e LuaResult\u003cString\u003e {        let mut cmd = Command::new(\"cargo\");        cmd.arg(command);        cmd.args(args);                let output = cmd.output().map_err(|e| {            LuaError::RuntimeError(format!(\"Failed to execute cargo {}: {}\", command, e))        })?;                if !output.status.success() {            let error = String::from_utf8_lossy(\u0026output.stderr);            return Err(LuaError::RuntimeError(format!(                \"cargo {} failed: {}\",                command, error            )));        }                Ok(String::from_utf8_lossy(\u0026output.stdout).into_owned())    }}実装のポイント：- エラーの詳細な伝播- 出力のUTF-8変換処理- ステータスコードによる成功/失敗の判定Lua層の実装詳細ウィンドウ管理Neovimのウィンドウ管理を実装する部分です。local function create_float_win(opts)    -- ウィンドウサイズの計算    local width = math.floor(vim.o.columns * opts.window_width)    local height = math.floor(vim.o.lines * opts.window_height)        -- バッファの作成と設定    local bufnr = vim.api.nvim_create_buf(false, true)    vim.api.nvim_buf_set_option(bufnr, \"buftype\", \"nofile\")    vim.api.nvim_buf_set_option(bufnr, \"swapfile\", false)    vim.api.nvim_buf_set_option(bufnr, \"modifiable\", true)    vim.api.nvim_buf_set_option(bufnr, \"filetype\", \"cargo-output\")        -- ウィンドウ設定    local win_opts = {        relative = \"editor\",        width = width,        height = height,        col = math.floor((vim.o.columns - width) / 2),        row = math.floor((vim.o.lines - height) / 2),        style = \"minimal\",        border = opts.border    }        local winnr = vim.api.nvim_open_win(bufnr, true, win_opts)    return bufnr, winnrend実装のポイント：- 画面サイズに応じた動的なレイアウト- バッファとウィンドウの適切な設定- ユーザーカスタマイズ可能なオプション出力処理コマンド出力の整形と表示を担当する部分です。local function process_output(lines)    local processed = {}    for _, line in ipairs(lines) do        local timestamp = os.date(\"%H:%M:%S\")        local prefixed_line = string.format(\"[%s] \", timestamp)                if line:match(\"^error\") then            table.insert(processed, prefixed_line .. \"@error@\" .. line)        elseif line:match(\"^warning\") then            table.insert(processed, prefixed_line .. \"@warning@\" .. line)        elseif line:match(\"^%s*Compiling\") then            table.insert(processed, prefixed_line .. \"@info@\" .. line)        elseif line:match(\"^%s*Running\") then            table.insert(processed, prefixed_line .. \"@info@\" .. line)        elseif line:match(\"^%s*Finished\") then            table.insert(processed, prefixed_line .. \"@success@\" .. line)        else            table.insert(processed, prefixed_line .. line)        end    end    return processedend実装のポイント：- タイムスタンプによる実行時間の可視化- 出力種別に応じた装飾- 効率的な文字列処理プラグインの初期化と設定動的ライブラリのロードプラグインの初期化時に重要な、動的ライブラリのロード処理です。local function load_cargo_lib()    local plugin_dir = vim.fn.fnamemodify(vim.fn.resolve(debug.getinfo(1, \"S\").source:sub(2)), \":h:h:h\")    local lib_name = vim.fn.has(\"mac\") == 1 and \"libcargo_nvim.dylib\"        or vim.fn.has(\"win32\") == 1 and \"cargo_nvim.dll\"        or \"libcargo_nvim.so\"    local lib_path = plugin_dir .. \"/target/release/\" .. lib_name        if vim.fn.filereadable(lib_path) == 0 then        error(string.format(\"Cargo library not found: %s\", lib_path))    end        return package.loadlib(lib_path, \"luaopen_cargo_nvim\")()end実装のポイント：- クロスプラットフォーム対応- 適切なエラーハンドリング- ライブラリパスの動的解決パフォーマンス最適化のポイントRust側の最適化メモリ効率Arcによる共有リソースの効率的な管理適切なライフタイム管理不必要なクローンの回避非同期処理Tokioランタイムの効率的な利用ブロッキング処理の最小化適切なエラーハンドリングLua側の最適化バッファ管理必要最小限のバッファ更新効率的な行挿入メモリ使用量の最適化ウィンドウ管理リソースの適切な解放イベントの効率的な処理画面更新の最適化おわりに「なんとなく」Rustを選んで始めたcargo.nvimの開発でしたが、結果として多くの学びがありました。特に印象的だったのは、RustとLuaという異なる言語の組み合わせが予想以上に効果的だったことです。当初は「かっこいいから」という理由で選んだRustですが、システムレベルの処理とエラーハンドリングの面で、その選択は正しかったと確信しています。設計面では、「なんとなく」とは正反対の、明確な責任分担の重要性を学びました。RustとLuaの境界をしっかりと定義し、各言語の得意分野を活かすことで、保守性の高い構造を実現できました。また、非同期処理やメモリ効率の最適化など、パフォーマンスに関する知見も得られました。思えば、「なんとなく」から始まったこのプロジェクトは、むしろ「必然」だったのかもしれません。時としてエンジニアの直感は、技術的な正当性を伴って現実のものとなるのだと、身をもって体験しました。今後も、この「なんとなく」と「確信」が混ざり合った独特な開発体験を大切にしながら、より使いやすく、高性能なプラグインを目指して開発を続けていきたいと思います。最後まで読んでいただき、ありがとうございました。自作したツールcargo.nvimについて、This Week in RustにPRを送信したところ、マージされ、\"Great project, thanks for the submission!\"というコメントをいただきました。https://t.co/RB1ExrAhwJ pic.twitter.com/zcUpS6eX2G— nwiizo (@nwiizo) 2025年1月16日   参考リンクcargo.nvim関連cargo.nvim GitHub リポジトリcargo.nvim ドキュメントNeovim開発関連Neovim API ドキュメントNeovim Lua ガイドNeovim プラグイン開発ガイドRust開発関連mlua クレートのドキュメントtokio ドキュメントCargo Bookその他の参考資料Lua 5.4 リファレンスマニュアルRust非同期プログラミングガイド","isoDate":"2025-01-15T02:08:31.000Z","dateMiliSeconds":1736906911000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"既にあるものを正しく使うあるいは、インフラストラクチャをつくるとはどういうことなのか","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/12/202120","contentSnippet":"「既存のツールはどれも使えない。自分たちで作るしかない」はじめにインフラ/プラットフォームチームでよく耳にする言葉です。監視システム、デプロイメントパイプライン、構成管理ツール。エンジニアたちは次々と内製化の道を選びます。しかし、本当にゼロからの開発は必要なのでしょうか。このような判断の裏には、私たちが見落としがちな重要な視点が隠れています。多くのチームが「自前開発」という選択肢に飛びつく前に、立ち止まって考えるべきことがあります。システム運用アンチパターン ―エンジニアがDevOpsで解決する組織・自動化・コミュニケーション作者:Jeffery D. SmithオライリージャパンAmazonインフラストラクチャを「作る」とは何かインフラストラクチャを「作る」行為は必ずしもコードを書くことを意味しません。それは組織のニーズに合わせて適切なツールを選び運用プロセスを設計することです。経験豊富なエンジニアは問題解決の方法を知っています。正しい道具を選び効果的に使う経験を持っているのです。ja.wikipedia.org優れたエンジニアは必ずしも多くのコードを書きません。彼らは既存のツールを深く理解し効果的に組み合わせることで大きな価値を生み出します。toris.ioなぜ私たちは独自開発を選びがちなのか多くのインフラエンジニアは既存ツールよりも独自開発を選びます。その背景にはいくつかの思い込みがあります。最も多いのは「自社の環境は特殊だ」という思い込みです。確かにどの組織にも固有の課題はあります。しかしそれは既存ツールの組み合わせで解決できることが多いのです。次に「既存ツールの学習コストが高すぎる」という過大評価があります。新しいツールを作るコストと比べて本当にそうでしょうか。長期的な運用コストまで考える必要があります。また「技術的チャレンジへの期待」から独自開発を選ぶこともあります。新しい技術を学ぶことは重要です。しかし既存ツールの深い理解と活用にも同様の技術的チャレンジは存在します。正しいものを正しくつくる　プロダクトをつくるとはどういうことなのか、あるいはアジャイルのその先について作者:市谷 聡啓ビー・エヌ・エヌ新社Amazon組織とツールの調和ツール選定で最も重要なのは組織の成熟度とチームの体制に合わせた選択です。これは単なる技術的な判断ではありません。チームの技術力と学習能力は現状と将来の両面から判断が必要です。既存ツールの採用はチームの学習機会にもなります。組織の運用プロセスと文化もツール選択に大きく影響します。例えばGitOpsツールの導入ではチームの作業フローやレビュープロセスも再設計する必要があります。ツールの導入は組織全体の変革につながるのです。「変化を嫌う人」を動かす:魅力的な提案が受け入れられない4つの理由作者:ロレン・ノードグレン,デイヴィッド・ションタル,船木 謙一(監修)草思社AmazonOSSとの関わり方新しいツールを作る代わりに既存のOSSプロジェクトへの貢献を選択する価値は大きいです。これは「作る」から「改善に貢献する」への文化的シフトを意味します。OSSプロジェクトへの貢献は単なるコード提供以上の意味があります。コミュニティとの関わりを通じてチームの視野は広がります。技術力も向上します。3-shake.connpass.comzenn.devインフラストラクチャの価値を最大化するインフラエンジニアとしての価値ある選択は時として「作らない」という判断です。既存のツールやサービスを組織に合わせて活用し真に価値のある部分に時間を投資すべきです。新しいものを作ることは選択肢の一つに過ぎません。より重要なのは組織の目標達成に最も効果的な手段を選ぶことです。そのためには既存ツールの深い理解が必要です。組織のニーズを正確に把握することも欠かせません。 speakerdeck.comまとめインフラストラクチャを「作る」とは新しいツールを開発することだけを意味しません。それは既存の優れたツールを理解し組織に最適な形で導入することです。組織にとって重要なのは、「新しいものを作る」よりも既存のものを効果的に活用し改善に貢献できる文化を育てることです。これにより、インフラストラクチャの真の価値を最大化することができます。同時に、エンジニアにとって新しい技術への挑戦や実装は大きな魅力であり、そこから得られる学びや成長は貴重な財産となります。組織の正解と個人の楽しさは別物ですが、どちらも尊重しなければならないのでバランス感覚は必要です。楽しくなければエンジニアなんて退職してしまいます。優れたエンジニアは、この組織のニーズと個人の技術的探求のバランスを取りながら、キャリアを進めていっている気がします。","isoDate":"2025-01-12T11:21:20.000Z","dateMiliSeconds":1736680880000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"年始にstarshipでプロンプトの式年遷宮を行いたい","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/10/185633","contentSnippet":"適応は適応力を阻害する知識創造企業（新装版）作者:野中 郁次郎,竹内 弘高東洋経済新報社Amazonはじめに開発環境の最適化は、現代のソフトウェア開発において重要な課題です。また、その更新には式年遷宮のように、定期的な刷新には技術の継承と革新という二つの側面があります。しかし、過度な適応は適応力を阻害するという逆説もあります。この視点から、私は開発環境を定期的に見直し、必要な変更を加えています。昨年、その一環としてターミナルエミュレータをWarpに移行しました。Warpは洗練されたUIと優れた機能性を備え、AIによるコマンド提案やブロックベースの出力表示など、モダンな機能により開発効率を大きく向上させてくれました。agnozingdays.hatenablog.com招待があるのでこちらからインストールしてください❤️https://app.warp.dev/referral/9Z8MRV2025年を迎え、新たな改善として開発環境のさらなる最適化を目指しています。特に注目したのが、日々の開発作業で最も頻繁に目にするターミナルのプロンプトです。より詳細な開発環境の状態把握を実現するため、高速でカスタマイズ性の高いクロスシェルプロンプト「starship」の導入を決めました。この記事では、Fishシェルをベースにしたstarshipの導入過程と、具体的な設定内容を共有します。また、WarpとFish、そしてstarshipの組み合わせがもたらす相乗効果についても詳しく解説していきます。starship.rsstarshipの特徴と選択理由starshipは、任意のシェルで動作する、高速で柔軟なプロンプトです。Rustで書かれており、システムリソースを最小限に抑えながら、豊富な情報を表示できることが特徴です。私がstarshipを選択した主な理由は以下の点です。まず、クロスシェル対応という特徴が魅力的でした。開発環境によってbash、zsh、fishなど異なるシェルを使用することがありますが、starshipならば一つの設定ファイルですべてのシェルで同じ見た目と機能を実現できます。次に、Rustで実装されているという点も重要でした。シェルの起動時やプロンプトの更新時のパフォーマンスが優れており、ストレスなく使用できます。特に大規模なGitリポジトリでの作業時でも、プロンプトの更新による遅延をほとんど感じません。また、モジュール式の設計により、必要な情報だけを選択して表示できる点も気に入っています。開発言語やツールの追加・削除が容易で、環境の変化に合わせて柔軟に対応できます。starship.rsインストールと初期設定私は普段からFishシェルを使用しているため、まずFishのインストール状況を確認しました。macOSではHomebrewを使ってFishをインストールしています。brew install fish続いて、starshipもHomebrewでインストールしました：brew install starshipなお、他のOS環境では公式のインストールスクリプトを使用することもできます。curl -sS https://starship.rs/install.sh | shFishシェルの場合、~/.config/fish/config.fishの末尾に以下の初期化コードを追加します。starship init fish | sourceこの設定により、Fishシェルの起動時に自動的にstarshipが初期化されます。私の場合、既にFishの設定ファイルにはテーマやエイリアスなどの設定が含まれていましたが、starshipはそれらと競合することなく動作しています。特に、Fishの持つ構文ハイライトや補完機能との相性が良く、快適な開発環境を実現できています。プロンプトの詳細設定starship.rsstarshipの設定は~/.config/starship.tomlで行います。私の設定では、開発で使用する様々なツールの状態を視覚的に把握できるように工夫しています。github.comそれ以外にも設定のサンプルがあるの使ってみたり、参考にしてもよいかもです。starship.rsプロンプトのレイアウト設定formatセクションでは、プロンプトの全体的な構造を定義しています。パワーライン風のデザインを採用し、各モジュール間を矢印で滑らかに接続しています。format = \"\"\"[](fg:#9A348E)\\$directory\\[](fg:#DA627D bg:#9A348E)\\$git_branch\\$git_status\\[](fg:#FCA17D bg:#DA627D)\\$kubernetes\\[](fg:#86BBD8 bg:#FCA17D)\\$aws\\...このように、各セグメントの背景色を前後で調整することで、矢印型のつなぎ目を実現しています。色は、視認性とアクセシビリティを考慮して選択しました。ディレクトリ表示の最適化カレントディレクトリの表示は、開発作業において最も基本的な情報です。[directory]style = \"fg:#E4E4E4 bg:#9A348E\"format = '[ $path ]($style)'truncation_length = 3truncation_symbol = \"…/\"truncation_length = 3の設定により、ディレクトリの深さが3階層を超える場合は自動的に省略されます。これにより、長いパスでもプロンプトが横に広がりすぎることを防いでいます。また、truncation_symbol = \"…/\"で省略部分を直感的に表現しています。Git情報の詳細表示Git関連の情報は、開発作業において特に重要です。[git_branch]symbol = \" \"style = \"fg:#E4E4E4 bg:#DA627D\"format = '[ $symbol$branch ]($style)'[git_status]style = \"fg:#E4E4E4 bg:#DA627D\"format = '[$all_status$ahead_behind ]($style)'conflicted = \"≠\"ahead = \"⇡${count}\"behind = \"⇣${count}\"diverged = \"⇕\"untracked = \"±${count}\"stashed = \"※\"modified = \"!${count}\"staged = \"+${count}\"renamed = \"»${count}\"deleted = \"×${count}\"Gitの状態を直感的なアイコンで表現することで、リポジトリの状態を一目で把握できます。特に以下の状態を重視しています。コンフリクトの発生（≠）プッシュ・プル待ちの変更（⇡/⇣）作業ディレクトリの状態（未追跡、変更、ステージング）スタッシュの存在（※）これらの情報をコンパクトに表示することで、Git操作のミスを防ぎ、効率的な作業を実現しています。クラウドと開発環境の状態表示現代の開発では、複数のクラウドサービスやコンテナ環境を使用することが一般的です。[kubernetes]symbol = \"☸ \"style = \"fg:#E4E4E4 bg:#FCA17D\"format = '[ $symbol$context(\\($namespace\\)) ]($style)'disabled = false[aws]symbol = \"☁ \"style = \"fg:#E4E4E4 bg:#86BBD8\"format = '[ $symbol($profile)(\\($region\\)) ]($style)'disabled = false[docker_context]symbol = \"🐋 \"style = \"fg:#E4E4E4 bg:#33658A\"format = '[ $symbol$context ]($style)'これらの設定により、以下の情報を常に把握できます。KubernetesのコンテキストとネームスペースAWSとGoogle Cloud プロファイルとリージョンDockerのコンテキスト特にマルチクラウド環境での作業時に、誤った環境で操作してしまうリスクを軽減できます。プログラミング言語とツールのバージョン表示各プログラミング言語やツールのバージョン情報も、プロジェクトごとに適切に表示されます。[golang]symbol = \"🐹 \"style = \"fg:#E4E4E4 bg:#06969A\"format = '[ $symbol($version) ]($style)'[python]symbol = \"🐍 \"style = \"fg:#E4E4E4 bg:#1B9F62\"format = '[ $symbol($version) ]($style)'detect_extensions = [\"py\"]python_binary = [\"python\", \"python3\"][nodejs]symbol = \"⬢ \"style = \"fg:#E4E4E4 bg:#33658A\"format = '[ $symbol($version) ]($style)'detect_extensions = [\"js\", \"ts\", \"tsx\"]detect_files = [\"package.json\", \"tsconfig.json\"][rust]symbol = \"⚙ \"style = \"fg:#E4E4E4 bg:#86BBD8\"format = '[ $symbol($version) ]($style)'detect_extensions = [\"rs\"]detect_files = [\"Cargo.toml\", \"Cargo.lock\"]各言語の設定では、以下の点に注意を払っています。適切なファイル検出設定(認知が追いつかない部分を勝手に取得できるように)わかりやすいアイコンの選択(環境を間違って死なないように)バージョン情報の明確な表示(バージョンの勘違いで泣かないように)また、Terraform、Google Cloudなどのインフラ関連ツールも同様に設定しています。[terraform]symbol = \"🏗 \"style = \"fg:#E4E4E4 bg:#06969A\"format = '[ $symbol$workspace ]($style)'[gcloud]symbol = \"🌐 \"style = \"fg:#E4E4E4 bg:#33658A\"format = '[ $symbol$account(@$domain)(\\($project\\)) ]($style)'時刻表示とプロンプト文字作業時間の管理や、コマンド実行時刻の記録のために、時刻表示も含めています。[time]disabled = falsetime_format = \"%R\"style = \"fg:#E4E4E4 bg:#86BBD8\"format = '[ $time ]($style)'[character]success_symbol = \"❯\"error_symbol = \"❯\"vimcmd_symbol = \"❮\"24時間形式で時刻を表示し、コマンドの実行状態に応じてプロンプト文字を変更します。特にvimモードを使用している場合は、モードの切り替えが一目でわかるようになっています。おわりにstarshipを導入して一週間が経過しましたが、starshipの導入により、開発環境の視認性と操作性が大きく向上しました。新年を迎えるにあたっての環境整備として、非常に満足のいく選択だったと感じています。この設定は、私の開発スタイルに合わせて最適化したものですが、starshipの柔軟な設定システムを活用することで、誰でも自分に最適な開発環境を構築できます。ぜひ皆さんも、自分の作業スタイルに合わせたカスタマイズを試してみてください。設定ファイルは公開していますので、参考にしていただければ幸いです。また、今後も開発環境の改善を続け、さらに効率的な開発環境を目指していきたいと思います。","isoDate":"2025-01-10T09:56:33.000Z","dateMiliSeconds":1736502993000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"RustでのProtocol Buffersを学習するための図書管理システム実装","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/10/133852","contentSnippet":"はじめにProtocol BuffersとRustの実践的な学習を目的として図書管理システムを開発しました。 システムの構築にあたってはBufによるスキーマ管理とコード生成を採用することで開発環境を実現しています。今回の実装を通じてRustにおけるgRPCサービスの構築手法について理解を深めることができました。buf.buildフロントエンド開発については今後の課題として検討しています。 Remixが気になっているので実装したいと思ってます。本記事ではバックエンド実装に焦点を当てて解説します。 特にRustのエコシステムにおけるtonicやSQLxといったライブラリの活用方法に着目します。これらの実装を通じて得られた知見は他のRustプロジェクトにも応用可能な内容となっています。学習目的で実装したコードなので何かに活用していただければ幸いです。github.comプロジェクトのセットアップまず、以下のようなディレクトリ構造を作成します：library-system/├── buf/│   ├── buf.yaml│   ├── buf.gen.yaml│   └── library/│       └── v1/│           └── library.proto├── library-server/└── library-client/Bufの設定buf.yaml:version: v1name: buf.build/yourusername/library-systembreaking:  use:    - FILElint:  use:    - DEFAULTbuf.gen.yaml:version: v1plugins:  - plugin: buf.build/protocolbuffers/rust    out: ../library-server/src    opt:      - bytes=bytes  - plugin: buf.build/community/neoeinstein-tonic-rust    out: ../library-server/src    opt:      - no_client=false      - no_server=falseAPIの設計Protocol Buffersを使用してAPIを定義します：syntax = \"proto3\";package library.v1;import \"google/protobuf/timestamp.proto\";service LibraryService {    rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);    rpc GetUser(GetUserRequest) returns (GetUserResponse);    rpc SearchBooks(SearchBooksRequest) returns (SearchBooksResponse);    rpc CreateLoan(CreateLoanRequest) returns (CreateLoanResponse);    rpc ReturnBook(ReturnBookRequest) returns (ReturnBookResponse);}図書管理システムの実装詳細アーキテクチャと技術選定システムの基盤には非同期処理による高パフォーマンスな実装を採用しました。 Rustの非同期ランタイムであるtokioを活用することでリソースの効率的な利用を実現します。サーバーの起動処理は以下のコードで示すように非同期処理を基本とした設計です。#[tokio::main]async fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {    let service = LibraryServiceImpl::new(\u0026database_url).await?;    Server::builder()        .add_service(LibraryServiceServer::new(service))        .serve(addr)        .await?;    Ok(())}サーバーサイドの主要実装Protocol Buffersによるサービス定義が実装の起点となります。 サーバーの中核機能はLibraryServiceImpl構造体に集約されます。SQLxを用いたデータベース操作により型安全性の高いコードを実現しました。貸出処理のトランザクション制御は特に慎重な実装を必要としました。 以下のコードでは書籍の貸出状態確認から更新までを単一トランザクションで処理します。async fn create_loan(\u0026self, request: Request\u003cCreateLoanRequest\u003e) -\u003e Result\u003cResponse\u003cCreateLoanResponse\u003e, Status\u003e {    let mut tx = self.pool.begin().await?;    let book = sqlx::query_scalar::\u003c_, bool\u003e(\"SELECT available FROM books WHERE id = ?\")        .bind(\u0026req.book_id)        .fetch_optional(\u0026mut *tx)        .await?;    if !book.available {        return Err(Status::failed_precondition(\"Book is not available\"));    }    // 貸出処理の実行    tx.commit().await?;    Ok(Response::new(loan_response))}クライアントサイドの実装ユーザーインターフェースは直感的な操作を重視しました。 クライアントの初期化処理は以下のように簡潔な実装としています。async fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {    let channel = Channel::from_static(\"http://[::1]:50051\").connect().await?;    let client = LibraryServiceClient::new(channel);}エラー処理は利用者の視点を重視した実装としました。 サーバーからのエラーレスポンスを適切にハンドリングすることでユーザーへの明確なフィードバックを実現します。データベース設計データモデルは業務要件を正確に反映する設計としました。 ユーザー情報と書籍情報を管理する基本テーブルに加えて貸出履歴を記録するテーブルを実装します。CREATE TABLE loans (    id TEXT PRIMARY KEY,    book_id TEXT NOT NULL REFERENCES books(id),    user_id TEXT NOT NULL REFERENCES users(id),    loan_date TIMESTAMP NOT NULL,    due_date TIMESTAMP NOT NULL,    return_date TIMESTAMP);スキーマ設計は将来の拡張性を考慮しました。 返却日時や貸出状態を管理するカラムを追加することで機能拡張への対応を可能としています。この実装を通じて学んだ最も重要な点は型安全性とトランザクション管理の重要性です。RustとSQLxの組み合わせにより堅牢なシステムを実現できました。主要な機能ユーザー管理ユーザーの作成ユーザー情報の取得書籍管理書籍の検索在庫状態の管理貸出管理書籍の貸出返却処理貸出状態の追跡参考リソースBuf DocumentationTonic DocumentationSQLx DocumentationProtocol Buffers DocumentationGenerated SDKs for Rust now available on the Buf Schema Registryまとめ今回は図書管理システムを題材にRustとProtocol Buffersを組み合わせた実装を検証しました。 tonicとSQLxを活用したバックエンド開発を通じて両者の親和性の高さを実感できました。Rustの型システムと所有権の概念がProtocol Buffersの型定義と自然に調和する点が特に印象的でした。エラー処理と非同期プログラミングの実装パターンについても有意義な知見を得られました。 RustのResult型とtonicのステータスコードの組み合わせは明快なエラーハンドリングを実現します。またtokioを基盤とした非同期処理はSQLxのトランザクション管理と組み合わせることで堅牢な実装を可能にします。今後は本実装をベースにさらなる検証を進めたいと考えています。 予約システムやユーザー認証の追加を通じてスケーラブルな設計の可能性を探ります。フロントエンド開発ではRemixとTypeScriptを採用することでエンドツーエンドの型安全性についても検証を行う予定です。またDockerコンテナ化やCI/CDパイプラインの整備を通じて本番環境での運用性も確認していきます。RustとProtocol Buffersを主軸とした本プロジェクトは実用的なシステム開発の基盤として十分な手応えを感じる結果となりました。今回得られた知見は今後の開発プロジェクトにも大いに活用できるものと確信しています。最後に初春の誓い 新たに刻みしも昨日の影が まだ私を離さず目標という星は 遠く輝けど手の届かぬ空に ただ揺れている日々は川の流れのように変わらぬ場所を 静かに過ぎゆくされど生は進み刻は確かに 私を育てる明日もまた 新しい朝が来るそれだけが 確かな真実","isoDate":"2025-01-10T04:38:52.000Z","dateMiliSeconds":1736483932000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"NeovimをCursorのように進化させる - yetone/avante.nvim の導入","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/07/220406","contentSnippet":"「もはやCopilotなしでは開発できない」Cursorが体験として革新的すぎる」Clineこそ俺達が求めていたものだ！」とにかく新世代のAIエディターが最高！」  はじめに開発者のタイムラインを開けば、そんな投稿で溢れかえっています。確かに、AIによる開発支援は革新的で、プログラミングの未来を感じさせるものです。特に最近では、単なるコード補完を超えて、より多機能なAIアシスタントとしての役割を担うツールが増えてきています。実は、愛用のNeovimでもこうした最新のAI機能を導入できるんです。しかも、使い慣れたキーバインドやプラグインはそのまま。今回はavante.nvimというプラグインを使って、NeovimをAIパワード開発環境へと進化させる方法をご紹介します。github.comこのプラグインは、私たちvimmerにとって既に身近な存在であるcopilot.luaのような補完機能を超えて、より包括的なAI支援を実現します。コードの理解、リファクタリング、そして対話的なアシスタント機能まで、新世代のAIエディターが持つ機能をNeovimで実現できるのです。これまでのvimmerは、copilot.luaのようなシンプルで効率的なコード補完ツールを活用してきました。しかし、新世代のAIエディターは、コードの解析、リファクタリングの提案、そしてより高度なコンテキスト理解を備えています。この進化に対して、私たちvimmerはどのように向き合うべきでしょうか？でも、待ってください。私たち Vimmer はどうすれば...？ 長年磨き上げてきたNeovimを捨てて、新しいエディターに移行しなければいけないのでしょうか？いいえ、Neovimはもっと強くなれます。Neovimの最大の魅力は、その圧倒的なカスタマイズ性。それは単なるIDE（統合開発環境）ではなく、PDE（Personal Development Environment：個人開発環境）とも呼べる存在です。まるで自分だけの剣を鍛え上げていくように、エディターと共に成長していける。そんな独特の魅力がNeovimにはあります。私たちは常にNeovimを進化させ、新しい可能性を追求してきました。copilot.luaがその一例です。そして今、avante.nvimによって、さらなる進化の時が来ています。Neovim 以外の話はこちらです。laiso.hatenablog.comavante.nvim とはavante.nvimは、Cursor AI IDEの機能を模倣することを目的として開発されたNeovimプラグインです。AI駆動のコード提案機能を提供し、その提案を直接ソースファイルに適用できる機能を備えています。上記のカテゴリーでいうとコーディングエージェントに近いものになります。デモ動画こういう経験がサクッと得られるのでよいです。 https://t.co/x7S08l06v9 pic.twitter.com/X4mvE2c2H7— nwiizo (@nwiizo) 2025年1月7日   subを追加する例です。 https://t.co/x7S08l06v9 pic.twitter.com/EyjDkdzP9c— nwiizo (@nwiizo) 2025年1月7日   Note: GitHub上にデモ動画がありますが、実際の動作の様子を簡単に説明させていただきます：avante.nvimを使用すると、画面右側にAIアシスタントのサイドバーが表示され、現在開いているコードについて対話形式で質問や提案を行うことができます。コードの変更提案は差分形式で表示され、ワンクリックで適用することができます。まさにCursor AI IDEのような操作感を、Neovim上で実現しています。実際の動作については、GitHubのリポジトリでも確認することができます。特徴的な機能AIによるコードアシスタント: 現在のコードファイルについてAIに質問し、インテリジェントな提案を受けることができますワンクリック適用: AIの提案をシンプルなコマンドで即座にソースコードに反映できます他の生成AIとの連携: デフォルトのClaudeに加え、ChatGPTやGitHub Copilotを活用したコード提案が可能ですセットアップ方法lazy.nvimを使用した場合の設定例を紹介します。avante.nvimはデフォルトではCursorのように高度なAI機能を利用するように設定されていますが、他にもChatGPTやAzureなども指定できますが今回はより手軽に利用できるGitHub Copilotをプロバイダーとして設定します。これにより、Copilotのライセンスさえあれば、追加のAPIキーの設定なしでAI支援機能を利用することができます。以下が具体的な設定例です。{  \"yetone/avante.nvim\",  event = \"VeryLazy\",  lazy = false,  version = false,  opts = {    provider = \"copilot\",    auto_suggestions_provider = \"copilot\",        -- 動作設定    behaviour = {      auto_suggestions = false,      auto_set_highlight_group = true,      auto_set_keymaps = true,      auto_apply_diff_after_generation = false,      support_paste_from_clipboard = false,      minimize_diff = true,    },    -- ウィンドウ設定    windows = {      position = \"right\",  -- サイドバーの位置      wrap = true,        -- テキストの折り返し      width = 30,         -- サイドバーの幅      -- その他の詳細設定は省略    },  },  -- 依存関係の設定  dependencies = {    -- 必須の依存関係    \"stevearc/dressing.nvim\",    \"nvim-lua/plenary.nvim\",    \"MunifTanjim/nui.nvim\",    -- オプションの依存関係    \"hrsh7th/nvim-cmp\",    \"nvim-tree/nvim-web-devicons\",    \"zbirenbaum/copilot.lua\",    -- その他の拡張機能  }}私の設定はこちらです。github.com主要なキーマッピングデフォルトで以下のキーマッピングが利用可能です。主にこちらから利用していきます。\u003cLeader\u003eaa: サイドバーの表示\u003cLeader\u003ear: サイドバーの更新\u003cLeader\u003eaf: サイドバーのフォーカス切り替え\u003cLeader\u003eae: 選択したブロックの編集他ブログでのavante.nvimの紹介zenn.devまとめ開発者の間で「AIエディターこそが主流」という声が広がっていますが、Vimmerは愛用のNeovimを手放す必要はありません。avante.nvimの導入により、Neovimの使い慣れた操作性を維持したまま、最新のAI支援機能を活用することが可能です。特筆すべき点として、GitHub Copilotをプロバイダーとして使用することで、追加のAPIキー設定なしで高度な機能を利用できます。また、洗練されたサイドバーUIにより自然な開発ワークフローを実現し、\u003cLeader\u003eaaなどのシンプルなキーマッピングで直感的な操作を可能にします。Neovimの最大の魅力である圧倒的なカスタマイズ性を活かしながら、このプラグインを通じてAIパワード開発環境へと進化させることができます。プラグインは現在も活発に開発が継続されており、今後さらなる機能追加が期待できます。PDEとしてのNeovimの魅力を保ちながら、最新のAI支援機能を活用したいVimmerにぜひお勧めのプラグインです。最後に一言。「おい、お前、それは本当にvimmerか？」という声が聞こえてきそうです。しかし、私たちvimmerは常に進化を続けています。新しい技術を取り入れながらも、Vimの哲学と向き合い続けることもまた、vimmerの在り方の一つなのではないでしょうか。","isoDate":"2025-01-07T13:04:06.000Z","dateMiliSeconds":1736255046000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Rustで花火アニメーションと新年メッセージを作ろう","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/04/120812","contentSnippet":"はじめに私がRustという言語と再び出会ったのは、暮れも押し詰まった頃のことだった。シェアハウスの六畳一間の部屋で、誰かの足音の気配だけを感じながら、画面に向かっていた。シェアハウスの共用キッチンからは時折、誰かの料理する音が漏れ聞こえてくるが、年末だというのに妙に静かだった。メモリ安全性という言葉に惹かれたわけでも、高パフォーマンスに心を奪われたわけでもない。ただ、この年の瀬に、誰にも見せることのない花火を打ち上げたかっただけなのだ。深夜のターミナル画面に、デジタルの花を咲かせれば、少しは華やかな年越しになるかもしれない。そんな打算的な期待を胸に、私はコードを書き始めた。年末最後の実装でもバグを出してしまい、『来年もきっと、たくさんの失敗をして恥ずかしいコードを書くことになるだろうな』と考えていました。https://t.co/34hgesMGQu pic.twitter.com/k7f7GyqLoT— nwiizo (@nwiizo) 2025年1月2日   準備まずは、以下の外部クレートをインストールします。chrono: 日付と時刻を扱うためのクレートcolored: ターミナル出力に色をつけるためのクレートrand: 乱数を生成するためのクレートCargo.tomlに以下の行を追加してください。[dependencies]rand = \"0.8\"colored = \"2.0\"chrono = \"0.4\"構造体と列挙型の詳細Fireworkとその周辺の構造体struct Firework {    x: f64,           // x座標    y: f64,           // y座標    velocity: f64,    // 上昇速度    particles: Vec\u003cParticle\u003e,  // 爆発後のパーティクル    exploded: bool,   // 爆発したかどうか    color: Color,     // 花火の色    sparkles: Vec\u003cSparkle\u003e,   // 打ち上げ時の火花}struct Sparkle {    x: f64,           // 火花のx座標    y: f64,           // 火花のy座標    lifetime: i32,    // 火花の寿命}Firework構造体は花火1発分の情報を管理します。打ち上げ時にはexplodedがfalseで、上昇中の花火を表示。爆発後はexplodedがtrueとなり、particlesに格納された粒子が広がっていきます。sparklesは打ち上げ中の火花を表現するために使用されます。Particleの詳細struct Particle {    x: f64,           // x座標    y: f64,           // y座標    vx: f64,          // x方向の速度    vy: f64,          // y方向の速度    lifetime: i32,    // パーティクルの寿命    char: char,       // 表示する文字    color: Color,     // パーティクルの色    trail: Vec\u003c(f64, f64)\u003e,  // 軌跡の座標履歴}Particleは爆発後の火花を表現します。物理演算で放物線を描くように、速度と重力の影響を受けます。trailは軌跡を表示するために過去の座標を記録しています。色の実装#[derive(Clone, Copy)]enum Color {    Red, Green, Blue, Yellow, Magenta, Cyan,    Rainbow,  // 時間とともに色が変化    Silver,   // 明滅する白    Gold,     // 明滅する黄色    Pearl,    // 白と水色で明滅}Colorは単色だけでなく、Rainbowのような動的な色変化や、Silver/Gold/Pearlのような明滅効果も実装しています。get_colored_charメソッドで、時間（フレーム数）に応じた色を返します。アニメーションの仕組み花火の更新処理impl Firework {    fn update(\u0026mut self) {        if !self.exploded {            self.y -= self.velocity;  // 上昇            // 確率で火花を追加            if rand::thread_rng().gen_bool(0.3) {                self.sparkles.push(Sparkle {...});            }            // 一定の高さで爆発            if self.y \u003c= rand::thread_rng().gen_range(5.0..15.0) {                self.explode();            }        } else {            // パーティクルの更新と寿命切れの除去            for particle in \u0026mut self.particles {                particle.update();            }            self.particles.retain(|p| p.lifetime \u003e 0);        }    }}花火は打ち上げ時と爆発後で異なる動きをします。打ち上げ中は上昇しながら火花を散らし、一定の高さで爆発。爆発後は多数のパーティクルが放物線を描きながら広がります。描画処理の工夫fn draw_frame(fireworks: \u0026Vec\u003cFirework\u003e, frame_count: u32) {    // 背景に星を表示（10フレームごとに配置を変える）    if frame_count % 10 == 0 {        for _ in 0..50 {            let x = rand::thread_rng().gen_range(0..100);            let y = rand::thread_rng().gen_range(0..30);            frame[y][x] = ('·', Some(Color::Silver));        }    }        // 各花火の描画    for firework in fireworks {        // 打ち上げ火花の描画        for sparkle in \u0026firework.sparkles {            let x = sparkle.x as usize;            let y = sparkle.y as usize;            frame[y][x] = ('｡', Some(Color::Pearl));        }                if !firework.exploded {            // 上昇中の花火            frame[y][x] = ('⁂', Some(firework.color));        } else {            // 爆発後のパーティクル            for particle in \u0026firework.particles {                // 軌跡の描画                for (i, (trail_x, trail_y)) in particle.trail.iter().enumerate() {                    let char = match i {                        0 =\u003e '.',                        1 =\u003e '·',                        _ =\u003e '°',                    };                    frame[y][x] = (char, Some(particle.color));                }            }        }    }}描画処理では、まず背景に点滅する星を配置し、その上に花火を重ねていきます。パーティクルの軌跡は徐々に薄くなるように文字を変えています。これにより、より自然な花火の表現を実現しています。アニメーションとメッセージ表示最後に、main関数でアニメーションとメッセージ表示を行います。fn main() {    let year = Local::now().year(); // 現在の年を取得    let mut fireworks = Vec::new();    let mut frame_count = 0;    loop {        // 花火を追加        if frame_count % 15 == 0 \u0026\u0026 fireworks.len() \u003c 8 {            fireworks.push(Firework::new(rand::thread_rng().gen_range(10.0..90.0)));        }        // 花火を更新して描画        for firework in \u0026mut fireworks {            firework.update();        }        draw_frame(\u0026fireworks, frame_count);        fireworks.retain(|f| !f.is_done());        thread::sleep(Duration::from_millis(40));        frame_count += 1;        // 一定時間後にメッセージを表示        if frame_count \u003e 300 {            clear_screen();            display_new_year_message(year);            break;        }    }}ループ内で、一定の間隔で新しい花火を追加し、既存の花火を更新して描画しています。300フレーム後には、display_new_year_message関数を呼び出して新年のメッセージを表示します。この関数では、ASCIIアートを使ってメッセージを作成し、coloredクレートで色をつけています。まとめ結局、プログラムは年越しに間に合わなかった。シェアハウスの他の住人たちは、それぞれの実家や友人たちの元へと消えていき、廊下は一層静かになっていた。コンパイラの指摘する数々のエラーと向き合ううち、除夜の鐘が鳴り響き、新年は音もなく明けてしまった。しかし不思議なことに、深夜2時、ようやく完成したプログラムが描き出す花火の光に、私は密かな充実感を覚えていた。誰にも見せることはないだろうこの花火は、確かに私だけの新年を祝福していたのだから。来年は少し早めに取り掛かろう。もっとも、来年も誰かと過ごすことになるとは限らないが。これは私の経験則である。知らんけど。完全なコードは以下の通りです。github.com","isoDate":"2025-01-04T03:08:12.000Z","dateMiliSeconds":1735960092000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"アーキテクチャ設計の民主化とADR(Architectural Decision Records)による意思決定の未来 - Facilitating Software Architecture の読書感想文","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/31/232546","contentSnippet":"年末年始の慌ただしい時期に、数ある選択肢の中からこちらの記事をお読みいただき、誠にありがとうございます。人生を定期的に振り返ることには、本書で取り上げられているADR（Architecture Decision Records）に通じる素晴らしさがあります。過去の決定とその背景を記録し、将来の自分や他者が参照できる形で残すことは、個人の成長にとって貴重な資産となります。そんな観点から今年を振り返ってみると、2024年は私自身にとって大きな試練と変化の年でした。印象的だったのは、ある時期に突然、技術に対する興味や情熱が完全に失われてしまったことです。それは技術分野に限らず、仕事全般や私生活にも波及し、何をするにも意欲が湧かない、深い無気力状態に陥ってしまいました。しかし、この困難な時期を経て、いくつかの意味のある変化が生まれました。私は以前から技術書の書評を書いていましたが、これは主に自分の理解を深め、将来の自分のための記録として残すことが目的でした。より自分の感想や学びを素直に記録することに注力するようになりました。その結果長文になることも多々ある。この文章も同様に長くなってしまった。外部登壇やブログもいくつか書きました。また、Xでは書籍を紹介するアカウントの運営方法を始めました。めちゃくちゃにバカにされたり批判もされたが明確な敵ができて嬉しい。これは思いがけずフォロワーの方々との貴重な出会いを生み、さらには翻訳書の出版という新たな機会にもつながりました。あとは回復の過程で気づいたのは、基本的な生活習慣を見直すことの大切さでした。規則正しい運動習慣の確立、十分な睡眠時間の確保、そして栄養バランスを意識した食事管理を意識的に行うことで、徐々に日常を取り戻すことができました。また、仕事漬けの状態から一時的に距離を置き、純粋な娯楽を楽しむ時間を作ることも大きな助けとなりました。好きな映画やお笑い番組を観て心を癒したり、仕事や技術とは直接関係のない物語や小説に没頭する時間を意識的に作りました。一見すると遠回りに思えるこれらの活動が、むしろ心の回復を促し、結果として日常への活力を取り戻すきっかけとなったのです。このような経験を通じて、技術や仕事への向き合い方を大きく変えることができました。時には立ち止まり、心身の健康に意識を向けることの大切さを、身をもって学ぶ機会となったのです。そして、この振り返りを書き記すことは、まさにADRのように、将来の自分への重要な指針となることを願っています。あと、以下からtemplateを利用して作成することもできます。adr.github.ioはじめにここからは書評です。年の瀬や新しい年のスタートは、振り返りや目標設定の時期として特別な意味を持つことが多いと思います。そのような忙しい時期に手に取った一冊が、「Facilitating Software Architecture」でした。この本は、現代のソフトウェア開発における複雑な課題に向き合い、分散型アプローチを基盤にした実践的な知見を提供しています。読み進めるうちに、この時期に改めて考えたい「意思決定」「信頼」「チーム文化」といったテーマが深く掘り下げられており、多くの示唆を得ることができました。Facilitating Software Architecture: Empowering Teams to Make Architectural Decisions (English Edition)作者:Harmel-Law, AndrewO'Reilly MediaAmazon本書は、分散型アーキテクチャの実践を通じて、現代のソフトウェア開発における複雑な課題に立ち向かうための方法を探求しています。従来の中央集権的なアーキテクチャ手法の限界を明確にし、変化の激しい開発環境に適応するための分散型アプローチを提案します。ソフトウェア開発は技術的な進化だけでなく、チームや組織文化といった社会的要素とも密接に関連しています。成功する開発チームは、技術的な卓越性を追求するだけでなく、分散化された信頼に基づく意思決定や柔軟なプロセスを取り入れる必要があります。本書では、理論的な原則だけでなく、実践的なアプローチや具体的な事例を交えながら、分散型アーキテクチャを支える方法を体系的に示しています。重要なのは、トップダウンの権限に頼らない意思決定の実現です。組織が成長し複雑化する中で、中央集権的なアプローチはその限界を迎えつつあります。そこで必要となるのが、信頼関係に基づいた民主的な意思決定プロセスです。本書は、このような信頼ベースの分散型アーキテクチャを実現するための具体的な方法論を提供しています。learning.oreilly.comアーキテクチャの民主化が必要な理由の一つは、中央集権的なアプローチに内在する持続可能性の問題です。いかに優秀なアーキテクトであっても、人は組織を去り、知識は失われ、文脈は変化します。アーキテクチャの決定権を特定の個人や小グループに集中させることは、長期的には組織の脆弱性につながります。分散型アプローチは、この本質的な課題に対する解決策を提供します。知識と決定権を組織全体で共有することで、個人への依存を減らし、より持続可能な開発文化を築くことができるのです。「中央集権型アプローチの限界」「アドバイスプロセスの導入」「アーキテクチャ意思決定記録（ADR:Architectural Decision Records）」の活用といったテーマを中心に、現代のソフトウェア開発組織が直面する課題とその解決策を深く掘り下げています。この知識は、開発者、アーキテクト、リーダーなど、さまざまな役割の方々がそれぞれの立場でより良い意思決定を行うための指針となるでしょう。ADR（Architecture Decision Records）との出会いは『Fundamentals of Software Architecture』の第19章を通じてでした。後に振り返ると、Design IT!でも触れられていたかもしれませんが、その時点では深く印象に残っていませんでした。learning.oreilly.com初めてADRの概念に触れた時、その単純さと効果的さに強く惹かれました。アーキテクチャ上の重要な決定を、その背景や検討過程も含めて記録するという考え方は、私が長年感じていた「なぜその決定に至ったのか」という疑問への明確な解答でした。ADRの実践において重要なのは、その適用範囲と文脈の深さを適切に見極めることです。あくまでシステムの方向性を決定づける重要な技術選択や、将来に大きな影響を与える可能性のある決定に焦点を当てるべきです。例えば、マイクロサービスアーキテクチャの採用、主要なデータベースの選定、重要なインターフェースの設計などが該当します。ただし、これらの決定についても、組織の規模や文化、個々のプロジェクトや各メンバーの気質などの特性に応じて適切な記録の粒度と範囲を見極める必要があります。一方で、日々の実装上の判断や、影響範囲が限定的な決定については、よりライトウェイトな文書化手法を選択すべきでしょう。コードのコメント、プルリクエストの説明、あるいはチームのWikiなどが適しています。ADRの価値は、その決定が組織やプロジェクトに与える影響の大きさに比例するからです。その後、実践的な知見を得るために様々な導入事例を調査しました。以下のブログ記事からは具体的な実装方法や運用上の工夫について多くの学びを得ることができました。user-first.ikyu.co.jplaiso.hatenablog.comblog.studysapuri.jp speakerdeck.comこれらの事例研究を通じて、ADRは単なるドキュメンテーションツールではなく、チーム全体の意思決定プロセスを改善し、知識共有を促進する強力な手段であることを理解しました。その後、自身の関わるプロジェクトでもADRを段階的に導入し、マイクロサービスアーキテクチャにおける設計判断の記録と共有に活用してきました。現在では、チーム内の技術的なコミュニケーションにおいて不可欠なツールとなっています。syu-m-5151.hatenablog.comChapter 1. Centralized Architecture Practices in a Decentralized World第1章「Centralized Architecture Practices in a Decentralized World」では、伝統的なソフトウェアアーキテクチャ実践の詳細な分析と、現代の分散化された開発環境における限界について論じています。著者は、5つの重要な革命的変化を軸に、中央集権的なアーキテクチャ実践の課題を説得力ある形で示しています。この章は、アーキテクチャ実践の根本的な変革の必要性を理解する上で重要な示唆を提供します。伝統的なアーキテクチャ実践の限界著者はまず、伝統的なアーキテクチャ実践を「アイボリータワー型」と「ハンズオン型」という2つの代表的なアプローチに分類します。アイボリータワー型アプローチでは、アーキテクトが組織の上層部に位置し、全体を俯瞰的に見渡しながら統制を重視します。このモデルでは、アーキテクトは開発チームから距離を置き、主に文書やレビューを通じて指示を与えます。Figure 1-1. The ivory tower approach to practicing architecture より引用一方、ハンズオン型アプローチでは、アーキテクトが個々の開発チームに密着し、実装レベルでの直接的な支援を行います。このモデルでは、アーキテクトはチーム間を移動しながら、より実践的な指導と支援を提供します。Figure 1-2. The hands-on, cross-team approach to practicing architecture より引用これら2つのアプローチは、一見異なる実践方法を採用していますが、「アーキテクトへの決定権の集中」という本質的な共通点を持ちます。この中央集権的な特徴は、現代の開発環境において深刻な課題を引き起こします。この課題は顕著です。以前参画した大規模マイクロサービス開発プロジェクトでは、アイボリータワー型アーキテクトの理想的な設計と現場の実際のニーズとの間に大きなギャップが生じました。アーキテクトが提案する完璧な設計は、実際の開発現場での制約や要件と整合性が取れず、結果として開発の遅延と品質の低下を招きました。この経験から、現代のソフトウェア開発においては、より柔軟で適応的なアプローチが必要だと強く感じています。ソフトウェア開発を変えた5つの革命著者は、現代のソフトウェア開発を根本的に変革した5つの重要な革命として、アジャイル開発、クラウドコンピューティング、DevOps、プロダクト思考、ストリーム指向チームを提示します。これらの革命により、ソフトウェア開発はより分散的でフィードバック重視の方向へと導かれました。しかし個人的には、これらに加えて大規模言語モデル(LLM)の台頭が、ソフトウェア開発を根本的に変革する新たな革命になると考えています。LLMによる変革は、単なる開発効率の向上にとどまらず、アーキテクチャの設計プロセスやチーム間のコミュニケーション、意思決定の方法そのものを変える可能性を秘めています。例えば、設計の選択肢の探索や過去の決定の分析、ドキュメンテーションの自動生成といった作業が劇的に効率化され、開発者はより本質的な判断や創造的な活動に注力できるようになるでしょう。私は、これら全ての変革の影響を実務で強く実感しています。DevOpsの導入は、開発と運用の壁を取り払い、より迅速なフィードバックサイクルを実現しました。また、プロダクト思考の浸透により、技術的な卓越性だけでなく、実際のビジネス価値の提供に焦点が当たるようになりました。そしてLLMの活用は、これらの革新をさらに加速させ、ソフトウェア開発の未来を大きく変えていくことでしょう。分散化とフィードバックの重要性著者は、現代のソフトウェアアーキテクチャには「分散化」と「フィードバック」という2つの要素が不可欠だと主張します。以前のプロジェクトでは、分散化されたチーム構造を採用することで、各チームの自律性が向上し、より迅速な意思決定が可能になりました。というか人が多すぎるとフィードバックが大変になる。また、継続的なフィードバックの重要性も実感しています。実際の運用から得られる知見を設計に反映する仕組みを確立することで、より実効性の高いアーキテクチャを実現できました。本番環境での問題や予期せぬユースケースから学び、それを設計に反映するサイクルが重要でした。みんなのフィードバック大全作者:三村 真宗光文社Amazonカオスと不確実性への対応著者は、ソフトウェアシステムにおけるカオスと不確実性を、避けるべき問題としてではなく、むしろ自然な特性として受け入れることを提唱します。私も、この視点は極めて重要だと感じています。完璧な設計を追求するのではなく、変化への適応能力を重視する現実的なアプローチが、現代のソフトウェア開発には不可欠です。エンジニアリング組織論への招待 ~不確実性に向き合う思考と組織のリファクタリング作者:広木 大地技術評論社Amazon注目すべきは「弱い創発」の概念です。私が担当したマイクロサービスプロジェクトでは、予期せぬサービス間の相互作用が発生することがありました。しかし、これを問題視するのではなく、システムの進化の機会として捉え直すことで、より柔軟で強靭なアーキテクチャを実現できました。フィードバックループと伝統的アプローチの課題著者は、伝統的なアーキテクチャ実践の最大の問題点として、効果的なフィードバックループの欠如を指摘します。この指摘は、感覚と完全に一致します。たとえばハンズオン型アプローチでさえ、システム全体からの包括的なフィードバックを適切に取り入れることができていません。著者が挙げる追跡番号管理システムの事例は、この課題を明確に示しています。スケーリング機能と再試行メカニズムの相互作用が予期せぬ動作を引き起こすという事例は、私も似たような事例を経験したことがあります。個々のコンポーネントは適切に設計されていても、それらの組み合わせが予想外の結果をもたらすことは、分散システムではよく起こる現象です。チームの分散化とアーキテクチャの整合性著者は、チームの組織構造とアーキテクチャの構造における整合性の重要性を強調します。これはコンウェイの法則の現代的な解釈として理解できます。この整合性は極めて重要です。マイクロサービスアーキテクチャを採用しながら、中央集権的な意思決定プロセスを維持しようとした組織では、深刻な課題が発生します。マイクロサービスの境界設定や技術選定に関する決定が中央のアーキテクチャチームに集中していたため、各開発チームの自律性が損なわれ、結果として開発のボトルネックが発生しました。アーキテクチャの分散化には、それに対応する組織構造の変革が不可欠だと学びました。結論本章は、現代のソフトウェア開発における伝統的なアーキテクチャ実践の限界を明確に示し、新しいアプローチの必要性を説得力ある形で提示しています。著者が示す予測不可能性の受容、創発的な性質の活用、フィードバックの重視という3つの要件は、実践的な指針として極めて有用です。これらの要件は技術的な側面だけでなく、組織的・文化的な変革も必要とすることが分かっています。重要なのは、チームの自律性を高めながら、組織全体としての一貫性を保つバランスです。分散化とフィードバックを重視する新しいアプローチは、このバランスを実現する上で重要な実践基盤となります。今後、ソフトウェア開発の複雑性はさらに増していくことが予想されます。その中で、本章で示された知見は、より適応力の高い組織とアーキテクチャを実現するための重要な指針となるでしょう。Part I. First PrinciplesPart I. First Principlesは、アーキテクチャ実践の基本原則を示す重要なパートです。伝統的なソフトウェアアーキテクチャの実践が直面する課題と、その解決策として分散型の意思決定アプローチを提案しています。このパートでは、アーキテクチャ実践の核となる「決定」に焦点を当て、その重要性と評価基準を明確にします。さらに大規模な意思決定の従来のアプローチを検証し、それらが現代のソフトウェア開発における分散型の意思決定と迅速なフィードバックという要件を満たせない理由を分析します。この課題に対する解決策として「アーキテクチャ・アドバイスプロセス」を提案します。このプロセスは分散型の意思決定と迅速なフィードバックを両立させる新しいアプローチです。著者はこのプロセスの導入方法や予想される課題、そしてアーキテクチャ決定記録（ADRs）による信頼構築と組織学習の方法を具体的に説明します。このパートは、現代のソフトウェア開発における効果的なアーキテクチャ実践の基礎となる原則と実践方法を包括的に提供しています。アドバイスプロセスとそれを支える要素の理解は、次のパートで扱う実践的なトピックの土台となります。learning.oreilly.comChapter 2. To Practice Architecture Is to Decide第2章「To Practice Architecture Is to Decide」はソフトウェアアーキテクチャの実践における意思決定の本質と重要性を扱います。アーキテクチャ的に重要な意思決定の定義と判断基準について深く掘り下げています。著者はアーキテクチャ意思決定を構造・非機能特性・依存関係・インターフェース・構築技術の5つの観点から整理し実践的な指針を提供します。Software Architecture and Decision-Making: Leveraging Leadership, Technology, and Product Management to Build Great Products がとても良いがlearning.oreilly.comこの本は島田さんによって翻訳されている。とてもありがたい。ソフトウェアアーキテクトのための意思決定術　リーダーシップ／技術／プロダクトマネジメントの活用作者:Srinath PereraインプレスAmazonアーキテクチャ決定の本質著者はすべてのアーキテクチャ決定が技術的決定である一方で技術的決定の全てがアーキテクチャ決定ではないという重要な区別から議論を始めます。この区別は実務上非常に重要です。私もプロジェクトの初期段階でこの区別が曖昧だったために些末な技術的決定に時間を費やしてしまうケースを何度も目にしてきました。Figure 2-1. All architectural decisions are technical decisions, but not all technical decisions are architectural ones より引用アーキテクチャ決定の基準として著者はMichael Nygardの5つの基準を採用します。構造への影響・非機能特性への影響・依存関係への影響・インターフェースへの影響・構築技術への影響です。この基準は実践的で分かりやすく私も日々の意思決定の判断に活用しています。cognitect.comアーキテクチャ的に重要な決定の特定著者は更に一歩踏み込んでアーキテクチャ的に重要な決定の基準を提示します。重要なのは運用環境へのデプロイとの関係です。どんなに優れた設計も実際に動作するまでは単なる仮説に過ぎません。デプロイを阻害する決定は常に重要です。以前関わったプロジェクトでは理想的なアーキテクチャを追求するあまりデプロイが困難になり結果として価値の提供が遅れるという失敗を経験しました。意思決定者の多様性著者はアーキテクチャ決定は必ずしもアーキテクトだけのものではないという重要な指摘を行います。開発者やQAエンジニアも重要なアーキテクチャ決定を行う可能性があります。この視点は伝統的なアーキテクチャ実践からの大きな転換を示唆します。私の現在のプロジェクトでもチームメンバー全員がアーキテクチャ決定に関与する文化を築いています。その結果より良い決定が行われるだけでなくチームの当事者意識も高まっています。意思決定プロセスの重要性著者は意思決定のプロセスよりも結果の重要性を強調します。長時間の検討や意図的な決定であることは必ずしも良い決定を保証しません。むしろ迅速な決定と実践からのフィードバックの方が重要な場合が多いのです。この指摘は私の実務経験とも一致します。完璧な決定を目指して時間をかけるよりも早期に実践し改善を重ねる方が良い結果につながることを何度も経験してきました。結論本章の内容は日々のアーキテクチャ実践に直接活かせる示唆に富んでいます。アーキテクチャ決定の判断基準とデプロイとの関係の2点は重要です。これらの基準を用いることで意思決定の質と速度の両方を改善できます。一方で組織の規模や文化によってはこれらの原則の適用が難しい場合もあります。その場合は段階的な導入や既存のプロセスとの調和を図る必要があるでしょう。結論として本章はアーキテクチャ実践における意思決定の本質を明確に示し実践的な指針を提供しています。これらの知見は現代のソフトウェア開発組織において極めて重要な意味を持ちます。Chapter 3. Decisions at Scale第3章「Decisions at Scale」は組織規模でのアーキテクチャ意思決定プロセスを詳細に分析します。著者は意思決定の本質的な構造を明らかにし標準的な意思決定アプローチの特徴と限界を示しています。現代の分散化されたソフトウェア開発環境における意思決定プロセスの要件について深い洞察を提供します。パーフェクトな意思決定――「決める瞬間」の思考法作者:安藤広大ダイヤモンド社Amazon意思決定プロセスの基本構造著者は意思決定プロセスをオプションの生成と決定の実行と決定の共有という3つの要素に分解します。この単純な分析枠組みは実務上極めて有用です。私も以前関わったマイクロサービスプロジェクトで同様の枠組みを用いて意思決定プロセスを整理しました。重要なのは決定の共有です。いかに優れた決定でも共有が適切に行われなければ無意味です。チーム間のコミュニケーション不足により優れた設計判断が台無しになるケースを何度も目にしてきました。Figure 3-1. A naive view of a generic decision process (“deciding”) in context (the required need for the decision and the subsequent implementation of the result) より引用標準的な意思決定プロセスとその限界著者は意思決定プロセスを中央集権型と分散型に大別します。中央集権型には独裁的・委任型・諮問型があり分散型には合意型・民主型・コンセンサス型があります。多くの組織が中央集権型と分散型のハイブリッドなアプローチを採用します。例えば技術選定は諮問型で行いながら実装の詳細はチームに委ねるといった具合です。意思決定プロセスの文化的基盤意思決定プロセスを考える際に重要なのは、その文化的基盤への理解です。渡邊雅子の『論理的思考とは何か』では、論理的思考が領域ごとに異なる形を取ることを指摘しています。この知見は、アーキテクチャ意思決定プロセスを設計する上で重要な示唆を与えます。経済領域では効率性を重視した思考が、政治領域では合意形成を重視した思考が特徴的です。また、法技術領域では規範性を重視した思考が、社会領域では共感を重視した思考が中心となります。例えば、マイクロサービスアーキテクチャの採用を検討する際、効率性（コストとパフォーマンス）、合意形成（各部門の利害調整）、規範性（セキュリティ要件）、共感（チームの受容性）という異なる観点からの評価が必要になります。アーキテクチャの意思決定プロセスを設計する際は、これらの文化的な思考パターンを状況に応じて適切に組み合わせることが重要です。特に日本の組織においては、共感による推理と配慮的な表現を重視する社会領域のアプローチを適切に取り入れることで、より効果的な意思決定が可能になります。論理的思考とは何か (岩波新書)作者:渡邉 雅子岩波書店Amazon意思決定プロセスの要件著者は意思決定プロセスの4つの要件を示します。適切な人々の関与・決定権の最適化・信頼の重視・共有の最小化です。これらの要件は私の実務経験とも合致します。以前のプロジェクトで決定権を完全に分散化したことで意思決定が遅くなり逆に集中化し過ぎて柔軟性を失うという両極端な失敗を経験しました。実践的な示唆本章の内容は日々のアーキテクチャ実践に直接活かせる示唆に富んでいます。意思決定プロセスの選択基準と共有方法の工夫は重要です。私の現在のプロジェクトでは決定のスコープに応じて異なるプロセスを使い分けています。マイクロサービス間のインターフェース設計は合意型で行う一方サービス内部の実装は各チームに委ねるといった具合です。結論著者はスピードと分散化を両立する新しい意思決定プロセスの可能性を示唆して締めくくっています。この視点は極めて重要です。私も組織の規模や文化に応じて柔軟にプロセスを適応させることが重要だと考えています。一つの正解はなく文脈に応じた適切な選択が必要です。結論として本章は意思決定プロセスの本質を明らかにし実践的な指針を提供しています。これらの知見は現代のソフトウェア開発組織において極めて重要な意味を持ちます。Chapter 4. The Architecture Advice Process第4章「The Architecture Advice Process」はアーキテクチャ意思決定のアプローチを提案します。アドバイスプロセスと呼ばれるこのアプローチは高速な意思決定と権限の分散化を両立します。著者は具体的な事例を通じてこのプロセスの実践方法と効果を示しています。他者と働く──「わかりあえなさ」から始める組織論 (NewsPicksパブリッシング)作者:宇田川元一ニューズピックスAmazonアドバイスプロセスの本質著者は意思決定プロセスの根本的な変革としてアドバイスプロセスを提案します。このプロセスの核心は誰もが意思決定を開始できるという点です。意思決定の集中化は開発の大きなボトルネックとなってきました。アドバイスプロセスでは決定者は2つのグループから助言を求める必要があります。影響を受ける関係者とその領域の専門家です。これは単なる形式的な手続きではなく社会的な契約として機能します。実践例による理解著者は2つの具体例を通じてアドバイスプロセスを説明します。1つ目は開発チームがリリーストグルを導入する事例です。チームは関係者や専門家から助言を得ることで当初の設計を大きく改善しました。私も似たような経験をしています。以前のプロジェクトでフィーチャートグルの導入を決めた際に様々な関係者の意見を聞くことで運用面の課題を事前に把握できました。アドバイスの本質著者はアドバイスは方向性と理由の組み合わせだと説明します。単なる意見との違いは理由の有無です。この視点は極めて重要です。理由を伴わない意見は意思決定の改善につながりません。理由のない意見は混乱を招くだけでした。「このフレームワークを使うべき」という意見より「このフレームワークならこういう理由でこの課題が解決できる」というアドバイスの方が遥かに有用でした。信頼の重要性アドバイスプロセスの成功は信頼関係にかかっています。著者は信頼を築くためには対話が重要だと指摘します。これは私の実務経験とも合致します。信頼はどの職種にも重要である。信頼がない職場では仕事ができないのは万国で共通なのである。対話を通じて相互理解を深めることで初めて有意義なアドバイスが可能になります。一方的な意見の押し付けは避けるべきです。syu-m-5151.hatenablog.com結論アドバイスプロセスは組織文化も変革します。従来型のアーキテクチャ実践では意思決定権限が集中することで様々な歪みが生じていました。アドバイスプロセスはこの問題を解決します。私の組織でもアドバイスプロセスの導入後はチーム間のコミュニケーションが活発になり意思決定のスピードも向上しました。結論として本章はアジャイルな開発環境に適した新しいアーキテクチャ実践を提案しています。アドバイスプロセスは意思決定の民主化と効率化を両立する優れたアプローチです。これからのソフトウェア開発組織にとって重要な示唆を含んでいます。Chapter 5. Rolling Out the Architecture Advice Process第5章「Rolling Out the Architecture Advice Process」はアドバイスプロセスの具体的な導入方法について解説します。著者は現在の組織的立場に応じた3つの導入アプローチを示し導入時の課題と対処法を詳細に説明しています。企業変革のジレンマ　「構造的無能化」はなぜ起きるのか (日本経済新聞出版)作者:宇田川元一日経BPAmazon導入アプローチの選択著者は導入アプローチを現在の意思決定権限に基づいて分類します。アーキテクトとして意思決定権を持つ場合は自身の実践から始めます。開発チームとして権限がない場合は実験的な試行から始めます。この分類は的確です。以前関わったプロジェクトでは権限を持つアーキテクトから導入を始めることで組織全体への浸透がスムーズでした。段階的な導入の重要性著者は小規模な実験からスタートすることを強く推奨します。これは組織の文化や既存のプロセスに大きな変更を加えるためです。実験を通じて課題を早期に発見し対処することが重要です。この指摘は極めて実践的です。私も大規模な変更を一度に行って混乱を招いた経験があります。段階的なアプローチは確実な導入につながります。初期の課題への対応著者は導入初期に直面する主な課題として4つを挙げます。プロセスの誤解、適切な助言者の選定漏れ、Why?の問いかけ不足、責任の所在の不明確さです。これらの課題は私も度々遭遇します。チームが自律的に判断を行う文化への移行には慎重なケアが必要です。信頼の構築著者は信頼関係の構築がプロセスの成功に不可欠だと指摘します。自身と他者の判断能力への信頼、アドバイスの授受への信頼、全体状況の把握への信頼が重要です。私の組織でも信頼関係の醸成に注力しています。定期的な振り返りと成功体験の共有が効果的でした。結論本章の内容は極めて実践的な示唆に富んでいます。導入時のチェックリストは有用です。組織の専門家マップを整備することでアドバイスプロセスがより効果的になります。私の現在のプロジェクトでもこのアプローチを採用しています。各領域の専門家を明確化することで適切なアドバイスを得やすくなりました。結論として本章はアドバイスプロセスの実践的な導入方法を提供しています。組織の現状に応じた段階的な導入と信頼関係の構築に焦点を当てた著者の提案は極めて妥当です。次章で説明される「アーキテクチャ決定記録」と組み合わせることで更に効果的な実践が可能になるでしょう。Chapter 6. Architectural Decision Records第6章「Architectural Decision Records」は、アーキテクチャ意思決定プロセスを支援し記録するための実践的なアプローチとしてArchitectural Decision Records (ADRs)を詳細に解説しています。ADRsはアーキテクチャ意思決定の透明性を高め、組織の学習を促進する重要なツールとして位置づけられています。百年の孤独 (新潮文庫 カ 24-2)作者:ガブリエル・ガルシア=マルケス新潮社AmazonADRsの本質と目的ADRsは単なる決定の記録ではありません。アーキテクチャ意思決定の全過程を支援する重要なツールです。現代のソフトウェア開発では意思決定の透明性とトレーサビリティが極めて重要です。実際の開発現場では以前のアーキテクチャ決定が後から問題を引き起こすことがしばしば発生します。ADRsはそのような状況でもアーキテクチャ決定の背景と理由を明確に示すことができます。意思決定の全プロセスをサポートするADRsの役割は重要です。とあるプロジェクトでも複雑なマイクロサービスアーキテクチャの移行においてADRsを活用しました。チーム間のコミュニケーションが改善され決定プロセスの透明性が大きく向上しました。Figure 6-1. The place of ADRs in the advice process より引用ADRsとDesign docsの違いここでADRsとよく比較されるDesign docsとの主な違いを整理しておくことは有用でしょう。両者は一見似ているように見えますが、その目的と特性は大きく異なります。tkybpp.hatenablog.comADRsは個々の重要な技術的決定に焦点を当て、その決定に至った背景と理由を時系列で記録します。例えば「なぜKafkaではなくRabbitMQを選択したのか」「どうしてMongoDBを採用したのか」といった具体的な決定事項とその文脈を残します。一度記録された決定は変更せず、新しい決定を追加することで履歴を形成していきます。一方、Design docsはシステム全体やコンポーネントの設計を包括的に説明することを目的とします。技術的な設計の詳細、アーキテクチャの全体像、実装方針などを広く扱い、システムの各部分の関係性を示します。Design docsは必要に応じて更新され、常に現在の設計状態を反映するように維持されます。この違いは実務上重要な意味を持ちます。あるマイクロサービス開発プロジェクトでは、Design docsでシステム全体のアーキテクチャや各サービスの役割、データフローを説明する一方で、ADRsでは個別の技術選定の決定と理由を記録していました。両者は補完関係にあり、大規模なプロジェクトでは両方を併用することで、設計の全体像と重要な決定の経緯の両方を効果的に残すことができます。このように、ADRsはDesign docsと異なり、意思決定のプロセスと理由を明確に記録することに特化しています。この特徴は、後述する「意思決定の全プロセスをサポート」という役割と密接に結びついています。他にも技術ドキュメントはあるのですが全体を探るにはこちらがオススメです。技術文書の書き方 · GitHubADRsの構造と実践ADRsには明確な構造があります。タイトル、メタデータ、決定内容、コンテキスト、オプション、結果、アドバイスという基本的なセクションで構成されます。各セクションは読み手を意識した構造になっており、決定の背景から結果までを効果的に伝えることができます。実際の開発現場ではオプションと結果のセクションが重要です。あるプロジェクトでデータベースの選定を行う際にADRsを活用しました。複数のオプションを比較検討する過程で、チームメンバー全員が意思決定に参加できる環境を作ることができました。ADRsのライフサイクル管理ADRsのステータス管理は重要です。ドラフト、提案、承認、廃止といった基本的なステータスに加えて、組織の必要に応じて独自のステータスを追加することも可能です。ステータス管理を通じてADRsの現在の状態を明確に示すことができます。とある案件ではGitHubのプルリクエストプロセスとADRsを統合しました。これによりレビューとフィードバックのプロセスが自然な形で確立され、意思決定の質が向上しました。ADRsの組織的影響ADRsの導入は組織文化にも大きな影響を与えます。意思決定プロセスの透明性が高まることで、チーム間の信頼関係が強化されます。また、過去の決定を参照できることで、新しいメンバーのオンボーディングも効率化されます。一方で、ADRsの導入には慎重なアプローチが必要です。形式的な文書作成に陥らないよう、実際の意思決定プロセスを支援するツールとして活用することが重要です。過度な形式主義は避けるべきです。結論と展望ADRsは現代のソフトウェア開発組織に不可欠なツールです。アーキテクチャ意思決定の透明性を高め、組織の学習を促進します。しかし、その効果を最大限に引き出すためには、組織の文化や既存のプロセスに合わせた適切な導入が必要です。Figure 6-1の意思決定プロセスの図は印象的です。ADRsが意思決定のどの段階でどのように活用されるかを明確に示しています。この図は実際の導入時のガイドとしても有用です。今後の課題としては、分散開発チームでのADRsの活用や、自動化ツールとの統合などが考えられます。これらの課題に取り組むことで、より効果的なアーキテクチャ意思決定プロセスを実現できるでしょう。結論ADRsは理論的な枠組みとしても優れていますが、実践的なツールとしてさらに重要です。とある案件では週次のアーキテクチャレビューでADRsを活用しています。これにより意思決定プロセスが標準化され、チーム全体の理解が深まりました。最後に強調したいのは、ADRsは生きたドキュメントだということです。形式的な文書作成に終始せず、実際の意思決定プロセスを支援するツールとして活用することが成功の鍵となります。組織の成長とともにADRsも進化させていく柔軟な姿勢が重要です。Chapter 6. Architectural Decision Records第6章「Architectural Decision Records」は、アーキテクチャ意思決定プロセスを支援し記録するためのアプローチとしてArchitectural Decision Records (ADRs)を詳細に解説しています。ADRsはアーキテクチャ意思決定の透明性を高め、組織の学習を促進する重要なツールとして位置づけられています。ADRsの本質と目的ADRsは単なる決定の記録ではありません。アーキテクチャ意思決定の全過程を支援する重要なツールです。現代のソフトウェア開発では意思決定の透明性とトレーサビリティが極めて重要です。実際の開発現場では以前のアーキテクチャ決定が後から問題を引き起こすことがしばしば発生します。ADRsはそのような状況でもアーキテクチャ決定の背景と理由を明確に示すことができます。意思決定の全プロセスをサポートするADRsの役割は重要です。とあるプロジェクトでも複雑なマイクロサービスアーキテクチャの移行においてADRsを活用しました。チーム間のコミュニケーションが改善され決定プロセスの透明性が大きく向上しました。Figure 6-1. The place of ADRs in the advice process より引用ADRsの構造と実践ADRsには明確な構造があります。タイトル、メタデータ、決定内容、コンテキスト、オプション、結果、アドバイスという基本的なセクションで構成されます。各セクションは読み手を意識した構造になっており、決定の背景から結果までを効果的に伝えることができます。実際の開発現場ではオプションと結果のセクションが重要です。あるプロジェクトでデータベースの選定を行う際にADRsを活用しました。複数のオプションを比較検討する過程で、チームメンバー全員が意思決定に参加できる環境を作ることができました。ADRsのライフサイクル管理ADRsのステータス管理は重要です。ドラフト、提案、承認、廃止といった基本的なステータスに加えて、組織の必要に応じて独自のステータスを追加することも可能です。ステータス管理を通じてADRsの現在の状態を明確に示すことができます。とある案件ではGitHubのプルリクエストプロセスとADRsを統合しました。これによりレビューとフィードバックのプロセスが自然な形で確立され、意思決定の質が向上しました。ADRsの組織的影響ADRsの導入は組織文化にも大きな影響を与えます。意思決定プロセスの透明性が高まることで、チーム間の信頼関係が強化されます。また、過去の決定を参照できることで、新しいメンバーのオンボーディングも効率化されます。一方で、ADRsの導入には慎重なアプローチが必要です。形式的な文書作成に陥らないよう、実際の意思決定プロセスを支援するツールとして活用することが重要です。過度な形式主義は避けるべきです。結論と展望ADRsは現代のソフトウェア開発組織に不可欠なツールです。アーキテクチャ意思決定の透明性を高め、組織の学習を促進します。しかし、その効果を最大限に引き出すためには、組織の文化や既存のプロセスに合わせた適切な導入が必要です。今後の課題としては、分散開発チームでのADRsの活用や、自動化ツールとの統合などが考えられます。これらの課題に取り組むことで、より効果的なアーキテクチャ意思決定プロセスを実現できるでしょう。結論ADRsは理論的な枠組みとしても優れていますが、実践的なツールとしてさらに重要です。とある案件では週次のアーキテクチャレビューでADRsを活用しています。これにより意思決定プロセスが標準化され、チーム全体の理解が深まりました。最後に強調したいのは、ADRsは生きたドキュメントだということです。形式的な文書作成に終始せず、実際の意思決定プロセスを支援するツールとして活用することが成功の鍵となります。組織の成長とともにADRsも進化させていく柔軟な姿勢が重要です。Part II. Nurturing and Evolving Your Culture of Decentralized TrustPart II. Nurturing and Evolving Your Culture of Decentralized Trustは、分散型アーキテクチャにおける組織文化の育成と発展に焦点を当てたパートです。Part Iで示したアドバイスプロセスとADRsを基盤として、それらを実効性のある仕組みへと成長させるために必要な要素を解説します。従来のヒエラルキー型組織から信頼ベースの分散型組織への移行における権限とガバナンスの再構築から始まり、その実現を支援する具体的な仕組みを提示します。特徴的なのはアーキテクチャ・アドバイスフォーラム、クロスファンクショナル要件、技術戦略、アーキテクチャ原則、テクノロジーレーダーといった支援要素の導入です。これらは一見シンプルですが、組織の状況に応じて柔軟に適用・進化させることができる実践的なツールです。このパートは、分散型アーキテクチャの実践に不可欠な信頼の文化を育むための具体的なアプローチを提供します。組織の一貫性を保ちながら分散型の意思決定を実現する方法を学ぶことができます。Chapter 7. Replacing Hierarchy with Decentralized Trust第7章「Replacing Hierarchy with Decentralized Trust」は、組織の階層構造を分散化された信頼関係へと転換する過程について詳細に解説しています。この章を通じて著者は、アーキテクチャの実践における信頼の重要性と、その育成・維持に必要な要素を具体的に示しています。変化を起こすリーダーはまず信頼を構築する　生き残る組織に変えるリーダーシップ作者:Frances Frei（フランシス・フライ）,Anne Morriss（アン・モリス）日本能率協会マネジメントセンターAmazon信頼に基づく意思決定への転換アーキテクチャ・アドバイスプロセスは従来の階層的な意思決定構造を根本から変革します。意思決定の責任と説明責任を再分配し、より分散的で柔軟な組織構造を実現します。この転換は組織に大きな変化をもたらします。あるプロジェクトでは、従来のアーキテクチャ・レビューボードを廃止し、アドバイスプロセスへの移行を実施しました。当初は混乱もありましたが、チーム間のコミュニケーションが活発になり意思決定のスピードが大幅に向上しました。信頼文化の醸成著者は信頼文化の育成が不可欠だと主張します。信頼は自然に生まれるものではなく、意識的な取り組みが必要です。組織の規模が大きくなるにつれて、信頼関係の維持は難しくなります。とある案件では週次の振り返りミーティングを設け、意思決定プロセスの透明性を確保しています。これにより、チームメンバー同士の信頼関係が強化され、より良い意思決定が可能になりました。フロー重視のマインドセット著者はフローを重視するマインドセットの重要性を強調します。Netflixの事例を引用しながら、不必要な規則や承認プロセスを排除することの意義を説明します。実際のプロジェクトでも、過度な承認プロセスがボトルネックとなっていた経験があります。アドバイスプロセスの導入により、意思決定のフローが改善され、開発のスピードが向上しました。信頼の維持と成長組織の成長とともに信頼関係を維持することは困難になります。著者は小規模なチームから大規模な組織への移行過程で起こる課題を詳細に分析します。あるプロジェクトでは、チームの規模拡大に伴い、非公式なクリークが形成され始めました。この問題に対して、定期的な1on1ミーティングとフィードバックセッションを導入することで、信頼関係の維持に成功しました。信頼を支える要素著者は信頼関係を支える追加的な要素について言及します。これにはアーキテクチャ・アドバイスフォーラムや検証可能なCFRなどが含まれます。これらの要素は組織の状況に応じて選択的に導入することが重要です。とある案件では技術レーダーを導入し、技術選定の透明性を確保しています。これにより、チーム間の知識共有が促進され、より良い意思決定が可能になりました。確実性と予測可能性の誘惑著者は確実性と予測可能性への執着に警鐘を鳴らします。これは組織が官僚主義に陥る主要な原因となります。私も以前、過度な標準化により柔軟性を失ったプロジェクトを経験しています。実験的アプローチの重要性著者は継続的な実験とフィードバックの重要性を強調します。これは組織学習の核心です。とある案件でも小規模な実験から始め、成功事例を徐々に拡大するアプローチを採用しています。結論この章は、分散化された信頼に基づくアーキテクチャ実践への移行について、実践的な指針を提供しています。組織の成長に伴う信頼関係の変化と、それに対する対応策の重要性は印象的でした。これらの知見は、現代のソフトウェア開発組織に重要な示唆を与えます。技術の進化とともに組織構造も進化が必要です。分散化された信頼関係に基づく意思決定プロセスは、その進化の重要な一歩となるでしょう。今後の課題としては、リモートワークの普及に伴う信頼関係の構築方法や、グローバル組織における文化的な違いへの対応などが考えられます。これらの課題に対しても、本章で示された原則は有効な指針となるはずです。Chapter 8. An Architecture Advice Forum第8章「An Architecture Advice Forum」は、アーキテクチャ・アドバイスプロセスを支援する重要なツールとしてのアーキテクチャ・アドバイスフォーラムについて詳細に解説しています。この章を通じて、著者は定期的な対話の場がアーキテクチャ意思決定の質を向上させ、組織の信頼関係を強化する方法を具体的に示しています。ダイアローグ 価値を生み出す組織に変わる対話の技術作者:熊平美香ディスカヴァー・トゥエンティワンAmazonアドバイスフォーラムの本質アーキテクチャ・アドバイスフォーラムは単なる会議ではありません。それは意思決定プロセスを透明化し信頼関係を構築する場です。従来のアーキテクチャレビューボードとは異なり、承認プロセスではなく対話を重視します。このフォーラムの導入により意思決定の質が劇的に向上しました。あるプロジェクトでは、マイクロサービスアーキテクチャへの移行を決定する際にアドバイスフォーラムを活用し、多様な視点からの意見を集約できました。フォーラムの構造と運営フォーラムはシンプルな構造を持ちます。新規の決定案件に対するアドバイス、既存の決定のステータス確認、そしてその他の事項という基本的な議題構成です。このシンプルさが参加者の集中力を高め、本質的な議論を可能にします。実際の運用では定期的な開催が重要です。週次や隔週での開催が一般的ですが、組織の規模や文化に応じて調整が必要です。とある案件では週次開催を採用し、必要に応じて臨時セッションも設けています。協調的な議論の促進従来の対立的な議論から協調的な対話へのシフトがアドバイスフォーラムの特徴です。参加者は意見を戦わせるのではなく、共通の課題解決に向けて知見を共有します。Figure 8-1は従来の一対一のアドバイス形式と、フォーラム形式の違いを明確に示しています。フォーラムでは複数の視点が同時に共有され、より豊かな議論が可能になります。Figure 8-1. Comparing the interaction modes of the “no advice forum” approach (multiple, one-to-one serial interactions, one after another) with the “advice forum” alternative (multiple conversations, all in the same forum, with an audience of other advice offerers as well as nonadvising, learning observers) より引用信頼関係の構築アドバイスフォーラムは信頼関係の構築に大きく貢献します。定期的な対話を通じて、チーム間の理解が深まり、組織全体の凝集性が高まります。このフォーラムを通じて部門間の壁が徐々に低くなっていきました。実践的な導入方法フォーラムの導入は段階的に行うべきです。まず小規模なグループで実験的に開始し、成功事例を積み重ねていくアプローチが効果的です。初期段階では明確な目的と期待値を設定することが重要です。とある案件では最初の3ヶ月を試験期間として設定し、参加者からのフィードバックを基に継続的な改善を行いました。この経験から、フォーラムの形式は組織の文化に合わせて柔軟に調整すべきだと学びました。組織的な影響フォーラムは組織文化の変革をもたらします。透明性の向上は信頼関係を強化し、より良い意思決定を可能にします。また、新しいメンバーの参加障壁を下げ、知識共有を促進します。結論アーキテクチャ・アドバイスフォーラムは、現代のソフトウェア開発組織に不可欠なツールです。透明性と信頼を基盤とした意思決定プロセスは、より良いアーキテクチャの実現と組織の成長を支援します。今後の課題としては、リモートワーク環境でのフォーラムの効果的な運営や、大規模組織での展開方法の確立が挙げられます。しかし、フォーラムの基本原則を理解し適切に適用すれば、これらの課題も克服できるはずです。このフォーラムは組織の成熟度を高める強力な触媒となります。アーキテクチャ設計の質を向上させるだけでなく、エンジニアリング組織全体の協調性と創造性を高める効果があります。Chapter 9. Testable CFRs and Technology Strategy第9章「Testable CFRs and Technology Strategy」は、組織の技術的アラインメントを実現するための2つの重要な要素について詳細に解説しています。著者はテスト可能なCFR（Cross-Functional Requirements）と技術戦略を通じて、効果的な組織アラインメントを実現する方法を具体的に示しています。組織アラインメントの本質組織のアラインメントは単なる技術的な整合性以上のものです。多くの組織が技術的な標準化のみに注力し、ビジネス目標との整合性を見失いがちです。実際のプロジェクトでは、技術的な方向性は揃っていても組織の目標達成に寄与していないケースをよく目にします。あるプロジェクトでは、マイクロサービスアーキテクチャの採用により技術的な統一は図れましたが、サービスの分割粒度が業務の実態と合わず、結果として開発効率の低下を招きました。テスト可能なCFRの重要性著者はテスト可能なCFRの必要性を強調しています。CFRはシステム全体に横断的に適用される要件を明確にします。重要なのは、これらの要件が具体的でテスト可能な形で記述されることです。とある案件では、パフォーマンス要件を具体的な数値で定義し、自動テストで継続的に検証できるようにしました。「レスポンスタイムは500ms以内」といった曖昧な表現ではなく、「95%のリクエストが500ms以内、99%が800ms以内に完了すること」と明確に定義することで、チーム間の認識の違いを解消できました。技術戦略の役割技術戦略は組織の方向性を示す重要なツールです。著者は技術戦略を「組織のビジョンと目標達成に向けた技術的な選択と投資判断のフレームワーク」と定義しています。多くの組織が技術戦略を単なる技術選定の指針として扱いがちです。しかし、より重要なのは「何を選択しないか」の明確化です。あるプロジェクトでは、特定のクラウドプロバイダーに限定することで、運用負荷の軽減とコスト最適化を実現できました。ミニマルバイアブルアグリーメント著者は必要最小限の合意の重要性を強調します。これはCFRと技術戦略の両方に適用される概念です。過剰な標準化や制約は組織の柔軟性を損なう一方、不十分な合意は混乱を招きます。とある案件では「最小驚き原則」を採用し、チーム間で予期せぬ違いが発生していないかを定期的にチェックしています。これにより、必要な標準化と柔軟性のバランスを維持できています。戦略的投資の重要性著者は技術戦略を「言葉だけでなく投資」として具現化することを推奨します。これは共有サービスの形で実現されることが多いです。セルフサービス型のインフラストラクチャプラットフォームの提供が効果的でした。各チームが独自のインフラを構築・運用するのではなく、標準化されたプラットフォームを利用することで、開発効率の向上とコスト削減を実現できました。結論CFRと技術戦略は組織アラインメントを実現する上で不可欠なツールです。これらを適切に組み合わせることで、組織は効率的かつ効果的な意思決定が可能になります。しかし、これらのツールの導入には慎重なアプローチが必要です。組織の規模や文化に応じて、段階的な導入と継続的な改善が重要です。今後は、分散開発やクラウドネイティブアーキテクチャの普及に伴い、より柔軟で適応性の高いCFRと技術戦略の在り方が求められるでしょう。技術の進化に合わせて、これらのフレームワークも進化させていく必要があります。Chapter 10. Collectively Sourced Architectural Principles第10章「Collectively Sourced Architectural Principles」は、組織全体で共有されるアーキテクチャ原則の策定と維持について解説しています。この章を通じて著者は、アーキテクチャ原則が単なるドキュメントではなく、組織の技術戦略を実現するための重要な指針となることを示しています。チームトポロジー　価値あるソフトウェアをすばやく届ける適応型組織設計作者:マシュー・スケルトン,マニュエル・パイス日本能率協会マネジメントセンターAmazonアーキテクチャ原則の本質アーキテクチャ原則は組織の技術戦略を具体化する重要なツールです。多くの組織がトップダウンでアーキテクチャ原則を定めようとしますが、そのアプローチでは現場の実態と乖離した形骸化した原則になりがちです。実際のプロジェクトでは、チームメンバー全員で原則を策定することで、より実践的で実効性のある原則を作ることができました。例えばマイクロサービスアーキテクチャの採用において、「チームの独立性を最も重視する」という原則を設定し、サービス間の結合度を最小限に抑えることができました。learning.oreilly.comプリンシプルワークショップの実践著者はプリンシプルワークショップを通じて、組織全体で原則を策定することを推奨しています。重要なのは、参加者の多様性と、戦略的なテーマに基づいた原則の整理です。原則のメンテナンス原則の進化も重要なテーマです。著者は原則を「生きたドキュメント」として捉え、定期的な見直しと更新の必要性を説きます。ADRsを通じて原則の変更を記録し、その背景と理由を明確にすることで、組織の学習を促進できます。クラウドネイティブ化の過程で原則の見直しが必要になりました。「自社のクラウド」という原則に縛られすぎて柔軟性を失っていたため、「適切なクラウドサービスの選択」という原則に更新しました。組織文化との関係著者は原則が組織文化の反映であることを強調します。単なる技術的なガイドラインではなく、組織の価値観とビジョンを体現するものとして位置づけています。私のチームでは原則の策定プロセス自体が、組織文化の変革のきっかけとなりました。チーム間の対話が活発になり、技術的な決定に対する共通理解が深まりました。実践的な適用原則の適用は柔軟であるべきです。著者は原則を「絶対的なルール」ではなく「意思決定の指針」として捉えることを推奨します。これは現代のソフトウェア開発における不確実性に対応する賢明なアプローチです。例えば、あるプロジェクトでは特定の機能実装において原則との衝突が発生しましたが、その状況をADRで明確に記録し、例外的な対応の理由を共有することで、チーム全体の理解を深めることができました。結論アーキテクチャ原則は、組織の技術戦略を実現するための重要なツールです。しかし、その効果を最大限に引き出すためには、全員参加の策定プロセス、定期的な見直し、そして柔軟な適用が不可欠です。今後の課題としては、リモートワーク環境での原則策定ワークショップの実施方法や、グローバル組織での文化的な違いへの対応が挙げられます。しかし、著者が示した基本的なフレームワークは、これらの課題に対しても十分な適用可能性を持っています。Part III. Finding Your Way Through the Decision LandscapeChapter 11. Technology Radar第11章「Using a Technology Radar」は、組織の技術選択と意思決定を支援するためのツールとしてのTechnology Radarについて解説しています。著者は単なる技術トレンドの可視化ツール以上の価値をTechnology Radarに見出し、組織の集合知を活用した意思決定支援の仕組みとして位置づけています。Technology Radarといえばどこかのポッドキャストでt-wadaさんがオススメをしていたのでそこから見始めている(本当に覚えてなくて誰か教えてください⋯)。www.thoughtworks.comTechnology Radarの本質Technology Radarは航空管制のレーダーに似た形式で技術トレンドを可視化します。Thoughtworksが開発したこのツールは技術の採用状況を4つの象限(Tools/Techniques/Platforms/Languages \u0026 Frameworks)と4つのリング(Adopt/Trial/Assess/Hold)で表現します。著者はこれを「単なる技術マッピングではなく組織の集合的な経験と知見を凝縮したもの」と説明します。このビジュアライゼーションは一目で技術の位置づけを把握できる優れた特徴を持ちます。「Mermaid」のような新興技術が「Trial」から「Adopt」へ移行する様子や「AWS」が「Adopt」から「Trial」へ後退する変遷など、技術の盛衰を時系列で追跡できます。Technology Radarと意思決定プロセスTechnology Radarは組織の意思決定プロセスと密接に連携します。アーキテクチャ決定記録(ADR)にTechnology Radarのブリップ(技術要素)を参照することで、決定の文脈や根拠を明確にできます。Technology Radarと意思決定プロセスの連携は双方向です。新しい技術の採用決定は新規ブリップの追加につながり、既存技術の評価変更は位置の移動として反映されます。この相互作用により、組織の技術選択の履歴と根拠が透明化されます。組織独自のTechnology Radarの構築著者は組織固有のTechnology Radarの重要性を強調します。社内版Technology Radarでは自社開発のツールやフレームワークもブリップとして登録できます。また象限やリングの定義も組織の文脈に合わせて調整可能です。Technology Radarの作成プロセスもまた重要な価値を持ちます。ブリップの収集から位置づけの決定まで、組織全体を巻き込んだ共創的なプロセスとして設計されています。このプロセス自体が技術に関する組織的な対話と学習の機会となります。継続的な更新と発展Technology Radarは定期的な更新(リスイープ)により鮮度を保ちます。更新プロセスにおけるブリップのステータス変更を示しています。定期更新に加えて個別の意思決定に応じた随時更新も可能です。この柔軟な更新メカニズムにより、組織の技術動向をリアルタイムに反映できます。更新の際にはブリップの履歴を保持することが推奨されます。各ブリップの変遷を追跡できる履歴ページを用意することで、技術選択の経緯と根拠を後から参照できます。これは新規参画者のオンボーディングや過去の意思決定の振り返りに有用です。実践的な示唆Technology Radarの実践では、適切な更新頻度の設定が重要です。著者は四半期または半年ごとの更新を推奨していますが、組織の技術変化の速度に応じて調整が必要です。より重要なのは更新のクオリティです。表面的な技術トレンドの追跡ではなく、組織の経験と教訓を凝縮した有意義な指針となることを目指すべきです。Technology Radarの運用では意思決定支援ツールとしての本質を見失わないことが肝要です。単なる技術カタログではなく、組織の技術選択を導く羅針盤として機能させる必要があります。そのためには技術情報の蓄積だけでなく、その活用を促進する仕組みづくりも重要です。Technology Radarは組織の技術戦略を可視化し共有するための強力なツールです。しかしその効果を最大限に引き出すには、組織文化や既存のプロセスとの調和が不可欠です。形式的な導入ではなく、組織の意思決定プロセスと密接に連携させることで、真の価値を発揮できます。結論Technology Radarは組織の技術選択を支援する効果的なツールとして機能します。その価値は単なる技術トレンドの可視化にとどまらず、組織の集合知を活用した意思決定支援の仕組みとして重要です。定期的な更新と履歴の保持により、組織の技術進化の軌跡を記録し学習に活かすことができます。意思決定プロセスとの密接な連携により、組織全体の技術力向上に貢献する重要な基盤となります。Part III. Finding Your Way Through the Decision LandscapePart III: Finding Your Way Through the Decision Landscape では、分散型の意思決定プロセスを効果的に実践するためのフレームワークや技術、心構えを紹介しています。まず、意思決定における人間的な側面に焦点を当て、感情、創造性、バイアス、恐れといった要素がどのように意思決定に影響を与えるかを探り、それを乗り越えるために認知科学やチェックリストを活用して自己の弱点を意識的に克服する方法を提案します。また、ソフトウェア開発における不確実性や「未知の未知」に対処するために、小さな決定を迅速に積み重ねるアプローチや、最小限の機能を持つシステムを構築して初期段階で重要な決定を検証する「Walking Skeleton」を推奨し、スパイクを活用してリスクを軽減する方法を説明します。さらに、意思決定の相互関連性を認識し、過去と未来の決定がどのように影響し合うかを4つの視点から分析しながら、技術的および社会技術的な要素を考慮したアプローチを示し、組織内の信頼関係や文化の影響を考慮した対話やフィードバックを重視することの重要性を強調しています。これらを通じて、分散型の意思決定を支える心構えと実践的な手法を提供し、複雑な意思決定の環境を乗り越えるための実用的な知見を得られるようにしています。Chapter 12. The Art of Deciding第12章「The Art of Deciding」は、アーキテクチャ意思決定における人間的な側面、感情や創造性といった定量化が難しい要素に焦点を当てています。著者は意思決定を単なる論理的プロセスとしてではなく、人間の感性や組織の文化が深く関わる芸術的な営みとして捉え、その本質と実践方法を詳細に解説しています。コンテキストのフレーミング意思決定における最初の重要なステップは適切なコンテキストの設定です。著者は地図の比喩を用いて説明します。1:1の地図は全ての詳細を含むものの実用的ではありません。一方で1:1000の地図は必要な情報を抽象化し意思決定を支援します。意思決定のコンテキストも同様に適切な抽象化と焦点付けが重要です。例えば私が以前関わったクラウド移行プロジェクトでは、技術的な観点だけでなく法規制やビジネス要件も含めた包括的なコンテキストを設定することで、より適切な意思決定が可能になりました。オプションと結果の検討意思決定のオプションと結果を検討する際は創造性が重要な役割を果たします。著者は「フレームに制限されすぎない」ことを強調します。これは実務でも重要な指摘です。以前のプロジェクトで既存のアーキテクチャパターンにとらわれすぎた結果、より良いソリューションを見逃した経験があります。オプションの検討ではインスピレーションの源を広く求めることも重要です。技術書だけでなく他分野の知見も参考になります。例えば著者は農業の本からも洞察を得ています。この多面的なアプローチは新しい視点をもたらします。アドバイスを通じた洗練アドバイスプロセスは意思決定の質を高める重要な要素です。ただしこれは形式的なものではなく社会的な契約として機能します。著者はBadaraccoの質問フレームワークを引用し「我々の義務は何か」「現実の世界で何が機能するか」といった観点からの検討を推奨します。実務ではアドバイスの質と形式のバランスが重要です。形式的なレビューに陥らず建設的な対話を生み出すには組織文化の醸成が必要です。私のチームでは週次のアーキテクチャ・フォーラムを設け、オープンな議論の場を作っています。メタ認知の重要性著者は意思決定者のメタ認知（自己の思考プロセスへの理解）の重要性を強調します。これは感情やバイアスへの対処に重要です。例えば「なぜその選択に不安を感じるのか」「どのようなバイアスが働いているのか」を意識的に考えることで、より良い判断が可能になります。実践では3つのエクササイズが提案されています。理由の共有・反応と応答の区別・挑戦的なアドバイスの積極的な収集です。これらは日々の意思決定プロセスに組み込むことで効果を発揮します。意思決定の実行最後の意思決定の実行段階では恐れとバイアスへの対処が重要です。著者はBikartの5つの恐れ（失敗・成功・同一化・認識欠如・利己性）を紹介し、これらへの認識と対処の重要性を説明します。実務では「決定を試着する」というアプローチが有効です。ADRをドラフト状態で作成し一晩置くことで、より客観的な判断が可能になります。私のチームでもこのプラクティスを採用し効果を上げています。組織文化への影響本章の内容は個人の意思決定スキル向上だけでなく組織文化の変革にも大きな示唆を与えます。従来型のアーキテクトが意思決定権限を手放し、アドバイザーとしての新しい役割を受け入れるプロセスは重要です。本章では著者が実際に経験した事例としてPete Hunter（エンジニアリングディレクター）のケースが印象的です。Pete Hunterはアーキテクチャ・アドバイスプロセスを初めて導入したクライアントの一人でした。彼は当初、チームに意思決定権限を委譲することへの不安や懸念を抱えていましたが、プロセスを通じて組織の成長を実感しました。Hunterの事例は権限移譲における心理的な課題を鮮明に示しています。彼は意思決定権限の委譲に際して、チームの能力や判断への不安、コントロール欲求との葛藤など、多くのリーダーが直面する感情的な課題を率直に語っています。しかし最終的に彼は「We need to let go and support them」（権限を手放してチームをサポートする必要がある）という重要な洞察に至りました。この経験は組織における信頼構築と権限委譲の本質を示す貴重な事例となっています。結論アーキテクチャ意思決定は論理的な分析だけでなく人間的な要素を含む複雑な営みです。本章は意思決定の「アート」としての側面に光を当て、より効果的な実践のための具体的なガイダンスを提供しています。重要なのはコンテキストのフレーミング、創造的なオプション検討、アドバイスプロセスの活用、メタ認知の実践です。これらの要素を意識的に取り入れることで、より良いアーキテクチャ意思決定が可能になります。今後の組織運営においては、これらの知見を活かした意思決定プロセスの確立と、それを支える文化の醸成が重要な課題となるでしょう。技術的な卓越性と人間的な洞察の両立が、現代のソフトウェアアーキテクチャ実践には不可欠です。Chapter 13. Tackling Architectural Variability第13章「Tackling Architectural Variability」は、ソフトウェア開発における不確実性とアーキテクチャの可変性に焦点を当てています。著者は同じシステムを二度と作ることはないという洞察から始め、この本質的な可変性にどう向き合うべきかについて具体的な指針を提供します。BIG THINGS　どデカいことを成し遂げたヤツらはなにをしたのか？作者:ベント・フリウビヤ,ダン・ガードナーサンマーク出版Amazon可変性の本質と影響ソフトウェア開発における可変性は避けられない現実です。最も慎重に計画された開発プロジェクトでさえ予期せぬ変化に直面します。例えばある大規模プロジェクトでは、当初想定していなかったスケーリング要件の変更により、ID管理システムの設計を大幅に見直す必要が生じました。可変性は4つの主要な課題をもたらします。作業の困難さ、予測不可能な変更の発生、認知的負荷の増大、そしてコミュニケーションと同期のオーバーヘッドです。これらの課題は個々のチームだけでなく組織全体に影響を及ぼします。可変性への実践的アプローチ著者は可変性を単なる問題としてではなく「ソフトウェアの力の源泉」として捉え直すことを提案します。この視点は非常に重要です。私のチームでも、予期せぬ要件変更を新機能開発の機会として活用した経験があります。重要なのは小さな決定の積み重ねというアプローチです。この方法は3つの利点を持ちます。第一に意思決定から実装までの時間を短縮できます。第二にオーバーヘッドを削減できます。そして第三にフィードバックを加速し、リスクを低減できます。Walking Skeletonの活用著者は初期の意思決定を検証する手段としてWalking Skeletonの概念を紹介します。これは最小限の機能を持つ実装を通じて、主要なアーキテクチャ上の決定を早期に検証する手法です。新規プロジェクトの立ち上げ時にこのアプローチを採用し、大きな効果を得ました。注目すべきは機能的なコンテキストを通じた決定の検証です。単なる技術的な検証ではなく実際のユースケースに基づく検証により、より実践的なフィードバックを得ることができます。フラクチャープレーンの活用大きな決定を分割する際の指針として著者はフラクチャープレーンの概念を提示します。機能的、タイミング的、コードベース上の分割点を見極めることで、より効果的な意思決定が可能になります。私のプロジェクトでも、マイクロサービスの分割において、この考え方に基づいてサービス境界を定義し、成功を収めました。将来のフローへの影響意思決定は現在の開発フローだけでなく将来のフローにも影響を与えます。著者はReinertsenの「小さなバッチサイズは高いオーバーヘッドを生む」という一般的な認識への反論を紹介します。実際の開発現場でも、小さな決定の積み重ねが結果として意思決定の質と速度を向上させる事例を多く経験しています。結論可変性はソフトウェア開発の本質的な特徴であり、それを排除するのではなく「活用する」という視点が重要です。著者の提案する小さな決定の積み重ねというアプローチは、現代のソフトウェア開発における実践的な指針となります。この方法はマイクロサービスアーキテクチャなど複雑なシステムの開発において、高い効果を発揮しています。今後の組織運営においては、この知見を活かし「予測不可能性を前提とした開発プロセス」の確立が重要な課題となるでしょう。技術的な卓越性と人間的な洞察の両立が、現代のソフトウェアアーキテクチャ実践には不可欠です。Chapter 14. Variability and the Interconnectedness of Decisions第14章「Variability and the Interconnectedness of Decisions」は、アーキテクチャ意思決定の相互関連性とその可変性について深く掘り下げています。著者は意思決定の関係性を4つの視点から分析し、それらを理解し効果的に扱うためのツールとしてスパイクの活用を提案しています。「変化を嫌う人」を動かす:魅力的な提案が受け入れられない4つの理由作者:ロレン・ノードグレン,デイヴィッド・ションタル,船木 謙一(監修)草思社Amazonスパイクによる可変性への対処意思決定の可変性に対処する強力なツールとして著者はスパイクの活用を提案します。スパイクは不確実性の高い決定を検証する際に非常に効果的です。例えば以前のプロジェクトでマイクロサービスアーキテクチャへの移行を検討した際、スパイクを使って主要なアーキテクチャ上の決定を早期に検証できました。Figure 14-1. Spikes fit into an overall decision process at the start, somewhere around “decision required” and “option making” より引用Figure 14-1に示されるように、スパイクは意思決定プロセスの初期段階で活用されます。本番環境へのデプロイまで待たずにフィードバックを得られることは大きな利点です。実際にスパイクを通じて想定外の課題を早期に発見し、アプローチを修正できた経験が何度もあります。意思決定の4つの視点著者は意思決定の関係性を理解するための4つの視点を提示します。第一に意思決定の連続性です。決定は単独で存在するのではなく時系列上で連なっています。第二に逆ピラミッド構造です。より低層の決定が上層の決定のコンテキストを形成します。第三に原子性です。これ以上分割できない最小単位の決定が存在します。第四に双方向の対話です。新しい決定が過去の決定に影響を与えることもあります。この4つの視点は実務でも非常に有用です。あるプロジェクトでは意思決定の逆ピラミッド構造を意識することで、より効果的な決定順序を設計できました。低層の決定が上層に与える影響を考慮することは重要です。レイヤー構造の重要性著者は意思決定を3つの主要なレイヤーで捉えることを提案します。レイヤー1は独立した製品やプログラムに関する決定です。レイヤー2は境界と制約の保護です。レイヤー3は自律的で接続されたコミュニティに関する決定です。でもこのレイヤー構造の理解は非常に重要でした。クラウドネイティブアプリケーションの開発では、レイヤー2での適切な境界設定が後の開発の成否を大きく左右しました。各レイヤーの特性を理解し意識的に決定を行うことで、より堅牢なアーキテクチャを実現できます。社会技術的な複雑性意思決定の相互関連性は技術的な側面だけでなく社会的な側面も持ちます。著者は信頼関係とコントロールの感覚の重要性を強調します。技術的に正しい決定であっても、組織の信頼関係が損なわれると実装が困難になることがあります。この文脈で参考になるのが『何回説明しても伝わらない』という本です。この本は認知科学の観点から、コミュニケーションの本質的な課題と解決策を提示しています。特に「話せばわかる」という前提自体を問い直し、相手の立場に立った理解と伝達の重要性を説いています。これは分散型アーキテクチャにおける意思決定プロセスを考える上でも重要な示唆を与えてくれます。「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策作者:今井むつみ日経BPAmazonスパイクはこの社会技術的な複雑性にも対処できます。コードを書いて検証するという具体的なアプローチは、抽象的な議論よりも建設的な対話を促進します。私のチームでもスパイクを通じた検証により、チーム間の信頼関係を強化できた経験があります。結論可変性と相互関連性を持つアーキテクチャ意思決定において、スパイクは強力なツールとなります。意思決定の4つの視点を理解し、適切なレイヤー構造で捉えることで、より効果的な意思決定が可能になります。また社会技術的な側面にも配慮することで、組織全体としての決定の質を向上させることができます。今後の組織運営においては、これらの知見を活かし「早期検証と段階的な進化」を重視したアプローチが重要になるでしょう。技術的な卓越性と人間的な洞察の両立が、現代のソフトウェアアーキテクチャ実践には不可欠です。Chapter 15. The Transition of Power and Accountability第15章「The Transition of Power and Accountability」は、アーキテクチャ意思決定プロセスの導入に伴う権限と責任の移行について深く掘り下げています。著者は組織的・個人的な課題に焦点を当て、分散型アーキテクチャ実践への移行を成功させるための具体的な指針を提供します。権限移行の本質的な課題組織における権限移行は単純なプロセスではありません。伝統的な階層構造から分散型の意思決定モデルへの移行には大きな困難が伴いました。重要なのは心理的安全性の確保です。Figure 15-1. A circles and roles view of the advice process that shows the accountabilities inherent in the advice process, how they map to various roles, and how those roles interrelate より引用Figure 15-1は意思決定プロセスにおける役割と責任の関係を示しています。このモデルは単なる組織図ではなく、各役割が持つ責任と相互の関係性を明確に示します。実際のプロジェクトでもこのような可視化が有効でした。権限を得る側の課題権限を得る側の主な課題は「本当に権限を持っているのか」という不安です。私のチームでも当初はアーキテクトに過度に依存する傾向がありました。これを克服するには明確なコミュニケーションと段階的な移行が重要です。NetflixのSunshiningの例は印象的です。失敗を隠すのではなく公開し学習する文化は、権限移行の成功に不可欠です。私のプロジェクトでもこのアプローチを採用し、チームの自律性と学習能力が大きく向上しました。権限を手放す側の課題権限を手放す側も大きな不安を抱えます。「悪い決定がされるのではないか」という懸念は自然なものです。私自身もアーキテクトとしてこの不安を経験しました。しかし重要なのは「完璧な決定」ではなく「学習と改善のプロセス」です。注意が必要なのはサボタージュの問題です。著者は意図的な妨害行為の具体例を挙げています。このような行為は往々にして無意識に行われることが多く、早期発見と対処が重要でした。メタ認知の重要性著者はメタ認知（自己の思考プロセスの理解）の重要性を強調します。これは私も強く共感する点です。「反応」と「応答」の区別は実践的に非常に重要です。あるプロジェクトでは、チーム全体でこの概念を共有することで、より建設的な対話が可能になりました。メタ思考～「頭のいい人」の思考法を身につける作者:澤円大和書房Amazon結論権限と責任の移行は組織にとって大きな挑戦です。しかし適切に実施することで、より強靭で適応力のある組織を作ることができます。心理的安全性の確保と明確なコミュニケーションが重要でした。今後の組織運営においては、心理的安全性の確保と透明性の高いプロセスの確立が重要な課題となります。技術的な卓越性と人間的な洞察の両立が、現代のソフトウェアアーキテクチャ実践には不可欠です。Chapter 16. On Leadership第16章「On Leadership」は、分散型アーキテクチャにおけるリーダーシップの本質と実践について深く掘り下げています。著者はリーダーシップに関する一般的な誤解を解き、分散型アーキテクチャの文脈における効果的なリーダーシップのあり方を具体的に示しています。誰もが人を動かせる!　あなたの人生を変えるリーダーシップ革命作者:森岡毅日経BPAmazonリーダーシップの誤解を解く著者はまずリーダーシップに関する4つの主要な誤解を指摘します。第一に「リーダーシップは生まれつきの才能である」という誤解です。著者はPeter Druckerの言葉を引用し「リーダーシップはパフォーマンスであり地道な仕事である」と主張します。第二に「リーダーシップは階層と結びついている」という誤解です。実際の組織では「ピーターの法則」として知られるように階層的な昇進は必ずしもリーダーシップ能力と一致しません。むしろ階層的な昇進システムそのものがリーダーシップの育成を阻害する可能性があります。第三に「リーダーシップは一方向的である」という誤解です。従来の考え方では指示は上から下へ一方向に流れると想定されてきました。しかし現代の組織では双方向のコミュニケーションとフィードバックが不可欠です。第四に「リーダーシップはマネジメントと同じである」という誤解です。マネジメントが現状の最適化を目指すのに対しリーダーシップは変革と未来に焦点を当てる点で本質的に異なります。Leader-Leaderアプローチ著者はリーダーシップのモデルとしてL. David Marquetの「Leader-Leader」アプローチを推奨します。このアプローチは全員がリーダーになり得るという信念に基づいています。重要なのは認知的な仕事においては従来の上意下達型のリーダーシップが機能しないという洞察です。Leader-Leaderアプローチでは「私はこうするつもりです」という宣言を通じてリーダーシップを実践します。この宣言に対して反対がなければ実行に移せます。これにより意思決定の分散化と迅速化を両立できます。移行期のリーダーシップ課題分散型アーキテクチャへの移行期には4つの主要な課題があります。第一に「コントロールを手放す」ことです。これは単なる形式的な権限移譲ではなく心理的な変革を必要とします。第二に「安全性を個別の決定より優先する」ことです。多様な視点を取り入れるには心理的安全性の確保が不可欠です。技術的な正しさよりも組織の信頼関係構築を優先する必要があります。第三に「I intend to」プラクティスの導入です。これは権限移譲を具体化する効果的な方法です。チームメンバーが主体的に行動を起こせる環境を作ります。第四に「信頼してから検証する」アプローチです。失敗を許容し学習機会として捉える文化づくりが重要です。検証は必要ですがマイクロマネジメントは避けるべきです。モラルリーダーシップの重要性著者はモラルリーダーシップの継続的な必要性を強調します。技術的パフォーマンスへの影響は過大評価されがちですが組織の道徳的側面への影響は過小評価されています。モラルリーダーシップは多様性を保護し心理的安全性を促進します。これは分散型アーキテクチャの実践において重要です。パワーバランスの偏りを防ぎ幅広い声が貢献できる環境を維持します。実践的な示唆著者の提案は現代のソフトウェア開発組織に重要な示唆を与えます。注目すべきはリーダーシップを特定の役職や個人に固定化しないという考え方です。組織の成長とともにリーダーシップも進化させる必要があります。継続的な学習とフィードバックを重視する文化づくりも重要です。失敗を恐れず実験と改善を繰り返すサイクルを確立することで組織全体の能力が向上します。結論本章は分散型アーキテクチャにおけるリーダーシップの新しいモデルを提示しています。Leader-Leaderアプローチとモラルリーダーシップの組み合わせは現代のソフトウェア開発組織に適した枠組みを提供します。重要なのはリーダーシップを学習可能なスキルとして捉える視点です。これは組織の持続的な成長と進化を支える基盤となります。今後の組織運営においてはこれらの知見を活かし分散型でありながら一貫性のある技術戦略を実現することが求められます。Chapter 17. Fitting the Advice Process Within Your Organization第17章「Fitting the Advice Process Within Your Organization」は、アーキテクチャ・アドバイスプロセスを既存の組織構造に統合する方法について深く掘り下げています。著者は組織の境界とその接点に注目し、分散型アーキテクチャ実践を組織全体に効果的に適用するための具体的な指針を提供しています。ソフトウェアエンジニアリングのサブカルチャー著者はまずソフトウェアエンジニアリング部門の独自性に着目します。伝統的な組織文化とは異なる特性を持つソフトウェア開発において、アドバイスプロセスは自然な形で受け入れられる可能性が高いと指摘します。注目すべきはソフトウェア開発の4つの特徴です。標準的な製品開発モデルとの違い、変化の速度、組織との接点の少なさ、そして既に受け入れられている文化的な違いです。これらは以前関わった大規模プロジェクトでも、ソフトウェア開発チームは他部門とは異なる働き方を自然に確立していました。アドバイスプロセスバブルの概念著者はアドバイスプロセスバブルという概念を提示します。このバブルは分散型実践のための明確な境界を持つ空間として機能します。Figure 17-1はバブルの基本的な構造を示しており、組織の他の部分との関係性を明確にします。Figure 17-1. An advice process bubble where teams practice the advice process, surrounded by the rest of the organization where everything continues as usual より引用バブルは完全に独立しているわけではありません。むしろ組織との適切な接点を維持しながら、内部の自律性を確保する仕組みとして機能します。私のチームでもこのアプローチを採用し、組織全体との調和を保ちながら独自の開発文化を育てることができました。バブルの成長と分割バブルの成長には慎重なアプローチが必要です。著者は段階的な成長と適切なタイミングでの分割を推奨します。Figure 17-2は分割後のバブル構造を示しており、組織とのインターフェースをどう維持するかが明確に示されています。Figure 17-2. An additional circle with responsibilities for linking into the wider organization’s performance management process has been added to the advice process bubble より引用重要なのはバブル分割の判断基準です。信頼関係の低下、意思決定の遅延、不必要な情報共有の増加などが分割のシグナルとなります。あるプロジェクトでは規模の拡大に伴いコミュニケーションコストが増大し、結果として2つのバブルに分割することで効率が改善しました。組織との期待値の管理著者は組織からの期待に対する適切な対応の重要性を強調します。明示的な期待と暗黙的な期待の区別が重要です。要件の達成や透明性の確保といった明示的な期待に加えて、階層的な質問への対応や適切なスキルの確保といった暗黙的な期待にも注意を払う必要があります。この観点は実務上極めて重要です。私のチームでも組織の期待を明確に理解し対応することで、分散型実践の価値を示すことができました。定期的なステータス報告や成果の可視化は、組織との信頼関係構築に大きく貢献しました。結論アドバイスプロセスの組織への適合は継続的な取り組みを必要とします。著者はバブルの独自性を保護しながら組織との調和を図ることの重要性を強調します。これは単なる技術的な課題ではなく、組織文化の変革を伴う取り組みです。このアプローチは現代のソフトウェア開発組織に極めて有効です。マイクロサービスアーキテクチャやDevOpsの実践において、チームの自律性と組織全体の整合性のバランスを取る際に役立ちました。今後の課題としては、リモートワークの普及やグローバル開発の加速に伴う新たな組織的課題への対応が考えられます。しかし著者が示した原則と実践的なアプローチは、これらの課題に対しても有効な指針となるはずです。おわりに実は本書を最初に読んだのは11月でした。読了後すぐに、この本の内容が字分の人生の年末の振り返りや自身の職務経歴書の更新と似ているなぁって思って、書評自体は年末年始に書こうと決めました。その間、折に触れて内容を整理し、メモを取り続けていましたが、実際の執筆は結局大晦日までずれ込んでしまいました。しかし、この「遅さ」が逆に、一年を通じての経験と本書の内容を結びつける機会を与えてくれたように思います。本書「Facilitating Software Architecture」を通じて、私たちは分散型アーキテクチャにおける実践的アプローチを学んできました。印象的だったのは、アーキテクチャの実践が単なる技術的な設計にとどまらず、組織文化や人間関係の深い理解を必要とすることです。本書の核心は、アーキテクチャを「共創的な営み」として捉える視点にあります。伝統的な中央集権型アプローチから分散型への移行は、単なるプロセスの変更以上の意味を持ちます。それは組織全体の思考様式の転換であり、新しい形の協働を生み出す試みです。アーキテクチャ・アドバイスプロセスとADR（Architecture Decision Records）は、この新しいアプローチを支える具体的な実践として重要です。これらは意思決定の透明性を高め、組織の学習を促進する強力なツールとなります。同時に、Technology RadarやWalking Skeletonといった手法は、不確実性の高い環境での実践的な指針を提供してくれます。しかし、最も重要なのは「信頼」を基盤とした組織文化の醸成です。分散型アーキテクチャの成功は、技術的な卓越性だけでなく、組織メンバー間の深い信頼関係に依存します。本書を通じて学んだ様々なプラクティスも、この信頼関係があってこそ効果を発揮するものです。この一年間、私自身が経験した技術への意欲の喪失と回復の過程は、本書の内容と深く共鳴するものでした。個人としてもチームとしても、時には立ち止まり、基本に立ち返ることの重要性を再認識させてくれます。心身の健康に意識を向け、純粋な楽しみの時間を大切にすることは、持続可能な開発文化の基盤となるでしょう。これからのソフトウェア開発は、さらなる複雑性と不確実性に直面することでしょう。しかし、本書で示された分散型アプローチと、それを支える様々な実践は、これらの課題に立ち向かうための強力な武器となるはずです。個人としても組織としても、継続的な学習と適応を重ねながら、より良いソフトウェア開発の実現を目指していきたいと思います。2024年もみなさん、最後まで読んでくれて本当にありがとうございます。途中で挫折せずに付き合ってくれたことに感謝しています。読者になってくれたら更に感謝です。Xまでフォロワーしてくれたら泣いているかもしれません。","isoDate":"2024-12-31T14:25:46.000Z","dateMiliSeconds":1735655146000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Clippyのすすめ - 他者の評価を気にせず何度でも指摘してくれる機械もしくは注意力の限界を超えてケアをしてくれる機械","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/27/170046","contentSnippet":"はじめにプログラミングを学ぶ上で、良いコードの書き方を知ることは非常に重要です。今回は、Rustで良いコードを書くための強力な味方、Clippyについて学んでいきましょう。プログラミング初心者の方から、他の言語からRustに移ってきた方まで、きっと新しい発見があるはずです。私も最近、Rustに関する素晴らしい本を読んでいます。「Effective Rust」と「Idiomatic Rust」は、Rustらしい書き方やデザインパターンについて詳しく解説していて、とても勉強になります。ただ、正直なところ、本を読んだだけでは私自身なかなか良いコードが書けず、ツールでのレビューで「これRustらしくないよね」とよく指摘されています。そのたびに勉強させられています。きっと同じような経験をされている方も多いのではないでしょうか。Idiomatic Rust: Code like a Rustacean (English Edition)作者:Matthews, BrendenManningAmazonEffective Rust: 35 Specific Ways to Improve Your Rust Code (English Edition)作者:Drysdale, DavidO'Reilly MediaAmazonそんな中で私の強い味方になっているのが、今回紹介するClippyです。本で学んだ内容を実践しようとするとき、Clippyは具体的なアドバイスをくれる、とても親切な存在です。特に「ここがRustらしくない」と言われたときの改善方法を、実例を挙げて教えてくれるのが心強いです。rust-lang.github.ioRust 標準 linter: Clippyプログラミング言語には、よくある間違いや非推奨の書き方をチェックして警告を発してくれる、lintというプログラムがあります。元々はC言語をチェックするものでしたが、現在では様々な言語のためのlinterが作られています。Lint Nightなんてイベントもあります。lintnight.connpass.comRustには言語標準のlinterがあり、その名をclippyと言います。使い方は極めて簡単で、cargoツールチェインがインストールされていれば、下記のようにインストールして、$ rustup component add clippy下記のコマンドをcrateのフォルダで実行するだけです。$ cargo clippyClippyのlinterとしての特徴linterはコードの品質を向上するために、多くの現場で使われているツールですが、実際には厳しすぎるルールや、実際の問題にそぐわないものも多くあります。これを偽陽性(false positive)の検出と呼びます。通常は設定ファイルや特殊なコメントをコードに埋め込むことによって、特定のlintの有効・無効を切り替えることになります。これは無視できない労力で、linterのバージョンを更新するたびに新たなルールに対応する必要が出てきたり、コメントによってコードが汚くなったりするデメリットもあります。Clippyの特徴は、デフォルトの設定でもそのような偽陽性の警告が少なく、実際にコードの品質が向上したり、プログラマとしての知識が得られるのを実感できるような警告が多いということです。実践的な例例えば、次のような関数を見てください:fn sum_squares(values: \u0026Vec\u003ci32\u003e) -\u003e i32 {    values.iter().fold(0, |acc, value| acc + value * value)}この関数は問題なく動きますが、Idiomatic Rust（慣用的なRustコード）ではありません。Clippyは、次のような親切な警告を出してくれます：Checking test001 v0.1.0 (/Users/nwiizo/git/workspace_2024/clippy/test001)warning: writing `\u0026Vec` instead of `\u0026[_]` involves a new object where a slice will do --\u003e src/main.rs:1:24  |1 | fn sum_squares(values: \u0026Vec\u003ci32\u003e) -\u003e i32 {  |                        ^^^^^^^^^ help: change this to: `\u0026[i32]`  |  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#ptr_arg  = note: `#[warn(clippy::ptr_arg)]` on by defaultこれは、\u0026Vecよりも\u0026[]のほうが汎用性が高いということを教えてくれています。Vec\u003cT\u003eは\u0026[T]に暗黙に変換されるので、わざわざVec\u003cT\u003eで宣言するということは、使える範囲を狭めるだけで何のメリットもないのです。この関数は、機能性を全く損なわずに、次のように書き直すことができます：fn sum_squares(values: \u0026[i32]) -\u003e i32 {    values.iter().fold(0, |acc, value| acc + value * value)}ミュータブル参照の場合ところで、引数の型がミュータブル参照であった場合は話が別です。\u0026mut Vec\u003cT\u003eと\u0026mut [T]ではできることが異なります。次のように、引数のベクター型のサイズを変えるような関数は、ミュータブルスライスで置き換えることはできません：fn append_square(values: \u0026mut Vec\u003ci32\u003e) {    values.push(values.iter().fold(0, |acc, value| acc + value * value));}// 使用例let mut vv = vec![1,2,3];append_square(\u0026mut vv);assert_eq!(vec![1,2,3,14], vv);このため、Clippyはミュータブル参照に対しては警告を発しません。これは、Clippyが文脈を理解して適切な判断を下せることを示す良い例です。neovim/nvim-lspconfig での設定VSCodeやCursor は知らないがこちらの設定でneovim は設定できる。  {    \"neovim/nvim-lspconfig\",    config = function()      require(\"nvchad.configs.lspconfig\").defaults()      local lspconfig = require \"lspconfig\"      lspconfig.rust_analyzer.setup {        settings = {          [\"rust-analyzer\"] = {            checkOnSave = {              command = \"clippy\",              extraArgs = { \"--all\", \"--\", \"-W\", \"clippy::all\" },            },          },        },      }      require \"configs.lspconfig\"    end,  },おわりにClippyは、より良いRustプログラムを書くことができるように導いてくれる、優しい先生のような存在です。もちろん、Clippyも完璧ではなく、時には偽陽性の検出もありますが、それは人間でも同じことです。より良いRustの書き方を学び、コードの品質を向上させ、プログラミングの知識を深められるClippyは、人間のレビュアーとは違って何度指摘されても評価が下がることのない、心強い味方となってくれます。という利点があります。ぜひ、みなさんも日々のRustプログラミングにClippyを取り入れてみてください。疑問に思ったClippyの警告は、その都度調べてみることをお勧めします。そうすることで、Rustの理解がより深まっていくはずです。Effective Rustに関しては日本語の本が出ているので興味があれば読んでみても良いと思う。Effective Rust ―Rustコードを改善し、エコシステムを最大限に活用するための35項目作者:David Drysdaleオーム社Amazon個人的に良かった記事qiita.comkenoss.github.io業務 におけるRust の記事を読んだがどちらの記事もとても良かった。","isoDate":"2024-12-27T08:00:46.000Z","dateMiliSeconds":1735286446000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"「評論家気取り」という作る人の行き着く先が怖い","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/27/144509","contentSnippet":"らーめん再遊記 第一巻より引用らーめん再遊記（１） (ビッグコミックス)作者:久部緑郎,河合単小学館Amazonはじめに技術界隈には、長年続いている不穏な現象があります。コードを書くことに情熱を注いでいた人々が、いつの間にか他人の成果物を論評することに執心するようになってしまうのです。なぜ私たちは燃え尽きてしまうのか作者:ジョナサン マレシック青土社Amazonこの現象は、特にベテランと呼ばれるエンジニアたちの間で顕著です。彼らは確かな技術力を持ち、素晴らしい成果を残してきました。しかし、彼らの多くが、創造者から評論家への転身!?を遂げつつあります。仕事の辞め方 (幻冬舎単行本)作者:鈴木おさむ幻冬舎Amazon実は私たちエンジニアは皆、いずれ評論家になる運命を背負っているのかもしれません。年を重ね、技術の第一線から遠ざかるにつれ、「作る」ことから「評論する」ことへと、その重心を少しずつシフトさせていきます。それは半ば必然であり、誰もが通る道なのでしょう。だからこそ、今、この問題について考えたいと思います。これは、いずれ評論家になるかもしれない私自身への警告であり、そして自戒の言葉でもあります。実装者から評論家へ。エンジニアの変質を、私は憂慮しています。この静かな変化について、正面から向き合ってみましょう。作る側が評論に逃げるとき「このコードは素人レベルで時代遅れです。基礎から学び直してください」「アーキテクチャへの理解が浅く、重要な議論が抜け落ちています」「技術選定の根拠が説明されておらず、設計思想が古いままです」「なぜあのライブラリやアーキテクチャに触れていないのですか。初歩的な見落としです」SNSには辛辣な評論・批評が溢れ、技術ブログには高圧的な論評が並び、カンファレンスの裏チャンネルは批判で充満しています。最も危惧すべきは、これらの評論・批評の多くが、かつては優れたコードを生み出していたはずのエンジニアたちから発せられているということです。問題なのは、これらの言説が建設的な議論を装いながら、実際には単なる批判に終始している点です。 改善案を示すわけでもなく、プルリクエストを送るわけでもなく、ただ「ダメ出し」だけを繰り返しています。これは技術的な議論ではなく、単なる自己顕示でしかありません。アイデアのつくり方作者:ジェームス W.ヤングCCCメディアハウスAmazon自意識が一流評論家になってしまったかつて天才だったエンジニアXのタイムラインには、自らを一流評論家だと思い込んだエンジニアたちが目立っています。「この実装は素人レベルです。こんなコードしか書けない人は、基礎から学び直すべきです」—そう断罪するのです。 しかし、彼ら自身は数年前の自分のコードを振り返ってみたことがあるでしょうか。あるいは最近では、実装よりもメンテナンス業務が中心になってはいないでしょうか。かつての優秀なエンジニアたちは、初学者への指摘だけでは飽き足らず、すでに実績のあるエンジニアたちにまで批判の矛先を向けています。有名OSSのプルリクエストには「この設計は時代遅れです。モダンな設計パターンを学んでから出直してください」と高圧的なコメントを残し、技術ブログに対しても「この技術選定の根拠が説明されていません」「重要な議論が抜け落ちています」と、まるで査読者のような態度で指摘を繰り返します。さらに気がかりなのは、オープンソースのイシューやプルリクエストへの不建設的な態度です。具体的な改善案を示すことなく、ただ問題点の指摘だけを行うのです。「なぜこの設計を選んだのですか？」「この実装では不十分です」という批判は、具体的な改善案を伴わない限り、何の価値も生み出せません。評論家気取りのポストで注目を集める快感に魅了されたエンジニアは、徐々に変質していきます。最初は些細な技術的指摘から始まり、「いいね」という承認欲求に駆られ、その評論は次第に厳しさを増していくのです。「なぜこの技術スタックを選んだのですか？」「なぜこの設計パターンを採用しなかったのですか？」—まるで面接官のように、実装者を追い詰める質問を投げかけ始めます。そして最も懸念すべきは、若手エンジニアの成長機会が損なわれていくという事実です。建設的なフィードバックの代わりに投げかけられる批判は、若手の挑戦する意欲を削ぎ、コミュニティへの貢献を躊躇させています。時には、自身を技術界の権威だと思い込んだエンジニアが、若手たちの真摯な努力までも批判の対象としてしまうのです。評論は衰退の始まりエンジニアが評論家めいた物言いを始めるとき、それは衰退の予兆かもしれません。ただし、適切な評論や建設的な批判は、技術の発展に不可欠な要素でもあります。レビューやフィードバックを通じて、実装の品質は向上し、よりよい設計が生まれていきます。問題なのは、創造的な貢献を伴わない批判に終始してしまうことです。創造者には創造者としての責務があります。コードに不満があるならば、改善のプルリクエストを送ることができます。ドキュメントが不十分と感じるなら、具体的な改善案を示すことができます。アーキテクチャが気に入らないのであれば、より優れた実装を示す機会が開かれています。発表内容に不満があるというのなら、自らが登壇する選択肢もあります。これは単なる理想論ではありません。優れたエンジニアたちは、常にこの原則に従って行動してきました。彼らは単なる批判ではなく、コードで語ります。問題点の指摘だけではなく、改善案の実装を示します。時には厳しい指摘も必要ですが、それは常により良い方向への具体的な提案を伴うものでなければなりません。評論と批判は、建設的な議論の土台となり得ます。しかし、それは実装による貢献があってこそ意味を持つのです。評論家として批判するだけでなく、創造者として具体的な改善を示していく—それこそが、エンジニアの進むべき道筋なのではないでしょうか。みんなのフィードバック大全作者:三村 真宗光文社Amazonなぜ評論に逃げるのか実のところ、その理由は複雑に絡み合っています。一見すると創造する意欲が失われていくように見えますが、その背景にはさまざまな要因が存在します。まず、技術の進化スピードが年々加速していることが挙げられます。かつて最先端だった技術スタックは、わずか数年で「レガシー」と呼ばれるようになります。新しい技術への追従に疲れ、自信を失っていく—そんなベテランエンジニアの姿を、私たちは目にしてきました。また、組織の中での役割の変化も大きな要因となります。マネジメントやアーキテクトの立場になると、直接コードを書く機会が減っていきます。それは自然なキャリアパスかもしれませんが、同時に「作る」喜びから遠ざかることも意味します。さらに、以前の自分を超えられないという焦りもあるでしょう。若かりし頃に作り上げた素晴らしいプロダクトやライブラリ。その成功体験が重荷となり、新しいチャレンジを躊躇させることもあります。過去の栄光に縛られ、新たな失敗を恐れる—そんな心理が、評論という安全な場所への逃避を促します。そして、評論には誘惑があります。技術ブログへの評論記事は数時間で書け、発表資料への批判は数分で完結し、SNSなら数行のポストで事足ります。実装を伴う苦労も、メンテナンスの責任も、失敗のリスクも必要ありません。最も注意すべきは、その行為が「いいね」という即時の報酬と、表面的な自己肯定感をもたらすことです。賢明な分析家として認められ、技術の識者として扱われる。この心地よさが、さらなる評論への逃避を促していきます。他者への批判で得られる一時的な優越感は、しかし、本当の自己肯定感とは異なります。 建設的な創造による達成感こそが、エンジニアの誇りとなるべきものです。時には、組織の文化や環境も影響します。過度な品質要求や、失敗を許容しない雰囲気は、エンジニアを萎縮させ、批評家的な立場に追いやってしまうことがあります。新しいことへの挑戦よりも、既存のものを批評する方が「安全」だと感じてしまうのです。この悪循環は、技術コミュニティ全体に影響を及ぼします。建設的な議論が減少し、若手の挑戦する意欲が失われ、コミュニティの分断が進んでいきます。評論は容易でも、実際の改善は誰も行わない—そんな状況に陥っているのです。しかし、これは決して避けられない運命ではありません。技術の変化を恐れず、小さな一歩から始める勇気を持つこと。過去の成功や失敗にとらわれすぎず、新しい挑戦を続けること。そして何より、評論家としての安易な満足に甘んじないこと。それが、創造者としての道を歩み続けるための鍵となるのではないでしょうか。批評の教室　──チョウのように読み、ハチのように書く (ちくま新書)作者:北村紗衣筑摩書房Amazon作る側の矜持エンジニアの本質的価値は、創造する能力にあります。 しかし、それは建設的な評論の価値を否定するものではありません。むしろ、創造と評論のバランスを保つことこそが、真のエンジニアとしての成熟を示すのかもしれません。不満な実装を見つけたのなら、より良いコードで示していきましょう。しかし、それは時として現実的ではないこともあります。そんなとき、具体的で建設的で受け入れやすいフィードバックは、それ自体が価値ある貢献となり得ます。資料に物足りなさを感じたのなら、自らより良い資料を書いていきましょう。ただし、すべての領域で自ら書き直すことは不可能です。そこでは、経験に基づいた示唆に富む指摘が、コミュニティの発展を支えることになります。エンジニアの成長は、実装による具体的な貢献を通じて実現されます。しかし、それは単独の作業ではありません。建設的なフィードバックの交換、経験の共有、そして時には適切な批評—これらの相互作用が、より良い実装を生み出す土台となります。重要なのは、創造と評論の適切なバランスです。他者のコードを批判するだけでなく、具体的な改善案を示すことができます。時には成果を否定したくなることもあるでしょうが、それを建設的なフィードバックへと昇華させることが大切です。また、自身の実装経験に基づいた説得力のある指摘は、コミュニティの発展に大きく寄与します。特に若手エンジニアに対しては、その成長を支援する温かい指摘を心がけたいものです。SNSでの浅薄な承認に価値を見出すのではなく、実装と建設的な評論の両輪で、技術コミュニティの発展に貢献していきましょう。それこそが、経験を積んだエンジニアとしての責務なのではないでしょうか。創造の喜びを忘れず、同時に適切な評論の価値も理解する—その両方を備えることで、私たちは真のエンジニアとしての成長を続けることができるのです。そして、それこそが技術コミュニティ全体の発展につながっていくはずです。批評理論を学ぶ人のために世界思想社Amazonおわりに「この文章自体も、評論ではないでしょうか」—そんな声が聞こえてきそうです。その通りです。私たちは、いずれ評論家になる運命から完全に逃れることはできないのかもしれません。年を重ねていったり、第一線を離れていく中で、評論的な視点は自然と身についていきます。それは、ある意味で技術者としての成熟の一面なのかもしれません。しかし、それでも私たちには選択の余地があります。評論に溺れるのか、それとも最後まで創造を続けるのか。私は後者を選びたいと思います。だからこそ、この文章を書き終えたら、すぐにコードを書きます。 プルリクエストを送り、ドキュメントを改善します。たとえ疲れてしまって楽な評論的な視点を持ったとしても、それを建設的な創造へと昇華させる努力を続けていきます。エンジニアは、創造することで価値を示せます。評論だけでは、成長は望めません。私たちは、作ることで命をつなぎます。 評論家という名の死に屈することなく。ついでにGitHubでもフォローしてくれ⋯github.com","isoDate":"2024-12-27T05:45:09.000Z","dateMiliSeconds":1735278309000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"2024年 俺が愛した本たち 非技術書編(物語を除く)","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/25/084801","contentSnippet":"この記事は、3-shake Advent Calendar 2024 6日目のエントリ記事です。はじめにこんにちは、nwiizoです。2024年も終わりに近づいています。毎年恒例となった年末の読書振り返りの時期が来ました。今年はいつも以上に多くの本を読みましたが、その中でも技術書以外の本との出会いが、私の世界を大きく広げてくれました。哲学書、ビジネス書、社会科学書など、多岐にわたるジャンルの本に触れることで、新しい視点や考え方を学ぶことができました。なお、今回は物語やノンフィクションについては別の機会に譲り、主にビジネスや思考に関する本を中心にご紹介させていただきます。一見エンジニアリングとは関係のない本の中に、日々の仕事や課題解決に活かせるヒントが数多く隠れていることに気づかされた一年でもありました。本を読むことは知識を得るだけでなく、物事を多角的に捉える力を育んでくれます。様々な分野の本に触れることで、自分の思考の幅が広がり、新しいアイデアや解決策が浮かぶようになってきたように感じています。...とここまで偉そうに書きましたが、実際のところ私は「へぇ～、そうなんだ」とか「なるほど、そういう考え方もあるのか」くらいの気持ちで本を読んでいます。この記事では、2024年に私の心に深く刻まれた非技術書をご紹介したいと思います。これらの本との出会いが、読者の皆さんの新たな読書体験のきっかけになれば幸いです。はじめに昨年以前に紹介した本BIG THINGS　どデカいことを成し遂げたヤツらはなにをしたのか？High Conflict よい対立 悪い対立 世界を二極化させないために「怠惰」なんて存在しない 終わりなき生産性競争から抜け出すための幸福論THINK BIGGER 「最高の発想」を生む方法「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策イシューからはじめよ［改訂版］――知的生産の「シンプルな本質」会って、話すこと。――自分のことはしゃべらない。相手のことも聞き出さない。人生が変わるシンプルな会話術勘違いが人を動かす――教養としての行動経済学入門おわりに昨年以前に紹介した本syu-m-5151.hatenablog.comsyu-m-5151.hatenablog.comsyu-m-5151.hatenablog.comsyu-m-5151.hatenablog.comBIG THINGS　どデカいことを成し遂げたヤツらはなにをしたのか？世間を賑わせたメガプロジェクトの成功と失敗について掘り下げた本です。何が面白いって、メガプロジェクトというのはほぼ確実に上手くいかないのです。予算はオーバーし、納期は遅れ、最後には利益も出ない。しかも規模が大きいだけに、失敗のインパクトも半端ない。でも、そんな中でもたまに劇的に成功するプロジェクトがある。本書は、その差は一体どこにあるのかを探っています。著者が紹介する成功への要因は意外とシンプルです。「ゆっくり考え、すばやく動く」という原則や、「レゴを使ってつくる」という具体的な可視化の手法、「マスタービルダーを雇う（専門家を頼る）」といった実践的なアプローチが示されています。実は、この本の面白さは二重構造になっています。壮大なプロジェクトの成功と失敗の物語として読むと純粋に面白いのですが、自分が経験したことがあるプロジェクトに重ねて読むと...（ちょっと考え込む）まあ、そこは各自の想像にお任せします。特に印象的だったのは、大規模プロジェクトの教訓が、実は小規模なプロジェクトにも当てはまるという指摘です。例えば「小さく試し、成功したら拡大する」というアプローチは、ビジネスからアート、果ては生物の進化まで、不確実性と向き合うあらゆる分野で見られる原則なんですよね。何か新しいことに挑戦しようと考えている人には、特におすすめの一冊です。ただし、現在進行形でプロジェクトの真っ只中にいる人は、読むタイミングを少し考えた方がいいかもしれません。なんてったって、成功率0.5%という現実を突きつけられますからね。BIG THINGS　どデカいことを成し遂げたヤツらはなにをしたのか？作者:ベント・フリウビヤ,ダン・ガードナーサンマーク出版AmazonHigh Conflict よい対立 悪い対立 世界を二極化させないために対立には2つの種類があるということを、この本は教えてくれます。健全な対立は、私たちの成長を促し、相互理解と向上につながります。一方で、不健全な対立（ハイコンフリクト）は、「私たち対彼ら」という二項対立に陥り、問題の本質とは関係のない揚げ足取りや感情的な対立を引き起こします。読んでいて特に対立は感情の問題ではなく、構図の問題だという指摘が印象に残りました。私たちは「相手の感情を変えなければ」と思いがちですが、実は解決すべきは対立という構造そのものなんですね。本書が提案する解決策も興味深いものでした。従来の「逃げる」「戦う」「我慢する」という3つの方法ではなく、第四の道を示してくれます。それは、最終的な意見の一致を目指すのではなく、お互いの話に真摯に耳を傾けること。意見は違っていても、自分の話をちゃんと聞いてもらえたと全員が感じられれば、それが健全な対話への第一歩になるというわけです。読んでいて「よい対立」というのは、実は「よい対話」のことなのかもしれないと思いました。相手と自分の違いを楽しみながら、お互いの考えを知ろうとする姿勢。それが結果的に、建設的な関係性を築くヒントになるのではないでしょうか。ダイアローグ 価値を生み出す組織に変わる対話の技術作者:熊平美香ディスカヴァー・トゥエンティワンAmazonただし、これは理想論に聞こえるかもしれません。実際の現場では、感情的になったり、相手の話を遮ってしまったりすることは日常茶飯事です。でも、だからこそ、この本が教えてくれる対立の構造を理解し、より良い対話を目指すヒントは、とても価値があると感じました。High Conflict よい対立 悪い対立 世界を二極化させないために作者:アマンダ・リプリーディスカヴァー・トゥエンティワンAmazon「怠惰」なんて存在しない 終わりなき生産性競争から抜け出すための幸福論「休むこと」に罪悪感を覚える社会の呪縛について、深い洞察を投げかける一冊です。著者は、「怠惰は悪である」という私たちの思い込みが、実は資本主義社会が生み出した幻想だと指摘します。人の価値は生産性では測れないという当たり前だけど忘れがちな事実です。「もっとできるはずだ」「自分の限界を信じるな」といった私たちが \"真実\" だと思い込んでいる考えが、実は \"ウソ\" かもしれないと思わされます。働くということ　「能力主義」を超えて (集英社新書)作者:勅使川原真衣集英社Amazon特に印象的だったのは、休息は \"サボり\" ではなく、むしろ脳を活性化させる大切な時間だという指摘です。何もしていないように見える時間こそ、実は新しいアイデアが生まれる瞬間だったりします。実はこれは、近年増加している燃え尽き症候群の問題とも深く関係しています。休むことを後ろめたく感じ、常に生産的でなければならないというプレッシャーは、私たちのメンタルヘルスに大きな影響を与えているのです。心療内科医が教える本当の休み方作者:鈴木 裕介アスコムAmazonこれは昨年話題になった『なぜ私たちは燃え尽きてしまうのか』という本でも指摘されていました。バーンアウトは単なる個人の弱さの問題ではなく、仕事が私たちのアイデンティティそのものになってしまっているという、現代社会の構造的な問題なのだと。なぜ私たちは燃え尽きてしまうのか作者:ジョナサン マレシック青土社Amazon実は私も、「もっと頑張れるはずだ」と自分を追い込むタイプでした。でも、そんな生き方って本当に正しいのかな？と考えるきっかけをくれた本です。生産性や成果だけが人生の価値を決めるわけじゃない。この当たり前の事実に、改めて気づかされました。この本は、急がなくていい、そんなに頑張らなくていいと、優しく語りかけてくれます。そして、それは決して「怠けていい」という意味ではなく、むしろ自分らしく、人間らしく生きるための大切な気づきなのだと教えてくれるのです。「怠惰」なんて存在しない 終わりなき生産性競争から抜け出すための幸福論作者:デヴォン・プライスディスカヴァー・トゥエンティワンAmazonTHINK BIGGER 「最高の発想」を生む方法この本は、私たちの「創造性」に対する多くの思い込みを覆してくれる一冊です。「天才のひらめき」という美しい物語は、実は幻想かもしれないという衝撃的な指摘から始まります。著者によれば、イノベーションの本質は「新しいアイデアを無から生み出すこと」ではなく、「既存のアイデアを新しく組み合わせること」なのだそうです。例えば、ピカソが天才的なアーティストとされるのは、同時代の画家マティスとアフリカのビリ人による彫像を巧みに組み合わせて、キュビスムという新しい芸術様式を生み出したからなんですね。この点について、私は広告界の巨人ジェームス・W・ヤングの『アイデアのつくり方』（1940年）から学びました。ヤングは「新しいアイデアとは、既存の要素の新しい組み合わせ以外の何物でもない」と述べています。そして私は、その組み合わせを見つけるには、事物の関連性を見つけ、組み合わせを試行錯誤することが重要だと考えています。アイデアのつくり方作者:ジェームス W.ヤングCCCメディアハウスAmazon特に印象的だったのは、私たちが「創造性を高める」と信じている方法の多くが、実は科学的な根拠に欠けているという指摘です。ブレインストーミングの効果は研究で否定されているとか、オフィス空間を奇抜にしても創造性は上がらないとか。むしろ大切なのは、様々な素材を一つ一つ心の解像度を上げて捉え、向き合うこと。そして、それらの関係性を探り出すことなのです。著者は、アイデアの創造プロセスについて興味深い観察を示してくれます。何気ない見聞き、例えば電車に乗っているとき、風呂に入っているとき、トイレのときなど、ふとした瞬間にアイデアが心の中で飛び込んでくる。でも、これは実は偶然ではなく、それまでの地道な素材集めと向き合いの結果なんだそうです。THINK BIGGER 「最高の発想」を生む方法：コロンビア大学ビジネススクール特別講義 (NewsPicksパブリッシング)作者:シーナ・アイエンガーニューズピックスAmazonこの本は、世の中に溢れている「創造性神話」を丁寧に解きほぐしながら、誰もが実践できる方法論を示してくれます。アイデアを生むには、まず問題を無意識の中で整理し、忘れたような状態にすることも大切なんですね。そして何より、「天才のひらめき」を待つのではなく、地道に知識を蓄え、既存のアイデアを組み合わせていく。そんな着実なアプローチこそが、実は最も創造的な方法なのかもしれません。「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策コミュニケーションの失敗の原因を、認知科学の視点から解き明かしてくれる一冊です。著者は、「話せばわかる」という私たちの思い込みが、実は幻想かもしれないと指摘します。人は自分の都合のいいように誤解する生き物だという指摘です。これは、相手が「悪意を持って誤解している」わけではなく、むしろ 私たち一人一人が持つ「知識や思考の枠組み（スキーマ）」が異なるために起こる自然な現象なんだそうです。例えば、同じ「ネコ」という言葉を聞いても、人によって思い浮かべる映像は全く違います。これと同じように、ビジネスの現場でも、私たちは知らず知らずのうちに、自分のスキーマを通して相手の言葉を解釈しているのです。著者は、コミュニケーションの達人になるためのヒントも示してくれます。ポイントは、「失敗を成長の糧にする」「説明の手間を惜しまない」「相手をコントロールしようとしない」「聞く耳を持つ」といった心構えです。これは決して「相手に合わせろ」という話ではなく、むしろお互いの違いを認識した上で、どう理解し合えるかを考えることの大切さを教えてくれます。この本は、日々のコミュニケーションで「なんでわかってくれないんだろう」と悩む私に、とても実践的なヒントを与えてくれました。結局のところ、完璧な伝達は不可能で、むしろ誤解や聞き違いを前提に、どうコミュニケーションを取るかを考えることが大切なのかもしれません。「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策作者:今井むつみ日経BPAmazonイシューからはじめよ［改訂版］――知的生産の「シンプルな本質」この本は私にとって特別な一冊です。「今この局面でケリをつけるべき問題」を見極めることの大切さを教えてくれた、まさにバイブルと呼べる存在でした。今回の読書振り返りを書くにあたっても、「何を伝えるべきか」を考える際の指針となってくれています。本書の核心は、「真に価値のある仕事は、イシューの設定から始まる」というものです。世の中には問題が山積みですが、その中で「今、本当に答えを出すべき」かつ「答えを出す手段がある」問題は、実はごくわずかです。優れた知的生産には分野を超えて共通の手法があると本書は教えてくれます。ビジネスでも、研究でも、アートでも、本質的な問題を見極めることから始めるという原則は変わりません。これは『熟達論―人はいつまでも学び、成長できる』でも同様の指摘がされています。分野は違えど、真に優れた実践者たちには共通のパターンがあるのです。それは問題の本質を見抜き、そこに向けて地道な努力を重ねる姿勢です。両書を読み進めるうちに、自分の中で「イシュー」を見極めることと「熟達」することの間に深いつながりがあることを感じました。熟達論―人はいつまでも学び、成長できる―作者:為末大新潮社Amazonこの気づきは私の学びの姿勢を大きく変えました。以前は目の前の課題に対して「とにかくやってみる」というアプローチでしたが、今は必ず立ち止まって「本当のイシューは何か」を考えるようになりました。そして、そのイシューに向き合う中で、自分自身の熟達度も少しずつ上がっていくような気がしています。また、本書では「課題解決の2つの型」について深く掘り下げています。ギャップフィル型（あるべき姿が明確な場合）と、ビジョン設定型（そもそもあるべき姿を見極める必要がある場合）という分類は、単なる理論的な整理ではありません。これは実践の場で直面する様々な課題に対して、どのようなアプローチを取るべきかを示す羅針盤となってくれます。多くの失敗は、この2つの型を取り違えることから始まるのかもしれません。今年の読書でも、この本で学んだ「イシューからはじめる」という考え方が、本の選び方や読み方に大きな影響を与えています。一見バラバラに見える本たちも、実は私なりの「イシュー」に基づいて選んでいたことに、この振り返りを書きながら気づきました。それぞれの本が、異なる角度から私の中の「イシュー」に光を当ててくれていたのです。イシューからはじめよ［改訂版］――知的生産の「シンプルな本質」作者:安宅和人英治出版Amazon会って、話すこと。――自分のことはしゃべらない。相手のことも聞き出さない。人生が変わるシンプルな会話術この本との出会いは、私の会話に対する考え方を大きく変えてくれました。「人は他人の話に興味がない」という荒々しいけれど正直な前提から始まり、そこから真摯に「ではなぜ人は会って話すのか」を探っていく展開に引き込まれました。本書で最も印象的だったのは、「外にあるものを一緒に見つめる」という会話の本質についての洞察です。自分のことを話したり、相手のことを聞き出したりする必要はない。むしろ、お互いの外にあるものに目を向け、新しい風景を一緒に発見することが、会話の醍醐味なのだと。実は最近、NON STYLE 石田さんの「答え合わせ」や令和ロマン・髙比良くるまさんの「漫才過剰考察」にハマっていて、面白い掛け合いの「仕組み」についてかなり考えていました。答え合わせ（マガジンハウス新書）作者:石田明マガジンハウスAmazonでも本書を読んで、会話の本質は必ずしもそういった技術的な部分だけではないことに気づかされました。巧みなツッコミやテンポのいい掛け合いも素晴らしいけれど、二人で同じ風景を見つめて「へぇ」と言い合えるような静かな会話にも、また違った味わいがあるんですね。漫才過剰考察作者:令和ロマン・髙比良くるま辰巳出版Amazonこれまで私は「相手に興味を持ってもらえるような話をしなきゃ」「相手の話をもっと引き出さなきゃ」と、どこか力んでいた気がします。でも、本書はそんな会話の構えをすべて取り払ってくれました。漫才のようにオチを付ける必要もない。ツッコミも不要。むしろ、ボケにボケを重ねて「今なんの話してたっけ？」となる方が、会話として自然なのかもしれません。会話は決して「相手を理解する」「自分を理解してもらう」ためのものではない。そう割り切ることで、むしろ自然な会話が生まれる。この逆説的な知恵が、私の日々の会話をより楽しいものにしてくれています。会って、話すこと。――自分のことはしゃべらない。相手のことも聞き出さない。人生が変わるシンプルな会話術作者:田中 泰延ダイヤモンド社Amazon勘違いが人を動かす――教養としての行動経済学入門人はとても愚か。「人は論理や情熱ではなく、認知バイアスによって動く」という衝撃的な視点を示してくれる一冊です。その象徴的な例が、男性用トイレの小便器にハエのマークを描くと飛び散りが激減する「ハウスフライ効果」。私たちは意外なほど、こういった「勘違い」によって行動が変わってしまう生き物なんですね。本書は、普段の生活で遭遇する様々な認知バイアスについて、豊富な事例とともに解説してくれます。例えば、カジノが現金ではなくチップを使う理由。実は、チップを使うと現金を使う時より負けた時の痛みを感じにくくなるそうです。さらにカーペットを長めにして歩くスペードを遅くさせたり、出口への最短ルートをわかりにくくしたり...。私たちの行動を操る仕掛けが、至る所に張り巡らされているんです。特に印象的だったのは、「予期的後悔」についての指摘です。私たちは「将来後悔するかもしれない」という不安から、決断を先送りにしがちです。でも実は、人は将来の感情を過大評価する傾向があり、実際の後悔は想像よりもずっと小さいものだとか。この点については、『変化を嫌う人を動かす』という本でも深く掘り下げられています。人が変化を受け入れられない理由として「惰性」「労力」「感情」「心理的反発」という4つの要因があるそうです。両書を併せて読むことで、人がなぜ現状維持バイアスに縛られやすいのか、より立体的に理解できました。「変化を嫌う人」を動かす:魅力的な提案が受け入れられない4つの理由作者:ロレン・ノードグレン,デイヴィッド・ションタル,船木 謙一(監修)草思社Amazon本書を読んで、自分の行動の多くが実は「論理的な判断」ではなく「認知バイアス」によって左右されていることを実感しました。この気づきは、自分の意思決定を見直すきっかけになると同時に、他者の行動をより深く理解することにもつながります。賢明なのは、これらのバイアスと戦うことではなく、その存在を認識した上で、うまく付き合っていくことなのかもしれません。勘違いが人を動かす――教養としての行動経済学入門作者:エヴァ・ファン・デン・ブルック,ティム・デン・ハイヤーダイヤモンド社Amazonおわりに今年の読書を振り返ってみると、一つの大きなテーマが浮かび上がってきました。それは「人はいかに自分の思い込みに縛られているか」ということです。私たちは普段、意識せずに様々な思い込みの中で生活しています。でも、新しい本と出会うたびに、そんな「当たり前」が少しずつ揺さぶられていくような体験をしました。「へぇ～、そうなんだ」という素直な驚きから始まった読書でしたが、振り返ってみると、それぞれの本が不思議と響き合って、より深い気づきをもたらしてくれたように思います。理論的な本を読んでは実践的な本で確認し、個人的な視点の本を読んでは社会的な視点の本で補完する。そんな読書の往復運動の中で、自分の視野が少しずつ広がっていくのを感じました。来年も、このように自分の「思い込み」を優しく解きほぐしてくれるような本との出会いを楽しみにしています。そして、その体験をまた皆さんと共有できればと思います。最後まで読んでいただき、ありがとうございました。","isoDate":"2024-12-24T23:48:01.000Z","dateMiliSeconds":1735084081000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"2024年 俺が愛した本たち 技術書編","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/23/174750","contentSnippet":"この記事は、3-shake Advent Calendar 2024 24日目のエントリ記事です。はじめにこんにちは、nwiizoです。2024年も残りわずかとなりました。年の瀬に差し掛かるこの時期、1年の歩みを振り返り、時の流れを見つめ直すことは、私にとって特別な意味を持っています。今年は特に、技術書との関わり方に大きな変化がありました。本を紹介する投稿する中で、技術書のみならず、さまざまな分野の書籍を読む機会が大幅に増えました。私の書斎は、いつの間にか技術書のデータセンターと化しました。サーバーラックの代わりに本棚が整然と並び、それぞれの棚には未読の本という名のサーバーがぎっしりと配置されています。これらの「サーバー」は、24時間365日、知識というバックグラウンドプロセスを静かに実行し続けています。既にメモリの使用率は常に100%ですが、まだ、クラッシュすることはありません。クラッシュしたら次の年はこの文章を読むことができません。特に今年は、技術書との向き合い方を見つめ直した1年でした。これまでのように「量」を追い求めるのではなく、一冊一冊を深く理解し、質を重視することに注力しました。技術書は単なる情報の集合体ではなく、先人たちの経験や洞察が凝縮された知恵の結晶です。その知恵を丁寧に咀嚼し、自分の中に取り込む過程が、エンジニアとしての成長に直結することを改めて実感しました。この記事では、2024年に私が出会い、心を揺さぶられた技術書たちを厳選してご紹介します。これらの書籍が、読者の皆様に新たな発見と学びをもたらすきっかけになれば幸いです。はじめに昨年以前に紹介した本2024年に読んでよかった技術書Platform Engineering on KubernetesPlatform EngineeringContinuous DeploymentCloud Observability in ActionLearning OpenTelemetryBecoming SREFundamentals of Data EngineeringTidy First?ソフトウェア開発現場の「失敗」集めてみた。42の失敗事例で学ぶチーム開発のうまい進めかたプログラミングRust 第2版Effective Rustバックエンドエンジニアを目指す人のためのRustReal World HTTP 第3版【改訂新版】システム障害対応の教科書GitHub CI/CD実践ガイドおわりに昨年以前に紹介した本syu-m-5151.hatenablog.comsyu-m-5151.hatenablog.comsyu-m-5151.hatenablog.comsyu-m-5151.hatenablog.com2024年に読んでよかった技術書今年も、私の知識データベースは絶え間なく更新され続けました。読書から得た知識は、ソフトウェアエンジニアとしての実務という名のプロダクション環境で厳密にテストされ、その成果は、いくつかの技術イベントでの登壇という形でデプロイされました。幸いにも、これまでクリティカルな障害が発生したことはありません。私の脳内APIは、多くの技術書から寄せられるリクエストを処理し続けています。レスポンスタイムは決して速いとは言えませんが、スループットは着実に向上しています。そして以下では、2024年に私の知識基盤に大きなアップデートをもたらした技術書を紹介します。これらの書籍は、私に新しい視点やスキルを与え、成長の助けとなりました。speakerdeck.comPlatform Engineering on Kubernetes「Platform Engineering on Kubernetes」は、クラウドネイティブ時代のプラットフォームエンジニアリングの本質と実践を包括的に解説した一冊です。本書は、単なるKubernetesの解説書を超えて、現代のソフトウェア開発組織が直面する課題とその解決策を体系的に示しています。Platform Engineering on Kubernetes (English Edition)作者:Salatino, MauricioManningAmazon本書の核心は、「なぜKubernetes上にプラットフォームを構築する必要があるのか」という根本的な問いに対する答えを提示している点です。著者は、複数のチームが関わり、複数のクラウドプロバイダーへのデプロイを行い、異なるスタックを扱う組織では、Kubernetesの導入だけでは不十分であることを説き、プラットフォームエンジニアリングによってこれらの課題を技術的・組織的に解決する方法を示しています。特に印象的なのは、プラットフォームチームと開発チームの協調に関する著者の洞察です。プラットフォームは単なる技術的な基盤ではなく、開発者の生産性を最大化し、ビジネス価値の迅速な提供を可能にする戦略的な資産として位置づけられています。これは、DevOpsの理想をクラウドネイティブ時代に実現するための具体的なアプローチと言えます。本書は、概念的な解説に留まらず、実践的なステップバイステップのガイドも提供しています。カンファレンスアプリケーションというサンプルを通じて、プラットフォームの設計から実装、運用までを一貫して学ぶことができます。これにより、読者は理論と実践の両面から、プラットフォームエンジニアリングの本質を理解できます。また、本書はCrossplane、ArgoCD、Dapr、OpenFeatureなど、現代のクラウドネイティブツールの活用法も詳しく解説しています。これらのツールを適切に組み合わせることで、開発者体験の向上とインフラストラクチャの効率化を両立できることが示されています。この本を読み進める中で、プラットフォームエンジニアリングが単なる技術的な取り組みを超えて、組織全体のデジタルトランスフォーメーションを推進する原動力となり得ることを実感しました。著者の提示する知見は、エンジニアリング組織の次なるステージを考える上で、貴重な指針となるでしょう。「Platform Engineering on Kubernetes」では、プラットフォームエンジニアリングの技術的側面について深く解説されています。しかし、内部開発者向けのプラットフォームも一つのプロダクトとして捉え、その価値提供を最適化していく視点も重要です。そこで、以下の書籍との併読をお勧めします。プロダクトマネジメントのすべて 事業戦略・IT開発・UXデザイン・マーケティングからチーム・組織運営まで作者:及川 卓也,小城 久美子,曽根原 春樹翔泳社Amazon「プロダクトマネジメントのすべて」は、プロダクトの企画から運用、改善までを包括的に解説した決定版です。本書を通じて、プラットフォームを一つのプロダクトとして捉え、ユーザーである開発者の体験を最適化していくための方法論を学ぶことができます。さらに、プラットフォームチームがどのようにステークホルダーと協働し、組織全体の価値を最大化していくかについても、実践的な知見を得ることができます。両書を組み合わせることで、技術とプロダクトマネジメントの両面から、より効果的なプラットフォームエンジニアリングの実践が可能になるでしょう。Platform Engineering「Platform Engineering: A Guide for Technical, Product, and People Leaders」は、現場での実践知を出発点として、プラットフォームエンジニアリングの本質に迫る実践的なガイドです。技術リーダーから上級管理職まで向けた幅広い読者層に向けて書かれており、個人的にはもう少しだけ広げて開発者やプラットフォームを実際に使う側も読んでも学びのある本だと感じました。Platform Engineering: A Guide for Technical, Product, and People Leaders (English Edition)作者:Fournier, Camille,Nowland, IanO'Reilly MediaAmazon「Platform Engineering on Kubernetes」がKubernetesを基盤とした技術的な実装と運用に重点を置いているのに対し、本書はプラットフォームエンジニアリングをより広い文脈で捉え、組織的・人的側面にも深く踏み込んでいます。例えば、プラットフォームチームの組織的な位置づけ、ステークホルダーとの関係構築、プラットフォーム提供者と利用者の協力関係の構築など、「Platform Engineering on Kubernetes」では詳しく触れられていない領域をカバーしています。特に注目すべきは、本書がプラットフォームの成功を技術的な完成度だけでなく、組織全体への価値提供という観点から評価している点です。プラットフォームの採用を促進し、持続可能な運用を実現するためには、技術的な卓越性に加えて、組織的な課題への対応も重要であることを説いています。そのため、両書を併読することで、技術的な実装から組織的な展開まで、プラットフォームエンジニアリングの全体像を把握することができます。本書を読む前に、「Team Topologies」を一読することを強くお勧めします。「Team Topologies」は、現代のソフトウェア開発組織における効果的なチーム構造とその相互作用のパターンを提示しており、プラットフォームチームの位置づけや役割を理解する上で不可欠な知見を提供してくれます。この基礎的な理解があることで、本書で展開されるプラットフォームエンジニアリングの実践論をより深く理解することができます。チームトポロジー　価値あるソフトウェアをすばやく届ける適応型組織設計作者:マシュー・スケルトン,マニュエル・パイス日本能率協会マネジメントセンターAmazon著者の豊富な経験が凝縮された本書は、単なる表面的な手法の模倣ではなく、実際の現場での試行錯誤から導き出されたプラクティス、そしてその背後にある根本的な原理と思想を探求しています。それが現代のソフトウェア開発組織においていかに革新的な価値を生み出すかを浮き彫りにしている点が特徴的です。本書の真価は、プラットフォームエンジニアリングを単なる技術的な手法の集合としてではなく、日々の実践から得られた知見を体系化し、組織の進化と持続的な成長を促す戦略的な思考基盤として捉えている点にあります。技術的な実装の詳細よりも、組織が現場の文脈に根ざした実践を重ね、そこからプラクティスを抽出し、最終的にプラットフォームエンジニアリングの本質的な原則を理解して創造的に応用していく方法論に重点が置かれています。技術的な側面、特にCloud Nativeな実装に興味がある方には、「Platform Engineering on Kubernetes」がおすすめです。こちらの書籍では、Kubernetesを基盤としたプラットフォームエンジニアリングの実践的なアプローチが詳細に解説されています。両書を併読することで、プラットフォームエンジニアリングの組織的側面と技術的側面の両方を深く理解することができ、より包括的な知識を得ることができるでしょう。本書は、プラットフォームエンジニアリングの現場で直面する本質的な難しさを率直に語っています。具体的には、「技術的に面白いから作る」のではなく現場で真に必要とされるものを見極めて提供するという価値提供の本質、計画の難しさを認識しつつも現場の文脈に応じて適切に実行するという実践知、そして組織の重要なシステムを支える責任を全うするための運用の成熟という現場力の醸成といった課題を挙げています。これらの課題に対して、本書は原則に基づきながらも現場の実態に即した解決の道筋を示しています。最後に、読者として強く感じたのは、プラットフォームエンジニアリングが単なる技術的な課題ではなく、組織的な取り組みとして捉える必要があるという点です。特に、チームの持続可能性とユーザー満足度の両立という観点から、著者の提案する実践的なアプローチは非常に価値があります。本書で提示されているプラクティスは、理想的ではありますが現実的な目標として設定されており、段階的な改善のためのロードマップとしても機能します。特に重要なのは、組織の規模や成熟度に応じて適切なアプローチを選択し、継続的に改善を進めていく姿勢だと考えています。Continuous Deployment「Continuous Deployment: Enable Faster Feedback, Safer Releases, and More Reliable Software 」は、継続的デプロイメントの実践に焦点を当てた包括的なガイドです。継続的デプロイメントは、ソフトウェアパイプラインを完全に自動化し、手動介入を必要としない手法です。この方法により、クオリティーゲートを通過したすべてのコードコミットが自動的に本番環境にデプロイされます。Continuous Deployment: Enable Faster Feedback, Safer Releases, and More Reliable Software (English Edition)作者:Servile, ValentinaO'Reilly MediaAmazon本書の理解をより深めるためには、「Grokking Continuous Delivery」との併読をお勧めします。この本は、継続的デリバリーの基本概念から実践的な実装まで、体系的に解説しています。特に、継続的デプロイメントへの段階的な移行プロセスや、組織文化の変革について、実践的な知見を提供してくれます。両書を読み進めることで、継続的デプロイメントの技術的側面と組織的側面の両方を包括的に理解することができます。Grokking Continuous Delivery (English Edition)作者:Wilson, ChristieManningAmazonこちらの本は日本語版がリリースされています。入門 継続的デリバリー ―テストからリリースまでを安全に自動化するソフトウェアデリバリーのプロセス作者:Christie Wilsonオーム社Amazon本書は、単なる技術的な実装の解説に留まらず、プラットフォームエンジニアリングと開発プロセス全体を変革する可能性について深く掘り下げています。特に、フィーチャーフラグ、カナリーリリース、A/Bテストなどの重要な概念と、それらの実践的な適用方法について詳細な洞察を提供しています。継続的デプロイメントの価値は、ソフトウェア開発の特性と人間の性質を理解することで明確になります。人間は反復作業を得意としませんが、コンピューターシステムはこの種の作業に適しています。継続的デプロイメントは、人間と機械の特性の違いを活かし、相互補完的に活用します。コード変更から本番環境へのデプロイまでを完全に自動化することで、開発者は創造的な問題解決に注力でき、反復的なタスクはシステムに任せることができます。結果として、ソフトウェア開発プロセス全体の効率が向上し、人的ミスのリスクも減少します。本書は、技術的側面だけでなく、組織文化やチーム間の協力体制についても掘り下げています。また、継続的デプロイメントがもたらすソフトウェアのリリースサイクルの短縮や、ユーザーへのフィードバックループの最小化についても解説しています。同時に、コードの品質管理やテスト戦略により高い要求を課すことの重要性も強調しています。強固な自動テスト、モニタリング、迅速なロールバック機能など、継続的デプロイメントを成功させるために不可欠な安全策についても説明しています。実践的な見地からも、本書は開発者が直面する現実的な課題に対する具体的な解決策を提供しています。各章は理論的な基礎から始まり、実際の適用例、そして起こりうる問題とその対処法まで、包括的に解説しています。特に、実際の組織がどのように継続的デプロイメントを導入し、成功を収めているかについての事例研究は、実務に直接活かせる貴重な知見となっています。本書を通じて、継続的デプロイメントが単なる技術的なツールではなく、組織全体の開発文化を変革し、ソフトウェア品質を向上させるための包括的なアプローチであることが理解できます。その実践は、開発効率の向上、リリース品質の改善、そして最終的には顧客満足度の向上につながります。Cloud Observability in Action「Cloud Observability in Action」は、クラウドネイティブ時代におけるオブザーバビリティの概念と実践方法を包括的に解説した一冊です。オブザーバビリティを投資対効果の観点から捉え、データの生成から収集、処理、可視化に至るまでのプロセス全体を俯瞰します。これは、神の視点でシステムを観察できるようになる、デジタル世界の第三の目を手に入れるようなものです。Cloud Observability in Action (English Edition)作者:Hausenblas, MichaelManningAmazonOpenTelemetry、Prometheus、Grafana、Loki、Jaegerなどのオープンソースツールを活用し、誰でも実践的な知見を時間以外の費用をかけずに得られるよう工夫されています。まるで高級な料理のレシピを、コンビニの食材だけで再現する魔法のような本です。著者の豊富な経験に基づくベストプラクティスが随所に盛り込まれ、参考URLも惜しみなく共有されています。システムの監視方法について、何百人もの先人たちが積み上げてきた叡智を一冊に凝縮したような贅沢な内容です。単なるツールの使い方の解説にとどまらず、オブザーバビリティを組織文化として定着させるためのヒントも提供されています。つまり、「システムの見える化」という名の文化革命の指南書とも言えるでしょう。本書を通じて、システムの内部状態を把握・推論する力を身につけることができます。これは、デジタルの迷宮で道に迷った開発者たちに、アリアドネの糸を提供するようなものです。得られた知見をどのように活用するかは読者次第ですが、システムと組織の継続的な進化を支える原動力として、オブザーバビリティを正しく理解し実践することができます。少なくとも、「エラーログを検索すれば何とかなる」という幻想から解放されることは間違いありません。本書は、複雑化するシステムの「見える化」を実現するための、実践的なガイドブックです。これを読まずにオブザーバビリティを始めるのは、暗闇の中でパズルを解こうとするようなものかもしれません。本稿では、各章の要点を丁寧に読み解きながら、私なりの学びと気づきをシェアしていきます。皆様にとっても、オブザーバビリティへの理解を深め、その実践への一歩を踏み出すきっかけとなれば幸いです。Learning OpenTelemetry「Learning OpenTelemetry」は、可観測性という広大な領域に対する実践的な航海図といえます。本書の最も重要な貢献は、OpenTelemetryというテクノロジーを通じて、システムの可観測性をビジネス価値へと変換する具体的な方法論を提示している点です。Learning OpenTelemetry: Setting Up and Operating a Modern Observability System (English Edition)作者:Young, Ted,Parker, AustinO'Reilly MediaAmazon本書を読む際は、オブザーバビリティに関する以下の2冊との併読をお勧めします。まず「Observability Engineering」は、可観測性の基本概念から実践的な実装まで、より広い文脈で解説しています。特に、OpenTelemetryを含む様々な可観測性ツールの位置づけや、組織における可観測性の文化醸成について、包括的な視点を提供してくれます。両書を読み進めることで、技術的な実装の詳細と、より大きな戦略的文脈の両方を理解することができます。Observability Engineering: Achieving Production Excellence (English Edition)作者:Majors, Charity,Fong-Jones, Liz,Miranda, GeorgeO'Reilly MediaAmazonまた、「入門 監視」は、システム監視の基礎から応用まで、実践的な知見を提供してくれます。監視とオブザーバビリティの関係性、メトリクスの収集と分析、アラートの設計など、日々の運用に直結する知識を学ぶことができます。入門 監視 ―モダンなモニタリングのためのデザインパターン作者:Mike JulianオライリージャパンAmazon本書の特筆すべき点は、技術的深度、組織的展開、ビジネス価値という3つの視点を統合的に扱っていることです。技術面では、OpenTelemetryの内部アーキテクチャから実装の詳細まで、体系的な解説を提供しています。特に、トレース、メトリクス、ログの統合方法や、テレメトリパイプラインの設計については、実務で即座に活用できる具体的な知見が豊富です。組織面では、可観測性の導入を単なる技術導入ではなく、組織変革として捉える視点を提供しています。特に、Deep対Wide、Code対Collection、Centralized対Decentralizedという3つの軸に基づく展開戦略は、組織の規模や成熟度に応じた柔軟なアプローチを可能にします。ビジネス面では、テレメトリデータを通じてビジネスの意思決定や改善につなげていく方法について、具体的な指針を示しています。私が実務を通じて特に共感したのは、本書の掲げる「Do no harm, break no alerts」という原則です。可観測性の向上は、既存のシステムや運用プロセスを破壊することなく、段階的に実現していくべきだという主張は、現場の実態に即した賢明なアプローチだと感じます。本書の構成も実践的です。各章は理論的な基礎から始まり、実装の詳細、そして運用上の考慮点へと展開されていきます。特に、各章末のケーススタディやベストプラクティスは、他組織の経験から学ぶ貴重な機会を提供してくれます。最後に、本書の結論部分で言及されている「可観測性の次のフロンティア」についても注目に値します。AIとの統合やテストとしての可観測性など、新しい可能性の提示は、この分野の今後の発展を考える上で重要な示唆を与えてくれます。OpenTelemetryの導入を検討している組織にとって、本書は単なる技術解説書以上の価値を持つ戦略的なガイドブックとなるでしょう。また、すでにOpenTelemetryを導入している組織にとっても、その活用方法を再考し、より高度な可観測性を実現するための有益な指針となることは間違いありません。こちらの本は日本語版がリリースされています。入門 OpenTelemetry ―現代的なオブザーバビリティシステムの構築と運用作者:Ted Young,Austin ParkerオライリージャパンAmazonBecoming SRE「Becoming SRE」は、SRE（Site Reliability Engineering）という職種に対する深い理解と実践的な洞察を提供する画期的な一冊です。本書は、個人がSREとしてのキャリアを築くための道筋と、組織がSREを導入・発展させるための戦略を包括的に解説しています。Becoming SRE: First Steps Toward Reliability for You and Your Organization (English Edition)作者:Blank-Edelman, David N.O'Reilly MediaAmazonSREに関する書籍は数多く出版されていますが、本書の特筆すべき点は、その実践に基づいた具体性と実用性にあります。特に、他のSRE関連書籍が理論や理想的なプラクティスの解説に重点を置く傾向がある中、本書は現場で直面する現実的な課題とその解決策に焦点を当てています。例えば、Googleが提唱したSREの原則やプラクティスを、規模や成熟度の異なる組織でどのように適用していくかについて、具体的なステップとアプローチを示しています。また、SREとしてのキャリアパスや、組織内でのSRE文化の醸成方法など、実務者の視点に立った実践的なアドバイスが豊富に盛り込まれています。syu-m-5151.hatenablog.com本書の価値は、SREという職種を単なる技術的な役割としてではなく、組織の文化や価値観を形作る存在として捉えている点にあります。著者のDavid Blank-Edelman氏は、長年のSREとしての経験を基に、技術とビジネスの両面からSREの本質に迫っています。本書は3つのパートで構成されています。Part Iでは、SREの基本的な概念、文化、そしてマインドセットについて解説しています。特に注目すべきは、SREが目指すべき「適切な信頼性レベル」という考え方です。100%の信頼性を追求するのではなく、ビジネスの要求と照らし合わせながら、最適な信頼性レベルを見極めることの重要性が説かれています。Part IIは、個人がSREになるための具体的なステップを示しています。技術的なスキルセットはもちろん、コミュニケーション能力、問題解決力、そして失敗から学ぶ姿勢など、SREに求められる多面的な資質について詳細に解説されています。特筆すべきは、オンコール対応やインシデント管理といった実務的なトピックについても、豊富な事例とともに具体的なアドバイスが提供されている点です。Part IIIでは、組織としてSREを導入・発展させるための戦略が展開されています。SREの成功は、個々のエンジニアの努力だけでなく、組織全体のサポートと理解が不可欠だという著者の主張は説得力があります。特に興味深いのは、SREの組織的な成熟度を5つのステージで捉えるフレームワークです。各ステージの特徴と課題、そして次のステージへの移行に必要な施策が具体的に示されています。本書が特に強調しているのは、SREにおける「文化」の重要性です。モニタリング、自動化、インシデント対応といった技術的な実践も重要ですが、それらを支える組織文化がなければ、SREは真の力を発揮できません。データ駆動の意思決定、失敗から学ぶ姿勢、部門間の協働、これらの文化的要素をどのように育んでいくかについても、深い洞察が示されています。また、本書はSREの導入と成長における現実的な課題にも正面から向き合っています。技術的な障壁はもちろん、組織の抵抗、リソースの制約、文化の変革の難しさなど、SREが直面する様々な課題に対する具体的な対処法が提示されています。総じて本書は、SREを目指す個人にとってのキャリアガイドであると同時に、組織にとってのSRE導入・発展のロードマップとして機能する実践的な指南書です。著者の豊富な経験に基づくアドバイスは、SREという未知の領域に踏み出そうとする読者にとって、信頼できる道標となるはずです。こちらの本も日本語版がリリースされています。SREをはじめよう ―個人と組織による信頼性獲得への第一歩作者:David N. Blank-EdelmanオライリージャパンAmazonFundamentals of Data Engineering「Fundamentals of Data Engineering」は、データエンジニアリングの基礎から実践までを体系的に解説した包括的な一冊です。データエンジニアリングを「raw dataを取り込み、高品質で一貫性のある情報を生成するシステムとプロセスの開発、実装、維持」と定義し、その全容を詳細に説明しています。Fundamentals of Data Engineering: Plan and Build Robust Data Systems (English Edition)作者:Reis, Joe,Housley, MattO'Reilly MediaAmazon本書は4つのパートで構成されており、Part Iではデータエンジニアリングの基礎と構成要素、Part IIではデータエンジニアリングのライフサイクルの詳細、Part IIIではセキュリティとプライバシー、そして将来の展望を扱っています。特に、データ生成からストレージ、取り込み、変換、提供までの一連のライフサイクルについて、実践的な知見が豊富に盛り込まれています。著者たちは、特定のツールや技術に依存しない原則ベースのアプローチを採用しています。これにより、急速に変化するデータ技術の世界においても、長く有効な知識を提供することに成功しています。データエンジニアは、セキュリティ、データ管理、DataOps、データアーキテクチャ、オーケストレーション、ソフトウェアエンジニアリングの交差点に位置し、これらの要素を統合的に理解し活用する必要があることが強調されています。本書の特筆すべき点は、理論と実践のバランスが絶妙なことです。データエンジニアリングの基本原則を解説しながら、実際のシステム設計や運用における具体的な課題とその解決策も提示しています。また、クラウドファーストの時代におけるデータエンジニアリングの在り方についても深い洞察が示されています。セキュリティとプライバシーに関する章では、データエンジニアリングにおけるセキュリティの重要性と、具体的な実装方法が詳細に解説されています。GDPRなどの規制への対応や、データの匿名化、アクセス制御など、現代のデータエンジニアが直面する重要な課題がカバーされています。最後に、データエンジニアリングの将来に関する章では、業界の動向と今後の展望が示されています。クラウドスケールの「データOS」の出現や、リアルタイムデータ処理と機械学習の融合など、興味深い予測が述べられています。本書は、データエンジニアリングの世界で活躍したい技術者にとって、必携の一冊となるでしょう。体系的な知識の習得と実践的なスキルの向上に大いに役立つ内容となっています。こちらの本も日本語版がリリースされています。データエンジニアリングの基礎 ―データプロジェクトで失敗しないために作者:Joe Reis,Matt HousleyオライリージャパンAmazonTidy First?「Tidy First?」は、エクストリームプログラミングの考案者であり、ソフトウェアパターンの先駆者として知られるKent Beckによる、コードの整理整頓に関する画期的な一冊です。本書は、リファクタリングの新しい考え方として「Tidying（整理整頓）」という概念を提唱し、その実践的なアプローチを示しています。Tidy First?: A Personal Exercise in Empirical Software Design (English Edition)作者:Beck, KentO'Reilly MediaAmazonリファクタリングといえば「リファクタリング 既存のコードを安全に改善する」や「レガシーコードからの脱却」ですがこのリファクタリングの考え方をより小規模で実践的なアプローチへと発展させたものと言えるでしょう。リファクタリング 既存のコードを安全に改善する（第2版）作者:ＭａｒｔｉｎＦｏｗｌｅｒオーム社Amazonレガシーコードからの脱却 ―ソフトウェアの寿命を延ばし価値を高める9つのプラクティス作者:David Scott BernsteinオライリージャパンAmazon本書の核心は、「いつ、どこで、どのようにコードを整理するべきか」という実践的な問いに対する答えを提示している点です。特に注目すべきは、Tidyingをリファクタリングの部分集合として位置づけ、より小規模で安全な改善活動として定義している点です。本書は3つのパートで構成されています。Part 1: Tydingsでは、具体的な整理整頓の手法が示されています。変数名の調整や対称性の確保、不要なコードの削除など、小規模だが効果的な改善活動が詳しく解説されています。これらは、ボーイスカウトの原則（来たときよりも美しく）とも通じる考え方です。Part 2: Managingでは、Tidyingの実践的なマネジメントについて解説されています。特に重要なのは、機能開発の直前にTidyingを行うべきという提言です。これは、料理をする前にキッチンを整理整頓するのと同じように、本題に取り組む前に作業環境を整えることの重要性を示唆しています。また、Tidyingは1時間以内に完了できる規模に抑えるべきという具体的な指針も示されています。Part 3: Theoryでは、Tidyingの理論的な基盤が展開されています。特筆すべきは、経済的な観点からの分析です。NPV（正味現在価値）やオプション理論を用いて、Tidyingの投資対効果を説明しています。また、疎結合と高凝集というソフトウェアアーキテクチャの基本原則との関連も論じられています。また、ソフトウェア設計の基本原則をより深く理解するために、以下の2冊との併読をお勧めします。「Balancing Coupling in Software Design」は、システムの結合度に焦点を当て、モジュール性と複雑性のバランスを取るための実践的なガイドを提供しています。特に、結合度を単なる「悪いもの」としてではなく、システム設計における重要なツールとして捉え直す視点は、Tidyingの経済的価値の考え方と共鳴します。Balancing Coupling in Software Design: Universal Design Principles for Architecting Modular Software Systems (Addison-Wesley Signature Series (Vernon)) (English Edition)作者:Khononov, VladAddison-Wesley ProfessionalAmazonさらに、「A Philosophy of Software Design, 2nd Edition」は、ソフトウェア設計における複雑性の管理について、より哲学的な視点から考察を展開しています。この本は、モジュール分割の原則やインターフェース設計の考え方など、Tidyingの実践を支える理論的な基盤を補完してくれます。A Philosophy of Software Design, 2nd Edition (English Edition)作者:Ousterhout, John K. Amazon本書の真価は、コードの整理整頓を、技術的な活動としてだけでなく、経済的な投資活動として捉える視点を提供している点です。これは、技術的な改善活動の必要性を経営層に説明する際の有効な理論的基盤となります。また、本書は3部作の第1巻として位置づけられており、個人、チーム、組織のレベルでの開発プラクティスを包括的に扱う野心的なプロジェクトの出発点となっています。私にとって、本書は技術的負債の管理に関する新しい視点を提供してくれました。特に、小規模な改善活動を継続的に行うことの重要性と、その活動の経済的な価値を理解する上で、貴重な指針となっています。本書で提唱されているTidyingの概念は、現代のソフトウェア開発における持続可能性の向上に大きく貢献する可能性を秘めています。技術的な改善と経済的な価値創造の両立を目指す実践的なアプローチとして、多くの開発者にとって有益な知見となるでしょう。こちらの本も日本語版がリリースされます。読んでないのですが定評のある翻訳者陣が担当しており、高品質な翻訳が期待できます。Tidy First? ―個人で実践する経験主義的ソフトウェア設計作者:Kent Beckオーム社Amazonソフトウェア開発現場の「失敗」集めてみた。42の失敗事例で学ぶチーム開発のうまい進めかた「ソフトウェア開発現場の「失敗」集めてみた」は、開発現場でありがちな失敗を42の事例としてまとめ上げた、笑いと教訓が詰まった一冊です。本書の特徴は、各エピソードを4コマ漫画付きで紹介しながら、その失敗から学べる教訓と対策を実践的に解説している点にあります。ソフトウェア開発現場の「失敗」集めてみた。 42の失敗事例で学ぶチーム開発のうまい進めかた作者:出石 聡史翔泳社Amazon本書の真髄は、「失敗」を単なる戒めとしてではなく、成長のための貴重な学びの機会として提示している点です。例えば、「全部入りソフトウェア」や「八方美人仕様」といった事例は、読んでいて思わず苦笑してしまうものの、自分の過去や現在の案件と重ね合わせると背筋が凍るような リアルな内容となっています。特に印象的なのは、各失敗事例が企画、仕様、設計・実装、進捗管理、品質管理、リリース後という開発工程に沿って整理されている点です。これにより、どの段階でどのような落とし穴が待ち構えているのかを、体系的に理解することができます。本書の構成は非常に巧みです。各エピソードは、まず4コマ漫画で状況を分かりやすく説明し、続いて失敗の詳細な解説へと進みます。そして、なぜその失敗が起きるのかという原因分析を行い、最後にどうすれば防げるのかという具体的な対策を示すという流れで展開され、読者を笑いながら学びへと導いていきます。時には「あるある...」と共感し、時には「まさか自分も...」と冷や汗をかきながら、気づけば実践的な対策を学んでいられるという、絶妙な構成となっています。本書を読み進めていく中で、開発現場で日々直面する可能性のある様々な失敗のパターンが、読者の経験と重なりながら鮮やかに描き出されていきます。それぞれの事例は、読者が「ああ、これは...」と思わず身につまされるような、リアルな状況として描かれています。ここで思い出したのが、「達人プログラマー 第2版」です。この本もまた、ソフトウェア開発における失敗と成功の本質を深く掘り下げています。両書に共通するのは、失敗を恐れるのではなく、そこから学び、次につなげていく姿勢です。「達人プログラマー」が開発者としての哲学や普遍的な原則を説くのに対し、この本は現場での具体的な失敗事例とその対策に焦点を当てており、互いに補完し合う関係にあると言えるでしょう。達人プログラマー ―熟達に向けたあなたの旅― 第2版作者:David Thomas,Andrew Huntオーム社Amazon本書の真価は、これらの失敗を「笑い」というクッションを通して提示することで、読者が防衛本能を働かせることなく、客観的に問題を理解し、解決策を考えられるようにしている点です。また、各事例に対する具体的な対策は、実務ですぐに活用できる実践的なものとなっています。私自身、本書を読みながら何度も「あ、これ...」と苦笑いしましたが、同時に「明日からこうしよう」という具体的なアクションプランも得ることができました。特に、チームリーダーやプロジェクトマネージャーにとって、この本は「失敗」という観点からプロジェクトを見直す貴重な機会を提供してくれます。本書は、開発現場の失敗から学ぶという姿勢を大切にしながら、その教訓を次の成功へとつなげていく道筋を示してくれる良書です。時には笑い、時には考え込み、そして明日からの行動を変えていく—そんな良い意味での「反省の書」といえるでしょう。プログラミングRust 第2版「プログラミングRust 第2版」は、Rustという言語の深い理解を導く羅針盤のような一冊です。本書は、システムプログラミングの本質に迫りながら、現代的な言語機能を体系的に解説するという野心的な試みに成功しています。プログラミングRust 第2版作者:Jim Blandy,Jason Orendorff,Leonora F. S. TindallオライリージャパンAmazonこの本の特筆すべき点は、Rustの重要な概念を段階的に、かつ包括的に解説していることです。特に所有権とライフタイム、並行処理といったRustの特徴的な機能について、理論的な説明と実践的な例を絶妙なバランスで提供しています。これは、まるで高度な技術文書をコンパイラが最適化するように、複雑な概念を理解しやすい形に変換してくれる働きがあります。本書の構成は、基本的な言語機能から始まり、徐々により高度なトピックへと展開していきます。例えば、非同期プログラミングやトレイト、ジェネリクス、マクロなど、モダンなRustの重要な機能が詳細に解説されています。これは、読者の理解度を段階的にスケールアップさせていく、よく設計されたアーキテクチャのようです。特に印象的なのは、本書がパフォーマンスとメモリ安全性を両立させるためのRustの機能を、システムプログラマの視点から丁寧に解き明かしている点です。これは、高可用性システムの設計原則にも通じる、信頼性とパフォーマンスのトレードオフを実践的に学べる貴重な機会を提供しています。また、本書は2021年のRust Editionに対応しており、最新の言語機能や実践的なプログラミング手法が網羅されています。これは、まるで継続的デリバリーのパイプラインのように、最新の知識を読者に届けてくれます。実務的な観点からも、本書の価値は計り知れません。エラーハンドリング、テスト、デバッグといった実践的なトピックについても、深い洞察と具体的な実装例を提供しています。これらの知識は、本番環境でのRustプログラミングにおいて、インシデントを防ぎ、安定性を確保するための重要な基盤となります。本書は、単なる言語仕様の解説書を超えて、システムプログラミングの本質に迫る良書といえます。その内容は、Rustを学ぶ開発者にとって、強固な基盤となるインフラストラクチャを提供してくれることでしょう。私にとって、本書は技術書のデータセンターの中核を担うサーバーとして機能しています。新しい機能や概念に出会うたびに、本書に立ち返り、その本質的な理解を深めることができます。2025年に予定されているRust 2024 Editionのリリースに向けて、本書の次版がどのように進化していくのか、今から楽しみでなりません。Programming Rust: Fast, Safe Systems Development (English Edition)作者:Blandy, Jim,Orendorff, Jason,Tindall, Leonora F. S.O'ReillyAmazonEffective Rust「Effective Rust」は、Rustのコンパイラが発する警告やエラーの深い理由を解き明かしてくれる、暗号解読書のような一冊です。本書は、単なる文法やパターンの解説を超えて、Rustの設計思想とその根底にある原理を探求することで、より深い理解と実践的なスキルの獲得を可能にします。Effective Rust: 35 Specific Ways to Improve Your Rust Code (English Edition)作者:Drysdale, DavidO'Reilly MediaAmazon本書の真髄は、「なぜそのコードがコンパイラに拒否されるのか」という本質的な問いに対する答えを提供している点です。これは、まるでセキュリティ監査ツールのような役割を果たし、潜在的な問題を事前に検出し、より安全なコードへと導いてくれます。例えば、借用チェッカーとの「戦い」は、実はメモリ安全性を確保するための重要な対話であることを理解させてくれます。特筆すべきは、本書が型システムを通じたデザインパターンを詳細に解説している点です。これは、アプリケーションのアーキテクチャを型安全に設計するための青写真を提供してくれます。例えば、newtypeパターンの活用や、トレイトを用いた共通の振る舞いの表現など、型システムを活用した設計手法を学ぶことができます。また、本書はエラーハンドリングのベストプラクティスについて深い洞察を提供します。OptionやResult型の効果的な使用法から、独自のエラー型の設計まで、堅牢なエラー処理の体系を示してくれます。これは、まるで障害対策のプレイブックのような役割を果たします。実務的な観点からも、本書の価値は計り知れません。依存ライブラリの管理やツールチェーンの活用など、実践的なトピックについても詳しく解説されています。特に、Clippyとの対話を通じたコード品質の向上や、CIシステムの設定など、現代のソフトウェア開発に不可欠な知識が網羅されています。本書は、「とりあえず動く」コードから「より良い」コードへの進化を支援してよりイディオマティックなRustコードへの道筋を示してくれます。私にとって、本書は技術書のデータセンターにおける重要なセキュリティシステムとして機能しています。コードの品質と安全性を確保するためのチェックポイントとして、常に参照すべき存在となっています。特に、「なぜそうすべきか」という根本的な理解を深めることで、より効果的なRustプログラミングが可能になります。こちらの本も日本語版がリリースされています。Effective Rust ―Rustコードを改善し、エコシステムを最大限に活用するための35項目作者:David Drysdaleオーム社Amazonバックエンドエンジニアを目指す人のためのRust「バックエンドエンジニアを目指す人のためのRust」は、単なるRustの入門書を超えて、実践的なプロジェクトを通じてバックエンドエンジニアに必要な知識とスキルを体系的に学べる一冊です。本書は、「なぜバックエンドにRustなのか」という根本的な問いに、具体的なプログラミング体験を通じて答えを提示しています。バックエンドエンジニアを目指す人のためのRust作者:安東 一慈,大西 諒,徳永 裕介,中村 謙弘,山中 雄大翔泳社Amazon「Webバックエンド開発にRustは不要ではないか？」という疑問に対して、本書は実践的な回答を提供します。Rustの型システムとコンパイラによる厳格なチェックは、本番環境での予期せぬエラーを事前に防ぐことができます。また、エラーハンドリングやOption/Result型の扱いなど、Rustの特徴的な機能は、信頼性の高いバックエンドシステムの構築に直接的に貢献します。本書の構成は、学習者の段階的な成長を支援するように綿密に設計されています。計算クイズから始まり、ポーカーゲーム実装でデータ構造を学び、家計簿プログラムでファイルI/Oを理解し、最終的にはTODOアプリの開発とデプロイメントまでを経験できます。各プロジェクトは、バックエンド開発に必要な特定の技術要素に焦点を当てており、理論と実践を効果的に結びつけています。また、本書はCargoによるパッケージ管理、ユニットテスト、リンター、フォーマッターといった実務で重要となる開発ツールの活用方法も丁寧に解説しています。これらのツールは、チーム開発における生産性と品質の向上に直結する重要な要素です。本書を通じて学べる実践的なスキルは、現代のバックエンド開発の現場で直接活用できます。とりわけ、Webアプリケーション開発からデプロイメントまでの一連のプロセスを実際に体験できる点は、実務への橋渡しとして非常に価値があります。最終章では採用面接を想定した内容も含まれており、学習した内容を実際のキャリアにつなげる道筋も示されています。Real World HTTP 第3版「Real World HTTP 第3版」は、HTTPプロトコルの基礎から最新動向まで、体系的かつ実践的に解説した決定版です。本書は、HTTPの歴史的な進化をたどりながら、ブラウザの内部動作やサーバーとのやり取りについて、実例とコードを交えて詳細に解説しています。Real World HTTP 第3版 ―歴史とコードに学ぶインターネットとウェブ技術作者:渋川 よしきオライリージャパンAmazon本書は、辞書的に知りたい項目を調べるのにも、通して読んで体系的に学習するのにも適しています。特に注目すべきは、認証やセキュリティなど、開発者が苦手意識を持ちがちな領域についても、実践的な観点から詳しく解説している点です。サンプルコードはGoを使用していますが、これは動作確認や挙動の理解に焦点を当てたものです。実際の実装例を通じて、HTTPの基本的な仕組みから最新の機能まで、具体的に理解することができます。もう少し入門的な内容としては「［改訂新版］プロになるためのWeb技術入門」をオススメしたいです。10年以上にわたって多くの読者に支持されてきた本書はWebシステムの基礎から最新のSPAまで、体系的かつ段階的に学べる実践的な入門書です。本書は、なぜWebシステムをうまく作ることができないのかという根本的な問いに対して、技術の本質的な理解を通じて答えを導き出そうとしています。サンプルもどうようにGoですし、Goは本能さえあれば読めるので…。［改訂新版］プロになるためのWeb技術入門作者:小森 裕介技術評論社Amazonまた、実装やWeb技術を学べたと思ってアーキテクチャ設計を学ぶ準備が整った方には、「アーキテクトの教科書 価値を生むソフトウェアのアーキテクチャ構築」をお勧めします。本書は、アーキテクチャ設計の本質的な考え方から、実践的な構築手法までを体系的に解説していて入門にはぴったりです。アーキテクトの教科書 価値を生むソフトウェアのアーキテクチャ構築作者:米久保 剛翔泳社AmazonWeb技術やアーキテクチャについて検索エンジンやChatGPTで調べると、求めている答えにたどり着くまでに多くの時間がかかり、また得られる情報が断片的になりがちです。一方、良質な技術書は、その分野の知識を体系的に整理し、読者が見落としがちな重要なポイントも含めて包括的に解説してくれます。さらに、実践的な経験に基づく洞察や、背景にある原理の説明など、オンラインでは得にくい深い知見を提供してくれます。第3版では、より初学者を意識した導入や、スーパーアプリなどプラットフォーム化するウェブに関する新章が追加されています。また、HTTP/3とQUICなど最新の技術動向についても詳しく解説されています。本書の圧倒的な情報量は、単なるボリュームではなく、実務で本当に必要となる知識が凝縮されています。AWSやWebフレームワークでの開発スキルも重要ですが、真のWebエンジニアとして成長するためには、本書で解説されているような基盤となる知識の理解が不可欠です。学び直しにも最適な一冊であり、眺めるだけでも新しい発見が得られます。HTTPやWeb技術の深い理解を目指す若手エンジニアには、まさに必携の書といえるでしょう。【改訂新版】システム障害対応の教科書「システム障害対応の教科書」は、システム障害対応の暗黙知を形式知化し、体系的に解説した画期的な一冊です。本書は、インシデント発生から終息までの一連のプロセスを詳細に解説するだけでなく、組織としての障害対応力向上までを包括的にカバーしています。【改訂新版】システム障害対応の教科書作者:木村 誠明技術評論社Amazon改訂新版では、チームメンバーの教育と育成、障害対応訓練、事故を防ぐ手順書の作り方、エンドユーザ向け情報発信についての新章が追加され、より実践的な内容となっています。特に、ワークブック編の追加により、理論を実践に落とし込むための具体的な手法が提供されており、新人から中堅、マネージャーまで幅広い層に価値のある内容となっています。本書の真価は、システム障害対応における役割と基本動作の明確化にあります。インシデントコマンダー、作業担当者、ユーザ担当者など、各役割の責務と行動規範が詳細に解説されています。また、必要なドキュメントやツール、環境についても具体的な説明があり、すぐに実務に活かせる実践的な知識を得ることができます。特に注目すべきは、組織の障害対応レベル向上と体制作りに関する章です。障害対応力のスキルチェックシートや訓練の実施要領など、組織として継続的に改善していくための具体的な方法論が示されています。また、生成AI技術のシステム運用への応用についても言及されており、最新の技術動向も押さえられています。Appendixでは、実際の難易度の高いシステム障害ケースが紹介されており、ビジネスロジックの障害から大規模インフラ障害、災害時の対応まで、現実的なシナリオに基づいた学びを得ることができます。これらのケーススタディは、理論と実践を結びつける貴重な教材となっています。本書は、システム運用に関わるすべての人にとって、障害対応の基本から応用まで、体系的に学べる決定版といえます。新人エンジニアの教育から、中堅エンジニアのスキル向上、マネージャーの組織運営まで、幅広いニーズに応える内容となっています。運用であればAWS運用入門も今年読んで良かった本なのであわせて紹介しておきます。AWS運用入門　押さえておきたいAWSの基本と運用ノウハウ作者:佐竹 陽一,山﨑 翔平,小倉 大,峯 侑資SBクリエイティブAmazon申し訳ありません。GitHub CI/CD実践ガイドの章は前の章とは独立して新規に追加すべきでした。改めて追加させていただきます：GitHub CI/CD実践ガイド「GitHub CI/CD実践ガイド」は、持続可能なソフトウェア開発を支えるGitHub Actionsの設計と運用について、基礎から実践、そして応用まで体系的に解説した一冊です。本書は、単なるGitHub Actionsの使い方マニュアルを超えて、現代のソフトウェア開発における継続的インテグレーションと継続的デリバリーの本質に迫っています。GitHub CI/CD実践ガイド――持続可能なソフトウェア開発を支えるGitHub Actionsの設計と運用 エンジニア選書作者:野村 友規技術評論社Amazon本書の特徴は、その構成の緻密さにあります。基礎編では、GitHub Actionsの基本概念や構文を丁寧に解説し、実践編では具体的なユースケースに基づいた実装方法を示し、応用編では高度な使い方やセキュリティ、組織としての実践方法を展開しています。この段階的なアプローチにより、読者は自然と実践的なCI/CDの知識を積み上げていくことができます。特筆すべきは、本書がセキュリティと運用の観点を強く意識している点です。GitHub Actionsの基本的な使い方だけでなく、OpenID Connectによるセキュアなクラウド連携、Dependabotによる依存関係の管理、GitHub Appsによるクロスリポジトリアクセスなど、実運用で直面する重要な課題についても深く掘り下げています。本書が提供する知見は、現代のソフトウェア開発において不可欠な継続的デリバリーの実践へと読者を導きます。組織のパフォーマンス向上からバージョン管理戦略、テスト戦略、そしてインフラストラクチャの変更管理まで、包括的な視点でCI/CDの実践方法を解説しています。私にとって本書は、日々のCI/CD運用における信頼できるリファレンスとなっています。実装時の細かな疑問から、アーキテクチャレベルの設計判断まで、様々な場面で本書の知見が活きています。GitHubを利用する開発者にとって、この本は確実に実務の質を高めてくれる一冊となるでしょう。個人的にLearning GitHub Actionsが好きだったので日本語版のような書籍がでてきてくれて嬉しいです。Learning GitHub Actions: Automation and Integration of CI/CD with GitHub (English Edition)作者:Laster, BrentO'Reilly MediaAmazonおわりに2024年、私にとって技術書との関わり方が大きく変化した1年でした。技術書に関してはこれまでのように単に量を追い求めるのではなく、一冊一冊をより深く理解することに注力しました。その過程で、技術書は単なる情報の集合体ではなく、先人たちの経験や洞察が凝縮された知恵の結晶であることを改めて実感しました。今年はプラットフォームエンジニアリング、継続的デプロイメント、オブザーバビリティ、SRE、データエンジニアリングなど、現代のソフトウェアエンジニアリングにおける重要なテーマを深く学ぶことができました。また、技術イベントでの発表や記事執筆に向けて、多くの入門書にも触れる機会があり、そこに込められた読者の理解を深めるための緻密な工夫にも感銘を受けました。特に印象深かったのは、これらの技術書に共通する「実践知の体系化」というアプローチです。例えば、『Platform Engineering』は組織的な実践知を理論化し、『システム障害対応の教科書』は現場の暗黙知を形式知へと昇華させています。また、『プログラミングRust』や『Effective Rust』といった言語関連の書籍も、単なる技術解説を超えて、設計思想や原理の本質的な理解に重点を置いています。これらの本から得た知識は、日々の業務や技術イベントでの発表を通じて実践し、さらにその経験を自分の言葉で発信することで、理解をより深めることができました。来年も引き続き、質の高い技術書との出会いを大切にし、得られた知見を実践し、コミュニティに還元していくことで、エンジニアとしての成長を続けていきたいと考えています。","isoDate":"2024-12-23T08:47:50.000Z","dateMiliSeconds":1734943670000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"初回実行が遅ければ遅延初期化でやればいいじゃない - RustのTUIアプリケーション改善","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/14/121545","contentSnippet":"この記事はRust Advent Calendar 2024 シリーズ3の15日目の記事です。はじめにみなさん、アプリケーションの初回実行の遅さに悩んでいませんか？「初回の検索が遅い...」「起動に時間がかかる...」「ユーザーから苦情が...」といった問題は、多くの開発者が直面する共通の課題です。実は、こういった問題の多くは初期化のタイミングを工夫することで効果的に解決できます。特にRustの場合、遅延初期化の仕組みを積極的に活用することで、パフォーマンスとユーザー体験を大きく改善することが可能です。初期化処理を適切なタイミングで実行することで、アプリケーションの応答性を保ちながら、必要なデータの準備を効率的に行うことができるのです。今回は郵便番号検索アプリケーション（jposta）を具体例として、初期化の最適化手法について詳しく見ていきましょう。この実践的なケーススタディを通じて、効果的な初期化戦略の実装方法を学んでいきます。github.com遅延初期化とは遅延初期化は、「必要になるまで初期化を待つ」という考え方を基本とする重要な最適化テクニックです。アプリケーションの起動時に全てのデータを一度に読み込むのではなく、そのデータが実際に使用されるタイミングまで読み込みを延期することで、システムの効率性を高めることができます。ja.wikipedia.org特に重要な利点として、アプリケーションの起動時間の大幅な短縮が挙げられます。全ての機能を一度に初期化する代わりに、必要な機能から順次初期化することで、ユーザーは最小限の待ち時間でアプリケーションの使用を開始できます。また、大きな設定ファイルの読み込みやデータベース接続の確立、重いライブラリの初期化、キャッシュの構築といったリソース集約的な操作を必要なタイミングまで延期することで、メモリやCPUなどの限られたリソースを効率的に活用することが可能となります。さらに、遅延初期化は複雑な依存関係を持つシステムにおいても効果的です。複数のコンポーネントが互いに依存し合う状況では、初期化の順序が問題となることがありますが、各コンポーネントを必要に応じて初期化することで、この課題を自然に解決できます。加えて、テスト容易性の向上も重要な利点です。必要なコンポーネントだけを初期化できることで、単体テストやモジュールテストが容易になり、テストの実行速度も向上します。また、エラーハンドリングの改善にも貢献します。初期化時のエラーを早期に検出できるだけでなく、実際に使用されないコンポーネントの初期化エラーを回避することができます。運用環境での柔軟性も高まり、システムの一部機能が利用できない状況でも、他の機能を正常に動作させることが可能になります。このように、遅延初期化は現代のソフトウェア開発において、パフォーマンス、保守性、信頼性の面で多くのメリットをもたらす重要な設計パターンとなっています。blog1.mammb.comRustにおける遅延初期化の進化Rustにおける遅延初期化の歴史は、2014年に登場したlazy_staticから始まり、これはマクロベースの実装でスレッドセーフ性に課題があり、型の制約も厳しいものでした。github.comその後、2020年にはonce_cellが登場し、マクロを必要としないシンプルなAPIとスレッドセーフな実装、より柔軟な型のサポートを提供することで、遅延初期化の実装が大きく改善されました。github.comそして2024年になると、LazyCell/LazyLockが標準ライブラリに統合され、さらなる最適化と依存関係の削減が実現され、Rustの遅延初期化機能は新たな段階へと進化を遂げています。blog.rust-lang.orgこのように、Rustの遅延初期化は時代とともに進化し、より使いやすく堅牢な実装へと発展してきました。techblog.paild.co.jp問題の理解：なぜ初期処理が必要か？まず、jpostcode_rsライブラリの実装を見てみましょう：use std::sync::LazyLock;static ADDRESS_MAP: LazyLock\u003cHashMap\u003cString, Vec\u003cAddress\u003e\u003e\u003e = LazyLock::new(|| {    let data = include_str!(concat!(env!(\"OUT_DIR\"), \"/address_data.json\"));    let raw_map: HashMap\u003cString, Value\u003e =        serde_json::from_str(data).expect(\"Failed to parse raw data\");    // ...});このコードの重要なポイントは、LazyLockによる遅延初期化を採用することで、JSONデータの初回アクセス時までパースを延期し、必要なタイミングでメモリへの展開を行う設計となっているということです。このコードから分かるように、初回アクセス時のパフォーマンス低下は遅延初期化の仕組みに起因しています。そこで私たちは、この遅延初期化の特性を活用し、ユーザーが実際にアクセスする前に初期化を完了させる戦略を考案しました。解決策：遅延初期化を活用した初期処理従来の初期化パターンfn new() -\u003e App {    let (search_tx, search_rx) = mpsc::channel::\u003cString\u003e();    let (result_tx, result_rx) = mpsc::channel();    thread::spawn(move || {        while let Ok(query) = search_rx.recv() {            // 初回検索時にデータ初期化が発生 = 遅い！        }    });    App { /* ... */ }}改善後：標準ライブラリの機能を活用use std::sync::{LazyLock, Mutex};// グローバルな初期化フラグstatic INITIALIZED: LazyLock\u003cMutex\u003cbool\u003e\u003e = LazyLock::new(|| Mutex::new(false));impl App {    fn new() -\u003e App {        let (search_tx, search_rx) = mpsc::channel::\u003cString\u003e();        let (result_tx, result_rx) = mpsc::channel();        thread::spawn(move || {            // バックグラウンドで初期化            {                let mut init = INITIALIZED.lock().unwrap();                if !*init {                    // 軽いクエリで事前初期化をトリガー                    let _ = lookup_addresses(\"100\");                    let _ = search_by_address(\"東京\");                    *init = true;                }            }            // 以降の検索は初期化済みのデータを使用            let mut cache: HashMap\u003cString, Vec\u003cString\u003e\u003e = HashMap::new();            while let Ok(query) = search_rx.recv() {                // 通常の検索処理            }        });        App { /* ... */ }    }}この手法の効果とメリットとデメリットこの手法の中核となる標準ライブラリのLazyLockやMutexなどの基本機能は、追加のライブラリを必要としない堅牢な実装を可能にします。既存のRustプログラマーにとって馴染みのある仕組みを使用しているため、コードの理解や保守が容易であり、依存関係も最小限に抑えることができます。また、これらの機能は既にRustチームによって最適化され、徹底的にテストされているため、高いパフォーマンスと信頼性が保証されています。システムの保守性と運用面では、初期化ロジックの集中管理により、状態管理が大幅に簡素化されます。INITIALIZEDフラグを用いた明示的な制御により、初期化状態の追跡が容易になり、デバッグ性も向上します。さらに、初期化処理をバックグラウンドスレッドで実行することで、メインスレッドのブロッキングを避け、UIの即時表示とレスポンシブな操作感を実現できます。スケーラビリティの観点からは、新機能の追加や初期化順序の制御が柔軟に行えるため、システムの成長に合わせた拡張が容易です。Mutexによる適切な同期制御により、複数スレッドからの安全なアクセスが保証され、並行処理との親和性も高くなっています。また、必要なデータの予測的な先読みとメモリ使用の最適化により、効率的なリソース管理が可能です。初期化処理のモジュール化により、新しい機能の追加時も既存コードへの影響を最小限に抑えられ、キャッシュの効果的な活用によって、大規模なアプリケーションでも高いパフォーマンスを維持できます。一方で、この手法にはいくつかの重要な課題も存在します。まず、メモリ使用量の増加が挙げられます。事前初期化アプローチでは、実際には使用されない可能性のあるデータ構造も含めて、すべてのデータをメモリに展開する必要があります。これは特にメモリリソースが限られている環境において深刻な問題となる可能性があり、システムの全体的なパフォーマンスに影響を与える可能性があります。また、起動時のリソース消費も重要な課題です。バックグラウンドでの初期化処理は、システムの起動時により多くのCPUとメモリリソースを必要とします。特にモバイルデバイスやバッテリー駆動の機器では、この追加のリソース消費が電力効率に悪影響を及ぼす可能性があります。ユーザーの使用パターンによっては、この初期化コストが実際の便益を上回ってしまう場合もあります。さらに、実装の複雑性が増加することも大きな課題です。遅延初期化と事前初期化を組み合わせることで、コードベースの複雑性が著しく増加します。特に初期化の順序や依存関係の管理が複雑になり、開発者がシステムの動作を理解し、デバッグすることが困難になる可能性があります。この複雑性は、新しい機能の追加や既存機能の修正時にも影響を及ぼし、開発効率の低下につながる可能性があります。テストの複雑化も見過ごせない問題です。バックグラウンド初期化を含むコードのテストでは、タイミングや状態管理の観点から、適切なテストケースの作成と実行が困難になります。特に並行処理に関連するバグの再現や検証が複雑になり、品質保証のプロセスに追加の負担がかかる可能性があります。最後に、エラーハンドリングの複雑化も重要な課題です。バックグラウンドでの初期化中に発生したエラーの適切な処理と、それに対するユーザーへの適切なフィードバック提供が技術的な課題となります。エラーが発生した場合の回復処理や、部分的な機能提供の実装も複雑になり、システムの信頼性と保守性に影響を与える可能性があります。このように、標準ライブラリの機能を活用した実装は多くの利点をもたらす一方で、システムの要件や制約に応じて、これらのデメリットを慎重に検討する必要があります。実装時には、これらのトレードオフを考慮しながら、適切な設計判断を行うことが重要となります。実装時の注意点デッドロックの防止{  // スコープによるロックの制限    let mut init = INITIALIZED.lock().unwrap();    if !*init {        *init = true;    }}  // ロックの自動解放初期化の冪等性if !*init {    // 複数回実行されても安全な実装に    let _ = lookup_addresses(\"100\");    *init = true;}まとめ私たちは「初回アクセスが遅いなら、事前に必要な処理を済ませておこう」というシンプルながら実用的なアプローチについて、Rustの標準ライブラリの遅延初期化機構を通じて検討してきました。この手法には、メモリ使用量の増加やコードの複雑化といった課題も存在しますが、適切に実装することで大きな効果が期待できます。標準ライブラリの機能を活用し、依存関係を最小限に抑えながら、スレッドセーフな実装を実現することで、効率的かつ安全な初期化処理が可能となります。このように、遅延初期化と事前初期化を組み合わせたアプローチは、システムの特性や要件に応じて検討すべき重要な最適化パターンの一つと言えるでしょう。参考文献The Rust Standard Library - std::sync::LazyLockThe Rust Standard Library - std::cell::LazyCellRust Performance Book","isoDate":"2024-12-14T03:15:45.000Z","dateMiliSeconds":1734146145000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Rust 再学習戦記","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/12/013950","contentSnippet":"プログラミング言語の再入門とは、未知の大地への探求というよりも、私たちが知っているはずの領域を新たな視点で見つめ直す営みです。それは初めての出会いのような激しい高揚感とは異なり、むしろ静かな再発見の過程といえるでしょう。この記事は3-shake Advent Calendar 2024 シリーズ2の12日目の記事です。はじめに2017年、私の心にRustという言語が静かに灯りを点しました。その光は、システムプログラミングの深い理解への憧れを呼び覚まし、私を導いていきました。情熱に突き動かされるように、DevOpsツールの創造から始まり、パケット解析の探究へ、そしてWebフレームワークの実装へと、私の歩みは広がっていきました。高速な実行速度と安全性という輝きに心を奪われながらも、未熟なエコシステムという現実が私たちの前に立ちはだかりました。パッケージの追従に心を砕き、破壊的な変更に耐え、そして孤独なメンテナンスの重みを感じながら、私は一時の別れを告げることを選びました。しかし2024年を迎えた今、私の目の前で世界は確かな変化を見せています。Rustの開発者満足度は非常に高い一方で、実務での採用はまだ限定的です。これは、現時点ではRustを業務で使用している開発者が比較的少なく、主に技術的な興味や言語の特徴に惹かれて自発的に選択している人が多いためかもしれません。まぁ何はともあれ、私もその魅力に惹かれた1人のエンジニア。最新のRustを探究すべく、再入門することにしました。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazonなぜ今、Rustなのか技術的な成熟Rustのエコシステムは大きく進化し、この数年で安定性が著しく向上しています。パッケージの破壊的変更は目に見えて減少し、Zero To Production In Rustをはじめとした実践的な運用ガイドの登場により、本番環境での運用ノウハウが充実してきました。さらに、日本語での技術記事や登壇資料も増え、日本語でのコミュニケーションも充実してきています。主要パッケージの品質向上と運用実績の蓄積により、開発環境全体の信頼性は大幅に高まっています。また、言語サーバーの進化やツールチェーンの充実により、開発効率も飛躍的に向上しました。実践的な機能面においても、目覚ましい進歩が見られます。エラーハンドリングの改善やWebAssemblyサポートの強化により、クロスプラットフォーム対応も一層充実しました。また、コンパイラの最適化改善による実行時オーバーヘッドの最小化や、所有権システムによるメモリ安全性の保証など、Rustの基本的な強みはさらに磨きがかかっています。特に、非同期プログラミングのエコシステムは大きく成熟し、堅牢な基盤が確立されています。また、2025年には2024 Rdition がリリースされる。SREとしての展望今後は、Rustで構築されたマイクロサービスや高性能なバックエンドサービスのためのインフラ構築や運用の機会が増えていくことが予想されます。特に、コンテナ環境でのデプロイメントやクラウドネイティブな環境でのインフラ構築において、Rustアプリケーションの特性を最大限に活かすための設計が求められるでしょう。例えば、Rustの低メモリ消費という特徴を活かしたコンテナリソースの最適化や、高速な実行速度を考慮したオートスケーリングの設計など、アプリケーションの特性に合わせたインフラストラクチャの構築が重要になってきます。また、モニタリングやログ収集といった運用基盤においても、Rustアプリケーションに適した構成を検討していく必要があるでしょう。SREとしてRustのプロダクションデプロイメントに関わる場合は、Zero To Production In Rustを参照することをお勧めします。この書籍では、Rustアプリケーションの本番環境への展開に関する実践的なガイドラインが提供されています。www.zero2prod.comRustの再入門のための学習コンテンツ再入門にあたり、Rustの最新のプラクティスやエコシステムの変化をキャッチアップするため、いくつかの資料に取り組みました。特に有用だった書籍を紹介していきます。書籍の良さは情報を俯瞰できる点にあると考えています。わからない点があればLLMに質問することができますので⋯。なお、この記事はRustの基礎知識がある方向けの再入門という観点で資料を選定しているため、完全な初学者向けの内容は含んでいません。参照したドキュメントや内容の詳細については、Xで共有しているドキュメントをご確認ください。プログラミングRust 第2版 を読んで可能な限り手を動かす会を実施します。https://t.co/rmUpbPtK9O— nwiizo (@nwiizo) 2024年11月21日   読んだ本についての定義についてはこちらを参考にしてほしいです。読んでいない本について堂々と語る方法 (ちくま学芸文庫)作者:ピエール・バイヤール,大浦康介筑摩書房Amazonまた、yuk1tydさんのドキュメントは2021年時点の情報ですが、現在も十分に有用な内容となっているためおすすめです。blog-dry.com書籍Programming Rust, 2nd EditionO'Reilly Mediaから出版されている本書は、Rustの基本的な概念から高度な機能まで包括的に解説する定番の教科書です。特に所有権やライフタイム、並行処理といったRustの特徴的な機能について、実践的な例を交えながら詳細に説明されています。本当に再入門してから何度も読んでいる。生成AIに聞くか本を読むか実際に書いていくかの三択である。Programming Rust: Fast, Safe Systems Development作者:Blandy, Jim,Orendorff, Jason,Tindall, Leonora F SO'Reilly MediaAmazon2021年の第2版では、Rust 2021 Editionに対応し、非同期プログラミングやトレイト、ジェネリクス、マクロなど、モダンなRustの重要な機能が大幅に加筆されました。特に、パフォーマンスとメモリ安全性を両立させるためのRustの機能を、システムプログラマの視点から解説している点が特徴です。再三にはなるが2024 Rdition がリリースされる。それに合わせて再び書籍が出されるのが楽しみである。3年毎にリリースがあるのは早すぎず遅すぎずちょうど嬉しい。これまでと違う学び方をしたら挫折せずにRustを学べた話 / Programming Rust techramen24conf LTでも紹介されているように、本書は体系的な学習を可能にする構成と、実践的な例示の豊富さが特徴です。特に、Rustの概念モデルを丁寧に解説している点は、言語仕様の深い理解につながります。再入門時の体系的な知識のアップデートに最適な一冊といえるでしょう。 speakerdeck.comまた、日本語の書籍も出ているので感謝すべきである。プログラミングRust 第2版作者:Jim Blandy,Jason Orendorff,Leonora F. S. TindallオライリージャパンAmazonバックエンドエンジニアを目指す人のためのRust翔泳社から出版されているこの入門書は、実践的なプロジェクトを通じてRustを学ぶアプローチを採用しています。計算クイズからTODOアプリまで、段階的に難易度を上げながら、バックエンドエンジニアに必要な技術要素をカバーしている点が特徴です。バックエンドエンジニアを目指す人のためのRust作者:安東 一慈,大西 諒,徳永 裕介,中村 謙弘,山中 雄大翔泳社Amazon本書の優れている点は、各プロジェクトを通じて特定のRustの概念を深く掘り下げる構成にあります。例えば、ポーカーゲームの実装を通じてデータ構造の理解を深め、家計簿プログラムでファイルI/Oを学び、画像処理ツールで並列処理を実践的に理解できます。また、Cargoによるパッケージ管理、ユニットテスト、リンター、フォーマッターといった実務で重要となる開発ツールの活用方法も丁寧に解説されています。特筆すべきは、エラーハンドリングやOption/Result型の扱いなど、Rustの特徴的な機能を実際のユースケースに即して学べる点です。さらに、Webアプリケーション開発からデプロイメントまでをカバーしており、現代のバックエンド開発の実践的なスキルが身につく構成となっています。ただし、この本はプログラミング言語としてのRustの入門書として優れているものの、プログラミング未経験者にはRust自体の学習難度が高いため、他の言語での開発経験がある方に特にお勧めします。体系的な構成と実践的なプロジェクトを通じた学習アプローチは、技術書の模範となる一冊といえるでしょう。www.estie.jpコミュニティと情報源Rustの再入門において、コミュニティへの参加は技術的な成長と最新動向の把握に重要な役割を果たしています。日本のRustコミュニティは活発な技術交流が行われています。Rust.TokyoRust.Tokyoは日本最大のRustカンファレンスで、年に一度開催される重要なイベントです。私は再入門直後にこのカンファレンスに参加することになり、登壇資料の準備に追われる事態となりましたが、結果的に学習のよい動機付けとなりました。カンファレンスでは、企業での採用事例や実装のベストプラクティス、パフォーマンスチューニングの知見など、実践的な内容が数多く共有されます。また、国内外のRustコミュニティのメンバーとの交流を通じて、最新のトレンドやツール、開発手法について直接学ぶ機会も得られます。Rust-jp ZulipRust-jp Zulipは、日本のRustコミュニティの中心的なコミュニケーション基盤です。SlackやDiscordと異なり、トピックベースの会話構造を持つZulipを採用することで、過去の議論や質問への回答を効率的に検索できる点が特徴です。このプラットフォームでは、初心者向けの基本的な質問から、高度な実装の相談まで、幅広いディスカッションが日本語で行われています。特に、実務での問題解決やコードレビュー、アーキテクチャの相談など、実践的な議論が活発に行われており、再入門者にとって貴重な学習リソースとなっています。学びの記録2017年の実践パケット解析の実装Webフレームワーク検証Rust関連記事一覧2024 年やったことRustでterraform plan/apply のターゲット指定を簡単にするツールを作ってみた - tfocusの仕組みと使い方退屈なことはRust Build Scripts にやらせようRustで郵便番号・住所検索TUIツールを開発した - jpostaRustによる郵便番号検索API (yubin_api) の技術解説tfocusexpjpostcode_rsおわりに2017年の経験は、今となっては貴重な財産です。言語に入門し、一度は挫折を経験しながらもプロダクトへの導入に挑戦したこと、そして結果的に撤退を選択せざるを得なかったことは、私にとって大きな学びとなりました。この貴重な経験と適切な判断へと導いてくれた当時のメンターには感謝しています。パッケージ管理の困難さ、破壊的変更への対応、そして継続的な開発の課題 - これらの経験があったからこそ、現在のRustエコシステムの進化をより深く理解できています。Rustは単なるプログラミング言語の進化を超えて、エコシステム全体として大きく成長しました。特に、かつて私が直面した課題の多くが、コミュニティの成熟とツールチェーンの進化によって解決されつつあります。実践的なユースケースの蓄積は、次世代のシステム開発における新たな可能性を示唆しています。Rust 2024エディションのリリースを控え、言語とエコシステムはさらなる進化を遂げようとしています。SREとしても、このような発展を続けるRustの動向を把握し、実践的な知識を蓄積していくことは、将来への重要な投資になると確信しています。この記事を読んでいる方々も、ぜひこの成長と進化の過程に参加してみませんか？初めての方も、かつて離れた方も、今こそRustと再会するベストなタイミングかもしれません。","isoDate":"2024-12-11T16:39:50.000Z","dateMiliSeconds":1733935190000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Rustによる郵便番号検索API (yubin_api) の技術解説","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/04/233641","contentSnippet":"こちらの記事は Rust Advent Calendar 2024 シリーズ 3 7日目の記事です！qiita.comはじめにRustを使用したWebアプリケーション開発は、高いパフォーマンスと堅牢性を両立させる方法として注目を集めています。本記事では、日本の郵便番号システムにアクセスするRESTful API「yubin_api」の実装を通じて、Rustの実践的な開発手法を解説します。workspace_2024/yubin_api at main · nwiizo/workspace_2024 · GitHubこのプロジェクトでは、axumを使用したWebサーバーの構築、非同期プログラミング（async/await）、構造化されたエラーハンドリングを実装しています。また、プロダクション環境を想定したメトリクス収集とモニタリング、型安全なAPIデザインにも焦点を当てています。ちなみに元ライブラリーの実装についてはsyumai さんの実装を全面的に参考にさせていただいております。blog.syum.ai1. プロジェクトの構成まず、Cargo.tomlの依存関係から見ていきましょう：[dependencies]# Webフレームワーク関連axum = { version = \"0.7\", features = [\"macros\"] }  # Webフレームワークtokio = { version = \"1.0\", features = [\"full\"] }   # 非同期ランタイムtower = { version = \"0.4\", features = [\"full\"] }   # HTTPサービス抽象化tower-http = { version = \"0.5\", features = [\"cors\", \"trace\", \"limit\", \"request-id\"] }# ロギングと監視tracing = \"0.1\"                # ログ出力tracing-subscriber = \"0.3\"     # ログ設定metrics = \"0.21\"              # メトリクス収集metrics-exporter-prometheus = \"0.12\"  # Prometheus形式出力# シリアライズ/デシリアライズserde = { version = \"1.0\", features = [\"derive\"] }serde_json = \"1.0\"# ユーティリティthiserror = \"1.0\"   # エラー定義uuid = { version = \"1.0\", features = [\"v4\"] }  # ユニークID生成utoipa = { version = \"4.1\", features = [\"uuid\"] }  # OpenAPI生成# 郵便番号データベースjpostcode_rs = \"0.1.3\"2. エラー処理の実装（error.rs）エラー処理は、APIの信頼性を確保する重要な部分です：use axum::{    http::StatusCode,    response::{IntoResponse, Response},    Json,};use thiserror::Error;use tracing::warn;// APIのエラー型を定義#[derive(Debug, Error)]pub enum ApiError {    #[error(\"Invalid postal code format\")]    InvalidPostalCode,    #[error(\"Address not found\")]    NotFound,    #[error(\"Internal server error: {0}\")]    Internal(String),}// エラーをHTTPレスポンスに変換する実装impl IntoResponse for ApiError {    fn into_response(self) -\u003e Response {        // エラーの種類に応じてステータスコードを設定        let (status, error_message) = match self {            ApiError::InvalidPostalCode =\u003e (StatusCode::BAD_REQUEST, self.to_string()),            ApiError::NotFound =\u003e (StatusCode::NOT_FOUND, self.to_string()),            ApiError::Internal(ref e) =\u003e {                // 内部エラーはログに記録                warn!(\"Internal server error: {}\", e);                (                    StatusCode::INTERNAL_SERVER_ERROR,                    \"Internal server error\".to_string(),                )            }        };        // JSONレスポンスの構築        let body = Json(serde_json::json!({            \"error\": error_message,            \"status\": status.as_u16(),            // エラー追跡用のユニークID            \"request_id\": uuid::Uuid::new_v4().to_string()        }));        (status, body).into_response()    }}3. データモデルの定義（models.rs）APIで使用するデータ構造を定義します：use serde::{Deserialize, Serialize};// 住所情報のレスポンス構造体#[derive(Debug, Serialize, Deserialize, utoipa::ToSchema)]pub struct AddressResponse {    pub postal_code: String,    pub prefecture: String,    pub prefecture_kana: String,    pub prefecture_code: i32,    pub city: String,    pub city_kana: String,    pub town: String,    pub town_kana: String,    pub street: Option\u003cString\u003e,    pub office_name: Option\u003cString\u003e,    pub office_name_kana: Option\u003cString\u003e,}// jpostcode_rsのAddress型からの変換を実装impl From\u003cjpostcode_rs::Address\u003e for AddressResponse {    fn from(addr: jpostcode_rs::Address) -\u003e Self {        AddressResponse {            postal_code: addr.postcode,            prefecture: addr.prefecture,            prefecture_kana: addr.prefecture_kana,            prefecture_code: addr.prefecture_code,            city: addr.city,            city_kana: addr.city_kana,            town: addr.town,            town_kana: addr.town_kana,            street: addr.street,            office_name: addr.office_name,            office_name_kana: addr.office_name_kana,        }    }}// 住所検索用のクエリ構造体#[derive(Debug, Deserialize, utoipa::ToSchema)]pub struct AddressQuery {    pub query: String,    #[serde(default = \"default_limit\")]    pub limit: usize,}// デフォルトの検索結果制限数fn default_limit() -\u003e usize {    10}4. メトリクス収集の設定（metrics.rs）アプリケーションのパフォーマンスを監視するためのメトリクス設定：use metrics::{describe_counter, describe_histogram, register_counter, register_histogram};use metrics_exporter_prometheus::PrometheusBuilder;pub fn setup_metrics() {    // リクエスト数のカウンター    describe_counter!(        \"yubin_api_postal_lookups_total\",        \"Total number of postal code lookups\"    );    describe_counter!(        \"yubin_api_address_searches_total\",        \"Total number of address searches\"    );    // レスポンス時間のヒストグラム    describe_histogram!(        \"yubin_api_postal_lookup_duration_seconds\",        \"Duration of postal code lookups in seconds\"    );    describe_histogram!(        \"yubin_api_address_search_duration_seconds\",        \"Duration of address searches in seconds\"    );    // メトリクスの登録    register_counter!(\"yubin_api_postal_lookups_total\");    register_counter!(\"yubin_api_address_searches_total\");    register_histogram!(\"yubin_api_postal_lookup_duration_seconds\");    register_histogram!(\"yubin_api_address_search_duration_seconds\");    // Prometheusレコーダーの設定    PrometheusBuilder::new()        .install()        .expect(\"Failed to install Prometheus recorder\");}Rustの知っておいたほうがいいポイント解説(前編)属性マクロの使用#[derive(...)]: 自動実装の導入#[error(...)]: エラーメッセージの定義#[serde(...)]: シリアライズ設定トレイトの実装From\u003cT\u003e: 型変換の実装IntoResponse: HTTPレスポンスへの変換Error: カスタムエラー型の定義ジェネリクスとライフタイムOption\u003cT\u003e: 省略可能な値の表現Result\u003cT, E\u003e: エラーハンドリングVec\u003cT\u003e: 可変長配列の使用型システムの活用カスタム構造体の定義列挙型によるエラー表現デフォルト値の実装Rust初学者のためのyubin_api実装解説 - 後編5. APIルートの実装（routes.rs）APIの実際のエンドポイントを実装します：use axum::{extract::Path, http::StatusCode, response::IntoResponse, Json};use metrics::{counter, histogram};use tracing::info;// ヘルスチェックエンドポイントpub async fn health_check() -\u003e impl IntoResponse {    StatusCode::OK}// 郵便番号検索エンドポイントpub async fn lookup_by_postal_code(    Path(code): Path\u003cString\u003e,  // URLパスからパラメータを取得) -\u003e Result\u003cJson\u003cVec\u003cAddressResponse\u003e\u003e, ApiError\u003e {    // リクエストのログ記録    info!(\"Looking up postal code: {}\", code);        // メトリクスのカウントアップ    counter!(\"yubin_api_postal_lookups_total\", 1);        // 処理時間の計測開始    let start = std::time::Instant::now();    // 郵便番号検索の実行    let result = jpostcode_rs::lookup_address(\u0026code).map_err(|e| match e {        jpostcode_rs::JPostError::InvalidFormat =\u003e ApiError::InvalidPostalCode,        jpostcode_rs::JPostError::NotFound =\u003e ApiError::NotFound,    })?;    // 処理時間の計測と記録    let duration = start.elapsed().as_secs_f64();    histogram!(\"yubin_api_postal_lookup_duration_seconds\", duration);    // 結果の返却    Ok(Json(result.into_iter().map(Into::into).collect()))}// 住所検索エンドポイントpub async fn search_by_address(    Json(query): Json\u003cAddressQuery\u003e,  // リクエストボディからのJSONパース) -\u003e Result\u003cJson\u003cVec\u003cAddressResponse\u003e\u003e, ApiError\u003e {    info!(\"Searching address with query: {}\", query.query);        // 入力値の検証    if query.query.trim().is_empty() {        return Err(ApiError::InvalidPostalCode);    }    counter!(\"yubin_api_address_searches_total\", 1);    let start = std::time::Instant::now();    // 住所検索の実行    let mut results: Vec\u003cAddressResponse\u003e = jpostcode_rs::search_by_address(\u0026query.query)        .into_iter()        .map(Into::into)        .collect();    // 結果数の制限適用    results.truncate(query.limit);    let duration = start.elapsed().as_secs_f64();    histogram!(\"yubin_api_address_search_duration_seconds\", duration);    Ok(Json(results))}6. メインアプリケーションの実装（main.rs）アプリケーションのエントリーポイントとサーバーの設定：use axum::{routing::{get, post}, Router};use std::net::SocketAddr;use tower::ServiceBuilder;use tower_http::{    cors::{Any, CorsLayer},    trace::{DefaultMakeSpan, DefaultOnResponse, TraceLayer},};use tracing::info;#[tokio::main]async fn main() {    // ロギングの初期化    tracing_subscriber::fmt()        .with_env_filter(            tracing_subscriber::EnvFilter::try_from_default_env()                .unwrap_or_else(|_| \"yubin_api=debug,tower_http=debug\".into()),        )        .init();    // メトリクス収集の初期化    setup_metrics();    // リクエストトレース設定    let trace_layer = TraceLayer::new_for_http()        .make_span_with(DefaultMakeSpan::new().include_headers(true))        .on_response(DefaultOnResponse::new().include_headers(true));    // CORS設定    let cors = CorsLayer::new()        .allow_methods(Any)        .allow_headers(Any)        .allow_origin(Any);    // ルーターの設定    let app = Router::new()        .route(\"/health\", get(health_check))        .route(\"/postal/:code\", get(lookup_by_postal_code))        .route(\"/address/search\", post(search_by_address))        .layer(ServiceBuilder::new()            .layer(trace_layer)            .layer(cors));    // サーバーアドレスの設定    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));    info!(\"Server listening on {}\", addr);    // サーバーの起動    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();    axum::serve(listener, app).await.unwrap();}7. 重要な実装パターンの解説非同期処理// 非同期関数の定義pub async fn lookup_by_postal_code(...) -\u003e Result\u003c...\u003e {    // 非同期処理の実行    let result = jpostcode_rs::lookup_address(\u0026code)?;    // ...}// 非同期ランタイムの設定#[tokio::main]async fn main() {    // ...}エラーハンドリング// Result型を使用したエラー処理let result = jpostcode_rs::lookup_address(\u0026code).map_err(|e| match e {    JPostError::InvalidFormat =\u003e ApiError::InvalidPostalCode,    JPostError::NotFound =\u003e ApiError::NotFound,})?;ミドルウェアの構成let app = Router::new()    .route(...)    .layer(ServiceBuilder::new()        .layer(trace_layer)        .layer(cors));8. API使用例郵便番号による検索curl http://localhost:3000/postal/1000001レスポンス例：[  {    \"postal_code\": \"1000001\",    \"prefecture\": \"東京都\",    \"city\": \"千代田区\",    \"town\": \"千代田\",    ...  }]住所による検索curl -X POST http://localhost:3000/address/search \\  -H \"Content-Type: application/json\" \\  -d '{\"query\": \"東京都千代田区\", \"limit\": 10}'9. Rustの知っておいたほうがいいポイント解説(後編)非同期プログラミングasync/awaitの使用方法tokioランタイムの理解非同期関数の定義と呼び出しエラーハンドリングパターンResult型の活用エラー変換のベストプラクティスエラーの伝播（?演算子）HTTPサーバーの実装ルーティング設定ミドルウェアの活用リクエスト/レスポンスの処理テスト可能な設計モジュール分割依存性の分離エラー処理の一貫性おわりにyubin_apiの実装を通じて、Rustによる実践的なWeb API開発の全体像を見てきました。このプロジェクトでは、カスタムエラー型の定義や型安全なデータ変換、トレイトの実装といった堅牢な型システムの活用を行いました。また、tokioによる非同期ランタイムやasync/awaitの効果的な使用、エラーハンドリングとの統合などの非同期プログラミングの実践も重要な要素となっています。さらに、メトリクス収集や構造化ログ、エラートラッキングといった運用面の考慮など、重要な概念と技術を学ぶことができました。このプロジェクトは、単なる郵便番号検索APIの実装を超えて、Rustの実践的な使用方法と、プロダクション品質のWebサービス開発の基本を学ぶ良い例となっています。","isoDate":"2024-12-04T14:36:41.000Z","dateMiliSeconds":1733323001000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Rustで郵便番号・住所検索TUIツールを開発した - jposta","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/03/230030","contentSnippet":"こちらの記事は Rust Advent Calendar 2024 シリーズ 3 5日目の記事です！qiita.comはじめにこんにちは！jposta を紹介させてください。jpostaは、日本の郵便番号・住所をターミナルから手軽に検索できるTUIツール 🔍 です。Rustで書かれており ⚡、使いやすさを重視してリアルタイム検索を実装しました 🖥️。jposta の動作イメージ元ライブラリーの実装についてはsyumai さんの実装を全面的に参考にさせていただいております。美しい実装すぎて震えました。blog.syum.ai機能紹介この小さなツールでは、郵便番号から住所の簡単検索 🏠 はもちろん、住所からの郵便番号検索 🔢 もラクラクできます。入力しながらサクサク表示されるリアルタイム検索 ⚡ や、キーボードだけでスイスイ操作 ⌨️ が可能で、スクロールもサクサク動き 📜、もちろん日本語もバッチリ対応 🗾 しています。ぜひGitHubをチェックしてみてください！github.comインストールcargo install --git https://github.com/nwiizo/jpostaもしくはcargo install jpostaこちら、みんなだいすきcrate.ioにちゃんとあげました。https://crates.io/crates/jposta基本操作Tab: 郵便番号/住所検索モード切替↑↓: 結果スクロールEsc: 終了検索モード郵便番号検索数字を入力すると自動で該当する住所を表示部分一致対応（\"100\"で始まる郵便番号すべて等）住所検索漢字やかなで住所を入力部分一致対応（\"渋谷\"等）Rustでの実装解説1. 基本構造の定義#[derive(Clone)]enum InputMode {    Postal,   // 郵便番号検索    Address,  // 住所検索}struct App {    input: String,    results: Vec\u003cString\u003e,    input_mode: InputMode,    scroll_state: ScrollbarState,    scroll_position: u16,    search_tx: mpsc::Sender\u003cString\u003e,    result_rx: mpsc::Receiver\u003cVec\u003cString\u003e\u003e,}InputModeは検索モードを表す列挙型です。Cloneトレイトを導出することで、値のコピーが可能になります。App構造体はアプリケーションの状態を管理します。input: 現在の入力文字列results: 検索結果の配列input_mode: 現在の検索モードscroll_stateとscroll_position: スクロール状態の管理search_txとresult_rx: スレッド間通信用のチャンネル2. アプリケーションの初期化impl App {    fn new() -\u003e App {        let (search_tx, search_rx) = mpsc::channel::\u003cString\u003e();        let (result_tx, result_rx) = mpsc::channel();        thread::spawn(move || {            let mut last_query = String::new();            let mut input_mode = InputMode::Postal;                        while let Ok(query) = search_rx.recv() {                // 検索処理（後述）            }        });        App {            input: String::new(),            results: Vec::new(),            input_mode: InputMode::Postal,            scroll_state: ScrollbarState::default(),            scroll_position: 0,            search_tx,            result_rx,        }    }}new()関数では、2つのチャンネルを作成（検索クエリ用と結果用）検索処理を行うワーカースレッドを起動初期状態のAppインスタンスを返す3. 検索処理の実装// 検索スレッド内の処理if query.starts_with(\"MODE_CHANGE:\") {    input_mode = match \u0026query[11..] {        \"postal\" =\u003e InputMode::Postal,        _ =\u003e InputMode::Address,    };    continue;}if query == last_query { continue; }last_query = query.clone();if query.is_empty() {    let _ = result_tx.send(Vec::new());    continue;}thread::sleep(Duration::from_millis(100));let results = match input_mode {    InputMode::Postal =\u003e lookup_addresses(\u0026query)        .map(|addresses| {            addresses                .into_iter()                .map(|addr| addr.formatted_with_kana())                .collect()        })        .unwrap_or_default(),    InputMode::Address =\u003e search_by_address(\u0026query)        .into_iter()        .map(|addr| addr.formatted_with_kana())        .collect(),};let _ = result_tx.send(results);検索処理では、モード変更メッセージの確認と処理重複クエリのスキップ空クエリの即時処理ディバウンス処理（100ms）モードに応じた検索実行結果の送信4. UIとイベント処理fn main() -\u003e io::Result\u003c()\u003e {    enable_raw_mode()?;    let mut stdout = stdout();    execute!(stdout, EnterAlternateScreen)?;    let backend = CrosstermBackend::new(stdout);    let mut terminal = Terminal::new(backend)?;    let mut app = App::new();    loop {        app.check_results();        terminal.draw(|f| {            let chunks = Layout::default()                .direction(Direction::Vertical)                .constraints([                    Constraint::Length(3),                    Constraint::Min(0)                ])                .split(f.size());            // 入力欄の描画            let input_block = Block::default()                .title(match app.input_mode {                    InputMode::Postal =\u003e \"郵便番号検索\",                    InputMode::Address =\u003e \"住所検索\",                })                .borders(Borders::ALL);                        let input = Paragraph::new(app.input.as_str())                .block(input_block)                .style(Style::default().fg(Color::Yellow));            f.render_widget(input, chunks[0]);            // 結果表示の描画            let results_block = Block::default()                .title(format!(\"検索結果 ({} 件)\", app.results.len()))                .borders(Borders::ALL);                        let results = Paragraph::new(app.results.join(\"\\n\"))                .block(results_block)                .scroll((app.scroll_position, 0));            f.render_widget(results, chunks[1]);        })?;        // キー入力処理        if let Event::Key(key) = event::read()? {            match key.code {                KeyCode::Char(c) =\u003e {                    app.input.push(c);                    app.search();                }                KeyCode::Backspace =\u003e {                    app.input.pop();                    app.search();                }                KeyCode::Up =\u003e app.scroll_up(),                KeyCode::Down =\u003e app.scroll_down(),                KeyCode::Tab =\u003e app.change_mode(match app.input_mode {                    InputMode::Postal =\u003e InputMode::Address,                    InputMode::Address =\u003e InputMode::Postal,                }),                KeyCode::Esc =\u003e break,                _ =\u003e {}            }        }    }    // 終了処理    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;    disable_raw_mode()?;    Ok(())}UIとイベント処理では、ターミナルの初期化メインループ検索結果の確認画面描画キー入力処理終了時のクリーンアップ5. 補助機能の実装impl App {    fn search(\u0026mut self) {        let _ = self.search_tx.send(self.input.clone());    }    fn check_results(\u0026mut self) {        if let Ok(new_results) = self.result_rx.try_recv() {            self.results = new_results;            self.scroll_position = 0;            self.scroll_state = ScrollbarState::new(self.results.len());        }    }    fn scroll_up(\u0026mut self) {        self.scroll_position = self.scroll_position.saturating_sub(1);    }    fn scroll_down(\u0026mut self) {        if !self.results.is_empty() {            self.scroll_position = self                .scroll_position                .saturating_add(1)                .min((self.results.len() as u16).saturating_sub(1));        }    }    fn change_mode(\u0026mut self, mode: InputMode) {        self.input_mode = mode;        let mode_str = match self.input_mode {            InputMode::Postal =\u003e \"postal\",            InputMode::Address =\u003e \"address\",        };        let _ = self.search_tx.send(format!(\"MODE_CHANGE:{}\", mode_str));        self.input.clear();        self.results.clear();    }}補助機能として、1. 検索リクエストの送信2. 検索結果の確認と更新3. スクロール処理4. モード切替処理これらの機能により、スムーズな検索体験を実現しています。使用ライブラリratatui: TUI（テキストユーザーインターフェース）フレームワークcrossterm: ターミナル操作ライブラリjpostcode_rs: 郵便番号データ処理ライブラリRust学習リソース1. 基礎学習The Rust Programming Language - 公式ガイドブックRust by Example - 実例で学ぶRustRustlings - 対話型学習ツール2. 基本概念構造体（Structs）列挙型（Enums）メソッド実装3. メモリ管理所有権システム参照と借用4. 言語機能パターンマッチングクロージャ5. エラー処理と型システムエラー処理Result型境界チェック演算子さいごにこのプロジェクトは、Rustの実践的な学習と日本の住所システムへの理解を深める良い機会となりました 📚。非同期処理やTUIの実装を通じて、Rustの強力な型システムと安全性を活かしたコーディングを実践できました ⚡。ぜひ使ってみて、フィードバックをいただければ幸いです 🙏。プルリクエストも大歓迎です 🎉！ソースコード🦀GitHub - jposta","isoDate":"2024-12-03T14:00:30.000Z","dateMiliSeconds":1733234430000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"退屈なことはRust Build Scripts にやらせよう","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/03/143149","contentSnippet":"こちらの記事は Rust Advent Calendar 2024 シリーズ 3 3日目の記事です！qiita.comはじめにRustのビルドスクリプト（build.rs）は、コンパイル前のデータ処理や環境設定を自動化する強力なツールです。しかし、大いなる力には、大いなる責任が伴います。コードの生成、リソースの最適化、プラットフォーム固有の設定管理など、ビルド時の様々なタスクを効率的に処理できます。今回は、そのユースケースの1つとして、郵便番号データを処理するビルドスクリプトの実装を詳しく解説します。この例を通じて、build.rsの基本的な使い方から実践的な活用方法まで、段階的に理解を深めていきましょう。doc.rust-lang.orgはじめにユースケース：郵便番号データの処理実装の全体像実装の詳細解説1. ファイル変更の監視設定2. パスの設定3. データの処理4. 結果の出力生成したデータの利用方法1. アプリケーションでのデータ読み込み2. 検索機能の実装build.rsの主要な機能1. 環境変数の設定2. リンカ設定3. コードの生成実践的な利用シーン1. 設定ファイルの統合と生成2. プロトコル定義ファイルの生成3. アセットファイルの埋め込み4. データベースマイグレーションファイルの統合参考資料まとめユースケース：郵便番号データの処理このビルドスクリプトは、複数のJSONファイルに分散された郵便番号データを1つのファイルにマージする処理を行います。github.com実装の全体像use serde_json::Value;use std::collections::HashMap;use std::fs;use std::path::Path;use walkdir::WalkDir;fn main() {    println!(\"cargo:rerun-if-changed=jpostcode-data/data/json\");    let json_dir = Path::new(\"jpostcode-data/data/json\");    let out_dir = std::env::var(\"OUT_DIR\").unwrap();    let dest_path = Path::new(\u0026out_dir).join(\"address_data.json\");    let mut merged_data = HashMap::new();    // ... データ処理ロジック ...}実装の詳細解説1. ファイル変更の監視設定println!(\"cargo:rerun-if-changed=jpostcode-data/data/json\");この行は、指定したディレクトリ内のファイルが変更された場合にのみビルドスクリプトを再実行するように設定します。これにより、不必要なビルド時間を削減できます。2. パスの設定let json_dir = Path::new(\"jpostcode-data/data/json\");let out_dir = std::env::var(\"OUT_DIR\").unwrap();let dest_path = Path::new(\u0026out_dir).join(\"address_data.json\");json_dir: 入力となるJSONファイルが格納されているディレクトリout_dir: Cargoが提供するビルド出力ディレクトリdest_path: 生成されるファイルの出力先3. データの処理for entry in WalkDir::new(json_dir).into_iter().filter_map(|e| e.ok()) {    if entry.file_type().is_file()        \u0026\u0026 entry.path().extension().map_or(false, |ext| ext == \"json\")    {        let content = fs::read_to_string(entry.path()).unwrap();        let file_data: HashMap\u003cString, Value\u003e = serde_json::from_str(\u0026content).unwrap();        let prefix = entry.path().file_stem().unwrap().to_str().unwrap();        for (suffix, data) in file_data {            let full_postcode = format!(\"{}{}\", prefix, suffix);            merged_data.insert(full_postcode, data);        }    }}このコードブロックでは以下の処理を行っています。WalkDirを使用してディレクトリを再帰的に走査JSONファイルのみを対象にフィルタリング各ファイルの内容を読み込みとパースファイル名とデータを組み合わせて完全な郵便番号を生成マージされたデータに追加4. 結果の出力fs::write(dest_path, serde_json::to_string(\u0026merged_data).unwrap()).unwrap();処理したデータを1つのJSONファイルとして出力します。生成したデータの利用方法1. アプリケーションでのデータ読み込みuse once_cell::sync::Lazy;use serde::{Deserialize, Serialize};use std::collections::HashMap;#[derive(Debug, Serialize, Deserialize)]struct Address {    postcode: String,    prefecture: String,    city: String,    // ... 他のフィールド}static ADDRESS_MAP: Lazy\u003cHashMap\u003cString, Vec\u003cAddress\u003e\u003e\u003e = Lazy::new(|| {    let data = include_str!(concat!(env!(\"OUT_DIR\"), \"/address_data.json\"));    serde_json::from_str(data).expect(\"Failed to parse address data\")});2. 検索機能の実装fn lookup_address(postal_code: \u0026str) -\u003e Option\u003c\u0026Vec\u003cAddress\u003e\u003e {    ADDRESS_MAP.get(postal_code)}fn search_by_prefecture(prefecture: \u0026str) -\u003e Vec\u003c\u0026Address\u003e {    ADDRESS_MAP        .values()        .flat_map(|addresses| addresses.iter())        .filter(|addr| addr.prefecture == prefecture)        .collect()}build.rsの主要な機能1. 環境変数の設定// コンパイル時の条件設定println!(\"cargo:rustc-cfg=feature=\\\"custom_feature\\\"\");// 環境変数の設定println!(\"cargo:rustc-env=APP_VERSION=1.0.0\");2. リンカ設定// 外部ライブラリのリンクprintln!(\"cargo:rustc-link-lib=sqlite3\");println!(\"cargo:rustc-link-search=native=/usr/local/lib\");3. コードの生成// バージョン情報の生成let version_code = format!(    \"pub const VERSION: \u0026str = \\\"{}\\\";\\n\",    env!(\"CARGO_PKG_VERSION\"));fs::write(\"version.rs\", version_code)?;実践的な利用シーン1. 設定ファイルの統合と生成複数の環境向けの設定ファイルを1つに統合する例：use std::collections::HashMap;use serde_json::Value;fn main() {    println!(\"cargo:rerun-if-changed=config/\");        let environments = [\"development\", \"staging\", \"production\"];    let mut merged_config = HashMap::new();        for env in environments {        let config_path = format!(\"config/{}.json\", env);        let config_content = std::fs::read_to_string(\u0026config_path).unwrap();        let config: Value = serde_json::from_str(\u0026config_content).unwrap();                merged_config.insert(env, config);    }        let out_dir = std::env::var(\"OUT_DIR\").unwrap();    let dest_path = Path::new(\u0026out_dir).join(\"config.rs\");        // 設定をRustのコードとして出力    let config_code = format!(        \"pub static CONFIG: Lazy\u003cHashMap\u003c\u0026str, Value\u003e\u003e = Lazy::new(|| {{            serde_json::from_str({}).unwrap()        }});\",        serde_json::to_string(\u0026merged_config).unwrap()    );        std::fs::write(dest_path, config_code).unwrap();}使用例：// main.rsuse once_cell::sync::Lazy;include!(concat!(env!(\"OUT_DIR\"), \"/config.rs\"));fn get_database_url(env: \u0026str) -\u003e String {    CONFIG[env][\"database\"][\"url\"].as_str().unwrap().to_string()}2. プロトコル定義ファイルの生成Protocol Buffersの定義ファイルからRustコードを生成する例：use std::process::Command;fn main() {    println!(\"cargo:rerun-if-changed=proto/\");        // protoファイルのコンパイル    let status = Command::new(\"protoc\")        .args(\u0026[            \"--rust_out=src/generated\",            \"--proto_path=proto\",            \"service.proto\"        ])        .status()        .unwrap();            if !status.success() {        panic!(\"Failed to compile proto files\");    }        // 生成されたコードをモジュールとして登録    let mod_content = r#\"        pub mod generated {            include!(\"generated/service.rs\");        }    \"#;        std::fs::write(\"src/proto_mod.rs\", mod_content).unwrap();}使用例：// lib.rsmod proto_mod;use proto_mod::generated::{UserRequest, UserResponse};pub async fn handle_user_request(req: UserRequest) -\u003e UserResponse {    // プロトコル定義に基づいた処理}3. アセットファイルの埋め込み画像やテキストファイルをバイナリに埋め込む例：use std::collections::HashMap;use base64;fn main() {    println!(\"cargo:rerun-if-changed=assets/\");        let mut assets = HashMap::new();        // 画像ファイルの埋め込み    for entry in std::fs::read_dir(\"assets\").unwrap() {        let entry = entry.unwrap();        let path = entry.path();                if path.extension().map_or(false, |ext| ext == \"png\" || ext == \"jpg\") {            let content = std::fs::read(\u0026path).unwrap();            let encoded = base64::encode(\u0026content);                        let asset_name = path.file_name().unwrap().to_str().unwrap();            assets.insert(asset_name.to_string(), encoded);        }    }        // アセットデータをRustコードとして出力    let out_dir = std::env::var(\"OUT_DIR\").unwrap();    let dest_path = Path::new(\u0026out_dir).join(\"assets.rs\");        let assets_code = format!(        \"pub static ASSETS: Lazy\u003cHashMap\u003cString, String\u003e\u003e = Lazy::new(|| {{            let mut m = HashMap::new();            {}            m        }});\",        assets.iter().map(|(k, v)| {            format!(\"m.insert(\\\"{}\\\".to_string(), \\\"{}\\\".to_string());\", k, v)        }).collect::\u003cVec\u003c_\u003e\u003e().join(\"\\n\")    );        std::fs::write(dest_path, assets_code).unwrap();}使用例：// lib.rsuse once_cell::sync::Lazy;include!(concat!(env!(\"OUT_DIR\"), \"/assets.rs\"));pub fn get_image_data(name: \u0026str) -\u003e Option\u003cVec\u003cu8\u003e\u003e {    ASSETS.get(name)        .map(|encoded| base64::decode(encoded).unwrap())}4. データベースマイグレーションファイルの統合SQLマイグレーションファイルを1つのモジュールにまとめる例：fn main() {    println!(\"cargo:rerun-if-changed=migrations/\");        let mut migrations = Vec::new();        // マイグレーションファイルの収集    for entry in std::fs::read_dir(\"migrations\").unwrap() {        let entry = entry.unwrap();        let path = entry.path();                if path.extension().map_or(false, |ext| ext == \"sql\") {            let version = path.file_stem().unwrap().to_str().unwrap()                .split('_').next().unwrap();            let content = std::fs::read_to_string(\u0026path).unwrap();                        migrations.push((version.to_string(), content));        }    }        // マイグレーションをRustコードとして出力    let migrations_code = format!(        \"pub static MIGRATIONS: \u0026[(\u0026str, \u0026str)] = \u0026[{}];\",        migrations.iter()            .map(|(ver, sql)| format!(\"(\\\"{}\\\", \\\"{}\\\")\", ver, sql.replace(\"\\\"\", \"\\\\\\\"\")))            .collect::\u003cVec\u003c_\u003e\u003e()            .join(\",\\n\")    );        let out_dir = std::env::var(\"OUT_DIR\").unwrap();    let dest_path = Path::new(\u0026out_dir).join(\"migrations.rs\");    std::fs::write(dest_path, migrations_code).unwrap();}使用例：// database.rsinclude!(concat!(env!(\"OUT_DIR\"), \"/migrations.rs\"));pub async fn run_migrations(db: \u0026SqlitePool) -\u003e Result\u003c()\u003e {    for (version, sql) in MIGRATIONS {        db.execute(sql).await?;        println!(\"Applied migration version {}\", version);    }    Ok(())}これらの例は、build.rsの実践的な使用方法を示しています。各例で以下のような利点があります。コンパイル時のリソース最適化開発時の利便性向上ランタイムパフォーマンスの改善コードの保守性向上実際のプロジェクトでは、これらの手法を組み合わせたり、プロジェクトの要件に合わせてカスタマイズしたりすることで、より効率的な開発環境を構築できます。しかし、魔環境もしくはビルド地獄を顕現させることもできるので注意が必要だと思いました。参考資料The Cargo Book - Build ScriptsRust By Example - Build Scriptsまとめこのビルドスクリプトの実装例を通じて、build.rsの有用性が明確になりました。コンパイル時のデータ最適化や複数ファイルの統合処理、動的なコード生成、そしてプラットフォーム固有の設定管理など、多岐にわたる機能を提供します。実際のプロジェクトでは、これらの機能を組み合わせることで、効率的な開発環境とビルドプロセスを実現できます。build.rsを活用することで、コンパイル時に必要なリソースの最適化や設定の自動化が可能となり、開発効率の向上とコードの保守性改善に大きく貢献します。","isoDate":"2024-12-03T05:31:49.000Z","dateMiliSeconds":1733203909000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"3-shake Advent Calendar 2024 やっていきます #3SHAKE","link":"https://syu-m-5151.hatenablog.com/entry/2024/11/30/142710","contentSnippet":"こんにちは、nwiizoです。晩秋の肌寒さが身にしみるこの11月も今日で終わりですね。ついこの前、昨年のAdvent Calendarで記事埋めを依頼され、慌ただしく準備した記憶が鮮明です。まったく、時の流れとは不思議なものです。今年もスリーシェイクのAdvent Calendarを開催することができます。この企画が実現したのは、ひとえに社内の方々の温かいご協力の賜物であり、その事実に深い感謝の念を抱いております。qiita.comスリーシェイクは「インフラをシンプルにしてイノベーションを起こす」というビジョンのもと、クラウド、セキュリティ、データ連携、HR領域で4つのサービスを展開しているテクノロジーカンパニーです。3-shake.com先日、シリーズB追加ラウンドとしてNTTデータ、SCSKから10億円の資金調達を実施し、資本業務提携を締結するニュースが出るなど、着実に成長を続けています。prtimes.jp今年のAdvent Calendarでも、エンジニアの技術的な記事だけでなく、スリーシェイクで働く様々な職種のメンバーによる記事をお届けする予定です。エンジニア以外にも営業、カスタマーサクセス、広報、経営企画など、多様なバックグラウンドを持つメンバーたちが、それぞれの視点からスリーシェイクでの経験や日々の発見を共有していきます。なぜ技術的な記事に限定しないのか。それは、私たちが目指すイノベーションには、技術だけでなく、様々な専門性や視点が必要だと考えているからです。このAdvent Calendarを通じて、スリーシェイクがどのような会社で、どんな人たちが働いているのか、より深く知っていただければ幸いです。記事の更新情報は、スリーシェイクの公式Xアカウント（@3shake_Inc）でお知らせしていきますので、ぜひフォローをお願いします！また、Advent Calendarも合わせてチェックしていただければと思います。成長を続けるスリーシェイクの「今」を知るきっかけとして、どうぞお楽しみください！jobs-3-shake.com","isoDate":"2024-11-30T05:27:10.000Z","dateMiliSeconds":1732944430000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"メインテーマはKubernetes","link":"https://speakerdeck.com/nwiizo/meintemahakubernetes","contentSnippet":"2024年16:20-17:00（Track A）にて「メインテーマはKubernetes」というタイトルで登壇します。\r\rイベント名: Cloud Native Days Winter 2024\r\r公式URL:https://event.cloudnativedays.jp/cndw2024/\r\rセッションURL:https://event.cloudnativedays.jp/cndw2024/talks/2373","isoDate":"2024-11-28T05:00:00.000Z","dateMiliSeconds":1732770000000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Neovimのイベントタイミングガイド","link":"https://syu-m-5151.hatenablog.com/entry/2024/11/27/023303","contentSnippet":"はじめにNeovimでの設定やプラグイン開発において、適切なタイミングでコードを実行することは非常に重要です。このガイドでは、Neovimの主要なイベントについて、実用的な例を交えながら解説します。1. 起動時のイベント系統Neovimの起動プロセスで最も重要なイベントはVimEnterです。これは全ての初期化処理（vimrcの読み込み、プラグインの初期化など）が完了した後に発火します：vim.api.nvim_create_autocmd(\"VimEnter\", {  callback = function()    -- プラグインの初期化    -- カラースキームの設定    -- ステータスラインの設定など  end,})2. バッファ操作のイベント系統バッファの作成から読み込みまでの主要なイベント：BufNew: バッファ作成直後BufAdd: バッファリストへの追加時BufReadPre: ファイル読み込み前BufReadPost: ファイル読み込み後BufEnter: バッファアクティブ化時vim.api.nvim_create_autocmd(\"BufReadPost\", {  pattern = \"*\",  callback = function()    -- ファイル読み込み後の処理    -- 最後のカーソル位置の復元など  end,})3. 編集モードのイベント系統テキスト編集に関連する主要なイベント：InsertEnter: 挿入モード開始時TextChangedI: 挿入モードでテキスト変更時InsertLeave: 挿入モード終了時TextChanged: ノーマルモードでテキスト変更時vim.api.nvim_create_autocmd(\"InsertEnter\", {  pattern = \"*\",  callback = function()    -- 挿入モード開始時の設定    -- 相対行番号の無効化など  end,})4. ファイル保存のイベント系統ファイル保存時の処理フロー：BufWritePre: 保存前BufWrite: 保存処理中BufWritePost: 保存後vim.api.nvim_create_autocmd(\"BufWritePre\", {  pattern = \"*\",  callback = function()    -- 保存前の自動整形    -- 末尾の空白除去など  end,})5. 終了時のイベント系統Neovim終了時の処理順序：QuitPre: 終了コマンド実行時VimLeavePre: 終了処理開始前VimLeave: 最終終了処理時vim.api.nvim_create_autocmd(\"VimLeavePre\", {  callback = function()    -- セッション保存    -- 未保存バッファの保存など  end,})実践的なサンプルコード以下は、よくある設定パターンの例です：-- ファイルタイプ別の設定vim.api.nvim_create_autocmd(\"FileType\", {  pattern = {\"python\", \"lua\", \"rust\"},  callback = function()    local settings = {      python = { indent = 4, expandtab = true },      lua = { indent = 2, expandtab = true },      rust = { indent = 4, expandtab = true }    }    local ft = vim.bo.filetype    if settings[ft] then      vim.bo.shiftwidth = settings[ft].indent      vim.bo.expandtab = settings[ft].expandtab    end  end,})-- 自動保存の設定vim.api.nvim_create_autocmd({\"InsertLeave\", \"TextChanged\"}, {  pattern = \"*\",  callback = function()    if vim.bo.modified and vim.bo.buftype == \"\" then      vim.cmd(\"silent! write\")    end  end,})-- 最後のカーソル位置を復元vim.api.nvim_create_autocmd(\"BufReadPost\", {  pattern = \"*\",  callback = function()    local last_pos = vim.fn.line(\"'\\\"\")    if last_pos \u003e 0 and last_pos \u003c= vim.fn.line(\"$\") then      vim.cmd('normal! g`\"')    end  end,})注意点イベントは適切な順序で処理される必要があります重い処理は非同期で行うことを推奨しますパターンマッチングを活用して、必要なファイルタイプのみで実行するようにしますvim.schedule()を使用して、UIブロッキングを避けます参考文献Neovim オートコマンドドキュメントAutocmd | 5. eventsNeovim Lua API リファレンスnvim_create_autocmd())","isoDate":"2024-11-26T17:33:03.000Z","dateMiliSeconds":1732642383000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Rustでterraform plan/apply のターゲット指定を簡単にするツールを作ってみた - tfocusの仕組みと使い方","link":"https://syu-m-5151.hatenablog.com/entry/2024/11/27/004309","contentSnippet":"1. はじめにこんにちは、nwiizoです。本記事では、Terraformで特定のリソースだけをplan/applyするためのインタラクティブCLIツール「tfocus」の設計と実装について、Rustの学習という観点も交えながら詳しく解説していきます。github.comまた、良さそうであればGithub Starsをいただきたいです。2. 背景と動機2.1 開発の契機大規模なTerraformコードベースでの作業において、様々な課題に直面することがあります。本番環境で特定リソースにトラブルが発生した際の調査や、開発中の変更を検証する場合、また大規模な変更を段階的に適用する必要がある場合などが典型的な例です。従来のTerraform CLIでも-targetオプションでリソースを指定できますが、正確なリソースパスを記述する必要があり、緊急時の運用には適していません。特に本番環境でのインシデント対応時には、迅速かつ正確なリソース指定が求められます。developer.hashicorp.com2.2 解決したい問題ツールの開発にあたり、複数の課題解決を目指しています。まずリソース選択を直感的に行えるようにすることで、運用者の負担を軽減します。同時に操作ミスを未然に防ぐ仕組みを導入し、安全性を確保します。また、緊急時にも迅速な対応ができるインターフェースを実現し、効率的なデバッグ作業を可能にすることで、運用効率の向上を図ります。3. 技術スタックの選定3.1 Rustを選んだ理由Rustを採用した理由は複数あります。まず、ゼロコスト抽象化による高いパフォーマンスを実現できることが挙げられます。また、強力な型システムと所有権モデルにより、メモリ安全性を確保できます。さらに、様々なOS向けにネイティブバイナリを生成できるクロスプラットフォーム対応も重要な選定理由となりました。豊富なクレートが利用可能な充実したエコシステムも、開発効率を高める要因となっています。最後に、純粋な学習目的として、小規模なツール開発を通じてRustの理解を深めることも目指しています。何かを引用するために書籍を貼ったが何を引用したいか忘れてしまった(がぎりぎりでこのブログを書いている為に調べることができない)。達人プログラマー ―熟達に向けたあなたの旅― 第2版作者:David Thomas,Andrew Huntオーム社Amazon3.2 主要な依存クレート[dependencies]walkdir = \"2.3\"      # ファイルシステム走査regex = \"1.5\"        # パターンマッチングclap = \"4.4\"         # CLIパーサーthiserror = \"1.0\"    # エラー型colored = \"2.0\"      # カラー出力crossterm = \"0.27\"   # TUIfuzzy-matcher = \"0.3\" # あいまい検索doc.rust-lang.org各クレートの選定理由：walkdir: 効率的な再帰的ファイル走査を提供regex: 高速で柔軟なパターンマッチングが可能clap: 型安全なCLI引数パーサーthiserror: エラー型の簡潔な定義crossterm: プラットフォーム独立なTUI実装fuzzy-matcher: 使いやすいあいまい検索機能4. 実装の詳細4.1 アーキテクチャ設計プロジェクトは機能ごとに明確に分離された以下のモジュール構成を採用しています：src/├── cli.rs        # CLIインターフェース├── display.rs    # 表示処理├── error.rs      # エラー型├── executor.rs   # Terraform実行├── input.rs      # 入力処理├── main.rs       # エントリーポイント├── project.rs    # プロジェクト解析├── selector.rs   # リソース選択UI└── types.rs      # 共通型定義各モジュールの責務：cli.rs: コマンドライン引数の定義と解析#[derive(Parser)]#[command(author, version, about)]pub struct Cli {    /// Terraformディレクトリのパス    #[arg(short, long, default_value = \".\")]    pub path: PathBuf,    /// 実行する操作    #[arg(short, long)]    pub operation: Option\u003cOperation\u003e,    /// 詳細出力の有効化    #[arg(short, long)]    pub verbose: bool,}project.rs: Terraformファイルの解析impl TerraformProject {    pub fn parse_directory(path: \u0026Path) -\u003e Result\u003cSelf\u003e {        let mut project = TerraformProject::new();        for file_path in Self::find_terraform_files(path)? {            project.parse_file(\u0026file_path)?;        }        Ok(project)    }    fn parse_file(\u0026mut self, path: \u0026Path) -\u003e Result\u003c()\u003e {        let content = fs::read_to_string(path)?;        self.parse_resources(\u0026content, path)?;        self.parse_modules(\u0026content, path)?;        Ok(())    }}4.2 エラーハンドリング型安全なエラーハンドリングを実現するため、カスタムエラー型を定義：#[derive(Error, Debug)]pub enum TfocusError {    #[error(\"IO error: {0}\")]    Io(#[from] std::io::Error),    #[error(\"Failed to parse terraform file: {0}\")]    ParseError(String),    #[error(\"Invalid target selection\")]    InvalidTargetSelection,    #[error(\"Terraform command failed: {0}\")]    TerraformError(String),    #[error(\"No terraform files found\")]    NoTerraformFiles,}4.3 リソース選択UIの実装fuzzy検索を活用した効率的なリソース選択：impl Selector {    fn filter_items(\u0026mut self) {        let query = self.query.to_lowercase();        let mut matches: Vec\u003c(usize, i64)\u003e = self            .items            .iter()            .enumerate()            .filter_map(|(index, item)| {                self.matcher                    .fuzzy_match(\u0026item.search_text.to_lowercase(), \u0026query)                    .map(|score| (index, score))            })            .collect();                // スコアでソート        matches.sort_by_key(|\u0026(_, score)| -score);        self.filtered_items = matches.into_iter()            .map(|(index, _)| index)            .collect();    }    fn render_screen(\u0026mut self) -\u003e Result\u003c()\u003e {        let mut stdout = stdout();        execute!(            stdout,            terminal::Clear(ClearType::All),            cursor::MoveTo(0, 0)        )?;                self.render_search_box()?;        self.render_items()?;        self.render_status_line()?;                stdout.flush()?;        Ok(())    }}4.4 パフォーマンス最適化実行速度とメモリ使用量の最適化：[profile.release]opt-level = 3        # 最高レベルの最適化lto = true          # リンク時最適化codegen-units = 1   # 単一コード生成ユニットstrip = true        # バイナリサイズ削減5. Rustから学ぶシステム設計tfocusの実装を通じて学べるRustの重要概念プログラミングRust 第2版作者:Jim Blandy,Jason Orendorff,Leonora F. S. TindallオライリージャパンAmazon5.1 所有権とライフタイムリソースの効率的な管理：impl Resource {    pub fn full_name(\u0026self) -\u003e String {        if self.is_module {            format!(\"module.{}\", self.name)        } else {            format!(\"{}.{}\", self.resource_type, self.name)        }    }}5.2 エラー伝播?演算子を使用した簡潔なエラーハンドリング：pub fn execute_terraform_command(    operation: \u0026Operation,    target_options: \u0026[String],) -\u003e Result\u003c()\u003e {    let mut command = Command::new(\"terraform\");    command.arg(operation.to_string());        for target in target_options {        command.arg(target);    }        let status = command.spawn()?.wait()?;        if status.success() {        Ok(())    } else {        Err(TfocusError::TerraformError(            \"Command execution failed\".to_string()        ))    }}5.3 トレイトの活用共通インターフェースの定義：pub trait Display {    fn render(\u0026self) -\u003e Result\u003c()\u003e;    fn update(\u0026mut self) -\u003e Result\u003c()\u003e;}6. まとめ6.1 現在の成果このプロジェクトは現在、直感的なリソース選択UIを実現し、クロスプラットフォームでの利用を可能にしています。また、効率的なメモリ使用を実現するとともに、型安全なエラーハンドリングを導入することで、安定性の向上にも成功しています。6.2 今後の展開使われるようになったらやっていきたいこと。機能拡張の面では、依存関係の可視化機能を導入し、リソース状態をより詳細に表示できるようにしたいと考えています。さらに、バッチ処理のサポートを追加することで、大規模な処理にも対応できるようにしていきます。品質向上については、テストカバレッジを拡大し、システム全体のパフォーマンスを最適化していく予定です。また、エラーメッセージをより分かりやすく改善することで、ユーザー体験の向上を図ります。ドキュメント整備においては、API文書を充実させ、初心者向けのチュートリアルを作成していきます。さらに、実際の使用シーンを想定したユースケース集を整備することで、ユーザーの理解促進を支援していきたいと考えています。おわりにtfocusの開発を通じて、RustとTerraformの実践的な活用方法を示しました。このツールが皆様のインフラ運用の一助となれば幸いです。コードはGitHubで公開しています：nwiizo/tfocusフィードバックやコントリビューションをお待ちしています。","isoDate":"2024-11-26T15:43:09.000Z","dateMiliSeconds":1732635789000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"RustでJSONを扱いたいのでSerde入門します","link":"https://syu-m-5151.hatenablog.com/entry/2024/11/26/141035","contentSnippet":"はじめにRustでデータのシリアライズ/デシリアライズを扱う際、最も広く使われているのがserdeクレートです。特にWeb APIやファイル入出力でよく使用されるJSONとの相互変換において、非常に重宝するツールです。今回は、serdeの基本的な使い方と、開発効率を上げるためのツールについて解説します。SerdeとはSerdeは\"Serialize\"と\"Deserialize\"を組み合わせた造語で、データ構造の変換を担当するRustのフレームワークです。多様なデータフォーマットに対応（JSON、YAML(アーカイブされている)、TOML等）高性能で型安全な実装カスタマイズ可能な属性システムコード生成による簡単な実装docs.rsプロジェクトのセットアップまず、Cargo.tomlに必要な依存関係を追加します。[dependencies]serde = { version = \"1.0\", features = [\"derive\"] }serde_json = \"1.0\"基本的な使い方1. 構造体の定義use serde::{Serialize, Deserialize};#[derive(Serialize, Deserialize, Debug)]struct User {    name: String,    age: u32,    email: String,    is_active: bool,}2. JSONからRustへの変換（デシリアライズ）fn main() {    let json_str = r#\"    {        \"name\": \"John Doe\",        \"age\": 30,        \"email\": \"john@example.com\",        \"is_active\": true    }    \"#;    let user: User = serde_json::from_str(json_str).unwrap();    println!(\"Deserialized user: {:?}\", user);}3. RustからJSONへの変換（シリアライズ）fn main() {    let user = User {        name: \"Jane Doe\".to_string(),        age: 25,        email: \"jane@example.com\".to_string(),        is_active: true,    };    let json = serde_json::to_string_pretty(\u0026user).unwrap();    println!(\"Serialized JSON:\\n{}\", json);}JSON to Rust ツールの活用開発効率を大幅に向上させるツールとして、「JSON to Rust」があります。このツールは、JSONデータからRustの構造体定義を自動生成してくれます。JSON to Rustの使い方https://jsonformatter.org/json-to-rust にアクセス左側のペインにJSONデータを貼り付け自動的に右側にRustの構造体定義が生成される例えば、以下のようなJSONデータがあった場合{    \"user_profile\": {        \"id\": 123,        \"username\": \"rust_lover\",        \"settings\": {            \"theme\": \"dark\",            \"notifications\": true        },        \"tags\": [\"rust\", \"programming\"]    }}以下のようなRust構造体が生成されます。// Example code that deserializes and serializes the model.// extern crate serde;// #[macro_use]// extern crate serde_derive;// extern crate serde_json;//// use generated_module::[object Object];//// fn main() {//     let json = r#\"{\"answer\": 42}\"#;//     let model: [object Object] = serde_json::from_str(\u0026json).unwrap();// }extern crate serde_derive;#[derive(Serialize, Deserialize)]pub struct Welcome3 {    #[serde(rename = \"user_profile\")]    user_profile: UserProfile,}#[derive(Serialize, Deserialize)]pub struct UserProfile {    #[serde(rename = \"id\")]    id: i64,    #[serde(rename = \"username\")]    username: String,    #[serde(rename = \"settings\")]    settings: Settings,    #[serde(rename = \"tags\")]    tags: Vec\u003cString\u003e,}#[derive(Serialize, Deserialize)]pub struct Settings {    #[serde(rename = \"theme\")]    theme: String,    #[serde(rename = \"notifications\")]    notifications: bool,}高度な使い方カスタム属性の活用Serdeは様々な属性を提供して、シリアライズ/デシリアライズの挙動をカスタマイズできます。#[derive(Serialize, Deserialize, Debug)]struct Configuration {    #[serde(rename = \"apiKey\")]    api_key: String,        #[serde(default)]    timeout_seconds: u32,        #[serde(skip_serializing_if = \"Option::is_none\")]    optional_field: Option\u003cString\u003e,}エラーハンドリング実際のアプリケーションでは、適切なエラーハンドリングが重要です。use serde::{Serialize, Deserialize};use std::error::Error;use std::fs;use std::io;use std::collections::HashMap;// ユーザーの基本構造体#[derive(Serialize, Deserialize, Debug)]struct User {    id: u32,    name: String,    age: u32,    email: String,    is_active: bool,    // オプショナルなフィールド    #[serde(skip_serializing_if = \"Option::is_none\")]    metadata: Option\u003cHashMap\u003cString, String\u003e\u003e,}// カスタムエラー型の定義#[derive(Debug)]enum UserError {    ParseError(serde_json::Error),    // JSONパースエラー    ValidationError(String),          // バリデーションエラー    DatabaseError(String),            // DB操作エラー    IoError(io::Error),              // ファイル操作エラー}// serde_json::ErrorからUserErrorへの変換を実装impl From\u003cserde_json::Error\u003e for UserError {    fn from(err: serde_json::Error) -\u003e UserError {        UserError::ParseError(err)    }}// io::ErrorからUserErrorへの変換を実装impl From\u003cio::Error\u003e for UserError {    fn from(err: io::Error) -\u003e UserError {        UserError::IoError(err)    }}// std::error::Errorトレイトの実装impl std::fmt::Display for UserError {    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {        match self {            UserError::ParseError(e) =\u003e write!(f, \"Parse error: {}\", e),            UserError::ValidationError(msg) =\u003e write!(f, \"Validation error: {}\", msg),            UserError::DatabaseError(msg) =\u003e write!(f, \"Database error: {}\", msg),            UserError::IoError(e) =\u003e write!(f, \"IO error: {}\", e),        }    }}impl Error for UserError {}// Userの実装impl User {    // バリデーションメソッド    fn validate(\u0026self) -\u003e Result\u003c(), UserError\u003e {        if self.name.is_empty() {            return Err(UserError::ValidationError(\"Name cannot be empty\".to_string()));        }        if self.age \u003e 150 {            return Err(UserError::ValidationError(\"Invalid age\".to_string()));        }        if !self.email.contains('@') {            return Err(UserError::ValidationError(\"Invalid email format\".to_string()));        }        Ok(())    }}// 基本的なJSONパース関数fn parse_user(json_str: \u0026str) -\u003e Result\u003cUser, serde_json::Error\u003e {    // map_errを使用してエラーをログ出力    serde_json::from_str(json_str).map_err(|e| {        println!(\"Error parsing JSON: {}\", e);        e  // 元のエラーを返す    })}// より詳細なエラーハンドリングを行う関数fn process_user_data(json_str: \u0026str) -\u003e Result\u003cUser, UserError\u003e {    // JSONのパース    let user: User = serde_json::from_str(json_str)?;  // ?演算子でエラーを伝播        // バリデーション    user.validate()?;  // ?演算子でエラーを伝播        Ok(user)}// 複数ユーザーからの検索（Option型との組み合わせ）fn find_user_by_id(json_str: \u0026str, target_id: u32) -\u003e Result\u003cOption\u003cUser\u003e, UserError\u003e {    // JSONから複数ユーザーをパース    let users: Vec\u003cUser\u003e = serde_json::from_str(json_str)?;        // 指定されたIDのユーザーを探す    Ok(users.into_iter().find(|user| user.id == target_id))}// ファイル操作を含むエラーハンドリングfn load_user_from_file(path: \u0026str) -\u003e Result\u003cUser, UserError\u003e {    // ファイルを読み込み    let content = fs::read_to_string(path).map_err(|e| {        eprintln!(\"Failed to read file {}: {}\", path, e);        UserError::IoError(e)    })?;    // JSONをパースしてUserを返す    process_user_data(\u0026content)}// ファイルへの保存fn save_user_to_file(user: \u0026User, path: \u0026str) -\u003e Result\u003c(), UserError\u003e {    // UserをJSONに変換    let json = serde_json::to_string_pretty(user).map_err(|e| {        eprintln!(\"Failed to serialize user: {}\", e);        UserError::ParseError(e)    })?;    // ファイルに書き込み    fs::write(path, json).map_err(|e| {        eprintln!(\"Failed to write to file {}: {}\", path, e);        UserError::IoError(e)    })?;    Ok(())}fn main() {    // 1. 有効なJSONの例    let valid_json = r#\"        {            \"id\": 1,            \"name\": \"John Doe\",            \"age\": 30,            \"email\": \"john@example.com\",            \"is_active\": true,            \"metadata\": {                \"last_login\": \"2024-01-01\",                \"location\": \"Tokyo\"            }        }    \"#;    // 2. 無効なJSONの例（バリデーションエラー）    let invalid_json = r#\"        {            \"id\": 2,            \"name\": \"\",            \"age\": 200,            \"email\": \"invalid-email\",            \"is_active\": true        }    \"#;    // 3. 複数ユーザーのJSONの例    let users_json = r#\"[        {            \"id\": 1,            \"name\": \"John Doe\",            \"age\": 30,            \"email\": \"john@example.com\",            \"is_active\": true        },        {            \"id\": 2,            \"name\": \"Jane Doe\",            \"age\": 25,            \"email\": \"jane@example.com\",            \"is_active\": true        }    ]\"#;    // 4. 各種エラーハンドリングの実演    println!(\"1. 基本的なパース:\");    match parse_user(valid_json) {        Ok(user) =\u003e println!(\"成功: {:?}\", user),        Err(e) =\u003e println!(\"エラー: {}\", e),    }    println!(\"\\n2. バリデーション付きパース:\");    match process_user_data(invalid_json) {        Ok(user) =\u003e println!(\"成功: {:?}\", user),        Err(e) =\u003e println!(\"エラー: {}\", e),    }    println!(\"\\n3. ユーザー検索:\");    match find_user_by_id(users_json, 1) {        Ok(Some(user)) =\u003e println!(\"ユーザーが見つかりました: {:?}\", user),        Ok(None) =\u003e println!(\"ユーザーが見つかりません\"),        Err(e) =\u003e println!(\"エラー: {}\", e),    }    println!(\"\\n4. ファイル操作:\");    // 有効なユーザーをファイルに保存    if let Ok(user) = parse_user(valid_json) {        match save_user_to_file(\u0026user, \"user.json\") {            Ok(()) =\u003e println!(\"ユーザーを保存しました\"),            Err(e) =\u003e println!(\"保存エラー: {}\", e),        }        // 保存したファイルから読み込み        match load_user_from_file(\"user.json\") {            Ok(loaded_user) =\u003e println!(\"ロードしたユーザー: {:?}\", loaded_user),            Err(e) =\u003e println!(\"ロードエラー: {}\", e),        }    }}ベストプラクティス型の使い分け必須フィールドは通常の型オプショナルフィールドはOption\u003cT\u003e配列はVec\u003cT\u003eを使用エラーハンドリングunwrap()は開発時のみ使用本番コードではResultを適切に処理カスタム属性の活用#[serde(rename)]でフィールド名の変換#[serde(default)]でデフォルト値の設定#[serde(skip_serializing_if)]で条件付きスキップまず、Cargo.tomlにchronoの依存関係を追加します。use chrono;use serde::{Deserialize, Serialize};use std::collections::HashMap;use std::error::Error as StdError;use std::fmt;use std::fs; // chronoクレートのインポート// ベストプラクティスに基づいた構造体の定義#[derive(Serialize, Deserialize, Debug)]struct UserProfile {    // 1. 必須フィールド（通常の型）    id: u64,    username: String,    email: String,    // 2. オプショナルフィールド（Option\u003cT\u003eの使用）    #[serde(skip_serializing_if = \"Option::is_none\")]    phone_number: Option\u003cString\u003e,    #[serde(skip_serializing_if = \"Option::is_none\")]    biography: Option\u003cString\u003e,    // 3. 配列（Vec\u003cT\u003eの使用）    #[serde(skip_serializing_if = \"Vec::is_empty\")]    interests: Vec\u003cString\u003e,    // 4. カスタム属性の活用    // JSONでは\"lastLoginTime\"として表示    #[serde(rename = \"lastLoginTime\")]    last_login_time: String,    // デフォルト値の設定    #[serde(default)]    is_active: bool,    // 動的なキーバリューペア    #[serde(default, skip_serializing_if = \"HashMap::is_empty\")]    metadata: HashMap\u003cString, String\u003e,}// カスタムエラー型の定義#[derive(Debug)]enum ProfileError {    JsonError(serde_json::Error),    ValidationError(String),    IoError(std::io::Error),}// ProfileErrorにDisplayトレイトを実装impl fmt::Display for ProfileError {    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {        match self {            ProfileError::JsonError(e) =\u003e write!(f, \"JSON error: {}\", e),            ProfileError::ValidationError(e) =\u003e write!(f, \"Validation error: {}\", e),            ProfileError::IoError(e) =\u003e write!(f, \"IO error: {}\", e),        }    }}// ProfileErrorにErrorトレイトを実装impl StdError for ProfileError {    fn source(\u0026self) -\u003e Option\u003c\u0026(dyn StdError + 'static)\u003e {        match self {            ProfileError::JsonError(e) =\u003e Some(e),            ProfileError::ValidationError(_) =\u003e None,            ProfileError::IoError(e) =\u003e Some(e),        }    }}// エラー変換の実装impl From\u003cserde_json::Error\u003e for ProfileError {    fn from(err: serde_json::Error) -\u003e Self {        ProfileError::JsonError(err)    }}impl From\u003cstd::io::Error\u003e for ProfileError {    fn from(err: std::io::Error) -\u003e Self {        ProfileError::IoError(err)    }}// UserProfileの実装impl UserProfile {    // コンストラクタ    fn new(id: u64, username: String, email: String) -\u003e Self {        UserProfile {            id,            username,            email,            phone_number: None,            biography: None,            interests: Vec::new(),            last_login_time: chrono::Utc::now().to_rfc3339(),            is_active: true,            metadata: HashMap::new(),        }    }    // バリデーション    fn validate(\u0026self) -\u003e Result\u003c(), ProfileError\u003e {        if self.username.is_empty() {            return Err(ProfileError::ValidationError(                \"Username cannot be empty\".to_string(),            ));        }        if !self.email.contains('@') {            return Err(ProfileError::ValidationError(                \"Invalid email format\".to_string(),            ));        }        Ok(())    }    // メタデータの追加    fn add_metadata(\u0026mut self, key: \u0026str, value: \u0026str) {        self.metadata.insert(key.to_string(), value.to_string());    }    // 興味・関心の追加    fn add_interest(\u0026mut self, interest: \u0026str) {        self.interests.push(interest.to_string());    }}// プロファイル処理関数fn process_profile(json_str: \u0026str) -\u003e Result\u003cUserProfile, ProfileError\u003e {    // JSONからプロファイルを作成    let profile: UserProfile = serde_json::from_str(json_str)?;    // バリデーション    profile.validate()?;    Ok(profile)}// ファイル操作を含むプロファイル保存fn save_profile(profile: \u0026UserProfile, path: \u0026str) -\u003e Result\u003c(), ProfileError\u003e {    // バリデーション    profile.validate()?;    // JSON文字列に変換（整形付き）    let json = serde_json::to_string_pretty(profile)?;    // ファイルに保存    fs::write(path, json)?;    Ok(())}fn main() -\u003e Result\u003c(), Box\u003cdyn StdError\u003e\u003e {    // 1. プロファイルの作成    let mut profile = UserProfile::new(1, \"john_doe\".to_string(), \"john@example.com\".to_string());    // オプショナルフィールドの設定    profile.phone_number = Some(\"123-456-7890\".to_string());    profile.biography = Some(\"Tech enthusiast and developer\".to_string());    // 興味・関心の追加    profile.add_interest(\"Programming\");    profile.add_interest(\"Open Source\");    // メタデータの追加    profile.add_metadata(\"location\", \"Tokyo\");    profile.add_metadata(\"timezone\", \"UTC+9\");    // 2. JSONへの変換と保存    println!(\"保存するプロファイル:\");    println!(\"{:#?}\", profile);    save_profile(\u0026profile, \"profile.json\").map_err(|e| Box::new(e) as Box\u003cdyn StdError\u003e)?;    println!(\"\\nプロファイルを保存しました\");    // 3. JSONからの読み込みとバリデーション    let json_str = r#\"{        \"id\": 2,        \"username\": \"jane_doe\",        \"email\": \"jane@example.com\",        \"phone_number\": \"098-765-4321\",        \"biography\": \"Software Engineer\",        \"interests\": [\"AI\", \"Machine Learning\"],        \"lastLoginTime\": \"2024-01-01T00:00:00Z\",        \"metadata\": {            \"location\": \"Osaka\",            \"language\": \"ja\"        }    }\"#;    match process_profile(json_str) {        Ok(loaded_profile) =\u003e {            println!(\"\\n読み込んだプロファイル:\");            println!(\"{:#?}\", loaded_profile);        }        Err(e) =\u003e match e {            ProfileError::JsonError(e) =\u003e println!(\"JSONエラー: {}\", e),            ProfileError::ValidationError(e) =\u003e println!(\"バリデーションエラー: {}\", e),            ProfileError::IoError(e) =\u003e println!(\"I/Oエラー: {}\", e),        },    }    // 4. 無効なデータの例    let invalid_json = r#\"{        \"id\": 3,        \"username\": \"\",        \"email\": \"invalid-email\"    }\"#;    match process_profile(invalid_json) {        Ok(_) =\u003e println!(\"予期せぬ成功\"),        Err(e) =\u003e match e {            ProfileError::ValidationError(msg) =\u003e {                println!(\"\\nバリデーションエラー（期待通り）: {}\", msg)            }            _ =\u003e println!(\"予期せぬエラー\"),        },    }    Ok(())}まとめSerdeは、RustでJSONを扱う際の強力なツールです。JSON to Rustのようなツールと組み合わせることで、より効率的な開発が可能になります。基本的な使い方を押さえた上で、プロジェクトの要件に応じて高度な機能を活用していくことをお勧めします。参考リンクSerde公式ドキュメントJSON to Rust Converterserde_json クレートドキュメント","isoDate":"2024-11-26T05:10:35.000Z","dateMiliSeconds":1732597835000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"私の為のNvChadのキーマッピングガイド","link":"https://syu-m-5151.hatenablog.com/entry/2024/11/24/171651","contentSnippet":"はじめに私は定期的に必要なことを忘れてしまう。子ども時代に水を口に入れて水の飲み方を忘れてしまったことがある。大切なことを今まで普通にできたことが急にできなくなることがある。学習もそう、定期的に復習して思い出すことが大切だと感じているが突然忘れてしまうことがある。突然忘れてしまうと探す必要があるが毎回探すのが面倒になってきたのでNvChadのキーマッピングをまとめてみた。基本的なショートカット表記\u003cC\u003e = Ctrlキー\u003cleader\u003e = スペースキー（デフォルト）\u003cA\u003e = Altキー\u003cS\u003e = Shiftキーよく使う機能とそのキーマッピング1. ファイル操作で必須のコマンド\u003cC-s\u003e    - 保存（これだけは絶対覚える。:w なんてやっているとvsCodeを使っている人にバカにされる）\u003cC-c\u003e    - ファイル全体をコピー（便利）\u003cleader\u003efm - フォーマット（コードを整形してくれる）\u003cleader\u003en  - 行番号の表示/非表示\u003cleader\u003ern - 相対行番号の切り替え2. 検索系（Telescope）検索系は本当によく使うので、最優先で覚えたいです。\u003cleader\u003eff - ファイル検索（最重要）\u003cleader\u003efw - プロジェクト内のテキスト検索（grep）\u003cleader\u003efb - 開いているバッファを検索\u003cleader\u003efo - 最近開いたファイルを検索\u003cleader\u003efz - 現在のバッファ内をあいまい検索\u003cleader\u003ecm - Gitコミットを検索\u003cleader\u003egt - Gitのステータスを表示github.com3. LSP関連（コードジャンプ・リファレンス）コードリーディングする時に本当に助かる機能たちです。gd - 定義へジャンプ（最も使う）gr - 参照を探す（変数やメソッドの使用箇所を探せる）K  - ドキュメントを表示（カーソル位置の要素の説明を表示）gi - 実装へジャンプ（インターフェースから実装を探せる）\u003cleader\u003eds - 診断情報をloclistに表示github.com4. 画面分割とウィンドウ移動複数のファイルを同時に見たい時に使います。\u003cC-h\u003e - 左のウィンドウへ\u003cC-l\u003e - 右のウィンドウへ\u003cC-j\u003e - 下のウィンドウへ\u003cC-k\u003e - 上のウィンドウへ5. バッファ操作\u003cleader\u003eb - 新しいバッファを開く\u003ctab\u003e - 次のバッファへ\u003cS-tab\u003e - 前のバッファへ\u003cleader\u003ex - バッファを閉じる6. ターミナル操作ターミナルは必要に応じて呼び出せます。\u003cA-i\u003e - フローティングターミナル（これが一番便利）\u003cA-h\u003e - 水平分割のターミナル\u003cA-v\u003e - 垂直分割のターミナル\u003cC-x\u003e - ターミナルモードを抜ける7. その他の便利機能\u003cleader\u003ech - チートシート表示（キーマッピングを忘れた時用）\u003cleader\u003e/  - コメントアウトのトグル\u003cC-n\u003e     - ファイルツリーの表示/非表示\u003cleader\u003ee  - ファイルツリーにフォーカス\u003cEsc\u003e     - ハイライトをクリアなぜこれらのキーマッピングを覚える必要があるのか私の経験上、以下の機能は開発効率を大きく向上させてくれます。ファイル検索（Telescope）プロジェクト内のファイルを素早く見つけられるコードベースの把握が容易になるGit操作との連携で変更管理がしやすいLSP機能コードの定義や参照を素早く調べられるリファクタリングが楽になるコードの理解が深まるエラー診断が即座にわかるRust を書いていると 1 箇所書き換えると芋づる式に修正が発生するのでどうしても必要になる。ターミナル統合エディタを離れずにコマンドを実行できるgit操作やビルドが快適フローティング表示で作業の邪魔にならないバッファ管理複数ファイルの編集がスムーズ必要なファイルをすぐに切り替えられるなぜNvChadを選んだのか実は、私のエディタ遍歴は長い。最初はVimから始まり、その後SpaceVim、AstroNvim、LunarVimなど、様々なNeovim系のディストリビューションを試してきた。VSCodeやIntelliJ IDEAのVimプラグインも使っていた時期がある。その過程で、Vimのキーバインドの快適さと、モダンなIDEの便利さ、その両方の良さを実感していた。ただ、どれも何かが違った。なんとなくしっくりこない。そんな中で出会ったのがNvChadだった。そんな中でNvChadに出会い、決め手となったのは開発体制の健全さだった。リポジトリは定期的に更新され、ドキュメントも整備されている。破壊的な変更がある場合も、きちんとアナウンスされ、移行のガイドラインが提供される。コミュニティも活発で、問題が起きた時のサポートも期待できる。nvchad.comさらに、NvChadの設計思想も気に入った。必要最小限の機能を高速に動作させることを重視し、その上で必要な機能を追加できる拡張性を持っている。プラグインマネージャーにlazy.nvimを採用し、起動時間の最適化もされている。LSPやTreeSitterの統合も洗練されており、快適なコーディング環境を提供してくれる。結果として、NvChadは私の理想とするエディタ環境に最も近かった。Vimの哲学を大切にしながら、モダンな開発環境を実現している。もちろん、完璧なエディタは存在しないし、NvChadにも改善の余地はきっとある。しかし、現時点で最も信頼できる選択肢の一つであることは間違いない。Vimを学ぶために通常のVimを学ぶ場合は、「実践Vim 思考のスピードで編集しよう！」がおすすめだ。Vimの基本から応用までを体系的に学べ、実践的な例も豊富に掲載されている。実践Vim　思考のスピードで編集しよう！ (アスキー書籍)作者:Ｄｒｅｗ Ｎｅｉｌ,新丈 径角川アスキー総合研究所Amazonまた、Vim Adventuresというゲームも面白い。ゲーム感覚でVimのキー操作を学べ、楽しみながら基本的なコマンドが身につく。初心者にも優しい学習カーブで、Vimの世界に入るきっかけとして最適だ。vim-adventures.comしかし、NvChadはこれらの基本的なVimの知識に加えて、モダンなIDE的機能を提供してくれる。このガイドでは、特にNvChad特有の機能に焦点を当てて説明しました。私自身、日々の開発作業でNvChadの恩恵を受けており、その便利さを多くの人と共有したいと考えている。まとめ私はVimを使い始めて数年経つが、今でも新しい発見がある。NvChadも同様で、日々の作業の中で「こんな機能があったのか」と驚かされることが多い。最初は覚えることの多さに圧倒されるかもしれないが、焦る必要はない。私の経験では、まずは基本的なファイル操作から始めるのが良い。保存やコピーといった最低限の操作を確実に覚えることで、日常的な編集作業に支障がなくなる。次に、Telescopeによるファイル検索を習得すると、作業効率が格段に上がる。プロジェクト内のファイルを瞬時に探せるようになり、コードベースの把握も容易になる。その後、LSPの基本機能を学んでいくと良いだろう。定義ジャンプやドキュメント表示は、コードリーディングの強力な味方となる。ウィンドウ操作とバッファ管理、ターミナル操作は、これらの基本操作に慣れてから徐々に取り入れていけば良い。結局のところ、エディタは道具でしかない。完璧に使いこなす必要はなく、自分の作業をサポートしてくれる程度に理解していれば十分だ。このガイドも、そんな私のような「忘れっぽいプログラマー」のための備忘録として活用してもらえれば幸いだ。少しずつでも確実に、自分なりのNvChadの使い方を見つけていってほしい。参考リンクNvChad公式ドキュメントGitHub - NvChad/NvChadNeovim LSP Documentation","isoDate":"2024-11-24T08:16:51.000Z","dateMiliSeconds":1732436211000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"先人の知見から学ぶ、その経験則","link":"https://syu-m-5151.hatenablog.com/entry/2024/11/20/122114","contentSnippet":"この度、Cloud Native における最新の機能やベストプラクティスにおいての学びについて、登壇させていただくことになりました。このテーマについて私なりに取り留めのない思考を整理した考えを共有させていただきます。event.cloudnativedays.jpソフトウェアエンジニアリングの型についてソフトウェアの世界には、プログラミング言語における変数やデータの「型」とは別に、長年の経験と知恵から生まれた様々な型が存在します。ここでいう「型」とは、開発者の思考や行動のパターンを体系化したものを指します。これらの型は、プログラマーが日々直面する問題に対する体系的な解決策を提供します。こうした型は、文脈や状況によって様々な呼び方をします。例えば、同じような問題解決のアプローチでも、ある文脈では「パターン」、別の文脈では「ベストプラクティス」と呼ばれることがあります。また、同じような設計手法でも、技術スタックやチームの文化によって異なる名前で知られていることもあります。このように、型の呼び方は多様ですが、その本質は問題解決のための知恵の結晶であることは変わりません。そのため、このブログでは意図的に「定石」「パターン」「手法」「アプローチ」「作法」「ベストプラクティス」など、様々な呼び方を用いて型を説明していきます。これは、同じような概念や手法が異なる文脈で別の名前で呼ばれている実態を反映させるためです。それぞれの呼び方が持つニュアンスの違いを理解することで、型に対するより深い理解が得られると考えています。いろんな名前の型の種類と特徴まず「定石」は、特定の状況下での最適な対処方法を示します。例えば、データベースにおけるN+1問題の解決方法やメモリリーク対策の手順など、具体的な技術的課題に対する確立された解決策です。次に「パターン」は、一般的な設計上の問題に対する標準的な解決策を提供します。いくつかの文脈で登場しますがコードやソフトウェアの構造化と再利用性を高めます。「手法」は開発プロセスを改善するための具体的な方法論を指します。テスト駆動開発（TDD）、リファクタリング、継続的インテグレーションなどが該当し、より体系的な開発アプローチを可能にします。「アプローチ」は問題解決への基本的な考え方や戦略を示し、ドメイン駆動設計（DDD）やマイクロサービスアーキテクチャなどが含まれます。また、「作法」はコードの品質と保守性を高めるための慣習を表します。SOLID原則、クリーンコード、命名規則などがこれにあたり、チーム開発における共通理解を促進します。「ベストプラクティス」は実践で効果が実証された推奨される方法であり、セキュリティ対策、パフォーマンスチューニング、エラー処理などの具体的な実装手法を含みます。他にも同じような文脈なのにいろんな言い方の「型」があります。aws.amazon.comlearn.microsoft.comcloud.google.com型の重要な特性これらの型には、いくつかの重要な特性があります。まず状況依存性があり、プロジェクトの規模や要件、チームの習熟度、ビジネスドメインによって最適な型が変化します。また、進化と適応の性質も持ち合わせており、新しい技術の登場により型自体が進化したり、既存の型が新しい文脈で再解釈されたり、チームの経験を通じて洗練されていきます。さらに、相互補完性も重要な特性です。複数の型を組み合わせることで相乗効果が生まれ、異なる型が互いの弱点を補完し合います。状況に応じて型を柔軟に組み合わせることが、効果的な問題解決には不可欠です。このように、ソフトウェアにおける「型」は、単なる規則や制約ではなく、効果的な問題解決のための知識体系として機能しています。これらの型を理解し、適切に活用することで、より効率的で品質の高い開発が可能になります。型の存在を認識し、その本質を理解することは、プログラマーとしての成長において重要な要素となるでしょう。プリンシプル オブ プログラミング 3年目までに身につけたい 一生役立つ101の原理原則作者:上田勲秀和システムAmazonどの巨人の型に乗るのか？ソフトウェアの世界で「定石」を学ぶことは、ある種の賭けのような性質を持っています。最初は論理的な理解が難しい概念や方法論を受け入れる必要があるにもかかわらず、その価値は実践してみないとわからないという矛盾を抱えているためです。多くの場合、「きっと将来役立つはず」という信念に基づいて学習を進める必要があります。この学習における矛盾は、特に高度な開発手法を習得する際に顕著に現れます。例えば、テスト駆動開発（TDD）の習得では、最初はテストを先に書くという一見非効率に思える手法に違和感を覚えるでしょう。しかし、この手法の真価は、実際にプロジェクトで実践し、コードの品質向上や保守性の改善を体験してはじめて理解できます。同様に、アーキテクチャ設計原則の導入においても、初期段階では過度に複雑に感じられる設計パターンや抽象化の価値を理解することは困難です。デザインパターンの学習や関数型プログラミングの考え方も、習得には相当な時間と労力を要します。これらの知識は、直接的な効果が見えにくい一方で、長期的には開発効率と品質を大きく向上させる可能性を秘めています。このジレンマを乗り越えるためには、段階的な学習アプローチと実践を通じた検証が重要になります。小規模なプロジェクトや個人的な開発で新しい手法を試し、その効果を実感することから始めることで、より大きなプロジェクトでの適用に向けた確信と経験を積むことができます。ルールズ・オブ・プログラミング ―より良いコードを書くための21のルール作者:Chris Zimmermanオーム社Amazon作法の習得における難しさ確立された手法（パターン）の習得には、独特の困難さが伴います。その中でも特に重要な課題として、習得前後のジレンマと成長段階による最適解の変化が挙げられます。まず、習得前後のジレンマについて考えてみましょう。体得するまでは本当の価値がわからないという特徴は、多くの開発手法に共通しています。例えば、ある設計パターンを学び始めた時点では、それがどのような状況でどれほどの効果を発揮するのか、具体的にイメージすることが困難です。さらに厄介なことに、体得してしまうと、その影響を客観的に評価しづらくなるという逆説的な問題も存在します。手法が無意識のうちに身についてしまうと、その手法を使わない場合との比較が難しくなり、問題が発生した際に、その原因がパターンの適用にあるのか、それとも他の要因によるものなのか、判断が困難になってしまいます。次に、成長段階による最適解の変化について着目する必要があります。プログラマーとしての習熟度によって最適な手法が変わるというのは、多くの現場で観察される現象です。例えば、初級者の段階では、まずはシンプルな実装手法に焦点を当て、基本的なプログラミングスキルを確実に身につけることが重要です。中級者になると、設計パターンの理解と適切な適用が課題となり、コードの構造化や再利用性を意識した開発が求められるようになります。上級者では、さらに進んで、パターンの取捨選択や状況に応じた最適化が必要となります。また、チームの規模や製品の成熟度によっても適切なアプローチは変化します。小規模なチームでは比較的シンプルな設計で十分な場合でも、チームが大きくなるにつれて、より体系的なアプローチが必要となることがあります。同様に、プロダクトの初期段階では迅速な開発を優先し、成熟期に入ってからより洗練された設計パターンを導入するなど、状況に応じた柔軟な対応が求められます。このように、作法の習得プロセスは単純な知識の蓄積ではなく、様々な要因を考慮しながら、継続的に改善と適応を行っていく必要のある複雑な取り組みと言えます。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazon不適切なパターンを見分けるための3つの条件複雑さという落とし穴不適切なパターンの最も顕著な特徴は、シンプルさの欠如です。優れたパターンには、核となる概念がシンプルで説明が簡潔であり、様々な状況への応用が柔軟に可能という特徴があります。このシンプルさは、単なる実装の簡素さだけでなく、パターンが解決しようとする問題と解決方法の関係性が明確であることを意味します。一方で、複雑な条件分岐が多い実装手法や、例外処理が複雑に絡み合ったエラーハンドリング、過度に抽象化された設計パターンなどは、保守性を低下させる要因となりかねません。特に、抽象化の層が必要以上に深くなると、コードの見通しが悪くなり、バグの温床となる可能性があります。シンプルさを欠いたパターンは、チームメンバー間での共有や理解を困難にし、結果として開発効率の低下やメンテナンスコストの増大を招くことがあります。批判を許さない教条主義検証がタブー視されている状況は、不適切なパターンの存在を示す重要な指標です。「それが会社の方針だから」という説明やレガシーコードの無批判な踏襲、特定の実装パターンへの過度な信仰は、危険な兆候と言えます。このような状況では、パターンの有効性や適用範囲について、客観的な評価や建設的な議論が行われにくくなります。定石の効果は常に検証可能であるべきであり、新しい技術やアプローチとの比較検討を行える環境が必要です。また、チーム内で改善提案が歓迎される雰囲気を醸成することも、健全なパターン活用には不可欠です。例えば、定期的なコードレビューやアーキテクチャ検討会での議論、実装パターンの効果測定など、具体的な検証の機会を設けることが重要です。パターンの効果や適用方法について、オープンな議論と継続的な改善が可能な環境を整えることで、より適切なパターンの選択と進化が促進されます。また、新しいチームメンバーからの質問や疑問を歓迎する文化を作ることで、既存のパターンの妥当性を定期的に見直すきっかけにもなります。魔法の解決策という幻想パターンに対する過度な期待は、不適切な適用を引き起こす大きな要因です。特定のアーキテクチャやパターンへの過度な期待や、新しいフレームワークやツールへの盲目的な信仰は、実装の複雑化や運用コストの増大を引き起こす可能性があります。特に、「銀の弾丸」を求める姿勢は、現実的な問題解決を見失わせる原因となりかねません。どんなパターンにも適用範囲や限界があることを認識し、状況に応じた適切な選択を行うことが重要です。例えば、マイクロサービスアーキテクチャは分散システムの柔軟性を高める可能性がありますが、運用の複雑さやネットワークの信頼性など、新たな課題も同時にもたらします。期待と現実のギャップを冷静に評価し、パターンの適用による実際の効果を慎重に見極める必要があります。これには、パターン導入前後での定量的な指標の比較や、チームメンバーからのフィードバック収集、実際のユーザーへの影響分析など、多角的な評価アプローチが求められます。また、パターンの導入は段階的に行い、各段階での効果を確認しながら進めることで、リスクを最小限に抑えることができます。仮説思考―ＢＣＧ流　問題発見・解決の発想法 内田和成の思考作者:内田 和成東洋経済新報社Amazon定石の進化と検証確立された手法は、暫定的な真実としての性質を持っています。これは、定石が先人の経験則の集大成として形成されながらも、常に改善の余地があるという特徴を示しています。時代とともに技術は進化し、新しい方法論が生まれることで、既存の定石が見直されたり置き換わったりすることは珍しくありません。この変化を受け入れ、柔軟に適応していく姿勢が重要です。また、定石の適用には段階的な最適化が必要です。プロジェクトの初期段階では、迅速な開発とフィードバックループの確立を重視した手法が有効です。その後、サービスがスケールしていく段階では、パフォーマンスや保守性を考慮したパターンの導入が必要となってきます。さらに、プロダクトが成熟期に入ったメンテナンスフェーズでは、長期的な運用を見据えた定石の適用が求められます。このように、プロジェクトのライフサイクルに応じて、適切な手法を選択し組み合わせていくことが重要です。そして、これらの手法の有効性を担保するためには、継続的な検証が不可欠です。具体的には、パフォーマンス指標による定量的な評価や、実際のユーザーからのフィードバックの収集、さらにはチーム内での定期的な振り返りを通じて、採用している手法の効果を多角的に検証する必要があります。この検証プロセスを通じて、チームは定石の適用方法を改善し、より効果的な開発プラクティスを確立することができます。このような進化と検証のサイクルを通じて、定石は単なる形式的なルールではなく、実践的で価値のある知識体系として発展していきます。重要なのは、定石を固定的なものとして捉えるのではなく、常に改善と適応を繰り返す生きた知識として扱うことです。それによって、チームは変化する要求や技術環境に柔軟に対応しながら、より効果的な開発プロセスを実現することができます。論点思考作者:内田 和成東洋経済新報社Amazonおわりにそもそも、Kubernetesは型の集大成とも言える存在です。PodやDeployment、Service、Operatorなど、その設計思想には分散システム開発における長年の経験と知恵が型として結晶化されています。Kubernetesの各機能は、それぞれが独立した型でありながら、組み合わさることでより大きな価値を生み出しており、まさにここで議論してきた型の相互補完性を体現していると言えるでしょう。ソフトウェアにおける定石やパターンとの付き合い方は、プログラマーとしての成長において重要な要素となります。ここで重要なのは、バランスの取れたアプローチです。定石を完全に否定せず、かといって盲目的にも従わないという姿勢を保ちながら、常に検証と改善を心がけることが大切です。チームや製品の成長に合わせて手法を進化させていくことで、より効果的な開発プロセスを確立することができます。また、開発手法の習得には継続的な学習のサイクルが不可欠です。まずは基本的なパターンを学び実践するところから始め、経験を積みながら定石の本質を理解していきます。その過程で、状況に応じて手法を適応させたり改善したりすることで、より深い理解と実践的なスキルを身につけることができます。さらに、未来への視点を持つことも重要です。現在の課題解決だけでなく、将来の拡張性も考慮に入れた選択を心がけます。新しい技術やアプローチに対してオープンな姿勢を保つことで、より良い解決策を見出す可能性を広げることができます。また、チーム全体での知識と経験の共有を促進することで、組織としての成長も期待できます。定石やパターンは確かに重要な指針となりますが、それは絶対的な真理ではありません。状況や文脈に応じて、柔軟に解釈し適用していく必要があります。プログラマーとして成長するには、確立された手法を理解し、適切に活用しながら、常に改善と進化を続けることが重要です。この継続的な学習と適応のプロセスこそが、真に効果的な開発手法の確立につながるのです。このような姿勢で開発に取り組むことで、個人としての技術力向上だけでなく、チーム全体の生産性と品質の向上にも貢献することができます。ソフトウェアの世界は常に進化し続けており、その中で成長し続けるためには、確かな基礎と柔軟な思考を併せ持つことが不可欠なのです。","isoDate":"2024-11-20T03:21:14.000Z","dateMiliSeconds":1732072874000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"#技育CAMPキャラバン in福岡🗣️で学生の質問に答えた。","link":"https://syu-m-5151.hatenablog.com/entry/2024/11/17/003421","contentSnippet":"はじめに先日、技育CAMPキャラバンin福岡に社会人エンジニアとして参加し、学生の皆さんと対話する貴重な機会を得ました。このイベントは一方的な講義形式ではなく、各企業がブースを設け、学生と直接対話できる形式で行われました。talent.supporterz.jp私は株式会社スリーシェイクのSreake事業部に所属しています。当社はインフラエンジニアやSRE特化の企業であり、必ずしも全ての学生エンジニアの志望と合致するわけではありません。そのため、マッチングに時間が余った際には、先輩社会人として学生からの様々な質問に答える時間を持つことができました(もちろん、インフラエンジニアやSREに興味がある学生は応募してほしいです)。jobs-3-shake.com実はこの内容は半分冗談で半分本気なのですが、基本的な生活習慣の重要性は本当に伝えたいメッセージの一つです。なので、後半に参考文献などを貼ってます。もう、おじさんなので学生エンジニアに出会ったら、集中力を高める食事、認知機能を向上させる運動、記憶の定着に不可欠な質の良い睡眠、創造性を引き出す意識的な休憩といった基本的な生活習慣の最適化と、予期せぬチャンスを活かす計画的偶発性理論に基づくキャリア形成の話しかしていない。— nwiizo (@nwiizo) 2024年11月16日   この記事では、学生の皆さんから頂いた質問と回答を整理してまとめました。完璧な内容ではないかもしれませんが、対話を通じてかつての自分自身の悩みや不安が蘇り、過去の自分に語りかけているような不思議な感覚を覚えました。この内容が、ご質問いただいた学生の皆さまはもちろんのこと、同様の悩みを抱えているすべての方々の参考となれば幸いです。なお、各回答は異なる方々からの質問に対して、それぞれの文脈に沿ってお答えしたものとなっております。Q.失敗するのが怖くて全体として中途半端になってしまうこの質問をされた時に分かりすぎて泣きそうになった。エンジニアとして働いてきたり少し長く生きた経験から言えることは、失敗を恐れることよりも、挑戦しないことのほうが人生にとって大きなリスクとなるということです。結局のところ、これは自己愛の問題なのかもしれません。「時間を無駄にしたくない」「労力を無駄にしたくない」「チャンスを無駄にしたくない」。そういった思いが強すぎると、かえって何も始められなくなってしまいます。この「無駄にしたくない」という感情の根底には、自分を大切にする気持ちが強すぎるあまり、逆に自分を縛ってしまうというパラドックスがあります。完璧を求めすぎる。失敗を許せない。その背景には、実は自分への過度な期待や要求があるのです。嫌われる勇気作者:岸見 一郎,古賀 史健ダイヤモンド社Amazonでも、人生は無駄にしても良いんです。むしろ、無駄を恐れるあまり何も挑戦しないほうが、本当の意味で人生を無駄にしてしまうことになります。健全な自己愛とは、失敗しても自分を受け入れられる強さ、完璧でない自分を許せる余裕を持つことなのです。人生で最も価値のあるものは、一朝一夕には手に入りません。技術力も、人間関係も、信頼も、全て時間をかけて少しずつ築き上げていくものです。その時間を掛けられるかどうかは、今この瞬間にどれだけ自分を信じられるかにかかっています。そして、自分を信じるためには、失敗した自分も含めて、まるごと受け入れる覚悟が必要です。実は、本当に価値のあるものには、必ず痛みが伴います。すぐに得られる快楽は往々にして一時的なものですが、時間をかけて獲得したものこそが、本物の価値を持つのです。エンジニアとしての技術力も同じです。一朝一夕には身につかず、時には挫折も味わう。でも、その痛みを受け入れ、耐えることができれば、必ず実を結ぶのです。私自身、数々の失敗を経験してきました。コンテストに出て準備不足で大敗したり、本番環境でのデプロイミス、重要な機能の設計ミス、プロジェクトの見積もり違い、スタートアップへの参画での関わり方の間違いなど。一見すると、これらは全て「無駄な失敗」のように思えます。しかし、これらの失敗は全て、今の私の技術力と判断力の基礎となっています。失敗から学べる環境は、社会人になるとむしろ少なくなります。学生時代は、失敗から学ぶ最高の機会なのです。小さな挑戦から始めて、失敗した時の対応策を事前に考えておく。そして失敗から学んだことを必ず記録し、同じ失敗を繰り返さない仕組みを作る。これが私の失敗との向き合い方です。完璧を目指すのではなく、失敗してもいいと自分に許可を出すこと。そこから本当の挑戦が始まるのです。これは、自分を信頼し、自分を大切にする健全な自己愛の表れでもあります。また、簡単に手に入るものは、簡単に失われます。でも、痛みを伴って得たものは、決して簡単には失われない。この事実を心に留めておいてください。そして、これは自分自身との関係性においても同じことが言えます。自分を大切にしすぎるあまり縛ってしまうのではなく、失敗も含めて受け入れる。その寛容さこそが、本当の意味での自己愛なのかもしれません。超一流になるのは才能か努力か？ (文春e-book)作者:アンダース・エリクソン,ロバート・プール文藝春秋AmazonQ.プログラミングがあまり分からなくて不安ですこれはとても一般的な不安です。実は私も、そして多くのエンジニアも同じ経験をしてきました。プログラミングの習得は、多くの人が思い描くような線形的な成長カーブを描きません。理解が全く進まないように感じる時期が長く続き、そしてある日突然、「あ、わかった！」という瞬間が訪れるのです。これは私たちの脳が新しい概念を理解する際によく見られるパターンです。たとえば、プログラミングの各種概念は最初のうちは本当に理解が困難です。でも、ある時を境に急に全体像が見えてくる。それまでモヤモヤしていた霧が晴れるように、概念が腑に落ちる瞬間が必ずやってきます**。だからこそ、今理解できないからと諦めるのは本当に惜しいことです。理解できないのは当たり前の段階なのです。むしろ、理解できなくて当然の時期を耐え忍ぶことこそが、プログラミング習得の本質とも言えます。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazonそれと合わせて、私から一つアドバイスさせていただきたいことがあります。それは言語化能力を磨くことです。プログラミングの学習において、概念を言葉で説明できる能力は非常に重要です。なぜなら、自分の理解を言葉にすることで、その理解がより深まり、また他者と共有できるようになるからです。学んだことを日記やブログに書き留めることから始めてみましょう。技術書を読んでその内容を自分の言葉で要約してみる。分からないことを質問する際にも、自分の理解状態を具体的に言語化してみる。これらの活動は、一見するとプログラミングの学習から外れているように思えるかもしれません。しかし、言語化能力はエンジニアにとって、いくら高くても困ることのないスキルです。コードを書く力と、それを説明する力。この両輪があってこそ、真に優れたエンジニアとなれるのです。最後に繰り返しになりますが、今の不安は決して特別なものではありません。理解できないことに耐え、学び続ける勇気さえあれば、必ず道は開けます。今は理解できなくても、それは単に「まだ」理解できていないだけなのです。焦らず、諦めず、そして何より自分を信じて、一歩ずつ前に進んでいってください。ワイド新版　思考の整理学 (単行本 --)作者:外山　滋比古筑摩書房AmazonQ.キャリア形成をするときにどうすればよいでしょうか？10年程度のエンジニア経験を通じて、最も重要だと感じているのは「計画的偶発性」の考え方です。予期せぬチャンスは必ず訪れますが、それを活かせるかどうかは、日頃の準備にかかっています。そして、どのような道を選んでも、基礎的なスキルの習得は必須です。技術力はもちろん、コミュニケーション能力、プロジェクトマネジメントの基礎、ドキュメンテーションスキルなど、技術以外の部分が実は大きな差を生みます。これらを支えるのが規則正しい生活習慣です。質の良い睡眠、バランスの取れた食事、適度な運動。この当たり前のことを当たり前にできることが、長期的なキャリアを支える土台となります。最後に付け加えておきたいのは、最初の選択が全てを決めるわけではないということです。キャリアは常に変化し続けるものであり、必要に応じて軌道修正することも可能です。大切なのは、その時々で最善と思える選択をし、その環境で最大限学び、成長することです。イシューからはじめよ［改訂版］――知的生産の「シンプルな本質」作者:安宅和人英治出版AmazonQ.就活のときに気にしたほうがいいこと就職活動で自分が気にしていたのは相手の立場や背景を理解したコミュニケーションです。人事部門、現場エンジニア、経営層など、話す相手によって重視する観点が異なります。同じ経験や能力でも、相手の関心に応じて伝え方を工夫する必要があります。人事との対話では、将来のキャリアビジョンやチームへの貢献について。現場エンジニアとは技術的な興味や具体的な実装経験について。経営層にはビジネスへの理解や組織全体への価値提供について。このように文脈に応じて自分の強みを効果的に伝えられることが重要です。また、会社選びにおいては技術環境だけでなく、育成・評価制度やチームの雰囲気も重要な要素です。メンター制度の有無、技術研修の充実度、キャリアパスの明確さ。そしてチーム内のコミュニケーションスタイル、残業や休暇の取得状況、チーム間の連携方法。これらが実際の働きやすさを大きく左右します。このような状況に応じたコミュニケーション能力は、就活だけでなく、その後のエンジニアとしてのキャリアでも大きな差となって現れます。相手の関心や視点を理解し、それに応じて自分の経験や考えを効果的に伝える。これは単なる処世術ではなく、エンジニアに求められる重要なスキルの一つなのです。「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策作者:今井むつみ日経BPAmazonQ.学生の間でやったほうがいいこと正直に申し上げると、この質問に対する模範解答を示すことは避けたいと思います。なぜなら、誰もが自分の人生の主人公であり、その選択に責任を持つべきだからです。ただし、一つだけ確実に言えることがあります。それは、誰もあなたを救ってくれないということです。社会人になってから「あの時こうしておけば良かった」と思うことは誰にでもあります。しかし、それはその時の自分が選択した結果であり、その選択に対する責任は自分自身にあるのです。あなたの人生の舵を取れるのは、あなただけです。そして、その選択の結果として感じる後悔も、あなただけのものです。他人の経験談や助言は参考程度に留め、最終的には自分で考え、決断し、その結果に向き合う覚悟を持ってください。SOFT SKILLS ソフトウェア開発者の人生マニュアル 第2版作者:ジョン・ソンメズ日経BPAmazonQ.SREって何ですか？この質問に関しては、私が以前書いた「点でしかないものを線で見る為に - 「SREの前に」」というブログ記事と登壇資料を紹介しました(同運営イベントなので・・・)。syu-m-5151.hatenablog.comこの記事では、SREの考え方や、実践に必要な基礎知識について詳しく解説しています。あとはインフラエンジニア版の競技プログラミングサイトを紹介した。sadservers.comQ.生産性を上げる方法はありますか？私からの回答は明確です。「スマートフォンを制限すること」に尽きます。現代の最大の生産性の敵は、実はポケットの中にあります。スマートフォンは素晴らしいツールですが、使い方を誤ると大きな時間泥棒となります。これは単なる時間管理の問題ではありません。スマートフォンやSNSは、意図的に依存性を持つように設計されています。「ついスマホを見てしまう」「暇があれば通知をチェックしている」「SNSやYouTubeを見ていたら、気づいたら何時間も経っていた」—これらは偶然ではありません。これらのプラットフォームは、ドーパミンという報酬物質を放出させ、継続的な使用を促す仕組みになっているのです。その影響は私たちの生活のあらゆる面に及びます。集中力の低下により、情報過多で何をしようとしていたのかを忘れてしまう。メンタルヘルスへの悪影響として、衝撃的なニュースや他人の投稿を見て不安や劣等感を感じる。さらには睡眠の質の低下をもたらし、就寝前の使用が質の良い睡眠を妨げています。では、具体的にどうすれば良いのでしょうか。まずは物理的にスマホを遠ざけることから始めましょう。自分の部屋に置かないという選択は、思い切った対策に思えるかもしれませんが、効果は絶大です。目覚まし時計などのような、スマホの代替となるツールを積極的に活用することで、依存度を下げることができます。そして何より大切なのは、リアルで人と会って交流することです。オンラインのつながりに頼りすぎると、かえって孤独感が深まることがあります。実際の対面でのコミュニケーションは、心の健康を保つ上で非常に重要です。重要なのは、これは決してあなたの意志の弱さが原因ではないということです。現代のテクノロジーは、人間の脳の仕組みを巧妙に利用するように設計されています。だからこそ、意識的な制限と代替手段の確保が必要なのです。休憩時間もスマートフォンに頼るのではなく、軽い運動や瞑想を取り入れる。寝る前の読書習慣をつけるなど、スマートフォンに依存しない生活リズムを作ることで、驚くほど生産性が向上します。あなたの本来の能力を最大限に発揮するために、まずはスマートフォンとの適切な距離感を見つけることから始めてみてください。スマホ脳（新潮新書）作者:アンデシュ・ハンセン新潮社AmazonQ.周りのすごい人と比べてしまって落ち込みますこの悩みをよく聞きます。俺も思います。確かに私たち人間は、ついつい目に見えるラベルで判断してしまいがちです。学歴、過去の実績、Xのフォロワー数、有名企業でのインターン経験、GitHubのスター数など。でも、エンジニアの本当の凄さは、そんな表面的なところにはありません。人生は、運よりも実力よりも「勘違いさせる力」で決まっている作者:ふろむだダイヤモンド社Amazon私が長年エンジニアとして働いてきて確信しているのは、本当に優れたエンジニアの価値は、その人が直面する問題をどう解決するか、チームにどう貢献するか、そして日々どう成長していくかにあるということです。時には、ほんの些細な気づきや熱量や視点の違いが、大きなアウトプットの差を生むことがあります。これは学生時代に限らず、社会人になってからも同様です。確かに、自分が目指したいキャリアイメージに向けて、意識的にある種のラベルを獲得しようとすることは否定しません。それも一つの戦略です。ただし、より重要なのは、自分の思考プロセスや行動を明確に言語化できる能力です。「なぜその選択をしたのか」「どのように問題を解決したのか」を論理的に説明できる人は、社会に出てからより高く評価される傾向にあります。肩書きや過去の実績は、その人の一部分でしかありません。むしろ、今この瞬間にどれだけ真摯に技術や事業と向き合っているか、どれだけ学ぼうとする意欲があるか、そしてどれだけチームに価値をもたらしているか。そういった日々の積み重ねこそが、エンジニアとしての本質的な価値を形作っていくのです。だからこそ、表面的なラベルで自分を判断する必要はありません。あなたにしかできない貢献の仕方があり、あなたにしかない成長の道筋があるはずです。重要なのは、自分の考えや行動を明確に言語化し、それを他者と共有できること。そして、他の人と比べるのではなく、昨日の自分と比べて、一歩ずつでも確実に前に進んでいくことです。いかにして問題をとくか作者:G．ポリア丸善出版Amazon余談ですが、技術的な記事を書いたり登壇したりすることで「いいね」を集めたり、ハッカソンやビジネスコンテストで賞を獲得したりすることで得られる達成感は、一時的な快感に過ぎず、あくまでも外部からの評価でしかありません。イベントやSNSでの反響は確かにモチベーションの維持や目標設定には有効です。しかし、それを自分の技術力の証明と混同してしまうのは危険です。特に、外部での評価が高まると実際の技術力以上に自己評価が膨らみがちです。定期的に競技プログラミングやISUCON、CTF、学生ならICTSCにでも参加して、自分の現在地を冷静に確認することをお勧めします。結局のところ、ソフトウェアエンジニアにとって最も大切なのは、地道なコーディングと技術力の着実な積み重ねなのです。質問ではないのですが投稿まとめツイートの内容をサクッとまとめます。エンジニアの間で「運動が大切だ」という話をよく耳にします。確かにその通りですが、健康維持には運動以外にも同等に重要な要素が複数あります。これは人生の多くの側面に当てはまる話です。「すごい」と感じる人に出会ったとき、その瞬間にその人と自分の実力差や実績の差に圧倒されがちですが、実はそれは表面的な差でしかありません。大切なのは、基本的な生活習慣を整え、地道な努力を10、20年単位で継続できるかどうかです。短期的には大きな差が付いているように見えても、正しい生活習慣と共に粘り強く継続することで、必ず追い付き、追い越すことができます。運動脳作者:アンデシュ・ハンセンAmazon質の良い睡眠は、技術の習得と定着に直接的な影響を与えます。睡眠中、脳は日中の学習内容を整理し、長期記憶として定着させる重要な作業を行っています。しかし、多くのエンジニアは必要な睡眠時間を確保できていない「睡眠負債」の状態にあります。これは単なる「睡眠不足」という言葉で片付けられる問題ではありません。借金と同じように、睡眠負債は返済が滞ると、脳も体も思うように機能しなくなり、最終的には「眠りの自己破産」を引き起こしてしまいます。その結果、集中力の低下、記憶力の減退、さらには深刻な健康上の問題まで引き起こす可能性があります。特に危険なのは、睡眠負債による「マイクロスリープ（瞬間的居眠り）」です。1秒未満から10秒程度の意識の途切れは、本人も気づかないうちに起こり、作業中の重大なミスや事故につながりかねません。コードレビューやインフラ作業など、高度な注意力を要する作業において、これは深刻な問題となります。対策として重要なのは、就寝前のブルーライトを避け、規則正しい睡眠サイクルを維持することです。週末の寝だめでは解決しない睡眠負債を作らないよう、平日から意識的に睡眠時間を確保することが、長期的な学習効率と作業パフォーマンスを支える土台となります。スタンフォード式　最高の睡眠作者:西野 精治サンマーク出版Amazon適切な食事も、持続的な集中力の維持に不可欠です。ただ、多くのエンジニアに共通して見られる問題として、安易に糖質に偏った食事を選択しがちという傾向があります。手軽なカップ麺やパン類、菓子類への依存は、一時的な満足感は得られても、長期的には集中力の低下を招きます。特に気をつけたいのがタンパク質の摂取不足です。プログラミングは脳を使う仕事であり、脳の働きを最適化するためには十分なタンパク質摂取が欠かせません。忙しい中でも、プロテインドリンクの活用や、コンビニで手に入る鶏むね肉のサラダなど、手軽にタンパク質を補給できる方法を確保しておくことをお勧めします。ここで個人的におすすめなのが低温調理器の活用です。特に鶏むね肉の調理に関しては、低温調理器があれば手間をかけずに柔らかく美味しいタンパク質を確保できます。帰宅後に調理を始めるのは大変ですが、低温調理器なら出勤前にセットしておくだけで、帰宅時には完璧な火加減の料理が待っています。しかも、大量調理が可能なので、一度の調理で数日分のタンパク質を準備できます。コーヒーや糖分に頼りすぎない食生活を意識することも重要です。特に朝食では、炭水化物とタンパク質をバランスよく摂取することで、一日を通して安定したパフォーマンスを発揮できます。疲れない体をつくる最高の食事術作者:牧田善二小学館Amazonそして見落とされがちなのが、意識的な休養時間の確保です。連続的な作業は、必ずしも生産性の向上には繋がりません。むしろ、疲れをごまかして動き続けることは、回復に要する時間を延ばすだけでなく、深刻な健康上の問題を引き起こす可能性があります。休養には「生理的休養」「心理的休養」「社会的休養」の3種類があり、これらを適切に組み合わせることで、より効果的な疲労回復が期待できます。ただし、ここで言う休養とは、スマートフォンを触ることではありません。むしろ、休憩時間にスマートフォンを見ることは、脳を別の形で疲労させてしまう最悪の選択と言えます。理想的な休養とは、「自分で決めた」「仕事とは関係ない」「成長できる」「楽しむ余裕がある」という条件を満たした活動を指します。これらの要素が揃うことで、単なる休憩ではなく、心身の本質的な回復と成長をもたらす「攻めの休養」となります。デジタルデバイスから完全に離れ、心身をリセットする時間が必要です。短い散歩や深呼吸、窓の外を眺めるなど、意識的に何もしない時間を作ることで、脳は自然と新しいアイデアを生み出す準備を整えていきます。これは一見、時間の無駄に思えるかもしれませんが、長期的な生産性向上には不可欠な投資なのです。休養学―あなたを疲れから救う作者:片野 秀樹東洋経済新報社Amazon運動も確かに重要ですが、それは全体の一部分でしかありません。質の良い睡眠、バランスの取れた食事、適切な休憩。これらすべての要素が揃って初めて、エンジニアとして最高のパフォーマンスを発揮できるのです。ぜひ、生活習慣全体を見直す機会にしていただければと思います。おわりに後から見返すと純粋な学生に対して偉そうで斜に構えた回答をしてるなぁ… もっとベタをやれって思ってしまいました。ともあれ無事に終わって良かったです。学生の皆さんと対話できる貴重な機会を得て、私自身も多くの気づきがありました。かつての自分も同じような不安や悩みを抱えていたことを思い出し、その時の気持ちが今でも鮮明に蘇ってきます。そして不思議なことに、皆さんの質問に答えながら、過去の自分自身とも対話をしているような感覚がありました。技術の世界は常に変化し続けています。その中で最も重要なのは、技術そのものではなく、技術を学び続ける力、問題を解決する力、そして人と協力する力です。これは今も昔も変わらない真理だと感じています。皆さんには無限の可能性があります。当時の私がそうだったように、今は不安や迷いがあるかもしれません。でも、その不安を抱えながらも一歩を踏み出す勇気があれば、必ず道は開けます。失敗を恐れず、積極的に挑戦し続けてください。私たち社会人エンジニアは、かつての自分を重ねながら、皆さんの成長を心から応援しています。そして、この対話を通じて、私自身も過去の自分と向き合い、その不安や迷いを受け止め直すことができました。私たちは常に、過去の自分を励ましながら、未来の誰かの道標となれるよう成長し続けているのかもしれません。なお、イベントでお会いした学生の皆さん、もし追加の質問や相談事があれば、お気軽にDMをください。可能な範囲で、皆さんのキャリアについて一緒に考えていけたらと思います。pitta.me","isoDate":"2024-11-16T15:34:21.000Z","dateMiliSeconds":1731771261000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"点でしかないものを線で見る為に - 「SREの前に」というタイトルで登壇しました。","link":"https://syu-m-5151.hatenablog.com/entry/2024/11/11/110223","contentSnippet":"はじめに先日、技育プロジェクト（株式会社サポーターズ）主催の技育CAMPアカデミアという勉強会にて「SREの前に」というイベントで登壇する機会をいただきました。今回は「点」としての情報を「線」として繋げて見ることの重要性について、お話しさせていただきました。このイベントは、特にこれからSREを目指す学生の方々に向けて、運用の基礎的な考え方や歴史的背景を共有することを目的としています。サピエンス全史　上　文明の構造と人類の幸福 (河出文庫)作者:ユヴァル・ノア・ハラリ河出書房新社Amazonイベントページtalent.supporterz.jpどこにでも答えがある時代私たちは情報があふれる時代に生きています。技術書やオンラインドキュメント、技術ブログ、そして最近では生成AIなど、様々な方法で技術知識を得ることができます。しかし、これらの情報の多くは「点」として存在しています。なぜその技術が生まれたのか、どのような課題を解決しようとしていたのか、当時のエンジニアたちは何を考えていたのか―――そういった文脈や歴史的な背景は、資料や書籍だけでは見えづらいものです。それでも必要とされるエンジニアになってほしい「SREとは何か」という知識自体は、今や簡単に手に入ります。しかし、なぜSREという概念が必要とされるようになったのか、従来の運用との本質的な違いは何か、といった背景を理解することは容易ではありません。運用の世界では、過去の経験や失敗から学び、それを現在の実践に活かすことが非常に重要です。こうした経験や知見は、単なる技術ドキュメントからは読み取ることが難しいのです。そして、さらに重要なのは、その時々の「正解っぽい何か」を理解し、実際の課題解決に活かせるようになることです。技術やプラクティスは、それ自体が目的なのではありません。例えば、SREの施策やベストプラクティスも、結局のところ「どうすれば安定的にサービスを運用できるか」という課題に対する一つの解答なのです。私たちに求められているのは、その解答を理解し、自分たちの文脈に合わせて適切に活用していく力ではないでしょうか。技術の変遷を知ることで見えてくるものこの20年間で技術は劇的に変化しました。クラウドの普及、コンテナ技術の発展、マイクロサービスアーキテクチャの採用など、システムの在り方そのものが大きく変わってきています。しかし、これらの変化の根底には「より良いサービスを、より確実に、より効率的に提供したい」という普遍的な願いがあります。技術の進化を「新しい技術の登場」としてだけでなく、「なぜその技術が必要とされたのか」という視点で理解することで、次に何が必要とされるのか、自分たちはどう進化していくべきなのかが見えてくるはずです。発表を通じて伝えたかったこと今回の発表で、特に若手エンジニアの皆さんに伝えたかったのは、技術を「点」で捉えるのではなく、その背景にある文脈や歴史的な流れを「線」として理解することの大切さです。これは単に「過去を知る」ということではなく、未来への洞察力を養うことにもつながります。変化の激しいIT業界では、個々の技術は常に進化し、新しいものに置き換わっていきます。しかし、その変化の本質を理解し、次の一手を考えられるエンジニアこそが、これからも必要とされ続けるのだと信じています。そして、これは重要な点なのですが、私たちが目にする技術の変遷は、常に正解への道のりだったわけではありません。むしろ、その時々の制約や状況の中で、エンジニアたちが必死に模索した結果の一つにすぎません。「その時はそれしか選択肢がなかった」という判断もまた、とても重要な文脈です。この視点を持つことで、現在の技術選択に対しても、より深い理解と柔軟な判断が可能になるのではないでしょうか。発表資料 speakerdeck.com今回の発表では、以下のような内容をお話させていただきました。運用の歴史的変遷2000年代前半の運用現場では、多くが手作業で行われ、開発チームと運用チームの間には大きな壁が存在していました。その後、2009年頃からDevOpsの概念が登場し、開発と運用の協調が重要視されるようになりました。2010年代に入ると、GoogleによってSREが体系化され、データドリブンな運用やプロアクティブな障害対策が標準的なアプローチとなっていきました。現代の運用における課題現在のSREは、システムの複雑化やマイクロサービスアーキテクチャの採用により、新たな課題に直面しています。特に以下の点が重要になってきています：システムの複雑性の管理クラウドネイティブ環境での信頼性確保組織の成長に伴う運用のスケーリング継続的なシステム改善の実現歴史から学ぶ重要性発表では特に、過去の経験や失敗から学ぶことの重要性を強調しました。技術の進化は決して直線的ではなく、過去の課題が形を変えて再び現れることも少なくありません。そのため、歴史的な文脈を理解することは、現在の課題に対する解決策を考える上で非常に重要です。この発表が、技術を学ぶ方々、特に学生の皆さんにとって、個々の知識を繋げて理解するための一助となれば幸いです。単に「今」の技術トレンドを追いかけるだけでなく、その背景にある文脈や歴史を理解することで、より深い技術理解と、将来の変化への対応力を身につけることができるのではないかと考えています。システムの本質を見失わないために本発表では詳しく触れませんでしたが、ここで一つ重要な課題に言及しておきたいと思います。クラウドの発展は、確かにシステム開発を劇的に効率化しました。ですが、その便利さは大きな落とし穴も持っています。クラウドの力が強大になり、エンジニアの技術力が相対的に低下し、それがさらなるクラウド依存を生む。この負のサイクルは、私たちの目の前で着実に進行しています。禅とオートバイ修理技術 上 (ハヤカワ文庫NF)作者:ロバート Ｍ パーシグ早川書房Amazonシステムが動作している状態さえ維持できれば問題ないという考え方や、複雑な問題はクラウドサービスに任せておけばよいという姿勢は、一見合理的に見えます。しかし、システムの性能改善や障害対応時に、表面的な理解しかないエンジニアには、その本質的な原因を特定することすらできません。各システムの深い理解と、時には「痛み」とも呼べる経験は必要不可欠です。しかし、「動いているからいい」という現状で、この必要性を伝えることは非常に難しい。これは現代のエンジニアリング教育における最大の課題です。禅とオートバイ修理技術 下 (ハヤカワ文庫NF)作者:ロバート Ｍ パーシグ早川書房Amazonエンジニアリングの本質は表面的な最適化ではありません。まず根本的な理解があり、その上で適切な抽象化や最適化を行う―――これこそが、私たちが目指すべき姿なのです。コンピュータの構成と設計　MIPS Edition　第6版 　上・下電子合本版作者:David Patterson,John Hennessy日経BPAmazon最後に今回の発表を通じて、多くの学生の方々と交流する機会を得ました。皆さんの熱心な質問や鋭い観察には、とても励まされました。もうすぐ30歳を迎える身として、学生の皆さんの真摯な質問一つひとつに胸が熱くなり、できる限り丁寧に答えたいという気持ちで一杯になりました。実は私自身、学生時代は進むべき道に悩み、多くの不安を抱えていました。だからこそ、今回質問をしてくださった学生の皆さん、そしてイベントに来てくださった全ての方々と、いつかじっくりとお話ができればと思っています。（ちなみに、この年になっても人見知りが抜けず、時々無愛想な態度をとってしまうことがあります。そんな時は「まだまだ成長途中のエンジニア」として、温かい目で見守っていただけると嬉しいです）技術の世界は日々変化していきますが、その変化の中に普遍的な価値を見出し、理解を深めていく姿勢は、エンジニアとして成長していく上で最も重要な要素の一つだと考えています。時には「その時はそれしか選択肢がなかった」という判断があったことを理解しつつ、過去のエンジニアにリスペクトを送りつつ私たちはきっと、この悩みや探求の過程を共有することで、共に成長していけるはずです。最後に、このような貴重な機会を提供してくださった技育プロジェクト（株式会社サポーターズ）のスタッフの皆様、そして参加してくださった皆様に心より感謝申し上げます。若手エンジニアの皆さんの成長を、これからも微力ながら支援させていただければ幸いです。","isoDate":"2024-11-11T02:02:23.000Z","dateMiliSeconds":1731290543000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"SREの前に","link":"https://speakerdeck.com/nwiizo/srenoqian-ni","contentSnippet":"2024年11月06日(水) 18:00～19:00の予定に遅刻してしまい、大変申し訳ございませんでした。お詫びとして、当初非公開予定であった資料を公開させていただきます。元々、公開する予定ではなかったので補足が足りない部分などあると思いますのでご容赦下さい。\r\rブログなどで補足情報出すかもなので気になればフォローしてください\r- https://syu-m-5151.hatenablog.com/\r- https://x.com/nwiizo\r\r\rSREの前に - 運用の原理と方法論\r公式URL: https://talent.supporterz.jp/events/2ed2656a-13ab-409c-a1d9-df8383be25fd/","isoDate":"2024-11-06T05:00:00.000Z","dateMiliSeconds":1730869200000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"技術がなければ作れない、必要がなければ存在している資格がない - Platform Engineering: A Guide for Technical, Product, and People Leaders の読書感想文","link":"https://syu-m-5151.hatenablog.com/entry/2024/10/25/060600","contentSnippet":"我に似せる者は生き、我を象る者は死す(本質を理解して創造的に学ぶ者は発展し、表面的な模倣に留まる者は衰退する)。はじめに「Platform Engineering: A Guide for Technical, Product, and People Leaders」は、現場での実践知を出発点として、プラットフォームエンジニアリングの本質に迫る実践的なガイドとして、技術リーダーから上級管理職まで向けた幅広い読者層に向けて書かれています。個人的にはもう少しだけ広げて開発者やプラットフォームを実際に使う側も読んでも学びのある本だと思いました。著者のCamilleとIanの豊富な経験が凝縮された本書は、単なる表面的な手法の模倣ではなく、実際の現場での試行錯誤から導き出されたプラクティス、そしてその背後にある根本的な原理と思想を探求し、それが現代のソフトウェア開発組織においていかに革新的な価値を生み出すかを浮き彫りにしています。本書の真価は、プラットフォームエンジニアリングを単なる技術的な手法の集合としてではなく、日々の実践から得られた知見を体系化し、組織の進化と持続的な成長を促す戦略的な思考基盤として捉えている点にあります。技術的な実装の詳細よりも、組織が現場の文脈に根ざした実践を重ね、そこからプラクティスを抽出し、最終的にプラットフォームエンジニアリングの本質的な原則を理解して創造的に応用していく方法論に重点が置かれています。これは、現代のソフトウェア開発組織が直面する複雑性の管理と開発者体験の向上という課題に対する、本質的かつ持続可能な解決の道筋を示すものとなっています。Platform Engineering: A Guide for Technical, Product, and People Leaders (English Edition)作者:Fournier, Camille,Nowland, IanO'Reilly MediaAmazonプラットフォームエンジニアリングの重要性プラットフォームエンジニアリングは、複雑なソフトウェア環境でのイノベーションを促進する開発者体験の向上に不可欠な鍵となり、クラウドへの移行だけでは解決できない問題に対処するための重要な基盤を提供しています。さらに、組織の成長に伴うスケーラビリティの要求とセキュリティニーズの両方に対応する重要な役割を果たすことで、現代のソフトウェア開発組織にとって極めて重要な存在となっています。learning.oreilly.com本書が組織的・戦略的側面に焦点を当てているのに対し、より技術的な側面、特にCloud Nativeな実装に興味がある方には、「Platform Engineering on Kubernetes」がおすすめです。こちらの書籍では、Kubernetesを基盤としたプラットフォームエンジニアリングの実践的なアプローチが詳細に解説されています。syu-m-5151.hatenablog.com両書を併読することで、プラットフォームエンジニアリングの組織的側面と技術的側面の両方を深く理解することができ、より包括的な知識を得ることができるでしょう。本書の構成と特徴本書は現場での実践を起点としながら、プラットフォームエンジニアリングを組織的、戦略的に展開するためのガイドとして構成されており、著者たちが数々の現場で直面した課題と、そこから得られた具体的で実行可能な知見を提供しています。特筆すべきは、個々の技術的解決策にとどまらず、チーム構成や製品管理、ステークホルダーマネジメントなど、現場で真に重要となる組織的側面にも焦点を当てている点で、日々の実践に携わる技術リーダーからCTOやSVPなどの組織の舵取りを担う上級管理職までを想定した実践的な内容となっています。最後に、これら3つのパートは、現場での実践から抽出された原則（Part I）、その原則に基づく具体的なプラクティス（Part II）、そしてそれらの効果を測定・評価する方法（Part III）という、現場起点の論理的な流れを形成しています。特に、第3部で提示される成功の定義は、第1部で説明される現場から導き出された原則と、第2部で示される実践的なアプローチを有機的に結びつける重要な役割を果たしています。本書は、プラットフォームエンジニアリングの現場で直面する本質的な難しさを率直に語っています。具体的には、「技術的に面白いから作る」のではなく現場で真に必要とされるものを見極めて提供するという価値提供の本質、計画の難しさを認識しつつも現場の文脈に応じて適切に実行するという実践知、そして組織の重要なシステムを支える責任を全うするための運用の成熟という現場力の醸成といった課題を挙げています。これらの課題に対して、本書は原則に基づきながらも現場の実態に即した解決の道筋を示しています。正しいものを正しくつくる　プロダクトをつくるとはどういうことなのか、あるいはアジャイルのその先について作者:市谷 聡啓ビー・エヌ・エヌ新社AmazonPart I. Platform Engineeringの本質と意義第1部は、Platform Engineeringの根本的な「なぜ」と「何を」に焦点を当てています。Simon Sinekの「イノベーションは夢からではなく、苦闘から生まれる」という言葉に象徴されるように、本章では現代のソフトウェア開発が直面する複雑性と変化の課題に対して、Platform Engineeringがなぜ適切なアプローチなのかを解説しています。特に印象的なのは、Platform Engineeringの4つの柱（製品思考、ソフトウェアエンジニアリング、包括的アプローチ、運用効率）について、単なる理論的な枠組みではなく、実践的な基盤として提示している点です。私の経験でも、これらの要素のバランスを取ることが、プラットフォームチームの成功への鍵となっています。また、国内の参考資料として、jacopenさんの『「共通基盤」を超えよ！ 今、Platform Engineeringに取り組むべき理由』がおすすめです。この記事を読むことで、本書の全体像がより明確に理解できるので一読してもらいたいです。 speakerdeck.comChapter 1. Why Platform Engineering Is Becoming Essential第1章「Why Platform Engineering Is Becoming Essential」は、プラットフォームエンジニアリングが現代のソフトウェア開発組織において不可欠となっている背景と理由について、包括的な視点から解説しています。著者は、過去25年間のソフトウェア組織が直面してきた共通の課題から説き起こし、クラウドコンピューティングとオープンソースソフトウェア（OSS）の台頭がもたらした複雑性の増大、そしてそれに対するプラットフォームエンジニアリングの解決アプローチを詳細に論じています。プラットフォームエンジニアリングの本質と定義著者は、プラットフォームを「自己サービス型のAPI、ツール、サービス、知識、サポートを、魅力的な内部プロダクトとして組み合わせた基盤」と定義しています。この定義は、単なる技術的な基盤以上のものを示唆しており、プラットフォームが組織全体に提供する価値を包括的に捉えています。他にもCNCFが公開している「CNCF Platforms White Paper」では、Platformsについて「クラウドネイティブコンピューティングのためのプラットフォームは、プラットフォームのユーザーのニーズに応じて定義・提示される統合された機能のコレクションです。幅広いアプリケーションやユースケースに対して、一般的な機能やサービスを取得・統合するための一貫した体験を確保するクロスカッティングなレイヤーです。優れたプラットフォームは、Webポータル、プロジェクトテンプレート、セルフサービスAPIなど、その機能やサービスの利用と管理に一貫したユーザー体験を提供します」と定義しています。tag-app-delivery.cncf.ioまた、プラットフォームエンジニアリングの成熟度を評価するための「Platform Engineering Maturity Model」も公開されていますので、ぜひ参考にしてください。tag-app-delivery.cncf.ioFigure 1-1. The over-general swamp, held together by glue より引用[Figure 1.1]では、「Over-General Swamp」の状態を示しており、多数のアプリケーションが個別のプリミティブと直接統合され、それらの間を大量のglueコードが繋いでいる様子が描かれています。この図は、プラットフォームが存在しない状態での複雑性の増大を視覚的に表現しています。あるプログラムで、異なるシステムやコンポーネントを連携させるために書かれる仲介的なコードのことです。このコードは、システムの本来の機能には直接関係しませんが、互換性のない部品同士をスムーズに連携させるために必要な「接着剤」のような役割を果たします。これを『グルーコード』と言います。ja.wikipedia.org特に印象的なのは、著者がプラットフォームエンジニアリングを複雑性を管理しながらビジネスへのレバレッジを提供するという明確な目的を持った規律として位置づけている点です。私の経験でも、単なる技術的な基盤提供を超えて、開発者の生産性向上とビジネス価値の創出を同時に実現することが、プラットフォームエンジニアリングの成功の鍵となっています。現代のソフトウェア開発における「Over-General Swamp」の問題Figure 1-2. How platforms reduce the amount of glue より引用[Figure 1.2]は、プラットフォームエンジニアリングによる解決後の状態を示しています。この図では、プラットフォームが複数のプリミティブを抽象化し、アプリケーションとの間にクリーンなインターフェースを提供している様子が描かれています。glueコードが大幅に削減され、システム全体の見通しが改善されていることが分かります。著者は現代のソフトウェア開発環境を「Over-General Swamp（過度に一般化された沼）」と表現し、この比喩を通じて複雑性の罠を見事に描き出しています。クラウドとOSSの普及により、開発者は豊富な選択肢を手に入れましたが、それは同時に「接着剤（glue）」と呼ばれる統合コードやカスタム自動化の増加をもたらしました。プラットフォームエンジニアリングによる解決アプローチ著者が提示するプラットフォームエンジニアリングの解決策は、製品としてのアプローチを重視しています。これは、ユーザー中心の視点を持ちながら、機能の取捨選択を慎重に行い、全体としての一貫性と使いやすさを追求することを意味します。Appleの製品開発アプローチを例に挙げながら、著者は機能の追加だけでなく、むしろ何を含めないかの判断の重要性を強調しています。INSPIRED 熱狂させる製品を生み出すプロダクトマネジメント作者:マーティ・ケーガン,佐藤真治,関満徳日本能率協会マネジメントセンターAmazon技術的な側面では、プラットフォームエンジニアリングは複雑性を管理可能なレベルに抑えることを目指します。例えば、インフラストラクチャの分野では、Terraformの例を用いて、個々のチームが独自にインフラストラクチャを管理する場合の問題点と、プラットフォームによる抽象化がもたらす利点が説明されています。DXを成功に導くクラウド活用推進ガイド CCoEベストプラクティス作者:黒須 義一,酒井 真弓,遠山 陽介,伊藤 利樹,饒村 吉晴日経BPAmazonプラットフォームチームの役割とイノベーション著者は、プラットフォームチームの役割について、従来のインフラストラクチャ、DevTools、DevOps、SREの各アプローチとの違いを明確に示しています。これらの従来のアプローチは、それぞれの専門分野に特化していますが、プラットフォームエンジニアリングはこれらの境界を越えて、より包括的な価値を提供することを目指します。チームトポロジー　価値あるソフトウェアをすばやく届ける適応型組織設計作者:マシュー・スケルトン,マニュエル・パイス日本能率協会マネジメントセンターAmazon特筆すべきは、著者がイノベーションとプラットフォームの関係について、現実的な見解を示している点です。プラットフォームは既存の技術スタック内でのビジネスイノベーションを促進する一方で、プラットフォームの範囲を超えた革新的な取り組みも必要だと認めています。例えば、データ領域での新しい技術の採用など、プラットフォームの制約を一時的に超えることが必要な場合もあると指摘しています。章全体からの学び第1章は、プラットフォームエンジニアリングが現代のソフトウェア開発組織にとって不可欠な理由を説得力のある形で提示しています。複雑性の増大、運用負荷の増加、イノベーションの必要性といった課題に対して、プラットフォームエンジニアリングは包括的な解決策を提供します。著者は、プラットフォームエンジニアリングが単なる技術的な取り組みではなく、組織全体の成功に関わる戦略的な施策であることを強調しています。これは、私の実務経験とも強く共鳴する見解です。プラットフォームエンジニアリングの成功には、技術的な卓越性だけでなく、組織的な変革とイノベーションのバランスを取ることが求められます。今後のソフトウェア開発組織にとって、プラットフォームエンジニアリングの導入は避けて通れない課題となるでしょう。本章は、その理由と意義を深く理解するための優れた導入を提供しています。特に、プラットフォームエンジニアリングが組織にもたらす具体的な価値と、その実現に向けた実践的なアプローチについての示唆は、多くの組織にとって有用な指針となるはずです。特に注目すべきは、プラットフォームを「製品」として扱うアプローチや、ステークホルダーマネジメントの重要性など、技術面だけでなく組織的な側面にも焦点を当てている点です。これらの知見は、プラットフォームエンジニアリングの実践において大きな価値をもたらすと考えられます。プラットフォームエンジニアリングリーダーとして、本書から学んだ知識を自身のチームや組織に適用し、より効果的なプラットフォーム戦略を構築していくことが重要です。また、本書が提起する課題や解決策について、同僚や業界のピアとのディスカッションを通じて、さらなる洞察を得ることができるでしょう。このような実践と対話を通じて、プラットフォームエンジニアリングの分野がさらに発展していくことが期待されます。「翻訳記事 -「インフラ基盤部門は本当に必要か」に関する議論」なんかもとても良い記事なので読んでほしいです。ca-srg.devChapter 2. The Pillars of Platform Engineering第2章「The Pillars of Platform Engineering」は、プラットフォームエンジニアリングの4つの重要な柱について詳細に解説しています。著者は、Product（製品としてのアプローチ）、Development（ソフトウェアベースの抽象化）、Breadth（幅広い開発者への対応）、Operations（基盤としての運用）という4つの柱を通じて、効果的なプラットフォームエンジニアリングの実践方法を示しています。これらの柱は相互に補完し合い、成功するプラットフォームエンジニアリングの基礎を形成しています。キュレートされた製品アプローチの重要性プラットフォームエンジニアリングにおける最初の柱は、キュレートされた製品アプローチです。このアプローチは、単なる技術的な実装を超えて、ユーザーのニーズを中心に据えた戦略的な製品開発を意味します。著者は、これを「paved paths（舗装された道）」と「railways（鉄道）」という2つの異なるタイプのプラットフォーム製品として説明しています。Paved Pathsは、複数のオファリングを統合した使いやすいワークフローを提供し、アプリケーションチームから複雑性を隠蔽しながら、パレート原理に基づいて20%のユースケースで80%のニーズをカバーすることを目指す標準的なアプローチを提供します。Figure 2-1. Architecture of a paved path platform より引用[Figure 2.1]は「paved path」の概念を視覚的に表現しており、複数のオファリングを使いやすいワークフローとして統合し、アプリケーションチームから複雑性を隠蔽する方法を示しています。これは共通のニーズに対応するための標準的なアプローチを提供することを目的としており、著者が提唱する製品としてのプラットフォームの本質を端的に表現しています。Railwaysは、既存製品では対応できない特定ニーズに応え、組織全体に特定の機能を提供するための重要なインフラストラクチャ投資を伴い、プロトタイプから進化してスケーラブルなソリューションを提供する新しい形態のプラットフォームです。Figure 2-2. Architecture of a railway platform より引用[Figure 2.2]は「railway」型プラットフォームを示しており、既存の製品では対応できない特定のニーズに応える新しい形態のプラットフォームを表現しています。具体例として、バッチジョブプラットフォーム、通知システム、グローバルアプリケーション設定プラットフォーム、データ処理パイプライン、監視・モニタリングプラットフォームなどが挙げられます。プラットフォームを製品として捉えることは、単なる技術的な選択以上の意味を持ちます。ユーザー中心のデザインを通じて一貫性のある使いやすいインターフェースを提供し、明確なドキュメンテーションと効果的なオンボーディング体験を実現することが重要です。また、必要な機能の追加と不要機能の大胆な削除を行いながら、機能の優先順位付けを適切に管理し、継続的な改善サイクルを通じてユーザーフィードバックを収集・分析し、パフォーマンス指標の測定と定期的な機能の見直しを行うことが求められます。ソフトウェアベースの抽象化の実現著者は、「ソフトウェアを構築していないなら、それはプラットフォームエンジニアリングではない」と明確に述べています。この主張は、プラットフォームエンジニアリングの本質を理解する上で極めて重要です。効果的な抽象化を実現するためには、適切な粒度での機能分割、一貫性のあるインターフェース、バージョニング戦略、エラーハンドリングなどのAPI設計の原則に加えて、スケーラビリティ、パフォーマンス、セキュリティ、監視可能性などの実装上の考慮事項も重要となります。幅広い開発者ベースへのサービス提供プラットフォームの対象は幅広い開発者ベースであり、セルフサービス機能、ユーザー観測性、ガードレール、マルチテナンシーが重要な要素となります。これらは直感的なユーザーインターフェースとAPI駆動の自動化による効率的なワークフロー、詳細なログ記録とパフォーマンスメトリクス、セキュリティ制御とリソース制限、そしてリソースの分離とアクセス制御を実現します。GenerativeAIの影響と展望著者は、GenerativeAIがプラットフォームエンジニアリングに与える影響について、MLOpsの進化、ツールチェーンの整備、インフラストラクチャの効率化、データガバナンス、LLMエコシステムの観点から包括的な分析を提供しています。これには、モデル開発ライフサイクル管理とデプロイメント自動化、研究者向けインターフェースと非技術者向け操作性、コンピュートリソースとストレージの最適化、プライバシー保護とコンプライアンス対応、そしてモデル選択と統合が含まれます。基盤としての運用プラットフォームが組織の基盤として機能するためには、プラットフォームへの責任、プラットフォームのサポート、運用規律という3つの要素が不可欠です。これらは、エンドツーエンドの管理と問題解決の主導、ユーザーサポート体制とドキュメンテーションの充実、そして標準化されたプロセスと品質管理を通じて実現されます。章全体からの学び第2章は、プラットフォームエンジニアリングの4つの柱を通じて、成功するプラットフォームの要件を明確に示しています。技術的な卓越性、組織的な変革、イノベーション、継続的な進化が、プラットフォームエンジニアリングの成功には不可欠です。これらは最新技術の適用とパフォーマンスの最適化、チーム構造の最適化とスキル開発、新技術の評価と導入、そしてフィードバックの収集と反映を通じて実現されます。これらの要素は相互に関連し、バランスの取れた実装が必要となります。プラットフォームエンジニアリングは継続的な取り組みであり、技術的な側面だけでなく、組織的な支援と文化の醸成を通じて常に進化し続ける必要があります。Part II. Platform Engineering Practices第2部は、C.S.Lewisの「卵が鳥になるのは難しいかもしれないが、卵のままで飛ぶ方がよほど難しい」という言葉から始まり、プラットフォームエンジニアリングの実践的な側面に焦点を当てています。著者は8つの主要な失敗パターンを特定し、それぞれに対する具体的な解決策を提示しています。特に重要なのは、プラットフォームエンジニアリングが単なるインフラストラクチャエンジニアリングやDevOpsの再ブランディングではないという指摘です。私のチームでも、適切なタイミングでの開始、適切な人材ミックス、製品思考の導入、効果的な運用という要素が、成功への重要な要因となっています。Chapter 3. How and When to Get Started第3章「How and When to Get Started」は、プラットフォームエンジニアリングの導入時期と方法について、組織の成熟度や規模に応じた具体的なアプローチを提供しています。著者は、三つの主要な状況に焦点を当て、各シナリオにおける成功への道筋を示しています。小規模組織でのプラットフォーム協力の育成著者は小規模スタートアップにおけるプラットフォームエンジニアリングのアプローチを、成熟度モデルを用いて説明しています。特に注目すべきは、アドホック段階とやや管理された段階という2つのフェーズの定義です。この文脈で参考になるのが、CNCF Platform Engineering Maturity Modelです。このフレームワークは、組織の成熟度を評価し、次のステップを計画する際の指針となります。tag-app-delivery.cncf.ioアドホック段階では、シンプルな自動化と基本的なプロセスの確立に焦点を当てることが推奨されています。著者は、この段階で重要なのはソースコントロール、自動化された継続的デプロイメント、そして軽量なプロセスの3つの要素だと強調しています。これは私の経験とも一致しており、特に小規模チームにおいては、過度に複雑なプロセスや高度な技術スタックを避け、シンプルさを保つことが重要です。やや管理された段階では、チームの成長に伴い、より構造化されたアプローチが必要となります。著者はローカル開発環境の自動化、ステージング環境の整備、観測可能性の向上などの要素を重視しています。この段階での重要な洞察は、技術選択の社会化と意思決定プロセスの確立の必要性です。チームトポロジー　価値あるソフトウェアをすばやく届ける適応型組織設計作者:マシュー・スケルトン,マニュエル・パイス日本能率協会マネジメントセンターAmazon協力を代替するプラットフォームチームの創設組織の成長に伴い、アドホックな協力体制から正式なプラットフォームチームへの移行が必要となります。著者は、この移行のタイミングとしてダンバー数（50-250人）を参考指標として挙げています。これは、組織内の協力関係が自然に維持できる限界を示す重要な指標です。この移行のプロセスについては、DevOps Topologiesが有用な参考資料となります。web.devopstopologies.com著者は、プラットフォームチームの設立において、所有権の中央集権化がもたらす利点とコストのバランスを慎重に検討する必要性を強調しています。特に注目すべきは、新しい技術やアーキテクチャではなく、問題解決に焦点を当てるという原則です。これは、プラットフォームチームが陥りがちな、技術的な理想主義による過度な複雑化を避けるための重要な指針となります。internaldeveloperplatform.org伝統的なインフラストラクチャ組織の変革既存のインフラストラクチャ組織をプラットフォームエンジニアリング組織へと変革する過程について、著者は包括的なガイダンスを提供しています。特に重要なのは、エンジニアリング文化全体の変革の必要性です。従来のコスト管理やベンダー交渉中心の文化から、ユーザー中心の製品開発文化への転換が求められます。この変革プロセスを支援するフレームワークとして、Thoughtworks Technology Radarが有用です。www.thoughtworks.com特に重要なのは、エンジニアリング文化全体の変革の必要性です。従来のコスト管理やベンダー交渉中心の文化から、ユーザー中心の製品開発文化への転換が求められます。 本を紹介します。伝統的な組織からプロダクト中心の組織への移行について詳しく解説しています。PROJECT TO PRODUCT　フローフレームワークでデジタルディスラプション時代に成功する方法作者:MIK KERSTENパレードAmazon変革のプロセスにおいて、著者は段階的なアプローチの重要性を強調しています。最も有望な領域から始め、成功事例を積み重ねていくことで、組織全体の変革を推進することが推奨されています。また、プロダクトマネージャーの役割についても現実的な視点が示されており、単にプロダクトマネージャーを採用するだけでは不十分で、エンジニアリングチームの協力が不可欠であることが指摘されています。「変化を嫌う人」を動かす:魅力的な提案が受け入れられない4つの理由作者:ロレン・ノードグレン,デイヴィッド・ションタル,船木 謙一(監修)草思社Amazon章全体からの学び第3章は、プラットフォームエンジニアリングの導入と発展に関する実践的なガイドを提供しています。とりわけ重要なのは、組織の規模や成熟度に応じて適切なアプローチを選択する必要性です。私自身も組織のプラットフォームエンジニアリングを主導している立場から、小規模スタートアップでは軽量なプロセスと基本的な自動化から始め、成長に伴って段階的に発展させていく著者の提案に強く共感します。特に印象的なのは、著者がプラットフォームエンジニアリングを単なる技術的な取り組みではなく、組織文化の変革として捉えている点です。これは私の実務経験とも一致しており、多くの組織が陥りがちな技術偏重のアプローチを避けるための重要な示唆となっています。例えば、私のチームでは新しい技術の導入よりも、まず既存の問題解決と開発者体験の向上に焦点を当てることで、より持続可能な変革を実現できています。また、チーム編成に関する著者の洞察も非常に実践的です。特に、大企業出身のエンジニアの採用に関する警告は、私自身の経験からも非常に的確だと感じています。優れた技術力を持っていても、規模の異なる組織での経験をそのまま適用しようとする傾向は、しばしば新たな問題を引き起こす原因となりうるからです。この章の知見は、今後のプラットフォームエンジニアリングの実践において重要な指針となるでしょう。組織の成熟度に応じた段階的なアプローチ、ユーザー中心の文化醸成、そして適切なチーム構築は、成功への鍵となる要素です。私たちプラットフォームエンジニアリングリーダーは、これらの知見を活かしながら、各組織の状況に適した変革を推進していく必要があります。Chapter 4. Building Great Platform Teams第4章「Building Great Platform Teams」は、プラットフォームエンジニアリングチームの構築と育成に焦点を当てています。この章では、効果的なプラットフォームチームの構築に必要な多様な役割と、それらの役割間のバランスの取り方について、実践的な知見が提供されています。特に、ソフトウェアエンジニアとシステムエンジニアの異なる視点をどのように融合させ、顧客中心のプラットフォームを構築するかという課題に深く切り込んでいます。シングルフォーカスチームの課題単一の視点に偏ったチーム構成は、長期的に見て大きな課題を生み出します。システムエンジニアに偏重したチームは運用面では優れているものの、プラットフォームの抽象化や設計面で課題を抱えがちです。一方、ソフトウェアエンジニアに偏重したチームは新機能の開発には長けていますが、運用安定性や既存システムの改善に対する意識が低くなりがちです。私の経験からも、この両極端な状況を目にすることが多々あります。過去のプロジェクトでは、システムエンジニアの視点が強すぎるあまり、新機能開発に対して過度に慎重になり、結果として顧客ニーズへの対応が遅れるという課題がありました。一方で、開発速度を重視するあまり、運用の視点が欠如し、本番環境での深刻な問題を引き起こすケースも見てきました。Figure 4-1. Breaking down the major engineering roles in a platform engineering team より引用[Figure 4-1]で示されているように、プラットフォームエンジニアリングチームにおける主要なエンジニアリング役割の分類は、このバランスの重要性を明確に表しています。プラットフォームエンジニアの多様な役割プラットフォームエンジニアリングチームにおける主要な役割について、著者は4つの異なる専門性を持つエンジニアの重要性を強調しています。Software Engineerはソフトウェア開発に特化しながらもシステムへの深い理解と運用への関心を持ち、ビジネスクリティカルなシステムのオンコール対応ができ、慎重なペースでの開発に納得できる人材です。Systems EngineerはDevOpsエンジニアやSREに近い立場ながら、より広範な視点を持ち、インフラストラクチャの統合からプラットフォームのコードベースに関わる深いシステムの問題解決まで、幅広い業務を担当します。Reliability Engineerは信頼性に特化し、インシデント管理、SLOのコンサルティング、カオスエンジニアリング、ゲームデイの実施など、システム全体の信頼性向上に注力します。そしてSystems Specialistは、ネットワーキング、カーネル、パフォーマンス、ストレージなど、特定の技術領域に深い専門性を持つエンジニアですが、著者はこの役割については組織の規模と必要性が明確になってから採用することを推奨しています。特に印象的なのは、各役割の採用と評価についての具体的なアドバイスです。例えば、システムエンジニアの採用において、コーディング面接の柔軟な運用を提案しています。私のチームでもこのアプローチを採用し、結果として運用経験が豊富で、かつ適度なコーディングスキルを持つエンジニアの採用に成功しています。また、クラウドネイティブプラットフォームの構築において、これら4つの役割が相互に補完し合い、それぞれの専門性を活かしながら協働することで、より堅牢なプラットフォームの実現が可能になることを日々の実務で実感しています。プラットフォームエンジニアリングマネージャーの重要性プラットフォームエンジニアリングマネージャーには、プラットフォームの運用経験、長期プロジェクトの経験、そして細部への注意力が不可欠です。私の経験上、特に運用経験の重要性は強調してもしすぎることはありません。複雑なシステムの運用経験がないマネージャーが、技術的な課題の深刻さを過小評価し、結果として重大なサービス障害を引き起こすケースを何度も目にしてきました。プロダクトマネジメントのすべて 事業戦略・IT開発・UXデザイン・マーケティングからチーム・組織運営まで作者:及川 卓也,小城 久美子,曽根原 春樹翔泳社Amazonチーム文化の構築と維持チーム文化の構築は、技術的な課題と同じくらい重要です。著者が示す開発チームとSREチームの統合事例は、私自身のチーム統合経験とも共鳴する部分が多くあります。特に、異なる文化を持つチームを統合する際の段階的なアプローチは、非常に実践的です。私のチームでは、定期的な技術共有セッションとクロスファンクショナルなプロジェクト編成を通じて、異なる背景を持つエンジニア間の相互理解を促進しています。これにより、「システムチーム」vs「開発チーム」という対立構造を避け、より協調的な文化を醸成することができています。章全体からの学びプラットフォームエンジニアリングチームの成功には、技術的なスキルと組織文化の両面でのバランスが不可欠です。著者の提案する4つの役割分類と、それぞれの役割に対する適切な評価・育成方法は、実践的で価値のある指針となっています。特に重要なのは顧客エンパシーです。これは単なるスキルではなく、チーム全体の文化として根付かせる必要があります。プラットフォームエンジニアリングチームが提供する価値は、単なる技術的な解決策ではなく、顧客の課題を深く理解し、それに対する適切な解決策を提供することにあるからです。今後のプラットフォームエンジニアリングには、技術の進化に加えて、組織のデジタルトランスフォーメーションへの対応も求められます。この章で学んだチーム構築の原則は、そうした変化に対応する上で重要な指針となるでしょう。個人的な経験からも、技術と人、そして文化のバランスを取ることが、持続可能なプラットフォーム組織の構築には不可欠だと確信しています。Chapter 5. Platform as a Product第5章「Platform as a Product」は、プラットフォームエンジニアリングにおいて、プラットフォームを製品として捉えるアプローチの重要性と実践方法について深く掘り下げています。著者は、組織内プラットフォームの構築において、プロダクト思考を採用することの意義と、その実現に向けた具体的な戦略を提示しています。顧客中心のプロダクトカルチャーの確立著者は、内部顧客の特性として、小規模な顧客基盤、囚われの観客、利害の対立、顧客満足度の変動、そして時として競合者となり得る顧客の存在を挙げています。私の経験でも、特に囚われの観客という特性は重要で、単にプラットフォームの使用を強制するのではなく、真に価値のある製品として受け入れられる必要があります。著者が提唱する「顧客エンパシー」の文化は、面接プロセスからの組み込み、顧客中心の目標設定、ユーザーフィードバックの定期的な収集など、具体的な施策を通じて醸成されます。私のチームでも、エンジニアのサポート輪番制を導入し、顧客の課題を直接理解する機会を設けることで、より顧客志向の製品開発が実現できています。プロダクトディスカバリーとマーケット分析新しいプラットフォーム製品の発見と検証について、著者は他チームが構築した成功事例を基に広範な用途に適用可能な製品として発展させること、特定のチームと協力して具体的な課題解決から始めて一般化可能な製品を作り出すこと、そして導入障壁が低く明確な価値提案を持つ製品から着手することという三つのアプローチを提示しています。プロダクトロードマップの重要性著者は、プロダクトロードマップの構築において、プラットフォームが目指す理想的な状態を示す長期的なビジョン、ビジョン実現のための具体的なアプローチを示す中期的な戦略、定量的な成功指標となる年間目標とメトリクス、そして具体的な実装計画となる四半期ごとのマイルストーンという段階的なアプローチを提案しています。この考え方は、「プロダクトマネージャーのしごと 第２版」でも強調されており、同書ではプロダクトマネージャーの重要な役割として、ビジョンとロードマップの策定、顧客ニーズの深い理解、データ駆動の意思決定、そしてステークホルダーとの効果的なコミュニケーションを挙げています。特に、プロダクトロードマップは単なる実装計画ではなく、製品の戦略的な方向性を示す重要なツールとして位置づけられています。プロダクトマネージャーのしごと 第2版 ―1日目から使える実践ガイド作者:Matt LeMayオーム社Amazon失敗のパターンと対策著者は主要な失敗パターンとして、移行コストの過小評価、ユーザーの変更予算の過大評価、安定性が低い状況での新機能価値の過大評価、そしてエンジニアリングチームの規模に対する製品マネージャーの過剰な配置を指摘しています。私の経験からも、特に移行コストの過小評価は深刻な問題となりがちで、新機能の魅力に目を奪われ、既存システムからの移行に伴う実務的な課題を軽視してしまうケースを何度も目にしてきました。章全体からの学びプラットフォームを製品として扱うアプローチの成功には、文化、製品市場適合性、実行の3つの要素が不可欠です。著者が強調するように、単なる技術的な優位性ではなく、顧客価値の創出と組織全体への影響を考慮した包括的なアプローチが求められます。プラットフォームエンジニアリングリーダーとして、この章から学んだ最も重要な教訓は、技術的な卓越性と顧客価値のバランスを取ることの重要性です。プラットフォームは技術的に優れているだけでなく、実際のユーザーにとって価値のある、使いやすい製品でなければなりません。また、私はプロダクトマネジメントについて学んできてなかったので主張としてなんとなくしか理解できない事柄もいくつかあった。Chapter 6. Operating Platforms第6章「Operating Platforms」は、プラットフォームエンジニアリングにおける運用の本質と、その実践的なアプローチについて深く掘り下げています。この章では、プラットフォームの運用が単なる技術的な課題ではなく、組織全体の成功に直結する戦略的な要素であることを強調しています。著者は、「レアなことは規模が大きくなると一般的になる」という Jason Cohen の言葉を引用しながら、プラットフォームの規模拡大に伴う運用上の課題とその対処方法について詳細に論じています。【改訂新版】システム障害対応の教科書作者:木村 誠明技術評論社Amazonオンコール体制の重要性と実践著者は、オンコール体制について非常に現実的な視点を提供しています。特に印象的だったのは、24x7のオンコール体制の必要性についての議論です。私自身、過去に「重要ではない」と思われる開発者ツールのプラットフォームでさえ、予想外のタイミングで重要になる経験をしてきました。例えば、深夜のクリティカルなバグ修正時にデプロイメントプラットフォームが機能しないという状況は、まさに著者が指摘する通りの事例です。著者が提案する「週に5件以下のビジネスインパクトのある問題」という基準は、理想的ではありますが、現実的な目標として受け入れられます。これは私の経験とも一致しており、このレベルを超えると組織の持続可能性が急速に低下することを実感してきました。特に、この数字を超えると、チームのバーンアウトや離職率の上昇といった深刻な問題につながることを、実際のプロジェクトで何度も目の当たりにしてきました。また、マージされたDevOpsアプローチの重要性について、著者は説得力のある議論を展開しています。プラットフォームチームの規模が限られている場合、開発とオペレーションを分離することは現実的ではないという指摘は、多くの組織にとって重要な示唆となります。私の経験では、小規模なプラットフォームチームでDevとOpsを分離しようとした結果、コミュニケーションの断絶や責任の所在の不明確化といった問題が発生したケースを数多く見てきました。サポート実践の段階的アプローチサポート体制については、著者が提案する4段階のアプローチが非常に実践的です。特に、サポートレベルの形式化から始まり、最終的にはエンジニアリングサポート組織（ESO）の確立に至るまでの発展プロセスは、多くの組織が参考にできるモデルとなっています。第1段階のサポートレベルの形式化では、支援要請の分類と対応の優先順位付けが重要です。私のチームでも、この分類作業を通じて、実際には多くの問題が共通のパターンを持っていることが分かり、効率的な対応方法を確立することができました。第2段階のクリティカルでないサポートのオンコールからの分離は、チームの持続可能性を確保する上で重要なステップです。私の経験では、この分離を実施することで、開発者が本来の開発業務に集中できる時間が増え、結果としてプラットフォームの品質向上にもつながりました。第3段階のサポートスペシャリストの採用については、著者が指摘する「ユニコーン」の必要性に強く共感します。T1とT2の両方をこなせる人材を見つけることは確かに難しいですが、非伝統的な背景を持つ人材の育成という提案は、現実的かつ効果的なアプローチだと考えています。最後の第4段階である大規模なエンジニアリングサポート組織の確立については、著者が提供するFAANG企業での実例が非常に参考になります。特に、アプリケーションの階層化とそれに応じたSLAの設定、顧客のオンコール要件、システムエンジニアの採用といった具体的な施策は、大規模組織での運用の複雑さと、その解決策を理解する上で重要な示唆を提供しています。運用フィードバックの実践運用フィードバックの実践については、著者がSLO、SLA、エラーバジェットについて興味深い見解を示しています。特に、エラーバジェットが必ずしも万能な解決策ではないという指摘は、現実の組織運営において非常に重要な視点です。私の経験では、エラーバジェットの導入が却ってチーム間の対立を生む結果となったケースもありました。著者が提案する合成モニタリングの重要性は、現代のプラットフォーム運用において極めて重要です。開発時間の25%、リソースコストの10%という投資推奨は、一見高額に感じるかもしれませんが、問題の早期発見と対応によって得られる価値を考えると、十分に正当化できる投資だと考えています。私のチームでも、合成モニタリングの導入により、ユーザーからの報告前に問題を検知し、対応できるケースが大幅に増加しました。変更管理の現実的アプローチ変更管理に関する著者の見解は、現代のDevOps実践との関連で特に興味深いものでした。完全な自動化を目指しつつも、その過程での適切な変更管理の重要性を説いている点は、多くのプラットフォームチームにとって重要な示唆となります。著者が指摘する通り、プラットフォームの変更は複雑で状態を持つことが多く、単純なCI/CDの適用が難しい場合が多いです。私の経験でも、キャッシュクリアやデータベースマイグレーションなど、慎重な制御が必要な操作が多く存在し、これらの管理には明確なプロセスと慎重なアプローチが必要でした。運用レビューの実践運用レビューについての議論は、特にリーダーシップの観点から重要です。チームレベルでのシンプルかつ厳格なレビュー、そして組織レベルでの本質的なレビューの必要性は、プラットフォーム運用の成功に不可欠な要素として描かれています。私の経験では、週次の運用レビューを通じて、潜在的な問題を早期に発見し、対応することができました。特に、ページング頻度、サポートチケットの傾向、インシデントの根本原因分析などを定期的にレビューすることで、システムの健全性を維持し、改善の機会を見出すことができました。また、著者が強調するリーダーシップの関与の重要性は、非常に重要な指摘です。運用レビューに経営層が積極的に参加することで、運用上の課題が適切に理解され、必要なリソースの確保や優先順位付けがスムーズに行われるようになった経験があります。章全体からの学びこの章は、プラットフォーム運用の複雑さと、それを成功に導くための実践的なアプローチを包括的に示しています。特に、運用の規律がプラットフォームの成功にとって不可欠であることを強調している点は、現代のソフトウェア開発環境において極めて重要な示唆となっています。読者として強く感じたのは、プラットフォーム運用が単なる技術的な課題ではなく、組織的な取り組みとして捉える必要があるという点です。特に、チームの持続可能性とユーザー満足度の両立という観点から、著者の提案する実践的なアプローチは非常に価値があります。この章で提示されている運用プラクティスは、理想的ではありますが現実的な目標として設定されており、段階的な改善のためのロードマップとしても機能します。私自身、これらのプラクティスの多くを実践してきましたが、特に重要なのは、組織の規模や成熟度に応じて適切なアプローチを選択し、継続的に改善を進めていく姿勢だと考えています。最後に、この章の内容は、プラットフォームエンジニアリングリーダーが直面する現実的な課題と、その解決のための具体的なアプローチを提供しており、現代のソフトウェア開発組織にとって重要な指針となっています。特に、運用の持続可能性とビジネス価値の創出のバランスを取りながら、組織を成長させていくための実践的な知見は、非常に価値のあるものだと言えます。Chapter 7. Planning and Delivery第7章「Planning and Delivery」は、プラットフォームエンジニアリングにおける計画立案と実行の重要性について深く掘り下げています。この章では、長期的なプロジェクトの計画から日々の実行管理、そして成果の可視化に至るまで、プラットフォームチームのリーダーが直面する実践的な課題と、その解決のためのアプローチについて詳細に解説しています。BIG THINGS　どデカいことを成し遂げたヤツらはなにをしたのか？作者:ベント・フリウビヤ,ダン・ガードナーサンマーク出版Amazon長期プロジェクトの計画立案プラットフォームエンジニアリングの特徴的な側面の一つは、長期的なプロジェクトの存在です。私の経験でも、新しいインフラストラクチャの構築や大規模なマイグレーションプロジェクトは、しばしば数ヶ月から数年の期間を要します。著者が提案するプロポーザルドキュメントの作成から実行計画への移行というアプローチは、このような長期プロジェクトを成功に導くための実践的な方法論として非常に重要です。特に印象的だったのは、プロジェクトの目的と要件をプロポーザルドキュメントで明確化する部分です。私自身、過去に大規模なマイグレーションプロジェクトをリードした際、初期段階でのプロポーザルドキュメントの重要性を痛感しました。背景、テネット、ガイドライン、問題の詳細、解決策の概要、実行計画という構造化されたアプローチは、関係者間の合意形成と期待値の調整に非常に効果的でした。ボトムアップなロードマップ計画著者が提案するボトムアップなロードマップ計画は、プラットフォームチームが直面する現実的な課題に対する実践的な解決策を提供しています。特に、KTLO（Keep the Lights On）作業、マンデート、システム改善という3つの主要な作業カテゴリの区分は、リソース配分と優先順位付けの明確な枠組みを提供します。私のチームでも、KTLOワークの見積もりから始めて、段階的にプランニングの精度を上げていく手法を採用しています。特に、全体の40%をKTLOに、残りを70/20/10の比率で新機能開発、アーキテクチャ改善、イノベーションに配分するというガイドラインは、バランスの取れたリソース配分の指針として有用でした。戦略の要諦 (日本経済新聞出版)作者:リチャード・Ｐ・ルメルト日経BPAmazon隔週での成果と課題の共有著者が提案する「Wins and Challenges」という取り組みは、プラットフォームチームの成果を可視化し、組織全体との信頼関係を構築するための効果的な方法です。私のチームでも、この手法を導入してから、ステークホルダーとのコミュニケーションが大幅に改善されました。特に重要なのは、チャレンジを適切に共有することの価値です。私の経験では、問題を隠すのではなく、適切に共有し、解決に向けた支援を得られる関係性を構築することが、長期的な信頼関係の構築に不可欠でした。このような定期的な成果共有の重要性は、「SREsのためのSRE定着ガイド」でも定点観測会として紹介されており、インフラストラクチャーの価値を他のチームに継続的に伝えていく機会として非常に有効です。 speakerdeck.comプロジェクト管理の実践的アプローチ著者が警告する「長期的な停滞」に陥るリスクは、多くのプラットフォームチームにとって現実的な課題です。私も過去に、過度に野心的な目標設定や不明確な問題設定により、プロジェクトが停滞する経験をしました。これを避けるために、プロジェクトの範囲を適切に設定し、段階的な価値提供を重視するアプローチを採用しています。章全体からの学びこの章で提示されている計画立案と実行管理のフレームワークは、プラットフォームエンジニアリングの成功に不可欠な要素を網羅しています。特に、長期的なビジョンと短期的な成果のバランス、透明性の高いコミュニケーション、そして継続的な価値提供の重要性は、現代のプラットフォームエンジニアリングにおいて極めて重要です。私の経験からも、これらの実践は組織の規模や成熟度に関わらず、適用可能で効果的なアプローチだと確信しています。ただし、各組織の状況に応じて適切にカスタマイズすることが重要です。特に、チームの規模が小さい段階では、過度に形式的なプロセスを避け、エッセンシャルな実践に焦点を当てることを推奨します。この章の内容は、プラットフォームエンジニアリングチームが直面する計画立案と実行管理の課題に対する実践的なガイドとして、非常に価値のあるものだと評価しています。Chapter 8. Rearchitecting Platforms第8章「Rearchitecting Platforms」は、プラットフォームの再アーキテクチャリングという重要なテーマについて、その必要性、アプローチ、実践方法を包括的に解説しています。著者は、プラットフォームの進化が不可避であるという現実を踏まえ、どのようにして既存のシステムを運用しながら進化させていくかという実践的な知見を提供しています。特に印象的なのは、冒頭のRandy Schoupによる「If you don't end up regretting your early technology decisions, you probably overengineered.」（初期の技術選定を後悔しないのであれば、おそらく過剰設計だった）という引用です。この言葉は、プラットフォームエンジニアリングにおける現実的なアプローチの重要性を端的に表現しています。進化的アーキテクチャ ―絶え間ない変化を支える作者:Neal Ford,Rebecca Parsons,Patrick KuaオライリージャパンAmazonまた、日本の伊勢神宮で実践される式年遷宮のように、定期的にシステムを刷新しながら価値を維持・向上させていく「式年遷宮アーキテクチャ」の考え方も、この文脈で参考になる概念といえます。agnozingdays.hatenablog.comv2開発とリアーキテクチャリングの選択Figure 8-1. How a platform is successfully rearchitected over time より引用[Figure 8-1]は、プラットフォームの進化とリアーキテクチャリングの関係を時系列で示した重要な図です。この図は、プラットフォームが「Scrappy Platform」から「Scalable Platform」を経て「Robust Platform」へと進化していく過程を表しています。著者は、新システムを一から作り直すv2アプローチと、既存システムを進化させるリアーキテクチャリングアプローチを比較し、後者を推奨しています。私自身の経験からも、v2アプローチの失敗を何度も目にしてきました。特に印象的だったのは、セカンドシステム効果による過剰な機能の盛り込みと、移行コストの過小評価という2つの典型的な失敗パターンです。たとえば、あるプロジェクトでは、既存システムの問題点を全て解決しようとするあまり、新システムの設計が複雑化し、開発期間が当初の見積もりの3倍以上に膨れ上がってしまいました。結果として、ビジネスニーズの変化に追いつけず、プロジェクトは中止を余儀なくされました。著者が提案する3つの異なるエンジニアリングマインドセット（パイオニア、セトラー、タウンプランナー）の分類は、非常に示唆に富んでいます。私のチームでも、このフレームワークを参考に、フェーズに応じた適切な人材配置を行うことで、より効果的なリアーキテクチャリングを実現できています。パイオニアマインドセットは、新しい可能性を探索し、革新的なソリューションを生み出すのに長けています。一方で、セトラーマインドセットは、実験的なアイデアを実用的なプロダクトへと昇華させる能力に優れています。そして、タウンプランナーマインドセットは、システムの効率化と産業化を得意としています。セキュリティアーキテクチャの重要性特に注目すべきは、セキュリティをアーキテクチャレベルで考える必要性についての指摘です。著者は、プラットフォームのセキュリティは後付けではなく、設計段階から組み込まれるべきだと主張しています。これは、私が過去に経験した大規模なセキュリティインシデントからも、極めて重要な教訓だと感じています。例えば、あるプロジェクトでは、セキュリティを後付けで考えたために、重要なアーキテクチャ上の変更が必要となり、多大なコストと時間を要しました。特に、マルチテナント環境におけるデータの分離や、認証・認可の仕組みは、後からの変更が極めて困難でした。「サイバー犯罪を完全に防ぐことはできないが、システムをよりスマートに設計することで被害を最小限に抑えることは可能」という著者の指摘は、現代のセキュリティアプローチの本質を突いています。特に重要なのは、以下の実践的なアプローチです：標準化された認証・認可の仕組みの提供セキュアなデフォルト設定の重要性アクセス制御の宣言的な定義テナント分離アーキテクチャの採用ガードレールの設計と実装リアーキテクチャリングの実践において、著者はガードレールの重要性を強調しています。これは、変更を安全に実施するための枠組みとして機能します。特に、以下の4つの側面からのアプローチが重要です：後方互換性の維持: APIの互換性を保ち、既存のクライアントへの影響を最小限に抑える包括的なテスト戦略: 単体テストから統合テスト、合成モニタリングまでの総合的なアプローチ環境管理の重要性: 開発、テスト、本番環境の適切な分離と管理段階的なロールアウト: カナリアリリースやトランチ方式による慎重なデプロイメント私の経験では、特に後方互換性の維持が重要です。一度失った顧客の信頼を取り戻すのは極めて困難であり、互換性の破壊は避けるべき最大のリスクの一つです。たとえば、あるプロジェクトでは、APIの下位互換性を破壊する変更を行ったことで、顧客のシステムに深刻な影響を与え、その修復に数ヶ月を要しました。リアーキテクチャリングの計画立案著者が提案する4段階の計画立案プロセスは、実践的で効果的なアプローチです：最終目標の設定: 3-5年の長期的なビジョンを明確にする移行コストの見積もり: 現実的なコストと時間の評価12ヶ月での主要な成果の設定: 短期的な価値提供の確保リーダーシップの支持獲得: 組織的なサポートの確保特に印象的なのは、12ヶ月での具体的な成果達成を重視している点です。私のチームでも、長期的なビジョンと短期的な成果のバランスを取ることで、ステークホルダーの信頼を維持しながら、大規模なリアーキテクチャリングを成功させることができました。具体的には、以下のような3つの目標設定が効果的でした：大きな価値を生む野心的な目標: ビジネスにインパクトのある変革より小規模だが確実な価値提供: 現実的な改善の実現技術的な基盤の確立: 新アーキテクチャの実運用開始章全体からの学びこの章から学んだ最も重要な教訓は、リアーキテクチャリングは技術的な課題である以上に、組織的な取り組みであるという点です。技術的な優位性だけでなく、ビジネス価値の創出と組織の継続的な発展を両立させる必要があります。私の経験からも、リアーキテクチャリングの成功には、技術的な卓越性、組織的な支援、そして段階的な実行アプローチが不可欠です。特に、早期の価値提供と段階的な移行を重視することで、リスクを最小限に抑えながら、必要な変革を実現することができます。また、著者が警告する新入社員主導のリアーキテクチャリングの危険性も重要な指摘です。過去の経験や他社での成功体験に基づく性急な変更は、往々にして組織の文化や既存システムの複雑さを考慮できず、失敗に終わることが多いです。最後に、この章は現代のプラットフォームエンジニアリングが直面する重要な課題に対する実践的なガイドを提供しており、多くのプラットフォームリーダーにとって貴重な参考資料となるでしょう。特に、継続的な進化の必要性と実践的なアプローチの重要性は、今後のプラットフォーム戦略を考える上で極めて重要な示唆を提供しています。Chapter 9. Migrations and Sunsetting of Platforms第9章「Migrations and Sunsetting of Platforms」は、プラットフォームエンジニアリングにおける最も困難な課題の一つである、マイグレーションとプラットフォームのサンセットについて詳細に解説しています。著者は、C. Scott Andreasの「プラットフォームは、土台のように、その上に構築するための安定した表面を提供するべきものである」という言葉を引用しながら、変更を管理しつつ安定性を提供するというプラットフォームエンジニアリングの本質的な課題に切り込んでいます。cloud.google.comこちらも参考になるかと思います。learn.microsoft.comaws.amazon.comマイグレーションのアンチパターン著者が指摘するマイグレーションの主要なアンチパターンは、私の経験とも強く共鳴します。特に、コンテキストのない締め切り、曖昧な要件、不十分なテスト、そしてクリップボード持ちの説教者という4つのパターンは、多くのプラットフォームチームが陥りがちな罠です。私自身、ある大規模なマイグレーションプロジェクトで、経営陣から突然の期限を課された経験があります。その時の教訓は、マイグレーションは技術的な課題である以上に、コミュニケーションと計画の課題であるということでした。具体的には、チームメンバーや関係者との丁寧なコミュニケーション、段階的なマイグレーション計画の策定、そして明確な成功基準の設定が重要でした。また、曖昧な要件の問題は特に深刻です。「Product X version Y以前を使用している場合は...」といった通知を送っても、多くのユーザーはProduct Xが何を指すのかすら理解できていないことがあります。これは単なるコミュニケーションの問題ではなく、プラットフォームの可視性と理解可能性の問題でもあります。learning.oreilly.comより簡単なマイグレーションのためのエンジニアリング著者は、マイグレーションを容易にするための技術的なアプローチとして、製品抽象化、透過的なマイグレーション、メタデータ追跡、自動化の重要性を説いています。これらは、現代のクラウドネイティブ環境において特に重要です。私の経験では、グルーコードの最小化とバリエーションの制限が特に重要でした。あるプロジェクトでは、各チームが独自のグルーコードを持っていたために、システムの更新が極めて困難になっていました。この教訓を活かし、次のプロジェクトでは標準化されたインターフェースと限定的なカスタマイズオプションを提供することで、マイグレーションの複雑さを大幅に削減することができました。また、使用状況メタデータの追跡も極めて重要です。過去のプロジェクトで、依存関係の把握が不十分だったために、マイグレーション中に予期せぬ問題が発生し、スケジュールが大幅に遅延した経験があります。この経験から、プラットフォームの使用状況、依存関係、所有者情報を常に追跡するシステムを構築することが、効果的なマイグレーション管理の基盤となることを学びました。スムーズなマイグレーションの調整マイグレーションの成功には、早期のコミュニケーションと公開性が不可欠です。著者が提案する、12ヶ月以上先の期限に対する慎重なアプローチは、私の経験からも非常に賢明です。特に印象的なのは、最後の20%をプッシュするという考え方です。実際のプロジェクトでは、最初の80%は比較的スムーズに進むことが多いものの、残りの20%で予想外の課題に直面することがよくあります。この段階での成功には、古いシステムの適切な維持管理、予期せぬ技術的課題への柔軟な対応、そして責任の所在の明確化が重要です。私の経験では、この最後の20%で重要なのは、チームのモチベーション維持です。古いシステムの維持に割り当てられたチームメンバーが、キャリアの行き詰まりを感じて離職するケースも少なくありません。これを防ぐために、新旧システムの作業をバランスよく配分し、全員が新しい技術にも触れる機会を提供することが重要です。プラットフォームのサンセットプラットフォームのサンセットは、マイグレーション以上に難しい判断を必要とします。著者は、サンセットを検討すべき状況として、ユーザー数の少なさ、高いサポートコスト、他の優先事項への注力必要性という3つの条件を挙げています。私の経験では、特に構築者の抵抗が大きな課題となることがあります。開発者は自分たちが構築したシステムに愛着を持ちがちで、そのサンセットには強い感情的な抵抗を示すことがあります。あるプロジェクトでは, 新システムへの移行が技術的には可能であったにもかかわらず、開発チームの強い愛着により、不必要に長期間両方のシステムを維持することになりました。このような状況を避けるためには、客観的な評価基準と透明性の高い意思決定プロセスが重要です。具体的には、使用状況メトリクス、維持コスト、技術的負債の状況など、定量的なデータに基づく判断を行うことで、感情的な議論を避けることができます。また、サンセット計画の策定においては、段階的なアプローチが効果的です。まず使用制限を設けてから完全な廃止へと移行する方法や、特定の機能のみを段階的に廃止していく方法など、状況に応じた柔軟なアプローチを取ることが重要です。章全体からの学びこの章から得られる最も重要な教訓は、マイグレーションとサンセットは避けられない現実であり、それらを効果的に管理することがプラットフォームチームの価値を証明する機会となるということです。著者が述べているように、マイグレーションは「税金」のようなものかもしれませんが、それは避けられない更新のコストです。プラットフォームエンジニアリングの真価は、より良い自動化、コミュニケーション、実行を通じて、この変更のコストを組織全体で最小化できるという点にあります。私の経験からも、成功するマイグレーションには、技術的な準備、組織的なサポート、そして効果的なコミュニケーションが不可欠です。特に重要なのは、ユーザー体験を最優先し、できる限り多くの作業を事前に準備することです。さらに、マイグレーションやサンセットの経験は、将来のプラットフォーム設計にも活かすべき重要な学びとなります。特に、変更のしやすさを初期の設計段階から考慮することで、将来のマイグレーションコストを低減することができます。最後に、この章は、プラットフォームエンジニアリングにおけるマイグレーションとサンセットの重要性を再認識させ、その実践的なアプローチを提供する貴重な指針となっています。その教訓は、現代のクラウドネイティブ環境において、ますます重要性を増していくことでしょう。Chapter 10. Managing Stakeholder Relationships第10章「Managing Stakeholder Relationships」は、プラットフォームエンジニアリングにおけるステークホルダー管理の重要性と実践的なアプローチについて詳細に解説しています。著者は、プロダクトマネジメントとステークホルダーマネジメントの違いを明確にし、後者がプラットフォームチームの成功にとって極めて重要であることを強調しています。社内政治の教科書作者:高城 幸司ダイヤモンド社Amazonステークホルダーマッピング：パワー・インタレストグリッドFigure 10-1. Power-interest grid, showing the four quadrants of stakeholders based on their power within the organization and interest in your work より引用[Figure 10-1]は、ステークホルダーのマッピングを「パワー」と「関心」の2軸で表現した重要な図です。この図は、ステークホルダーを4つの象限に分類し、それぞれに対する適切なアプローチを示しています。私の経験でも、このような体系的なマッピングは、限られたリソースを効果的に配分する上で非常に有用でした。Figure 10-2. The power-interest grid showing Juan’s stakeholders より引用[Figure 10-2]では、架空の例としてJuanというVPのステークホルダーマップが示されています。この例は、現実のプラットフォームチームが直面する複雑なステークホルダー関係を見事に表現しています。特に重要なのは、パワーと関心の高いステークホルダー（CPOや主要エンジニアリングチームのリーダー）に対する戦略的なアプローチの必要性です。適切な透明性でのコミュニケーション著者は、ステークホルダーとのコミュニケーションにおいて、過度な詳細の共有を避けることの重要性を強調しています。これは、私のチームでも痛感した教訓です。以前、技術的な詳細を過度に共有したことで、かえってステークホルダーの不信感を招いた経験があります。特に重要なのは、1:1ミーティングの戦略的な活用です。初期段階での関係構築には有効ですが、組織の成長とともにその限界も見えてきます。私の経験では、四半期ごとのKeep Satisfied/Keep Informedステークホルダーとの1:1、そして月次でのManage Closelyステークホルダーとの1:1というリズムが効果的でした。受け入れ可能な妥協点の見出し方ステークホルダーとの関係において、妥協は避けられない現実です。特に印象的なのは、「yes, with compromises」というアプローチです。これは、完全な拒否でも無条件の受け入れでもない、現実的な解決策を提供します。シャドウプラットフォームの問題は、多くのプラットフォームチームが直面する課題です。私のチームでも、ある部門が独自のプラットフォームを構築し始めた際、最初は抵抗を感じました。しかし、著者が提案するように、パートナーシップのアプローチを取ることで、最終的には組織全体にとって価値のある結果を生み出すことができました。予算管理とコストの課題経済的な逆風時における予算管理は、プラットフォームチームにとって特に難しい課題です。著者が提案する3段階のアプローチ（明日の受益者の特定、チーム単位での作業のグループ化、カットすべき箇所と維持すべき箇所の明確化）は、実践的で効果的です。私の経験では、ビジネスへの直接的な価値の提示が特に重要でした。例えば、効率化プロジェクトの場合、具体的なコスト削減額を示すことで、予算の正当性を説得力を持って説明することができました。章全体からの学びこの章から得られる最も重要な教訓は、ステークホルダー管理がプラットフォームチームの成功にとって決定的に重要であるという点です。これは単なるコミュニケーションの問題ではなく、組織の戦略的な成功要因です。私の経験からも、良好なステークホルダー関係は、困難な時期を乗り越えるための重要な資産となります。特に、予算削減や組織変更といった厳しい局面では、日頃からの信頼関係が決定的な違いを生みます。最後に、この章が提供する実践的なフレームワークと具体例は、現代のプラットフォームエンジニアリングリーダーにとって、極めて価値のある指針となるでしょう。Part III. What Does Success Look Like?第3部は、プラットフォームエンジニアリングの成功をホリスティックに評価するアプローチを提示しています。Alice in Wonderlandからの引用が示唆するように、プラットフォームチームは常に走り続けているにもかかわらず、その進捗が見えにくいという現実に直面します。著者は、単純なメトリクスやモデルだけでは不十分だとし、アライメント、信頼、複雑性管理、愛される存在という4つの評価領域を提案しています。これは私の実務経験とも強く共鳴します。特に、CNCFのプラットフォームエンジニアリング成熟度モデルを参考にしつつも、より包括的な評価アプローチを取ることの重要性は、多くのプラットフォームリーダーにとって価値のある指針となるでしょう。Chapter 11. Your Platforms Are Aligned第11章「Your Platforms Are Aligned」は、プラットフォームエンジニアリングチームの成功を評価する最初の基準として「アライメント（整合性）」を深く掘り下げています。この章を通じて、著者はプラットフォームチーム間のアライメントがいかに重要か、そしてミスアライメントがどのような問題を引き起こすかを具体的に示しています。特に印象的なのは、冒頭のTom DeMarcoとTim Listerの「チームの目的は目標の達成ではなく、目標の整合性である」という言葉です。この視点は、現代のプラットフォームエンジニアリングにおいて極めて重要な示唆を提供しています。アジャイルチームによる目標づくりガイドブック OKRを機能させ成果に繋げるためのアプローチ作者:小田中 育生翔泳社Amazon目的のアライメント著者は目的のアライメントの重要性を、継続的インテグレーション（CI）プラットフォームと運用システムプラットフォームの対立という具体例を通じて説明しています。この事例は、私自身が経験したプラットフォームチーム間の対立を思い起こさせます。特に印象的なのは、OSプラットフォームチームがインフラストラクチャマインドセットを保持し、顧客体験よりも技術的完璧さを優先してしまうという状況です。著者は、プラットフォームチームの共通目的として、製品（キュレートされた製品アプローチ）、開発（ソフトウェアベースの抽象化）、幅広さ（広範な開発者基盤へのサービス提供）、運用（ビジネスの基盤としての運用）という4つの柱を挙げています。これらの柱は、プラットフォームチームが技術的な卓越性だけでなく、組織全体の価値創出に貢献するための重要な指針となります。製品戦略のアライメント製品戦略のアライメントについて、著者は4つのプラットフォームチームが異なる技術的選択を行い、その結果として5つの異なるコンピュートプラットフォームが存在するという事例を挙げています。これは、私が以前経験した状況と非常によく似ています。チーム間の協調不足が、重複した機能と互換性の問題を引き起こし、結果として顧客にとって使いづらい環境を作ってしまうのです。著者は、この問題に対する解決策として、独立したプロダクトマネジメント、独立したリードIC、全社的な顧客調査からのフィードバック、そして必要に応じた組織再編という4つのアプローチを提案しています。特に、プロダクトマネジメントの独立性について、エンジニアリングマネージャーの直接の影響下から切り離すことの重要性は、実践的な示唆に富んでいます。計画のアライメント計画のアライメントに関して、著者は大規模なプロジェクト（1開発者年以上）に焦点を当てることの重要性を強調しています。細かい計画まで全てを統制しようとすると、チームの機動性が失われ、緊急のニーズに対応できなくなるリスクがあります。これは私の経験とも一致しており、特に大規模な組織では、過度な計画の詳細化がかえって効果的な実行の妨げとなることがあります。著者は、意見の対立を避けることなく、むしろそれを前向きに活用することを提案しています。Amazonの「Have Backbone; Disagree and Commit」という原則を引用しながら、強い信念を持ちつつも、最終的な決定には全面的にコミットするという姿勢の重要性を説いています。プリンシプルドリーダーシップによるアライメント著者は、最終的なアライメントが原則に基づいたリーダーシップから生まれると主張しています。これは単なる上意下達ではなく、協調的で透明性のあるプロセスを通じて、チーム全体が理解し、納得できる決定を導き出すことの重要性を示しています。組織の共通目標を達成するための計画と実行は、単なるトップダウンの意思決定ではなく、チーム全体の協力と理解に基づいて進められるべきです。組織のアライメントへの道筋組織全体のアライメントを実現するには、単なる技術的な調整以上のものが必要です。著者が示す通り、プラットフォームチームのリーダーは、技術的な卓越性とビジネス価値のバランスを取りながら、組織全体の目標達成に向けて多様なステークホルダーと協力していく必要があります。特に、競合するプロジェクトや優先順位の調整において、オープンな議論と明確な意思決定プロセスが重要となります。プラットフォームエンジニアリングの成功は、明確な目標設定と、その目標に向けた組織全体の一貫した取り組みにかかっています。アライメントを通じて、組織は効果的なプラットフォームを構築し、継続的な改善を実現することができます。この章は、そのための具体的な指針と実践的なアプローチを提供しています。章全体からの学びこの章から得られる最も重要な教訓は、プラットフォームアライメントが組織の成功に直接的な影響を与えるという点です。著者が強調するように、アライメントは単なる技術的な統一ではなく、目的、製品戦略、計画という3つの次元で実現される必要があります。私の経験からも、これらの要素が適切に整合していない場合、チーム間の摩擦や非効率な重複投資、そして最終的には顧客満足度の低下につながることを痛感しています。特に印象的なのは、アライメントが「測定可能な改善」と密接に結びついているという著者の指摘です。プラットフォームの成功を評価するには、まず目標について合意し、それに向かって進む必要があります。アライメントのプロセスを通じて、組織は焦点を当てるべき領域をより明確に理解し、具体的な目標と作業項目を設定することができます。私の実務経験でも、製品市場のフィードバックを定期的に収集し、内部メトリクスだけでなく実際のユーザーの声に耳を傾けることで、プラットフォームが選択した方向性が正しいかどうかを判断できることを学びました。これは著者が指摘する「プラットフォームが改善すべき点を意識的に選択できる」という考えと完全に一致します。著者が指摘するように、この章の内容はプラットフォームエンジニアリングに特有のものではありません。しかし、プラットフォームエンジニアリングの文脈では、その価値が直接的な収益成長などの明確な指標で測定できないことが多く、投資先の選択においてより大きな裁量が求められます。これは、プラットフォームリーダーシップの最大の課題の一つとなっています。最後に、この章は個々のプロダクトチームが独自の視点で構築を進めることの危険性を明確に示しています。確かに、これによって部分的な成功は得られるかもしれませんが、チーム全体としての整合性が欠如すると、真の卓越性は達成できません。プラットフォームエンジニアリングの真の成功は、技術的な優秀性だけでなく、組織全体のアライメントを通じて実現されるのです。これらの学びを実践に移す際は、組織の規模や成熟度に応じて適切にアプローチを調整する必要があります。アライメントは一朝一夕には達成できませんが、継続的な対話と調整を通じて、段階的に実現していくことが可能です。Chapter 12. Your Platforms Are Trusted第12章「Your Platforms Are Trusted」は、プラットフォームエンジニアリングにおける信頼の重要性と、その獲得・維持の方法について深く掘り下げています。著者は、Warren Buffettの「信頼は空気のようなものだ - 存在するときは誰も気付かないが、欠如したときは誰もが気付く」という言葉を引用しながら、プラットフォームの成功には信頼が不可欠であることを強調しています。特に、この章では運用能力、大規模投資の意思決定、そしてビジネスへのボトルネック化という3つの主要な信頼喪失のリスクに焦点を当てています。運用における信頼構築運用面での信頼構築について、著者は単なるプラクティスの導入以上のものが必要だと指摘しています。私自身の経験でも、オンコール体制やSLOの設定だけでは、アプリケーションチームの信頼を完全に獲得することは困難でした。特に印象的なのは、経験値の圧縮が不可能であるというAmazonの教訓です。これは、大規模運用の経験は実際の運用を通じてしか得られないという現実を端的に表現しています。著者は、この課題に対する2つのアプローチを提案しています。1つ目は大規模運用経験を持つリーダーの採用と権限付与、2つ目は運用リスクの許容度に基づくユースケースの優先順位付けです。これらは、私が過去に経験した運用信頼性の向上プロジェクトとも共鳴する実践的なアプローチです。信頼構築の実践において、私たちのチームで特に効果的だったのは、段階的なアプローチの採用です。まず、非クリティカルなワークロードから始めて、運用の安定性を実証し、そこから徐々にミッションクリティカルなワークロードへと移行していく方法を取りました。例えば、新しいコンテナオーケストレーションプラットフォームの導入時には、最初は内部の開発環境のワークロードのみを対象とし、3ヶ月間の安定運用を確認した後に、段階的に本番環境のワークロードを移行していきました。この過程で特に重要だったのは、透明性の高いコミュニケーションです。週次のステータスレポートでは、インシデントの詳細な分析結果だけでなく、それに基づく具体的な改善計画も共有しました。また、主要なステークホルダーとの定期的な1on1ミーティングでは、技術的な課題だけでなく、ビジネス目標との整合性についても率直な議論を行いました。このような取り組みを通じて、運用面での信頼を着実に築き上げることができました。syu-m-5151.hatenablog.com大規模投資における信頼構築大規模投資に関する信頼構築について、著者は技術的ステークホルダーの賛同とエグゼクティブスポンサーシップの重要性を強調しています。私の経験でも、技術的な正当性だけでなく、ビジネス価値の明確な説明が、大規模投資の承認を得る上で決定的に重要でした。特に、既存システムの維持管理を怠らないことの重要性は、実務を通じて痛感しています。著者が提示する「Icicle」チームの事例は、特に示唆に富んでいます。高レイテンシーに敏感なワークロードを持つチームの信頼を獲得するために、プラットフォームチームが自身の技術的な「正しさ」にこだわるのではなく、顧客のニーズに合わせて柔軟に戦略を変更した例は、現代のプラットフォームエンジニアリングにおいて極めて重要な教訓を提供しています。私たちの組織では、大規模投資の承認プロセスにおいて、段階的なマイルストーンと明確な成功指標の設定を重視しています。例えば、新しいマイクロサービスプラットフォームへの投資では、6ヶ月ごとの具体的な目標を設定し、各フェーズでの成果を定量的に評価できるようにしました。これにより、投資の妥当性を継続的に検証し、必要に応じて計画を調整することが可能になりました。特に重要なのは、ビジネス価値の可視化です。技術的な改善だけでなく、開発者生産性の向上、運用コストの削減、新機能のリリース速度の改善など、具体的な数値で効果を示すことで、エグゼクティブの継続的なサポートを得ることができました。この経験から、大規模投資の成功には、技術的な実現可能性とビジネス価値の両面からの綿密な検討が不可欠だと実感しています。優先順位付けと信頼ビジネスのボトルネックとなることを避けるための信頼構築について、著者はベロシティの文化醸成とプロジェクトの優先順位付けの重要性を説いています。私のチームでも、計画された作業と緊急の要求のバランスを取ることは常に課題でした。特に、「次の四半期のOKRまで待つ必要がある」という対応は、アジャイルなビジネス環境では受け入れられないという著者の指摘は、現実の組織運営と強く共鳴します。著者が紹介するDiego Quirogaの事例は、ボトルネック解消の実践的なアプローチを示しています。特に、セルフサービス化による効率化とサポート要求の分析に基づく改善は、私自身のプラットフォーム改善プロジェクトでも有効だった施策です。過度に結合したプラットフォームの教訓著者は、「バッテリー込み」アプローチの失敗事例を通じて、プラットフォームの過度な結合がもたらす問題を説明しています。この事例は、エンドツーエンドのワークフローを提供しようとするあまり、コンポーネント間の結合が強くなり、最終的に運用の安定性と機能追加の柔軟性を失ってしまうという、多くのプラットフォームチームが陥りがちな罠を見事に描き出しています。章全体からの学びこの章の最も重要な教訓は、信頼の構築には時間がかかるが、その喪失は一瞬であるという現実です。運用上の予期せぬ問題、ビジネスの急激な変化、チームの離職など、私たちの制御を超えた多くの要因が信頼を損なう可能性があります。そのため、プラットフォームリーダーには、日々の活動を通じて継続的に信頼を強化していく努力が求められます。特に印象的なのは、多くのプラットフォームリーダーが陥りがちな傲慢さへの警告です。技術的な正しさにこだわるあまり、顧客やステークホルダーの声に耳を傾けない態度は、長期的な成功の妨げとなります。プラットフォームの真の成功は、技術的な卓越性とビジネス要求への迅速な対応の両立にかかっているのです。この章の学びは、現代のクラウドネイティブ環境において、ますます重要性を増していくでしょう。プラットフォームの信頼性と柔軟性の両立、そして顧客との信頼関係の構築は、今後のプラットフォームエンジニアリングの成功に不可欠な要素となります。Chapter 13. Your Platforms Manage Complexity第13章「Your Platforms Manage Complexity」は、プラットフォームエンジニアリングにおける複雑性管理の本質と実践について深く掘り下げています。著者は、Donald A. Normanの「人々の望ましい行動ではなく、実際の行動に合わせて設計しなければならない」という言葉を引用しながら、複雑性管理が単なる技術的な課題ではなく、人間の行動や組織の現実を考慮に入れた総合的なアプローチを必要とすることを強調しています。 speakerdeck.com意図せぬ複雑性の管理複雑性管理の成功を測る重要な指標の一つは、アプリケーションチームが必要とする「グルー（接着剤）コード」の量です。私の経験では、プラットフォームチームが提供する抽象化が不適切な場合、アプリケーションチームは独自のグルーコードを書かざるを得なくなり、結果として全体の複雑性が増大してしまいます。特に注目すべきは、著者が指摘する「ヒューマングルー」の問題です。これは、技術的なグルーコードの削減を目指すあまり、人間による手動の調整や対応に依存してしまう状況を指します。私のチームでも、以前は運用上の問題解決に人間の介入を多用していましたが、これは持続可能な解決策ではありませんでした。このような課題に対して、私たちは自動化と適切な抽象化のバランスを重視するアプローチを採用しています。例えば、マイグレーションプロジェクトでは、所有権メタデータレジストリを活用し、チケットの自動割り当てと進捗管理を実現しました。これにより、人的なプロジェクト管理の負担を大幅に削減することができました。シャドウプラットフォームの管理シャドウプラットフォームの問題について、著者は完全な抑制ではなく、適切な管理の重要性を説いています。私の経験でも、アプリケーションチームによる独自のプラットフォーム構築を全面的に禁止することは、イノベーションの芽を摘んでしまう危険性があります。特に印象的なのは、シャドウプラットフォームを組織の学習機会として捉える視点です。あるプロジェクトでは、データサイエンスチームが構築した独自のプラットフォームを、最終的に全社的なソリューションへと発展させることができました。これは、パイオニア的なイノベーションとエンタープライズレベルの安定性のバランスを取る良い例となりました。著者が提示する「Single Pane of Glass」のアンチパターンの分析も示唆に富んでいます。統合UIの構築は一見魅力的に見えますが、実際にはベンダーツールの進化に追従することの難しさや、異なるユーザーペルソナのニーズへの対応など、予想以上の複雑性をもたらす可能性があります。成長の管理による複雑性制御著者は、無制限な成長が複雑性を増大させる要因となることを警告しています。これは私の実務経験とも強く共鳴します。特に印象的なのは、効率性の向上とチーム規模の拡大のバランスについての指摘です。私のチームでも、新しい課題に直面するたびに人員を増やすのではなく、まず既存のプロセスの効率化や自動化を検討するようにしています。著者が提案する「既存の領域での新しい作業は、そのチームの既存のメンバーによってまかなわれるべき」というルールは、実践的な指針として非常に有用です。これにより、チームは優先順位の明確化と効率化への投資を迫られ、結果として複雑性の管理にも寄与します。プロダクトディスカバリーを通じた複雑性管理プロダクトディスカバリーの重要性について、著者はオープンソースシステムの導入を例に説明しています。私の経験では、顧客の要求をそのまま受け入れてオープンソースシステムを提供するのではなく、真の要件の理解と適切な抽象化のレベルを見極めることが重要です。特に印象的なのは、データ処理系のOSSに関する事例です。PostgreSQL、Cassandra、MongoDBなどの広範なインターフェースを持つシステムの運用は、ユースケースと利用者の増加に伴って線形に複雑性が増大していきます。これは、多くのプラットフォームチームが直面する現実的な課題です。内部と外部の複雑性のバランス最後に著者が示すデータプラットフォームの事例は、複雑性管理の実践的なチャレンジを見事に描き出しています。10人程度のチームがPostgreSQL、Kafka、Cassandraなどの複数のOSSシステムを運用する中で直面した課題は、私自身の経験とも強く共鳴します。特に、運用負荷の増大と顧客要求の多様化のバランスを取ることの難しさは、多くのプラットフォームチームが直面する普遍的な課題です。著者が描写する改善の試行錯誤のプロセスは、とりわけ示唆に富んでいます。ベンダーのホステッドサービスへの移行、SLAの明確化、APIの完全なカプセル化など、様々なアプローチを試みながらも、それぞれに課題があったという経験は、私たちの組織でも同様でした。特に印象的なのは、これらの「失敗」を通じて、真の顧客ニーズの理解と実現可能な解決策の発見につながっていったという点です。最終的な解決策として導き出された、シンプルな(key, value)セマンティクスのプラットフォームと特定のユースケースに最適化されたSQL系システムの組み合わせは、複雑性管理の理想的なアプローチを示しています。これは、完璧な解決策を一度に実現しようとするのではなく、段階的な改善と顧客との密接な協力を通じて、持続可能な解決策を見出していく過程の重要性を示しています。章全体からの学びこの章の最も重要な教訓は、複雑性管理が継続的な取り組みであり、完全な解決は望めないという現実的な認識です。しかし、これは諦めるべき理由ではなく、むしろ組織の北極星として、継続的な改善の方向性を示す指針となります。私の経験からも、複雑性管理の成功には、技術的なソリューション、組織的な取り組み、そして顧客との協力の3つの要素が不可欠です。特に重要なのは、完璧を求めるのではなく、継続的な改善と学習のサイクルを確立することです。最後に、この章は現代のプラットフォームエンジニアリングが直面する本質的な課題に対する実践的な洞察を提供しています。複雑性の管理は、技術的な課題であると同時に、組織的な課題でもあります。プラットフォームエンジニアリングチームのリーダーとして、この両面からのアプローチを常に意識しながら、持続可能な改善を推進していく必要があるでしょう。Chapter 14. Your Platforms Are Loved第14章「Your Platforms Are Loved」は、プラットフォームエンジニアリングにおける「愛される」という概念の意味と重要性について深く掘り下げています。著者は、Tina Turnerの「What's love got to do with it?」という問いかけから始め、内部向けのツールが「愛される」必要があるのかという根本的な疑問に対して、説得力のある回答を提示しています。この章では、プラットフォームが単に機能するだけでなく、ユーザーに愛される存在となることが、実は生産性向上の重要な指標となることを示しています。愛されるプラットフォームの本質著者は、日常生活で私たちが愛用する道具を例に挙げ、プラットフォームが「愛される」とはどういうことかを説明しています。私の経験でも、最も成功したプラットフォームは、必ずしも最も高価なものや機能が豊富なものではなく、特定の目的に対して適切に設計され、信頼性高く動作するものでした。特に印象的なのは、著者が生産性の直接的な測定の難しさに触れながら、「愛される」ことを生産性の代理指標として捉える視点です。私のチームでも、以前は定量的なメトリクスにこだわりすぎて、実際のユーザー体験を見失いかけた時期がありました。単純な採用率や効率性の指標に固執すると、プラットフォームチームが制御しやすいシステムを作ることに注力してしまい、実際のユーザーニーズを見失うという著者の指摘は、多くのプラットフォームチームが陥りがちな罠を的確に描写しています。「単に動く」から「愛される」への進化著者が紹介するAmazonのApolloプラットフォームの事例は、プラットフォームが「愛される」ために必要な要素を具体的に示しています。特に印象的なのは、優れたUIと自動化インターフェース、強い意見を持った設計、そして必要に応じて抽象化を「突き破れる」柔軟性という3つの特徴です。『INSPIRED 熱狂させる製品を生み出すプロダクトマネジメント』では、成熟したIT企業の製品開発に共通する3つの特徴として、リスクを開発の最終段階ではなく初期段階で積極的に特定・対処すること、製品の定義とデザインを順序立てて進めるのではなく協調的に同時進行させること、そして単なる機能実装ではなく本質的な問題解決にフォーカスすることを挙げています。また著者は、優れたプロダクトマネジャーの条件として、顧客、データ、自社ビジネス、そして市場・業界それぞれについての深い知見を持つことが不可欠だと説いています。こちらの方が良いでしょうか？プロダクトマネジメントの本質をよりシンプルに表現してみました。INSPIRED 熱狂させる製品を生み出すプロダクトマネジメント作者:マーティ・ケーガン,佐藤真治,関満徳日本能率協会マネジメントセンターAmazon私のチームでも、最近完了したコンテナオーケストレーションプラットフォームの刷新プロジェクトで、これらの原則を意識的に取り入れました。特に、「システムの状態をUIが正確に反映している」という信頼性の確保と、「特殊なケースにも対応できる拡張ポイントの提供」というバランスの取れた設計により、ユーザーからの高い評価を得ることができました。ハックのような解決策も愛される理由著者が紹介する「Waiter」プラットフォームの事例は、特に示唆に富んでいます。技術的には「ハック」のように見える実装でも、ユーザーの実際の問題を解決し、摩擦を最小限に抑えることができれば、強く支持される可能性があることを示しています。私の経験でも、「理想的」な設計からは外れるものの、ユーザーの具体的な課題を解決する実装が、結果として大きな価値を生み出すケースを何度か経験しました。例えば、あるマイクロサービスプラットフォームでは、理想的なマイクロサービスアーキテクチャの原則から外れる実装を許容することで、開発者の生産性を大幅に向上させることができました。明白な価値提供による信頼獲得著者が紹介するS3互換オブジェクトストアの事例は、既知の価値と適切な実装の組み合わせの重要性を示しています。特に重要なのは、認知度、互換性、エンジニアリング品質、市場投入までの時間という4つの要素です。これは、私が過去に経験した失敗から学んだ教訓とも一致します。章全体からの学びこの章の最も重要な教訓は、プラットフォームが「愛される」ということは、単なる感情的な問題ではなく、実際の生産性と価値創出に直結するという点です。特にSmruti Patelの「マルチツール」という比喩は、プラットフォームの本質を見事に表現しています。私の経験からも、最も成功したプラットフォームは、必ずしも最新のトレンドを追いかけたものではなく、基本的な信頼性を確保しながら、ユーザーの実際の問題を着実に解決していくアプローチを取ったものでした。愛されるプラットフォームを構築するには、技術的な卓越性だけでなく、ユーザーとの深い信頼関係の構築が不可欠です。これは一朝一夕には達成できませんが、継続的な改善と誠実な対話を通じて、確実に実現できる目標なのです。おわりに本書は、プラットフォームエンジニアリングという営みが、技術を極めることと人に寄り添うことの両立を求められる実践であることを、様々な現場での経験を通じて描き出しています。技術的な卓越性を追求しながらも、組織の変革に寄り添い、ステークホルダーとの信頼関係を育み、持続可能な文化を醸成していくという総合的な視点は、現代のソフトウェア開発組織が直面する本質的な課題に対する深い洞察を提供しています。プラットフォームエンジニアリングは、技術的な基盤を「作って終わり」にするのではなく、組織とともに成長し続ける生命体のような存在です。それは、日々の地道な技術の研鑽と、組織やユーザーのニーズへの繊細な理解が融合することで初めて、真の価値を生み出すことができます。本書は、その困難な実践に挑戦する人々にとって、同じ道を歩む先達からの贈り物となるでしょう。今後のソフトウェア開発において、プラットフォームエンジニアリングはますます重要な役割を担っていくことでしょう。しかし、その本質は変わることなく、技術を極めることと人に寄り添うことの両立にあり続けるはずです。本書で示された知見をもとに、各組織が自らの文脈に即した実践を積み重ね、技術と人間性が調和した真に価値あるプラットフォームエンジニアリングを実現していくことを願ってやみません。みなさん、最後まで読んでくれて本当にありがとうございます。途中で挫折せずに付き合ってくれたことに感謝しています。読者になってくれたら更に感謝です。Xまでフォロワーしてくれたら泣いているかもしれません。","isoDate":"2024-10-24T21:06:00.000Z","dateMiliSeconds":1729803960000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"「大規模システムの効率的運用の裏側」というイベントに登壇するのでどんなこと話すか整理する #aeon_tech_hub","link":"https://syu-m-5151.hatenablog.com/entry/2024/10/15/101516","contentSnippet":"大規模システム運用の難しさは、その規模と複雑性に起因します。開発する人も多く、運用に関わる人間も多く、そしてシステムの性能や信頼性を評価する人間も多数います。この多様な関係者の利害が複雑に絡み合う中、技術的な課題に加え、人的・組織的な課題も顕著になります。さらに、複雑に構成されたシステムコンポーネントと日々向き合いながら、刻々と変化するビジネスの要求に応えていく必要があります。これらの要因が重なり合い、大規模システムの運用を極めて困難なものにしているのです。aeon.connpass.comはじめにこのたび、2024年10月23日に開催予定の「＜Platform Engineering、DevOps、CCoE＞大規模システムの効率的運用の裏側」というイベントに登壇者としてお呼びいただきました。大規模システムの効率的運用は非常に複雑な課題であり、アンチパターンはあっても画一的な正解はないと考えています。時に、人的・組織的な制約から、アンチパターンと言われるような策を採用せざるを得ない状況もあるでしょう。システム運用アンチパターン ―エンジニアがDevOpsで解決する組織・自動化・コミュニケーション作者:Jeffery D. SmithオライリージャパンAmazonこのような複雑な背景を持つ大規模システムの運用について議論する機会をいただき、大変光栄に思うとともに、その難しさも痛感しております。このブログでは、イベントの概要をお伝えするとともに、私が登壇者として特に議論したいと考えているポイントをご紹介します。大規模システムの効率的な運用に関心のある方々に、このイベントが提供する価値と、当日予想される議論の展開について、参考情報を提供できればと思います。イベント概要と登壇の意気込み「大規模システムを少人数で効率的に、そして安全に運用する工夫」をテーマにしたパネルディスカッションに登壇することになりました。このイベントでは、大規模システムの効率的な運用に関する最新のトレンドと実践的なアプローチについて議論したいです。イベントで期待すること時間の制約があるため、全ての話題を深く掘り下げることは難しいですが、以下のような内容について議論できればと思っています。1. 運用設計の重要性の再確認大規模システムの運用における設計の重要性について、特にプロセスの標準化と自動化について様々な観点から議論が展開されることを期待しています。特に注目したいのは、継続的デリバリーに関する最新トレンドです。これらは、効率的な運用の基盤となるものであり、常に進化し続けています。同時に、効果的な監視（Monitoring）と観測可能性（Observability）確保のベストプラクティスも重要なトピックです。システムの健全性を常に把握し、問題を早期に発見・対処するための手法は、大規模システム運用の要となります。さらに、実際の現場での継続的改善サイクルの実践例と、それに伴う課題についても深く掘り下げたいと考えています。理論と実践のギャップを埋め、実効性のある改善活動を展開するための知見が共有されることを期待しています。最後に、大規模システム特有のリスク管理とインシデント対応の効果的アプローチについても議論したいと思います。予期せぬ障害や障害への迅速かつ適切な対応は、システムの信頼性維持に不可欠です。これらのトピックを通じて、参加者の皆様が自身の環境で「次に効率化に取り組むべき観点」を見出すヒントになればと思います。限られた時間ではありますが、できるだけ具体的な事例や実践的なアドバイスを共有できるよう努めたいと考えています。運用設計の重要性を再確認し、その効果的な実践方法について深い洞察を得られる場となることを目指したいです。2. 現代的アプローチによる大規模システム運用の効率化大規模システムの効率的な運用を実現するためには、Platform Engineering、DevOps、CCoE（Cloud Center of Excellence）、そしてSRE（Site Reliability Engineering）といった現代的なアプローチの統合的な活用が不可欠です。これらの概念は、それぞれが独自の強みを持ちながら、相互に補完し合うことで、システム運用の効率性と信頼性を大きく向上させます。これらをスピーカーの方々がどう展開していくか楽しみです。各概念については概要とおすすめ資料を貼っておきます。2.1 Platform EngineeringPlatform Engineeringは、開発者の生産性向上と業務効率化の要となる重要な分野です。議論の中心となるのは、開発者体験（Developer Experience）向上の具体的な方策です。これには、内部プラットフォーム構築のケーススタディやセルフサービス化によるデベロッパーの生産性向上が含まれます。また、プラットフォームの標準化と柔軟性のバランスを取ることの重要性も探ります。これらのトピックについて理解を深めるため、以下の資料も参考にしてほしいです。cloud.google.com speakerdeck.comlearning.oreilly.com speakerdeck.com2.2 DevOpsDevOpsの実践は、開発と運用の壁を取り払い、より効率的なシステム運用を実現します。ここでは、開発と運用の統合によるメリットと課題、CI/CDの最新プラクティスと導入のポイントについて議論したいです。「You build it, you run it」原則の実践方法や、自動化とツール化の成功事例も重要なトピックとなります。これらの議論を深めるため、以下の資料も参考にしてほしいです。learning.oreilly.comlearning.oreilly.comcloud.google.comweb.devopstopologies.comwww.ryuzee.com speakerdeck.com2.3 CCoE（Cloud Center of Excellence）CCoEは、組織全体のクラウド活用を最適化し、ガバナンスを確立する上で重要な役割を果たします。クラウドベストプラクティスの確立と普及方法、マルチクラウド環境でのガバナンス戦略、クラウドコスト最適化の具体的アプローチなどが主要な議論のポイントとなります。これらのトピックについて、以下の資料も参考にしてほしいです。aws.amazon.comtechblog.ap-com.co.jpDXを成功に導くクラウド活用推進ガイド CCoEベストプラクティス作者:黒須 義一,酒井 真弓,遠山 陽介,伊藤 利樹,饒村 吉晴日経BPAmazonca-srg.dev2.4 SRE（Site Reliability Engineering）[おまけ]SREは、システムの信頼性を維持しながら、イノベーションを促進するための重要な概念です。SLI（Service Level Indicator）とSLO（Service Level Objective）の効果的な設定と運用、エラーバジェットの活用による信頼性とイノベーションのバランス管理について議論したいです。また、トイル（反復的な手作業）の削減戦略とその効果、インシデント管理とポストモーテムの実践についても触れる予定です。これらのトピックについて、以下の資料も参考にしてほしいです。www.oreilly.co.jp speakerdeck.com speakerdeck.comsyu-m-5151.hatenablog.com各セッションでの私は、これらの資料を参考にしつつ、最新の事例や実践的なアプローチについて議論を展開したいです。参加者の皆様にとって、自組織での適用に役立つ具体的な知見を得られる機会となることを期待しています。3. 大規模システムの効率的運用の課題と対策についての議論大規模システムを少人数で効率的に運用するには、技術面だけでなく組織面での工夫も重要です。このセッションでは、実際の運用現場で直面する課題とその対策について、私の経験から得た洞察を共有します。これらのトピックについても登壇者や参加者の皆さまと当日お話ができれば嬉しいです。当日はおそらく具体性の高いテーマについてそれぞれ話すと思うのですが、ここでは私のスタンスを決めておくために抽象的な話をしたいと思います。具体と抽象作者:細谷 功dZERO（インプレス）Amazonまた、人の具体的な技術や現場の話を聞く時のコツは相手がどのような立場の人間でどういう悩みをもっているか想像したり知ることで理解が深まります。この点について、コミュニケーションの観点からさらに掘り下げると、以下のような考察ができます。相手の立場や悩みを想像することで理解が深まるのは、各個人が独自の知識体系や思考の枠組みを持ち、認知バイアスの影響を受けているため、効果的なコミュニケーションには相手の考えや感情を推測する能力と自己の思考を客観視する能力が重要だからです。これらの点を意識することで、大規模システムの運用に関する議論や情報共有がより実りあるものになると考えています。「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策作者:今井むつみ日経BPAmazon3.1 大規模システム運用の現実と組織的課題理想的な運用モデルと実際の運用現場のギャップについて考察したいです。理論と実践の乖離を埋めるための具体的なアプローチや、現場の声を活かした運用モデルの最適化事例を聞きたいです。また、少人数チームでの大規模システム運用における組織的な課題とその解決策を探りたいです。リソース制約下での効果的なタスク分配と優先順位付け、クロスファンクショナルスキルの育成による柔軟な人員配置などが重要なポイントとなります。チームトポロジー　価値あるソフトウェアをすばやく届ける適応型組織設計作者:マシュー・スケルトン,マニュエル・パイス日本能率協会マネジメントセンターAmazon3.2 効率的な運用を支える組織文化の構築HRT（Humility, Respect, Trust）原則を基盤とした少人数チームの強化方法について議論したいです。チーム内でのオープンなフィードバック文化の醸成や、相互理解と信頼関係を深めるためのチームビルディング活動の重要性を強調したいです。さらに、システム/サービスの価値を組織全体で共有するための効果的なコミュニケーション手法を探りたいです。定期的な全体会議やニュースレターを活用した情報共有、ビジュアライゼーションツールを用いたシステム価値の可視化などが具体的な方策となります。Team Geek ―Googleのギークたちはいかにしてチームを作るのか作者:Brian W. Fitzpatrick,Ben Collins-SussmanオライリージャパンAmazon3.3 段階的アプローチによる運用改善と組織変革スモールスタートの重要性と組織全体への展開方法を議論したいです。パイロットプロジェクトの選定と成功事例の横展開、段階的な改善プロセスの設計と各フェーズでの評価指標の設定などが重要です。また、少人数チームでの定点観測会の効果的な運営とステークホルダーマネジメントについて考察したいです。データ駆動型の定点観測会の実施方法と成果の可視化、ステークホルダーの期待値管理と効果的な報告体制の構築などが焦点となります。業務改革の教科書－－成功率9割のプロが教える全ノウハウ (日本経済新聞出版)作者:白川克,榊巻亮日経BPAmazon3.4 大規模システムの効率的な運用設計と組織的活用少人数チームの生産性を向上させる運用設計の実践事例を聞きたいです。標準化されたプロセスとツールの導入によるチーム効率の向上、自動化を活用した日常的なオペレーションの効率化、チーム間のナレッジ共有を促進する仕組みづくりなどが重要なポイントです。また、組織の成長に合わせた運用設計の進化と最適化について議論したいです。スケーラブルな運用モデルの設計と段階的な導入方法、変化する事業ニーズに柔軟に対応できる運用設計のアプローチ、継続的な改善サイクルを組み込んだ運用設計プロセスの確立などが焦点となります。「変化を嫌う人」を動かす: 魅力的な提案が受け入れられない4つの理由作者:ロレン・ノードグレン,デイヴィッド・ションタル草思社Amazon3.5 技術的改善の価値を組織全体で共有する方法「信頼性は会話です」という考え方を組織文化に組み込む実践例を聞きたいです。定期的な信頼性レビュー会議の実施と改善点の共有、チーム横断的な信頼性向上タスクフォースの設置などが具体的な方策となります。また、ITIL 4フレームワークを活用した組織横断的な価値創出事例を共有し、ITILのベストプラクティスを組織の特性に合わせてカスタマイズする方法やサービス価値システムの構築と継続的な最適化プロセスについて議論したいです。さらに、少人数チームの技術的改善を経営層に効果的に伝えるテクニックを探りたいです。ビジネス指標と技術指標を紐付けた改善効果の可視化、経営層向けダッシュボードの設計と定期的な報告会の実施などが重要なポイントとなります。【ITIL4公認】ITIL 4の基本 図解と実践作者:中 寛之日経BPAmazon3.6 継続的な改善を推進する組織体制の構築「始めるより続けることの方が難しい」という現実に対する組織的アプローチを議論したいです。長期的な改善ロードマップの設計と定期的な見直しプロセス、改善活動の成果を評価・表彰する仕組みの導入などが焦点となります。また、少人数チームでの理論、実践、モチベーションのバランスを保つ具体的な方法を探りたいです。学習と実践のサイクルを組み込んだ業務設計、チーム内でのスキルマトリクスの活用と成長機会の創出などが重要なポイントです。企業変革のジレンマ 「構造的無能化」はなぜ起きるのか作者:宇田川元一日経BPAmazon3.7 運用原則の組織への効果的な導入新しい運用原則の導入事例と組織全体への展開方法を聞きたいです。運用原則の核心的要素の段階的導入計画（例：SREの場合のエラーバジェット概念）、新しい運用文化の醸成とエンジニアリング組織全体への浸透策、様々な運用原則（SRE、DevOps、ITIL等）の基本概念を組織に適用する方法などが焦点となります。また、定量的指標を活用した組織的な意思決定プロセスについて議論し、サービスレベル目標（例：SLO）の設定プロセスとステークホルダーとの合意形成手法、リスクベースの優先順位付けと資源配分のための指標活用（例：エラーバジェット）などを探りたいです。さらに、インシデント管理と事後分析を組織の学習文化に組み込む方法を考察し、責任追及ではなく改善を重視する文化を醸成するための事後分析ガイドラインの策定、インシデントからの学びを組織知識として蓄積・活用するナレッジマネジメントシステムの構築などについて議論したいです。【改訂新版】システム障害対応の教科書作者:木村 誠明技術評論社Amazon大規模システムの効率的な運用は、技術と組織の両面からのアプローチが不可欠です。少人数チームでの運用という制約の中で、いかに組織の力を最大限に引き出し、システムの安定性と効率性を両立させるか。この課題に対する様々な視点と解決策について、参加者の皆様と活発な議論ができることを楽しみにしています。おわりにこのイベントが、大規模システムの効率的な運用に関する深い洞察と実践的な知見を共有される場となることを強く期待しています。Platform Engineering、DevOps、CCoE、SREの概念を適切に組み合わせ、各組織の特性に合わせてカスタマイズする方法について、参加者全員で活発な議論ができることを楽しみにしています。大規模システムの運用の正解は常に変化し続けるものです。このイベントでの学びを通じて、参加者それぞれが自社のシステム運用を見直し、改善していくきっかけになれば幸いです。登壇者の一人として、皆様と直接対話し、互いの経験や知見を共有できることを心から楽しみにしています。ぜひ多くの方にご参加いただき、一緒に大規模システムの効率的な運用について語り合いましょう！イベントの詳細や参加方法については、イベント公式ページをご確認ください。皆様のご参加を心よりお待ちしております。なお、このブログは私の思いつくままに書いたため、やや散文的になってしまいました。しかし、ここに記した考えや情報が、大規模システムの運用に関わる方々にとって何かしらの参考になれば幸いです。私自身、このイベントを通じてさらに学びを深め、より洗練された見解を得られることを楽しみにしています。www.youtube.com","isoDate":"2024-10-15T01:15:16.000Z","dateMiliSeconds":1728954916000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"FishでGoパッケージを一括更新したいのでワンライナー","link":"https://syu-m-5151.hatenablog.com/entry/2024/10/09/180510","contentSnippet":"はじめにGoプログラマーにとって、パッケージを最新の状態に保つことは重要な作業だ。しかし、複数のパッケージを個別に更新するのは時間がかかり、効率が悪い。そこで今回は、Fishシェルを使用してGoパッケージを一括更新する堅牢なワンライナーを紹介する。このワンライナーは、様々な環境設定に対応できる柔軟性を持ち、効率的にパッケージを更新できる強力なツールだ。ワンライナーの全容まずは、このワンライナーの全体像を見てみよう。set -l gobin (go env GOBIN); test -z \"$gobin\" \u0026\u0026 set gobin (go env GOPATH)/bin; for f in $gobin/*; if test -x $f; set pkg (go version -m $f | awk '/mod /{print $2}'); test -n \"$pkg\" \u0026\u0026 go install \"$pkg@latest\"; end; end一見複雑に見えるこのコマンドだが、実は論理的に構成された複数の処理の組み合わせである。以下、各部分の役割と動作原理を詳しく解説していく。ワンライナーの解剖dic.pixiv.net1. GOBINの設定と確認set -l gobin (go env GOBIN); test -z \"$gobin\" \u0026\u0026 set gobin (go env GOPATH)/bin;この部分は、Goバイナリのインストール先ディレクトリを特定する役割を果たす。set -l gobin (go env GOBIN)：GOBINの値を取得し、ローカル変数gobinに格納する。test -z \"$gobin\" \u0026\u0026 set gobin (go env GOPATH)/bin：gobinが空の場合（つまりGOBINが設定されていない場合）、GOPATH/binをデフォルトとして使用する。この処理により、GOBINの設定の有無に関わらず適切なディレクトリを使用できる柔軟性を確保している。2. ディレクトリ内のファイル処理for f in $gobin/*; ...; end$gobinディレクトリ内の全ファイルに対してループ処理を行う。これにより、インストールされている全てのGoバイナリを対象に処理を実行できる。3. 実行可能ファイルの選別if test -x $f; ...; endtest -x $fで、ファイル$fが実行可能かどうかをチェックする。これにより、実行可能なバイナリファイルのみを処理対象とし、不要なファイルを除外している。4. パッケージ情報の抽出set pkg (go version -m $f | awk '/mod /{print $2}')go version -m $fコマンドでバイナリファイルのモジュール情報を取得し、awkコマンドを使用してパッケージ名を抽出する。この結果をpkg変数に格納する。5. パッケージの更新test -n \"$pkg\" \u0026\u0026 go install \"$pkg@latest\"pkg変数が空でないことを確認し、有効なパッケージ名が得られた場合のみgo install \"$pkg@latest\"を実行して最新バージョンにアップデートする。このワンライナーの利点環境適応性: GOBINの設定の有無に関わらず動作する。安全性: 実行可能ファイルのみを処理し、有効なパッケージ名が得られた場合のみ更新を試みる。効率性: 一行で全ての処理を完結させ、高速に実行できる。汎用性: 様々なGo開発環境で使用できる。使用上の注意点このワンライナーは、Fishシェル専用である。Bash等の他のシェルでは動作しない。GOPATHが正しく設定されていることを前提としている。大量のパッケージがある場合、実行に時間がかかる可能性がある。まとめ本記事で紹介したワンライナーは、Goプログラマーの日常的なタスクを大幅に簡略化し、開発環境を最新に保つ強力なツールとなる。環境設定の違いに柔軟に対応し、安全かつ効率的にパッケージを更新できる点が大きな魅力だ。このワンライナーを自分の開発フローに組み込むことで、常に最新のGoパッケージを使用した、より効率的で安全な開発が可能になる。ぜひ試してみてほしい。Goプログラミングの世界は日々進化している。このワンライナーを活用し、最新の機能や改善を逃さず、より良いコードを書く手助けとしてほしい。他にいい方法があればおしえてください。","isoDate":"2024-10-09T09:05:10.000Z","dateMiliSeconds":1728464710000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"2024年版 運用者たちのLLM","link":"https://speakerdeck.com/nwiizo/2024nian-ban-yun-yong-zhe-tatinollm","contentSnippet":"Cloud Operator Days 2024 クロージングイベント\rhttps://cloudopsdays.com/closing/\r\rとても、端的に言うと「プロンプトエンジニアリングをしよう」って話。\rこの発表資料は、LLM（大規模言語モデル）によるIT運用の可能性と課題を探っています。AIOpsの概念を基に、LLMがインシデント対応、ドキュメンテーション、コード分析などの運用タスクをどのように改善できるかを説明しています。同時に、LLMの「幻覚」や不完全性といった課題も指摘し、適切な利用方法やプロンプトエンジニアリングの重要性を強調しています。\r\r登壇時ブログ\rhttps://syu-m-5151.hatenablog.com/entry/2024/09/06/154607","isoDate":"2024-09-06T04:00:00.000Z","dateMiliSeconds":1725595200000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Platform Engineering と SRE の門 ","link":"https://speakerdeck.com/nwiizo/platform-engineering-to-sre-nomen","contentSnippet":"Platform Engineering とSREの門 というタイトルで登壇しました。入門のタイポではありません。\r\rイベント名: Platform Engineering Kaigi 2024\rイベントURL:https://www.cnia.io/pek2024/\r\r登壇ブログ:『Platform Engineering とSREの門』という間違ったみたいなタイトルで登壇しました。 #PEK2024\rhttps://syu-m-5151.hatenablog.com/entry/2024/07/09/215147","isoDate":"2024-07-09T04:00:00.000Z","dateMiliSeconds":1720497600000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"運用者の各領域で向き合うLLM","link":"https://speakerdeck.com/nwiizo/yun-yong-zhe-noge-ling-yu-dexiang-kihe-ullm","contentSnippet":"運用者の各領域で向き合うLLM というタイトルで登壇しました。\r\rイベント名: Cloud Operator Days Tokyo 2024 \rイベントURL:https://cloudopsdays.com/","isoDate":"2024-06-28T04:00:00.000Z","dateMiliSeconds":1719547200000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"可観測性ガイダンス","link":"https://speakerdeck.com/nwiizo/ke-guan-ce-xing-kaitansu","contentSnippet":"可観測性ガイダンスというタイトルで登壇してきました。\r\rイベント名: オブザーバビリティ再入門 - 大切さと高め方を知ろう！\rイベントURL: https://mackerelio.connpass.com/event/316449/\r\r\r# ブログでいくつかの可観測性に関する書籍のまとめを投稿しました。\r5年後には標準になっている可観測性のこと - Learning Opentelemetry の読書感想文\rhttps://syu-m-5151.hatenablog.com/entry/2024/04/16/180511\r\rもう一度読むObservability Engineering\rhttps://syu-m-5151.hatenablog.com/entry/2024/05/06/090014\r\r盲目的に始めないためのオブザーバビリティ実践ガイド - Cloud Observability in Actionの読書感想文\rhttps://syu-m-5151.hatenablog.com/entry/2024/05/10/121047","isoDate":"2024-06-04T04:00:00.000Z","dateMiliSeconds":1717473600000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"書を捨てよ、現場へ出よう","link":"https://speakerdeck.com/nwiizo/shu-woshe-teyo-xian-chang-hechu-you","contentSnippet":"書を捨てよ、現場へ出よう このSRE本がすごい！2024年 LT版というタイトルで登壇してきました。\r\rSREたちの廊下〜あなたの現場での悩み、あの本にヒントがあるかも〜\rhttps://findy.connpass.com/event/311323/\r\r元ブログはこちら\r\rこのSRE本がすごい！2024年版\rhttps://syu-m-5151.hatenablog.com/entry/2024/01/26/165255\r\r登壇ブログはこちら\r\r『読書とは、能力、知識ではなく 問いを獲得するための行為』みたいな内容で登壇しました。\rhttps://syu-m-5151.hatenablog.com/entry/2024/03/13/164951","isoDate":"2024-03-12T04:00:00.000Z","dateMiliSeconds":1710216000000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"走馬灯のIaCは考えておいて","link":"https://speakerdeck.com/nwiizo/zou-ma-deng-noiachakao-eteoite","contentSnippet":"走馬灯のIaCは考えておいてというタイトルで登壇してきました\r\r技術的負債に向き合う Online Conference\rhttps://findy.connpass.com/event/297813/\r\r走馬灯のセトリは考えておいての短編はどれも面白いのでオススメです。\rhttps://www.hayakawa-online.co.jp/shopdetail/000000015282/\r\r登壇ブログ |『走馬灯のIaCは考えておいて』というタイトルで登壇しました。\rhttps://syu-m-5151.hatenablog.com/entry/2023/11/21/132144","isoDate":"2023-11-21T05:00:00.000Z","dateMiliSeconds":1700542800000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"SREとPlatform Engineerの交差点","link":"https://speakerdeck.com/nwiizo/sretoplatform-engineernojiao-chai-dian","contentSnippet":"Platform Engineering Meetup #5 #PFEM\rhttps://platformengineering.connpass.com/event/295048/ \r\rSREとPlatform Engineerの交差点: 2つの領域の交差と組織への適用 というタイトルで登壇します。\r\r登壇ブログ |『SREとPlatform Engineerの交差点:2つの領域の交差と組織への適用』というタイトルで登壇しました\rhttps://syu-m-5151.hatenablog.com/entry/2023/10/05/233555\r\rグレイラットの殺人 ワシントン・ポーが面白かったのでオススメです。\rhttps://www.hayakawa-online.co.jp/shopdetail/000000015569/","isoDate":"2023-10-05T04:00:00.000Z","dateMiliSeconds":1696478400000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"SREからPlatform Engineerへの拡大","link":"https://speakerdeck.com/nwiizo/srekaraplatform-engineerhenokuo-da","contentSnippet":"SREからPlatform Engineerへの拡大 というタイトルで登壇してきました\r\rCloud Operator Days Tokyo 2023 運用の新時代　〜Effortless Operation〜\rhttps://cloudopsdays.com/\r\rクラウドインフラ運用技術者のための年次イベント「Cloud Operator Days Tokyo 2023」の見所を紹介\rhttps://cloud.watch.impress.co.jp/docs/news/1518302.html\r\rSREからPlatform Engineerへの拡大 というタイトルで登壇しました - じゃあ、おうちで学べる  https://syu-m-5151.hatenablog.com/entry/2023/08/10/150412 \r\r登壇しかないので20分しかないのでｷﾞｭｯとしてしまいました。","isoDate":"2023-08-09T04:00:00.000Z","dateMiliSeconds":1691553600000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"k8sgpt Deep Dive: KubernetesクラスタのAI駆動型分析について","link":"https://speakerdeck.com/nwiizo/k8sgpt-deep-dive-kuberneteskurasutanoaiqu-dong-xing-fen-xi-nituite","contentSnippet":"k8sgpt Deep Dive: KubernetesクラスタのAI駆動型分析についてというタイトルで登壇しました\r\r2023年8月3日 CloudNative Days Fukuoka 2023\rhttps://event.cloudnativedays.jp/cndf2023\r\rk8sgpt Deep Dive: KubernetesクラスタのAI駆動型分析について\rhttps://event.cloudnativedays.jp/cndf2023/talks/1885\r\rK8sGPT Deep Dive というタイトルで登壇しました #CNDF - じゃあ、おうちで学べる  \rhttps://syu-m-5151.hatenablog.com/entry/2023/08/03/155326","isoDate":"2023-08-03T04:00:00.000Z","dateMiliSeconds":1691035200000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Cloud Native の作法","link":"https://speakerdeck.com/nwiizo/cloud-native-nozuo-fa","contentSnippet":"2023年7月13日 \r\r成熟度モデルを活用したCloud Nativeへの道筋 という副題で登壇します #開発生産性con_findy\rhttps://syu-m-5151.hatenablog.com/entry/2023/07/13/131433\r\r\r開発生産性Conference の登壇資料\rhttps://findy.connpass.com/event/283417/","isoDate":"2023-07-13T04:00:00.000Z","dateMiliSeconds":1689220800000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"2023年もSRE再考と叫びなさい‼️","link":"https://speakerdeck.com/nwiizo/2023nian-mosrezai-kao-tojiao-binasai","contentSnippet":"2023年もSRE再考と叫びなさい‼️ SREの跡を求めず SREの求めたるところを求めよ というタイトルで登壇してきました\r\r2023年3月3日 エンジニア文化祭 2023\rhttps://forkwell.connpass.com/event/272596/\r\r『2023年もSRE再考と叫びなさい!!』というタイトルで登壇しました - じゃあ、おうちで学べる\rhttps://syu-m-5151.hatenablog.com/entry/2023/03/03/105049","isoDate":"2023-03-03T05:00:00.000Z","dateMiliSeconds":1677819600000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"自由研究には向かないウェブオペレーション ","link":"https://speakerdeck.com/nwiizo/zi-you-yan-jiu-nihaxiang-kanaiuebuoperesiyon","contentSnippet":"自由研究には向かないウェブオペレーション サイト運用管理を取り巻く環境の変化 Cloud Native時代に考えるLinux オペレーション というタイトルで登壇してきました。\r\r2023年2月18日\r【今更聞けない】Linuxのしくみ - Forkwell Library #16\rhttps://forkwell.connpass.com/event/273179/\r\rあとがき\r『自由研究には向かないウェブオペレーション』というタイトルで登壇しました。\rhttps://syu-m-5151.hatenablog.com/entry/2023/02/18/201252","isoDate":"2023-02-18T05:00:00.000Z","dateMiliSeconds":1676696400000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":" ポストモーテムはじめました","link":"https://speakerdeck.com/nwiizo/posutomotemuhazimemasita","contentSnippet":"ポストモーテムはじめました - 良いポストモーテムを執筆するために必要な5つのポイント というタイトルで登壇してきました。\r\r2023年02月09日\rインシデントにどう対応してきたか？みんなで学ぶポストモーテム Lunch LT\rhttps://findy.connpass.com/event/273197/\r\r『ポストモーテムはじめました』というタイトルで登壇しました。 - じゃあ、おうちで学べる  \rhttps://syu-m-5151.hatenablog.com/entry/2023/02/09/113316","isoDate":"2023-02-09T05:00:00.000Z","dateMiliSeconds":1675918800000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"セキュア・バイ・デザインの鳴くところ","link":"https://speakerdeck.com/nwiizo/sekiyuabaidezainnoming-kutokoro","contentSnippet":"セキュア・バイ・デザインの鳴くところ\r安全なソフトウェアを全体から考えるみるで候\r\rOWASP Fukuoka Meeting #9\rhttps://owasp-kyushu.connpass.com/event/266585/\r\r副読ブログ\rhttps://syu-m-5151.hatenablog.com/entry/2022/12/07/204400","isoDate":"2022-12-07T05:00:00.000Z","dateMiliSeconds":1670389200000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"cobra は便利になっている","link":"https://speakerdeck.com/nwiizo/cobra-habian-li-ninatuteiru","contentSnippet":"2022年3-shake SRE Tech Talk #4\rhttps://3-shake.connpass.com/event/253028/","isoDate":"2022-08-04T04:00:00.000Z","dateMiliSeconds":1659585600000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Observability Conference 2022 に登壇しました","link":"https://zenn.dev/nwiizo/articles/d837b78914de23","contentSnippet":"「Dapr の概念と実装から学ぶ Observability への招待」 というタイトルで登壇します。https://event.cloudnativedays.jp/o11y2022/talks/1382:embed:cite セッション概要Dapr は CloudNative な技術を背景に持つ分散アプリケーションランタイムです。本セッションでは Dapr の Observability に関する各種機能と、その実装について解説していきます。さらにスリーシェイクの Dapr と Observability への取り組みに関してもご紹介します。Dapr の機能でカバーできる点...","isoDate":"2022-03-11T04:02:18.000Z","dateMiliSeconds":1646971338000,"authorName":"nwiizo","authorId":"nwiizo"}]},"__N_SSG":true},"page":"/members/[id]","query":{"id":"nwiizo"},"buildId":"pWqQdT762jR6uLoQbggIh","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>