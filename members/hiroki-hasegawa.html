<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon shortcut" type="image/png" href="https://blog.3-shake.com//logo.png"/><link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;500;700&amp;family=Roboto:wght@300;400;500;700&amp;display=swap" rel="stylesheet"/><title>Hiroki Hasegawa | 3-shake Engineers&#x27; Blogs</title><meta property="og:title" content="Hiroki Hasegawa"/><meta property="og:url" content="https://blog.3-shake.com//members/hiroki-hasegawa"/><meta name="twitter:card" content="summary_large_image"/><meta property="og:site" content="3-shake Engineers&#x27; Blogs"/><meta property="og:image" content="https://blog.3-shake.com//og.png"/><link rel="canonical" href="https://blog.3-shake.com//members/hiroki-hasegawa"/><link rel="preload" href="/_next/static/css/dee6e29324b1364f347a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/dee6e29324b1364f347a.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-8a83f0fd99327c4684a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.1daf1ec1ecf144ee9147.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.9e003f150a446b53bdd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-1a98368b242d5422e7a2.js" as="script"/><link rel="preload" href="/_next/static/chunks/81b50c7ab23905e464b4340eb234bd6ea389d26b.c03eca8dad16a5aaea85.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/members/%5Bid%5D-c86b263a3b72cf772df9.js" as="script"/></head><body><div id="__next"><header class="site-header"><div class="content-wrapper"><div class="site-header__inner"><a class="site-header__logo-link" href="/"><img src="/logo.svg" alt="3-shake Engineers&#x27; Blogs" class="site-header__logo-img"/><span class="site-header__logo-text">3-shake<br/>Engineers&#x27; Blogs</span></a><div class="site-header__links"><a class="site-header__link" href="/feed.xml">RSS</a><a href="https://3-shake.com/category/recruit/" class="site-header__link">Recruit</a><a href="https://3-shake.com/" class="site-header__link">Company</a></div></div></div></header><section class="member"><div class="content-wrapper"><header class="member-header"><div class="member-header__avatar"><img src="/avatars/hirokihasegawa.png" alt="Hiroki Hasegawa" width="100" height="100" class="member-header__avatar-img"/></div><h1 class="member-header__name">Hiroki Hasegawa</h1><p class="member-header__bio">Let me know your favorite technology!</p><div class="member-header__links"><a href="https://twitter.com/Hiroki__IT" class="member-header__link"><img src="/icons/twitter.svg" alt="Twitterのユーザー@Hiroki__IT" width="22" height="22"/></a><a href="https://github.com/hiroki-it" class="member-header__link"><img src="/icons/github.svg" alt="GitHubのユーザー@hiroki-it" width="22" height="22"/></a><a href="https://hiroki-it.github.io/tech-notebook-mkdocs/" class="member-header__link"><img src="/icons/link.svg" alt="ウェブサイトのリンク" width="22" height="22"/></a></div></header><div class="member-posts-container"><div class="post-list"><article class="post-link"><a class="post-link__author" href="/members/hiroki-hasegawa"><img src="/avatars/hirokihasegawa.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">Hiroki Hasegawa</div><time dateTime="2023-01-14T13:38:15.000Z" class="post-link__date">a month ago</time></div></a><a href="https://hiroki-hasegawa.hatenablog.jp/entry/2023/01/14/223815" class="post-link__main-link"><h2 class="post-link__title">【Istio⛵️】サイドカーインジェクションの仕組み</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=hiroki-hasegawa.hatenablog.jp" width="14" height="14" class="post-link__site-favicon"/>hiroki-hasegawa.hatenablog.jp</div></a></article><article class="post-link"><a class="post-link__author" href="/members/hiroki-hasegawa"><img src="/avatars/hirokihasegawa.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">Hiroki Hasegawa</div><time dateTime="2022-12-24T21:00:00.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://hiroki-hasegawa.hatenablog.jp/entry/2022/12/25/060000" class="post-link__main-link"><h2 class="post-link__title">【Istio⛵️】サービスディスカバリーの仕組み</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=hiroki-hasegawa.hatenablog.jp" width="14" height="14" class="post-link__site-favicon"/>hiroki-hasegawa.hatenablog.jp</div></a></article></div></div></div></section><footer class="site-footer"><div class="content-wrapper"><p>© <!-- -->3-shake Inc.</p></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"member":{"id":"hiroki-hasegawa","name":"Hiroki Hasegawa","role":"SRE","bio":"Let me know your favorite technology!","avatarSrc":"/avatars/hirokihasegawa.png","sources":["https://hiroki-hasegawa.hatenablog.jp/feed"],"includeUrlRegex":"","twitterUsername":"Hiroki__IT","githubUsername":"hiroki-it","websiteUrl":"https://hiroki-it.github.io/tech-notebook-mkdocs/"},"postItems":[{"title":"【Istio⛵️】サイドカーインジェクションの仕組み","contentSnippet":"01. はじめに02. サイドカーによるサービスメッシュなぜサイドカーが必要なのかサイドカープロキシメッシュ03. admission-controllersアドオンについてadmission-controllersアドオンとはadmissionプラグインの種類MutatingAdmissionWebhookプラグインMutatingAdmissionWebhookプラグインとはAdmissionReview、AdmissionRequest、AdmissionResponse▼ AdmissionReview▼ AdmissionRequest▼ AdmissionResponse04. サイドカーインジェクションの仕組み全体のフロークライアント ➡︎ kube-apiserverここで説明するフロー箇所【１】 Podの作成をリクエストkube-apiserver ➡︎ Serviceここで説明するフロー箇所【２】 認証認可処理をコール【３】 アドオンの処理をコール【４】 AdmissionRequestに値を詰める【５】 AdmissionReviewを送信Service ➡︎ webhookサーバーここで説明するフロー箇所【６】 15017番ポートにポートフォワーディングkube-apiserver ⬅︎ Service ⬅︎ webhookサーバーここで説明するフロー箇所【７】 patch処理を定義【８】 AdmissionResponseに値を詰める【９】 AdmissionReviewを返信kube-apiserver ➡︎ etcdここで説明するフロー箇所【１０】 patch処理をコール【１１】 マニフェストを永続化クライアント ⬅︎ kube-apiserverここで説明するフロー箇所【１２】 コール完了を返信以降の仕組み05. おわりに01. はじめにどーも。正月で激太りしましたが、ダイエットの予定はありません🙋🏻‍♂️今回は、サービスメッシュを実装するIstioのサイドカーインジェクションに関する記事を投稿しました🚀前回の記事に引き続きIstioです。執筆時点 (2023/01/14) では、Istioが実装するサービメッシュには、『サイドカープロキシメッシュ』と『アンビエントメッシュ』があります。サイドカープロキシメッシュの仕組みの軸になっているものは、サイドカーコンテナであるistio-proxyコンテナです。Istioは、KubernetesのPodの作成時に、istio-proxyコンテナをPod内に自動的にインジェクション (注入) します本記事では、このサイドカーのインジェクションの仕組みをもりもり布教しようと思います😗 (沼のまわりに餌をまく)02. サイドカーによるサービスメッシュなぜサイドカーが必要なのかそもそも、なぜサービスメッシュでサイドカーが必要になったのでしょうか🤔マイクロサービスアーキテクチャのシステムには、アーキテクチャ固有のインフラ領域の問題 (例：サービスディスカバリーの必要性、マイクロサービス間通信の暗号化、テレメトリー収集、など) があります。アプリエンジニアが各マイクロサービス内にインフラ領域の問題に関するロジックを実装すれば、これらの問題の解決できます。しかし、アプリエンジニアはアプリ領域の問題に責務を持ち、インフラ領域の問題はインフラエンジニアで解決するようにした方が、互いに効率的に開発できます。そこで、インフラ領域の問題を解決するロジックをサイドカーとして切り分けます。これにより、アプリエンジニアとインフラエンジニアの責務を分離できるようになります。また、インフラ領域の共通ロジックをサイドカーとして各マイクロサービスに提供できるため、単純性が高まります。こういった流れの中で、サイドカーを使用したサービスメッシュが登場しました。↪️ 参考：サービスメッシュ、Istioがマイクロサービスのトラフィック制御、セキュリティ、可観測性に欠かせない理由：Cloud Nativeチートシート（9） - ＠ITWhat is Service Mesh and Why is it Necessary?サイドカープロキシメッシュIstioのサイドカーによるサービスメッシュ (サイドカープロキシメッシュ) は、サイドカーコンテナ (istio-proxyコンテナ) が稼働するデータプレーンサイドカーを中央集権的に管理するIstiod (discoveryコンテナ) が稼働するコントロールプレーンからなります。↪️ 参考：Istio / Architecture03. admission-controllersアドオンについてadmission-controllersアドオンとはIstioのPod内へのサイドカーインジェクションの前提知識として、admission-controllersアドオンを理解する必要があります。もし、admission-controllersアドオンをご存知の方は、 04. サイドカーインジェクションの仕組み まで飛ばしてください🙇🏻‍♂️kube-apiserverでは、admission-controllersアドオンとして有効化できます。有効化すると、認証ステップと認可ステップの後にmutating-admissionステップとvalidating-admissionステップを実行でき、admissionプラグインの種類に応じた処理を挿入できます。クライアント (kubectlクライアント、Kubernetesリソース) からのリクエスト (例：Kubernetesリソースに対する作成/更新/削除、kube-apiserverからのプロキシへの転送) 時に、各ステップでadmissionプラグインによる処理 (例：アドオンビルトイン処理、独自処理) を発火させられます。↪️ 参考：Admission Controllers Reference | KubernetesKubernetes Best Practices: Blueprints for Building Successful Applications on Kubernetes: Burns, Brendan, Villalba, Eddie, Strebel, Dave, Evenson, Lachlan: 9781492056478: Amazon.com: Booksadmissionプラグインの種類admission-controllersアドオンのadmissionプラグインには、たくさんの種類があります。IstioがPod内にサイドカーをインジェクションする時に使用しているアドオンは、『MutatingAdmissionWebhook』です。CertificateApprovalCertificateSigningCertificateSubjectRestrictionDefaultIngressClassDefaultStorageClassDefaultTolerationSecondsLimitRangerMutatingAdmissionWebhook 👈 これ！NamespaceLifecyclePersistentVolumeClaimResizePodSecurityPriorityResourceQuotaRuntimeClassServiceAccountStorageObjectInUseProtectionTaintNodesByConditionValidatingAdmissionWebhook↪️ 参考：Admission Controllers Reference | KubernetesMutatingAdmissionWebhookプラグインMutatingAdmissionWebhookプラグインとはMutatingAdmissionWebhookプラグインを使用すると、mutating-admissionステップ時に、リクエスト内容を変更する処理をフックできます。フックする具体的な処理として、webhookサーバーにAdmissionRequestリクエストとして送信することにより、レスポンスのAdmissionResponseに応じてリクエスト内容を動的に変更します。MutatingWebhookConfigurationで、MutatingAdmissionWebhookプラグインの発火条件やwebhookサーバーの宛先情報を設定します。MutatingWebhookConfigurationの具体的な実装については、サイドカーインジェクションの仕組みの中で説明していきます。↪️ 参考：Diving into Kubernetes MutatingAdmissionWebhook | by Morven Cao | IBM Cloud | MediumKubernetes Admission Webhook覚書き - gashirar's blogAdmission Webhookを作って遊んで、その仕組みを理解しよう（説明編）AdmissionReview、AdmissionRequest、AdmissionResponse▼ AdmissionReviewAdmissionReviewは以下のようなJSONであり、kube-apiserverとwebhookサーバーの間でAdmissionRequestとAdmissionResponseを運びます。{  \"apiVersion\": \"admission.k8s.io/v1\",  \"kind\": \"AdmissionReview\",  # AdmissionRequest  \"request\": {},  # AdmissionResponse  \"response\": {},}↪️ 参考：v1 package - k8s.io/api/admission/v1 - Go Packages▼ AdmissionRequestAdmissionRequestは以下のようなJSONです。kube-apiserverがクライアントから受信した操作内容が持つことがわかります。例で挙げたAdmissionRequestでは、クライアントがDeploymentをCREATE操作するリクエストをkube-apiserverに送信したことがわかります。{  \"apiVersion\": \"admission.k8s.io/v1\",  \"kind\": \"AdmissionReview\",  # AdmissionRequest  \"request\": {    ...    # 変更されるKubernetesリソースの種類を表す。    \"resource\": {      \"group\": \"apps\",      \"version\": \"v1\",      \"resource\": \"deployments\"    },    # kube-apiserverの操作の種類を表す。    \"operation\": \"CREATE\",    ...  }}↪️ 参考：Dynamic Admission Control | Kubernetes▼ AdmissionResponse一方でAdmissionResponseは、例えば以下のようなJSONです。AdmissionResponseに応じたマニフェスト変更処理をpatchキーの値に持ち、これはbase64方式でエンコードされています。{  \"apiVersion\": \"admission.k8s.io/v1\",  \"kind\": \"AdmissionReview\",  # AdmissionResponse  \"response\": {      \"uid\": \"\u003cvalue from request.uid\u003e\",      # 宛先のwebhookサーバーが受信したか否かを表す。      \"allowed\": true,      # PathによるPatch処理を行う。      \"patchType\": \"JSONPatch\",      # Patch処理の対象となるKubernetesリソースと処理内容を表す。base64方式でエンコードされている。      \"patch\": \"W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=\",    },}エンコード値をデコードしてみると、例えば以下のようなpatch処理が定義されています。# patchキーをbase64方式でデコードした場合[{\"op\": \"add\", \"path\": \"/spec/replicas\", \"value\": 3}]マニフェストに対する操作 (op) 、キー (path) 、値 (value) が設定されています。kube-apiserverがこれを受信すると、指定されたキー (.spec.replicas) に値 (3) に追加します。↪️ 参考：Dynamic Admission Control | Kubernetes04. サイドカーインジェクションの仕組み全体のフロー前提知識を踏まえた上で、admission-controllersアドオンの仕組みの中で、サイドカーのistio-proxyコンテナがどのようにPodにインジェクションされるのかを見ていきましょう。最初に、サイドカーインジェクションのフローは以下の通りになっています。画像の文字が小さくなってしまったため、拡大していただけると🙇🏻‍♂️↪️ 参考：Amazon.co.jp: Istio in Action (English Edition) 電子書籍: Posta, Christian E., Maloku, Rinor: 洋書クライアント ➡︎ kube-apiserverここで説明するフロー箇所『クライアント ➡︎ kube-apiserver』の箇所を説明します。【１】 Podの作成をリクエストまずは、クライアントがkube-apiserverにリクエストを送信するところです。クライアント (Deployment、DaemonSet、StatefulSet、を含む) は、Podの作成リクエストをkube-apiserverに送信します。この時のリクエスト内容は、以下の通りとします。# Podを作成する。$ kubectl apply -f foo-pod.yaml# foo-pod.yamlファイルapiVersion: v1kind: Podmetadata:  name: foo-pod  namespace: foo-namespacespec:  containers:    - name: foo      image: foo:1.0.0      ports:        - containerPort: 80またNamespaceでは、あらかじめistio-proxyコンテナのインジェクションが有効化されているとします。Istioではv1.10以降、リビジョンの番号のエイリアスを使用して、istio-proxyコンテナのインジェクションを有効化するようになりました。エイリアスはどんな値でも問題なく、よくあるエイリアスとしてdefaultやstableなどを使用します。apiVersion: v1kind: Namespacemetadata:  name: foo-namespace  labels:    # istio-proxyコンテナのインジェクションを有効化する。    # エイリアスは自由    istio.io/rev: \u003cエイリアス\u003e↪️ 参考：Istio / Announcing Support for 1.8 to 1.10 Direct Upgradeskube-apiserver ➡︎ Serviceここで説明するフロー箇所『kube-apiserver ➡︎ Service』の箇所を説明します。【２】 認証認可処理をコールkube-apiserverは、認証ステップと認可ステップにて、クライアントからのリクエストを許可します。【３】 アドオンの処理をコールkube-apiserverは、mutating-admissionステップにて、MutatingAdmissionWebhookプラグインの処理をコールします。前提知識の部分で具体的な実装を省略しましたが、Istioのバージョン1.14.3時点で、MutatingWebhookConfigurationは以下のようになっています。Namespaceでサイドカーインジェクションを有効化する時に使用したエイリアスは、このMutatingWebhookConfigurationで実体のリビジョン番号と紐づいています。$ kubectl get mutatingwebhookconfiguration istio-revision-tag-default -o yamlapiVersion: admissionregistration.k8s.io/v1beta1kind: MutatingWebhookConfigurationmetadata:  name: istio-revision-tag-default  labels:    app: sidecar-injector    # エイリアスの実体    istio.io/rev: \u003cリビジョン番号\u003e    # リビジョン番号のエイリアス    istio.io/tag: \u003cエイリアス\u003ewebhooks:  - name: rev.namespace.sidecar-injector.istio.io    # MutatingAdmissionWebhookプラグインの処理の発火条件を登録する。    rules:      - apiGroups: [\"\"]        apiVersions: [\"v1\"]        operations: [\"CREATE\"]        resources: [\"pods\"]        scope: \"*\"    # Webhookの前段にあるServiceの情報を登録する。    clientConfig:      service:        name: istiod-\u003cリビジョン番号\u003e        namespace: istio-system        path: \"/inject\" # エンドポイント        port: 443      caBundle: Ci0tLS0tQk ...    # Namespace単位のサイドカーインジェクション    # 特定のNamespaceでMutatingAdmissionWebhookプラグインの処理を発火させる。    namespaceSelector:      matchExpressions:        - key: istio.io/rev          operator: DoesNotExist        - key: istio-injection          operator: DoesNotExist    # Pod単位のサイドカーインジェクション    # 特定のオブジェクトでMutatingAdmissionWebhookプラグインの処理を発火させる。    objectSelector:      matchExpressions:        - key: sidecar.istio.io/inject          operator: NotIn          values:            - \"false\"        - key: istio.io/rev          operator: In          values:            - \u003cエイリアス\u003e    ...MutatingWebhookConfigurationには、MutatingAdmissionWebhookプラグインの発火条件やwebhookサーバーの宛先情報を定義します。MutatingAdmissionWebhookプラグインの発火条件に関して、例えばIstioでは、 NamespaceやPod.metadata.labelsキーに応じてサイドカーインジェクションの有効化/無効化を切り替えることができ、これをMutatingAdmissionWebhookプラグインで制御しています。webhookサーバーの宛先情報に関して、Istioではwebhookサーバーの前段にServiceを配置しています。MutatingAdmissionWebhookプラグインが発火した場合、Serviceの/inject:443にHTTPSプロトコルのリクエストを送信するようになっています。また、送信先のServiceの名前がistiod-\u003cリビジョン番号\u003eとなっていることからもわかるように、Serviceは特定のバージョンのIstiodコントロールプレーンに対応しており、想定外のバージョンのIstiodコントロールプレーンを指定しないように制御しています。一方で発火しなかった場合には、以降のAdmissionReviewの処理には進みません。【４】 AdmissionRequestに値を詰めるkube-apiserverは、mutating-admissionステップにて、クライアントからのリクエスト内容 (Podの作成リクエスト) をAdmissionReveiew構造体のAdmissionRequestに詰めます。{  \"apiVersion\": \"admission.k8s.io/v1\",  \"kind\": \"AdmissionReview\",  # AdmissionRequest  \"request\": {    ...    # 変更されるKubernetesリソースの種類を表す。    \"resource\": {      \"group\": \"core\",      \"version\": \"v1\",      \"resource\": \"pods\"    },    # kube-apiserverの操作の種類を表す。    \"operation\": \"CREATE\",    ...  }}【５】 AdmissionReviewを送信kube-apiserverは、mutating-admissionステップにて、Serviceの/inject:443にAdmissionReview構造体を送信します。Service ➡︎ webhookサーバーここで説明するフロー箇所『Service ➡︎ webhookサーバー』の箇所を説明します。【６】 15017番ポートにポートフォワーディングServiceは、/inject:443でリクエストを受信し、discoveryコンテナの15017番ポートにポートフォワーディングします。Istioのバージョン1.14.3時点で、Serviceは以下のようになっています。$ kubectl get svc istiod-service -n istio-system -o yamlapiVersion: v1kind: Servicemetadata:  namespace: istio-system  name: istiod-\u003cリビジョン番号\u003e  labels:    app: istiodspec:  type: ClusterIP  selector:    app: istiod    istio.io/rev: \u003cリビジョン番号\u003e  ports:    - name: grpc-xds      port: 15010      protocol: TCP      targetPort: 15010    - name: https-dns      port: 15012      protocol: TCP      targetPort: 15012    # webhookサーバーにポートフォワーディングする。    - name: https-webhook      port: 443      protocol: TCP      targetPort: 15017    - name: http-monitoring      port: 15014      protocol: TCP      targetPort: 15014.spec.selector.istio.io/revキーに、ポートフォワーディング先のPodを指定するためのリビジョン番号が設定されており、このPodはdiscoveryコンテナを持ちます。Istioは、discoveryコンテナ内でwebhookサーバーを実行し、15017番ポートでリクエストを待ち受けます。ここで、discoveryコンテナがリクエストを待ち受けているポート番号を見てみると、15017番ポートでリッスンしていることを確認できます。$ kubectl exec foo-istiod -n istio-system -- netstat -tulpnActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program nametcp        0      0 127.0.0.1:9876          0.0.0.0:*               LISTEN      1/pilot-discoverytcp6       0      0 :::15017                :::*                    LISTEN      1/pilot-discoverytcp6       0      0 :::8080                 :::*                    LISTEN      1/pilot-discoverytcp6       0      0 :::15010                :::*                    LISTEN      1/pilot-discoverytcp6       0      0 :::15012                :::*                    LISTEN      1/pilot-discoverytcp6       0      0 :::15014                :::*                    LISTEN      1/pilot-discovery↪️ 参考：istio/webhook.go at 1.14.3 · istio/istio · GitHubIstio / Application Requirementskube-apiserver ⬅︎ Service ⬅︎ webhookサーバーここで説明するフロー箇所『kube-apiserver ⬅︎ Service ⬅︎ webhookサーバー』の箇所を説明します。【７】 patch処理を定義仕組みの中でも、ここは重要な部分です。discoveryコンテナ内のwebhookサーバーは、リクエスト内容を書き換えるためのpatch処理を定義します。webhookサーバーは、マニフェストの.spec.containers[1]パスにistio-proxyキーを追加させるようなpatch処理を定義します。この定義によって、結果的にサイドカーのインジェクションが起こるということになります。[  ...  {    \"op\": \"add\",    # .spec.initContainers[1] を指定する。    \"path\": \"/spec/initContainers/1\",    # マニフェストファイルに追加される構造を表す。    \"value\": {      \"name\": \"istio-init\",      \"resources\": {                     ...      }    }  },  {    \"op\": \"add\",    # .spec.containers[1] を指定する。    \"path\": \"/spec/containers/1\",    # マニフェストファイルに追加される構造を表す。    \"value\": {      \"name\": \"istio-proxy\",      \"resources\": {                     ...      }    }  }  ...]↪️ 参考：istio/webhook.go at a19b2ac8af3ad937640f6e29eed74472034de2f5 · istio/istio · GitHubistio/webhook_test.go at 1.14.3 · istio/istio · GitHub本題と話が逸れるため今回は詳しく言及しませんが、上記のpathc処理ではサイドカーコンテナのistio-proxyコンテナの他に、initコンテナのistio-initコンテナもインジェクションできるようにします。このistio-initコンテナは、istio-proxyコンテナを持つPodでインバウンド/アウトバウンド通信の経路を制御できるように、Pod内にiptablesのルールを適用する責務を担っています💪🏻↪️ 参考：Istio Sidecar's interception mechanism for traffic - SoByte【８】 AdmissionResponseに値を詰めるdiscoveryコンテナ内のwebhookサーバーは、patch処理の定義をAdmissionReveiew構造体のAdmissionResponseに詰めます。patchキーの値に、先ほどのpatch処理の定義をbase64方式でエンコードした文字列が割り当てられています。{  \"apiVersion\": \"admission.k8s.io/v1\",  \"kind\": \"AdmissionReview\",  # AdmissionResponse  \"response\": {      \"uid\": \"*****\",      \"allowed\": true,      \"patchType\": \"JSONPatch\",      # Patch処理の対象となるKubernetesリソースと処理内容を表す。base64方式でエンコードされている。      \"patch\": \"\u003c先ほどのpatch処理の定義をbase64方式でエンコードした文字列\u003e\",    },}↪️ 参考：istio/webhook.go at 1.14.3 · istio/istio · GitHub【９】 AdmissionReviewを返信discoveryコンテナ内のwebhookサーバーは、AdmissionReview構造体をレスポンスとしてkube-apiserverに返信します。kube-apiserver ➡︎ etcdここで説明するフロー箇所『kube-apiserver ➡︎ etcd』の箇所を説明します。【１０】 patch処理をコールkube-apiserverは、AdmissionReview構造体を受信し、AdmissionResponseに応じてリクエスト内容を書き換えます。patch処理の定義をAdmissionReview構造体から取り出し、クライアントからのリクエスト内容を書き換えます。具体的には、istio-proxyコンテナとistio-initコンテナを作成できるように、リクエストしたマニフェストの該当箇所にキーを追加します。apiVersion: v1kind: Podmetadata:  name: foo-pod  namespace: foo-namespacespec:  containers:    - name: foo      image: foo:1.0.0      ports:        - containerPort: 80    # kube-apiserverが追加    - name: istio-proxy      ...  # kube-apiserverが追加  initContainers:    - name: istio-init    ...【１１】 マニフェストを永続化kube-apiserverは、etcdにPodのマニフェストを永続化します。クライアント ⬅︎ kube-apiserverここで説明するフロー箇所『クライアント ⬅︎ kube-apiserver』の箇所を説明します。【１２】 コール完了を返信kube-apiserverは、クライアントにレスポンスを受信します。$ kubectl apply -f foo-pod.yaml# kube-apiserverからレスポンスが返ってくるpod \"foo-pod\" created以降の仕組みkube-apiserverは、他のNodeコンポーネント (kube-controlleretcd、kube-scheduler、kubelet、など) と通信し、Podを作成します。このPodのマニフェストは、アプリコンテナの他に、istio-proxyコンテナとistio-initコンテナを持ちます。結果として、サイドカーコンテナのistio-proxyコンテナをインジェクションしたことになります。本題と話が逸れるため今回は詳しく言及しませんが、kube-apiserverと他コンポーネントの通信については、以下の方の記事と図が非常に参考になると思います🙇🏻‍♂️↪️ 参考：Kubernetes Master Components: Etcd, API Server, Controller Manager, and Scheduler | by Jorge Acetozi | jorgeacetozi | Medium05. おわりにIstioのサイドカーインジェクションの仕組みをもりもり布教しました。Istioへの愛が溢れてしまいました。今回登場したMutatingAdmissionWebhookプラグインに関して、私の関わっているプロダクトではIstio以外 (例：CertManager、Prometheus、AWSのaws-eks-vpc-cniアドオン、など) でも使用しています。そのため、MutatingAdmissionWebhookプラグインをどのように使っているのかを一度知れば、知識の汎用性が高いと考えています✌🏻サイドカーインジェクションはIstioでも基本的な機能であり、もし未体験の方がいらっしゃれば、お手元でサイドカーコンテナが追加されることを確認していただくとよいかもしれません👍","link":"https://hiroki-hasegawa.hatenablog.jp/entry/2023/01/14/223815","isoDate":"2023-01-14T13:38:15.000Z","dateMiliSeconds":1673703495000,"authorName":"Hiroki Hasegawa","authorId":"hiroki-hasegawa"},{"title":"【Istio⛵️】サービスディスカバリーの仕組み","contentSnippet":"01. はじめに02. サービスディスカバリーについてマイクロサービスアーキテクチャにおけるサービスディスカバリーサービスディスカバリーとはなぜサービスディスカバリーが必要なのかサービスディスカバリーの要素サービスディスカバリーのパターンサービスディスカバリーのパターンとはサーバーサイドパターンクライアントサイドパターン03. IstioのサービスディスカバリーIstioのサービスディスカバリーの仕組み全体像【１】【２】【３】【４】【５】discoveryコンテナの仕組みistio-proxyコンテナの仕組み04. istio-proxyコンテナ内のEnvoyの仕組みEnvoyの処理の流れ全体像【１】【２】【３】【４】【５】【６】EnvoyがADS-APIから取得した宛先情報を見てみようconfig_dumpエンドポイントリスナー値▼ 確認方法▼ 結果ルート値▼ 確認方法▼ 結果クラスター値▼ 確認方法▼ 結果エンドポイント値▼ 確認方法▼ 結果Envoyの処理の流れのまとめ【１】【２】【３】【４】【５】【６】05. おわりに謝辞01. はじめに3-shake Advent Calender 2022 最終日の記事です🎅🎄私は普段は 俺の技術ノート に知見を記録しており、はてなブログはデビュー戦となります。さて今回は、サービスメッシュを実装するIstioのサービスディスカバリーに関する記事を投稿しました🚀Istioの機能の一つである『サービスディスカバリー』の仕組みを、Envoyを交えながら、もりもり布教しようと思います (沼のまわりに餌をまく) 。今回の記事では、先日の 3-shake SRE Tech Talk で発表した内容に加えて、スライドの余白と発表時間の制約で記載できなかったことも記載しました😗↪️ 参考：Istio⛵️によるサービスディスカバリーの仕組み - Speaker Deck02. サービスディスカバリーについてマイクロサービスアーキテクチャにおけるサービスディスカバリーサービスディスカバリーとはマイクロサービスアーキテクチャでは、マイクロサービスからマイクロサービスにリクエストを送信する場面があります。サービスディスカバリーとは、宛先マイクロサービスの宛先情報 (例：IPアドレス、完全修飾ドメイン名、など) を検出し、送信元マイクロサービスが宛先マイクロサービスにリクエストを継続的に送信できるようにする仕組みのことです。なぜサービスディスカバリーが必要なのかそもそも、なぜサービスディスカバリーが必要なのでしょうか。マイクロサービスアーキテクチャでは、システムの信頼性 (定められた条件下で定められた期間にわたり、障害を発生させることなく実行する程度) を担保するために、マイクロサービスのインスタンスの自動スケーリングを採用します。この時、自動スケーリングのスケールアウトでマイクロサービスが増加するたびに、各インスタンスには新しい宛先情報が割り当てられてしまいます。また、マイクロサービスが作り直された場合にも、宛先情報は更新されてしまいます。このように、たとえインスタンスの宛先情報が更新されたとしても、インスタンスへのリクエストに失敗しない仕組みが必要です。サービスディスカバリーの要素サービスディスカバリーの仕組みは、次の要素からなります。名前解決に関しては、DNSベースのサービスディスカバリー (例：CoreDNS + Service + kube-proxyによるサービスディスカバリー) で必要となり、Istioでは使いません。そのため、本記事では言及しないこととします🙇🏻‍ 要素                    責務                                                                    送信元マイクロサービス  リクエストを送信する。                                                  宛先マイクロサービス    リクエストを受信する。                                                  サービスレジストリ      宛先マイクロサービスの宛先情報を保管する。                              ロードバランサー        宛先マイクロサービスのインスタンスにロードバランシングする。            名前解決                宛先マイクロサービスへのリクエスト送信時に、名前解決できるようにする。 サービスディスカバリーのパターンサービスディスカバリーのパターンとはサービスディスカバリーの仕組みにはいくつか種類があります。Istioのサービスディスカバリーは、このうちのサーバーサイドパターンを実装したものになります。サーバーサイドパターン送信元マイクロサービスから、問い合わせとロードバランシングの責務が切り離されています。送信元マイクロサービスは、ロードバランサーにリクエストを送信します。ロードバランサーは、宛先マイクロサービスの宛先をサービスレジストリに問い合わせ、またリクエストをロードバランシングする責務を担っています💪🏻(例) Istio、Linkerd、など↪️ 参考：Amazon.co.jp: Cloud Native Patterns: Designing change-tolerant software (English Edition) 電子書籍: Davis, Cornelia: 洋書Server-side service discovery patternクライアントサイドパターン通信の送信元マイクロサービスは、宛先マイクロサービスの宛先をサービスレジストリに問い合わせ、さらにロードバランシングする責務を担います。(例) NeflixのEureka、など↪️ 参考：Amazon.co.jp: Cloud Native Patterns: Designing change-tolerant software (English Edition) 電子書籍: Davis, Cornelia: 洋書Client-side service discovery patternService Discovery in Kubernetes: Combining the Best of Two Worlds03. IstioのサービスディスカバリーIstioのサービスディスカバリーの仕組みIstioが実装するサービスメッシュには、サイドカープロキシメッシュとアンビエントメッシュがあり、今回はサイドカープロキシメッシュのサービスディスカバリーを取り上げます。Istioのサービスディスカバリーは、discoveryコンテナとistio-proxyコンテナが軸となり、サーバーサイドパターンのサービスディスカバリーを実装します。全体像【１】 〜 【６】の全体像は、以下の通りです👇istio-proxyコンテナは、サービスレジストリへの問い合わせと、ロードバランシングする責務を担っていることに注目してください。【１】kube-apiserverは、Pod等の宛先情報をetcd等に保管します。これは、Kubernetesの通常の仕組みです。【２】discoveryコンテナは、kube-apiserverからPod等の宛先情報を取得し、自身に保管します。【３】istio-proxyコンテナは、discoveryコンテナからPod等の宛先情報を双方向ストリーミングRPCで取得します。【４】送信元マイクロサービスがリクエストを送信します。サーバーサイドパターンでの責務通り、送信元マイクロサービスはロードバランサー (ここではistio-proxyコンテナ) にリクエストを送信します。この時、送信元マイクロサービスがistio-proxyコンテナに直接的にリクエストを送信しているというよりは、iptablesがistio-proxyコンテナにリクエストをリダイレクトします。istio-proxyコンテナこれを受信します。【５】istio-proxyコンテナは、リクエストをロードバランシングし、宛先Podにこれを送信します。↪️ 参考：Amazon | Istio in Action | Posta, Christian E., Maloku, Rinor | Software DevelopmentJimmy Song - 专注于探索后 Kubernetes 时代的云原生新范式Tech-赵化冰的博客 | Zhaohuabing Blogdiscoveryコンテナの仕組みdiscoveryコンテナを詳しく見てみましょう。discoveryコンテナは、別名Istiodと呼ばれています。XDS-APIというエンドポイントを公開しており、XDS-APIのうち、サービスディスカバリーに関係するAPIは以下の通りです。 APIの種類  説明                                                   LDS-API    Envoyのリスナー値を取得できる。                        RDS-API    Envoyのルート値を取得できる。                          CDS-API    Envoyのクラスター値を取得できる。                      EDS-API    Envoyのエンドポイント値できる。                        ADS-API    各XDS-APIから取得できる宛先情報を整理して取得できる。 discoveryコンテナは、kube-apiserverからPod等の宛先情報を取得して自身のメモリ上に保管し、各XDS-APIから提供します。XDS-APIとistio-proxyコンテナの間では、gRPCの双方向ストリーミングRPCの接続が確立されています。そのため、istio-proxyコンテナからのリクエストに応じて宛先情報を返却するだけでなく、リクエストがなくとも、XDS-APIからもistio-proxyコンテナに対して宛先情報を送信します。各種XDS-APIから個別に宛先情報を取得できますが、Envoy上で宛先情報のバージョンの不整合が起こる可能性があるため、Istioでは実際にはADS-APIを使用しています。↪️ 参考：Amazon | Istio in Action | Posta, Christian E., Maloku, Rinor | Software Developmentistio-proxyコンテナの仕組みistio-proxyコンテナを詳しく見てみましょう。istio-proxyコンテナでは、pilot-agentとEnvoyが稼働しています。先ほどistio-proxyコンテナは、双方向ストリーミングRPCでADS-APIから宛先情報を取得すると説明しました。厳密にはEnvoyが、pilot-agentを介して、ADS-APIから双方向ストリーミングRPCで宛先情報を取得します。istio-proxyコンテナが送信元マイクロサービスからリクエストを受信すると、EnvoyはADS-APIから取得した宛先情報に基づいて、宛先マイクロサービスのインスタンスにロードバランシングします。↪️ 参考：Amazon | Istio in Action | Posta, Christian E., Maloku, Rinor | Software DevelopmentJimmy Song - 专注于探索后 Kubernetes 时代的云原生新范式Tech-赵化冰的博客 | Zhaohuabing Blog04. istio-proxyコンテナ内のEnvoyの仕組みEnvoyの処理の流れEnvoyがADS-APIから取得した宛先情報を見ていく前に、Envoyの処理の流れを解説します。istio-proxyコンテナ内のEnvoyでは、以下の仕組みでリクエストを処理します。全体像【１】 〜 【６】の全体像は、以下の通りです👇【１】istio-proxyコンテナは、送信元マイクロサービスからリクエストを受信します。【２】Envoyは、リクエストの宛先情報 (例：宛先IPアドレス、ポート番号、パス、ホスト、など) に応じてリスナー値を選びます。【３】Envoyは、リスナーに紐づくルート値を選びます。【４】Envoyは、クラスターに紐づくクラスター値を選びます。【５】Envoyは、クラスターに紐づくエンドポイント値を選びます。【６】Envoyは、エンドポイント値に対応するインスタンスにリクエストを送信します。Envoyで確認した宛先情報を👆に当てはめて見ていくことにしましょう。↪️ 参考：Amazon.co.jp: Istio in Action (English Edition) 電子書籍: Posta, Christian E., Maloku, Rinor: 洋書Amazon | Istio: Up and Running: Using a Service Mesh to Connect, Secure, Control, and Observe | Calcote, Lee, Butcher, Zack | Design Tools \u0026 TechniquesArchitecture Analysis of Istio: The Most Popular Service Mesh Project - Alibaba Cloud CommunityEnvoyがADS-APIから取得した宛先情報を見てみようconfig_dumpエンドポイント実際にEnvoyに登録されている宛先情報は、istio-proxyコンテナ自体のlocalhost:15000/config_dumpからJSONで取得できます。ただし、JSONだと見にくいので、yqコマンドでYAMLに変換すると見やすくなります。もしお手元にIstioがある場合は、Envoyにどんな宛先情報が登録されているか、Envoyを冒険してみてください👍🏻$ kubectl exec \\    -it foo-pod \\    -n foo-namespace \\    -c istio-proxy \\    -- bash -c \"curl http://localhost:15000/config_dump\" | yq -Pリスナー値▼ 確認方法istio-proxyコンテナがADS-APIから取得したリスナー値は、/config_dump?resource={dynamic_listeners}から確認できます。ここでは、foo-pod内でbar-podのリスナー値を確認したと仮定します。$ kubectl exec \\    -it foo-pod \\    -n foo-namespace \\    -c istio-proxy \\    -- bash -c \"curl http://localhost:15000/config_dump?resource={dynamic_listeners}\" | yq -P▼ 結果以下を確認できました。宛先IPアドレスや宛先ポート番号に応じてリスナー値を選べるようになっており、ここでは\u003c任意のIPアドレス\u003e:50002。リスナー値に紐づくルート値の名前configs:  - \"@type\": type.googleapis.com/envoy.admin.v3.ListenersConfigDump.DynamicListener    # リスナー名    name: 0.0.0.0_50002    active_state:      version_info: 2022-11-24T12:13:05Z/468      listener:        \"@type\": type.googleapis.com/envoy.config.listener.v3.Listener        name: 0.0.0.0_50002        address:          socket_address:            # 受信したパケットのうちで、宛先IPアドレスでフィルタリング            address: 0.0.0.0            # 受信したパケットのうちで、宛先ポート番号でフィルタリング            port_value: 50002        filter_chains:          - filter_chain_match:              transport_protocol: raw_buffer              application_protocols:                - http/1.1                - h2c            filters:              - name: envoy.filters.network.http_connection_manager                typed_config:                  \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager                  stat_prefix: outbound_0.0.0.0_50001                  rds:                    config_source:                      ads: {}                      initial_fetch_timeout: 0s                      resource_api_version: V3                    # 本リスナーに紐づくルート値の名前                    route_config_name: 50002  ...  - \"@type\": type.googleapis.com/envoy.admin.v3.ListenersConfigDump.DynamicListener  ...↪️ 参考：Administration interface — envoy 1.26.0-dev-7cc893 documentationConfigDump (proto) — envoy 1.26.0-dev-7cc893 documentationルート値▼ 確認方法istio-proxyコンテナがADS-APIから取得したリスナー値は、/config_dump?resource={dynamic_route_configs}から確認できます。ここでは、foo-pod内でbar-podのルート値を確認したと仮定します。$ kubectl exec \\    -it foo-pod \\    -n foo-namespace \\    -c istio-proxy \\    -- bash -c \"curl http://localhost:15000/config_dump?resource={dynamic_route_configs}\" | yq -P▼ 結果コマンドを実行するとYAMLを取得でき、以下を確認できました。リスナー値を取得した時に確認できたルート値の名前リクエストのパスやホストヘッダーに応じてルート値を選べるようになっているルート値に紐づくクラスター値の名前configs:  - \"@type\": type.googleapis.com/envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig    version_info: 2022-11-24T12:13:05Z/468    route_config:      \"@type\": type.googleapis.com/envoy.config.route.v3.RouteConfiguration      # ルート値の名前      name: 50002      virtual_hosts:        - name: bar-service.bar-namespace.svc.cluster.local:50002          # ホストベースルーティング          domains:            - bar-service.bar-namespace.svc.cluster.local            - bar-service.bar-namespace.svc.cluster.local:50002            - bar-service            - bar-service:50002            - bar-service.bar-namespace.svc            - bar-service.bar-namespace.svc:50002            - bar-service.bar-namespace            - bar-service.bar-namespace:50002            - 172.16.0.2            - 172.16.0.2:50002          routes:            - match:                # パスベースルーティング                prefix: /              route:                # 本ルートに紐づくクラスター値の名前                cluster: outbound|50002|v1|bar-service.bar-namespace.svc.cluster.local                timeout: 0s                retry_policy:                  retry_on: connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes                  num_retries: 2                  retry_host_predicate:                    - name: envoy.retry_host_predicates.previous_hosts                  host_selection_retry_max_attempts: \"5\"                  retriable_status_codes:                    - 503                max_stream_duration:                  max_stream_duration: 0s                  grpc_timeout_header_max: 0s              decorator:                operation: bar-service.bar-namespace.svc.cluster.local:50002/*  ...  - '@type': type.googleapis.com/envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig  ...↪️ 参考：Administration interface — envoy 1.26.0-dev-7cc893 documentationConfigDump (proto) — envoy 1.26.0-dev-7cc893 documentationクラスター値▼ 確認方法istio-proxyコンテナがADS-APIから取得したクラスター値は、/config_dump?resource={dynamic_active_clusters}から確認できます。ここでは、foo-pod内でbar-podのクラスター値を確認したと仮定します。$ kubectl exec \\    -it foo-pod \\    -n foo-namespace \\    -c istio-proxy \\    -- bash -c \"curl http://localhost:15000/config_dump?resource={dynamic_active_clusters}\" | yq -P▼ 結果コマンドを実行するとYAMLを取得でき、以下を確認できました。ルート値を取得した時に確認できたクラスター値の名前クラスター値に紐づくエンドポイント値の親名configs:  - \"@type\": type.googleapis.com/envoy.admin.v3.ClustersConfigDump.DynamicCluster    version_info: 2022-11-24T12:13:05Z/468    cluster:      \"@type\": type.googleapis.com/envoy.config.cluster.v3.Cluster      # クラスター値の名前      name: outbound|50002|v1|bar-service.bar-namespace.svc.cluster.local      type: EDS      eds_cluster_config:        eds_config:          ads: {}          initial_fetch_timeout: 0s          resource_api_version: V3        # 本クラスターに紐づくエンドポイント値の親名        service_name: outbound|50002|v1|bar-service.bar-namespace.svc.cluster.local  ...  - \"@type\": type.googleapis.com/envoy.admin.v3.ClustersConfigDump.DynamicCluster  ...↪️ 参考：Administration interface — envoy 1.26.0-dev-7cc893 documentationConfigDump (proto) — envoy 1.26.0-dev-7cc893 documentationエンドポイント値▼ 確認方法istio-proxyコンテナがADS-APIから取得したクラスター値は、/config_dump?include_edsから確認できます。ここでは、foo-pod内でbar-podのクラスター値を確認したと仮定します。$ kubectl exec \\    -it foo-pod \\    -n foo-namespace \\    -c istio-proxy \\    -- bash -c \"curl http://localhost:15000/config_dump?include_eds\" | yq -P▼ 結果コマンドを実行するとYAMLを取得でき、以下を確認できました。クラスター値を取得した時に確認できたエンドポイントの親名bar-podのインスタンスが3個あるため、3個のエンドポイントがあります全てのエンドポイントのload_balancing_weightキー値が等しい場合、EnvoyはP2Cアルゴリズムに基づいてロードバランシングします。configs:  dynamic_endpoint_configs:    - endpoint_config:        \"@type\": type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment        # エンドポイントの親名        cluster_name: outbound|50002|v1|bar-service.bar-namespace.svc.cluster.local        endpoints:          - locality:              region: ap-northeast-1              zone: ap-northeast-1a            lb_endpoints:              - endpoint:                  address:                    socket_address:                      # 冗長化されたbar-podのIPアドレス                      address: 11.0.0.1                      # bar-pod内のコンテナが待ち受けているポート番号                      port_value: 80                  health_check_config: {}                health_status: HEALTHY                metadata:                  filter_metadata:                    istio:                      workload: bar                    envoy.transport_socket_match:                      tlsMode: istio                # ロードバランシングアルゴリズムを決める数値                load_balancing_weight: 1          - locality:              region: ap-northeast-1              zone: ap-northeast-1d            lb_endpoints:              - endpoint:                  address:                    socket_address:                      # 冗長化されたbar-podのIPアドレス                      address: 11.0.0.2                      # bar-pod内のコンテナが待ち受けているポート番号                      port_value: 80                  health_check_config: {}                health_status: HEALTHY                metadata:                  filter_metadata:                    istio:                      workload: bar                    envoy.transport_socket_match:                      tlsMode: istio                # ロードバランシングアルゴリズムを決める数値                load_balancing_weight: 1          - locality:              region: ap-northeast-1              zone: ap-northeast-1d            lb_endpoints:              - endpoint:                  address:                    socket_address:                      # 冗長化されたbar-podのIPアドレス                      address: 11.0.0.3                      # bar-pod内のコンテナが待ち受けているポート番号                      port_value: 80                  health_check_config: {}                health_status: HEALTHY                metadata:                  filter_metadata:                    istio:                      workload: bar                    envoy.transport_socket_match:                      tlsMode: istio                # ロードバランシングアルゴリズムを決める数値                load_balancing_weight: 1        policy:          overprovisioning_factor: 140    ...    - endpoint_config:    ...↪️参考：Administration interface — envoy 1.26.0-dev-7cc893 documentationConfigDump (proto) — envoy 1.26.0-dev-7cc893 documentationSupported load balancers — envoy 1.26.0-dev-7cc893 documentationEnvoyの処理の流れのまとめ確認できた宛先情報を、Envoyの処理の流れに当てはめてみました。【１】送信元マイクロサービスは、宛先マイクロサービス (\u003c任意のIP\u003e/:50002) にリクエストを送信し、サイドカーコンテナのistio-proxyコンテナはこれを受信します。【２】Envoyは、リクエストの宛先 (IPアドレス、ポート番号、パス) からPodのリスナー値 (0.0.0.0_50002) を選びます。【３】Envoyは、リスナーに紐づくPodのルート値 (50002) を選びます。【４】Envoyは、クラスターに紐づくPodのクラスター値 (outbound|50002|v1|bar-service.bar-namespace.svc.cluster.local) を選びます。【５】Envoyは、クラスターに紐づくPodのインスタンスのエンドポイント値 (11.0.0.X/:80) を選びます。【６】Envoyは、エンドポイント値の宛先にPodのリクエストを送信します。サービスディスカバリーの冒険は以上です⛵05. おわりにIstioの機能の一つである『サービスディスカバリー』の仕組みを、Envoyを交えながらもりもり布教しました。Istioへの愛が溢れてしまいました。ここまで見ていただいたそこのあなた、片足が沼に浸かってます😏謝辞3-shake SRE Tech Talk での発表前後に、以下の方々に、発表内容について助言をいただきました。@ido_kara_deru さん@yosshi_ さん@yteraoka さん(アルファベット順)また、今回の 3-shake Advent Calender 2022 は、以下の方々に企画いただきました。@jigyakkuma_ さん@nwiizo さん(アルファベット順)皆様に感謝申し上げます🙇🏻‍♂️","link":"https://hiroki-hasegawa.hatenablog.jp/entry/2022/12/25/060000","isoDate":"2022-12-24T21:00:00.000Z","dateMiliSeconds":1671915600000,"authorName":"Hiroki Hasegawa","authorId":"hiroki-hasegawa"}]},"__N_SSG":true},"page":"/members/[id]","query":{"id":"hiroki-hasegawa"},"buildId":"KnKs7POUW3nQDWqbe5B-Q","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["link",{"rel":"icon shortcut","type":"image/png","href":"https://blog.3-shake.com//logo.png"}],["link",{"href":"https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;500;700\u0026family=Roboto:wght@300;400;500;700\u0026display=swap","rel":"stylesheet"}],["title",{"children":"Hiroki Hasegawa | 3-shake Engineers' Blogs"}],["meta",{"property":"og:title","content":"Hiroki Hasegawa"}],["meta",{"property":"og:url","content":"https://blog.3-shake.com//members/hiroki-hasegawa"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"property":"og:site","content":"3-shake Engineers' Blogs"}],["meta",{"property":"og:image","content":"https://blog.3-shake.com//og.png"}],["link",{"rel":"canonical","href":"https://blog.3-shake.com//members/hiroki-hasegawa"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-fa276ba060a4a8ac7eef.js"></script><script src="/_next/static/chunks/main-8a83f0fd99327c4684a8.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.1daf1ec1ecf144ee9147.js" async=""></script><script src="/_next/static/chunks/commons.9e003f150a446b53bdd9.js" async=""></script><script src="/_next/static/chunks/pages/_app-1a98368b242d5422e7a2.js" async=""></script><script src="/_next/static/chunks/81b50c7ab23905e464b4340eb234bd6ea389d26b.c03eca8dad16a5aaea85.js" async=""></script><script src="/_next/static/chunks/pages/members/%5Bid%5D-c86b263a3b72cf772df9.js" async=""></script><script src="/_next/static/KnKs7POUW3nQDWqbe5B-Q/_buildManifest.js" async=""></script><script src="/_next/static/KnKs7POUW3nQDWqbe5B-Q/_ssgManifest.js" async=""></script></body></html>