{"pageProps":{"member":{"id":"nwiizo","name":"nwiizo","role":"Software Developer","bio":"The Passionate Programmer","avatarSrc":"/avatars/nwiizo.jpeg","sources":["https://syu-m-5151.hatenablog.com/feed","https://zenn.dev/nwiizo/feed","https://speakerdeck.com/nwiizo.rss"],"includeUrlRegex":"","twitterUsername":"nwiizo","githubUsername":"nwiizo","websiteUrl":"https://nwiizo.github.io/"},"postItems":[{"title":"Neovimで使うCopilotのモデルをClaudeに変更する苦労話 - 技術ブログ未満の個人的体験談","link":"https://syu-m-5151.hatenablog.com/entry/2025/02/27/184558","contentSnippet":"免責事項: この記事は個人的な発見と試行錯誤を記録したものであり、正式なドキュメントに基づく推奨設定ではありません。ここで紹介する方法を実際の環境に適用する際は、十分な検証と自己責任でお願いします。はじめにこんにちは、Neovimユーザーのnwiizoです。今回は、NeovimでCopilotを使う際にAIモデルをClaudeに変更しようとして遭遇した「ちょっとした冒険」について共有したいと思います。最近、mizchiさんの最高のブログを読んだ。zenn.devこの記事を読んで魂を揺さぶられた。だが、まだVSCodeには移行しない。Neovimを使い続けることを決意した。揺らいだ。しかし、Neovim環境でもCopilotのAIモデルを自由に変更できたほうが良いと思い、特にClaudeモデルを試してみることにした。やりたかったこと最近、GitHub Copilotが Claude-3.7-sonnetなどのAnthropicのモデルをサポートするようになり、コーディング支援にもっと高度なAIの力を借りたいと思いました。GitHubの公式ドキュメント「Copilot Chat の AI モデルを変更する」によると、Copilot ChatのデフォルトLLMを別のモデルに変更できるようになっています。私のNeovim環境ではyetone/avante.nvimを使用してCopilotとの対話を行っていたので、このプラグインの設定でモデルを変更しようとしました。syu-m-5151.hatenablog.com最初の試み（失敗）まず試したのは、avante.nvimの設定で直接モデルを指定する方法です：{    \"yetone/avante.nvim\",    event = \"VeryLazy\",    lazy = false,    version = false,    opts = {      provider = \"copilot\", -- copilotを使用      auto_suggestions_provider = \"copilot\",      copilot = {        endpoint = \"https://api.githubcopilot.com\",        model = \"claude-3.7-sonnet\", -- ここでClaudeモデルを指定        timeout = 30000,        temperature = 0,        max_tokens = 4096,      },      -- 以下省略...    },    -- 依存関係などの設定...}しかし、この設定を適用してもなぜか期待通りの動作をしませんでした。デバッグを試みましたが、avante.nvimの設定だけではモデルの変更がうまく反映されていないようでした。というかこのような設定はたぶんなくて⋯。解決策：CopilotChat.nvimの力を借りる調査を進めるうちに、面倒になってCopilotC-Nvim/CopilotChat.nvimというプラグインの設定も変更しようと思いました。このプラグインはCopilotのチャットインターフェースを提供するもので、モデル設定も直接サポートしています。試しに以下の設定を追加してみました：-- Copilotチャット用の設定{  \"CopilotC-Nvim/CopilotChat.nvim\",  event = { \"VeryLazy\" },  branch = \"main\",  dependencies = {    { \"zbirenbaum/copilot.lua\" },    { \"nvim-lua/plenary.nvim\" },  },  opts = {    model = \"claude-3.7-sonnet\", -- モデル名を指定    debug = true, -- デバッグを有効化  },}そして驚いたことに、この設定を追加した後、avante.nvim側でもClaudeモデルが使われるようになりました！どうやら、CopilotChat.nvimの設定がcopilot.luaの基本設定に影響を与え、それがavante.nvimにも「引きずられて」反映されたようです。【注意】これは技術ブログ未満の個人的な発見であり、正式なドキュメントに基づくものではありません。このような依存関係による予期せぬ影響は、本番環境では深刻な問題を引き起こす可能性があります。設定の影響範囲を十分理解せずに適用すれば、システム全体に致命的な影響を及ぼす可能性があることを肝に銘じてください。なぜこうなったのか？正確な理由は不明ですが、おそらく両方のプラグインが同じzbirenbaum/copilot.luaに依存しており、この共通の依存関係を通じて設定が共有されたのだと思われます。CopilotChat.nvimがより直接的にCopilot APIとの連携部分を制御しているため、そちらでの設定が優先されたのでしょう。教訓Neovimのプラグインエコシステムでは、依存関係の連鎖によって予想外の相互作用が発生することがあります。今回のケースでは幸いにも望んだ結果につながりましたが、これは完全に「技術ブログ未満」の個人的な発見に過ぎません。警告: このような依存関係の連鎖による予期せぬ相互作用は、本番環境では極めて危険です。プラグイン間の隠れた依存関係による設定の「引きずり」は、デバッグが困難な問題を引き起こし、最悪の場合、本番システムの停止や重大なセキュリティ問題につながる可能性があります。設定変更の影響範囲を完全に理解しないまま適用することは、言わば地雷原を歩くようなものであることを忘れないでください。他の方も同様の状況に遭遇した場合、両方のプラグインを併用する方法が一つの解決策になるかもしれません。最終的な設定結局、私の設定はavante.nvimとCopilotChat.nvimの両方を含む形になりました：-- avante.nvimの設定（一部省略）{    \"yetone/avante.nvim\",    -- 省略...    opts = {      provider = \"copilot\",      auto_suggestions_provider = \"copilot\",      copilot = {        endpoint = \"https://api.githubcopilot.com\",        model = \"claude-3.7-sonnet\",        -- 省略...      },    },    -- 省略...},-- CopilotChat.nvimの設定{  \"CopilotC-Nvim/CopilotChat.nvim\",  event = { \"VeryLazy\" },  branch = \"main\",  dependencies = {    { \"zbirenbaum/copilot.lua\" },    { \"nvim-lua/plenary.nvim\" },  },  opts = {    model = \"claude-3.7-sonnet\",    debug = true,  },},これでNeovimでのコーディング体験がClaudeの能力で強化され、より的確なコード提案や説明が得られるようになりました。Neovimの設定は時に「魔法」のように思えることもありますが、それも含めて楽しいハック体験の一部なのでしょう。注：この記事は2025年2月時点の情報に基づいています。Copilotの仕様やプラグインの動作は変更される可能性があります。参考リンクGitHub Copilot Chat の AI モデルを変更する方法yetone/avante.nvimCopilotC-Nvim/CopilotChat.nvimzbirenbaum/copilot.lua","isoDate":"2025-02-27T09:45:58.000Z","dateMiliSeconds":1740649558000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"🦀 Automating Rust Dependency Management - A Deep Dive into cargo-autodd","link":"https://syu-m-5151.hatenablog.com/entry/2025/02/20/121157","contentSnippet":"📖 IntroductionWhen developing Rust projects, we frequently need to add new crates or remove unused ones. While Rust provides the cargo add command as a standard tool for managing dependencies from the command line:cargo add serde --features deriveHowever, cargo add requires manual execution and doesn't detect or remove unused dependencies. To further automate this dependency management process, I developed \"cargo-autodd\" 🚀.I developed \"cargo-autodd\", a CLI tool to automate dependency management in Rust. It analyzes use statements and extern crates to add required crates to Cargo.toml. Release planned this week with nvim support.https://t.co/ZNfOu4AxEd pic.twitter.com/Tsh0KzEiZV— nwiizo (@nwiizo) 2025年2月16日   🎯 What is cargo-autodd?cargo-autodd is a tool that automatically analyzes Rust source code to detect required dependencies and updates Cargo.toml accordingly.github.comKey features include:🔍 Analysis of use statements and extern crate declarations in source code🤖 Automatic detection of required crates⬆️ Addition of latest stable versions to Cargo.toml🗑️ Removal of unused crates⚡ Advanced analysis using rust-analyzer (optional)🛠️ Technical Details📊 Project Structure AnalysisThe analysis is centered around the DependencyManager struct, which has the following fields:struct DependencyManager {    project_root: PathBuf,  // Project root directory    cargo_toml: PathBuf,    // Path to Cargo.toml}🔄 Dependency Analysis ProcessThe analyze_dependencies method performs analysis in three stages:🚀 rust-analyzer Analysis (Priority)let output = Command::new(\"rust-analyzer\")    .arg(\"analysis\")    .arg(\"--workspace\")    .current_dir(&self.project_root)    .output()?;📝 Regex Analysis (Fallback)let use_regex = Regex::new(r\"use\\s+([a-zA-Z_][a-zA-Z0-9_]*)(::|\\s|;)\")?;let extern_regex = Regex::new(r\"extern\\s+crate\\s+([a-zA-Z_][a-zA-Z0-9_]*)\")?;✅ Result Aggregation and VerificationRecords usage locations and feature flags for each detected crateExcludes standard library cratesEliminates duplicates📝 Cargo.toml Update MechanismThe update_cargo_toml method updates dependencies through the following steps:📖 Reading Current Dependencieslet content = fs::read_to_string(&self.cargo_toml)?;let mut doc = content.parse::<DocumentMut>()?;➕ Adding New Dependenciesfor (name, crate_ref) in crate_refs {    if !current_deps.contains(name) && !is_std_crate(name) {        self.add_dependency(&mut doc, crate_ref)?;    }}➖ Removing Unused DependenciesPreserves essential dependencies specified by is_essential_depfn is_essential_dep(name: &str) -> bool {    let essential_deps = [        \"serde\",        \"tokio\",        \"anyhow\",        \"thiserror\",        \"async-trait\",        \"futures\",    ];    essential_deps.contains(&name)}📈 Version Management DetailsVersion management is handled by the get_latest_version method with the following features:🌐 Fetching Latest Version from crates.io APIlet url = format!(\"https://crates.io/api/v1/crates/{}/versions\", crate_name);🚫 Excluding Yanked Versionslet latest_version = response    .versions    .iter()    .find(|v| !v.yanked)?;🔢 Applying Semantic VersioningSpecifies only major and minor versionsAllows automatic patch version updatesOk(format!(\"^{}.{}.0\", version.major, version.minor))📚 Best Practices and Usage Guidelines🔧 PreparationInstall rust-analyzer (recommended)Ensure project builds successfully🚀 Execution StepsRun cargo autodd in the project root directoryReview the changesPay special attention to version specificationsVerify dependency consistency with cargo check🔍 TroubleshootingFalls back to regex analysis if rust-analyzer is unavailableManually correct any falsely detected dependencies🔮 Future PlansFuture enhancements planned for cargo-autodd include:🔍 Enhanced AnalysisMacro expansion and dependency analysisMore accurate feature flag detectionConsideration of conditional compilation (cfg attributes)📦 Extended Dependency ManagementAutomatic management of dev-dependenciesEnhanced workspace supportAutomatic version conflict resolution💻 Improved Developer ExperienceEditor integration (e.g., VSCode extension)More detailed dependency graph visualizationCI automation options🎉 Conclusioncargo-autodd is a powerful tool for automating dependency management in Rust projects. Its strengths can be summarized in three key areas:⚡ Enhanced EfficiencyEliminates manual dependency management overheadMaintains project dependencies at latest necessary versionsImproves maintainability through automated version management🔒 Ensured SafetyAccurate dependency analysis using rust-analyzerProper handling of semantic versioningProtection of essential dependencies🎯 Improved Developer ExperienceSimple usage patternReduced maintenance time through automationClear visualization of project dependenciesThese features allow developers to focus more on essential coding tasks. As an open-source project, it continues to evolve through community feedback and contributions.cargo-autodd is expected to become an increasingly important tool as the Rust ecosystem matures. We hope it serves as an effective solution to the challenge of dependency management for many developers in the Rust community. 🚀日本語版:syu-m-5151.hatenablog.com","isoDate":"2025-02-20T03:11:57.000Z","dateMiliSeconds":1740021117000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Rustの依存関係管理を自動化する - cargo-autoddの紹介","link":"https://syu-m-5151.hatenablog.com/entry/2025/02/20/120339","contentSnippet":"はじめにRustプロジェクトを開発していると、新しいクレートを追加したり不要なクレートを削除したりする作業は頻繁に発生します。現在、Rustにはcargo addというコマンドが標準で用意されており、コマンドラインから依存関係を追加することができます。cargo add serde --features deriveしかし、cargo addは手動での実行が必要で、また使用していない依存関係の検出や削除は行いません。この依存関係の管理をさらに自動化できないか？という思いから開発したのが「cargo-autodd」です。Rustで開発する際の面倒な依存関係管理を自動化するツール「cargo-autodd」を開発しました。ソースコード内のuse文やextern crate宣言を解析し、必要なクレートを自動でCargo.tomlに追加します。先ほど作ったのでバグや不具合があると思うのでPRお願いします。テストもない。https://t.co/ZNfOu4AxEd pic.twitter.com/RbQNyp0K8H— nwiizo (@nwiizo) 2025年2月16日   cargo-autoddとはcargo-autoddは、Rustのソースコードを解析して必要な依存関係を自動的に検出し、Cargo.tomlを更新するツールです。github.com主な特徴は以下の通りです：ソースコード内のuse文とextern crate宣言を解析必要なクレートを自動検出Cargo.tomlに最新の安定バージョンを追加未使用のクレートを削除rust-analyzerを活用した高度な解析（オプション）技術的な詳細プロジェクト構造の解析プロジェクトの解析はDependencyManager構造体を中心に行われます。この構造体は以下のようなフィールドを持ちます：struct DependencyManager {    project_root: PathBuf,  // プロジェクトのルートディレクトリ    cargo_toml: PathBuf,    // Cargo.tomlのパス}依存関係の解析プロセスanalyze_dependenciesメソッドは、以下の3段階で依存関係を解析します：rust-analyzerによる解析（優先）let output = Command::new(\"rust-analyzer\")    .arg(\"analysis\")    .arg(\"--workspace\")    .current_dir(&self.project_root)    .output()?;正規表現による解析（フォールバック）let use_regex = Regex::new(r\"use\\s+([a-zA-Z_][a-zA-Z0-9_]*)(::|\\s|;)\")?;let extern_regex = Regex::new(r\"extern\\s+crate\\s+([a-zA-Z_][a-zA-Z0-9_]*)\")?;結果の集約と検証検出された各クレートに対して、使用箇所とフィーチャーフラグを記録標準ライブラリのクレートを除外重複を排除Cargo.tomlの更新メカニズムupdate_cargo_tomlメソッドは、以下の手順で依存関係を更新します：現在の依存関係の読み取りlet content = fs::read_to_string(&self.cargo_toml)?;let mut doc = content.parse::<DocumentMut>()?;新規依存関係の追加for (name, crate_ref) in crate_refs {    if !current_deps.contains(name) && !is_std_crate(name) {        self.add_dependency(&mut doc, crate_ref)?;    }}未使用依存関係の削除ただし、is_essential_depで指定された重要な依存関係は保持fn is_essential_dep(name: &str) -> bool {    let essential_deps = [        \"serde\",        \"tokio\",        \"anyhow\",        \"thiserror\",        \"async-trait\",        \"futures\",    ];    essential_deps.contains(&name)}バージョン管理の詳細バージョン管理はget_latest_versionメソッドで行われ、以下の特徴があります：crates.ioのAPIを使用した最新バージョンの取得let url = format!(\"https://crates.io/api/v1/crates/{}/versions\", crate_name);Yank済みバージョンの除外let latest_version = response    .versions    .iter()    .find(|v| !v.yanked)?;セマンティックバージョニングの適用メジャーバージョンとマイナーバージョンのみを指定パッチバージョンは自動更新可能にOk(format!(\"^{}.{}.0\", version.major, version.minor))ベストプラクティスと使用上の注意点事前準備rust-analyzerのインストール（推奨）プロジェクトのビルドが通っていることを確認実行手順プロジェクトのルートディレクトリでcargo autoddを実行変更内容を必ず確認特にバージョン指定に注意を払うcargo checkで依存関係の整合性を検証トラブルシューティングrust-analyzerが使用できない場合は正規表現による解析にフォールバック誤検出された依存関係は手動で修正今後の展望cargo-autoddの将来的な機能拡張として、以下を計画しています：解析機能の強化マクロの展開とその依存関係の解析より正確なフィーチャーフラグの自動検出条件付きコンパイル（cfg属性）の考慮依存関係管理の拡張開発依存関係（dev-dependencies）の自動管理ワークスペース対応の強化バージョン競合の自動解決開発者体験の向上エディターへの組み込み（VSCode拡張など）より詳細な依存関係グラフの可視化CIでの自動実行オプションまとめcargo-autoddは、Rustプロジェクトにおける依存関係管理の自動化を実現する強力なツールです。その特徴は以下の点にあります：効率性の向上手動での依存関係管理の煩わしさを解消プロジェクトの依存関係を常に最新かつ必要最小限に保持バージョン管理の自動化による保守性の向上安全性の確保rust-analyzerを活用した正確な依存関係の解析セマンティックバージョニングの適切な処理重要な依存関係の保護機能開発者体験の改善シンプルな使用方法自動化による作業時間の削減プロジェクトの依存関係の可視化これらの機能により、開発者はより本質的なコーディング作業に集中できるようになります。また、オープンソースプロジェクトとして公開されているため、コミュニティからのフィードバックや貢献を受け入れながら、さらなる機能改善を進めていく予定です。cargo-autoddは、Rustエコシステムの成熟に伴い、より重要なツールとなることが期待されます。依存関係管理の自動化という課題に対する一つの解決策として、多くの開発者の方々に活用していただければ幸いです。English Edition:syu-m-5151.hatenablog.com","isoDate":"2025-02-20T03:03:39.000Z","dateMiliSeconds":1740020619000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"nwiizo はなぜ同じPlatform Engineeringを語るのに、2つの異なる資料を作ったのか #devsumi #PFEM","link":"https://syu-m-5151.hatenablog.com/entry/2025/02/14/071127","contentSnippet":"はじめにこんにちは、nwiizoです。2025年2月13日に2つのイベントで登壇する機会をいただきました。これは私が翻訳に関わった「Kubernetesで実践するPlatform Engineering」の発売を記念した販促登壇でしたが、原著者さんが書籍の内容自体について話をされると知っていたので、私はPlatform Engineeringという分野に関する自分なりの考えや経験を共有させていただく内容にしました。Kubernetesで実践する Platform Engineering作者:Mauricio Salatino翔泳社Amazon2つの異なるイベントでの発表同日に性質の異なる2つのイベントで話をさせていただきました。Developers Summitでは「インフラをつくるとはどういうことなのか、あるいはPlatform Engineeringについて」というタイトルで、幅広い技術者の方々に向けてPlatform Engineeringの基本的な考え方から実践的なアプローチまでをお話ししました。 speakerdeck.com一方、PFEM特別回では「Platform Engineeringは自由のめまい - 技術の選択における不確実性と向き合う」というテーマで、より専門的な視点からPlatform Engineeringの課題や可能性について話をしました。ただ、この回は資料作りや登壇などの疲れもピークに達していて、本来伝えたかったことと違う説明をしてしまった部分もあったように思います。 speakerdeck.com翻訳作業から得た気づき今回の発表の背景には、「Kubernetesで実践するPlatform Engineering」の翻訳作業があります。2025年2月19日に翔泳社から発売されるこの本は、\"Platform Engineering on Kubernetes\"の日本語翻訳版で、3-shake の同僚と一緒に取り組んだプロジェクトです。翻訳作業を通じて、Platform Engineeringの課題や可能性について考える機会を多く得ることができました。原著者のsalaboyさんのハンズオンや過去の発表資料、記事を読む中で、Platform Engineeringに対する彼の考え方を学ばせていただきました。実際に一緒に登壇する機会もいただき、私の拙い英会話力にも関わらず温かく接していただいたことも貴重な経験でした。登壇から学んだこと今回の登壇準備と実践を通じて、技術共有における重要な気づきがありました。最も重要だと感じたのは、聴衆のバックグラウンドに合わせて内容を適切に調整することです。Developers SummitとPFEM特別回では、参加者層が大きく異なりました。Developers Summitでは、DevOpsやPlatform Engineeringに詳しくない参加者が多く、日常的な開発における具体的な問題点から入り、それをPlatform Engineeringの文脈で捉え直すことで基礎的な理解を促しました。一方、PFEM特別回では参加者との間に共通認識があったため、より実践的な課題や技術的解決策について深く掘り下げることができました。この違いは技術資料の作成にも影響しました。資料作成では、「知的な発見」と「理解するためのコスト」のバランスが重要です。知的な発見とは「なるほど、そういう考え方があったのか」という新しい視点を得られる瞬間ですが、その発見に至るまでの説明が複雑すぎると理解へのコストが大きくなりすぎてしまいます。多くの技術プレゼンテーションでは既知の問題とその解決策を列挙することに終始しがちですが、それだけでは予想外の学びには至りません。予想外の学びこそが、聴衆の心に残る知的な発見として認知されやすいのです。ここで重要なのは、単に「よくある課題とその解決策」を並べるだけでなく、「明確には意識していなかったけれど、言われてみれば確かにそうだった」という新たな気づきを提供することです。例えば、日々の開発で感じている不便さを Platform Engineering の文脈で捉え直すことで、それが個人の問題ではなく構造的な課題だったと気づく瞬間を作り出せます。かといって基礎的な前提ばかりでは、聴衆にとって新しい気づきが得られません。Developers Summitでは基礎と新知見のバランスを重視し、PFEM特別回では基礎的な説明を最小限に抑え、より深い技術的な議論に時間を割きました。それ以外の「イライラ」「焦り」「困惑」といった感情は、むしろ読者の集中力を削ぎ、本質的な学びを妨げてしまう。技術資料は、共感と発見のポジティブな体験に徹するべきなのだ。確かに、高度な実装や複雑な概念を詰め込んだ資料を作ることは可能だ。しかし、そのような難解な内容は、読者の理解を遠ざけ、結果として伝えたい本質が埋もれてしまう。読者の多くがこのような否定的な感情を抱く資料は、作成者の自己満足に過ぎないと言えるでしょう。2025年ならではの発見として、Xのアルゴリズム変更により画像が優先表示されるようになった現在、印象に残るスライドを含めることが効果的です。複雑な概念を一枚の図で表現することで、SNS上での共有や議論が促進され、発表後もコミュニティでの対話が継続する可能性が高まります。また、Platform Engineeringという新しい分野では、技術コミュニティにおける「共通言語」の重要性も実感しました。Developers Summitではキーとなる概念を具体例と共に丁寧に説明し、PFEM特別回では既存の共通言語を活用してより専門的な議論を展開しました。知識を一方的に伝えるのではなく、参加者との対話を通じて互いに学び合える場を作ることを心がけ、翻訳者兼登壇者としての過剰な発言は控えました。この経験を通じて、技術を伝えることは単なる知識の転送ではなく、聴衆のコンテキストに寄り添いながら対話を生み出すプロセスだと実感しました。イベントの性質や参加者層によって求められる内容や深さが異なることを学び、今後もこの気づきを活かしながら効果的な技術共有を目指していきます。おわりに2つのイベントでの発表資料は異なる切り口で作成しましたが、どちらも力を入れて準備させていただきました。より詳細な内容についてはぜひ資料をご覧いただければと思います。また、完全版については機会があればお話させていただきたいと考えていますので、ご興味がありましたらぜひご依頼ください。最後に、この経験を通じて得られた知見を今後の活動にも活かしていきたいと考えています。ご清聴いただいた皆様、そして貴重な機会を提供してくださった関係者の皆様に心より感謝申し上げます。","isoDate":"2025-02-13T22:11:27.000Z","dateMiliSeconds":1739484687000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"インフラをつくるとはどういうことなのか、 あるいはPlatform Engineeringについて","link":"https://speakerdeck.com/nwiizo/inhurawotukurutohadouiukotonanoka-aruihaplatform-engineeringnituite","contentSnippet":"2025年02月13日 Developers Summit 2025 13-E-4 にて「インフラをつくるとはどういうことなのか、 あるいはPlatform Engineeringについて - Platform Engineeringの効果的な基盤構築のアプローチ」というタイトルで登壇します。同日にPFEM特別回 でも登壇するのですが資料頑張って作ったのでそっちも読んでください。完全版は機会があればお話するので依頼してください。\r\rイベント名:  Developers Summit 2025\r\r公式URL: https://event.shoeisha.jp/devsumi/20250213\r\rセッションURL: https://event.shoeisha.jp/devsumi/20250213/session/5546\r\r登壇ブログ: https://syu-m-5151.hatenablog.com/entry/2025/02/14/071127","isoDate":"2025-02-13T05:00:00.000Z","dateMiliSeconds":1739422800000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Platform Engineeringは自由のめまい ","link":"https://speakerdeck.com/nwiizo/platform-engineeringhazi-you-nomemai","contentSnippet":"2025年02月13日 Kubernetesで実践するPlatform Engineering発売記念！ PFEM特別回にて「Platform Engineeringは自由のめまい - 技術の選択における不確実性と向き合う」というタイトルで登壇します。同日にDevelopers Summit 2025 でも登壇したのですが資料頑張って作ったのでそっちも読んでください。\r\rイベント名: Kubernetesで実践するPlatform Engineering発売記念！ PFEM特別回\r\r公式URL: https://platformengineering.connpass.com/event/342670/\r\r登壇ブログ: https://syu-m-5151.hatenablog.com/entry/2025/02/14/071127","isoDate":"2025-02-12T05:00:00.000Z","dateMiliSeconds":1739336400000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Neovimで始めるGitHub Copilot - copilot.lua による Language Server の設定方法","link":"https://syu-m-5151.hatenablog.com/entry/2025/02/11/183337","contentSnippet":"github.blogこの設定は一時的なものであり、LSPのインストーラーが対応したらそちらで対応してください。github.comはじめに2025年2月10日、GitHubはCopilot Language Server SDKを公開しました。これは、エディタやIDEがLanguage Server Protocol（LSP）を通じてGitHub Copilotと連携できるものです。このリリースは、開発者がより柔軟にCopilotを利用できるようになる重要な一歩です。今までGitHub CopilotはVS Code、Visual Studio、JetBrains IDEs、Vim/Neovim、そして最近ではXcodeでも利用可能でしたが、これらのエディタすべてがCopilot Language Serverを使用して実装されていました。GitHubは開発者の選択肢を重視し、好みのエディタでCopilotを使用できるようにすることを目指しているみたいです。Copilotの進化NeovimでのCopilot利用は、以前はgithub/copilot.vimを通じて行われていました。このVimscriptベースのプラグインは、多くの開発者に利用されてきた公式の実装です。その後、Lua APIを活用したzbirenbaum/copilot.luaが登場しましたが、これも内部的にはcopilot.vimを通じてGitHub Copilotと通信を行っていました。このアーキテクチャでは、copilot.luaがNeovimのモダンなLua APIを活用した柔軟なインターフェースを提供し、バックエンドではcopilot.vimが実際のCopilotサービスとの通信を担当するという二層構造になっていました。そして今回のLanguage Server SDKの公開により、エディタとCopilotの連携方法が標準化され、直接Language Server Protocolを介してCopilotと通信できるようになりました。これにより、中間レイヤーが不要になり、より効率的で安定した実装が可能になりました。前提条件Neovim 0.8.0以上Node.js 18.x以上GitHubアカウント（Copilotのサブスクリプション）インストール手順1. Copilot Language Serverのインストールまず、Neovimの設定ディレクトリにCopilot用のディレクトリを作成し、Language Serverをインストールします。# Copilot用ディレクトリの作成mkdir -p ~/.config/nvim/copilot/# Language Serverのインストールnpm install @github/copilot-language-server -g --prefix ~/.config/nvim/copilot/# 実行権限の付与chmod +x ~/.config/nvim/copilot/bin/copilot-language-server2. Neovimプラグインのインストールlazy.nvimを使用している場合、以下の設定を~/.config/nvim/lua/plugins/copilot.luaに追加します。return {  \"zbirenbaum/copilot.lua\",  lazy = false,  priority = 1000,  config = function()    require(\"copilot\").setup {      suggestion = { enabled = false },      panel = { enabled = false },      server_opts_overrides = {        trace = \"verbose\",        cmd = {          vim.fn.expand(\"~/.config/nvim/copilot/bin/copilot-language-server\"),          \"--stdio\"        },        settings = {          advanced = {            listCount = 10,            inlineSuggestCount = 3,          },        },      },      filetypes = {        yaml = true,        markdown = true,        help = false,        gitcommit = true,        gitrebase = true,        hgcommit = false,        svn = false,        cvs = false,        [\".\"] = false,        [\"*\"] = true,      },    }  end,}3. 認証設定Neovimを起動後、以下のコマンドで認証を行います。:Copilot authブラウザが開き、GitHubアカウントでの認証が求められます。認証が完了すると、Copilotが使用可能になります。設定の説明設定の主要なポイントを解説します。この設定は私の設定ファイルなので自由に設定してください。suggestionとpanelenabled = false: デフォルトのサジェスト機能を無効化していますserver_opts_overridescmd: インストールしたLanguage Serverのパスと起動オプションを指定vim.fn.expand(\"~/.config/nvim/copilot/bin/copilot-language-server\"): Language Serverの実行ファイルのパスを指定。vim.fn.expand()関数を使用して~をホームディレクトリに展開\"--stdio\": Language Serverが標準入出力（stdio）を使用してNeovimと通信することを指定するオプションsettings.advanced:   - settings.advanced:listCount: 候補の表示数（10個）inlineSuggestCount: インラインサジェストの数（3個）filetypes各ファイルタイプでのCopilotの有効/無効を設定[\"*\"] = true: デフォルトですべてのファイルタイプで有効トラブルシューティングLanguage Serverが見つからない場合Error: Language server is not installed or not executableパスが正しいか確認実行権限が付与されているか確認chmod +xコマンドで実行権限を付与認証エラーの場合:Copilot authを再実行GitHubアカウントのサブスクリプション状態を確認まとめGitHub Copilot Language Server SDKの公開により、Neovimでより直接的にCopilotを利用できるようになりました。これまでのcopilot.vimを経由する方式から、直接Language Server Protocolを使用する方式への移行により、より効率的で保守性の高い実装が可能になりました。新しいSDKはnpmjs.comで公開されており、誰でも利用可能です。この変更により、エディタ開発者はより簡単にCopilotを統合でき、ユーザーはより安定した開発体験を得られるようになります。また、この方法は本来であれば不要でありlspconfigにコントリビューションすればよい()。github.com参考リンクGitHub Copilot Language Server SDK announcementCopilot.lua DocumentationLanguage Server Protocol SpecificationGitHub Copilot.vim","isoDate":"2025-02-11T09:33:37.000Z","dateMiliSeconds":1739266417000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"滅びゆく「なぜ？」と「どうして？」の学びをどう受け止めればよいのか？新人エンジニアの指導で感じる生成AI時代の指導の難しさ","link":"https://syu-m-5151.hatenablog.com/entry/2025/02/04/203205","contentSnippet":"anond.hatelabo.jpこの記事を読み、その内容は学生だけでなく、ソフトウェアエンジニアの教育にも適用できると考えました。以下、ソフトウェアエンジニア（以降、技術者と表記）の教育について、私見を述べさせていただきます。はじめに新人エンジニアや学生のOJTやハンズオン研修を担当する中で日々実感することがあります。生成AIの台頭により従来の指導方法が大きく揺らいでいるという現実です。特に、表面的な成果物の質と実際の理解度の乖離が、技術者教育における新たな課題として浮き彫りになってきています。この変化は、技術教育に関わる私たち全員に、新たな挑戦と機会をもたらしています。生成AIは確かに技術教育の在り方を根本から問い直すきっかけとなりましたが、それは同時に、より本質的な技術力の育成について考え直す機会でもあります。技術の進化に伴う変化は不可避ですが、その中で私たちにできることは、この変化を前向きに捉え、新しい時代にふさわしい技術教育の形を模索していくことではないでしょうか。このような問題意識のもと、本稿では2025年に向けた技術者教育の新しいアプローチについて考察していきます。変化する学習の風景これまでの技術習得プロセスには、ある種の必然性がありました。ライブラリの使い方で躓き、設計パターンの意図を理解できず悩み、そしてそれらを一つずつ克服していく。この過程で、指導者は学習者の理解度を正確に把握し、適切なサポートを提供することができました。しかし、生成AIの登場により、この学習の構図が大きく変容しています。ある日の出来事が、この変化を象徴的に表していました。新人エンジニアに依頼した簡単なAPIの実装が、驚くほど短期間で、かつ高品質なコードとして提出されたのです。しかし、コードレビューの場での会話は、次のような展開となりました。「このミドルウェアの実装パターンを選択した理由は？」「はい...Copilotが提案したものをそのまま採用しました」「例外処理の設計思想については？」「申し訳ありません。その部分はAIの出力そのままで...」更に印象的だったのは、実装中のトラブルシューティングでの出来事でした。学生がハンズオン研修で詰まっていたため、私がエラーメッセージを確認して原因を特定し、問題のファイルを開こうとした瞬間、そのファイルは既にCopilotによって修正されました。本来であれば、エラーの原因を一緒に探り、解決策を考えることで、貴重な学びの機会となるはずでした。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazon理解を伴わない実装力技術者として、私自身も生成AIを積極的に活用しています。それは現代のソフトウェア開発において、もはや必須のスキルといえるでしょう。しかし、「理解を伴わない実装力」という新たな現象が、技術者教育に大きな課題を投げかけています。最近経験した出来事が、この課題を端的に表していました。新人エンジニアが実装したAPIは、一見すると申し分のない出来栄えでした。しかし、設計の意図を問うと「ChatGPTやCopilotの提案をそのまま採用した」という答えが返ってきます。エラーが発生した際も、その原因を一緒に探ろうとした矢先、Copilotが自動的に修正を施してしまう。こうした状況は、技術者としての本質的な成長機会を失わせる危険性をはらんでいます。具体的な例として、複雑なマイクロサービスアーキテクチャを構築できるのに、RESTful APIの基本原則が説明できない。網羅的なユニットテストを実装できるのに、テストピラミッドの考え方が理解できていない。Kubernetesのマニフェストが書けるのに、コンテナ化の利点を説明できない。このような状況が増えています。しかし、ここで注目すべきは「理解を伴わない実装力」にも異なるタイプが存在することです。生成AIに依存した実装を行うエンジニアと、知識はあるが実践との紐付けが発展途上のエンジニアです。前者は、高度なアーキテクチャのコードを書けるように見えても、その設計思想を説明できず、エラーが発生すると即座にAIに解決を委ねます。コードレビューでの「なぜ」という問いに対して、「AIが提案したから」や「はぁ？」という支離滅裂な回答に終始し、自身の実装に対する責任感や当事者意識が希薄です。一方後者は、デザインパターンやアーキテクチャの理論的理解はあるものの、それを実践に活かしきれていない段階にいます。しかし、レビューで指摘されると「あ、確かにそうですね」と納得し、エラーに直面しても自分なりの仮説を立てて解決を試みます。不完全でも自分の言葉で説明しようとする姿勢があり、試行錯誤を重ねながら、徐々に知識と実践を紐づけていっています。これまでの教育現場では、学習者の成長過程が自然と把握できていました。エラーメッセージと格闘し、設計パターンの意図を咀嚼し、少しずつ理解を深めていく。その過程で、「基礎概念は理解できている」「応用に課題がある」といった具合に、理解度の段階が明確だったのです。しかし今や、生成AIの支援により、理解度と実装力の相関が著しく弱まっています。特に前者のようなタイプの場合、表面的な成果物の品質だけでは、技術力を測ることが困難になっているのです。後者のような「知識はあるが実践が追いついていない」エンジニアの場合、時間とともに着実な成長が期待できますが、AIに依存した実装では、その成長機会自体が失われてしまう危険性があります。技術者教育の本質を見つめ直す私たちが目指すべきは、単なる「実装力」の向上ではありません。なぜその技術が必要とされるのか、どのような文脈で使用されるべきか、実装による影響をどう評価するか。そういった本質的な理解力を持つエンジニアの育成こそが重要です。「動くコード」を書けることは、技術者としての第一歩に過ぎません。技術力とは、技術選択の理由を説明できること、その技術がもたらす長期的な影響を予測できること、そしてプロジェクト全体における個々の実装の位置づけを理解できることです。これは単にコードを書けるということとは本質的に異なる能力です。syu-m-5151.hatenablog.comしかし、生成AIの存在は、この「理解のプロセス」を大きく変えつつあります。AIの出力を適切に編集することで「完成」にたどり着けてしまう現状は、技術習得における重要な学びの機会を奪っているかもしれません。エラーとの格闘、設計の試行錯誤、レビューでの指摘と修正—これらの経験は、表面的には非効率に見えても、実は技術者としての成長に不可欠なプロセスなのです。さらに重要なのは、技術の進化に対する適応力です。特定の実装パターンやツールの使い方を覚えることよりも、新しい技術が登場した際にその本質を理解し、適切に評価できる力を養うことが重要です。この適応力は、深い理解と経験に裏打ちされた「考える力」からしか生まれません。syu-m-5151.hatenablog.comこれからの技術者教育2025年に向けたエンジニア育成の新しいアプローチ1. 生成AIとの対話力を含めた包括的な技術教育カリキュラムの構築生成AIを効果的に活用するスキルそのものを技術教育の重要な要素として位置づける必要があります。AIへの適切なプロンプト作成能力はもはやエンジニアの基礎スキルとして不可欠です。しかし、ここで重要なのは単にAIに答えを求めることではありません。具体的には、AIに実装方針を提案させる際も、その根拠となる設計原則や参考文献を確認し、実装の背景にある理論や概念について理解を深めていく必要があります。さらに、特定の実装パターンのメリット・デメリットを比較検討させることで、技術選択の判断力を養うことができます。また、エラーが発生した際は、その原因と対処法についての理解を深めるための質問を重ねることで、問題解決力を育てていきます。つまり、AIを「答えを得るためのツール」ではなく、「理解を深めるための対話相手」として活用する姿勢が求められます。生成AIとの対話を通じて、技術の本質的な理解を深める習慣を身につけることが重要です。また、AIが出力したコードやドキュメントを適切に評価・検証する力も重要な要素となっています。プロンプトエンジニアリングの技術に加えて、AIと人間それぞれの得意分野を理解し、適切な役割分担ができる判断力が必要です。特に、AIの出力を鵜呑みにせず、常に批判的に検証し、その背景にある原理原則を理解しようとする姿勢を育むことが重要です。2. 実装スキルから設計思考力へのフォーカスシフトコーディングスキルの習得以上に、システム設計の原則や思想を理解することが重要になってきています。実装の詳細は生成AIに任せられる時代だからこそ、私たちはより本質的な設計思考力の育成に注力すべきです。システム設計において重要なのは、ビジネス要件を技術要件に適切に変換する力です。スケーラビリティ、可用性、保守性といった非機能要件をどのように満たすのか。開発効率と運用コストのバランスをどう取るのか。こうしたトレードオフを適切に判断し、プロジェクト全体の成功に導く力が、これからのエンジニアには求められます。個々の実装の詳細は生成AIにある程度任せられる一方で、システム全体を俯瞰する力は2025年においては人間にしか培えない能力なのです。この力を育むためには、実際のプロジェクトの中で判断が必要な場面に直面させ、その経験を積ませることが効果的です。例えば、新しい機能追加の要件を受けた際に、既存システムへの影響範囲を分析させたり、将来の拡張性を考慮した設計を検討させたりすることで、システム全体を見渡す視点を養うことができます。3. プロセスと思考を重視した評価方法への転換技術者の評価においても、成果物の完成度だけでなく、そこに至るまでの思考プロセスを重視する必要があります。なぜその設計を選択したのか、どのような代替案を検討したのか、想定されるリスクにどう対処するのか。こうした意思決定の過程とその根拠を、自分の言葉で説明できる力が極めて重要です。特に注目すべきは、長期的な視点での判断力です。目の前の実装だけでなく、その選択が将来的なシステムの保守性や拡張性にどのような影響を与えるのか。技術負債との向き合い方や、チーム全体での知識共有の方法など、持続可能な開発を実現するための視点も評価の重要な要素となります。この文脈で懸念されるのが、表面的な成果や「スムーズな進捗」を演出しようとする風潮です。これは特定の層に限った問題ではなく、現代の開発環境が生み出す構造的な課題といえます。重要なのは、そうした見せかけの生産性を求めない組織文化の醸成です。真摯な試行錯誤やチャレンジを認め、失敗から学ぶことを奨励する環境づくりこそが、本質的な技術力の向上につながります。結局のところ、私たちが目指すべきは、表面的な実装の速さや完成度ではなく、持続可能な開発を実現するための思考力と判断力を備えたエンジニアの育成なのです。そのためには、短期的な成果だけでなく、プロセスの質を重視する評価体系への転換が不可欠です。これは単なる評価方法の変更ではなく、組織全体で取り組むべき文化的な転換といえるでしょう。おわりに生成AI時代における技術者教育は、まさに過渡期にあります。単純な「できる/できない」の二元論では測れない、技術力をどう育成し、評価していくのか。これは私たち指導者自身にとっても、大きな学びの機会となっています。この課題に対する明確な解答は、業界全体としてもまだ模索段階にあります。しかし、技術教育の在り方を根本から見直し、新しい時代に適応した指導方法を確立していく必要性は明らかです。エンジニアの評価や育成に関する従来の常識は、生成AIの台頭により大きく揺らいでいます。多くの組織や教育機関が同様の課題に直面している中、重要なのは個々の取り組みや知見を共有し、業界全体として解決策を模索していく姿勢です。エンジニア育成は組織の壁を超えた共通の課題であり、オープンな対話と試行錯誤を通じてこそ、新しい時代にふさわしい技術教育の形が見えてくるのではないでしょうか。","isoDate":"2025-02-04T11:32:05.000Z","dateMiliSeconds":1738668725000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"技術記事のレベル低下は誰のため？ - 楽して学べる幻想と戦うためにもしくはバズるという快楽に対する防衛術","link":"https://syu-m-5151.hatenablog.com/entry/2025/02/04/094857","contentSnippet":"はじめにバズっている技術ブログやSNSの投稿を見ていて「今さらこんな基本的なTipsが数千いいねされるのか」と感じることはありませんか。「とりあえずDockerを使ってみよう」「React超入門」といった手取り足取り系の投稿がバズり続け、タイムラインには毎日のように初心者向けコンテンツが流れています。同じような入門記事が異なる執筆者によって際限なく生み出されるこの状況は、技術情報の共有における興味深い現象と言えるでしょう。では、なぜこのような現象が続いているのでしょうか。「学習」に対する一般的な認識多くの普通の人にとって「学習」は快適な体験であるべきだという認識があります。自分が理解できる範囲の内容を読み、既存の知識と結びつけて徐々に理解を深めていく。分からないことがあれば基礎的な内容に立ち返る。実際、人間の脳は安全な環境で学習することを好む傾向にあり、多くの人は「コンフォートゾーン」の中で学習を進めていきたいという自然な欲求を持っています。これは特に新しい技術やプログラミングのような複雑な分野においても顕著に表れます。このような学習パターンは、人間の認知的な特性とも合致しています。新しい情報は、既存の知識体系の中に無理なく組み込めるときに最も効果的に定着するからです。そのため、急激な学習曲線や理解が追いつかない内容は、多くの人にとってストレス要因となり、学習意欲を低下させる原因となり得ます。自己啓発の教科書　禁欲主義からアドラー、引き寄せの法則まで作者:アナ・カタリーナ・シャフナー日経ナショナル ジオグラフィックAmazon現実の技術学習との乖離しかし実際の技術習得のプロセスはもっと異なるものです。理解できない内容を何度も読み返し、エラーと格闘しながら少しずつ理解を積み重ねていく必要があります。分からない用語を調べながら文脈を理解していくという地道な作業が求められます。時には数時間かけてもエラーが解決できず、徹底的にドキュメントを読み込んだり、ソースコードを追いかけたりする忍耐も必要です。このような現実の学習プロセスは、多くの人が求める「快適な学習体験」とは大きくかけ離れています。つまり、技術習得には「コンフォートゾーン」を意図的に離れ、混乱や不確実性と向き合う覚悟が必要なのです。このギャップこそが「お手軽入門記事」が無限に生産され続ける根本的な理由の一つと言えるでしょう。人々は常により優しい入り口、より分かりやすい説明を求め続けているのです。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazon需要と供給の関係バズっている技術ブログやSNSでは特徴的な循環が生まれています。チュートリアル的なコンテンツへの大きな需要があり、入門記事の方が読者数やフォロワーを獲得しやすい傾向にあります。複雑な技術解説や深い考察よりも、「とりあえず動くものを作る」といった実践的なコンテンツの方が、圧倒的に高いエンゲージメントを得られるのです。このような状況下では、執筆者もまた市場原理に従わざるを得ません。高度な技術記事を書いても読者が少なければ、自然と入門コンテンツにシフトしていくでしょう。結果として、さらに多くの基礎的なハウツー記事が生み出され、SNSのタイムラインを埋め尽くしていく循環が続いています。これは技術情報の生態系における一種の「自然淘汰」とも言えるかもしれません。上級者向けコンテンツの価値と課題上級者向けコンテンツには確かに大きな価値があります。業界全体の技術力向上に貢献し、特定の問題に対する深い洞察を共有することで、エンジニアとしてのキャリアアップにも役立ちます。しかしこれらのコンテンツは必然的に読者層が限定されます。前提知識が必要で理解に時間がかかり、即座に実践できない場合が多いためです。視点の多様性と技術記事の価値重要な点として、技術記事の「難易度」は極めて相対的です。ある人にとっての入門記事が、別の人にとっては上級者向けのコンテンツとなるという状況は珍しくありません。私たちは往々にして自分の知識レベルをベースラインとして記事の価値を判断しがちですが、技術学習においてはそれぞれが異なる文脈や背景を持っているのです。この認識は、技術記事を書く際の重要な視点となります。プラットフォームと個人の戦略技術記事プラットフォームにはトレンドとは別に普遍的な価値を持つ記事が確実に存在します。分散システムの設計原則やスケーラビリティの考察、セキュリティアーキテクチャの分析など、時代を超えて参照される価値のある記事です。しかしそれらの記事はトレンド入りしづらく、時として埋もれてしまいます。質の高い技術記事が、読者の多様な技術レベルや興味に応じて適切に届けられる仕組みづくりがプラットフォーム側には求められています。一方で個人の執筆戦略としては、より包括的なアプローチが有効です。時にはトレンドに乗った入門記事を書きつつ、自分の技術的な知見や経験を活かした深い考察も定期的に発信していく。理想的な技術ブログの運営には、読者の多様性を意識したバランスが重要です。入門的なコンテンツから実践的な応用記事、さらにはアーキテクチャ設計や性能改善といった本質的な議論まで、幅広い層に価値を提供することができます。このような多層的なアプローチは、技術コミュニティ全体の成長に貢献します。それぞれの記事が、異なる段階にいる読者にとって「次のステップ」となる可能性を持っているからです。執筆者は自身の経験を共有しながら、同時に読者それぞれの文脈での学びをサポートすることができるのです。Science Fictions　あなたが知らない科学の真実作者:スチュアート・リッチーダイヤモンド社Amazonまとめ表層的な入門記事が無限に存在する現状は決して悪いことではありません。むしろそれは多くのエンジニアが学習意欲を持っている証であり、業界の健全性を示すものとも言えます。執筆者としては読者の「コンフォートゾーン」を少しずつ広げていけるような段階的な難易度設定と丁寧な説明を心がけることが重要でしょう。そうすることで読者の成長を支援しながら、技術コミュニティ全体の発展に貢献できるはずです。アメリカは自己啓発本でできている作者:尾崎俊介平凡社Amazon","isoDate":"2025-02-04T00:48:57.000Z","dateMiliSeconds":1738630137000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"WebAssembly を開発する為にTrunkビルドツールを試してみました。","link":"https://syu-m-5151.hatenablog.com/entry/2025/02/01/120804","contentSnippet":"はじめにWebAssemblyの進化により、RustでWebアプリケーションを構築する機会が増えています。特にYewフレームワークは、React風の使い勝手とRustの堅牢性を組み合わせた開発が可能です。本記事では、Yewアプリケーション開発をスムーズにするビルドツールTrunkについて、セットアップから実践的なテクニックまで解説します。yew.rsTrunkとはTrunkは、WebAssemblyアプリケーションに特化したビルドツールです。そして、以下のような特徴を持ちます。ホットリロードによる高速な開発体験アセット管理の自動化（画像、CSS、その他静的ファイル）最小限の設定で開発環境の構築が可能プロダクションビルドの最適化機能trunkrs.dev環境構築まず、必要なツールをインストールします：# WebAssemblyターゲットの追加rustup target add wasm32-unknown-unknown# Trunkのインストールcargo install trunktrunkrs.devプロジェクトの作成以下のコマンドで新規プロジェクトを作成します：cargo new yew-appcd yew-appCargo.tomlに必要な依存関係を追加：[dependencies]yew = { git = \"https://github.com/yewstack/yew/\", features = [\"csr\"] }yew.rsシンプルなカウンターアプリの実装src/main.rsにカウンターアプリのコードを実装します：use yew::prelude::*;#[function_component(App)]fn app() -> Html {    let counter = use_state(|| 0);    let onclick = {        let counter = counter.clone();        move |_| {            let value = *counter + 1;            counter.set(value);        }    };    html! {        <div>            <button {onclick}>{\"+1\"}</button>            <p>{ *counter }</p>        </div>    }}fn main() {    yew::Renderer::<App>::new().render();}yew.rsHTMLテンプレートの準備index.htmlをプロジェクトルートに作成：<!DOCTYPE html><html>    <head>        <meta charset=\"utf-8\" />        <title>Yew Counter App</title>    </head>    <body></body></html>開発サーバーの設定と起動Trunk.tomlで開発サーバーの設定をカスタマイズできます：[serve]# 開発サーバーのアドレスaddress = \"127.0.0.1\"# ポート番号port = 8080# アセットディレクトリassets = [\"public\"]# プロキシ設定（APIサーバーなど）[[proxy]]backend = \"http://localhost:3000/api/\"開発サーバーを起動：trunk serve --openこれでhttp://localhost:8080にアプリケーションが立ち上がります。アセット管理のベストプラクティス静的ファイルはpublicディレクトリで管理します：public/  ├── images/      # 画像ファイル  ├── styles/      # CSSファイル  ├── fonts/       # フォントファイル  └── favicon.ico  # ファビコンtrunkrs.devプロダクションビルドの最適化本番環境向けのビルドでは、以下の最適化が可能です：# リリースビルドtrunk build --release# WebAssemblyコードの最適化trunk build --release --filehashデバッグとトラブルシューティング開発中によくあるトラブルの対処法：ビルドエラー時はtrunk cleanでキャッシュをクリアアセットが反映されない場合はtrunk serve --watchで監視を強化WebAssemblyのデバッグには開発者ツールのConsoleを活用(フロントエンド開発初心者で学びが多かった⋯)おわりにTrunkを活用することで、Yewアプリケーションの開発体験が大幅に改善されます。特にホットリロードとアセット管理の自動化は、開発効率を向上させる重要な機能です。参考リンクTrunk GitHubYew GitHubWebAssembly","isoDate":"2025-02-01T03:08:04.000Z","dateMiliSeconds":1738379284000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"RustとYewでポモドーロタイマーを作ってみた","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/29/120446","contentSnippet":"はじめにイベントで定期的に登壇をしていて休日出勤したのに消化しきれなかった代休が余っていたので、3連休爆誕させて以前から興味のあったWebAssemblyの学習に時間を使ってみることにしました(いくつか本も読んだのでいつか紹介します。)。「とりあえず何か作ってみる」のが一番の近道だと考え、日々の私生活でも使えそうなポモドーロタイマーを実装することにしました。WebAssemblyのエコシステムを調べていく中で、RustのYewというフレームワークが目に留まりました。ReactライクなAPIでWebAssemblyアプリケーションが作れるとのことで、ちょっと開発することにしました。github.com使用技術の選定理由Rust：WebAssemblyのための優れたツールチェーンを持っており、学習コストは高めですが、型安全性と高いパフォーマンスが魅力でしたYew：ReactライクなAPIで、コンポーネントベースの開発が可能。フロントエンド開発者にとって親しみやすい設計になっていますTrunk：ビルドツールとして採用。trunk serveだけで開発サーバーが立ち上がる手軽さが気に入りました技術スタックRust (v1.75.0)Yew (v0.21)WebAssemblyTrunk (Bundler)プロジェクトの概要ポモドーロテクニックは25分の作業時間と5分の休憩を交互に行う時間管理手法です。今回実装したアプリケーションでは、以下の機能を提供します：基本的なタイマー機能25分のカウントダウン開始/停止/リセット制御視覚的なフィードバックタスク管理機能タスクの記録実際の作業時間の追跡完了したタスクの履歴管理データエクスポート機能マークダウン形式での出力クリップボードへのコピー機能実装の詳細プロジェクトのセットアップまず、必要なツールとターゲットをインストールします：rustup target add wasm32-unknown-unknowncargo install trunk主要なデータ構造タスクとタイマーの状態管理のための構造体：#[derive(Clone, Debug)]struct Task {    description: String,    completed_at: DateTime<Local>,    duration: i32,}pub struct PomodoroTimer {    time: i32,    running: bool,    interval: Option<Interval>,    current_task: String,    completed_tasks: Vec<Task>,    initial_time: i32,    markdown_visible: bool,    markdown_content: String,}タイマー機能の実装Yewのコンポーネントシステムを利用して、タイマーの制御を実装しました：fn update(&mut self, ctx: &Context<Self>, msg: Self::Message) -> bool {    match msg {        Msg::Start => {            if !self.running {                let link = ctx.link().clone();                self.interval = Some(Interval::new(1000, move || {                    link.send_message(Msg::Tick);                }));                self.running = true;            }            true        }        // 他のメッセージハンドラ...    }}クリップボード機能の実装WebAssemblyからブラウザのクリップボードAPIを利用する実装：Msg::CopyToClipboard => {    if let Some(window) = window() {        let navigator = window.navigator();        let clipboard = navigator.clipboard();        let _ = clipboard.write_text(&self.markdown_content);    }    true}開発で直面した課題と解決策WebAssemblyとブラウザAPIの連携課題：クリップボード機能の実装で型の不一致が発生解決：web-sysクレートの適切な機能を有効化し、型の変換を正しく処理状態管理とライフタイム課題：コンポーネントの状態管理でライフタイムエラーが発生解決：use_stateとuse_mut_refを適切に使い分けて実装セットアップと実行方法プロジェクトの作成：cargo new --lib yew-pomodorocd yew-pomodoro依存関係の追加（Cargo.toml）：[dependencies]yew = { version = \"0.21\", features = [\"csr\"] }gloo-timers = \"0.3\"web-sys = { version = \"0.3.64\", features = [\"console\", \"HtmlInputElement\", \"Window\", \"Navigator\", \"Clipboard\"] }wasm-bindgen = \"0.2\"chrono = \"0.4\"アプリケーションの実行：trunk serve開発を通じて学んだことWebAssemblyの基本概念JavaScriptとの連携方法パフォーマンスの最適化ポイントRustの特徴的な機能所有権システム型安全性の恩恵コンパイル時のエラーチェックの強力さフロントエンド開発での新しい視点パフォーマンスを意識したコンポーネント設計WebAssemblyならではの制約と利点所感代休を使って新しい技術に触れる時間が作れたのは、とても良い経験になりました。特に、JavaScriptで書いているような処理をRustで書き直してみることで、言語の特性や設計の違いについて深く考える機会になりました。WebAssemblyは確かにまだエコシステムが発展途上ですが、Yewのような成熟したフレームワークを使えば、実用的なアプリケーションを比較的スムーズに開発できることが分かりました。ソースコードプロジェクトのソースコードはGitHubで公開しています。コメントや改善案があれば、お気軽にIssueやPull Requestを送ってください。次のステップ今回の学習を通じて、WebAssemblyの可能性を実感できました。次は以下のような発展的な内容に挑戦してみたいと考えています：Rustの非同期処理を活用した機能拡張WebAssemblyのパフォーマンス測定と最適化より大規模なアプリケーションでの実践参考リンクRust公式ドキュメントYewドキュメントRustで始めるWebAssemblyMDN WebAssemblyガイド休暇を使って新しい技術に触れることで、普段の業務にも新しい視点を持ち込めそうです。皆さんも、空き時間を見つけて興味のある技術に触れてみてはいかがでしょうか。読んだ書籍Rustで学ぶWebAssembly――入門からコンポーネントモデルによる開発まで エンジニア選書作者:清水 智公技術評論社AmazonProgramming WebAssembly with Rust: Unified Development for Web, Mobile, and Embedded Applications (English Edition)作者:Hoffman, KevinPragmatic BookshelfAmazon","isoDate":"2025-01-29T03:04:46.000Z","dateMiliSeconds":1738119886000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Site Reliability Engineering on Kubernetes","link":"https://speakerdeck.com/nwiizo/site-reliability-engineering-on-kubernetes","contentSnippet":"2025年01月26日 10:35-11:05（ルーム A）にて「Site Reliability Engineering on Kubernetes」というタイトルで登壇します。\r\rイベント名: SRE Kaigi 2025\r\r公式URL: https://2025.srekaigi.net/\r\rセッションURL: https://fortee.jp/sre-kaigi-2025/proposal/a75769d1-7835-4762-a1f6-508e714c8c8e\r\r登壇ブログ: https://syu-m-5151.hatenablog.com/entry/2025/01/26/005033","isoDate":"2025-01-26T05:00:00.000Z","dateMiliSeconds":1737867600000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"SRE Kaigi 2025 で登壇してきます。 #srekaigi","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/26/005033","contentSnippet":"はじめにnwiizoです。2025年1月26日のSRE Kaigi 2025にて「Site Reliability Engineering on Kubernetes」というタイトルで登壇させていただきます。本イベントは「More SRE !」をテーマに、SREの知見共有と技術者の交流を目的とした技術カンファレンスです。2025.srekaigi.netこの発表資料を作成するきっかけとなったのは、私が翻訳に関わった「Kubernetesで実践する Platform Engineering」（2025年2月19日出版予定）の仕事でした。本書の翻訳作業を通じて、SREとPlatform Engineeringの密接な関係性、そしてKubernetesがこれらを実現する優れた基盤となることを改めて実感しました。Kubernetesで実践する Platform Engineering作者:Mauricio Salatino翔泳社Amazon発表資料 speakerdeck.com発表資料はSpeaker Deckで公開しています。イベントのテーマである「さらにSREを広めよう」に沿って、SREやKubernetesの未経験者でも理解しやすい実装例やアーキテクチャパターン、参考資料を用意しました。紹介したものは一例であり、これだけが唯一の正解ではありません。また、イベントにおける最初の発表なのでSREについての部分も多めに説明しています。こちら、Xでのポストなのでリポストなどしてもらえれば幸いです。👻SRE Kaigi 2025 にて「Site Reliability Engineering on Kubernetes」というタイトルで登壇します。こちら、資料になります。https://t.co/SLoohm83jy#srekaigi #srekaigi_a— nwiizo (@nwiizo) 2025年1月26日   今回の発表内容は、以下のような幅広いトピックをカバーしています：基本的な概念と実装SREの本質：システムの信頼性を制御する技術としてのSREKubernetesにおけるSRE原則の実践方法Cloud Nativeアプローチによる実装戦略具体的な実装手法包括的な可観測性の実現GitOpsを活用した変更管理の自動化と標準化Progressive Deliveryの実装と運用ノウハウインシデント対応と自動復旧の仕組み化最新ツールの活用事例CloudEventsによるイベント基盤の構築Keptn Lifecycle Toolkitを用いた品質管理Argo Rolloutsによるデプロイメント制御Crossplaneを活用したリソース管理の自動化プラットフォームの発展成熟度モデルに基づく段階的な改善開発者の認知負荷軽減に向けた取り組みデータドリブンな運用改善の実現方法手を動かすオススメハンズオン発表内容をより深く理解し、実践的なスキルを身につけるために、以下のハンズオンをお勧めします：github.comCloud Native Days主催のハンズオン教材です。KubernetesやCloud Nativeツールの基本的な使い方から応用まで、段階的に学べます。実際の運用シナリオに基づいた実践的な内容となっていますgithub.comPlatform Engineering on Kubernetesの実践的なガイドです。本書の著者が作成した、実装例とベストプラクティスを含むリポジトリです。一つ一つのコンポーネントを実際に動かしながら、プラットフォームの構築方法を学べます。これらのハンズオンを通じて、セッションで紹介する概念や技術を実際に試してみることをお勧めします。理論と実践を組み合わせることで、より深い理解と実装スキルを得ることができます。また、これらの教材は常にアップデートされているため、最新のベストプラクティスも学ぶことができます。おわりに本セッションは、かなり雑多な内容を30分に詰め込んだ欲張りな構成となっています。これは、現場によって異なるSREの課題や取り組みを幅広く共有したいという思いを反映したものです。特に強調したい点は以下の3つです：SREは単なるツールの導入ではなく、組織が信頼性を制御するための包括的な取り組みであることKubernetesは優れた基盤を提供するが、適切な設計と運用が必要不可欠であること適切なオープンソースツールを組み合わせることで、本格的なSRE実装が可能になることこのセッションが「さらにSREに関わる技術者の活躍の場を増やす」「さらにSREを理解し、興味を持っていただける技術者を増やす」という本イベントの目標に貢献できれば幸いです。セッションは2025年1月26日 10:35-11:05、ルームAで行われます。SREに関わる技術者の方々はもちろん、SREに興味を持ち始めた方々のご参加もお待ちしています。詳細は公式サイトでご確認いただけます。イベントに関する最新情報は、X（旧Twitter）の @srekaigi で発信されていますので、ぜひフォローしてください。多くの方々とSREについての知見を共有できることを楽しみにしています。","isoDate":"2025-01-25T15:50:33.000Z","dateMiliSeconds":1737820233000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"現代システムの三体問題「技術」「組織」「戦略」を巡る戦い - Architecture Modernization の読書感想文","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/21/124130","contentSnippet":"そう、どこなのか知ったら、世界が一枚の地図みたいに小さくなってしまう。どこなのか知らないほうが、世界を広く感じられる。(引用:三体 黒暗森林〈上〉P152)はじめに「Architecture Modernization」は、一見すると整然と並べられた章立てと体系的な解説を持つアーキテクチャ現代化のガイドブックのように見えます。しかし、その内実は現代のソフトウェア開発が抱える混沌とした課題に真正面から向き合い、そこから組織の持続的な競争力を構築するための、書籍です。本書は、アーキテクチャ現代化を単なる技術的な刷新を超えて、組織全体の変革を必要とする戦略的な取り組みとして位置付けています。それは時として、既存の組織構造や慣習との軋轢を生み出し、チームの価値観や働き方の根本的な見直しを迫ることにもなります。著者はそうした困難な課題に対して、EventStorming、Wardley Mapping、Team Topologiesといった手法を、その本質的な価値を深く理解した上で、実践的な知見と共に提示します。手法それぞれは、世の中で広く知られているものばかりですが、本書の真価は、これらの手法を組織の現代化という大きな文脈の中で有機的に結びつけ、包括的なアプローチを形作っている点にあります。どの章も一つの主題に対する深い考察と実践知に裏打ちされており、表面的な解説で済ませることはありません。それでいて、各章は独立した価値を持ちながら、全体として一つの強力な変革の方法論を形作っています。それは、著者がこの混沌とした現代のソフトウェア開発の課題に対して、明確な指針を示そうとする強い意志の表れでもあるのです。learning.oreilly.com現代化の重要性と課題私たちが直面するソフトウェア開発の課題は、年々複雑さを増しています。そしてシステムの複雑性は今後さらに加速度的に増大するでしょう。2024年に見られた生成AIの急速な進展は、技術革新がもたらす変化の速度と規模を如実に示しています。このような状況下で、レガシーシステムの制約は組織の存続を脅かすリスクとなり得ます。一方で、現代的なアーキテクチャは大きな競争優位性をもたらす可能性があります。新興企業の中には、最新のアーキテクチャを採用することで、わずか数ヶ月で大規模なプラットフォームを構築し、急成長を遂げた例も存在します。クラウドネイティブなアーキテクチャの採用により、市場投入までの時間を大幅に短縮し、迅速な価値提供を実現しているのです。しかし、技術革新それ自体が自動的に社会全体や組織の繁栄をもたらすわけではありません。過去1000年の歴史を振り返ると、技術革新の恩恵は往々にして一部の組織や個人に集中し、広く行き渡らないケースが多かったことがわかります。現代のソフトウェア開発においても、技術革新の成果をいかに組織全体で共有し、持続可能な価値創造につなげていくかという課題に向き合う必要があります。技術革新と不平等の1000年史　上作者:ダロン アセモグル,サイモン ジョンソン早川書房Amazon技術革新と不平等の1000年史　下作者:ダロン アセモグル,サイモン ジョンソン早川書房Amazon本書のアプローチ本書の独自性は、技術的な側面だけでなく、組織とビジネスの文脈でアーキテクチャを捉える包括的な視点にあります。特に重要なのは、Better Value Sooner Safer Happier (BVSSH)という概念を通じて、現代化がもたらす多面的な価値を評価するフレームワークを提供している点です。また、本書はDomain-Driven Design、Event Storming、Wardley Mappingなど、実践で検証された手法を効果的に組み合わせながら、組織の現代化を実現するための具体的なアプローチを提供します。特に注目すべきは、コラボレーティブな手法とチームの自律性を重視する現代的なアプローチが、今日のソフトウェア開発の最前線で求められる実践と整合している点です。読み進めていくと、一見すると「知っている」と思っていた概念や手法であっても、それらが体系的に整理され、より深い文脈の中で位置付けられていることに気づかされます。例えば、EventStormingやDDDといった手法については、多くの開発者が知っているものの、それらを組織の変革やビジネス価値の創出と結びつけて理解している人は少ないかもしれません。本書は、これらの「知っているつもりだった」内容に新しい光を当て、より実践的で戦略的な視点を提供してくれます。特筆すべきは、本書が扱う「技術」「組織」「戦略」の3つの柱のうち、「戦略」には技術戦略だけでなく、ビジネス戦略も深く含まれている点です。アーキテクチャの選択がビジネスモデルや市場での競争優位性にどのように影響するのか、という視点は、技術リーダーが経営層と建設的な対話を行う上で非常に有用です。また、本書の独自性は、技術的なベストプラクティスを単に羅列するのではなく、それらを他の文脈の中で捉え直している点にあります。読者は自身の経験を振り返りながら、「あのとき、こういう視点があれば...」という新しい発見を数多く経験することになるでしょう。以下、各章の分析を通じて、本書が提供する実践的な知見と、その現場での適用方法について詳しく見ていきましょう。Architecture Modernization: Socio-technical alignment of software, strategy, and structure (English Edition)作者:Tune, Nick,Perrin, Jean-GeorgesManningAmazon1 What is architecture modernization?第1章「What is architecture modernization?」は アーキテクチャ現代化の本質的な価値とその戦略的重要性を包括的に論じています。この章を通じて著者は アーキテクチャ現代化が単なる技術刷新ではなく ビジネスの競争優位性を確立するための戦略的な活動であることを具体的な事例とともに示しています。特に現代化への投資を躊躇することで発生する負のスパイラルと その打開策としての進化的アプローチの重要性は 実務者として強く共感できる内容です。ソフトウェアファースト第２版　あらゆるビジネスを一変させる最強戦略作者:及川 卓也日経BPAmazonアーキテクチャ現代化の必要性とリスクアーキテクチャ現代化の重要性は、ある大手航空会社の事例によって象徴的に示されています。2022年に発生した数十年前のスケジューリングシステムの障害は、1万4千便以上のフライトのキャンセルを引き起こし、ブランドに甚大なダメージを与えました。このような重大なインシデントは、時代遅れのレガシーアーキテクチャがビジネスリスクであり、競争上の不利益をもたらすことを如実に示しています。ソフトウェアアーキテクチャの基礎 ―エンジニアリングに基づく体系的アプローチ作者:Mark Richards,Neal FordオライリージャパンAmazon一方で、英国のある自動車販売スタートアップは、サーバーレスなどの現代的なアーキテクチャを採用することで、わずか90日でオンライン中古車販売プラットフォームを構築し、英国で最速のユニコーン企業となりました。この成功は、レガシーの制約がない状態で最新のテクノロジーを活用できることの価値を示しています。両社の対比は、現代的なアーキテクチャがもたらす競争優位性を鮮明に示しています。Figure 1.1 The negative cycle of declining architecture health より引用Figure 1.1は アーキテクチャ現代化への投資を先送りすることで発生する負のスパイラルを示しています。システムの健全性が低下し 現代化のコストが増大することで さらに経営層の投資判断が躊躇われるという悪循環です。この問題の深刻さは Adam TornhillとMarkus Borgの研究「Code Red: The Business Impact of Code Quality」によって定量的に示されています。彼らの調査では システムの技術的負債により開発者の時間の最大42%が無駄になっていると指摘しています。arxiv.orgさらに IoTデバイスの急増に象徴されるように システムの複雑性は年々増大しており この問題は今後さらに深刻化すると予想されます。2019年に86億台だったIoTデバイスは 2030年には300億台近くまで増加すると予測されています。このような複雑性の増大は 古いアーキテクチャの欠点と現代的なアーキテクチャの利点をさらに顕著にすると考えられます。learning.oreilly.comアーキテクチャ現代化の本質と価値創造著者は アーキテクチャの現代化を 社会技術的なアプローチとして捉えることの重要性を強調しています。これは NetflixのCTOであったAdrian Cockroftの言葉に端的に表れています。「四半期ごとのリリースしかできない企業は 日次デプロイメントを実現している競合他社に大きく引き離される」という彼の警告は 現代化の遅れが存在的な脅威となりうることを示しています。Netflixは2009年に モノリシックなアーキテクチャから数百のクラウドベースのマイクロサービスへと移行し オンラインストリーミング市場での競争優位性を確立しました。この事例は 確立された企業であっても適切な現代化戦略によって イノベーションのスピードを加速できることを証明しています。Figure 1.3 Better Value Sooner Safer Happier. (Source: Smart et al., Sooner Safer Happier: Antipatterns and Patterns for Business Agility [Portland, OR: IT Revolution 2020]) より引用Figure 1.3で示されるBetter Value Sooner Safer Happier (BVSSH)モデルは アーキテクチャ現代化が組織にもたらす価値を多面的に表現しています。Betterは品質改善による効率化と手戻りの削減 Valueは収益改善や顧客維持率の向上などのビジネス成果 Soonerは学習と価値提供の迅速化 Saferはガバナンス リスク セキュリティ コンプライアンスの確保 Happierは従業員満足度の向上を表します。このモデルは ステークホルダーのニーズをバランスよく考慮し 現代化の効果を包括的に評価するフレームワークとして機能します。独立した価値ストリームの重要性アーキテクチャ現代化の核となる概念が 独立した価値ストリーム (IVS) です。Figure 1.5は IVSの4つの主要特性を示しています。ドメイン整合性は特定のビジネスサブドメインとの整合 成果志向はビジネス成果への貢献 チームの権限委譲はプロダクトと技術の意思決定の自律性 ソフトウェアの疎結合は独立した開発・デプロイの実現を意味します。これらの特性が重要である理由は BVSSHの実現に直結するためです。適切なドメイン境界の設定は ビジネスにおける結合度を低減し 関連する概念をグループ化します。これにより ソフトウェアとチーム間の依存関係が減少し チーム間の調整や待ち時間が最小化されます。結果として 新機能の開発がより迅速になります。成果志向のアプローチは より良い価値の創出につながります。著名なプロダクトマネジメントの専門家であるMarty Caganが指摘するように「エンジニアをコーディングだけに使っているなら その価値の半分しか活用できていない」のです。チームにチューニングされた要件を与えるのではなく 達成すべき成果を示し 解決策の発見を委ねることで エンジニアの創造的な才能を最大限に引き出すことができます。著者は IVSを実現するための重要な手法として EventStorming を提唱しています。Figure 1.7は ドメインエキスパート 開発者 プロダクトマネージャー UXスペシャリストなど多様な関係者が協力してドメイン境界を特定するプロセスを示しています。このコラボレーティブなアプローチは 従来の中央集権的なアーキテクチャ設計からの大きな転換を意味します。多様な参加者の知見を活用することで より質の高いドメイン境界の特定が可能になります。進化的なアプローチとポートフォリオ思考アーキテクチャ現代化は 数年にわたる長期的な取り組みですが 著者は ポートフォリオ駆動の進化的アプローチを提唱しています。これは 現代化を単なる古いシステムの書き換えとしてではなく UX 製品機能、ビジネスプロセス、ドメインモデルを根本的に見直す機会として捉える考え方です。Figure 1.10 Identifying the optimal modernization return on investment per subdomain with the Modernization Strategy Selector より引用Figure 1.10で示される現代化戦略セレクターは 各サブドメインに対する最適な現代化投資を特定し 優先順位付けを行うためのツールです。すべてのサブドメインで同じレベルの投資が必要なわけではなく むしろそれは最高価値の現代化機会の実現を遅らせる原因となります。このツールは 各領域の特性に応じて適切な戦略を選択することを可能にします。Figure 1.11 Architecture modernization is parallel streams of work (not phases) supported by continuous learning and upskilling. より引用著者は 現代化を【発見】【設計】【実装】の3つの並行ストリームとして捉えることを提案しています。Figure 1.11は これらのストリームが相互に影響を与えながら継続的に進化していく様子を示しています。この並行性こそが進化的アプローチを可能にする要因です。あるストリームでの発見が次の四半期の実装に影響を与え 実装での学びが次の設計に反映されるという具合です。特に 継続的な学習とスキル向上を現代化の基盤として位置付けている点は注目に値します。これは チームが新しい考え方や手法を習得し 実践する時間と機会を確保することの重要性を示しています。学習と実践の機会が不足すると 古い思考パターンのまま新しいアーキテクチャを設計してしまい その欠陥が引き継がれるリスクがあります。著者は この進化的なアプローチを支援するために Architecture Modernization Enabling Team (AMET) の設置を推奨しています。AMETは従来のアーキテクチャチームとは異なり 意思決定を行うのではなく 他のチームを支援し 現代化の持続的な改善を促進する役割を担います。これは 現代化のモメンタムを維持し 現代化終了後も持続可能な改善を実現するための重要な施策です。まとめ第1章は アーキテクチャ現代化を包括的な視点で捉え その本質と実践的なアプローチを示しています。とある組織の対比を通じて現代化の重要性を示し BVSSHモデルによって現代化の多面的な価値を明確化しています。IVSという概念を通じて現代化を実現するための具体的な方法論を提供し 進化的アプローチとポートフォリオ思考の重要性を強調することで 現代化を持続可能な取り組みとして位置付けています。本章は 現代のソフトウェア開発組織がアーキテクチャ現代化に取り組む際の 実践的かつ戦略的なガイドラインを提供していると評価できます。アーキテクチャ現代化が 技術的な刷新を超えて 組織の競争力を根本的に強化する戦略的な取り組みであることを 説得力をもって示している点は 特に印象的です。また コラボレーティブな手法とチームの自律性を重視する現代的なアプローチは 今日のソフトウェア開発の最前線で求められる実践と整合しています。2 Preparing for the journey第2章「Preparing for the journey」は アーキテクチャ現代化の旅を始める前に考慮すべき重要な準備と課題について包括的に論じています。著者は 組織の準備状況の評価から新しいアーキテクチャ思考の導入 そしてリーダーシップの重要性に至るまで 現代化への取り組みを成功に導くための具体的なガイダンスを提供しています。リーダーシップの準備著者は まず リーダーシップの準備状況 を評価することの重要性を強調しています。新機能の開発を一時的に減速させてまで現代化に投資する覚悟 レガシーシステムの複雑さと変更の困難さの理解 予期せぬ遅延やコスト増加への対応 資金調達モデルや優先順位付けプロセスの変更への準備など リーダーシップチームが直面する重要な課題を詳細に説明しています。特に重要なのは 学習と能力開発への投資です。著者は 現代化が一時的なワークショップやトレーニングコースではなく 継続的な財務的・時間的投資を必要とすることを強調しています。これは 必要なスキルを持つ人材を大量に雇用することでも解決できない問題です。新しい従業員は会社のドメイン システム 文化を学ぶ必要があり それには数ヶ月を要します。スタッフエンジニア　マネジメントを超えるリーダーシップ作者:Will Larson日経BPAmazon新しいアーキテクチャ思考の導入著者は コンウェイの法則 の重要性を強調しています。システムの設計は それを設計・構築する組織のコミュニケーション構造を反映するという原則です。Figure 2.1は 緩やかに結合されたドメイン境界が緩やかに結合されたソフトウェアアーキテクチャを可能にすることを示しています。これは チームが単一のビジネスサブドメインに整合した単一のコードベースで作業できることを意味します。Figure 2.1 Fast flow requires loosely coupled software architecture, which requires loosely coupled domains. より引用コラボレーティブなアーキテクチャ実践の採用も重要な課題です。著者は イベントストーミングなどの現代的な手法を早期に導入し その受け入れ状況を理解することを推奨しています。これらの手法は 伝統的なトップダウンのアプローチとは大きく異なり あらゆる分野の関係者が協力してドメイン境界を特定し 最適なソリューションを選択します。銀の弾丸及び金槌への警告著者は 「ボルトオン現代化」への警告を発しています。これは 根本的なアーキテクチャ上の課題に取り組まず システムの表面的な部分だけを変更するアプローチです。著者は政府サービスの構築での経験を引用し レガシーシステムやデータベースとの統合が残されたままでは 真の改善が実現できないことを示しています。情報を正しく選択するための認知バイアス事典作者:情報文化研究所フォレスト出版Amazon同様に 構造とプロセスの誤謬にも注意を促しています。組織構造の変更や新しいプロセスの採用だけでは 深い変化なしには大きな改善は望めません。チームワークの促進 製品決定の権限委譲 ビジネス・IT間の壁の解消 資金調達モデルの変更 技術品質への投資など 包括的な変更が必要です。ICEの事例から学ぶ成功要因著者は ICEの現代化事例を通じて 実践的な成功要因を示しています。ICEは ドメイン駆動設計とEventStormingを活用してドメインを理解し ストラングラーパターンを用いた段階的な移行を計画しました。その結果 データ取り込み処理時間の80%削減 新規サービスプロバイダーのオンボーディング時間の大幅短縮 マッチング生産性の5倍向上など 顕著な成果を達成しました。www.iceservices.com重要なのは この成功が技術的な側面だけでなく 社会的な側面への取り組みによって実現されたことです。チームの権限委譲 クロスファンクショナルな協力 製品中心の資金調達モデルへの移行など 組織的な変革が成功の鍵となりました。リーダーシップの多層的な展開最後に著者は あらゆるレベルでのリーダーシップの重要性を強調しています。ビジネス戦略の理解と貢献 現代化戦略の定義 アーキテクチャの設計と進化 組織構造の確立 ビジョンと進捗の伝達など 現代化のリーダーには多くの責任があります。これらの責任は単一のスーパーヒーローや小グループだけでは担えません。著者は Architecture Modernization Enabling Team (AMET) の設置を提案し リーダーシップの育成と支援の具体的な方法を示しています。AMETは 組織全体の現代化能力を高め 持続的な改善を確立することに焦点を当てます。リーダーの仮面――「いちプレーヤー」から「マネジャー」に頭を切り替える思考法作者:安藤 広大ダイヤモンド社Amazonまとめ第2章は 現代化の旅を成功に導くための準備と課題を包括的に論じています。リーダーシップの準備、新しいアーキテクチャ思考の導入、銀の弾丸への警告 そして多層的なリーダーシップの重要性という4つの主要な側面から 具体的なガイダンスを提供しています。特に印象的なのは ICEの事例を通じて これらの原則が実践でどのように機能するかを示している点です。現代化は技術的な変革を超えた組織全体の取り組みであり その成功には包括的な準備と持続的な支援が不可欠であることを 説得力を持って論じています。3 Business objectives第3章「Business objectives」は アーキテクチャ現代化の投資判断とビジネス成果の関係性について包括的に論じています。本章を通じて著者は 設計の選択がビジネスの競争優位性と成長戦略にどのように影響するかを 具体的な事例とともに示しています。この章で議論されている「アーキテクチャ現代化の投資判断とビジネス成果の関係性」は、日本のIT業界ではあまり明示的に語られてこなかった文脈です。日本では技術的負債の解消や保守性の向上といった技術的な観点からの議論が中心で、ビジネスの競争優位性や成長戦略との結びつけは比較的最近になって注目され始めた領域と言えます。日本だとこの本を思い出した。みずほ銀行システム統合、苦闘の19年史　史上最大のITプロジェクト「3度目の正直」作者:日経コンピュータ,山端 宏実,岡部 一詩,中田 敦,大和田 尚孝,谷島 宣之日経BPAmazonビジネス観点からの現代化の必要性著者は現代化投資の判断基準として7つのビジネスシナリオを提示しています。市場におけるスピード競争の激化への対応や ビジネス成長の阻害要因の解消 出口戦略の実現など 経営視点に立った明確な指標が示されています。特に印象的なのは より速く動く競合他社への対応に関する指摘です。成功体験による慣性が イノベーションへの意欲を低下させる一方で 新規参入者は最新技術とアプローチを活用し 大胆なリスクテイクが可能です。この非対称性が大企業にとって脅威となることを著者は警告しています。戦略の要諦 (日本経済新聞出版)作者:リチャード・Ｐ・ルメルト日経BPAmazon金融サービス企業の事例では この課題が具体的に示されています。市場リーダーだった同社は セキュリティと安定性を重視するあまり リスクを回避する文化が定着していました。しかし 新興企業の参入により 優れたユーザー体験を持つサービスが登場し 市場シェアを脅かされる事態となりました。最終的に同社は新CTOを迎え 現代化への投資を決断しましたが その過程では多くの組織的な課題に直面しています。著者は 一度成功した企業が陥りやすい罠も指摘しています。成功体験による慣性は イノベーションへのモチベーションを低下させ 結果として技術的負債の蓄積を加速させます。これは 技術的負債の負のスパイラルと呼ぶべき状況を生み出します。一方で OpenTableの事例は この課題に対する前向きな取り組みを示しています。同社は競合の脅威を早期に認識し 全面的な現代化投資を実行することで 開発生産性の大幅な向上を実現しました。www.opentable.comUXと内部プロセスの現代化著者は 現代化の必要性がユーザー体験にも直結することを指摘しています。特に重要なのは 信頼性の欠如がブランドに与えるダメージです。レンタカー予約システムの事例では 技術的な問題が原因で同じ予約が3回重複して行われ 顧客の信頼を大きく損なう結果となりました。内部システムの非効率性も深刻な課題です。従業員が複数のレガシーシステムを使い分けざるを得ない状況は 業務効率の低下だけでなく 従業員の満足度にも悪影響を及ぼします。さらに 新規採用した従業員の教育コストも増大し 組織の成長を阻害する要因となります。成長戦略と現代化の関係性著者はマトリクスを用いて 4つの成長戦略と現代化の関係性を整理しています。既存市場での新製品開発では 共有機能の抽出とシステム統合が重要な課題となります。欧州の海洋機器メーカーの事例は この課題を端的に示しています。同社はIoTプラットフォームの開発を目指しましたが レガシーシステムの制約により 目標とする処理性能を達成できない事態に陥りました。既存製品での市場浸透では システムの最適化と運用コスト削減が焦点となります。ラテンアメリカのチャレンジャーバンクの事例は この視点からの現代化を示しています。同社は優れたUXにより市場での地位を確立しましたが 事業の拡大に伴いカスタマーサポートのコストが線形に増加する課題に直面しました。現代化は この課題を解決するための戦略的な投資として位置づけられています。戦略的指標としてのノーススター著者は戦略目標を表す指標として ノーススターメトリクス(NSM)の活用を提案しています。NSMは顧客への本質的な価値を表現し 組織の戦略と整合する数値目標です。これは単なる技術指標ではなく ビジネス成果と直結した指標である必要があります。Figure 3.2 Amplitude’s north star framework より引用Figure 3.2は Amplitudeのノーススターフレームワークを示しています。このフレームワークは インプットメトリクスからノーススターメトリクスを経て ビジネス成果に至る価値の流れを可視化します。これにより 現代化の取り組みと事業価値の関係を明確にすることが可能となります。DanseBank社の事例では このフレームワークを活用して PSD2対応の本質的な価値を「取引履歴に基づく迅速な与信判断」と定義しています。同社はエンジニアを含む横断的なチームで エンパシーマップを活用した顧客理解を進め 規制対応という表面的な目標を超えて 顧客価値の創造という本質的な目標を見出すことに成功しています。M&Aと現代化の課題現代化の文脈で特に重要なのが M&Aへの対応です。Salesforceの事例は この課題を端的に示しています。同社はSlackやGitHubなど 複数の大規模な買収を実行していますが それぞれの企業が異なる技術スタックとインフラを持つため システム統合に大きな課題を抱えています。このような状況では ドメイン境界の再定義が重要な課題となります。単なるシステム統合を超えて 製品やドメインの本質的な再定義が必要となるケースも少なくありません。これは技術的な課題であると同時に 組織的な挑戦でもあります。出口戦略としての現代化著者は 出口戦略を目指す企業における現代化の特殊性も指摘しています。IPOや買収を目指す企業では 2-3年という限られた時間軸での投資判断が求められます。この場合 長期的な技術的負債の解消よりも 短期的な価値の創出が優先される傾向があります。しかし著者は このアプローチにも一定の合理性があることを認めています。投資の時間軸を明確にすることで 優先順位の設定が容易になり より効果的な現代化が可能になる場合もあります。重要なのは 短期的な価値創出と長期的な技術的健全性のバランスを適切に取ることです。まとめ本章は 現代化への投資判断をビジネスの文脈で捉え 具体的な評価基準と実践方法を提示しています。特に ノーススターメトリクスの活用は 技術的な取り組みとビジネス成果を結びつける効果的な手法として注目に値します。また各種事例は 現代化が組織全体の変革として成功するための具体的なアプローチを示しています。著者の主張の本質は アーキテクチャ現代化を単なる技術刷新ではなく 組織の戦略的な変革として捉える点にあります。その成功には ビジネス戦略との整合性 投資判断の明確な基準 そして組織全体での価値共有が不可欠です。特に重要なのは 現場のエンジニアが顧客価値を深く理解し その実現に向けて主体的に取り組める環境の構築です。DanseBank社のエンパシーマップの活用は この理想的な姿を具体的に示しています。読者は 本章を通じて アーキテクチャ現代化を戦略的な投資として位置づけ その判断基準と実践方法を学ぶことができます。特に 技術的な観点とビジネス的な観点を結びつける具体的な手法は 実務での活用価値が高いと考えられます。今日のソフトウェア開発組織において アーキテクチャ現代化は避けて通れない課題となっています。本章は その取り組みを成功に導くための実践的なガイドラインを提供しているといえるでしょう。4 Listening and mapping tours第4章「Listening and mapping tours」は アーキテクチャ現代化の始め方に焦点を当てています。著者は まず聞くこと（listening）から始めるという基本姿勢を強調し その実践的なアプローチを提示しています。この章を通じて 組織全体の状況を把握し 実行可能な現代化戦略を策定するための体系的な手法が示されています。この構成は、アーキテクチャ現代化が本質的に技術的な課題である以上に、人々の協力と理解を必要とする社会的な取り組みであることを示唆しています。技術的な解決策がいかに優れていても、それを実現する人々の協力が得られなければ、現代化の取り組みは成功しないという現実を反映しています。「変化を嫌う人」を動かす:魅力的な提案が受け入れられない4つの理由作者:ロレン・ノードグレン,デイヴィッド・ションタル,船木 謙一(監修)草思社Amazonリスニングツアーの本質と準備著者は アーキテクチャ現代化の開始時に陥りがちな罠を指摘しています。多くの組織では 事前に用意した解決策を提案し その説得に注力しがちです。しかし このアプローチは組織の実態を十分に理解しないまま 表面的な解決策に走るリスクがあります。著者は この罠を回避するために リスニングツアーという手法を提案しています。リスニングツアーは 経営層から現場の開発者まで幅広い関係者と対話を行い 組織の課題と可能性を深く理解するプロセスです。特に重要なのは 単なるヒアリングではなく 関係者との信頼関係を構築し 組織の本質的な課題を浮き彫りにする点です。リスニングツアーの実施主体として 著者は AMET（Architecture Modernization Enabling Team）の設置を推奨しています。AMETは 技術とビジネスの両方を理解するメンバーで構成され 現代化のビジョン策定から実行支援までを担います。特に重要なのは チーム内で得られた知見を共有し 一貫した理解を構築する能力です。効果的なリスニングの実践リスニングツアーの成功には いくつかの重要な要素があります。最も基本的なのは 安全な対話の場の創出です。著者は 威圧的な空間ではなく 自由な対話が可能な環境づくりの重要性を説いています。これは カジュアルな場所の選択や 適切なタイミングの設定など 細かな配慮の積み重ねによって実現されます。同様に重要なのが 質問のデザインです。著者は 直接的な質問だけでなく より深い洞察を引き出すための多様な質問形式を提案しています。例えば「Complete the sentence（文章の完成）」では「私の仕事で現在最も腹が立つことは_____です」といった形式で 感情的な側面も含めた本音を引き出すことができます。問いの編集力 思考の「はじまり」を探究する作者:安藤昭子ディスカヴァー・トゥエンティワンAmazonまた「Choose an emotion（感情の選択）」では 感情のホイールから特定のトピックに対する感情を選ぶことで より深い理解を促進します。「Pick an image（画像の選択）」では 視覚的な表現を通じて 言葉では表現しにくい認識や感覚を共有することが可能になります。ツールボックスの活用効果的なリスニングツアーには 適切なツールの活用も重要です。著者は Impact Mappingを用いてビジネス目標とその実現手段の関係を可視化することを提案しています。これにより 戦略的な優先順位付けと 具体的な施策の選定が容易になります。Figure 4.4 A C4 container diagram with multiple risks identified より引用Risk Stormingは システムのリスクを特定し評価するための効果的なツールです。C4モデルをベースに システムの構造とリスクの関係を可視化することで 技術的な課題とビジネスインパクトの関連をより明確に理解できます。各リスクは 発生確率とインパクトの観点から評価され 優先度付けが行われます。グループワークショップと組織的な展開個別の対話に加えて 著者は グループワークショップの重要性も強調しています。臨床腫瘍学分野の非営利組織の事例では 参加者が自身のモダナイゼーションジャーニーを選択できるようなワークショップを設計しています。この中で ダブルダイヤモンドやデザインスクィグルといったモデルが活用され 参加者の主体的な関与を促進しています。特に興味深いのは ワークショップの段階的なアプローチです。最初にジャーニーのメタファーを選択し 次にドメインの境界を探索し 最後に具体的なアクションを計画するという流れは 参加者の理解と合意を段階的に構築する効果があります。キックスターターワークショップの実践現代化の実行フェーズへの移行には 3日間のキックスターターワークショップが効果的です。スカンジナビアの大規模企業の事例では このワークショップを通じて モノリシックなシステムからの段階的な移行戦略を策定しています。ワークショップの成功には 事前の準備が重要です。第1日目は ビジネスビジョンの共有と現状の分析に充てられ 第2日目は ドメインの探索とEventStormingによるプロセスの理解 第3日目は具体的なアーキテクチャ設計と実行計画の策定に焦点を当てます。この段階的なアプローチにより 参加者全員が共通の理解を持ちながら 具体的な行動計画を策定することが可能になります。ドメイン駆動設計をはじめよう ―ソフトウェアの実装と事業戦略を結びつける実践技法作者:Vlad KhononovオライリージャパンAmazon継続的な改善と展開著者は ワークショップの成果を継続的な改善につなげる重要性も強調しています。キックスターターワークショップで得られた勢いを維持するために AMETが重要な役割を果たします。AMETは 単なる技術支援チームではなく 組織の現代化能力を継続的に向上させるためのファシリテーターとして機能します。また 定期的なフィードバックと振り返りの機会を設けることで 現代化の取り組みを継続的に改善することが重要です。これには アンケートやフォローアップセッションの活用が効果的です。著者は これらのフィードバックを通じて 組織全体の学習と進化を促進することを推奨しています。まとめ本章は アーキテクチャ現代化の開始フェーズにおける実践的なアプローチを提示しています。特に重要なのは 聞くことから始めるという基本姿勢です。これは 単なるヒアリングを超えて 組織の本質的な課題と可能性を理解するための戦略的なアプローチです。著者が提案する手法は 理論的な枠組みと実践的なツールの巧みな組み合わせによって特徴づけられます。リスニングツアー グループワークショップ キックスターターワークショップという段階的なアプローチは 組織の現状を深く理解し 実行可能な現代化戦略を策定する上で効果的なフレームワークを提供しています。これらの手法の成功には 適切な環境作りと継続的なサポート体制が不可欠です。AMETの設置はその一つの解決策ですが より本質的には 組織全体が現代化の重要性を理解し その実現に向けて協力する体制を構築することが求められます。アーキテクトとして この組織的な側面への理解と対応が 現代化の成功に不可欠な要素といえるでしょう。5 Wardley Mapping第5章「Wardley Mapping」は ビジネス戦略とアーキテクチャ戦略を結びつけるための実践的なフレームワークとして Wardley Mappingを紹介しています。この章を通じて 著者はビジネスランドスケープの可視化と進化の理解が アーキテクチャ現代化の意思決定において重要な役割を果たすことを示しています。learnwardleymapping.com日本だと「Wardley Mapping」はあまり聞き馴染みのない言葉だと思います。実践例みたいなのもあまり聞いたことがありませんでした。blog-smatsuzaki.hatenablog.comengineer.crowdworks.jp戦略的思考とWardley MappingWardley Mappingは 単なる可視化ツールを超えて ビジネスとテクノロジーの戦略的統合を実現する手法です。この手法の特徴は バリューチェーンと進化という2つの軸で ビジネスランドスケープを表現する点にあります。これは従来の2x2マトリックスのような静的なフレームワークとは一線を画します。著者は 戦略サイクルという概念を用いて その実践プロセスを説明しています。このサイクルは 目的 ランドスケープ 気候 ドクトリン リーダーシップの5つのフェーズで構成されます。Figure 5.1は このサイクルの相互関係を示しています。特に重要なのは このサイクルが単なる一方向のプロセスではなく 継続的な学習と適応のループとして機能する点です。Figure 5.1 The Strategy Cycle (Source: Simon Wardley) より引用ただし 戦略サイクルは単なるプロセスモデルではありません。このフレームワークは 組織がどのように戦略を実践し 学習し 適応していくかという包括的な視点を提供します。例えば 目的の定義では 単なるミッションステートメントの作成を超えて 組織の存在意義と未来への展望を深く掘り下げることが求められます。マッピングの実践Wardley Mapの作成プロセスは 6つのステップで構成されます。まず目的を定義し スコープを設定し ユーザーを特定します。次にユーザーニーズを明確にし バリューチェーンを構築し 最後に各コンポーネントの進化段階を評価します。Ben MosiorのWardley Mapping Canvasは この一連のステップをガイドする効果的なツールです。特に重要なのは スコープの設定です。マッピングの範囲を適切に定義することで 意味のある議論と洞察が可能になります。スコープが広すぎると表面的な分析に終わり 狭すぎると重要な関係性を見落とす可能性があります。著者は この判断をサポートするための具体的な指針を提供しています。実際のマッピングでは オンラインフードデリバリー企業の例を用いて具体的な適用方法が示されています。このケースでは レストランと顧客をつなぐマルチサイドプラットフォームのビジネスモデルに焦点を当てています。段階的なマッピングプロセスを視覚的に示しています。この事例で特に注目すべきは バリューチェーンの構築プロセスです。コンポーネント間の依存関係を可視化することで 技術的な選択がビジネス価値にどのように影響するかが明確になります。例えば クラウドプラットフォームのような基盤的なコンポーネントが いかに上位のサービスの可能性を規定するかが理解できます。進化の理解と評価Wardley Mappingにおける進化の概念は 単なる技術的な成熟度を超えた意味を持ちます。Genesis Custom Built Product Commodityという4つのステージは それぞれ異なる特性と戦略的意味を持ちます。著者は この評価を支援するための15の基準を提示しています。例えば Ubiquity（普及度）とCertainty（確実性）は 進化段階を評価する重要な特性です。さらに 市場の成熟度やユーザーの認識など 12の一般的な特性も評価の基準として提示されています。これらの基準を用いた評価は 必ずしも一意的な結果をもたらすわけではありません。むしろ 異なる視点からの評価結果の違いが 重要な戦略的議論のきっかけとなります。著者は この曖昧性を否定的に捉えるのではなく 組織の学習機会として活用することを推奨しています。気候変動の理解と対応著者は 競争環境の変化を「気候」として捉え その重要性を強調しています。特に すべては進化するという原則は 戦略策定の基本的な前提となります。この原則は 単なる観察結果ではなく 戦略的な対応を要求する動的な状況を示しています。特に重要なのは コンポーネントの共進化という概念です。技術やビジネスモデルは単独で進化するのではなく 相互に影響を与えながら進化します。例えば リモートワークの普及は Zoom SlackなどのコラボレーションツールとWi-Fi接続性の進化が組み合わさることで可能になりました。戦略的対応のパターン著者は 環境変化への対応として アクセラレーターとデセラレーターという2つのパターンを提示しています。アクセラレーターには オープンソース化やネットワーク効果の活用が含まれます。一方 デセラレーターには 知的財産権の保護やFUDの活用があります。特に注目すべきは オープンアプローチの戦略的活用です。著者は GoogleやMicrosoftの事例を引用し オープンソース化が競争優位性の獲得につながる可能性を示しています。例えば TensorFlowのオープンソース化は 機械学習の分野でGoogleの影響力を強化することに貢献しました。組織的な実践への示唆Wardley Mappingの実践では 技術的な側面だけでなく 組織的な側面も重要です。特に チーム間のコラボレーションと共通言語としてのマッピングが重要な役割を果たします。著者は AMETなどの組織的な枠組みの活用も提案しています。この手法の導入には 段階的なアプローチが有効です。著者は まずキーとなるステークホルダーとの小規模なマッピングセッションから始め 徐々に範囲を拡大していくことを推奨しています。これにより 組織全体での理解と受容が促進されます。まとめWardley Mappingは アーキテクチャ現代化の文脈で 特に重要な3つの価値を提供します。第一に ビジネスとテクノロジーの統合的な理解を促進します。第二に 進化という視点を通じて 長期的な戦略立案を支援します。第三に 具体的な意思決定のフレームワークを提供します。本章で示された手法は 特にアーキテクチャの意思決定において実践的な価値があります。技術選択やシステム構造の決定を ビジネス戦略との整合性を保ちながら行うことが可能になります。さらに 継続的な環境変化に対応する能力も強化されます。アーキテクトとして この手法を活用する際は 単なる技術マッピングに終始せず ビジネス価値との結びつきを常に意識することが重要です。また 組織全体での共通言語としてWardley Mappingを活用することで より効果的な戦略的対話が可能になるでしょう。最後に 著者は この手法の習得には継続的な実践が不可欠であることを強調しています。理論的な理解だけでなく 実際のビジネス課題への適用を通じて その効果的な活用方法を学んでいく必要があります。特に 気候変動の理解と戦略的対応のパターンは 実践を通じて深い理解が得られる領域といえるでしょう。6 Product taxonomy第6章「Product taxonomy」は アーキテクチャ現代化の基盤となる製品分類の枠組みを提示しています。タクソノミー（taxonomy）とは もともと生物学で用いられる分類体系のことで 生物をその特徴によって分類し 体系化する方法を指します。この考え方をソフトウェア開発組織に適用したのが プロダクトタクソノミーです。著者は この枠組みを通じて 組織構造とアーキテクチャの整合性を実現するための具体的なアプローチを示しています。プロダクトマネジメントのすべて 事業戦略・IT開発・UXデザイン・マーケティングからチーム・組織運営まで作者:及川 卓也,小城 久美子,曽根原 春樹翔泳社Amazonタクソノミーの意義と基本概念プロダクトタクソノミーは 組織のアーキテクチャを製品視点で体系化するためのフレームワークです。従来の組織構造やシステム構成が必ずしも効率的な開発を実現できていない現状に対して タクソノミーという視点で再構築することで より効果的な組織とアーキテクチャの形を見出すことができます。特に重要なのは タクソノミーがただの分類ではなく 価値提供の単位を定義する点です。これは 単なる技術的な構造化ではなく ビジネス価値の創出を中心に据えた組織設計を可能にします。実際の適用では 既存の組織構造や技術的な制約との調整が必要になりますが タクソノミーという視点があることで より戦略的な判断が可能になります。独立した価値ストリームプロダクトタクソノミーの核となるのが 独立した価値ストリームという概念です。著者は Figure 6.1と6.2を用いて この概念を説明しています。価値ストリームは ユーザーニーズの特定から解決策の提供まで 一連の開発活動を表します。Figure 6.1 The high-level activities in an independent value stream より引用Figure 6.2 The four key characteristics of an independent value stream より引用価値ストリームの独立性を実現するには 4つの重要な特性が必要です。1つ目は ビジネスサブドメインとの整合性です。これは 特定のビジネス領域に焦点を当てることで 明確な価値提供を可能にします。2つ目は 明確なビジネス成果への焦点です。具体的な成果指標を持つことで チームの方向性が明確になります。3つ目は 自律的なチームによる所有権です。チームが自律的に意思決定できることで 開発のスピードと質が向上します。4つ目は デカップルされたソフトウェアアーキテクチャです。技術的な独立性が チームの自律性を支えます。スコープとドメインの階層構造著者は Ruth MalanとDana Bredemeyerのアーキテクチャスコープレベルを参照しながら 組織の階層構造に応じた3つのスコープレベルを定義しています。スコープ1は 単一のチームが所有する小規模なドメイン スコープ2は 複数のチームが必要な中規模なドメイン スコープ3は さらに大きな組織的な複雑さを持つドメインを表します。この階層構造は 組織の規模や複雑さに応じた適切な分類を可能にします。例えば 小規模な組織では スコープ1と2で十分かもしれません。一方で Salesforceのような大規模組織では より多くのスコープレベルが必要になることもあります。ドメインとプロダクトの関係性ドメインは 関連するサブドメインをグループ化したものです。Figure 6.3の例では fulfillmentドメインが availability last mile warehousing logisticsという4つのサブドメインで構成されています。各サブドメインは独立した価値ストリームを持ち それぞれが特定の業務機能に焦点を当てています。プロダクトは より広い概念として定義されています。著者は Melissa Perriの定義を引用し プロダクトを「市場に提供可能な 繰り返し可能なソリューションで 特定のニーズや要求を満たすもの」と定義しています。この定義の重要な点は プロダクトが単なる機能の集合ではなく 顧客への完全な価値提供を実現する単位だという点です。プラットフォームの戦略的活用プラットフォームは 複数のプロダクトで共有される機能を提供する重要な要素です。著者は ドメインプラットフォームと内部開発プラットフォームの2種類を定義しています。Figure 6.6は これらの関係性を視覚的に示しています。Figure 6.6 Platforms provide reuse across multiple products より引用ドメインプラットフォームは ビジネスドメインに関連する共有機能を提供します。例えば 予約システムや認証システムなどが該当します。一方 内部開発プラットフォームは チームの開発活動を支援する機能を提供します。CI/CDパイプラインやモニタリングツールなどがこれにあたります。NAVの事例は プラットフォーム戦略の実践を示す良い例です。ノルウェーの行政機関であるNAVは 内部開発プラットフォームを複数のサブプラットフォームに分解することで スケーラビリティの課題に対応しています。特に重要なのは プラットフォームをプロダクトとして扱う「Platform as a Product」というアプローチです。これにより 利用者であるチームのニーズに適切に対応できる体制を維持しています。タクソノミーの設計と進化プロダクトタクソノミーの設計には、いくつかの重要な原則があります。これらの原則は、組織の現状を踏まえながら、段階的に理想的な状態へと進化させていくためのガイドラインとなります。第一の原則：容易な部分からの段階的アプローチまず重要なのは、容易な部分から始めることです。既存の製品ラインナップを整理・分類することから着手し、現在の組織構造を出発点として活用します。特に、チームが理解しやすい領域から取り組みを開始し、小さな成功を積み重ねて徐々に範囲を拡大していくことが効果的です。このアプローチにより、組織全体の理解と受容を促進しながら、段階的な改善を進めることができます。第二の原則：適切な技術・手法の活用効果的なタクソノミー設計には、状況に応じた適切な手法の選択が重要です。EventStormingはドメインの理解と境界の特定に、Wardley Mappingは価値連鎖と進化の段階の可視化に効果的です。さらにドメインストーリーテリングは具体的なユースケースの理解を深め、インパクトマッピングはビジネス目標との整合性を確認するのに役立ちます。これらの手法を組み合わせることで、表面的な理解を超えた深い洞察を得ることができます。第三の原則：継続的な進化の実践タクソノミーは静的なものではなく、継続的に進化させる必要があります。現状のアーキテクチャと目標とする価値ストリームの差異を定期的に評価し、四半期ごとのタクソノミー見直しと更新を実施することが求められます。ビジネス環境の変化や新たな要件への適応も重要な要素です。特に重要なのは、不整合の特定から始まり、段階的な改善を経て、定期的な評価とフィードバックの収集までの一連のプロセスです。現状と目標のギャップを明確にし、優先順位付けされた課題に取り組み、進捗を確認しながら方向性を調整していきます。このような継続的な改善サイクルを通じて、組織の成長と技術の進化に適応したタクソノミーを維持することができます。実践のためのガイドライン効果的な実践のためには、定期的なレビューセッションの開催が重要です。ステークホルダーからのフィードバックを収集し、成功事例と課題を文書化します。さらに、学習した内容を組織全体で共有することで、タクソノミーを組織の実態に即した、実用的なツールとして育てていくことができます。このような体系的なアプローチにより、タクソノミーは単なる分類システムを超えて、組織の変革と成長を支える重要な基盤となります。継続的な改善と適応を通じて、組織全体の効果的な進化を支援する枠組みとして機能していくのです。ソフトウェアアーキテクトのための意思決定術　リーダーシップ／技術／プロダクトマネジメントの活用作者:Srinath Perera,島田 浩二インプレスAmazonマクロレベルの戦略的課題マクロレベルでの重要な課題として 再利用の戦略があります。Figure 6.12は この課題を視覚的に表現しています。特に グローバル企業において 各地域市場で機能を複製するか 中央集権的なプラットフォームを構築するかという選択は 重要な戦略的決定となります。この選択には いくつかの重要な考慮点があります。ユーザー体験の一貫性 優先順位付けの方法 資金モデル 依存関係の管理 効率性と市場投入速度のバランスなどです。これらの要素を総合的に評価し 組織に適した戦略を選択する必要があります。Stripeの事例は この課題への実践的なアプローチを示しています。同社は Treasury機能の開発において 最初は独立した実装を行い 市場での検証後に既存のインフラストラクチャへの統合を進めました。このアプローチは 短期的な市場投入速度と長期的な効率性のバランスを取る良い例といえます。プロダクトモードへの移行従来のプロジェクトモードが スコープ コスト 期間の制約のもとで一時的なチームが成果を出すのに対し プロダクトモードは 長期的な継続的改善にフォーカスし 安定したチームによる自律的な開発を重視します。この移行は 単なる開発プロセスの変更ではありません。資金モデル チームの責任範囲 成功の定義など 組織全体の文化とマインドセットの変革が必要です。著者は この変革が一夜にして達成されるものではないと指摘しつつ その実現がアーキテクチャ現代化の成功には不可欠だと主張しています。まとめプロダクトタクソノミーは アーキテクチャ現代化を実現するための戦略的なフレームワークです。その核となる価値ストリームの独立性と プラットフォームの適切な活用は 組織の効率性と革新性を両立させる鍵となります。特に重要なのは タクソノミーが静的な分類ではなく 継続的に進化する生きた構造だという点です。定期的な見直しと更新を通じて 組織の成長と技術の進化に対応していく必要があります。アーキテクトとして この章から学ぶべき重要な点は タクソノミーが単なる構造の定義ではなく チームの自律性と技術的な進化を支える枠組みだということです。その設計と進化を適切にガイドすることが 現代化の成功に不可欠な要素といえるでしょう。組織の規模や状況に応じて 適切なアプローチを選択し 段階的な実現を目指すことが 実践的な戦略となります。7 Big picture EventStorming第7章「Big picture EventStorming」は、アーキテクチャ現代化において最も重要な「ゆっくり考える」フェーズを実現するための手法を紹介しています。著者は性急な意思決定の危険性を指摘し、その解決策としてEventStormingというコラボレーティブな技法を提示しています。現代化プロジェクトの多くは、「すばやく考え、ゆっくり動く」というパターンに陥りがちです。予算、工期、便益の3点全てを満たすプロジェクトは例外中の例外（0.5%）であり、その主な原因は初期の理解と計画が不十分なままプロジェクトを開始してしまうことにあります。BIG THINGS　どデカいことを成し遂げたヤツらはなにをしたのか？作者:ベント・フリウビヤ,ダン・ガードナーサンマーク出版AmazonEventStormingは、この課題に対する具体的な解決策を提供します。ドメインの深い理解を得るために十分な時間を確保し、関係者全員で慎重に検討を重ねることで、後続のフェーズで迅速な実行を可能にします。これは「ゆっくり考え、すばやく動く」という成功プロジェクトに共通する特徴を体現しています。本章では、この手法の実践的な適用方法と、組織全体での価値創造について、体系的な説明を展開していきます。特に重要なのは、人の心理や組織の力学が初期の理解フェーズを軽視させがちだという点への対処です。EventStormingは、この人間的な側面も考慮に入れた、実践的で効果的なアプローチを提供します。EventStormingの本質EventStormingは 2010年代半ばにAlberto Brandoliniによって考案された ドメイン探索のための手法です。その最大の特徴は シンプルな表記法と高い包摂性にあります。ドメインイベントという概念を用いて 業務の流れを左から右への時系列で表現します。Figure 7.1は その基本的な構造を示しています。Figure 7.1 Using domain events to map out a business on a timeline from left to right より引用特に重要なのは この手法が特別なトレーニングを必要としない点です。製品開発に関わる全ての人々（開発者 テスター プロダクトマネージャー UXデザイナー カスタマーサポート担当者など）が 自然に参加できるよう設計されています。これは 組織内の知識を最大限に活用し より深いドメイン理解を得るために不可欠な特性といえます。私自身の経験でも EventStormingの価値を実感する場面は多くあります。例えば あるプロジェクトで開発者が「この機能は重要ではない」と考えていた問題について カスタマーサポート担当者から「今朝も2件の問い合わせがあった」という指摘があり 認識のズレが明らかになった事例があります。このような気づきは 個別のインタビューでは得られにくいものです。手法の実践EventStormingの実践には いくつかの重要な要素があります。まず 会場の準備です。8メートル以上の壁面スペースと 付箋やペンなどの文具が必要です。Figure 7.8が最高なのでぜひ書籍を読んでみて下さい。また、テーブルや椅子は最小限にし 参加者が自由に動き回れる環境を整えることが重要です。セッションの進め方も重要です。著者は カオス的な探索という概念を提唱しています。これは 最初から整然とした構造を求めるのではなく 参加者全員が思いつくままにドメインイベントを書き出していく方法です。Figure 7.2は この過程を視覚的に示しています。Figure 7.2 An EventStorm runs from left to right but does not need to be neatly and precisely laid out. より引用私の実践では この「カオス」の許容が非常に重要だと感じています。整然とした構造を早期に求めすぎると 重要な気づきが失われる可能性があります。特に レガシーシステムの現代化では 表面には現れていない依存関係や制約が多く存在するため この探索的なアプローチが効果的です。ファシリテーションの技術EventStormingのファシリテーションには 高度なスキルが要求されます。著者は Figure 7.17など用いて いくつかの重要な原則を示しています。特に重要なのは 抽象度のバランスです。過度に抽象的なイベントは 重要な詳細を隠してしまい 過度に具体的なイベントは 全体像の理解を妨げます。Figure 7.17 Overly abstract events より引用実践的なテクニックとして ピボットイベントの活用があります。これは タイムライン全体を適切なサイズに分割し 理解を促進するための手法です。Figure 7.11は この手法の適用例を示しています。このような構造化により 複雑なドメインでも理解しやすくなります。Figure 7.11 Using pivotal events to sort the timeline より引用私の経験では このピボットイベントの選定が セッションの成否を分ける重要な要素となることが多いです。適切なピボットイベントは ドメインの本質的な変化点を表現し より深い議論のきっかけを提供します。問題とチャンスの発見著者は EventStormingが 単なるプロセスの可視化ではなく 問題とチャンスの発見ツールとしても機能することを強調しています。Figure 7.15は ユーザーのドロップアウトポイントを示す例です。このような視覚化により 業務上の課題がより明確になります。Figure 7.15 A customer dropping out of the funnel, resulting in lost revenue より引用特に興味深いのは 知識の欠落や争点の発見です。著者は 2017年の金融アドバイス業界での事例を紹介しています。この事例では メトリクスの計算方法について 開発者とマーケティング責任者の間で認識の不一致が発見されました。このような発見は 組織の意思決定の質を向上させる重要な機会となります。リモートでの実践パンデミック以降 リモートでのEventStormingの実践が急速に広がっています。著者は この変化を単なる代替手段としてではなく 新たな可能性として捉えています。Miroなどのデジタルツールでは 物理的な制約なく無限のモデリングスペースを使用でき コピー＆ペーストなどの効率的な操作も可能です。私の実践でも リモートならではの利点を多く発見しています。例えば 複数のセッションを時間をかけて実施できることや グループワークでの素早い複製と比較が可能なことは 大きな価値です。ただし 参加者の集中力維持や 非言語コミュニケーションの制限には 十分な注意が必要です。まとめEventStormingは アーキテクチャ現代化において 不可欠なツールです。その価値は 単なるプロセスの可視化を超えて 組織の知識の統合と 深い洞察の獲得にあります。特に 現代のソフトウェア開発において重要な ドメイン駆動設計の実践を支援する強力なツールとなります。一方で この手法の効果的な活用には 適切なファシリテーションスキルと 組織文化の醸成が必要です。Discovery mindsetの確立や bikesheddingの回避など 実践上の課題にも注意を払う必要があります。アーキテクトとして この手法を活用する際は 単なるテクニックとしてではなく 組織の知識を統合し 現代化の方向性を見出すための戦略的なツールとして位置づけることが重要です。特に レガシーシステムの現代化において その価値は極めて高いといえるでしょう。8 Product and domain modernization第8章「Product and domain modernization」は、アーキテクチャ現代化における製品とドメインの重要性に焦点を当てています。この章を通じて、著者は現代化が単なる技術的な刷新を超えて、ユーザー体験、製品価値、ドメインモデルの根本的な見直しを必要とすることを示しています。DDD（Domain-Driven Design）という言葉をよく耳にしますが、「DDDって結局クリーンアーキテクチャのことですか？」といった質問を受けることも多く、その本質的な理解が十分に広まっているとは言えない状況です。本章は、DDDの核心である「ドメインモデリング」について体系だった説明を提供しており、その点だけでも大きな価値があります。特に、ドメインモデルが単なる技術的な設計パターンではなく、ビジネスの本質を理解し表現するための手法であることが、具体的な事例とともにわかりやすく解説されています。ドメイン駆動設計入門 ボトムアップでわかる！ドメイン駆動設計の基本作者:成瀬 允宣翔泳社Amazon製品現代化の本質製品現代化の本質は、単なる技術的なアップデートではありません。著者は、多くの組織が陥りがちな 古いシステムを新技術で再構築するという罠 について警鐘を鳴らしています。現代化は、長年抱えてきた問題に向き合い、不要な複雑性を排除する機会です。リファクタリング 既存のコードを安全に改善する（第2版）作者:ＭａｒｔｉｎＦｏｗｌｅｒオーム社Amazonこの点は、英国政府のデジタルサービス（GDS）の事例で端的に示されています。GDSは、政府サービスの現代化において、ユーザー中心設計と継続的デリバリーを重視する方針を採用しました。その結果、数十年にわたって変更されていなかった政策やプロセスの見直しにまで踏み込んだ改革を実現しています。Figure 8.1が示すように、現代化は製品スタック全体に影響を与えます。UIの改善はユーザーの生産性向上につながり、ソフトウェアの改善はドメインとの整合性を高めます。さらに、概念的なドメインモデルの改善は、組織全体のコミュニケーションと革新を促進します。Figure 8.1 Full-stack modernization, from business domain up to user interface より引用要件の再定義プロセス製品要件の特定において、著者は 既存コードの単純な逆エンジニアリングを避けるべきと主張します。その理由は明確です。既存システムには、もはや不要な機能や、当初から有用性の低かった機能が含まれている可能性が高いからです。Citibank社の事例は、この問題の深刻さを示す象徴的な例です。1990年代スタイルのユーザーインターフェースが原因で、5億ドルの損失を被った事例は、内部向けシステムのUX軽視がもたらすリスクを如実に示しています。特に重要なのは 継続的なディスカバリー の実践です。著者はTeresa Torresの「Continuous Discovery Habits」を引用しながら、週次でのユーザー接点を持つことの重要性を強調しています。これは単なる検証ではなく、共創のマインドセットに基づく早期フィードバックの獲得を意味します。agnozingdays.hatenablog.comドメインモデルの現代化ドメインモデルの現代化は、組織のコミュニケーションと協働に直接的な影響を与えます。著者は、同じ用語に対する異なる解釈が引き起こす問題を、North American Smart Citiesの事例で示しています。「activated」という単語の解釈の違いが、品質エンジニアとソリューションアーキテクトの間で深刻な対立を引き起こした事例は、共通言語の重要性を端的に示しています。Figure 8.3は、同じフレーズが異なるドメイン概念を指す場合に発生する問題を視覚化しています。このような曖昧性は、コラボレーションの効率低下とコードの複雑化を招く原因となります。Figure 8.3 Problems arise when the same phrase is used to describe different domain concepts. より引用プロセスモデリングの実践著者は、プロセスモデリングEventStormingを、将来のドメイン状態を設計するための効果的なツールとして提案しています。この手法の特徴は、その構造化されたアプローチにあります。Figure 8.4は、アクター、アクション、システム、ドメインイベント、ポリシー、情報という基本的な要素を示しています。Figure 8.4 Process modeling EventStorming notation and syntax より引用この手法の実践では、良い質問をすることが重要です。著者は、「この役割を担う人数は何人か」「一人が複数の役割を担えるか」といった質問を通じて、機会の規模と最適化のポイントを特定することを推奨しています。Figure 8.8は、この質問アプローチの実践例を示しています。Figure 8.8 Asking questions about people in the domain to unlock valuable conversations より引用ドメインストーリーテリングの活用ドメインストーリーテリングは、EventStormingと並ぶ重要なモデリング手法です。著者はこの手法の特徴として、「ストーリー」を中心に据えた探索的なアプローチを挙げています。Figure 8.10は、この手法の基本的な表記法を示しています。Figure 8.10 The five basic notation elements of the Domain Storytelling pictographic language より引用特に注目すべきは、この手法が 一度に一つのフローに集中する アプローチを取る点です。これはEventStormingの多面的なアプローチとは異なりますが、特定のシナリオを深く理解する上で効果的です。実践的な成果と課題英国のDepartment for Levelling Up, Housing, and Communities の事例は、これらのアプローチの実践的な価値を示しています。彼らは継続的なディスカバリーアプローチを採用し、ユーザー研究を通じて段階的な改善を実現しました。その結果、単なる規制対応を超えて、政策立案者への新たな価値提供まで実現しています。この事例で特に興味深いのは、文脈的探査（contextual inquiry）とユーザビリティテストの組み合わせです。文脈的探査によってユーザーの本質的なニーズを理解し、ユーザビリティテストで具体的な解決策を検証するという二段階のアプローチは、効果的な現代化戦略の好例といえます。まとめ製品とドメインの現代化は、アーキテクチャ現代化の中核を成す要素です。その成功は、技術的な刷新だけでなく、ユーザー体験、製品価値、ドメインモデルの包括的な見直しに依存します。特に重要なのは、現代化を単なる「古いものの置き換え」ではなく、組織の価値創造能力を根本的に強化する機会として捉えることです。この章で示された手法と事例は、現代のソフトウェア開発組織が直面する課題に対する実践的な解決策を提供しています。特に、継続的なディスカバリーとコラボレーティブなモデリング手法の組み合わせは、現代化プロジェクトの成功に不可欠な要素といえるでしょう。私たちアーキテクトは、これらの知見を活かし、技術とビジネスの架け橋となる現代化戦略を策定していく必要があります。9 Identifying domains and subdomains第9章「Identifying domains and subdomains」は、アーキテクチャ現代化における最も重要な課題であるドメインとサブドメインの識別について論じています。著者はドメイン境界の設計がチームの効果的な構造化とルースカップリングなアーキテクチャの実現に不可欠であることを示し、その実践的なアプローチを提示しています。新版　考える技術・書く技術　問題解決力を伸ばすピラミッド原則作者:バーバラ・ミントダイヤモンド社Amazonドメイン境界の本質と価値良いドメイン境界の設計は、単なる技術的な課題を超えた組織的な価値を持ちます。Figure 9.2が示すように、適切なドメイン境界は依存関係の削減による開発の高速化とチームの幸福度向上をもたらします。関連する概念のまとまりは明確な目的意識を生み、チームの動機付けと持続可能な実践を促進します。Figure 9.2 Well-designed domain boundaries maximize cohesion and minimize coupling, contributing to higher-performing teams and better products. より引用この価値は特にレガシーシステムの現代化において顕著です。私が過去に担当した金融機関のプロジェクトでは、明確なドメイン境界の欠如が開発の遅延と品質の低下を引き起こしていました。チーム間の依存関係が複雑に絡み合い、小さな変更でも多数のチームの調整が必要になる状況でした。結果として、1行のコード変更に数週間の調整期間を要することもありました。ドメイン境界設計の実践例BBCの事例は、ドメイン境界の進化を示す典型的な例です。当初BBCはニュース・スポーツ・天気予報といった垂直方向のサービスごとに境界を設定していました。各サービスは独自の発展を遂げ、週間数百万のアクセスを誇る規模に成長しました。しかしこの構造は、サービス間での一貫した体験の提供を難しくしていました。そこでBBCは、記事・検索・トピックといった水平方向のドメインへと再構成を行いました。この変更により、共通コンポーネントの再利用が促進され、パーソナライゼーションや分析といった横断的な機能の実装が容易になりました。現代化の具体的アプローチFigure 9.12は、大規模航空会社におけるドメイン分割の具体例を示しています。予約・ロイヤルティ・チェックイン・旅程管理といった明確な責任範囲を持つドメインが識別されています。各ドメインは複数のサブドメインで構成され、独立したチームによる開発を可能にしています。Figure 9.12 Domains and subdomains identified at the airline (Source: Javiera Laso) より引用この事例で興味深いのは、同じ名前のサブドメインが異なるドメインに存在する点です。一般的なアーキテクトの直感に反するこの決定は、各ドメインにおける意味的な違いに基づいています。私の経験でも、一見同じに見える概念でも、ビジネスコンテキストが異なれば別々に扱うべき場合が多々あります。評価と発展のフレームワークFigure 9.21のサブドメイン概要キャンバスは、ドメイン境界の妥当性を評価するための実践的なツールです。このキャンバスは目的・主要概念・イベント・ポリシーなど、多面的な視点からドメインを分析します。私はこのキャンバスを使って、チームとステークホルダー間の対話を促進し、境界の設定に関する合意形成を図っています。Figure 9.21 The subdomain overview canvas より引用特に重要なのは、このキャンバスを通じて見えてくる依存関係の評価です。Vlad Khononovの提案する Pain = Strength * Volatility * Distance という公式は、依存関係の問題を定量的に評価する枠組みを提供します。私のプロジェクトでは、この公式を使って優先順位付けを行い、最も問題のある依存関係から順に解消していく戦略を採用しています。継続的な進化の実践ドメイン境界の設計は一回限りの活動ではありません。新機能の追加や事業環境の変化により、継続的な見直しが必要になります。最近のプロジェクトでは、マイクロサービスへの移行過程で、想定外の依存関係が発見され、境界の再設計が必要になりました。この課題に対して私たちが採用している手法は、四半期ごとのドメインレビューです。このレビューでは、変更頻度・依存関係のコスト・チームの生産性などの指標を評価し、必要に応じて境界の調整を行います。この定期的なフィードバックループが、境界設計の持続的な改善を可能にしています。まとめドメインとサブドメインの識別は、アーキテクチャ現代化の成功を左右する重要な要素です。技術的な側面だけでなく、組織の目標達成のための戦略的な活動として捉えることが重要です。BBCや航空会社の事例が示すように、適切なドメイン境界は組織の革新能力と開発効率を大きく向上させます。今後、マイクロサービスアーキテクチャの普及とともに、この課題の重要性は更に増すでしょう。私たちアーキテクトは、この章で示された原則と手法を実践に活かしながら、組織の持続的な進化を支援していく必要があります。10 Strategic IT portfolio第10章「Strategic IT portfolio」は、アーキテクチャ現代化における戦略的なIT投資の重要性とその実践方法について論じています。著者はアーキテクチャをポートフォリオとして捉え、ビジネス価値に基づいた投資判断を行うことの重要性を示し、その具体的なアプローチを提示しています。良い戦略、悪い戦略 (日本経済新聞出版)作者:リチャード・Ｐ・ルメルト日経BPAmazon戦略的ITの本質Martin Fowlerが提唱する「Utility versus Strategic IT」の二分法は、ITの戦略的価値を評価する基本的なフレームワークを提供します。ビジネスの差別化に寄与するソフトウェアは戦略的ITとして、単なるビジネスコストとしてのソフトウェアはユーティリティITとして分類されます。私の経験でも、この分類は実践的な価値があります。ある物流企業のプロジェクトでは、貨物の積載最適化や動的なETA計算の機能は戦略的ITとして位置付けられました。これらの機能は競合他社との差別化につながり、顧客維持率と運用効率の向上に貢献しました。一方で請求システムはユーティリティITとして扱われ、より洗練された機能を追加しても市場での優位性にはつながらないと判断されました。特に重要なのは、この分類が単なる理論的な枠組みではなく、具体的な投資判断と運用モデルの指針となる点です。チームの規模、メンバー構成、コラボレーションの方法、優先順位付け、アーキテクチャの選択など、多くの実務的な意思決定に影響を与えます。私の経験では、この分類を明確にすることで、組織全体の方向性が揃い、より効果的な資源配分が可能になりました。コアドメインチャートの活用著者は戦略的ITの評価ツールとして「Core Domain Charts」を提案しています。Figure 10.4に示されるように、このツールはビジネスの差別化度とモデルの複雑性という2つの軸でドメインを評価します。特に重要なのは、この評価が単なる分類に留まらず、投資判断と運用モデルの具体的な指針となる点です。Figure 10.4 A blank Core Domain Chart より引用電子スクーター企業の事例（Figure 10.5）は、このアプローチの実践を示しています。配車計画のドメインは高い差別化可能性と複雑性を持つため、コアドメインとして位置付けられました。このドメインには長期的な投資とシニアエンジニアの配置、高度なアーキテクチャパターンの採用が必要とされました。Figure 10.5 Core Domain Chart for the hypothetical shared scooter company より引用モデルの複雑性の評価には、ユーザーニーズの発見、製品設計、ドメインモデル設計、ソフトウェアの実装と進化、運用サポートなど、多面的な要素が含まれます。私の経験では、この包括的な評価アプローチにより、技術的な観点だけでなく、ビジネス価値の創出に必要な投資の全体像を把握することが可能になりました。戦略的パターンの認識著者は、コアドメインチャート上に現れる典型的なパターンとその含意を解説しています。特に興味深いのは決定的コア（Decisive Core）と隠れたコア（Hidden Core）の概念です。決定的コアは高い差別化と複雑性を持ち、市場での決定的な優位性をもたらす可能性を持ちます。隠れたコアは、ソフトウェア外の複雑性をソフトウェア化することで戦略的価値を生み出せる可能性がある領域です。また、疑わしいサポート（Suspect Supporting）というパターンは、差別化度が低いにも関わらず高い複雑性を持つドメインを示します。このパターンは多くの場合、技術的負債の蓄積を示唆しており、複雑性の低減が必要となります。私のプロジェクトでも、このパターンの特定が技術的負債への取り組みの優先順位付けに役立ちました。継続的な進化の重要性Vintedの事例は、戦略的ITポートフォリオの継続的な進化の重要性を示しています。カテゴリー管理という一見単純な領域が、実は戦略的な価値を持つコアドメインであることが、Core Domain Chartsを通じて明らかになりました。この発見は、組織の投資判断と技術戦略に大きな影響を与えました。特に注目すべきは、この発見が製品戦略との整合性を取る過程で得られた点です。ドメインの境界や技術的な実装の選択は、より大きな戦略的文脈の中で決定される必要があります。私の経験でも、技術的な決定を製品戦略と結びつけることで、より説得力のある提案が可能になりました。まとめ第10章は、アーキテクチャ現代化における戦略的な投資判断の重要性と、その実践的なアプローチを提供しています。特に重要なのは、アーキテクチャをポートフォリオとして捉え、ドメインごとに適切な投資と運用モデルを選択する視点です。この章で示された手法と知見は、現代のソフトウェア開発組織が直面する課題に対する具体的な解決策となります。私たちアーキテクトは、これらの知見を活かし、技術的な卓越性だけでなくビジネス価値の創出を重視した戦略的な判断を行っていく必要があります。特に、Core Domain Chartsを活用した投資判断の枠組みは、組織の現代化戦略を具体化する上で重要なツールとなるでしょう。11 Team Topologies第11章「Team Topologies」は、アーキテクチャ現代化における組織とソフトウェアの共進化の重要性に焦点を当てています。著者はMatthew SkeltonとManuel Paisが提唱するTeam Topologiesのフレームワークを基に、独立した価値ストリームを実現するためのチーム設計と進化のアプローチを提示しています。チームトポロジー　価値あるソフトウェアをすばやく届ける適応型組織設計作者:マシュー・スケルトン,マニュエル・パイス日本能率協会マネジメントセンターAmazonチーム設計の基本原則効果的なアーキテクチャ現代化には組織とソフトウェアの共同最適化が不可欠です。Figure 11.1が示すように、チーム間の依存関係の最小化とフローの最大化は現代化の中核的な課題です。Figure 11.1 Refining and validating domain boundaries with Team Topologies より引用私の経験でも、チーム構造とアーキテクチャの不整合は深刻な問題を引き起こします。以前関わったある金融機関のプロジェクトでは、チーム間の境界が不明確だったため、同じコードベースに複数のチームが介入し頻繁な調整が必要になりました。結果として、小さな変更にも数週間の時間を要する状況に陥りました。Team Topologiesは持続可能な高速フローを実現するための原則を提供します。この持続可能性が重要です。私が経験した多くの組織では、短期的な速度を追求するあまり技術的負債を蓄積し、最終的にはフローが著しく低下する結果となりました。 speakerdeck.com4つのチームタイプと3つの相互作用モードFigure 11.3は、Team Topologiesが提唱する4つのチームタイプを示しています。ストリーム整合型チームは製品機能の開発に直接関わり、プラットフォームチームは共通基盤を提供します。複雑サブシステムチームは特殊な専門知識を要する領域を担当し、イネーブリングチームは他のチームの成長を支援します。Figure 11.3 The four team types of Team Topologies より引用チーム間の相互作用には3つのモードがあります。コラボレーションは共通の目標に向けて密接に協力する形態で、X-as-a-Serviceは一方のチームが他方のサービスを利用する形態です。ファシリテーションは一時的な支援を提供する形態となります。私の実践では、これらのパターンを固定的に捉えるのではなく、状況に応じて柔軟に組み合わせることが重要でした。特に、プラットフォームチームとストリーム整合型チームの関係は、初期段階では密接なコラボレーションを行い、gradually X-as-a-Serviceに移行していく例が多くありました。コグニティブロードの管理Figure 11.2は、コグニティブロードの観点からチーム境界を評価する方法を示しています。内在的認知負荷はタスクの本質的な複雑さを、外在的認知負荷は環境要因による追加の負荷を、学習的認知負荷は新しい概念の習得に関する負荷を表します。Figure 11.2 Identifying potential high cognitive load on a Core Domain Chart より引用私の経験では、特に外在的認知負荷の管理が重要です。以前参加したプロジェクトでは、レガシーコードの複雑性により、新機能の開発に必要な本質的な作業以外の負荷が大きく、チームの生産性が著しく低下していました。この問題に対し、段階的なリファクタリングと適切なドメイン境界の設定で改善を図りました。チームの進化と再編成著者は、チーム構造を静的なものではなく、継続的に進化するものとして捉えています。Figure 11.10に示されるDiscover to Establishパターンは、その典型的な例です。新しい領域での探索段階では密接なコラボレーションを行い、理解が深まるにつれて相互作用のモードを変化させていきます。Figure 11.10 The discover to establish pattern より引用Heidi HelfandのDynamic Reteamingの概念も重要です。チームの構成は固定的であってはならず、組織の成長、新しい優先順位の発生、知識の共有、学習機会の創出などの理由で適切に変化させる必要があります。私のプロジェクトでも、月次でのメンバーの交代を制度化し、知識の共有と新鮮な視点の導入を図りました。独立した価値ストリームの検証独立した価値ストリームの実現には、Independent Service Heuristics (ISH)が有効です。このツールは、ビジネスインパクト、プロダクト決定の自律性、チームの認知負荷、コスト追跡、依存関係などの観点から、価値ストリームの独立性を評価します。私の経験では、ISHは特にレガシーシステムの現代化において有効でした。ある製造業のプロジェクトでは、ISHを使用して複数の候補となる価値ストリームを評価し、最も効果的な現代化の開始点を特定することができました。コンウェイの法則への対応コンウェイの法則は、組織のコミュニケーション構造がソフトウェアアーキテクチャに反映されることを示しています。著者は、この法則を避けるのではなく、積極的に活用することを提案しています。私が経験した失敗例では、マーケティング部門とIT部門の対立関係がアーキテクチャの複雑化を招いた事例があります。両部門の協力関係の欠如が、データの同期やシステムの整合性の問題を引き起こしました。この経験から、組織構造とアーキテクチャの整合性を意識的に設計することの重要性を学びました。フロントエンドとバックエンドのチーム構成著者は、フロントエンドとバックエンドのチーム構成について、3つの主要なパターンを提示しています。一つ目は「フロントバックチーム」パターンで、各チームがUIとバックエンドの両方を担当します。このパターンでは、一つの機能に関する変更を単一のチームで完結できる利点があります。二つ目は「ドメインごとの専門チーム」パターンです。フロントエンドチームとバックエンドチームは存在しますが、特定のドメイン領域に特化しています。これにより、ドメインの専門性を維持しながら、技術的な専門性も確保できます。三つ目は「完全分離」パターンです。フロントエンド開発を担当するチームとバックエンド開発を担当するチームが完全に分かれています。このパターンでは、技術的な専門性は高まりますが、機能開発時のチーム間調整コストが増大します。私の経験では、この選択は技術的な観点だけでなく、チームメンバーのキャリア志向や組織の文化も考慮する必要があります。ある製品開発組織では、フロントエンドとバックエンドの完全な分離を採用し、専門性の向上を図りましたが、コミュニケーションコストの増大という代償を払うことになりました。特に新機能の開発時には、フロントエンド・バックエンド間のインターフェース設計に多くの時間を要することになりました。まとめTeam Topologiesは、アーキテクチャ現代化における組織とソフトウェアの共進化のための実践的なフレームワークを提供しています。特に重要なのは、チーム構造を静的なものではなく、ビジネスの進化に応じて継続的に適応させていく視点です。私たちアーキテクトは、技術的な設計だけでなく、組織の構造とその進化にも注意を払う必要があります。特に、チームの認知負荷の管理、適切な相互作用モードの選択、そして組織全体としての学習能力の向上が、現代化の成功には不可欠です。この章で示された原則とパターンは、現代のソフトウェア開発組織が直面する複雑性に対する具体的な解決策となります。ただし、これらのパターンを機械的に適用するのではなく、組織の文脈に応じて適切にカスタマイズし、継続的に改善していくことが重要です。著者の提案する「持続可能な高速フロー」という概念は、短期的な生産性と長期的な健全性のバランスを取る上で、私たちに重要な示唆を与えています。アーキテクトとして、この視点を常に意識しながら、組織とアーキテクチャの共進化を導いていく必要があるでしょう。12 Loosely coupled software architecture第12章「Loosely coupled software architecture」は 独立した価値ストリームを実現するために不可欠な疎結合アーキテクチャについて論じています。この章を通じて著者は結合度という抽象的な概念を具体的な設計原則へと落とし込み ソフトウェアアーキテクトが実践で活用できる知見を提供しています。A Philosophy of Software Design, 2nd Edition (English Edition)作者:Ousterhout, John K. Amazon改訂新版　良いコード／悪いコードで学ぶ設計入門 ―保守しやすい　成長し続けるコードの書き方作者:仙塲 大也技術評論社Amazon結合度の本質と戦略的重要性著者は結合度を「一方のコンポーネントが他方のコンポーネントについてどれだけ知っているか」という観点から整理しています。Vlad Khononovの分類によれば 結合度は強い順に「侵襲的結合」「機能的結合」「モデル結合」「契約的結合」の4種類に分類されます。この分類は従来の抽象的な結合度の議論を具体的な評価基準へと昇華させた点で 実務上極めて有用です。最も強い結合である侵襲的結合では プライベートメソッドへのアクセスやデータベーススキーマの共有など あらゆる内部詳細が露出します。この状態では変更の影響範囲が予測不可能となり リスクの高い変更を強いられます。その一方で最も弱い契約的結合では インターフェイスを介した相互作用のみが許可されます。内部の実装詳細が隠蔽されているため 変更の影響を最小限に抑えることができます。Figure 12.1 This chapter covers the software architecture aspect of independent value streams. より引用Figure 12.1 はこれらの結合タイプが価値ストリームの独立性に与える影響を視覚的に表現しています。結合度が強いほどリスクが高くなり 弱いほど安全な変更が可能になることを明確に示しています。特に注目すべきは契約的結合の効果です。インターフェイスの背後にある実装は自由に変更できるため 迅速な進化が可能となります。局所的複雑性と大域的複雑性のバランスアーキテクチャ設計において 著者は局所的な複雑性と大域的な複雑性のバランスを取ることの重要性を指摘しています。マイクロサービス開発の初期には「100行以下のシンプルなサービス」という極端な設計指針が提唱されることがありました。しかしこのアプローチは局所的な複雑性を下げる一方で システム全体の複雑性を大幅に増大させる結果となりました。Figure 12.5 Balancing local and global complexity より引用Figure 12.5 は局所的複雑性と大域的複雑性のトレードオフを示しています。サービスを小規模に保つことで理解や変更は容易になりますが その分サービス間の相互作用が増加し システム全体の複雑性は増大します。私の経験でも 極端な分割は必ずしも最適な選択ではありませんでした。あるプロジェクトでは データの同期や整合性維持のために大量のボイラープレートコードが必要となり 結果として開発者の生産性を低下させる事態となりました。著者はVlad Khononovのフレームワーク「Pain = Strength * Volatility * Distance」を用いて このトレードオフを定量的に評価することを提案しています。このフレームワークは結合の強さ 変更頻度 社会的・技術的な距離という3つの要素から結合がもたらす痛みを評価します。これにより アーキテクト間で客観的な議論が可能となります。アーキテクチャフローのモデリング手法著者は EventStorming Domain Message Flow Modeling Software Design EventStormingといった視覚的なモデリング手法を紹介しています。これらの手法は複数のサブシステム間の相互作用を可視化し 結合度を評価・改善するための効果的なツールです。Eric Evansが提唱するモデル探索の渦巻きは ドメインモデルを継続的に評価・改良するプロセスを示しています。具体的なシナリオをもとに視覚的なモデリングを行い 必要に応じてコードの検証も実施します。私は特にこのアプローチを評価しています。抽象的な議論では見落とされがちな実装上の課題が 具体的なシナリオを通じて早期に発見されるためです。Domain Message Flow Modelingの事例として オンライン車両販売プラットフォームの検査プロセスが示されています。ユーザーの行動に基づいてイベントとコマンドを特定し ドメイン概念とデータフローを可視化します。特に重要なのはイベントとコマンドの使い分けです。コマンドは送信者が次のアクションを決定するのに対し イベントは受信者が判断を行います。このように意思決定の所在を明確化することで 将来の変更容易性が向上します。サブシステム設計の実践著者は個々のサブシステムの設計を評価するためのツールとして Bounded Context Canvas を提案しています。このキャンバスは名前 説明 戦略的分類 ドメインロール コミュニケーションパターンなど 8つのセクションでサブシステムを多面的に評価します。私の実践では このキャンバスを使うことでステークホルダー間の認識の齟齬を早期に発見できました。特に「domain roles」セクションは チームの責任範囲を明確化する上で有効でした。また「inbound/outbound communication」セクションは 依存関係の可視化に役立ち 不必要な結合の特定を容易にしました。より詳細な設計フェーズでは Software Design EventStorming が効果的です。この手法は従来のEventStormingにアグリゲートという概念を追加し より実装に近いレベルでモデリングを行います。視覚的な表現により 関係者全員がドメインモデルを共有・議論することが可能となります。サブシステムの現代化戦略著者は現代化戦略を選択するためのフレームワークとして Modernization Strategy Selector を提示しています。このフレームワークは行動の変更とテクノロジーの変更という2つの軸でモダナイゼーション戦略を評価します。行動の変更は既存機能の修正や新機能の追加を テクノロジーの変更はインフラストラクチャやプログラミング言語の刷新を表します。このフレームワークにより ROIを最大化する現代化アプローチを特定することが可能となります。移行パターンとしては Strangler Fig Pattern Bubble Pattern Autonomous Bubble Pattern などが紹介されています。Strangler Fig Patternでは 新しいシステムが既存のモノリスを徐々に包み込んでいきます。ルーティングコンポーネントがリクエストを振り分け 新しい機能は現代化されたサブシステムで処理します。一方 Bubble Patternでは 新しいサブシステムを既存システムの前に配置し アンチコラプションレイヤーを通じて古いシステムと統合します。さらに進化したAutonomous Bubble Patternでは 新しいサブシステムが独自のデータストアを持ち 非同期のデータ同期で既存システムと連携します。私の経験では Strangler Fig Pattern が最も実践的でした。段階的な移行が可能なため リスクを最小限に抑えながら現代化を進めることができました。まとめ本章は疎結合アーキテクチャの理論と実践を包括的に扱っています。特に価値があるのは 抽象的な概念を具体的な評価基準とツールセットへと変換している点です。Vlad Khononovの結合度フレームワークは結合の影響を定量的に評価する基準を提供し さまざまなモデリング手法は結合度を視覚化・改善するための実践的なアプローチを示しています。アーキテクトとして私が特に注目しているのは 局所的複雑性と大域的複雑性のバランスです。極端な分割や過度の統合を避け 組織の文脈に応じた適切なバランスを見出すことが重要です。また 現代化戦略の選択においては ROIを最大化する移行パターンの特定が鍵となります。結合度の設計はソフトウェアアーキテクチャの根幹をなす課題です。本章で示された原則とツールセットは この課題に対する実践的な解決策を提供しています。今後のソフトウェア開発において これらの知見はますます重要性を増すでしょう。13 Internal developer platforms第13章「Internal developer platforms」は アーキテクチャ現代化における開発者体験の重要性から始まり 独立した価値ストリームを実現するためのプラットフォーム戦略 そして 組織全体での効果的なプラットフォーム運用に至るまで 幅広いトピックをカバーしています。この章を通じて著者は組織がいかに優れたIDPを構築し 継続的なイノベーションを実現できるかを示しています。この資料は秀逸なので読んでほしいです。 speakerdeck.com自分のブログもこちらに添えさせていただきます。syu-m-5151.hatenablog.com開発者体験の本質著者は優れた開発者体験(DX)を独立した価値ストリームの基盤として位置付けています。最も重要なのはチームが価値創造に集中できる環境を整備することです。私の経験でも 多くの組織で開発者は本質的ではない作業に時間を取られすぎています。ある企業では新しいサービスの立ち上げに数週間を要し その大半がインフラ構築やCI/CDパイプラインの設定に費やされていました。単なる開発効率の改善だけでなく イノベーションの速度も重要な指標です。ある金融機関では 新機能のリリースに数ヶ月を要していましたが その大半は手作業による検証とデプロイメントプロセスでした。IDPの導入後は これらのプロセスが自動化され リリースサイクルは週単位まで短縮されました。結果として 競合他社に先駆けた新機能の展開が可能となりました。現代の開発者体験に求められる要件は厳格です。著者は新規アプリケーションを1日以内にプロダクションまで到達させることを基準として挙げています。これはHMRCのMDTPプラットフォームの事例で示されるように 実現可能な目標です。MDTPでは60以上のチームが日次デプロイメントを実現し 新規サービスの立ち上げも数分で完了できました。私の実践では セルフサービス化が鍵となります。あるEコマース企業では 各種リソースの作成やデプロイメントに毎回プラットフォームチームへの依頼が必要でした。この非効率な状況を改善するため AWSのようなセルフサービスモデルを参考に プラットフォームを再設計しました。その結果 開発チームは必要なときに即座にリソースを利用できるようになり 生産性が大幅に向上しました。Figure 13.1 The role of IDPs in enabling independent value streams より引用Figure 13.1は開発者体験とIDPの関係性を示しています。IDPは開発者の認知負荷を軽減し 価値創造に集中できる環境を提供します。これは単なる技術的な問題ではなく 組織の競争力に直結する戦略的な課題です。プラットフォームの基本能力著者は効果的なIDPが備えるべき能力として ゴールデンパス ビルド・デプロイパイプライン 可観測性 アプリケーションカタログなどを挙げています。中でも重要なのはゴールデンパスです。これは新規アプリケーション作成のための自動化された手順を提供します。可観測性の実現も重要な要素です。私が関わった製造業のプロジェクトでは 本番環境でのトラブルシューティングに多大な時間を要していました。OpenTelemetryを活用した統合的な監視基盤を整備することで 問題の特定と解決が格段に効率化されました。さらに プロアクティブな性能改善も可能となり システムの安定性が向上しました。Figure 13.2 Paved road for creating a new microservice and pushing to production in just a few hours より引用Figure 13.2は英国のネオバンクにおけるゴールデンパスの実装例を示しています。彼らは2000以上のマイクロサービスを運用しながら 数時間でプロダクションへのデプロイを実現しています。このような俊敏性は標準化された技術スタックと自動化された開発フローによって支えられています。私の実務経験でも ゴールデンパスの価値は明らかでした。あるプロジェクトでは Spring Boot ベースのマイクロサービステンプレートを整備し デプロイメントパイプラインやモニタリングの設定を自動化しました。その結果 新規サービスの立ち上げ時間は2週間から2時間へと劇的に短縮されました。アプリケーションカタログの整備も重要です。ある大規模組織では 類似機能を持つAPIが複数存在し 運用コストの増大を招いていました。Backstageを活用したカタログ整備により APIの可視性が向上し 再利用が促進されました。結果として 開発コストの削減と品質の向上を実現できました。プラットフォーム運用の実践著者はIDPをプロダクトとして扱うことの重要性を強調しています。これは単なる技術的なインフラストラクチャではなく 継続的に進化するサービスとして捉える必要があります。La Redouteの事例は この考え方を実践的に示しています。プロダクトマインドセットの具体的な実践として 定期的なフィードバックの収集があります。私のチームでは四半期ごとに開発者満足度調査を実施し その結果をプラットフォームの改善計画に反映しています。また 月次のプラットフォームユーザー会を開催し 開発者との直接対話の機会を設けています。彼らはプラットフォーム運用において 品質 効率性 スピードの3つの指標を重視しました。特筆すべきは プラットフォームチームが開発者を顧客として扱い その体験を継続的に改善していた点です。これは私が経験した多くのプラットフォームチームとは異なるアプローチでした。セキュリティとコンプライアンスの統合も重要な課題です。ある金融機関では セキュリティ要件の充足に多大な工数を要していました。IDPにセキュリティチェックを組み込むことで この問題を解決しました。自動化されたコードスキャンと監査ログの生成により コンプライアンス対応が効率化されました。プラットフォーム運用で重要なのは標準化と柔軟性のバランスです。MDTPの事例では Scala と Play Framework への強い標準化により 高度な自動化を実現しました。一方でNetflixは より柔軟なアプローチを採用し チームの技術選択の自由度を高く保っています。プラットフォームチームの構成も成功の鍵となります。私の経験では エンジニアリングスキルとプロダクトマインドセットを併せ持つ人材が必要です。また サポート担当とプラットフォーム開発者を分離し それぞれが専門性を発揮できる体制を整えることも有効でした。投資判断の指針著者は最小限の実行可能なプラットフォーム(TVP)という概念を提示しています。これは大規模なビッグバンプロジェクトを避け 必要最小限の機能から始めることを推奨します。私も同意見です。過去に関わった大規模なプラットフォーム構築では 2年の開発期間を経ても利用率が低く 投資対効果の説明に苦慮した経験があります。プラットフォーム構築の判断基準として 著者は組織の規模だけでなく採用可能性も重視します。技術スタックの強制や既存システムからの移行コストが高い場合 プラットフォームは形骸化するリスクがあります。実践的なアプローチとして 段階的な展開が有効です。あるプロジェクトでは まずCI/CDパイプラインの標準化から着手し その価値が認められた後に他の機能を順次追加していきました。このアプローチにより 投資対効果の可視化と関係者の合意形成が容易になりました。ビルドvs購入の判断も重要です。市場には様々なプラットフォームソリューションが存在します。私の経験では 汎用的な機能は既存ソリューションを活用し 組織固有のニーズに対応する部分のみを内製する戦略が効果的でした。まとめ本章はIDPの構築と運用に関する包括的な指針を提供しています。特に価値があるのは開発者体験を中心に据えたアプローチです。プラットフォームチームは技術的な卓越性だけでなく サービスマインドセットを持つことが求められます。今日のソフトウェア開発において IDPは組織の競争力を左右する重要な要素となっています。しかしその構築には慎重な判断と継続的な投資が必要です。プラットフォーム構築を検討する組織は まず最小限の機能から始め 利用状況と価値創出を確認しながら段階的に発展させていくアプローチを採用すべきでしょう。重要なのは IDPを単なるツール群としてではなく 組織の開発生産性とイノベーション能力を高めるための戦略的資産として位置付けることです。その成功は技術的な選択だけでなく 組織文化や人材育成を含めた包括的なアプローチにかかっています。優れたIDPは 開発者が本質的な価値創造に集中できる環境を提供し 組織全体のイノベーション能力を高めます。今後も クラウドネイティブ技術の進化や開発手法の多様化に応じて IDPの重要性は増していくでしょう。アーキテクトとして この領域への深い理解と実践的な経験がますます求められています。14 Data mesh revolutionizing data engineering第14章「Data mesh revolutionizing data engineering」は データ管理の基本概念とその進化から始まり データメッシュの4つの原則とその実践 そしてデータ量子という革新的な概念の導入に至るまで データエンジニアリングの現代化に関する包括的な内容を提供しています。この章を通じて 著者は従来のデータ管理手法の限界と それを克服するためのデータメッシュアーキテクチャの可能性を示しています。syu-m-5151.hatenablog.comデータエンジニアリングの変遷と課題著者はまず データエンジニアリングの歴史的な変遷を振り返ります。1971年のCoddによるリレーショナルデータベースの提案から データウェアハウス データレイクに至る進化を辿っています。私も同様の変遷を経験してきましたが 各段階で新たな課題が生まれていく様子を興味深く見てきました。Figure 14.1 A data warehouse and some of its ingestion process より引用Figure 14.1は データウェアハウスのアーキテクチャを示しています。自動車部品小売企業の例では 顧客情報やトランザクションデータが複数のプロセスに分割され 新しい要件への対応に多大な労力を要します。例えば ロイヤリティプログラムの追加には新たなプロセスの構築が必要となり 既存のデータフローにも影響を与えます。一方 データレイクは データ取り込みの簡素化を実現しましたが 新たな課題を生み出しました。データの民主化という理想は データアクセスの複雑さという現実に直面します。私のプロジェクトでも データレイクの導入により データの取り込みは容易になりましたが データサイエンティストが必要なデータを見つけ出し 適切な形式に変換するまでに多大な時間を費やす状況が続きました。私の経験では この両者の問題は 中央集権的なチーム構造に起因することが多いです。ドメイン知識のないチームが全社的なデータパイプラインを管理するため 変更に対する柔軟性が失われていきます。あるプロジェクトでは 新しい分析要件に対応するために3ヶ月もの調整期間を要しました。この状況は データエンジニアの生産性とビジネスのアジリティを著しく低下させます。データメッシュの4つの原則著者は データメッシュを支える4つの原則として ドメイン所有権 プロダクトとしてのデータ セルフサービスプラットフォーム 連邦型計算ガバナンスを挙げています。これらは単なる技術的な原則ではなく 組織構造とアーキテクチャの共進化を促す指針です。ドメイン所有権は ビジネスドメインの専門家とデータアーキテクトを結びつけます。私のプロジェクトでも この原則の導入により データ品質が大幅に向上しました。ドメイン専門家が直接データの定義と品質基準に関与することで より適切なデータモデルの構築が可能になりました。例えば ある製造業のプロジェクトでは 工場のエンジニアと直接協働することで 生産データの品質基準を現場の実態に即して定義できました。プロダクトとしてのデータは 従来のプロジェクトベースのアプローチからの大きな転換を意味します。著者は DAUNTIVSという原則を提示し データプロダクトが持つべき特性を説明しています。これは 発見可能性 アドレス可能性 理解可能性 ネイティブなアクセス可能性 信頼性と真実性 相互運用性と組み合わせ可能性 価値 セキュリティを表します。Figure 14.4 The data quantum takes the shape of a hexagon, highlighting its multiple endpoints, allowing access to data, metadata, observability, and control. より引用Figure 14.4は データ量子という革新的な概念を示しています。これは従来のモノリシックなデータレイクとは異なり ドメイン単位で分割された最小のデプロイ可能な要素です。私の経験では この粒度の設定が成功の鍵となります。ある金融機関では 顧客データを過度に細分化したため 管理コストが増大し パフォーマンスも低下しました。適切な粒度を見出すには ビジネス要件とシステムの複雑性のバランスを慎重に検討する必要があります。データ契約の重要性著者はデータ契約をデータメッシュの中核的な要素として位置付けています。これは単なるスキーマ定義ではなく データプロダクトの振る舞いを定義する包括的な文書です。データ契約には 基本的な要素や論理・物理スキーマ データ品質ルール ガバナンスポリシー SLAなどが含まれます。私の実践では データ契約の導入により チーム間のコミュニケーションが大幅に改善されました。特にデータ品質とガバナンスの要件を明確に定義できる点は 規制要件の厳しい金融業界で重要な価値を持ちます。あるプロジェクトでは データ契約をGitで管理し 変更履歴を追跡可能にすることで コンプライアンス要件への対応も容易になりました。しかし データ契約の策定と維持には相応のコストがかかります。経験上 契約の粒度と更新頻度のバランスが重要です。過度に詳細な契約は維持コストを増大させ 逆に粗すぎる契約は価値を失います。私たちは 四半期ごとのレビューサイクルを設定し 継続的な改善を図っています。実装アプローチと経験プレーン著者は データメッシュの実装を3つの経験プレーンで構造化しています。インフラストラクチャ経験プレーンは基盤となるインフラストラクチャを提供し データプロダクト経験プレーンはデータプロダクトの管理を担当します。そしてメッシュ経験プレーンがこれらを統合し 全体としての価値を生み出します。実装において重要なのは サイドカーパターンの活用です。共通のサービスやライブラリをサイドカーとして実装することで 再利用性が高まり 開発効率が向上します。私のプロジェクトでは このアプローチにより 新規データプロダクトの開発期間を約40%削減できました。具体的には 認証 ログ収集 メトリクス収集などの共通機能をサイドカーに集約し 各データプロダクトはビジネスロジックに集中できる環境を整備しました。データ量子の実装では ディスカバリー＆ディクショナリーサービス オブザーバビリティサービス コントロールサービス データオンボーディング 相互運用可能なデータという5つのコンポーネントを適切に構成する必要があります。特に重要なのは オブザーバビリティの実現です。データの品質や可用性を継続的にモニタリングすることで 問題の早期発見と対応が可能になります。まとめデータメッシュは 単なる技術的なアーキテクチャパターンを超えて データエンジニアリングの組織的な変革を促す枠組みを提供しています。4つの原則は それぞれが相互に依存し補完し合う形で 全体としての価値を生み出します。私の経験では 最も重要なのは段階的な導入アプローチです。小規模なパイロットから始め 成功事例を積み重ねていくことで 組織全体の変革を推進できます。また データ契約の整備と標準化は 長期的な成功の鍵となります。具体的には まず重要度の高いのドメインを選定し そこでの成功体験を組織全体に展開していく戦略が効果的です。データメッシュの導入には 技術的な課題だけでなく 組織的な課題も存在します。特に重要なのは データプロダクトオーナーシップの確立です。ビジネスドメインの専門家がデータの品質と価値に責任を持つ文化を醸成することが 成功への近道となります。現代のデータ駆動型組織において データメッシュは避けては通れないトレンドとなっています。その成功は技術的な選択だけでなく 組織文化の変革とチームの自律性を含めた包括的なアプローチにかかっています。アーキテクトとして 技術的な深さと組織的な視点の両方を持ち合わせることが 今後ますます重要になっていくでしょう。データメッシュの導入を検討する組織には まず現状の課題を明確に特定し 段階的な移行計画を立てることを推奨します。特に重要なのは 早期の価値創出です。小さな成功を積み重ねることで 組織全体の変革モメンタムを維持できます。また 継続的な学習と改善のサイクルを確立し データメッシュの進化に合わせて組織も成長していく体制を整えることが 長期的な成功につながります。15 Architecture modernization enabling teams第15章「Architecture modernization enabling teams」は アーキテクチャ現代化を支援するチーム（AMET）の設立から その役割と進化 そして組織への長期的な影響に至るまで アーキテクチャ現代化のための組織的なアプローチを包括的に論じています。この章を通じて 著者は単なる技術的な改善を超えて 持続可能な組織の変革を実現するためのフレームワークを提示しています。スイッチ！作者:チップ・ハース,ダン・ハース早川書房AmazonAMETの本質と目的著者はAMETを 現代化のモメンタムを維持し 長期的な組織変革を実現するための触媒として位置付けています。私の経験でも アーキテクチャ現代化の最大の課題は技術的な側面ではなく 組織全体での持続的な改善の実現にあります。Figure 15.1 An AMET is an enabling team that facilitates stream-aligned teams (and other stakeholders) during the modernization journey. より引用Figure 15.1は AMETの基本的な役割を示しています。AMETは単なる技術指南役ではなく ストリーム整合型チームとその他のステークホルダーを支援し 組織全体の現代化能力を向上させる役割を担います。この点は極めて重要です。過去に関わったプロジェクトでは 技術的に優れたアーキテクトが指示を出すだけのケースがありましたが それでは真の組織的な成長は実現できませんでした。AMETの主要な責任は6つの課題に対応することです。取り組みの開始 モメンタムの維持 より良い設計の実現 持続的な変化の促進 ビジョンと進捗の共有 そして成功事例と学びの共有です。私の経験では 特にモメンタムの維持が重要です。ある組織では 最初の数ヶ月は順調に進んでいたものの 日常業務の圧力で現代化への取り組みが停滞しました。この事態を打開するため AMETがワークショップを開催し 現代化の価値を再確認する機会を設けました。その結果 チームの士気が回復し 取り組みを継続できました。ソフトウェアアーキテクチャメトリクス ―アーキテクチャ品質を改善する10のアドバイス作者:Christian Ciceri,Dave Farley,Neal Ford,Andrew Harmel-Law,Michael Keeling,Carola Lilienthal,João Rosa,Alexander von Zitzewitz,Rene Weiss,Eoin Woodsオーム社Amazonチームの構成と能力AMETの成功には 適切なスキルセットとマインドセットを持つメンバーの選定が不可欠です。技術的な専門性はもちろんですが それ以上に重要なのはイネーブリングマインドセットです。私はAMETのメンバー選定において この点を特に重視しています。例えば ある大規模な金融機関では 技術的に優れたアーキテクトを集めてAMETを構成しましたが うまく機能しませんでした。彼らは自身の技術的な正しさを主張することに注力し 各チームの状況や制約を理解しようとしませんでした。結果として チーム間の対立が生まれ 現代化の取り組み全体が停滞しました。一方で 成功事例もあります。ある製造業のプロジェクトでは AMETのメンバーが各チームと定期的な1on1を実施し 信頼関係の構築に注力しました。また 技術的な課題に直面したチームに対して 解決策を押し付けるのではなく 一緒に考えるアプローチを採用しました。この結果 チーム間の協力関係が強化され 現代化の取り組みが加速しました。Figure 15.5 AMET involvement decreases as the organization upskills より引用Figure 15.5は AMETの関与度が組織のアーキテクチャ能力の向上とともに変化していく様子を示しています。初期段階では強いリーダーシップを発揮し 徐々にその役割を変化させていくことが重要です。私のプロジェクトでも この段階的なアプローチが効果的でした。最初は具体的な指示を出していましたが チームの能力が向上するにつれて アドバイザリーな立場へと移行していきました。アーキテクトの教科書 価値を生むソフトウェアのアーキテクチャ構築作者:米久保 剛翔泳社Amazonアーキテクチャ運用モデルの確立AMETの重要な役割の一つは 持続可能なアーキテクチャ運用モデルの確立です。著者は4つのモデルを提示しています。善意の独裁者 第一人者 アーキテクトなしのアーキテクチャ そして囚人による運営です。これらのモデルは単なる組織構造ではなく アーキテクチャ意思決定の方法を規定する枠組みです。私はこれらのモデルを状況に応じて柔軟に組み合わせることを推奨します。例えば あるプロジェクトでは 初期段階では善意の独裁者モデルを採用し 組織の成熟度が向上するにつれてアーキテクトなしのアーキテクチャへと移行しました。このアプローチにより 初期の方向性の一貫性を保ちながら 長期的な自律性を実現できました。運用モデルの選択では 組織文化との整合性も重要です。ある組織では 高度に自律的な文化があったため 最初から第一人者モデルを採用しました。各チームに一人のアーキテクトを配置し チーム内での意思決定を重視しました。この判断により 現場での迅速な意思決定が可能になり 開発の速度が向上しました。また 意思決定プロセスの明確化も重要です。AMETは組織全体のアーキテクチャ意思決定プロセスを定義し 文書化する必要があります。私のプロジェクトでは Architecture Decision Records (ADR)の活用を推奨し 重要な意思決定の背景と理由を記録する習慣を確立しました。これにより チーム間での知識共有が促進され 一貫性のある意思決定が可能になりました。段階的な導入とスケーリング欧州の通信事業者の事例は AMETの実践的な導入方法を示しています。彼らは外部コンサルタントのJoão Rosaと協力し オペレーティングモデル探索チームを設立しました。このチームは 組織内の多様な視点を持つメンバーで構成され 現代化の方向性を探索する役割を担いました。注目すべきは 段階的なアプローチです。まず特定の領域（例：eコマースとeケア）に焦点を当て 現状の境界とその選択理由を理解することから始めました。この過程でEventStorming Capability Mapping Value Stream Mappingなどの手法を活用し 候補となるドメインとサービスの境界を特定していきました。私の経験でも このアプローチは効果的です。ある小売業のプロジェクトでは まず在庫管理システムの現代化からスタートし そこでの成功体験を基に他の領域へと展開していきました。小さな成功を積み重ねることで 組織全体の信頼を獲得し より大規模な変更への支持を得ることができました。アーキテクチャギルドの活用Comcastの事例は アーキテクチャギルドの効果的な活用を示しています。彼らは分散した技術組織において チャットツールとメーリングリストを活用した非同期のコミュニケーションを重視しました。また ワーキンググループの設立と意思決定プロセスの明確化により 大規模組織での効果的な意思決定を実現しました。私の経験では アーキテクチャギルドの成功には 明確な目的と運営ルールが不可欠です。ある組織では ギルドが単なる情報共有の場となってしまい 実質的な意思決定機能を果たせませんでした。目的とルールを明確化することで より効果的な運営が可能になります。また ギルドの進化も重要です。初期段階では標準化や技術選定に焦点を当てていたギルドが 徐々にイノベーションや知識共有の場へと発展していくケースがあります。この進化を促進するため 定期的なハッカソンや技術カンファレンスの開催を支援することも効果的です。成功のための重要要素著者は AMETの成功には リーダーシップの支援と適切な権限が不可欠だと指摘しています。私も完全に同意します。ある組織では AMETが形式的には設立されたものの 実質的な権限が与えられず 結果として現代化の取り組みが形骸化してしまいました。適切なリソースの確保も重要です。最低でも2名のフルタイムメンバーが必要です。パートタイムのみの構成では 日常業務に埋没してしまい AMETの本来の目的を達成できません。私のプロジェクトでは 3名のフルタイムメンバーと 必要に応じて参加する3名のパートタイムメンバーという構成が効果的でした。また 外部の知見の活用も検討すべきです。ただし 外部コンサルタントへの依存は避ける必要があります。私の実践では 外部の専門家を教育者として活用し 組織内の能力向上を図るアプローチが効果的でした。コミュニケーションとビジョンの共有AMETの重要な役割の一つは 現代化のビジョンと進捗の共有です。これは単なる情報発信ではなく 組織全体の方向性を合わせる重要な活動です。例えば あるプロジェクトでは 月次の全体会議で各チームの成功事例を共有し モチベーションの維持と知見の展開を図りました。また コミュニティの形成も重要です。技術ブログの開設や社内カンファレンスの開催を通じて 現代化に関する知識と経験を共有する場を作ることで 組織全体の能力向上を促進できます。私のプロジェクトでは 四半期ごとの技術カンファレンスが大きな効果を発揮しました。まとめAMETは アーキテクチャ現代化における重要な触媒として機能します。その成功には 適切なメンバーの選定 段階的なアプローチ そして持続可能な運用モデルの確立が不可欠です。ただし AMETは常に必要なわけではありません。組織の状況に応じて その必要性を慎重に判断することが重要です。特に重要なのは AMETを一時的なチームとして捉え その役割を組織に根付かせることです。最終的には AMETという足場を外しても 組織が自律的に現代化を進められる状態を目指すべきです。アーキテクトとして この移行プロセスをいかに効果的に支援できるかが 私たちの重要な責務となります。現代のソフトウェア開発において アーキテクチャの現代化は避けては通れない課題です。AMETは この課題に対する効果的なアプローチを提供します。その成功は 技術的な側面だけでなく 組織文化の変革とチームの自律性を含めた包括的なアプローチにかかっています。私たちアーキテクトは この変革の触媒として その責務を果たしていく必要があります。16 Strategy and roadmaps第16章「Strategy and roadmaps」は、アーキテクチャ現代化の戦略立案から始まり、段階的な実現アプローチ、組織全体への展開、そして継続的な評価と適応に至るまで、包括的な実践的ガイダンスを提供しています。著者は「nail it then scale it」という原則を通じて、大規模な組織変革を実現可能な形へと分解し、確実な成功へと導くアプローチを示しています。この辺は達人プログラマーにもどうようの記載があったなぁって感じています。達人プログラマー ―熟達に向けたあなたの旅― 第2版作者:David Thomas,Andrew Huntオーム社Amazon戦略構築の本質と実践効果的な現代化戦略の最重要要素は、全てのステークホルダーを巻き込む説得力のあるナラティブの構築です。著者は、技術的な負債や再構築といった工学的な用語だけでは、技術部門外の関係者の理解と支持を得ることは難しいと指摘します。この主張は極めて現実的です。私が関わった現代化プロジェクトでも、技術的な議論に終始したケースでは、経営層からの十分な支援を得ることができず、結果として現代化の範囲や速度が制限される事態に陥りました。Figure 16.2 Basic elements of a modernization strategy deck より引用Figure 16.2は戦略デッキの4つの基本要素を示しています。ビジネスコンテキスト、課題と障害、現代化の目的とイニシアチブ、優先順位とロードマップという構成は、論理的で説得力のある物語を紡ぎ出すための効果的な枠組みを提供します。特に重要なのは、これらの要素が単なる構造ではなく、全てのステークホルダーの共感を得るためのストーリーテリングのツールとして機能する点です。戦略デッキの構築で特に注目すべきは、定量的データと感情的要素の組み合わせです。CodeSceneによる技術的負債の可視化やDORAメトリクスによる業界比較といった客観的データに加え、従業員の生の声や具体的なインシデント事例を組み込むことで、より説得力のある物語を構築できます。この手法は特に経営層とのコミュニケーションで効果を発揮します。数値データは意思決定の根拠を提供し、実例や個人の声は課題の切実さを伝えることができます。初期フェーズの戦略的重要性著者は「nail it then scale it」アプローチの一環として、3-6ヶ月以内に最初のスライスを実現することを推奨しています。このタイムフレームは、価値の証明と学習の機会として適切なバランスを提供します。IgluCruise.comのCIO Scott Millettの事例は、この実践的アプローチの有効性を示す好例です。彼らは戦略を具体的な行動に落とし込み、段階的な実現を通じて組織全体の変革を達成しました。Figure 16.7 Hypothetical roadmap for delivering a first slice within six months より引用Figure 16.7は、6ヶ月以内に最初のスライスを実現するための理想的なロードマップを示しています。このアプローチの核心は、実行可能性の高い小さな成功を積み重ねることにあります。私のプロジェクト経験でも、大規模な変革を一度に実現しようとするアプローチは、多くの場合予期せぬ障害に直面し、モメンタムを失うリスクが高いことを実感しています。初期フェーズの成功には、優先順位付けのフレームワークが不可欠です。著者が提案するModernization Core Domain Chartとスコアカードは、複数の候補から最適な開始点を選定するための実践的なツールを提供します。私の実践では、この手法を用いてチーム間で優先順位の議論を行うことで、より客観的で建設的な意思決定が可能になりました。組織全体への展開と課題現代化の展開フェーズでは、プレイブックの活用が重要な役割を果たします。プレイブックは標準的なパターンやプロセスを文書化することで、知識の展開と再利用を促進します。しかし、著者は単なる技術的な手順書以上のものとしてプレイブックを位置付けています。効果的なプレイブックには、選択基準、前提条件、実例、教訓など、実践的な知恵が含まれるべきです。組織全体への展開で特に重要なのが、依存関係の管理です。依存関係の早期特定と適切な評価は、プロジェクトの遅延や追加コストを防ぐ上で重要です。私の経験では、依存関係の管理は技術的な側面だけでなく、組織的なコミュニケーションの課題としても重要です。アーキテクト定例会議やエンジニアリングオフサイトなど、定期的な情報交換の機会を設けることで、潜在的な依存関係を早期に発見できました。mobile.deの事例は、変更コストの概念を用いた投資判断の有効性を示しています。彼らは変更コストを可視化することで、技術的負債への投資の必要性を経営層に説得力を持って説明することに成功しました。この事例は、技術的な課題をビジネス価値と結びつけて説明することの重要性を示しています。継続的な評価と適応著者は、現代化の戦略とロードマップを静的なものではなく、継続的に進化する生きた文書として捉えることの重要性を強調しています。これは極めて重要な指摘です。私のプロジェクト経験でも、初期の計画通りに進まないケースが大半でした。重要なのは、この「ずれ」を失敗とせず、学習と適応の機会として活用することです。Figure 16.1 An evolutionary approach to modernization strategy and roadmaps より引用Figure 16.1が示すように、継続的な学習と適応のサイクルは、現代化の成功に不可欠です。著者は、メトリクス、パルスサーベイ、各種集会など、多様なフィードバック収集の手法を提案しています。特に注目すべきは、定量的指標と定性的フィードバックの組み合わせです。数値指標は客観的な進捗管理を可能にし、定性的なフィードバックは潜在的な課題や改善機会の発見を促進します。組織全体の学習を促進するには、効果的なフィードバックチャネルの確立が重要です。リスニングツアーやワークショップ、定期的なレトロスペクティブなど、様々な形式でのフィードバック収集を組み合わせることで、より包括的な理解と改善が可能になります。私の実践では、四半期ごとの大規模なレトロスペクティブと月次の小規模なフィードバックセッションを組み合わせることで、短期的な調整と長期的な方向性の修正のバランスを取ることができました。まとめ本章は、アーキテクチャ現代化における戦略とロードマップの重要性を、実践的な視点から包括的に論じています。特に価値があるのは、説得力のあるナラティブの構築と段階的な実現アプローチの組み合わせです。これにより、技術的な理想と組織的な現実のバランスを取りながら、持続可能な変革を実現することが可能になります。現代のソフトウェア開発組織において、アーキテクチャ現代化は避けて通れない課題です。本章で示された原則とツールセットは、この課題に対する実践的な解決策を提供しています。特に重要なのは、技術的な側面だけでなく、組織全体の変革という視点で現代化を捉えることです。私たちアーキテクトは、この包括的な視点を持ちながら、組織の持続的な進化を支援していく必要があります。最後に強調したいのは、現代化の成功は継続的な適応と学習のプロセスにあるという点です。完璧な計画を立てることは不可能ですが、早期に価値を証明し、フィードバックを基に継続的に改善していくアプローチにより、確実な成功への道を切り開くことができます。この原則を理解し、実践することが、現代のソフトウェアアーキテクトには求められています。17 Learning and upskilling第17章「Learning and upskilling」は、新しいアイデアの組織への導入から始まり、組織全体での継続的な学習文化の醸成、そして現代化プロジェクトに必要なスキル開発に至るまで、幅広いトピックをカバーしています。著者は、技術的な進歩が人類の歴史において常に重要な役割を果たしてきたという視点から、現代の組織が直面する学習と適応の課題を体系的に論じています。Unlearn（アンラーン）　人生100年時代の新しい「学び」作者:柳川 範之,為末 大日経BPAmazon新しいアイデアの導入と定着著者はシードプランティング（種まき）という比喩を用いて、新しい考え方やプラクティスの導入プロセスを説明します。この比喩は特に印象的です。私の経験でも、新しいアプローチを一朝一夕に導入できた例はほとんどありません。むしろ、小さな成功を積み重ね、組織の中で徐々に理解と支持を広げていくアプローチが効果的でした。PayFitの事例は、このアプローチの有効性を端的に示しています。彼らはDDDの導入において、まず少人数の書籍クラブから始め、その輪を徐々に広げていきました。この過程で興味深いのは、技術者だけでなく、製品やデザインの専門家も巻き込んでいった点です。私も以前、マイクロサービスアーキテクチャの導入で同様のアプローチを採用し、成功を収めました。最初は2-3人の技術リーダーと勉強会を始め、実験的なプロジェクトで成果を示し、その経験を基に組織全体への展開を図りました。プロジェクトニーズに応じたスキル開発現代化プロジェクトの成否は、チームのアップスキリング（スキル向上）にかかっています。著者は、プロジェクト開始前の早期スキル評価と、学習機会の確保の重要性を強調します。私の経験では、この点を軽視したプロジェクトの多くが失敗に終わっています。あるプロジェクトでは、新技術の導入を急ぐあまり十分な学習時間を確保せず、結果として開発の遅延と品質の低下を招きました。学習アプローチの選択では、著者は複数の選択肢を提示します。書籍、トレーニング、メンタリング、実践的な学習など、状況に応じた適切な組み合わせが重要です。私のチームでは、AWS認定試験の取得を目標にした学習プログラムを導入しました。具体的な目標があることで、チームメンバーのモチベーションが高まり、結果として組織全体の技術力向上につながりました。継続的学習環境の確立著者は、継続的な学習を組織のDNAに組み込むことの重要性を強調します。これは極めて重要な指摘です。私が経験した高パフォーマンス組織の多くは、学習を「追加の活動」ではなく「仕事の一部」として位置付けていました。例えば、あるチームでは週次の「ラーニングアワー」を設定し、新技術の調査や実験、ベストプラクティスの共有を行っていました。コミュニティ・オブ・プラクティス（実践コミュニティ）の活用も重要な要素です。著者はEmily Webberの著作を引用しながら、効果的なコミュニティ運営の4つの要件を示します。私の経験では、特に「安全な学習環境の創出」が重要でした。チームメンバーが失敗を恐れずに新しいアイデアを試すことができる環境があってこそ、真の学習と革新が可能になります。CloudSuiteの事例から学ぶ実践CloudSuiteの事例は、現代化における学習主導型アプローチの有効性を示しています。特に注目すべきは、彼らが大規模な計画を立てる前に、まず技術的エクセレンスの確立に注力した点です。私も同様のアプローチで成功を収めた経験があります。ある組織では、マイクロサービスへの移行を進める前に、まずテスト駆動開発とペアプログラミングの習慣を定着させました。これにより、後の大規模な変更をより安全に進めることができました。CloudSuiteの取り組みで特に印象的なのは、ボトムアップ型のドメイン発見プロセスです。彼らは開発者の日常的な課題から出発し、徐々にドメインの理解と境界の特定へと進んでいきました。この事例は、現代化が必ずしもトップダウンの大規模な計画から始める必要がないことを示しています。まとめ本章の最も重要な洞察は、アーキテクチャ現代化における学習とスキル開発が、単なる技術的なトレーニング以上の意味を持つという点です。それは組織文化の変革であり、持続的な改善能力の構築です。特に印象的なのは、著者が歴史的な例（印刷機の発明など）を引用しながら、技術変革における人間の学習と適応の重要性を示している点です。PayFitとCloudSuiteの事例は、現代化における二つの異なるアプローチを示しています。PayFitは書籍クラブという小さな種から組織全体の変革へと発展させ、CloudSuiteは技術的プラクティスの改善から始めて戦略的な変更へと進化させました。これらの事例は、現代化の成功には「正解」となる単一のアプローチは存在せず、組織の文脈に応じた適切な方法を選択する必要があることを示しています。私たちアーキテクトは、技術的な設計だけでなく、組織の学習能力の向上にも注力する必要があります。それは単なるスキルの向上ではなく、組織全体の適応能力と革新能力の向上を意味します。本章で示された原則と事例は、この課題に対する具体的な指針を提供しています。現代化を成功に導くには、技術とヒューマンファクターの両面からのアプローチが不可欠です。おわりに本書の真髄は、アーキテクチャ現代化における「技術」「組織」「戦略」という三つの要素の相互作用と、それらの調和を通じた組織の持続的な競争力の構築にあります。Better Value Sooner Safer Happier (BVSSH)という概念を軸に、技術的な改善、組織的な変革、そして事業戦略の実現を統合的に捉える視座を提供しています。三体問題への実践的アプローチ本書の説得力は、技術・組織・戦略の三要素に対する包括的なアプローチにあります。EventStorming、Wardley Mapping、Team Topologiesなどの手法は、それぞれが実践の場で検証された価値を持ち、三要素の効果的な統合を可能にします。内部開発プラットフォーム(IDP)やデータメッシュといった最新の概念も、この文脈で深い考察が加えられています。IoTデバイスの急増や生成AIの進展など、技術革新の加速度的な進展は、この三体問題をより複雑にしています。本書は、技術的負債による開発者の時間損失や重大なシステム障害の事業影響など、具体的な数値と事例を通じて、この課題の重要性を説得力をもって論じています。持続的な進化のためのフレームワーク「nail it then scale it」という原則に象徴される本書のアプローチは、三体問題に対する実践的な解決策を提示します。3-6ヶ月での最初の成果創出、Architecture Modernization Enabling Team (AMET)の活用、継続的な学習と能力開発の重視など、現代化を持続可能な形で実現するための具体的な方法論が示されています。本書は、アーキテクチャ現代化という課題を通じて、現代システムの三体問題に対する包括的な解答を提供しています。アーキテクトやテクニカルリーダーにとって、本書との出会いは、組織の持続的な進化への確かな指針となるでしょう。2025年もみなさん、最後まで読んでくれて本当にありがとうございます。途中で挫折せずに付き合ってくれたことに感謝しています。読者になってくれたら更に感謝です。Xまでフォロワーしてくれたら泣いているかもしれません。","isoDate":"2025-01-21T03:41:30.000Z","dateMiliSeconds":1737430890000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"なんとなくRustで書いたNeovimプラグイン - cargo.nvim の話","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/15/110831","contentSnippet":"はじめに全てのエンジニアが生成AIやAgentに夢中な2025年。私、nwiizoは今日もNeovimのプラグインを開発しています。今回は、RustのCargoコマンドをNeovimから直接実行できるプラグイン「cargo.nvim」の開発で得た知見を共有したいと思います。🦀 Built cargo.nvim - a Neovim plugin for seamless Rust development. Build & run Rust right in your editor, no terminal switching needed! ⚡️ #Rust #nvimhttps://t.co/YxVJzpYfmv pic.twitter.com/x5yIdpEdVN— nwiizo (@nwiizo) 2025年1月15日   「なぜRustなんだ？」と思われる方もいるかもしれません。正直に言うと、私もその理由を完全には説明できません。ただ、このプラグインを作るとき、「これはRustで書くべきだ」という強い直感がありました。影響ヒューリスティックというか...直感というか...。もちろん、システムプログラミング言語としての堅牢性や、非同期処理の扱いやすさといった技術的な理由もありますが...実はそれ以上に「Rustでプラグインを書くのがかっこいい」という、エンジニアとしてのロマンを追求した結果です。はい、完全にロマン駆動開発です。「なぜ今更vim？」「それAIで解決できないの？」という声が聞こえてきそうですが、私にとってvimプラグイン開発は単なるツール作りではありません。手触り感のあるエンジニアリング、そう呼びたくなる体験なのです。最新のAIが次々と登場する中で、あえて低レイヤーな開発に没頭する。それは、ある意味で技術的なロマンなのかもしれません。エンジニアの仕事はどんどんAIに寄り添うものになっていくでしょう。それは素晴らしいことだと思います。でも、だからこそ、私は基礎となる技術や職人的なクラフトマンシップを大切にしたいと考えています。そんな思いを込めて、今回はRustでvimプラグインを作ってみました。はい、かなり強引な導入ですが...。良ければGitHubでStarをつけていただけると嬉しいです。みなさんの応援が、「なんとなくRustで書いちゃった」この暴挙（？）の正当性を証明してくれる気がします。きっと...たぶん...。github.comちなみにRust のプロジェクトでこういうリポジトリも存在している。github.comプロジェクトの構造まず、cargo.nvimの基本構造を見てみましょう：.├── Cargo.toml          # Rust の依存関係と設定├── LICENSE            # ライセンス情報├── README.md          # プロジェクトの説明├── build.rs           # ビルド設定├── lua/               # Lua モジュール│   └── cargo/│       └── init.lua   # プラグインのメイン実装├── plugin/            # Neovim プラグイン│   └── cargo.lua      # プラグインのエントリーポイント└── src/              # Rust ソースコード    └── lib.rs        # Rust のコア実装この構造は、RustとLuaのハイブリッドな実装を効率的に管理するために設計されています。RustとLuaの役割分担cargo.nvimの特徴的な点は、RustとLuaを明確に役割分担していることです。この分担により、各言語の強みを最大限に活かした実装を実現しています。Rust (src/lib.rs)の役割Rust側では、プラグインの中核となる処理を担当しています。コアロジックの実装として、Cargoコマンドの実行を制御し、非同期処理を管理します。特に重要なのは、システムレベルの操作やエラーハンドリングの部分です。Rustの型システムと所有権モデルを活用することで、堅牢な実装を実現しています。また、パフォーマンスクリティカルな処理もRustの担当です。コマンド実行の最適化に加え、メモリ管理やスレッド制御など、システムリソースに直接関わる部分を効率的に処理します。これにより、プラグイン全体の実行性能を高いレベルで維持しています。Lua (lua/cargo/init.lua)の役割一方、Lua側はユーザーとの接点となる部分を担当します。UIの実装では、フローティングウィンドウの表示や制御を行い、バッファの管理やキーマッピングの設定を担います。また、シンタックスハイライトによる出力の視覚的な整理も、Luaが担当する重要な役割の一つです。さらに、Neovim APIとの連携も Luaの重要な責務です。イベントハンドリングやバッファ管理、ユーザー設定の処理など、Neovimとの緊密な連携が必要な部分を担当します。Luaの柔軟性を活かし、Neovimの機能を最大限に引き出す実装を行っています。使用している主要なパッケージRustの依存クレート (Cargo.toml)[dependencies]# Lua連携のためのクレートmlua = { version = \"0.9\", features = [\"luajit\", \"module\"] }# JSONシリアライズ/デシリアライズserde = { version = \"1.0\", features = [\"derive\"] }serde_json = \"1.0\"# 非同期処理tokio = { version = \"1.0\", features = [\"full\"] }# HTTPクライアント（将来の拡張用）reqwest = { version = \"0.11\", features = [\"json\"] }各クレートの選定理由と役割について説明します。mluaLuaとRustの橋渡しLua APIの安全な呼び出しエラー処理の統一tokio非同期処理の実装マルチスレッド制御リソース管理serde設定ファイルの読み込みJSONデータの処理型安全なデータ変換アーキテクチャの概要cargo.nvimは2層アーキテクチャを採用しています。これは、RustとLuaの特性を最大限に活かすために慎重に設計された構造です。[Rust Layer]    ↓ mlua[Lua Layer]    ↓ Neovim API[Neovim]この2層アーキテクチャの採用により、プラグインの品質と保守性を大きく向上させることができました。Rust層とLua層の責任を明確に分離することで、各レイヤーの役割が明確になり、コードの見通しが格段に良くなりました。特筆すべきは、mluaを介した層間の連携です。Rustの型安全性と高いパフォーマンスを維持しながら、Luaの柔軟性を活かしたNeovim APIの利用が可能となっています。この組み合わせにより、システムレベルの処理とユーザーインターフェースの実装を、それぞれの言語の強みを最大限に活かして実現できています。また、この構造によってパフォーマンスの最適化も容易になりました。Rustでの処理が必要な重い処理と、Luaで十分な軽い処理を適切に分離することで、全体的な実行効率を高いレベルで維持できています。加えて、今後の機能追加や修正においても、各層の独立性が高いため、変更の影響範囲を最小限に抑えることができます。開発を通じて得られた知見プラグインの開発を進める中で、いくつかの重要な気づきがありました。開発当初から意識していたのは責任分担です。RustとLuaの役割を明確に分けることで、開発の効率が大きく向上しました。Rustにはシステムレベルの処理を任せ、LuaではUI/UXの実装に専念する。この単純な原則が、結果として開発全体をスムーズにしてくれました。エラーハンドリングも大きな学びの一つでした。RustとLuaの特性を活かし、Rust側では可能な限り厳密なエラー処理を行い、Lua側ではそれらのエラーをユーザーにとって理解しやすい形で表示する。この組み合わせが、プラグインの信頼性向上に貢献しています。パフォーマンスについては、特に非同期処理の活用が効果的でした。Cargoコマンドの実行時間が長くなる場合でも、UIの応答性を維持できています。また、メモリ効率を意識した実装により、長時間の使用でもリソース消費を抑えられています。クロスプラットフォーム対応は予想以上に課題となりました。build.rsでの環境別設定や、パス処理の違いへの対応など、細かな配慮が必要でした。面倒なので自分と同じ環境のユーザーのみに対応しましたがユーザーが増えたら対応を考えます。これらの経験は、今後の開発にも活かしていきたいと考えています。Rust層の実装詳細コアストラクチャまず、プラグインの中核となるRustの実装を見ていきます。#[derive(Clone)]struct CargoCommands {    runtime: Arc<Runtime>,}impl CargoCommands {    fn new() -> LuaResult<Self> {        Ok(Self {            runtime: Arc::new(                tokio::runtime::Builder::new_current_thread()                    .enable_all()                    .build()                    .map_err(|e| LuaError::RuntimeError(e.to_string()))?,            ),        })    }}このコードの重要なポイントは：Cloneトレイトの実装によるランタイムの共有Arcによる安全な参照カウントTokioランタイムの効率的な管理非同期コマンド実行cargo.nvimの核となる機能、Cargoコマンドの実行処理です。impl CargoCommands {    async fn execute_cargo_command(&self, command: &str, args: &[&str]) -> LuaResult<String> {        let mut cmd = Command::new(\"cargo\");        cmd.arg(command);        cmd.args(args);                let output = cmd.output().map_err(|e| {            LuaError::RuntimeError(format!(\"Failed to execute cargo {}: {}\", command, e))        })?;                if !output.status.success() {            let error = String::from_utf8_lossy(&output.stderr);            return Err(LuaError::RuntimeError(format!(                \"cargo {} failed: {}\",                command, error            )));        }                Ok(String::from_utf8_lossy(&output.stdout).into_owned())    }}実装のポイント：- エラーの詳細な伝播- 出力のUTF-8変換処理- ステータスコードによる成功/失敗の判定Lua層の実装詳細ウィンドウ管理Neovimのウィンドウ管理を実装する部分です。local function create_float_win(opts)    -- ウィンドウサイズの計算    local width = math.floor(vim.o.columns * opts.window_width)    local height = math.floor(vim.o.lines * opts.window_height)        -- バッファの作成と設定    local bufnr = vim.api.nvim_create_buf(false, true)    vim.api.nvim_buf_set_option(bufnr, \"buftype\", \"nofile\")    vim.api.nvim_buf_set_option(bufnr, \"swapfile\", false)    vim.api.nvim_buf_set_option(bufnr, \"modifiable\", true)    vim.api.nvim_buf_set_option(bufnr, \"filetype\", \"cargo-output\")        -- ウィンドウ設定    local win_opts = {        relative = \"editor\",        width = width,        height = height,        col = math.floor((vim.o.columns - width) / 2),        row = math.floor((vim.o.lines - height) / 2),        style = \"minimal\",        border = opts.border    }        local winnr = vim.api.nvim_open_win(bufnr, true, win_opts)    return bufnr, winnrend実装のポイント：- 画面サイズに応じた動的なレイアウト- バッファとウィンドウの適切な設定- ユーザーカスタマイズ可能なオプション出力処理コマンド出力の整形と表示を担当する部分です。local function process_output(lines)    local processed = {}    for _, line in ipairs(lines) do        local timestamp = os.date(\"%H:%M:%S\")        local prefixed_line = string.format(\"[%s] \", timestamp)                if line:match(\"^error\") then            table.insert(processed, prefixed_line .. \"@error@\" .. line)        elseif line:match(\"^warning\") then            table.insert(processed, prefixed_line .. \"@warning@\" .. line)        elseif line:match(\"^%s*Compiling\") then            table.insert(processed, prefixed_line .. \"@info@\" .. line)        elseif line:match(\"^%s*Running\") then            table.insert(processed, prefixed_line .. \"@info@\" .. line)        elseif line:match(\"^%s*Finished\") then            table.insert(processed, prefixed_line .. \"@success@\" .. line)        else            table.insert(processed, prefixed_line .. line)        end    end    return processedend実装のポイント：- タイムスタンプによる実行時間の可視化- 出力種別に応じた装飾- 効率的な文字列処理プラグインの初期化と設定動的ライブラリのロードプラグインの初期化時に重要な、動的ライブラリのロード処理です。local function load_cargo_lib()    local plugin_dir = vim.fn.fnamemodify(vim.fn.resolve(debug.getinfo(1, \"S\").source:sub(2)), \":h:h:h\")    local lib_name = vim.fn.has(\"mac\") == 1 and \"libcargo_nvim.dylib\"        or vim.fn.has(\"win32\") == 1 and \"cargo_nvim.dll\"        or \"libcargo_nvim.so\"    local lib_path = plugin_dir .. \"/target/release/\" .. lib_name        if vim.fn.filereadable(lib_path) == 0 then        error(string.format(\"Cargo library not found: %s\", lib_path))    end        return package.loadlib(lib_path, \"luaopen_cargo_nvim\")()end実装のポイント：- クロスプラットフォーム対応- 適切なエラーハンドリング- ライブラリパスの動的解決パフォーマンス最適化のポイントRust側の最適化メモリ効率Arcによる共有リソースの効率的な管理適切なライフタイム管理不必要なクローンの回避非同期処理Tokioランタイムの効率的な利用ブロッキング処理の最小化適切なエラーハンドリングLua側の最適化バッファ管理必要最小限のバッファ更新効率的な行挿入メモリ使用量の最適化ウィンドウ管理リソースの適切な解放イベントの効率的な処理画面更新の最適化おわりに「なんとなく」Rustを選んで始めたcargo.nvimの開発でしたが、結果として多くの学びがありました。特に印象的だったのは、RustとLuaという異なる言語の組み合わせが予想以上に効果的だったことです。当初は「かっこいいから」という理由で選んだRustですが、システムレベルの処理とエラーハンドリングの面で、その選択は正しかったと確信しています。設計面では、「なんとなく」とは正反対の、明確な責任分担の重要性を学びました。RustとLuaの境界をしっかりと定義し、各言語の得意分野を活かすことで、保守性の高い構造を実現できました。また、非同期処理やメモリ効率の最適化など、パフォーマンスに関する知見も得られました。思えば、「なんとなく」から始まったこのプロジェクトは、むしろ「必然」だったのかもしれません。時としてエンジニアの直感は、技術的な正当性を伴って現実のものとなるのだと、身をもって体験しました。今後も、この「なんとなく」と「確信」が混ざり合った独特な開発体験を大切にしながら、より使いやすく、高性能なプラグインを目指して開発を続けていきたいと思います。最後まで読んでいただき、ありがとうございました。自作したツールcargo.nvimについて、This Week in RustにPRを送信したところ、マージされ、\"Great project, thanks for the submission!\"というコメントをいただきました。https://t.co/RB1ExrAhwJ pic.twitter.com/zcUpS6eX2G— nwiizo (@nwiizo) 2025年1月16日   参考リンクcargo.nvim関連cargo.nvim GitHub リポジトリcargo.nvim ドキュメントNeovim開発関連Neovim API ドキュメントNeovim Lua ガイドNeovim プラグイン開発ガイドRust開発関連mlua クレートのドキュメントtokio ドキュメントCargo Bookその他の参考資料Lua 5.4 リファレンスマニュアルRust非同期プログラミングガイド","isoDate":"2025-01-15T02:08:31.000Z","dateMiliSeconds":1736906911000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"既にあるものを正しく使うあるいは、インフラストラクチャをつくるとはどういうことなのか","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/12/202120","contentSnippet":"「既存のツールはどれも使えない。自分たちで作るしかない」はじめにインフラ/プラットフォームチームでよく耳にする言葉です。監視システム、デプロイメントパイプライン、構成管理ツール。エンジニアたちは次々と内製化の道を選びます。しかし、本当にゼロからの開発は必要なのでしょうか。このような判断の裏には、私たちが見落としがちな重要な視点が隠れています。多くのチームが「自前開発」という選択肢に飛びつく前に、立ち止まって考えるべきことがあります。システム運用アンチパターン ―エンジニアがDevOpsで解決する組織・自動化・コミュニケーション作者:Jeffery D. SmithオライリージャパンAmazonインフラストラクチャを「作る」とは何かインフラストラクチャを「作る」行為は必ずしもコードを書くことを意味しません。それは組織のニーズに合わせて適切なツールを選び運用プロセスを設計することです。経験豊富なエンジニアは問題解決の方法を知っています。正しい道具を選び効果的に使う経験を持っているのです。ja.wikipedia.org優れたエンジニアは必ずしも多くのコードを書きません。彼らは既存のツールを深く理解し効果的に組み合わせることで大きな価値を生み出します。toris.ioなぜ私たちは独自開発を選びがちなのか多くのインフラエンジニアは既存ツールよりも独自開発を選びます。その背景にはいくつかの思い込みがあります。最も多いのは「自社の環境は特殊だ」という思い込みです。確かにどの組織にも固有の課題はあります。しかしそれは既存ツールの組み合わせで解決できることが多いのです。次に「既存ツールの学習コストが高すぎる」という過大評価があります。新しいツールを作るコストと比べて本当にそうでしょうか。長期的な運用コストまで考える必要があります。また「技術的チャレンジへの期待」から独自開発を選ぶこともあります。新しい技術を学ぶことは重要です。しかし既存ツールの深い理解と活用にも同様の技術的チャレンジは存在します。正しいものを正しくつくる　プロダクトをつくるとはどういうことなのか、あるいはアジャイルのその先について作者:市谷 聡啓ビー・エヌ・エヌ新社Amazon組織とツールの調和ツール選定で最も重要なのは組織の成熟度とチームの体制に合わせた選択です。これは単なる技術的な判断ではありません。チームの技術力と学習能力は現状と将来の両面から判断が必要です。既存ツールの採用はチームの学習機会にもなります。組織の運用プロセスと文化もツール選択に大きく影響します。例えばGitOpsツールの導入ではチームの作業フローやレビュープロセスも再設計する必要があります。ツールの導入は組織全体の変革につながるのです。「変化を嫌う人」を動かす:魅力的な提案が受け入れられない4つの理由作者:ロレン・ノードグレン,デイヴィッド・ションタル,船木 謙一(監修)草思社AmazonOSSとの関わり方新しいツールを作る代わりに既存のOSSプロジェクトへの貢献を選択する価値は大きいです。これは「作る」から「改善に貢献する」への文化的シフトを意味します。OSSプロジェクトへの貢献は単なるコード提供以上の意味があります。コミュニティとの関わりを通じてチームの視野は広がります。技術力も向上します。3-shake.connpass.comzenn.devインフラストラクチャの価値を最大化するインフラエンジニアとしての価値ある選択は時として「作らない」という判断です。既存のツールやサービスを組織に合わせて活用し真に価値のある部分に時間を投資すべきです。新しいものを作ることは選択肢の一つに過ぎません。より重要なのは組織の目標達成に最も効果的な手段を選ぶことです。そのためには既存ツールの深い理解が必要です。組織のニーズを正確に把握することも欠かせません。 speakerdeck.comまとめインフラストラクチャを「作る」とは新しいツールを開発することだけを意味しません。それは既存の優れたツールを理解し組織に最適な形で導入することです。組織にとって重要なのは、「新しいものを作る」よりも既存のものを効果的に活用し改善に貢献できる文化を育てることです。これにより、インフラストラクチャの真の価値を最大化することができます。同時に、エンジニアにとって新しい技術への挑戦や実装は大きな魅力であり、そこから得られる学びや成長は貴重な財産となります。組織の正解と個人の楽しさは別物ですが、どちらも尊重しなければならないのでバランス感覚は必要です。楽しくなければエンジニアなんて退職してしまいます。優れたエンジニアは、この組織のニーズと個人の技術的探求のバランスを取りながら、キャリアを進めていっている気がします。","isoDate":"2025-01-12T11:21:20.000Z","dateMiliSeconds":1736680880000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"年始にstarshipでプロンプトの式年遷宮を行いたい","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/10/185633","contentSnippet":"適応は適応力を阻害する知識創造企業（新装版）作者:野中 郁次郎,竹内 弘高東洋経済新報社Amazonはじめに開発環境の最適化は、現代のソフトウェア開発において重要な課題です。また、その更新には式年遷宮のように、定期的な刷新には技術の継承と革新という二つの側面があります。しかし、過度な適応は適応力を阻害するという逆説もあります。この視点から、私は開発環境を定期的に見直し、必要な変更を加えています。昨年、その一環としてターミナルエミュレータをWarpに移行しました。Warpは洗練されたUIと優れた機能性を備え、AIによるコマンド提案やブロックベースの出力表示など、モダンな機能により開発効率を大きく向上させてくれました。agnozingdays.hatenablog.com招待があるのでこちらからインストールしてください❤️https://app.warp.dev/referral/9Z8MRV2025年を迎え、新たな改善として開発環境のさらなる最適化を目指しています。特に注目したのが、日々の開発作業で最も頻繁に目にするターミナルのプロンプトです。より詳細な開発環境の状態把握を実現するため、高速でカスタマイズ性の高いクロスシェルプロンプト「starship」の導入を決めました。この記事では、Fishシェルをベースにしたstarshipの導入過程と、具体的な設定内容を共有します。また、WarpとFish、そしてstarshipの組み合わせがもたらす相乗効果についても詳しく解説していきます。starship.rsstarshipの特徴と選択理由starshipは、任意のシェルで動作する、高速で柔軟なプロンプトです。Rustで書かれており、システムリソースを最小限に抑えながら、豊富な情報を表示できることが特徴です。私がstarshipを選択した主な理由は以下の点です。まず、クロスシェル対応という特徴が魅力的でした。開発環境によってbash、zsh、fishなど異なるシェルを使用することがありますが、starshipならば一つの設定ファイルですべてのシェルで同じ見た目と機能を実現できます。次に、Rustで実装されているという点も重要でした。シェルの起動時やプロンプトの更新時のパフォーマンスが優れており、ストレスなく使用できます。特に大規模なGitリポジトリでの作業時でも、プロンプトの更新による遅延をほとんど感じません。また、モジュール式の設計により、必要な情報だけを選択して表示できる点も気に入っています。開発言語やツールの追加・削除が容易で、環境の変化に合わせて柔軟に対応できます。starship.rsインストールと初期設定私は普段からFishシェルを使用しているため、まずFishのインストール状況を確認しました。macOSではHomebrewを使ってFishをインストールしています。brew install fish続いて、starshipもHomebrewでインストールしました：brew install starshipなお、他のOS環境では公式のインストールスクリプトを使用することもできます。curl -sS https://starship.rs/install.sh | shFishシェルの場合、~/.config/fish/config.fishの末尾に以下の初期化コードを追加します。starship init fish | sourceこの設定により、Fishシェルの起動時に自動的にstarshipが初期化されます。私の場合、既にFishの設定ファイルにはテーマやエイリアスなどの設定が含まれていましたが、starshipはそれらと競合することなく動作しています。特に、Fishの持つ構文ハイライトや補完機能との相性が良く、快適な開発環境を実現できています。プロンプトの詳細設定starship.rsstarshipの設定は~/.config/starship.tomlで行います。私の設定では、開発で使用する様々なツールの状態を視覚的に把握できるように工夫しています。github.comそれ以外にも設定のサンプルがあるの使ってみたり、参考にしてもよいかもです。starship.rsプロンプトのレイアウト設定formatセクションでは、プロンプトの全体的な構造を定義しています。パワーライン風のデザインを採用し、各モジュール間を矢印で滑らかに接続しています。format = \"\"\"[](fg:#9A348E)\\$directory\\[](fg:#DA627D bg:#9A348E)\\$git_branch\\$git_status\\[](fg:#FCA17D bg:#DA627D)\\$kubernetes\\[](fg:#86BBD8 bg:#FCA17D)\\$aws\\...このように、各セグメントの背景色を前後で調整することで、矢印型のつなぎ目を実現しています。色は、視認性とアクセシビリティを考慮して選択しました。ディレクトリ表示の最適化カレントディレクトリの表示は、開発作業において最も基本的な情報です。[directory]style = \"fg:#E4E4E4 bg:#9A348E\"format = '[ $path ]($style)'truncation_length = 3truncation_symbol = \"…/\"truncation_length = 3の設定により、ディレクトリの深さが3階層を超える場合は自動的に省略されます。これにより、長いパスでもプロンプトが横に広がりすぎることを防いでいます。また、truncation_symbol = \"…/\"で省略部分を直感的に表現しています。Git情報の詳細表示Git関連の情報は、開発作業において特に重要です。[git_branch]symbol = \" \"style = \"fg:#E4E4E4 bg:#DA627D\"format = '[ $symbol$branch ]($style)'[git_status]style = \"fg:#E4E4E4 bg:#DA627D\"format = '[$all_status$ahead_behind ]($style)'conflicted = \"≠\"ahead = \"⇡${count}\"behind = \"⇣${count}\"diverged = \"⇕\"untracked = \"±${count}\"stashed = \"※\"modified = \"!${count}\"staged = \"+${count}\"renamed = \"»${count}\"deleted = \"×${count}\"Gitの状態を直感的なアイコンで表現することで、リポジトリの状態を一目で把握できます。特に以下の状態を重視しています。コンフリクトの発生（≠）プッシュ・プル待ちの変更（⇡/⇣）作業ディレクトリの状態（未追跡、変更、ステージング）スタッシュの存在（※）これらの情報をコンパクトに表示することで、Git操作のミスを防ぎ、効率的な作業を実現しています。クラウドと開発環境の状態表示現代の開発では、複数のクラウドサービスやコンテナ環境を使用することが一般的です。[kubernetes]symbol = \"☸ \"style = \"fg:#E4E4E4 bg:#FCA17D\"format = '[ $symbol$context(\\($namespace\\)) ]($style)'disabled = false[aws]symbol = \"☁ \"style = \"fg:#E4E4E4 bg:#86BBD8\"format = '[ $symbol($profile)(\\($region\\)) ]($style)'disabled = false[docker_context]symbol = \"🐋 \"style = \"fg:#E4E4E4 bg:#33658A\"format = '[ $symbol$context ]($style)'これらの設定により、以下の情報を常に把握できます。KubernetesのコンテキストとネームスペースAWSとGoogle Cloud プロファイルとリージョンDockerのコンテキスト特にマルチクラウド環境での作業時に、誤った環境で操作してしまうリスクを軽減できます。プログラミング言語とツールのバージョン表示各プログラミング言語やツールのバージョン情報も、プロジェクトごとに適切に表示されます。[golang]symbol = \"🐹 \"style = \"fg:#E4E4E4 bg:#06969A\"format = '[ $symbol($version) ]($style)'[python]symbol = \"🐍 \"style = \"fg:#E4E4E4 bg:#1B9F62\"format = '[ $symbol($version) ]($style)'detect_extensions = [\"py\"]python_binary = [\"python\", \"python3\"][nodejs]symbol = \"⬢ \"style = \"fg:#E4E4E4 bg:#33658A\"format = '[ $symbol($version) ]($style)'detect_extensions = [\"js\", \"ts\", \"tsx\"]detect_files = [\"package.json\", \"tsconfig.json\"][rust]symbol = \"⚙ \"style = \"fg:#E4E4E4 bg:#86BBD8\"format = '[ $symbol($version) ]($style)'detect_extensions = [\"rs\"]detect_files = [\"Cargo.toml\", \"Cargo.lock\"]各言語の設定では、以下の点に注意を払っています。適切なファイル検出設定(認知が追いつかない部分を勝手に取得できるように)わかりやすいアイコンの選択(環境を間違って死なないように)バージョン情報の明確な表示(バージョンの勘違いで泣かないように)また、Terraform、Google Cloudなどのインフラ関連ツールも同様に設定しています。[terraform]symbol = \"🏗 \"style = \"fg:#E4E4E4 bg:#06969A\"format = '[ $symbol$workspace ]($style)'[gcloud]symbol = \"🌐 \"style = \"fg:#E4E4E4 bg:#33658A\"format = '[ $symbol$account(@$domain)(\\($project\\)) ]($style)'時刻表示とプロンプト文字作業時間の管理や、コマンド実行時刻の記録のために、時刻表示も含めています。[time]disabled = falsetime_format = \"%R\"style = \"fg:#E4E4E4 bg:#86BBD8\"format = '[ $time ]($style)'[character]success_symbol = \"❯\"error_symbol = \"❯\"vimcmd_symbol = \"❮\"24時間形式で時刻を表示し、コマンドの実行状態に応じてプロンプト文字を変更します。特にvimモードを使用している場合は、モードの切り替えが一目でわかるようになっています。おわりにstarshipを導入して一週間が経過しましたが、starshipの導入により、開発環境の視認性と操作性が大きく向上しました。新年を迎えるにあたっての環境整備として、非常に満足のいく選択だったと感じています。この設定は、私の開発スタイルに合わせて最適化したものですが、starshipの柔軟な設定システムを活用することで、誰でも自分に最適な開発環境を構築できます。ぜひ皆さんも、自分の作業スタイルに合わせたカスタマイズを試してみてください。設定ファイルは公開していますので、参考にしていただければ幸いです。また、今後も開発環境の改善を続け、さらに効率的な開発環境を目指していきたいと思います。","isoDate":"2025-01-10T09:56:33.000Z","dateMiliSeconds":1736502993000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"RustでのProtocol Buffersを学習するための図書管理システム実装","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/10/133852","contentSnippet":"はじめにProtocol BuffersとRustの実践的な学習を目的として図書管理システムを開発しました。 システムの構築にあたってはBufによるスキーマ管理とコード生成を採用することで開発環境を実現しています。今回の実装を通じてRustにおけるgRPCサービスの構築手法について理解を深めることができました。buf.buildフロントエンド開発については今後の課題として検討しています。 Remixが気になっているので実装したいと思ってます。本記事ではバックエンド実装に焦点を当てて解説します。 特にRustのエコシステムにおけるtonicやSQLxといったライブラリの活用方法に着目します。これらの実装を通じて得られた知見は他のRustプロジェクトにも応用可能な内容となっています。学習目的で実装したコードなので何かに活用していただければ幸いです。github.comプロジェクトのセットアップまず、以下のようなディレクトリ構造を作成します：library-system/├── buf/│   ├── buf.yaml│   ├── buf.gen.yaml│   └── library/│       └── v1/│           └── library.proto├── library-server/└── library-client/Bufの設定buf.yaml:version: v1name: buf.build/yourusername/library-systembreaking:  use:    - FILElint:  use:    - DEFAULTbuf.gen.yaml:version: v1plugins:  - plugin: buf.build/protocolbuffers/rust    out: ../library-server/src    opt:      - bytes=bytes  - plugin: buf.build/community/neoeinstein-tonic-rust    out: ../library-server/src    opt:      - no_client=false      - no_server=falseAPIの設計Protocol Buffersを使用してAPIを定義します：syntax = \"proto3\";package library.v1;import \"google/protobuf/timestamp.proto\";service LibraryService {    rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);    rpc GetUser(GetUserRequest) returns (GetUserResponse);    rpc SearchBooks(SearchBooksRequest) returns (SearchBooksResponse);    rpc CreateLoan(CreateLoanRequest) returns (CreateLoanResponse);    rpc ReturnBook(ReturnBookRequest) returns (ReturnBookResponse);}図書管理システムの実装詳細アーキテクチャと技術選定システムの基盤には非同期処理による高パフォーマンスな実装を採用しました。 Rustの非同期ランタイムであるtokioを活用することでリソースの効率的な利用を実現します。サーバーの起動処理は以下のコードで示すように非同期処理を基本とした設計です。#[tokio::main]async fn main() -> Result<(), Box<dyn std::error::Error>> {    let service = LibraryServiceImpl::new(&database_url).await?;    Server::builder()        .add_service(LibraryServiceServer::new(service))        .serve(addr)        .await?;    Ok(())}サーバーサイドの主要実装Protocol Buffersによるサービス定義が実装の起点となります。 サーバーの中核機能はLibraryServiceImpl構造体に集約されます。SQLxを用いたデータベース操作により型安全性の高いコードを実現しました。貸出処理のトランザクション制御は特に慎重な実装を必要としました。 以下のコードでは書籍の貸出状態確認から更新までを単一トランザクションで処理します。async fn create_loan(&self, request: Request<CreateLoanRequest>) -> Result<Response<CreateLoanResponse>, Status> {    let mut tx = self.pool.begin().await?;    let book = sqlx::query_scalar::<_, bool>(\"SELECT available FROM books WHERE id = ?\")        .bind(&req.book_id)        .fetch_optional(&mut *tx)        .await?;    if !book.available {        return Err(Status::failed_precondition(\"Book is not available\"));    }    // 貸出処理の実行    tx.commit().await?;    Ok(Response::new(loan_response))}クライアントサイドの実装ユーザーインターフェースは直感的な操作を重視しました。 クライアントの初期化処理は以下のように簡潔な実装としています。async fn main() -> Result<(), Box<dyn std::error::Error>> {    let channel = Channel::from_static(\"http://[::1]:50051\").connect().await?;    let client = LibraryServiceClient::new(channel);}エラー処理は利用者の視点を重視した実装としました。 サーバーからのエラーレスポンスを適切にハンドリングすることでユーザーへの明確なフィードバックを実現します。データベース設計データモデルは業務要件を正確に反映する設計としました。 ユーザー情報と書籍情報を管理する基本テーブルに加えて貸出履歴を記録するテーブルを実装します。CREATE TABLE loans (    id TEXT PRIMARY KEY,    book_id TEXT NOT NULL REFERENCES books(id),    user_id TEXT NOT NULL REFERENCES users(id),    loan_date TIMESTAMP NOT NULL,    due_date TIMESTAMP NOT NULL,    return_date TIMESTAMP);スキーマ設計は将来の拡張性を考慮しました。 返却日時や貸出状態を管理するカラムを追加することで機能拡張への対応を可能としています。この実装を通じて学んだ最も重要な点は型安全性とトランザクション管理の重要性です。RustとSQLxの組み合わせにより堅牢なシステムを実現できました。主要な機能ユーザー管理ユーザーの作成ユーザー情報の取得書籍管理書籍の検索在庫状態の管理貸出管理書籍の貸出返却処理貸出状態の追跡参考リソースBuf DocumentationTonic DocumentationSQLx DocumentationProtocol Buffers DocumentationGenerated SDKs for Rust now available on the Buf Schema Registryまとめ今回は図書管理システムを題材にRustとProtocol Buffersを組み合わせた実装を検証しました。 tonicとSQLxを活用したバックエンド開発を通じて両者の親和性の高さを実感できました。Rustの型システムと所有権の概念がProtocol Buffersの型定義と自然に調和する点が特に印象的でした。エラー処理と非同期プログラミングの実装パターンについても有意義な知見を得られました。 RustのResult型とtonicのステータスコードの組み合わせは明快なエラーハンドリングを実現します。またtokioを基盤とした非同期処理はSQLxのトランザクション管理と組み合わせることで堅牢な実装を可能にします。今後は本実装をベースにさらなる検証を進めたいと考えています。 予約システムやユーザー認証の追加を通じてスケーラブルな設計の可能性を探ります。フロントエンド開発ではRemixとTypeScriptを採用することでエンドツーエンドの型安全性についても検証を行う予定です。またDockerコンテナ化やCI/CDパイプラインの整備を通じて本番環境での運用性も確認していきます。RustとProtocol Buffersを主軸とした本プロジェクトは実用的なシステム開発の基盤として十分な手応えを感じる結果となりました。今回得られた知見は今後の開発プロジェクトにも大いに活用できるものと確信しています。最後に初春の誓い 新たに刻みしも昨日の影が まだ私を離さず目標という星は 遠く輝けど手の届かぬ空に ただ揺れている日々は川の流れのように変わらぬ場所を 静かに過ぎゆくされど生は進み刻は確かに 私を育てる明日もまた 新しい朝が来るそれだけが 確かな真実2024年もみなさん、最後まで読んでくれて本当にありがとうございます。途中で挫折せずに付き合ってくれたことに感謝しています。読者になってくれたら更に感謝です。XやGithubまでフォロワーしてくれたら泣いているかもしれません。","isoDate":"2025-01-10T04:38:52.000Z","dateMiliSeconds":1736483932000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"NeovimをCursorのように進化させる - yetone/avante.nvim の導入","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/07/220406","contentSnippet":"「もはやCopilotなしでは開発できない」Cursorが体験として革新的すぎる」Clineこそ俺達が求めていたものだ！」とにかく新世代のAIエディターが最高！」  はじめに開発者のタイムラインを開けば、そんな投稿で溢れかえっています。確かに、AIによる開発支援は革新的で、プログラミングの未来を感じさせるものです。特に最近では、単なるコード補完を超えて、より多機能なAIアシスタントとしての役割を担うツールが増えてきています。実は、愛用のNeovimでもこうした最新のAI機能を導入できるんです。しかも、使い慣れたキーバインドやプラグインはそのまま。今回はavante.nvimというプラグインを使って、NeovimをAIパワード開発環境へと進化させる方法をご紹介します。github.comこのプラグインは、私たちvimmerにとって既に身近な存在であるcopilot.luaのような補完機能を超えて、より包括的なAI支援を実現します。コードの理解、リファクタリング、そして対話的なアシスタント機能まで、新世代のAIエディターが持つ機能をNeovimで実現できるのです。これまでのvimmerは、copilot.luaのようなシンプルで効率的なコード補完ツールを活用してきました。しかし、新世代のAIエディターは、コードの解析、リファクタリングの提案、そしてより高度なコンテキスト理解を備えています。この進化に対して、私たちvimmerはどのように向き合うべきでしょうか？でも、待ってください。私たち Vimmer はどうすれば...？ 長年磨き上げてきたNeovimを捨てて、新しいエディターに移行しなければいけないのでしょうか？いいえ、Neovimはもっと強くなれます。Neovimの最大の魅力は、その圧倒的なカスタマイズ性。それは単なるIDE（統合開発環境）ではなく、PDE（Personal Development Environment：個人開発環境）とも呼べる存在です。まるで自分だけの剣を鍛え上げていくように、エディターと共に成長していける。そんな独特の魅力がNeovimにはあります。私たちは常にNeovimを進化させ、新しい可能性を追求してきました。copilot.luaがその一例です。そして今、avante.nvimによって、さらなる進化の時が来ています。Neovim 以外の話はこちらです。laiso.hatenablog.comavante.nvim とはavante.nvimは、Cursor AI IDEの機能を模倣することを目的として開発されたNeovimプラグインです。AI駆動のコード提案機能を提供し、その提案を直接ソースファイルに適用できる機能を備えています。上記のカテゴリーでいうとコーディングエージェントに近いものになります。デモ動画こういう経験がサクッと得られるのでよいです。 https://t.co/x7S08l06v9 pic.twitter.com/X4mvE2c2H7— nwiizo (@nwiizo) 2025年1月7日   subを追加する例です。 https://t.co/x7S08l06v9 pic.twitter.com/EyjDkdzP9c— nwiizo (@nwiizo) 2025年1月7日   Note: GitHub上にデモ動画がありますが、実際の動作の様子を簡単に説明させていただきます：avante.nvimを使用すると、画面右側にAIアシスタントのサイドバーが表示され、現在開いているコードについて対話形式で質問や提案を行うことができます。コードの変更提案は差分形式で表示され、ワンクリックで適用することができます。まさにCursor AI IDEのような操作感を、Neovim上で実現しています。実際の動作については、GitHubのリポジトリでも確認することができます。特徴的な機能AIによるコードアシスタント: 現在のコードファイルについてAIに質問し、インテリジェントな提案を受けることができますワンクリック適用: AIの提案をシンプルなコマンドで即座にソースコードに反映できます他の生成AIとの連携: デフォルトのClaudeに加え、ChatGPTやGitHub Copilotを活用したコード提案が可能ですセットアップ方法lazy.nvimを使用した場合の設定例を紹介します。avante.nvimはデフォルトではCursorのように高度なAI機能を利用するように設定されていますが、他にもChatGPTやAzureなども指定できますが今回はより手軽に利用できるGitHub Copilotをプロバイダーとして設定します。これにより、Copilotのライセンスさえあれば、追加のAPIキーの設定なしでAI支援機能を利用することができます。以下が具体的な設定例です。{  \"yetone/avante.nvim\",  event = \"VeryLazy\",  lazy = false,  version = false,  opts = {    provider = \"copilot\",    auto_suggestions_provider = \"copilot\",        -- 動作設定    behaviour = {      auto_suggestions = false,      auto_set_highlight_group = true,      auto_set_keymaps = true,      auto_apply_diff_after_generation = false,      support_paste_from_clipboard = false,      minimize_diff = true,    },    -- ウィンドウ設定    windows = {      position = \"right\",  -- サイドバーの位置      wrap = true,        -- テキストの折り返し      width = 30,         -- サイドバーの幅      -- その他の詳細設定は省略    },  },  -- 依存関係の設定  dependencies = {    -- 必須の依存関係    \"stevearc/dressing.nvim\",    \"nvim-lua/plenary.nvim\",    \"MunifTanjim/nui.nvim\",    -- オプションの依存関係    \"hrsh7th/nvim-cmp\",    \"nvim-tree/nvim-web-devicons\",    \"zbirenbaum/copilot.lua\",    -- その他の拡張機能  }}私の設定はこちらです。github.com主要なキーマッピングデフォルトで以下のキーマッピングが利用可能です。主にこちらから利用していきます。<Leader>aa: サイドバーの表示<Leader>ar: サイドバーの更新<Leader>af: サイドバーのフォーカス切り替え<Leader>ae: 選択したブロックの編集他ブログでのavante.nvimの紹介zenn.devまとめ開発者の間で「AIエディターこそが主流」という声が広がっていますが、Vimmerは愛用のNeovimを手放す必要はありません。avante.nvimの導入により、Neovimの使い慣れた操作性を維持したまま、最新のAI支援機能を活用することが可能です。特筆すべき点として、GitHub Copilotをプロバイダーとして使用することで、追加のAPIキー設定なしで高度な機能を利用できます。また、洗練されたサイドバーUIにより自然な開発ワークフローを実現し、<Leader>aaなどのシンプルなキーマッピングで直感的な操作を可能にします。Neovimの最大の魅力である圧倒的なカスタマイズ性を活かしながら、このプラグインを通じてAIパワード開発環境へと進化させることができます。プラグインは現在も活発に開発が継続されており、今後さらなる機能追加が期待できます。PDEとしてのNeovimの魅力を保ちながら、最新のAI支援機能を活用したいVimmerにぜひお勧めのプラグインです。最後に一言。「おい、お前、それは本当にvimmerか？」という声が聞こえてきそうです。しかし、私たちvimmerは常に進化を続けています。新しい技術を取り入れながらも、Vimの哲学と向き合い続けることもまた、vimmerの在り方の一つなのではないでしょうか。","isoDate":"2025-01-07T13:04:06.000Z","dateMiliSeconds":1736255046000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Rustで花火アニメーションと新年メッセージを作ろう","link":"https://syu-m-5151.hatenablog.com/entry/2025/01/04/120812","contentSnippet":"はじめに私がRustという言語と再び出会ったのは、暮れも押し詰まった頃のことだった。シェアハウスの六畳一間の部屋で、誰かの足音の気配だけを感じながら、画面に向かっていた。シェアハウスの共用キッチンからは時折、誰かの料理する音が漏れ聞こえてくるが、年末だというのに妙に静かだった。メモリ安全性という言葉に惹かれたわけでも、高パフォーマンスに心を奪われたわけでもない。ただ、この年の瀬に、誰にも見せることのない花火を打ち上げたかっただけなのだ。深夜のターミナル画面に、デジタルの花を咲かせれば、少しは華やかな年越しになるかもしれない。そんな打算的な期待を胸に、私はコードを書き始めた。年末最後の実装でもバグを出してしまい、『来年もきっと、たくさんの失敗をして恥ずかしいコードを書くことになるだろうな』と考えていました。https://t.co/34hgesMGQu pic.twitter.com/k7f7GyqLoT— nwiizo (@nwiizo) 2025年1月2日   準備まずは、以下の外部クレートをインストールします。chrono: 日付と時刻を扱うためのクレートcolored: ターミナル出力に色をつけるためのクレートrand: 乱数を生成するためのクレートCargo.tomlに以下の行を追加してください。[dependencies]rand = \"0.8\"colored = \"2.0\"chrono = \"0.4\"構造体と列挙型の詳細Fireworkとその周辺の構造体struct Firework {    x: f64,           // x座標    y: f64,           // y座標    velocity: f64,    // 上昇速度    particles: Vec<Particle>,  // 爆発後のパーティクル    exploded: bool,   // 爆発したかどうか    color: Color,     // 花火の色    sparkles: Vec<Sparkle>,   // 打ち上げ時の火花}struct Sparkle {    x: f64,           // 火花のx座標    y: f64,           // 火花のy座標    lifetime: i32,    // 火花の寿命}Firework構造体は花火1発分の情報を管理します。打ち上げ時にはexplodedがfalseで、上昇中の花火を表示。爆発後はexplodedがtrueとなり、particlesに格納された粒子が広がっていきます。sparklesは打ち上げ中の火花を表現するために使用されます。Particleの詳細struct Particle {    x: f64,           // x座標    y: f64,           // y座標    vx: f64,          // x方向の速度    vy: f64,          // y方向の速度    lifetime: i32,    // パーティクルの寿命    char: char,       // 表示する文字    color: Color,     // パーティクルの色    trail: Vec<(f64, f64)>,  // 軌跡の座標履歴}Particleは爆発後の火花を表現します。物理演算で放物線を描くように、速度と重力の影響を受けます。trailは軌跡を表示するために過去の座標を記録しています。色の実装#[derive(Clone, Copy)]enum Color {    Red, Green, Blue, Yellow, Magenta, Cyan,    Rainbow,  // 時間とともに色が変化    Silver,   // 明滅する白    Gold,     // 明滅する黄色    Pearl,    // 白と水色で明滅}Colorは単色だけでなく、Rainbowのような動的な色変化や、Silver/Gold/Pearlのような明滅効果も実装しています。get_colored_charメソッドで、時間（フレーム数）に応じた色を返します。アニメーションの仕組み花火の更新処理impl Firework {    fn update(&mut self) {        if !self.exploded {            self.y -= self.velocity;  // 上昇            // 確率で火花を追加            if rand::thread_rng().gen_bool(0.3) {                self.sparkles.push(Sparkle {...});            }            // 一定の高さで爆発            if self.y <= rand::thread_rng().gen_range(5.0..15.0) {                self.explode();            }        } else {            // パーティクルの更新と寿命切れの除去            for particle in &mut self.particles {                particle.update();            }            self.particles.retain(|p| p.lifetime > 0);        }    }}花火は打ち上げ時と爆発後で異なる動きをします。打ち上げ中は上昇しながら火花を散らし、一定の高さで爆発。爆発後は多数のパーティクルが放物線を描きながら広がります。描画処理の工夫fn draw_frame(fireworks: &Vec<Firework>, frame_count: u32) {    // 背景に星を表示（10フレームごとに配置を変える）    if frame_count % 10 == 0 {        for _ in 0..50 {            let x = rand::thread_rng().gen_range(0..100);            let y = rand::thread_rng().gen_range(0..30);            frame[y][x] = ('·', Some(Color::Silver));        }    }        // 各花火の描画    for firework in fireworks {        // 打ち上げ火花の描画        for sparkle in &firework.sparkles {            let x = sparkle.x as usize;            let y = sparkle.y as usize;            frame[y][x] = ('｡', Some(Color::Pearl));        }                if !firework.exploded {            // 上昇中の花火            frame[y][x] = ('⁂', Some(firework.color));        } else {            // 爆発後のパーティクル            for particle in &firework.particles {                // 軌跡の描画                for (i, (trail_x, trail_y)) in particle.trail.iter().enumerate() {                    let char = match i {                        0 => '.',                        1 => '·',                        _ => '°',                    };                    frame[y][x] = (char, Some(particle.color));                }            }        }    }}描画処理では、まず背景に点滅する星を配置し、その上に花火を重ねていきます。パーティクルの軌跡は徐々に薄くなるように文字を変えています。これにより、より自然な花火の表現を実現しています。アニメーションとメッセージ表示最後に、main関数でアニメーションとメッセージ表示を行います。fn main() {    let year = Local::now().year(); // 現在の年を取得    let mut fireworks = Vec::new();    let mut frame_count = 0;    loop {        // 花火を追加        if frame_count % 15 == 0 && fireworks.len() < 8 {            fireworks.push(Firework::new(rand::thread_rng().gen_range(10.0..90.0)));        }        // 花火を更新して描画        for firework in &mut fireworks {            firework.update();        }        draw_frame(&fireworks, frame_count);        fireworks.retain(|f| !f.is_done());        thread::sleep(Duration::from_millis(40));        frame_count += 1;        // 一定時間後にメッセージを表示        if frame_count > 300 {            clear_screen();            display_new_year_message(year);            break;        }    }}ループ内で、一定の間隔で新しい花火を追加し、既存の花火を更新して描画しています。300フレーム後には、display_new_year_message関数を呼び出して新年のメッセージを表示します。この関数では、ASCIIアートを使ってメッセージを作成し、coloredクレートで色をつけています。まとめ結局、プログラムは年越しに間に合わなかった。シェアハウスの他の住人たちは、それぞれの実家や友人たちの元へと消えていき、廊下は一層静かになっていた。コンパイラの指摘する数々のエラーと向き合ううち、除夜の鐘が鳴り響き、新年は音もなく明けてしまった。しかし不思議なことに、深夜2時、ようやく完成したプログラムが描き出す花火の光に、私は密かな充実感を覚えていた。誰にも見せることはないだろうこの花火は、確かに私だけの新年を祝福していたのだから。来年は少し早めに取り掛かろう。もっとも、来年も誰かと過ごすことになるとは限らないが。これは私の経験則である。知らんけど。完全なコードは以下の通りです。github.com","isoDate":"2025-01-04T03:08:12.000Z","dateMiliSeconds":1735960092000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"アーキテクチャ設計の民主化とADR(Architectural Decision Records)による意思決定の未来 - Facilitating Software Architecture の読書感想文","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/31/232546","contentSnippet":"年末年始の慌ただしい時期に、数ある選択肢の中からこちらの記事をお読みいただき、誠にありがとうございます。人生を定期的に振り返ることには、本書で取り上げられているADR（Architecture Decision Records）に通じる素晴らしさがあります。過去の決定とその背景を記録し、将来の自分や他者が参照できる形で残すことは、個人の成長にとって貴重な資産となります。そんな観点から今年を振り返ってみると、2024年は私自身にとって大きな試練と変化の年でした。印象的だったのは、ある時期に突然、技術に対する興味や情熱が完全に失われてしまったことです。それは技術分野に限らず、仕事全般や私生活にも波及し、何をするにも意欲が湧かない、深い無気力状態に陥ってしまいました。しかし、この困難な時期を経て、いくつかの意味のある変化が生まれました。私は以前から技術書の書評を書いていましたが、これは主に自分の理解を深め、将来の自分のための記録として残すことが目的でした。より自分の感想や学びを素直に記録することに注力するようになりました。その結果長文になることも多々ある。この文章も同様に長くなってしまった。外部登壇やブログもいくつか書きました。また、Xでは書籍を紹介するアカウントの運営方法を始めました。めちゃくちゃにバカにされたり批判もされたが明確な敵ができて嬉しい。これは思いがけずフォロワーの方々との貴重な出会いを生み、さらには翻訳書の出版という新たな機会にもつながりました。あとは回復の過程で気づいたのは、基本的な生活習慣を見直すことの大切さでした。規則正しい運動習慣の確立、十分な睡眠時間の確保、そして栄養バランスを意識した食事管理を意識的に行うことで、徐々に日常を取り戻すことができました。また、仕事漬けの状態から一時的に距離を置き、純粋な娯楽を楽しむ時間を作ることも大きな助けとなりました。好きな映画やお笑い番組を観て心を癒したり、仕事や技術とは直接関係のない物語や小説に没頭する時間を意識的に作りました。一見すると遠回りに思えるこれらの活動が、むしろ心の回復を促し、結果として日常への活力を取り戻すきっかけとなったのです。このような経験を通じて、技術や仕事への向き合い方を大きく変えることができました。時には立ち止まり、心身の健康に意識を向けることの大切さを、身をもって学ぶ機会となったのです。そして、この振り返りを書き記すことは、まさにADRのように、将来の自分への重要な指針となることを願っています。あと、以下からtemplateを利用して作成することもできます。adr.github.ioはじめにここからは書評です。年の瀬や新しい年のスタートは、振り返りや目標設定の時期として特別な意味を持つことが多いと思います。そのような忙しい時期に手に取った一冊が、「Facilitating Software Architecture」でした。この本は、現代のソフトウェア開発における複雑な課題に向き合い、分散型アプローチを基盤にした実践的な知見を提供しています。読み進めるうちに、この時期に改めて考えたい「意思決定」「信頼」「チーム文化」といったテーマが深く掘り下げられており、多くの示唆を得ることができました。Facilitating Software Architecture: Empowering Teams to Make Architectural Decisions (English Edition)作者:Harmel-Law, AndrewO'Reilly MediaAmazon本書は、分散型アーキテクチャの実践を通じて、現代のソフトウェア開発における複雑な課題に立ち向かうための方法を探求しています。従来の中央集権的なアーキテクチャ手法の限界を明確にし、変化の激しい開発環境に適応するための分散型アプローチを提案します。ソフトウェア開発は技術的な進化だけでなく、チームや組織文化といった社会的要素とも密接に関連しています。成功する開発チームは、技術的な卓越性を追求するだけでなく、分散化された信頼に基づく意思決定や柔軟なプロセスを取り入れる必要があります。本書では、理論的な原則だけでなく、実践的なアプローチや具体的な事例を交えながら、分散型アーキテクチャを支える方法を体系的に示しています。重要なのは、トップダウンの権限に頼らない意思決定の実現です。組織が成長し複雑化する中で、中央集権的なアプローチはその限界を迎えつつあります。そこで必要となるのが、信頼関係に基づいた民主的な意思決定プロセスです。本書は、このような信頼ベースの分散型アーキテクチャを実現するための具体的な方法論を提供しています。learning.oreilly.comアーキテクチャの民主化が必要な理由の一つは、中央集権的なアプローチに内在する持続可能性の問題です。いかに優秀なアーキテクトであっても、人は組織を去り、知識は失われ、文脈は変化します。アーキテクチャの決定権を特定の個人や小グループに集中させることは、長期的には組織の脆弱性につながります。分散型アプローチは、この本質的な課題に対する解決策を提供します。知識と決定権を組織全体で共有することで、個人への依存を減らし、より持続可能な開発文化を築くことができるのです。「中央集権型アプローチの限界」「アドバイスプロセスの導入」「アーキテクチャ意思決定記録（ADR:Architectural Decision Records）」の活用といったテーマを中心に、現代のソフトウェア開発組織が直面する課題とその解決策を深く掘り下げています。この知識は、開発者、アーキテクト、リーダーなど、さまざまな役割の方々がそれぞれの立場でより良い意思決定を行うための指針となるでしょう。ADR（Architecture Decision Records）との出会いは『Fundamentals of Software Architecture』の第19章を通じてでした。後に振り返ると、Design IT!でも触れられていたかもしれませんが、その時点では深く印象に残っていませんでした。learning.oreilly.com初めてADRの概念に触れた時、その単純さと効果的さに強く惹かれました。アーキテクチャ上の重要な決定を、その背景や検討過程も含めて記録するという考え方は、私が長年感じていた「なぜその決定に至ったのか」という疑問への明確な解答でした。ADRの実践において重要なのは、その適用範囲と文脈の深さを適切に見極めることです。あくまでシステムの方向性を決定づける重要な技術選択や、将来に大きな影響を与える可能性のある決定に焦点を当てるべきです。例えば、マイクロサービスアーキテクチャの採用、主要なデータベースの選定、重要なインターフェースの設計などが該当します。ただし、これらの決定についても、組織の規模や文化、個々のプロジェクトや各メンバーの気質などの特性に応じて適切な記録の粒度と範囲を見極める必要があります。一方で、日々の実装上の判断や、影響範囲が限定的な決定については、よりライトウェイトな文書化手法を選択すべきでしょう。コードのコメント、プルリクエストの説明、あるいはチームのWikiなどが適しています。ADRの価値は、その決定が組織やプロジェクトに与える影響の大きさに比例するからです。その後、実践的な知見を得るために様々な導入事例を調査しました。以下のブログ記事からは具体的な実装方法や運用上の工夫について多くの学びを得ることができました。user-first.ikyu.co.jplaiso.hatenablog.comblog.studysapuri.jp speakerdeck.comこれらの事例研究を通じて、ADRは単なるドキュメンテーションツールではなく、チーム全体の意思決定プロセスを改善し、知識共有を促進する強力な手段であることを理解しました。その後、自身の関わるプロジェクトでもADRを段階的に導入し、マイクロサービスアーキテクチャにおける設計判断の記録と共有に活用してきました。現在では、チーム内の技術的なコミュニケーションにおいて不可欠なツールとなっています。syu-m-5151.hatenablog.comChapter 1. Centralized Architecture Practices in a Decentralized World第1章「Centralized Architecture Practices in a Decentralized World」では、伝統的なソフトウェアアーキテクチャ実践の詳細な分析と、現代の分散化された開発環境における限界について論じています。著者は、5つの重要な革命的変化を軸に、中央集権的なアーキテクチャ実践の課題を説得力ある形で示しています。この章は、アーキテクチャ実践の根本的な変革の必要性を理解する上で重要な示唆を提供します。伝統的なアーキテクチャ実践の限界著者はまず、伝統的なアーキテクチャ実践を「アイボリータワー型」と「ハンズオン型」という2つの代表的なアプローチに分類します。アイボリータワー型アプローチでは、アーキテクトが組織の上層部に位置し、全体を俯瞰的に見渡しながら統制を重視します。このモデルでは、アーキテクトは開発チームから距離を置き、主に文書やレビューを通じて指示を与えます。Figure 1-1. The ivory tower approach to practicing architecture より引用一方、ハンズオン型アプローチでは、アーキテクトが個々の開発チームに密着し、実装レベルでの直接的な支援を行います。このモデルでは、アーキテクトはチーム間を移動しながら、より実践的な指導と支援を提供します。Figure 1-2. The hands-on, cross-team approach to practicing architecture より引用これら2つのアプローチは、一見異なる実践方法を採用していますが、「アーキテクトへの決定権の集中」という本質的な共通点を持ちます。この中央集権的な特徴は、現代の開発環境において深刻な課題を引き起こします。この課題は顕著です。以前参画した大規模マイクロサービス開発プロジェクトでは、アイボリータワー型アーキテクトの理想的な設計と現場の実際のニーズとの間に大きなギャップが生じました。アーキテクトが提案する完璧な設計は、実際の開発現場での制約や要件と整合性が取れず、結果として開発の遅延と品質の低下を招きました。この経験から、現代のソフトウェア開発においては、より柔軟で適応的なアプローチが必要だと強く感じています。ソフトウェア開発を変えた5つの革命著者は、現代のソフトウェア開発を根本的に変革した5つの重要な革命として、アジャイル開発、クラウドコンピューティング、DevOps、プロダクト思考、ストリーム指向チームを提示します。これらの革命により、ソフトウェア開発はより分散的でフィードバック重視の方向へと導かれました。しかし個人的には、これらに加えて大規模言語モデル(LLM)の台頭が、ソフトウェア開発を根本的に変革する新たな革命になると考えています。LLMによる変革は、単なる開発効率の向上にとどまらず、アーキテクチャの設計プロセスやチーム間のコミュニケーション、意思決定の方法そのものを変える可能性を秘めています。例えば、設計の選択肢の探索や過去の決定の分析、ドキュメンテーションの自動生成といった作業が劇的に効率化され、開発者はより本質的な判断や創造的な活動に注力できるようになるでしょう。私は、これら全ての変革の影響を実務で強く実感しています。DevOpsの導入は、開発と運用の壁を取り払い、より迅速なフィードバックサイクルを実現しました。また、プロダクト思考の浸透により、技術的な卓越性だけでなく、実際のビジネス価値の提供に焦点が当たるようになりました。そしてLLMの活用は、これらの革新をさらに加速させ、ソフトウェア開発の未来を大きく変えていくことでしょう。分散化とフィードバックの重要性著者は、現代のソフトウェアアーキテクチャには「分散化」と「フィードバック」という2つの要素が不可欠だと主張します。以前のプロジェクトでは、分散化されたチーム構造を採用することで、各チームの自律性が向上し、より迅速な意思決定が可能になりました。というか人が多すぎるとフィードバックが大変になる。また、継続的なフィードバックの重要性も実感しています。実際の運用から得られる知見を設計に反映する仕組みを確立することで、より実効性の高いアーキテクチャを実現できました。本番環境での問題や予期せぬユースケースから学び、それを設計に反映するサイクルが重要でした。みんなのフィードバック大全作者:三村 真宗光文社Amazonカオスと不確実性への対応著者は、ソフトウェアシステムにおけるカオスと不確実性を、避けるべき問題としてではなく、むしろ自然な特性として受け入れることを提唱します。私も、この視点は極めて重要だと感じています。完璧な設計を追求するのではなく、変化への適応能力を重視する現実的なアプローチが、現代のソフトウェア開発には不可欠です。エンジニアリング組織論への招待 ~不確実性に向き合う思考と組織のリファクタリング作者:広木 大地技術評論社Amazon注目すべきは「弱い創発」の概念です。私が担当したマイクロサービスプロジェクトでは、予期せぬサービス間の相互作用が発生することがありました。しかし、これを問題視するのではなく、システムの進化の機会として捉え直すことで、より柔軟で強靭なアーキテクチャを実現できました。フィードバックループと伝統的アプローチの課題著者は、伝統的なアーキテクチャ実践の最大の問題点として、効果的なフィードバックループの欠如を指摘します。この指摘は、感覚と完全に一致します。たとえばハンズオン型アプローチでさえ、システム全体からの包括的なフィードバックを適切に取り入れることができていません。著者が挙げる追跡番号管理システムの事例は、この課題を明確に示しています。スケーリング機能と再試行メカニズムの相互作用が予期せぬ動作を引き起こすという事例は、私も似たような事例を経験したことがあります。個々のコンポーネントは適切に設計されていても、それらの組み合わせが予想外の結果をもたらすことは、分散システムではよく起こる現象です。チームの分散化とアーキテクチャの整合性著者は、チームの組織構造とアーキテクチャの構造における整合性の重要性を強調します。これはコンウェイの法則の現代的な解釈として理解できます。この整合性は極めて重要です。マイクロサービスアーキテクチャを採用しながら、中央集権的な意思決定プロセスを維持しようとした組織では、深刻な課題が発生します。マイクロサービスの境界設定や技術選定に関する決定が中央のアーキテクチャチームに集中していたため、各開発チームの自律性が損なわれ、結果として開発のボトルネックが発生しました。アーキテクチャの分散化には、それに対応する組織構造の変革が不可欠だと学びました。結論本章は、現代のソフトウェア開発における伝統的なアーキテクチャ実践の限界を明確に示し、新しいアプローチの必要性を説得力ある形で提示しています。著者が示す予測不可能性の受容、創発的な性質の活用、フィードバックの重視という3つの要件は、実践的な指針として極めて有用です。これらの要件は技術的な側面だけでなく、組織的・文化的な変革も必要とすることが分かっています。重要なのは、チームの自律性を高めながら、組織全体としての一貫性を保つバランスです。分散化とフィードバックを重視する新しいアプローチは、このバランスを実現する上で重要な実践基盤となります。今後、ソフトウェア開発の複雑性はさらに増していくことが予想されます。その中で、本章で示された知見は、より適応力の高い組織とアーキテクチャを実現するための重要な指針となるでしょう。Part I. First PrinciplesPart I. First Principlesは、アーキテクチャ実践の基本原則を示す重要なパートです。伝統的なソフトウェアアーキテクチャの実践が直面する課題と、その解決策として分散型の意思決定アプローチを提案しています。このパートでは、アーキテクチャ実践の核となる「決定」に焦点を当て、その重要性と評価基準を明確にします。さらに大規模な意思決定の従来のアプローチを検証し、それらが現代のソフトウェア開発における分散型の意思決定と迅速なフィードバックという要件を満たせない理由を分析します。この課題に対する解決策として「アーキテクチャ・アドバイスプロセス」を提案します。このプロセスは分散型の意思決定と迅速なフィードバックを両立させる新しいアプローチです。著者はこのプロセスの導入方法や予想される課題、そしてアーキテクチャ決定記録（ADRs）による信頼構築と組織学習の方法を具体的に説明します。このパートは、現代のソフトウェア開発における効果的なアーキテクチャ実践の基礎となる原則と実践方法を包括的に提供しています。アドバイスプロセスとそれを支える要素の理解は、次のパートで扱う実践的なトピックの土台となります。learning.oreilly.comChapter 2. To Practice Architecture Is to Decide第2章「To Practice Architecture Is to Decide」はソフトウェアアーキテクチャの実践における意思決定の本質と重要性を扱います。アーキテクチャ的に重要な意思決定の定義と判断基準について深く掘り下げています。著者はアーキテクチャ意思決定を構造・非機能特性・依存関係・インターフェース・構築技術の5つの観点から整理し実践的な指針を提供します。Software Architecture and Decision-Making: Leveraging Leadership, Technology, and Product Management to Build Great Products がとても良いがlearning.oreilly.comこの本は島田さんによって翻訳されている。とてもありがたい。ソフトウェアアーキテクトのための意思決定術　リーダーシップ／技術／プロダクトマネジメントの活用作者:Srinath PereraインプレスAmazonアーキテクチャ決定の本質著者はすべてのアーキテクチャ決定が技術的決定である一方で技術的決定の全てがアーキテクチャ決定ではないという重要な区別から議論を始めます。この区別は実務上非常に重要です。私もプロジェクトの初期段階でこの区別が曖昧だったために些末な技術的決定に時間を費やしてしまうケースを何度も目にしてきました。Figure 2-1. All architectural decisions are technical decisions, but not all technical decisions are architectural ones より引用アーキテクチャ決定の基準として著者はMichael Nygardの5つの基準を採用します。構造への影響・非機能特性への影響・依存関係への影響・インターフェースへの影響・構築技術への影響です。この基準は実践的で分かりやすく私も日々の意思決定の判断に活用しています。cognitect.comアーキテクチャ的に重要な決定の特定著者は更に一歩踏み込んでアーキテクチャ的に重要な決定の基準を提示します。重要なのは運用環境へのデプロイとの関係です。どんなに優れた設計も実際に動作するまでは単なる仮説に過ぎません。デプロイを阻害する決定は常に重要です。以前関わったプロジェクトでは理想的なアーキテクチャを追求するあまりデプロイが困難になり結果として価値の提供が遅れるという失敗を経験しました。意思決定者の多様性著者はアーキテクチャ決定は必ずしもアーキテクトだけのものではないという重要な指摘を行います。開発者やQAエンジニアも重要なアーキテクチャ決定を行う可能性があります。この視点は伝統的なアーキテクチャ実践からの大きな転換を示唆します。私の現在のプロジェクトでもチームメンバー全員がアーキテクチャ決定に関与する文化を築いています。その結果より良い決定が行われるだけでなくチームの当事者意識も高まっています。意思決定プロセスの重要性著者は意思決定のプロセスよりも結果の重要性を強調します。長時間の検討や意図的な決定であることは必ずしも良い決定を保証しません。むしろ迅速な決定と実践からのフィードバックの方が重要な場合が多いのです。この指摘は私の実務経験とも一致します。完璧な決定を目指して時間をかけるよりも早期に実践し改善を重ねる方が良い結果につながることを何度も経験してきました。結論本章の内容は日々のアーキテクチャ実践に直接活かせる示唆に富んでいます。アーキテクチャ決定の判断基準とデプロイとの関係の2点は重要です。これらの基準を用いることで意思決定の質と速度の両方を改善できます。一方で組織の規模や文化によってはこれらの原則の適用が難しい場合もあります。その場合は段階的な導入や既存のプロセスとの調和を図る必要があるでしょう。結論として本章はアーキテクチャ実践における意思決定の本質を明確に示し実践的な指針を提供しています。これらの知見は現代のソフトウェア開発組織において極めて重要な意味を持ちます。Chapter 3. Decisions at Scale第3章「Decisions at Scale」は組織規模でのアーキテクチャ意思決定プロセスを詳細に分析します。著者は意思決定の本質的な構造を明らかにし標準的な意思決定アプローチの特徴と限界を示しています。現代の分散化されたソフトウェア開発環境における意思決定プロセスの要件について深い洞察を提供します。パーフェクトな意思決定――「決める瞬間」の思考法作者:安藤広大ダイヤモンド社Amazon意思決定プロセスの基本構造著者は意思決定プロセスをオプションの生成と決定の実行と決定の共有という3つの要素に分解します。この単純な分析枠組みは実務上極めて有用です。私も以前関わったマイクロサービスプロジェクトで同様の枠組みを用いて意思決定プロセスを整理しました。重要なのは決定の共有です。いかに優れた決定でも共有が適切に行われなければ無意味です。チーム間のコミュニケーション不足により優れた設計判断が台無しになるケースを何度も目にしてきました。Figure 3-1. A naive view of a generic decision process (“deciding”) in context (the required need for the decision and the subsequent implementation of the result) より引用標準的な意思決定プロセスとその限界著者は意思決定プロセスを中央集権型と分散型に大別します。中央集権型には独裁的・委任型・諮問型があり分散型には合意型・民主型・コンセンサス型があります。多くの組織が中央集権型と分散型のハイブリッドなアプローチを採用します。例えば技術選定は諮問型で行いながら実装の詳細はチームに委ねるといった具合です。意思決定プロセスの文化的基盤意思決定プロセスを考える際に重要なのは、その文化的基盤への理解です。渡邊雅子の『論理的思考とは何か』では、論理的思考が領域ごとに異なる形を取ることを指摘しています。この知見は、アーキテクチャ意思決定プロセスを設計する上で重要な示唆を与えます。経済領域では効率性を重視した思考が、政治領域では合意形成を重視した思考が特徴的です。また、法技術領域では規範性を重視した思考が、社会領域では共感を重視した思考が中心となります。例えば、マイクロサービスアーキテクチャの採用を検討する際、効率性（コストとパフォーマンス）、合意形成（各部門の利害調整）、規範性（セキュリティ要件）、共感（チームの受容性）という異なる観点からの評価が必要になります。アーキテクチャの意思決定プロセスを設計する際は、これらの文化的な思考パターンを状況に応じて適切に組み合わせることが重要です。特に日本の組織においては、共感による推理と配慮的な表現を重視する社会領域のアプローチを適切に取り入れることで、より効果的な意思決定が可能になります。論理的思考とは何か (岩波新書)作者:渡邉 雅子岩波書店Amazon意思決定プロセスの要件著者は意思決定プロセスの4つの要件を示します。適切な人々の関与・決定権の最適化・信頼の重視・共有の最小化です。これらの要件は私の実務経験とも合致します。以前のプロジェクトで決定権を完全に分散化したことで意思決定が遅くなり逆に集中化し過ぎて柔軟性を失うという両極端な失敗を経験しました。実践的な示唆本章の内容は日々のアーキテクチャ実践に直接活かせる示唆に富んでいます。意思決定プロセスの選択基準と共有方法の工夫は重要です。私の現在のプロジェクトでは決定のスコープに応じて異なるプロセスを使い分けています。マイクロサービス間のインターフェース設計は合意型で行う一方サービス内部の実装は各チームに委ねるといった具合です。結論著者はスピードと分散化を両立する新しい意思決定プロセスの可能性を示唆して締めくくっています。この視点は極めて重要です。私も組織の規模や文化に応じて柔軟にプロセスを適応させることが重要だと考えています。一つの正解はなく文脈に応じた適切な選択が必要です。結論として本章は意思決定プロセスの本質を明らかにし実践的な指針を提供しています。これらの知見は現代のソフトウェア開発組織において極めて重要な意味を持ちます。Chapter 4. The Architecture Advice Process第4章「The Architecture Advice Process」はアーキテクチャ意思決定のアプローチを提案します。アドバイスプロセスと呼ばれるこのアプローチは高速な意思決定と権限の分散化を両立します。著者は具体的な事例を通じてこのプロセスの実践方法と効果を示しています。他者と働く──「わかりあえなさ」から始める組織論 (NewsPicksパブリッシング)作者:宇田川元一ニューズピックスAmazonアドバイスプロセスの本質著者は意思決定プロセスの根本的な変革としてアドバイスプロセスを提案します。このプロセスの核心は誰もが意思決定を開始できるという点です。意思決定の集中化は開発の大きなボトルネックとなってきました。アドバイスプロセスでは決定者は2つのグループから助言を求める必要があります。影響を受ける関係者とその領域の専門家です。これは単なる形式的な手続きではなく社会的な契約として機能します。実践例による理解著者は2つの具体例を通じてアドバイスプロセスを説明します。1つ目は開発チームがリリーストグルを導入する事例です。チームは関係者や専門家から助言を得ることで当初の設計を大きく改善しました。私も似たような経験をしています。以前のプロジェクトでフィーチャートグルの導入を決めた際に様々な関係者の意見を聞くことで運用面の課題を事前に把握できました。アドバイスの本質著者はアドバイスは方向性と理由の組み合わせだと説明します。単なる意見との違いは理由の有無です。この視点は極めて重要です。理由を伴わない意見は意思決定の改善につながりません。理由のない意見は混乱を招くだけでした。「このフレームワークを使うべき」という意見より「このフレームワークならこういう理由でこの課題が解決できる」というアドバイスの方が遥かに有用でした。信頼の重要性アドバイスプロセスの成功は信頼関係にかかっています。著者は信頼を築くためには対話が重要だと指摘します。これは私の実務経験とも合致します。信頼はどの職種にも重要である。信頼がない職場では仕事ができないのは万国で共通なのである。対話を通じて相互理解を深めることで初めて有意義なアドバイスが可能になります。一方的な意見の押し付けは避けるべきです。syu-m-5151.hatenablog.com結論アドバイスプロセスは組織文化も変革します。従来型のアーキテクチャ実践では意思決定権限が集中することで様々な歪みが生じていました。アドバイスプロセスはこの問題を解決します。私の組織でもアドバイスプロセスの導入後はチーム間のコミュニケーションが活発になり意思決定のスピードも向上しました。結論として本章はアジャイルな開発環境に適した新しいアーキテクチャ実践を提案しています。アドバイスプロセスは意思決定の民主化と効率化を両立する優れたアプローチです。これからのソフトウェア開発組織にとって重要な示唆を含んでいます。Chapter 5. Rolling Out the Architecture Advice Process第5章「Rolling Out the Architecture Advice Process」はアドバイスプロセスの具体的な導入方法について解説します。著者は現在の組織的立場に応じた3つの導入アプローチを示し導入時の課題と対処法を詳細に説明しています。企業変革のジレンマ　「構造的無能化」はなぜ起きるのか (日本経済新聞出版)作者:宇田川元一日経BPAmazon導入アプローチの選択著者は導入アプローチを現在の意思決定権限に基づいて分類します。アーキテクトとして意思決定権を持つ場合は自身の実践から始めます。開発チームとして権限がない場合は実験的な試行から始めます。この分類は的確です。以前関わったプロジェクトでは権限を持つアーキテクトから導入を始めることで組織全体への浸透がスムーズでした。段階的な導入の重要性著者は小規模な実験からスタートすることを強く推奨します。これは組織の文化や既存のプロセスに大きな変更を加えるためです。実験を通じて課題を早期に発見し対処することが重要です。この指摘は極めて実践的です。私も大規模な変更を一度に行って混乱を招いた経験があります。段階的なアプローチは確実な導入につながります。初期の課題への対応著者は導入初期に直面する主な課題として4つを挙げます。プロセスの誤解、適切な助言者の選定漏れ、Why?の問いかけ不足、責任の所在の不明確さです。これらの課題は私も度々遭遇します。チームが自律的に判断を行う文化への移行には慎重なケアが必要です。信頼の構築著者は信頼関係の構築がプロセスの成功に不可欠だと指摘します。自身と他者の判断能力への信頼、アドバイスの授受への信頼、全体状況の把握への信頼が重要です。私の組織でも信頼関係の醸成に注力しています。定期的な振り返りと成功体験の共有が効果的でした。結論本章の内容は極めて実践的な示唆に富んでいます。導入時のチェックリストは有用です。組織の専門家マップを整備することでアドバイスプロセスがより効果的になります。私の現在のプロジェクトでもこのアプローチを採用しています。各領域の専門家を明確化することで適切なアドバイスを得やすくなりました。結論として本章はアドバイスプロセスの実践的な導入方法を提供しています。組織の現状に応じた段階的な導入と信頼関係の構築に焦点を当てた著者の提案は極めて妥当です。次章で説明される「アーキテクチャ決定記録」と組み合わせることで更に効果的な実践が可能になるでしょう。Chapter 6. Architectural Decision Records第6章「Architectural Decision Records」は、アーキテクチャ意思決定プロセスを支援し記録するための実践的なアプローチとしてArchitectural Decision Records (ADRs)を詳細に解説しています。ADRsはアーキテクチャ意思決定の透明性を高め、組織の学習を促進する重要なツールとして位置づけられています。百年の孤独 (新潮文庫 カ 24-2)作者:ガブリエル・ガルシア=マルケス新潮社AmazonADRsの本質と目的ADRsは単なる決定の記録ではありません。アーキテクチャ意思決定の全過程を支援する重要なツールです。現代のソフトウェア開発では意思決定の透明性とトレーサビリティが極めて重要です。実際の開発現場では以前のアーキテクチャ決定が後から問題を引き起こすことがしばしば発生します。ADRsはそのような状況でもアーキテクチャ決定の背景と理由を明確に示すことができます。意思決定の全プロセスをサポートするADRsの役割は重要です。とあるプロジェクトでも複雑なマイクロサービスアーキテクチャの移行においてADRsを活用しました。チーム間のコミュニケーションが改善され決定プロセスの透明性が大きく向上しました。Figure 6-1. The place of ADRs in the advice process より引用ADRsとDesign docsの違いここでADRsとよく比較されるDesign docsとの主な違いを整理しておくことは有用でしょう。両者は一見似ているように見えますが、その目的と特性は大きく異なります。tkybpp.hatenablog.comADRsは個々の重要な技術的決定に焦点を当て、その決定に至った背景と理由を時系列で記録します。例えば「なぜKafkaではなくRabbitMQを選択したのか」「どうしてMongoDBを採用したのか」といった具体的な決定事項とその文脈を残します。一度記録された決定は変更せず、新しい決定を追加することで履歴を形成していきます。一方、Design docsはシステム全体やコンポーネントの設計を包括的に説明することを目的とします。技術的な設計の詳細、アーキテクチャの全体像、実装方針などを広く扱い、システムの各部分の関係性を示します。Design docsは必要に応じて更新され、常に現在の設計状態を反映するように維持されます。この違いは実務上重要な意味を持ちます。あるマイクロサービス開発プロジェクトでは、Design docsでシステム全体のアーキテクチャや各サービスの役割、データフローを説明する一方で、ADRsでは個別の技術選定の決定と理由を記録していました。両者は補完関係にあり、大規模なプロジェクトでは両方を併用することで、設計の全体像と重要な決定の経緯の両方を効果的に残すことができます。このように、ADRsはDesign docsと異なり、意思決定のプロセスと理由を明確に記録することに特化しています。この特徴は、後述する「意思決定の全プロセスをサポート」という役割と密接に結びついています。他にも技術ドキュメントはあるのですが全体を探るにはこちらがオススメです。技術文書の書き方 · GitHubADRsの構造と実践ADRsには明確な構造があります。タイトル、メタデータ、決定内容、コンテキスト、オプション、結果、アドバイスという基本的なセクションで構成されます。各セクションは読み手を意識した構造になっており、決定の背景から結果までを効果的に伝えることができます。実際の開発現場ではオプションと結果のセクションが重要です。あるプロジェクトでデータベースの選定を行う際にADRsを活用しました。複数のオプションを比較検討する過程で、チームメンバー全員が意思決定に参加できる環境を作ることができました。ADRsのライフサイクル管理ADRsのステータス管理は重要です。ドラフト、提案、承認、廃止といった基本的なステータスに加えて、組織の必要に応じて独自のステータスを追加することも可能です。ステータス管理を通じてADRsの現在の状態を明確に示すことができます。とある案件ではGitHubのプルリクエストプロセスとADRsを統合しました。これによりレビューとフィードバックのプロセスが自然な形で確立され、意思決定の質が向上しました。ADRsの組織的影響ADRsの導入は組織文化にも大きな影響を与えます。意思決定プロセスの透明性が高まることで、チーム間の信頼関係が強化されます。また、過去の決定を参照できることで、新しいメンバーのオンボーディングも効率化されます。一方で、ADRsの導入には慎重なアプローチが必要です。形式的な文書作成に陥らないよう、実際の意思決定プロセスを支援するツールとして活用することが重要です。過度な形式主義は避けるべきです。結論と展望ADRsは現代のソフトウェア開発組織に不可欠なツールです。アーキテクチャ意思決定の透明性を高め、組織の学習を促進します。しかし、その効果を最大限に引き出すためには、組織の文化や既存のプロセスに合わせた適切な導入が必要です。Figure 6-1の意思決定プロセスの図は印象的です。ADRsが意思決定のどの段階でどのように活用されるかを明確に示しています。この図は実際の導入時のガイドとしても有用です。今後の課題としては、分散開発チームでのADRsの活用や、自動化ツールとの統合などが考えられます。これらの課題に取り組むことで、より効果的なアーキテクチャ意思決定プロセスを実現できるでしょう。結論ADRsは理論的な枠組みとしても優れていますが、実践的なツールとしてさらに重要です。とある案件では週次のアーキテクチャレビューでADRsを活用しています。これにより意思決定プロセスが標準化され、チーム全体の理解が深まりました。最後に強調したいのは、ADRsは生きたドキュメントだということです。形式的な文書作成に終始せず、実際の意思決定プロセスを支援するツールとして活用することが成功の鍵となります。組織の成長とともにADRsも進化させていく柔軟な姿勢が重要です。Chapter 6. Architectural Decision Records第6章「Architectural Decision Records」は、アーキテクチャ意思決定プロセスを支援し記録するためのアプローチとしてArchitectural Decision Records (ADRs)を詳細に解説しています。ADRsはアーキテクチャ意思決定の透明性を高め、組織の学習を促進する重要なツールとして位置づけられています。ADRsの本質と目的ADRsは単なる決定の記録ではありません。アーキテクチャ意思決定の全過程を支援する重要なツールです。現代のソフトウェア開発では意思決定の透明性とトレーサビリティが極めて重要です。実際の開発現場では以前のアーキテクチャ決定が後から問題を引き起こすことがしばしば発生します。ADRsはそのような状況でもアーキテクチャ決定の背景と理由を明確に示すことができます。意思決定の全プロセスをサポートするADRsの役割は重要です。とあるプロジェクトでも複雑なマイクロサービスアーキテクチャの移行においてADRsを活用しました。チーム間のコミュニケーションが改善され決定プロセスの透明性が大きく向上しました。Figure 6-1. The place of ADRs in the advice process より引用ADRsの構造と実践ADRsには明確な構造があります。タイトル、メタデータ、決定内容、コンテキスト、オプション、結果、アドバイスという基本的なセクションで構成されます。各セクションは読み手を意識した構造になっており、決定の背景から結果までを効果的に伝えることができます。実際の開発現場ではオプションと結果のセクションが重要です。あるプロジェクトでデータベースの選定を行う際にADRsを活用しました。複数のオプションを比較検討する過程で、チームメンバー全員が意思決定に参加できる環境を作ることができました。ADRsのライフサイクル管理ADRsのステータス管理は重要です。ドラフト、提案、承認、廃止といった基本的なステータスに加えて、組織の必要に応じて独自のステータスを追加することも可能です。ステータス管理を通じてADRsの現在の状態を明確に示すことができます。とある案件ではGitHubのプルリクエストプロセスとADRsを統合しました。これによりレビューとフィードバックのプロセスが自然な形で確立され、意思決定の質が向上しました。ADRsの組織的影響ADRsの導入は組織文化にも大きな影響を与えます。意思決定プロセスの透明性が高まることで、チーム間の信頼関係が強化されます。また、過去の決定を参照できることで、新しいメンバーのオンボーディングも効率化されます。一方で、ADRsの導入には慎重なアプローチが必要です。形式的な文書作成に陥らないよう、実際の意思決定プロセスを支援するツールとして活用することが重要です。過度な形式主義は避けるべきです。結論と展望ADRsは現代のソフトウェア開発組織に不可欠なツールです。アーキテクチャ意思決定の透明性を高め、組織の学習を促進します。しかし、その効果を最大限に引き出すためには、組織の文化や既存のプロセスに合わせた適切な導入が必要です。今後の課題としては、分散開発チームでのADRsの活用や、自動化ツールとの統合などが考えられます。これらの課題に取り組むことで、より効果的なアーキテクチャ意思決定プロセスを実現できるでしょう。結論ADRsは理論的な枠組みとしても優れていますが、実践的なツールとしてさらに重要です。とある案件では週次のアーキテクチャレビューでADRsを活用しています。これにより意思決定プロセスが標準化され、チーム全体の理解が深まりました。最後に強調したいのは、ADRsは生きたドキュメントだということです。形式的な文書作成に終始せず、実際の意思決定プロセスを支援するツールとして活用することが成功の鍵となります。組織の成長とともにADRsも進化させていく柔軟な姿勢が重要です。Part II. Nurturing and Evolving Your Culture of Decentralized TrustPart II. Nurturing and Evolving Your Culture of Decentralized Trustは、分散型アーキテクチャにおける組織文化の育成と発展に焦点を当てたパートです。Part Iで示したアドバイスプロセスとADRsを基盤として、それらを実効性のある仕組みへと成長させるために必要な要素を解説します。従来のヒエラルキー型組織から信頼ベースの分散型組織への移行における権限とガバナンスの再構築から始まり、その実現を支援する具体的な仕組みを提示します。特徴的なのはアーキテクチャ・アドバイスフォーラム、クロスファンクショナル要件、技術戦略、アーキテクチャ原則、テクノロジーレーダーといった支援要素の導入です。これらは一見シンプルですが、組織の状況に応じて柔軟に適用・進化させることができる実践的なツールです。このパートは、分散型アーキテクチャの実践に不可欠な信頼の文化を育むための具体的なアプローチを提供します。組織の一貫性を保ちながら分散型の意思決定を実現する方法を学ぶことができます。Chapter 7. Replacing Hierarchy with Decentralized Trust第7章「Replacing Hierarchy with Decentralized Trust」は、組織の階層構造を分散化された信頼関係へと転換する過程について詳細に解説しています。この章を通じて著者は、アーキテクチャの実践における信頼の重要性と、その育成・維持に必要な要素を具体的に示しています。変化を起こすリーダーはまず信頼を構築する　生き残る組織に変えるリーダーシップ作者:Frances Frei（フランシス・フライ）,Anne Morriss（アン・モリス）日本能率協会マネジメントセンターAmazon信頼に基づく意思決定への転換アーキテクチャ・アドバイスプロセスは従来の階層的な意思決定構造を根本から変革します。意思決定の責任と説明責任を再分配し、より分散的で柔軟な組織構造を実現します。この転換は組織に大きな変化をもたらします。あるプロジェクトでは、従来のアーキテクチャ・レビューボードを廃止し、アドバイスプロセスへの移行を実施しました。当初は混乱もありましたが、チーム間のコミュニケーションが活発になり意思決定のスピードが大幅に向上しました。信頼文化の醸成著者は信頼文化の育成が不可欠だと主張します。信頼は自然に生まれるものではなく、意識的な取り組みが必要です。組織の規模が大きくなるにつれて、信頼関係の維持は難しくなります。とある案件では週次の振り返りミーティングを設け、意思決定プロセスの透明性を確保しています。これにより、チームメンバー同士の信頼関係が強化され、より良い意思決定が可能になりました。フロー重視のマインドセット著者はフローを重視するマインドセットの重要性を強調します。Netflixの事例を引用しながら、不必要な規則や承認プロセスを排除することの意義を説明します。実際のプロジェクトでも、過度な承認プロセスがボトルネックとなっていた経験があります。アドバイスプロセスの導入により、意思決定のフローが改善され、開発のスピードが向上しました。信頼の維持と成長組織の成長とともに信頼関係を維持することは困難になります。著者は小規模なチームから大規模な組織への移行過程で起こる課題を詳細に分析します。あるプロジェクトでは、チームの規模拡大に伴い、非公式なクリークが形成され始めました。この問題に対して、定期的な1on1ミーティングとフィードバックセッションを導入することで、信頼関係の維持に成功しました。信頼を支える要素著者は信頼関係を支える追加的な要素について言及します。これにはアーキテクチャ・アドバイスフォーラムや検証可能なCFRなどが含まれます。これらの要素は組織の状況に応じて選択的に導入することが重要です。とある案件では技術レーダーを導入し、技術選定の透明性を確保しています。これにより、チーム間の知識共有が促進され、より良い意思決定が可能になりました。確実性と予測可能性の誘惑著者は確実性と予測可能性への執着に警鐘を鳴らします。これは組織が官僚主義に陥る主要な原因となります。私も以前、過度な標準化により柔軟性を失ったプロジェクトを経験しています。実験的アプローチの重要性著者は継続的な実験とフィードバックの重要性を強調します。これは組織学習の核心です。とある案件でも小規模な実験から始め、成功事例を徐々に拡大するアプローチを採用しています。結論この章は、分散化された信頼に基づくアーキテクチャ実践への移行について、実践的な指針を提供しています。組織の成長に伴う信頼関係の変化と、それに対する対応策の重要性は印象的でした。これらの知見は、現代のソフトウェア開発組織に重要な示唆を与えます。技術の進化とともに組織構造も進化が必要です。分散化された信頼関係に基づく意思決定プロセスは、その進化の重要な一歩となるでしょう。今後の課題としては、リモートワークの普及に伴う信頼関係の構築方法や、グローバル組織における文化的な違いへの対応などが考えられます。これらの課題に対しても、本章で示された原則は有効な指針となるはずです。Chapter 8. An Architecture Advice Forum第8章「An Architecture Advice Forum」は、アーキテクチャ・アドバイスプロセスを支援する重要なツールとしてのアーキテクチャ・アドバイスフォーラムについて詳細に解説しています。この章を通じて、著者は定期的な対話の場がアーキテクチャ意思決定の質を向上させ、組織の信頼関係を強化する方法を具体的に示しています。ダイアローグ 価値を生み出す組織に変わる対話の技術作者:熊平美香ディスカヴァー・トゥエンティワンAmazonアドバイスフォーラムの本質アーキテクチャ・アドバイスフォーラムは単なる会議ではありません。それは意思決定プロセスを透明化し信頼関係を構築する場です。従来のアーキテクチャレビューボードとは異なり、承認プロセスではなく対話を重視します。このフォーラムの導入により意思決定の質が劇的に向上しました。あるプロジェクトでは、マイクロサービスアーキテクチャへの移行を決定する際にアドバイスフォーラムを活用し、多様な視点からの意見を集約できました。フォーラムの構造と運営フォーラムはシンプルな構造を持ちます。新規の決定案件に対するアドバイス、既存の決定のステータス確認、そしてその他の事項という基本的な議題構成です。このシンプルさが参加者の集中力を高め、本質的な議論を可能にします。実際の運用では定期的な開催が重要です。週次や隔週での開催が一般的ですが、組織の規模や文化に応じて調整が必要です。とある案件では週次開催を採用し、必要に応じて臨時セッションも設けています。協調的な議論の促進従来の対立的な議論から協調的な対話へのシフトがアドバイスフォーラムの特徴です。参加者は意見を戦わせるのではなく、共通の課題解決に向けて知見を共有します。Figure 8-1は従来の一対一のアドバイス形式と、フォーラム形式の違いを明確に示しています。フォーラムでは複数の視点が同時に共有され、より豊かな議論が可能になります。Figure 8-1. Comparing the interaction modes of the “no advice forum” approach (multiple, one-to-one serial interactions, one after another) with the “advice forum” alternative (multiple conversations, all in the same forum, with an audience of other advice offerers as well as nonadvising, learning observers) より引用信頼関係の構築アドバイスフォーラムは信頼関係の構築に大きく貢献します。定期的な対話を通じて、チーム間の理解が深まり、組織全体の凝集性が高まります。このフォーラムを通じて部門間の壁が徐々に低くなっていきました。実践的な導入方法フォーラムの導入は段階的に行うべきです。まず小規模なグループで実験的に開始し、成功事例を積み重ねていくアプローチが効果的です。初期段階では明確な目的と期待値を設定することが重要です。とある案件では最初の3ヶ月を試験期間として設定し、参加者からのフィードバックを基に継続的な改善を行いました。この経験から、フォーラムの形式は組織の文化に合わせて柔軟に調整すべきだと学びました。組織的な影響フォーラムは組織文化の変革をもたらします。透明性の向上は信頼関係を強化し、より良い意思決定を可能にします。また、新しいメンバーの参加障壁を下げ、知識共有を促進します。結論アーキテクチャ・アドバイスフォーラムは、現代のソフトウェア開発組織に不可欠なツールです。透明性と信頼を基盤とした意思決定プロセスは、より良いアーキテクチャの実現と組織の成長を支援します。今後の課題としては、リモートワーク環境でのフォーラムの効果的な運営や、大規模組織での展開方法の確立が挙げられます。しかし、フォーラムの基本原則を理解し適切に適用すれば、これらの課題も克服できるはずです。このフォーラムは組織の成熟度を高める強力な触媒となります。アーキテクチャ設計の質を向上させるだけでなく、エンジニアリング組織全体の協調性と創造性を高める効果があります。Chapter 9. Testable CFRs and Technology Strategy第9章「Testable CFRs and Technology Strategy」は、組織の技術的アラインメントを実現するための2つの重要な要素について詳細に解説しています。著者はテスト可能なCFR（Cross-Functional Requirements）と技術戦略を通じて、効果的な組織アラインメントを実現する方法を具体的に示しています。組織アラインメントの本質組織のアラインメントは単なる技術的な整合性以上のものです。多くの組織が技術的な標準化のみに注力し、ビジネス目標との整合性を見失いがちです。実際のプロジェクトでは、技術的な方向性は揃っていても組織の目標達成に寄与していないケースをよく目にします。あるプロジェクトでは、マイクロサービスアーキテクチャの採用により技術的な統一は図れましたが、サービスの分割粒度が業務の実態と合わず、結果として開発効率の低下を招きました。テスト可能なCFRの重要性著者はテスト可能なCFRの必要性を強調しています。CFRはシステム全体に横断的に適用される要件を明確にします。重要なのは、これらの要件が具体的でテスト可能な形で記述されることです。とある案件では、パフォーマンス要件を具体的な数値で定義し、自動テストで継続的に検証できるようにしました。「レスポンスタイムは500ms以内」といった曖昧な表現ではなく、「95%のリクエストが500ms以内、99%が800ms以内に完了すること」と明確に定義することで、チーム間の認識の違いを解消できました。技術戦略の役割技術戦略は組織の方向性を示す重要なツールです。著者は技術戦略を「組織のビジョンと目標達成に向けた技術的な選択と投資判断のフレームワーク」と定義しています。多くの組織が技術戦略を単なる技術選定の指針として扱いがちです。しかし、より重要なのは「何を選択しないか」の明確化です。あるプロジェクトでは、特定のクラウドプロバイダーに限定することで、運用負荷の軽減とコスト最適化を実現できました。ミニマルバイアブルアグリーメント著者は必要最小限の合意の重要性を強調します。これはCFRと技術戦略の両方に適用される概念です。過剰な標準化や制約は組織の柔軟性を損なう一方、不十分な合意は混乱を招きます。とある案件では「最小驚き原則」を採用し、チーム間で予期せぬ違いが発生していないかを定期的にチェックしています。これにより、必要な標準化と柔軟性のバランスを維持できています。戦略的投資の重要性著者は技術戦略を「言葉だけでなく投資」として具現化することを推奨します。これは共有サービスの形で実現されることが多いです。セルフサービス型のインフラストラクチャプラットフォームの提供が効果的でした。各チームが独自のインフラを構築・運用するのではなく、標準化されたプラットフォームを利用することで、開発効率の向上とコスト削減を実現できました。結論CFRと技術戦略は組織アラインメントを実現する上で不可欠なツールです。これらを適切に組み合わせることで、組織は効率的かつ効果的な意思決定が可能になります。しかし、これらのツールの導入には慎重なアプローチが必要です。組織の規模や文化に応じて、段階的な導入と継続的な改善が重要です。今後は、分散開発やクラウドネイティブアーキテクチャの普及に伴い、より柔軟で適応性の高いCFRと技術戦略の在り方が求められるでしょう。技術の進化に合わせて、これらのフレームワークも進化させていく必要があります。Chapter 10. Collectively Sourced Architectural Principles第10章「Collectively Sourced Architectural Principles」は、組織全体で共有されるアーキテクチャ原則の策定と維持について解説しています。この章を通じて著者は、アーキテクチャ原則が単なるドキュメントではなく、組織の技術戦略を実現するための重要な指針となることを示しています。チームトポロジー　価値あるソフトウェアをすばやく届ける適応型組織設計作者:マシュー・スケルトン,マニュエル・パイス日本能率協会マネジメントセンターAmazonアーキテクチャ原則の本質アーキテクチャ原則は組織の技術戦略を具体化する重要なツールです。多くの組織がトップダウンでアーキテクチャ原則を定めようとしますが、そのアプローチでは現場の実態と乖離した形骸化した原則になりがちです。実際のプロジェクトでは、チームメンバー全員で原則を策定することで、より実践的で実効性のある原則を作ることができました。例えばマイクロサービスアーキテクチャの採用において、「チームの独立性を最も重視する」という原則を設定し、サービス間の結合度を最小限に抑えることができました。learning.oreilly.comプリンシプルワークショップの実践著者はプリンシプルワークショップを通じて、組織全体で原則を策定することを推奨しています。重要なのは、参加者の多様性と、戦略的なテーマに基づいた原則の整理です。原則のメンテナンス原則の進化も重要なテーマです。著者は原則を「生きたドキュメント」として捉え、定期的な見直しと更新の必要性を説きます。ADRsを通じて原則の変更を記録し、その背景と理由を明確にすることで、組織の学習を促進できます。クラウドネイティブ化の過程で原則の見直しが必要になりました。「自社のクラウド」という原則に縛られすぎて柔軟性を失っていたため、「適切なクラウドサービスの選択」という原則に更新しました。組織文化との関係著者は原則が組織文化の反映であることを強調します。単なる技術的なガイドラインではなく、組織の価値観とビジョンを体現するものとして位置づけています。私のチームでは原則の策定プロセス自体が、組織文化の変革のきっかけとなりました。チーム間の対話が活発になり、技術的な決定に対する共通理解が深まりました。実践的な適用原則の適用は柔軟であるべきです。著者は原則を「絶対的なルール」ではなく「意思決定の指針」として捉えることを推奨します。これは現代のソフトウェア開発における不確実性に対応する賢明なアプローチです。例えば、あるプロジェクトでは特定の機能実装において原則との衝突が発生しましたが、その状況をADRで明確に記録し、例外的な対応の理由を共有することで、チーム全体の理解を深めることができました。結論アーキテクチャ原則は、組織の技術戦略を実現するための重要なツールです。しかし、その効果を最大限に引き出すためには、全員参加の策定プロセス、定期的な見直し、そして柔軟な適用が不可欠です。今後の課題としては、リモートワーク環境での原則策定ワークショップの実施方法や、グローバル組織での文化的な違いへの対応が挙げられます。しかし、著者が示した基本的なフレームワークは、これらの課題に対しても十分な適用可能性を持っています。Part III. Finding Your Way Through the Decision LandscapeChapter 11. Technology Radar第11章「Using a Technology Radar」は、組織の技術選択と意思決定を支援するためのツールとしてのTechnology Radarについて解説しています。著者は単なる技術トレンドの可視化ツール以上の価値をTechnology Radarに見出し、組織の集合知を活用した意思決定支援の仕組みとして位置づけています。Technology Radarといえばどこかのポッドキャストでt-wadaさんがオススメをしていたのでそこから見始めている(本当に覚えてなくて誰か教えてください⋯)。www.thoughtworks.comTechnology Radarの本質Technology Radarは航空管制のレーダーに似た形式で技術トレンドを可視化します。Thoughtworksが開発したこのツールは技術の採用状況を4つの象限(Tools/Techniques/Platforms/Languages & Frameworks)と4つのリング(Adopt/Trial/Assess/Hold)で表現します。著者はこれを「単なる技術マッピングではなく組織の集合的な経験と知見を凝縮したもの」と説明します。このビジュアライゼーションは一目で技術の位置づけを把握できる優れた特徴を持ちます。「Mermaid」のような新興技術が「Trial」から「Adopt」へ移行する様子や「AWS」が「Adopt」から「Trial」へ後退する変遷など、技術の盛衰を時系列で追跡できます。Technology Radarと意思決定プロセスTechnology Radarは組織の意思決定プロセスと密接に連携します。アーキテクチャ決定記録(ADR)にTechnology Radarのブリップ(技術要素)を参照することで、決定の文脈や根拠を明確にできます。Technology Radarと意思決定プロセスの連携は双方向です。新しい技術の採用決定は新規ブリップの追加につながり、既存技術の評価変更は位置の移動として反映されます。この相互作用により、組織の技術選択の履歴と根拠が透明化されます。組織独自のTechnology Radarの構築著者は組織固有のTechnology Radarの重要性を強調します。社内版Technology Radarでは自社開発のツールやフレームワークもブリップとして登録できます。また象限やリングの定義も組織の文脈に合わせて調整可能です。Technology Radarの作成プロセスもまた重要な価値を持ちます。ブリップの収集から位置づけの決定まで、組織全体を巻き込んだ共創的なプロセスとして設計されています。このプロセス自体が技術に関する組織的な対話と学習の機会となります。継続的な更新と発展Technology Radarは定期的な更新(リスイープ)により鮮度を保ちます。更新プロセスにおけるブリップのステータス変更を示しています。定期更新に加えて個別の意思決定に応じた随時更新も可能です。この柔軟な更新メカニズムにより、組織の技術動向をリアルタイムに反映できます。更新の際にはブリップの履歴を保持することが推奨されます。各ブリップの変遷を追跡できる履歴ページを用意することで、技術選択の経緯と根拠を後から参照できます。これは新規参画者のオンボーディングや過去の意思決定の振り返りに有用です。実践的な示唆Technology Radarの実践では、適切な更新頻度の設定が重要です。著者は四半期または半年ごとの更新を推奨していますが、組織の技術変化の速度に応じて調整が必要です。より重要なのは更新のクオリティです。表面的な技術トレンドの追跡ではなく、組織の経験と教訓を凝縮した有意義な指針となることを目指すべきです。Technology Radarの運用では意思決定支援ツールとしての本質を見失わないことが肝要です。単なる技術カタログではなく、組織の技術選択を導く羅針盤として機能させる必要があります。そのためには技術情報の蓄積だけでなく、その活用を促進する仕組みづくりも重要です。Technology Radarは組織の技術戦略を可視化し共有するための強力なツールです。しかしその効果を最大限に引き出すには、組織文化や既存のプロセスとの調和が不可欠です。形式的な導入ではなく、組織の意思決定プロセスと密接に連携させることで、真の価値を発揮できます。結論Technology Radarは組織の技術選択を支援する効果的なツールとして機能します。その価値は単なる技術トレンドの可視化にとどまらず、組織の集合知を活用した意思決定支援の仕組みとして重要です。定期的な更新と履歴の保持により、組織の技術進化の軌跡を記録し学習に活かすことができます。意思決定プロセスとの密接な連携により、組織全体の技術力向上に貢献する重要な基盤となります。Part III. Finding Your Way Through the Decision LandscapePart III: Finding Your Way Through the Decision Landscape では、分散型の意思決定プロセスを効果的に実践するためのフレームワークや技術、心構えを紹介しています。まず、意思決定における人間的な側面に焦点を当て、感情、創造性、バイアス、恐れといった要素がどのように意思決定に影響を与えるかを探り、それを乗り越えるために認知科学やチェックリストを活用して自己の弱点を意識的に克服する方法を提案します。また、ソフトウェア開発における不確実性や「未知の未知」に対処するために、小さな決定を迅速に積み重ねるアプローチや、最小限の機能を持つシステムを構築して初期段階で重要な決定を検証する「Walking Skeleton」を推奨し、スパイクを活用してリスクを軽減する方法を説明します。さらに、意思決定の相互関連性を認識し、過去と未来の決定がどのように影響し合うかを4つの視点から分析しながら、技術的および社会技術的な要素を考慮したアプローチを示し、組織内の信頼関係や文化の影響を考慮した対話やフィードバックを重視することの重要性を強調しています。これらを通じて、分散型の意思決定を支える心構えと実践的な手法を提供し、複雑な意思決定の環境を乗り越えるための実用的な知見を得られるようにしています。Chapter 12. The Art of Deciding第12章「The Art of Deciding」は、アーキテクチャ意思決定における人間的な側面、感情や創造性といった定量化が難しい要素に焦点を当てています。著者は意思決定を単なる論理的プロセスとしてではなく、人間の感性や組織の文化が深く関わる芸術的な営みとして捉え、その本質と実践方法を詳細に解説しています。コンテキストのフレーミング意思決定における最初の重要なステップは適切なコンテキストの設定です。著者は地図の比喩を用いて説明します。1:1の地図は全ての詳細を含むものの実用的ではありません。一方で1:1000の地図は必要な情報を抽象化し意思決定を支援します。意思決定のコンテキストも同様に適切な抽象化と焦点付けが重要です。例えば私が以前関わったクラウド移行プロジェクトでは、技術的な観点だけでなく法規制やビジネス要件も含めた包括的なコンテキストを設定することで、より適切な意思決定が可能になりました。オプションと結果の検討意思決定のオプションと結果を検討する際は創造性が重要な役割を果たします。著者は「フレームに制限されすぎない」ことを強調します。これは実務でも重要な指摘です。以前のプロジェクトで既存のアーキテクチャパターンにとらわれすぎた結果、より良いソリューションを見逃した経験があります。オプションの検討ではインスピレーションの源を広く求めることも重要です。技術書だけでなく他分野の知見も参考になります。例えば著者は農業の本からも洞察を得ています。この多面的なアプローチは新しい視点をもたらします。アドバイスを通じた洗練アドバイスプロセスは意思決定の質を高める重要な要素です。ただしこれは形式的なものではなく社会的な契約として機能します。著者はBadaraccoの質問フレームワークを引用し「我々の義務は何か」「現実の世界で何が機能するか」といった観点からの検討を推奨します。実務ではアドバイスの質と形式のバランスが重要です。形式的なレビューに陥らず建設的な対話を生み出すには組織文化の醸成が必要です。私のチームでは週次のアーキテクチャ・フォーラムを設け、オープンな議論の場を作っています。メタ認知の重要性著者は意思決定者のメタ認知（自己の思考プロセスへの理解）の重要性を強調します。これは感情やバイアスへの対処に重要です。例えば「なぜその選択に不安を感じるのか」「どのようなバイアスが働いているのか」を意識的に考えることで、より良い判断が可能になります。実践では3つのエクササイズが提案されています。理由の共有・反応と応答の区別・挑戦的なアドバイスの積極的な収集です。これらは日々の意思決定プロセスに組み込むことで効果を発揮します。意思決定の実行最後の意思決定の実行段階では恐れとバイアスへの対処が重要です。著者はBikartの5つの恐れ（失敗・成功・同一化・認識欠如・利己性）を紹介し、これらへの認識と対処の重要性を説明します。実務では「決定を試着する」というアプローチが有効です。ADRをドラフト状態で作成し一晩置くことで、より客観的な判断が可能になります。私のチームでもこのプラクティスを採用し効果を上げています。組織文化への影響本章の内容は個人の意思決定スキル向上だけでなく組織文化の変革にも大きな示唆を与えます。従来型のアーキテクトが意思決定権限を手放し、アドバイザーとしての新しい役割を受け入れるプロセスは重要です。本章では著者が実際に経験した事例としてPete Hunter（エンジニアリングディレクター）のケースが印象的です。Pete Hunterはアーキテクチャ・アドバイスプロセスを初めて導入したクライアントの一人でした。彼は当初、チームに意思決定権限を委譲することへの不安や懸念を抱えていましたが、プロセスを通じて組織の成長を実感しました。Hunterの事例は権限移譲における心理的な課題を鮮明に示しています。彼は意思決定権限の委譲に際して、チームの能力や判断への不安、コントロール欲求との葛藤など、多くのリーダーが直面する感情的な課題を率直に語っています。しかし最終的に彼は「We need to let go and support them」（権限を手放してチームをサポートする必要がある）という重要な洞察に至りました。この経験は組織における信頼構築と権限委譲の本質を示す貴重な事例となっています。結論アーキテクチャ意思決定は論理的な分析だけでなく人間的な要素を含む複雑な営みです。本章は意思決定の「アート」としての側面に光を当て、より効果的な実践のための具体的なガイダンスを提供しています。重要なのはコンテキストのフレーミング、創造的なオプション検討、アドバイスプロセスの活用、メタ認知の実践です。これらの要素を意識的に取り入れることで、より良いアーキテクチャ意思決定が可能になります。今後の組織運営においては、これらの知見を活かした意思決定プロセスの確立と、それを支える文化の醸成が重要な課題となるでしょう。技術的な卓越性と人間的な洞察の両立が、現代のソフトウェアアーキテクチャ実践には不可欠です。Chapter 13. Tackling Architectural Variability第13章「Tackling Architectural Variability」は、ソフトウェア開発における不確実性とアーキテクチャの可変性に焦点を当てています。著者は同じシステムを二度と作ることはないという洞察から始め、この本質的な可変性にどう向き合うべきかについて具体的な指針を提供します。BIG THINGS　どデカいことを成し遂げたヤツらはなにをしたのか？作者:ベント・フリウビヤ,ダン・ガードナーサンマーク出版Amazon可変性の本質と影響ソフトウェア開発における可変性は避けられない現実です。最も慎重に計画された開発プロジェクトでさえ予期せぬ変化に直面します。例えばある大規模プロジェクトでは、当初想定していなかったスケーリング要件の変更により、ID管理システムの設計を大幅に見直す必要が生じました。可変性は4つの主要な課題をもたらします。作業の困難さ、予測不可能な変更の発生、認知的負荷の増大、そしてコミュニケーションと同期のオーバーヘッドです。これらの課題は個々のチームだけでなく組織全体に影響を及ぼします。可変性への実践的アプローチ著者は可変性を単なる問題としてではなく「ソフトウェアの力の源泉」として捉え直すことを提案します。この視点は非常に重要です。私のチームでも、予期せぬ要件変更を新機能開発の機会として活用した経験があります。重要なのは小さな決定の積み重ねというアプローチです。この方法は3つの利点を持ちます。第一に意思決定から実装までの時間を短縮できます。第二にオーバーヘッドを削減できます。そして第三にフィードバックを加速し、リスクを低減できます。Walking Skeletonの活用著者は初期の意思決定を検証する手段としてWalking Skeletonの概念を紹介します。これは最小限の機能を持つ実装を通じて、主要なアーキテクチャ上の決定を早期に検証する手法です。新規プロジェクトの立ち上げ時にこのアプローチを採用し、大きな効果を得ました。注目すべきは機能的なコンテキストを通じた決定の検証です。単なる技術的な検証ではなく実際のユースケースに基づく検証により、より実践的なフィードバックを得ることができます。フラクチャープレーンの活用大きな決定を分割する際の指針として著者はフラクチャープレーンの概念を提示します。機能的、タイミング的、コードベース上の分割点を見極めることで、より効果的な意思決定が可能になります。私のプロジェクトでも、マイクロサービスの分割において、この考え方に基づいてサービス境界を定義し、成功を収めました。将来のフローへの影響意思決定は現在の開発フローだけでなく将来のフローにも影響を与えます。著者はReinertsenの「小さなバッチサイズは高いオーバーヘッドを生む」という一般的な認識への反論を紹介します。実際の開発現場でも、小さな決定の積み重ねが結果として意思決定の質と速度を向上させる事例を多く経験しています。結論可変性はソフトウェア開発の本質的な特徴であり、それを排除するのではなく「活用する」という視点が重要です。著者の提案する小さな決定の積み重ねというアプローチは、現代のソフトウェア開発における実践的な指針となります。この方法はマイクロサービスアーキテクチャなど複雑なシステムの開発において、高い効果を発揮しています。今後の組織運営においては、この知見を活かし「予測不可能性を前提とした開発プロセス」の確立が重要な課題となるでしょう。技術的な卓越性と人間的な洞察の両立が、現代のソフトウェアアーキテクチャ実践には不可欠です。Chapter 14. Variability and the Interconnectedness of Decisions第14章「Variability and the Interconnectedness of Decisions」は、アーキテクチャ意思決定の相互関連性とその可変性について深く掘り下げています。著者は意思決定の関係性を4つの視点から分析し、それらを理解し効果的に扱うためのツールとしてスパイクの活用を提案しています。「変化を嫌う人」を動かす:魅力的な提案が受け入れられない4つの理由作者:ロレン・ノードグレン,デイヴィッド・ションタル,船木 謙一(監修)草思社Amazonスパイクによる可変性への対処意思決定の可変性に対処する強力なツールとして著者はスパイクの活用を提案します。スパイクは不確実性の高い決定を検証する際に非常に効果的です。例えば以前のプロジェクトでマイクロサービスアーキテクチャへの移行を検討した際、スパイクを使って主要なアーキテクチャ上の決定を早期に検証できました。Figure 14-1. Spikes fit into an overall decision process at the start, somewhere around “decision required” and “option making” より引用Figure 14-1に示されるように、スパイクは意思決定プロセスの初期段階で活用されます。本番環境へのデプロイまで待たずにフィードバックを得られることは大きな利点です。実際にスパイクを通じて想定外の課題を早期に発見し、アプローチを修正できた経験が何度もあります。意思決定の4つの視点著者は意思決定の関係性を理解するための4つの視点を提示します。第一に意思決定の連続性です。決定は単独で存在するのではなく時系列上で連なっています。第二に逆ピラミッド構造です。より低層の決定が上層の決定のコンテキストを形成します。第三に原子性です。これ以上分割できない最小単位の決定が存在します。第四に双方向の対話です。新しい決定が過去の決定に影響を与えることもあります。この4つの視点は実務でも非常に有用です。あるプロジェクトでは意思決定の逆ピラミッド構造を意識することで、より効果的な決定順序を設計できました。低層の決定が上層に与える影響を考慮することは重要です。レイヤー構造の重要性著者は意思決定を3つの主要なレイヤーで捉えることを提案します。レイヤー1は独立した製品やプログラムに関する決定です。レイヤー2は境界と制約の保護です。レイヤー3は自律的で接続されたコミュニティに関する決定です。でもこのレイヤー構造の理解は非常に重要でした。クラウドネイティブアプリケーションの開発では、レイヤー2での適切な境界設定が後の開発の成否を大きく左右しました。各レイヤーの特性を理解し意識的に決定を行うことで、より堅牢なアーキテクチャを実現できます。社会技術的な複雑性意思決定の相互関連性は技術的な側面だけでなく社会的な側面も持ちます。著者は信頼関係とコントロールの感覚の重要性を強調します。技術的に正しい決定であっても、組織の信頼関係が損なわれると実装が困難になることがあります。この文脈で参考になるのが『何回説明しても伝わらない』という本です。この本は認知科学の観点から、コミュニケーションの本質的な課題と解決策を提示しています。特に「話せばわかる」という前提自体を問い直し、相手の立場に立った理解と伝達の重要性を説いています。これは分散型アーキテクチャにおける意思決定プロセスを考える上でも重要な示唆を与えてくれます。「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策作者:今井むつみ日経BPAmazonスパイクはこの社会技術的な複雑性にも対処できます。コードを書いて検証するという具体的なアプローチは、抽象的な議論よりも建設的な対話を促進します。私のチームでもスパイクを通じた検証により、チーム間の信頼関係を強化できた経験があります。結論可変性と相互関連性を持つアーキテクチャ意思決定において、スパイクは強力なツールとなります。意思決定の4つの視点を理解し、適切なレイヤー構造で捉えることで、より効果的な意思決定が可能になります。また社会技術的な側面にも配慮することで、組織全体としての決定の質を向上させることができます。今後の組織運営においては、これらの知見を活かし「早期検証と段階的な進化」を重視したアプローチが重要になるでしょう。技術的な卓越性と人間的な洞察の両立が、現代のソフトウェアアーキテクチャ実践には不可欠です。Chapter 15. The Transition of Power and Accountability第15章「The Transition of Power and Accountability」は、アーキテクチャ意思決定プロセスの導入に伴う権限と責任の移行について深く掘り下げています。著者は組織的・個人的な課題に焦点を当て、分散型アーキテクチャ実践への移行を成功させるための具体的な指針を提供します。権限移行の本質的な課題組織における権限移行は単純なプロセスではありません。伝統的な階層構造から分散型の意思決定モデルへの移行には大きな困難が伴いました。重要なのは心理的安全性の確保です。Figure 15-1. A circles and roles view of the advice process that shows the accountabilities inherent in the advice process, how they map to various roles, and how those roles interrelate より引用Figure 15-1は意思決定プロセスにおける役割と責任の関係を示しています。このモデルは単なる組織図ではなく、各役割が持つ責任と相互の関係性を明確に示します。実際のプロジェクトでもこのような可視化が有効でした。権限を得る側の課題権限を得る側の主な課題は「本当に権限を持っているのか」という不安です。私のチームでも当初はアーキテクトに過度に依存する傾向がありました。これを克服するには明確なコミュニケーションと段階的な移行が重要です。NetflixのSunshiningの例は印象的です。失敗を隠すのではなく公開し学習する文化は、権限移行の成功に不可欠です。私のプロジェクトでもこのアプローチを採用し、チームの自律性と学習能力が大きく向上しました。権限を手放す側の課題権限を手放す側も大きな不安を抱えます。「悪い決定がされるのではないか」という懸念は自然なものです。私自身もアーキテクトとしてこの不安を経験しました。しかし重要なのは「完璧な決定」ではなく「学習と改善のプロセス」です。注意が必要なのはサボタージュの問題です。著者は意図的な妨害行為の具体例を挙げています。このような行為は往々にして無意識に行われることが多く、早期発見と対処が重要でした。メタ認知の重要性著者はメタ認知（自己の思考プロセスの理解）の重要性を強調します。これは私も強く共感する点です。「反応」と「応答」の区別は実践的に非常に重要です。あるプロジェクトでは、チーム全体でこの概念を共有することで、より建設的な対話が可能になりました。メタ思考～「頭のいい人」の思考法を身につける作者:澤円大和書房Amazon結論権限と責任の移行は組織にとって大きな挑戦です。しかし適切に実施することで、より強靭で適応力のある組織を作ることができます。心理的安全性の確保と明確なコミュニケーションが重要でした。今後の組織運営においては、心理的安全性の確保と透明性の高いプロセスの確立が重要な課題となります。技術的な卓越性と人間的な洞察の両立が、現代のソフトウェアアーキテクチャ実践には不可欠です。Chapter 16. On Leadership第16章「On Leadership」は、分散型アーキテクチャにおけるリーダーシップの本質と実践について深く掘り下げています。著者はリーダーシップに関する一般的な誤解を解き、分散型アーキテクチャの文脈における効果的なリーダーシップのあり方を具体的に示しています。誰もが人を動かせる!　あなたの人生を変えるリーダーシップ革命作者:森岡毅日経BPAmazonリーダーシップの誤解を解く著者はまずリーダーシップに関する4つの主要な誤解を指摘します。第一に「リーダーシップは生まれつきの才能である」という誤解です。著者はPeter Druckerの言葉を引用し「リーダーシップはパフォーマンスであり地道な仕事である」と主張します。第二に「リーダーシップは階層と結びついている」という誤解です。実際の組織では「ピーターの法則」として知られるように階層的な昇進は必ずしもリーダーシップ能力と一致しません。むしろ階層的な昇進システムそのものがリーダーシップの育成を阻害する可能性があります。第三に「リーダーシップは一方向的である」という誤解です。従来の考え方では指示は上から下へ一方向に流れると想定されてきました。しかし現代の組織では双方向のコミュニケーションとフィードバックが不可欠です。第四に「リーダーシップはマネジメントと同じである」という誤解です。マネジメントが現状の最適化を目指すのに対しリーダーシップは変革と未来に焦点を当てる点で本質的に異なります。Leader-Leaderアプローチ著者はリーダーシップのモデルとしてL. David Marquetの「Leader-Leader」アプローチを推奨します。このアプローチは全員がリーダーになり得るという信念に基づいています。重要なのは認知的な仕事においては従来の上意下達型のリーダーシップが機能しないという洞察です。Leader-Leaderアプローチでは「私はこうするつもりです」という宣言を通じてリーダーシップを実践します。この宣言に対して反対がなければ実行に移せます。これにより意思決定の分散化と迅速化を両立できます。移行期のリーダーシップ課題分散型アーキテクチャへの移行期には4つの主要な課題があります。第一に「コントロールを手放す」ことです。これは単なる形式的な権限移譲ではなく心理的な変革を必要とします。第二に「安全性を個別の決定より優先する」ことです。多様な視点を取り入れるには心理的安全性の確保が不可欠です。技術的な正しさよりも組織の信頼関係構築を優先する必要があります。第三に「I intend to」プラクティスの導入です。これは権限移譲を具体化する効果的な方法です。チームメンバーが主体的に行動を起こせる環境を作ります。第四に「信頼してから検証する」アプローチです。失敗を許容し学習機会として捉える文化づくりが重要です。検証は必要ですがマイクロマネジメントは避けるべきです。モラルリーダーシップの重要性著者はモラルリーダーシップの継続的な必要性を強調します。技術的パフォーマンスへの影響は過大評価されがちですが組織の道徳的側面への影響は過小評価されています。モラルリーダーシップは多様性を保護し心理的安全性を促進します。これは分散型アーキテクチャの実践において重要です。パワーバランスの偏りを防ぎ幅広い声が貢献できる環境を維持します。実践的な示唆著者の提案は現代のソフトウェア開発組織に重要な示唆を与えます。注目すべきはリーダーシップを特定の役職や個人に固定化しないという考え方です。組織の成長とともにリーダーシップも進化させる必要があります。継続的な学習とフィードバックを重視する文化づくりも重要です。失敗を恐れず実験と改善を繰り返すサイクルを確立することで組織全体の能力が向上します。結論本章は分散型アーキテクチャにおけるリーダーシップの新しいモデルを提示しています。Leader-Leaderアプローチとモラルリーダーシップの組み合わせは現代のソフトウェア開発組織に適した枠組みを提供します。重要なのはリーダーシップを学習可能なスキルとして捉える視点です。これは組織の持続的な成長と進化を支える基盤となります。今後の組織運営においてはこれらの知見を活かし分散型でありながら一貫性のある技術戦略を実現することが求められます。Chapter 17. Fitting the Advice Process Within Your Organization第17章「Fitting the Advice Process Within Your Organization」は、アーキテクチャ・アドバイスプロセスを既存の組織構造に統合する方法について深く掘り下げています。著者は組織の境界とその接点に注目し、分散型アーキテクチャ実践を組織全体に効果的に適用するための具体的な指針を提供しています。ソフトウェアエンジニアリングのサブカルチャー著者はまずソフトウェアエンジニアリング部門の独自性に着目します。伝統的な組織文化とは異なる特性を持つソフトウェア開発において、アドバイスプロセスは自然な形で受け入れられる可能性が高いと指摘します。注目すべきはソフトウェア開発の4つの特徴です。標準的な製品開発モデルとの違い、変化の速度、組織との接点の少なさ、そして既に受け入れられている文化的な違いです。これらは以前関わった大規模プロジェクトでも、ソフトウェア開発チームは他部門とは異なる働き方を自然に確立していました。アドバイスプロセスバブルの概念著者はアドバイスプロセスバブルという概念を提示します。このバブルは分散型実践のための明確な境界を持つ空間として機能します。Figure 17-1はバブルの基本的な構造を示しており、組織の他の部分との関係性を明確にします。Figure 17-1. An advice process bubble where teams practice the advice process, surrounded by the rest of the organization where everything continues as usual より引用バブルは完全に独立しているわけではありません。むしろ組織との適切な接点を維持しながら、内部の自律性を確保する仕組みとして機能します。私のチームでもこのアプローチを採用し、組織全体との調和を保ちながら独自の開発文化を育てることができました。バブルの成長と分割バブルの成長には慎重なアプローチが必要です。著者は段階的な成長と適切なタイミングでの分割を推奨します。Figure 17-2は分割後のバブル構造を示しており、組織とのインターフェースをどう維持するかが明確に示されています。Figure 17-2. An additional circle with responsibilities for linking into the wider organization’s performance management process has been added to the advice process bubble より引用重要なのはバブル分割の判断基準です。信頼関係の低下、意思決定の遅延、不必要な情報共有の増加などが分割のシグナルとなります。あるプロジェクトでは規模の拡大に伴いコミュニケーションコストが増大し、結果として2つのバブルに分割することで効率が改善しました。組織との期待値の管理著者は組織からの期待に対する適切な対応の重要性を強調します。明示的な期待と暗黙的な期待の区別が重要です。要件の達成や透明性の確保といった明示的な期待に加えて、階層的な質問への対応や適切なスキルの確保といった暗黙的な期待にも注意を払う必要があります。この観点は実務上極めて重要です。私のチームでも組織の期待を明確に理解し対応することで、分散型実践の価値を示すことができました。定期的なステータス報告や成果の可視化は、組織との信頼関係構築に大きく貢献しました。結論アドバイスプロセスの組織への適合は継続的な取り組みを必要とします。著者はバブルの独自性を保護しながら組織との調和を図ることの重要性を強調します。これは単なる技術的な課題ではなく、組織文化の変革を伴う取り組みです。このアプローチは現代のソフトウェア開発組織に極めて有効です。マイクロサービスアーキテクチャやDevOpsの実践において、チームの自律性と組織全体の整合性のバランスを取る際に役立ちました。今後の課題としては、リモートワークの普及やグローバル開発の加速に伴う新たな組織的課題への対応が考えられます。しかし著者が示した原則と実践的なアプローチは、これらの課題に対しても有効な指針となるはずです。おわりに実は本書を最初に読んだのは11月でした。読了後すぐに、この本の内容が字分の人生の年末の振り返りや自身の職務経歴書の更新と似ているなぁって思って、書評自体は年末年始に書こうと決めました。その間、折に触れて内容を整理し、メモを取り続けていましたが、実際の執筆は結局大晦日までずれ込んでしまいました。しかし、この「遅さ」が逆に、一年を通じての経験と本書の内容を結びつける機会を与えてくれたように思います。本書「Facilitating Software Architecture」を通じて、私たちは分散型アーキテクチャにおける実践的アプローチを学んできました。印象的だったのは、アーキテクチャの実践が単なる技術的な設計にとどまらず、組織文化や人間関係の深い理解を必要とすることです。本書の核心は、アーキテクチャを「共創的な営み」として捉える視点にあります。伝統的な中央集権型アプローチから分散型への移行は、単なるプロセスの変更以上の意味を持ちます。それは組織全体の思考様式の転換であり、新しい形の協働を生み出す試みです。アーキテクチャ・アドバイスプロセスとADR（Architecture Decision Records）は、この新しいアプローチを支える具体的な実践として重要です。これらは意思決定の透明性を高め、組織の学習を促進する強力なツールとなります。同時に、Technology RadarやWalking Skeletonといった手法は、不確実性の高い環境での実践的な指針を提供してくれます。しかし、最も重要なのは「信頼」を基盤とした組織文化の醸成です。分散型アーキテクチャの成功は、技術的な卓越性だけでなく、組織メンバー間の深い信頼関係に依存します。本書を通じて学んだ様々なプラクティスも、この信頼関係があってこそ効果を発揮するものです。この一年間、私自身が経験した技術への意欲の喪失と回復の過程は、本書の内容と深く共鳴するものでした。個人としてもチームとしても、時には立ち止まり、基本に立ち返ることの重要性を再認識させてくれます。心身の健康に意識を向け、純粋な楽しみの時間を大切にすることは、持続可能な開発文化の基盤となるでしょう。これからのソフトウェア開発は、さらなる複雑性と不確実性に直面することでしょう。しかし、本書で示された分散型アプローチと、それを支える様々な実践は、これらの課題に立ち向かうための強力な武器となるはずです。個人としても組織としても、継続的な学習と適応を重ねながら、より良いソフトウェア開発の実現を目指していきたいと思います。2024年もみなさん、最後まで読んでくれて本当にありがとうございます。途中で挫折せずに付き合ってくれたことに感謝しています。読者になってくれたら更に感謝です。XやGithubまでフォロワーしてくれたら泣いているかもしれません。","isoDate":"2024-12-31T14:25:46.000Z","dateMiliSeconds":1735655146000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Clippyのすすめ - 他者の評価を気にせず何度でも指摘してくれる機械もしくは注意力の限界を超えてケアをしてくれる機械","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/27/170046","contentSnippet":"はじめにプログラミングを学ぶ上で、良いコードの書き方を知ることは非常に重要です。今回は、Rustで良いコードを書くための強力な味方、Clippyについて学んでいきましょう。プログラミング初心者の方から、他の言語からRustに移ってきた方まで、きっと新しい発見があるはずです。私も最近、Rustに関する素晴らしい本を読んでいます。「Effective Rust」と「Idiomatic Rust」は、Rustらしい書き方やデザインパターンについて詳しく解説していて、とても勉強になります。ただ、正直なところ、本を読んだだけでは私自身なかなか良いコードが書けず、ツールでのレビューで「これRustらしくないよね」とよく指摘されています。そのたびに勉強させられています。きっと同じような経験をされている方も多いのではないでしょうか。Idiomatic Rust: Code like a Rustacean (English Edition)作者:Matthews, BrendenManningAmazonEffective Rust: 35 Specific Ways to Improve Your Rust Code (English Edition)作者:Drysdale, DavidO'Reilly MediaAmazonそんな中で私の強い味方になっているのが、今回紹介するClippyです。本で学んだ内容を実践しようとするとき、Clippyは具体的なアドバイスをくれる、とても親切な存在です。特に「ここがRustらしくない」と言われたときの改善方法を、実例を挙げて教えてくれるのが心強いです。rust-lang.github.ioRust 標準 linter: Clippyプログラミング言語には、よくある間違いや非推奨の書き方をチェックして警告を発してくれる、lintというプログラムがあります。元々はC言語をチェックするものでしたが、現在では様々な言語のためのlinterが作られています。Lint Nightなんてイベントもあります。lintnight.connpass.comRustには言語標準のlinterがあり、その名をclippyと言います。使い方は極めて簡単で、cargoツールチェインがインストールされていれば、下記のようにインストールして、$ rustup component add clippy下記のコマンドをcrateのフォルダで実行するだけです。$ cargo clippyClippyのlinterとしての特徴linterはコードの品質を向上するために、多くの現場で使われているツールですが、実際には厳しすぎるルールや、実際の問題にそぐわないものも多くあります。これを偽陽性(false positive)の検出と呼びます。通常は設定ファイルや特殊なコメントをコードに埋め込むことによって、特定のlintの有効・無効を切り替えることになります。これは無視できない労力で、linterのバージョンを更新するたびに新たなルールに対応する必要が出てきたり、コメントによってコードが汚くなったりするデメリットもあります。Clippyの特徴は、デフォルトの設定でもそのような偽陽性の警告が少なく、実際にコードの品質が向上したり、プログラマとしての知識が得られるのを実感できるような警告が多いということです。実践的な例例えば、次のような関数を見てください:fn sum_squares(values: &Vec<i32>) -> i32 {    values.iter().fold(0, |acc, value| acc + value * value)}この関数は問題なく動きますが、Idiomatic Rust（慣用的なRustコード）ではありません。Clippyは、次のような親切な警告を出してくれます：Checking test001 v0.1.0 (/Users/nwiizo/git/workspace_2024/clippy/test001)warning: writing `&Vec` instead of `&[_]` involves a new object where a slice will do --> src/main.rs:1:24  |1 | fn sum_squares(values: &Vec<i32>) -> i32 {  |                        ^^^^^^^^^ help: change this to: `&[i32]`  |  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#ptr_arg  = note: `#[warn(clippy::ptr_arg)]` on by defaultこれは、&Vecよりも&[]のほうが汎用性が高いということを教えてくれています。Vec<T>は&[T]に暗黙に変換されるので、わざわざVec<T>で宣言するということは、使える範囲を狭めるだけで何のメリットもないのです。この関数は、機能性を全く損なわずに、次のように書き直すことができます：fn sum_squares(values: &[i32]) -> i32 {    values.iter().fold(0, |acc, value| acc + value * value)}ミュータブル参照の場合ところで、引数の型がミュータブル参照であった場合は話が別です。&mut Vec<T>と&mut [T]ではできることが異なります。次のように、引数のベクター型のサイズを変えるような関数は、ミュータブルスライスで置き換えることはできません：fn append_square(values: &mut Vec<i32>) {    values.push(values.iter().fold(0, |acc, value| acc + value * value));}// 使用例let mut vv = vec![1,2,3];append_square(&mut vv);assert_eq!(vec![1,2,3,14], vv);このため、Clippyはミュータブル参照に対しては警告を発しません。これは、Clippyが文脈を理解して適切な判断を下せることを示す良い例です。neovim/nvim-lspconfig での設定VSCodeやCursor は知らないがこちらの設定でneovim は設定できる。  {    \"neovim/nvim-lspconfig\",    config = function()      require(\"nvchad.configs.lspconfig\").defaults()      local lspconfig = require \"lspconfig\"      lspconfig.rust_analyzer.setup {        settings = {          [\"rust-analyzer\"] = {            checkOnSave = {              command = \"clippy\",              extraArgs = { \"--all\", \"--\", \"-W\", \"clippy::all\" },            },          },        },      }      require \"configs.lspconfig\"    end,  },おわりにClippyは、より良いRustプログラムを書くことができるように導いてくれる、優しい先生のような存在です。もちろん、Clippyも完璧ではなく、時には偽陽性の検出もありますが、それは人間でも同じことです。より良いRustの書き方を学び、コードの品質を向上させ、プログラミングの知識を深められるClippyは、人間のレビュアーとは違って何度指摘されても評価が下がることのない、心強い味方となってくれます。という利点があります。ぜひ、みなさんも日々のRustプログラミングにClippyを取り入れてみてください。疑問に思ったClippyの警告は、その都度調べてみることをお勧めします。そうすることで、Rustの理解がより深まっていくはずです。Effective Rustに関しては日本語の本が出ているので興味があれば読んでみても良いと思う。Effective Rust ―Rustコードを改善し、エコシステムを最大限に活用するための35項目作者:David Drysdaleオーム社Amazon個人的に良かった記事qiita.comkenoss.github.io業務 におけるRust の記事を読んだがどちらの記事もとても良かった。","isoDate":"2024-12-27T08:00:46.000Z","dateMiliSeconds":1735286446000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"「評論家気取り」という作る人の行き着く先が怖い","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/27/144509","contentSnippet":"らーめん再遊記 第一巻より引用らーめん再遊記（１） (ビッグコミックス)作者:久部緑郎,河合単小学館Amazonはじめに技術界隈には、長年続いている不穏な現象があります。コードを書くことに情熱を注いでいた人々が、いつの間にか他人の成果物を論評することに執心するようになってしまうのです。なぜ私たちは燃え尽きてしまうのか作者:ジョナサン マレシック青土社Amazonこの現象は、特にベテランと呼ばれるエンジニアたちの間で顕著です。彼らは確かな技術力を持ち、素晴らしい成果を残してきました。しかし、彼らの多くが、創造者から評論家への転身!?を遂げつつあります。仕事の辞め方 (幻冬舎単行本)作者:鈴木おさむ幻冬舎Amazon実は私たちエンジニアは皆、いずれ評論家になる運命を背負っているのかもしれません。年を重ね、技術の第一線から遠ざかるにつれ、「作る」ことから「評論する」ことへと、その重心を少しずつシフトさせていきます。それは半ば必然であり、誰もが通る道なのでしょう。だからこそ、今、この問題について考えたいと思います。これは、いずれ評論家になるかもしれない私自身への警告であり、そして自戒の言葉でもあります。実装者から評論家へ。エンジニアの変質を、私は憂慮しています。この静かな変化について、正面から向き合ってみましょう。作る側が評論に逃げるとき「このコードは素人レベルで時代遅れです。基礎から学び直してください」「アーキテクチャへの理解が浅く、重要な議論が抜け落ちています」「技術選定の根拠が説明されておらず、設計思想が古いままです」「なぜあのライブラリやアーキテクチャに触れていないのですか。初歩的な見落としです」SNSには辛辣な評論・批評が溢れ、技術ブログには高圧的な論評が並び、カンファレンスの裏チャンネルは批判で充満しています。最も危惧すべきは、これらの評論・批評の多くが、かつては優れたコードを生み出していたはずのエンジニアたちから発せられているということです。問題なのは、これらの言説が建設的な議論を装いながら、実際には単なる批判に終始している点です。 改善案を示すわけでもなく、プルリクエストを送るわけでもなく、ただ「ダメ出し」だけを繰り返しています。これは技術的な議論ではなく、単なる自己顕示でしかありません。アイデアのつくり方作者:ジェームス W.ヤングCCCメディアハウスAmazon自意識が一流評論家になってしまったかつて天才だったエンジニアXのタイムラインには、自らを一流評論家だと思い込んだエンジニアたちが目立っています。「この実装は素人レベルです。こんなコードしか書けない人は、基礎から学び直すべきです」—そう断罪するのです。 しかし、彼ら自身は数年前の自分のコードを振り返ってみたことがあるでしょうか。あるいは最近では、実装よりもメンテナンス業務が中心になってはいないでしょうか。かつての優秀なエンジニアたちは、初学者への指摘だけでは飽き足らず、すでに実績のあるエンジニアたちにまで批判の矛先を向けています。有名OSSのプルリクエストには「この設計は時代遅れです。モダンな設計パターンを学んでから出直してください」と高圧的なコメントを残し、技術ブログに対しても「この技術選定の根拠が説明されていません」「重要な議論が抜け落ちています」と、まるで査読者のような態度で指摘を繰り返します。さらに気がかりなのは、オープンソースのイシューやプルリクエストへの不建設的な態度です。具体的な改善案を示すことなく、ただ問題点の指摘だけを行うのです。「なぜこの設計を選んだのですか？」「この実装では不十分です」という批判は、具体的な改善案を伴わない限り、何の価値も生み出せません。評論家気取りのポストで注目を集める快感に魅了されたエンジニアは、徐々に変質していきます。最初は些細な技術的指摘から始まり、「いいね」という承認欲求に駆られ、その評論は次第に厳しさを増していくのです。「なぜこの技術スタックを選んだのですか？」「なぜこの設計パターンを採用しなかったのですか？」—まるで面接官のように、実装者を追い詰める質問を投げかけ始めます。そして最も懸念すべきは、若手エンジニアの成長機会が損なわれていくという事実です。建設的なフィードバックの代わりに投げかけられる批判は、若手の挑戦する意欲を削ぎ、コミュニティへの貢献を躊躇させています。時には、自身を技術界の権威だと思い込んだエンジニアが、若手たちの真摯な努力までも批判の対象としてしまうのです。評論は衰退の始まりエンジニアが評論家めいた物言いを始めるとき、それは衰退の予兆かもしれません。ただし、適切な評論や建設的な批判は、技術の発展に不可欠な要素でもあります。レビューやフィードバックを通じて、実装の品質は向上し、よりよい設計が生まれていきます。問題なのは、創造的な貢献を伴わない批判に終始してしまうことです。創造者には創造者としての責務があります。コードに不満があるならば、改善のプルリクエストを送ることができます。ドキュメントが不十分と感じるなら、具体的な改善案を示すことができます。アーキテクチャが気に入らないのであれば、より優れた実装を示す機会が開かれています。発表内容に不満があるというのなら、自らが登壇する選択肢もあります。これは単なる理想論ではありません。優れたエンジニアたちは、常にこの原則に従って行動してきました。彼らは単なる批判ではなく、コードで語ります。問題点の指摘だけではなく、改善案の実装を示します。時には厳しい指摘も必要ですが、それは常により良い方向への具体的な提案を伴うものでなければなりません。評論と批判は、建設的な議論の土台となり得ます。しかし、それは実装による貢献があってこそ意味を持つのです。評論家として批判するだけでなく、創造者として具体的な改善を示していく—それこそが、エンジニアの進むべき道筋なのではないでしょうか。みんなのフィードバック大全作者:三村 真宗光文社Amazonなぜ評論に逃げるのか実のところ、その理由は複雑に絡み合っています。一見すると創造する意欲が失われていくように見えますが、その背景にはさまざまな要因が存在します。まず、技術の進化スピードが年々加速していることが挙げられます。かつて最先端だった技術スタックは、わずか数年で「レガシー」と呼ばれるようになります。新しい技術への追従に疲れ、自信を失っていく—そんなベテランエンジニアの姿を、私たちは目にしてきました。また、組織の中での役割の変化も大きな要因となります。マネジメントやアーキテクトの立場になると、直接コードを書く機会が減っていきます。それは自然なキャリアパスかもしれませんが、同時に「作る」喜びから遠ざかることも意味します。さらに、以前の自分を超えられないという焦りもあるでしょう。若かりし頃に作り上げた素晴らしいプロダクトやライブラリ。その成功体験が重荷となり、新しいチャレンジを躊躇させることもあります。過去の栄光に縛られ、新たな失敗を恐れる—そんな心理が、評論という安全な場所への逃避を促します。そして、評論には誘惑があります。技術ブログへの評論記事は数時間で書け、発表資料への批判は数分で完結し、SNSなら数行のポストで事足ります。実装を伴う苦労も、メンテナンスの責任も、失敗のリスクも必要ありません。最も注意すべきは、その行為が「いいね」という即時の報酬と、表面的な自己肯定感をもたらすことです。賢明な分析家として認められ、技術の識者として扱われる。この心地よさが、さらなる評論への逃避を促していきます。他者への批判で得られる一時的な優越感は、しかし、本当の自己肯定感とは異なります。 建設的な創造による達成感こそが、エンジニアの誇りとなるべきものです。時には、組織の文化や環境も影響します。過度な品質要求や、失敗を許容しない雰囲気は、エンジニアを萎縮させ、批評家的な立場に追いやってしまうことがあります。新しいことへの挑戦よりも、既存のものを批評する方が「安全」だと感じてしまうのです。この悪循環は、技術コミュニティ全体に影響を及ぼします。建設的な議論が減少し、若手の挑戦する意欲が失われ、コミュニティの分断が進んでいきます。評論は容易でも、実際の改善は誰も行わない—そんな状況に陥っているのです。しかし、これは決して避けられない運命ではありません。技術の変化を恐れず、小さな一歩から始める勇気を持つこと。過去の成功や失敗にとらわれすぎず、新しい挑戦を続けること。そして何より、評論家としての安易な満足に甘んじないこと。それが、創造者としての道を歩み続けるための鍵となるのではないでしょうか。批評の教室　──チョウのように読み、ハチのように書く (ちくま新書)作者:北村紗衣筑摩書房Amazon作る側の矜持エンジニアの本質的価値は、創造する能力にあります。 しかし、それは建設的な評論の価値を否定するものではありません。むしろ、創造と評論のバランスを保つことこそが、真のエンジニアとしての成熟を示すのかもしれません。不満な実装を見つけたのなら、より良いコードで示していきましょう。しかし、それは時として現実的ではないこともあります。そんなとき、具体的で建設的で受け入れやすいフィードバックは、それ自体が価値ある貢献となり得ます。資料に物足りなさを感じたのなら、自らより良い資料を書いていきましょう。ただし、すべての領域で自ら書き直すことは不可能です。そこでは、経験に基づいた示唆に富む指摘が、コミュニティの発展を支えることになります。エンジニアの成長は、実装による具体的な貢献を通じて実現されます。しかし、それは単独の作業ではありません。建設的なフィードバックの交換、経験の共有、そして時には適切な批評—これらの相互作用が、より良い実装を生み出す土台となります。重要なのは、創造と評論の適切なバランスです。他者のコードを批判するだけでなく、具体的な改善案を示すことができます。時には成果を否定したくなることもあるでしょうが、それを建設的なフィードバックへと昇華させることが大切です。また、自身の実装経験に基づいた説得力のある指摘は、コミュニティの発展に大きく寄与します。特に若手エンジニアに対しては、その成長を支援する温かい指摘を心がけたいものです。SNSでの浅薄な承認に価値を見出すのではなく、実装と建設的な評論の両輪で、技術コミュニティの発展に貢献していきましょう。それこそが、経験を積んだエンジニアとしての責務なのではないでしょうか。創造の喜びを忘れず、同時に適切な評論の価値も理解する—その両方を備えることで、私たちは真のエンジニアとしての成長を続けることができるのです。そして、それこそが技術コミュニティ全体の発展につながっていくはずです。批評理論を学ぶ人のために世界思想社Amazonおわりに「この文章自体も、評論ではないでしょうか」—そんな声が聞こえてきそうです。その通りです。私たちは、いずれ評論家になる運命から完全に逃れることはできないのかもしれません。年を重ねていったり、第一線を離れていく中で、評論的な視点は自然と身についていきます。それは、ある意味で技術者としての成熟の一面なのかもしれません。しかし、それでも私たちには選択の余地があります。評論に溺れるのか、それとも最後まで創造を続けるのか。私は後者を選びたいと思います。だからこそ、この文章を書き終えたら、すぐにコードを書きます。 プルリクエストを送り、ドキュメントを改善します。たとえ疲れてしまって楽な評論的な視点を持ったとしても、それを建設的な創造へと昇華させる努力を続けていきます。エンジニアは、創造することで価値を示せます。評論だけでは、成長は望めません。私たちは、作ることで命をつなぎます。 評論家という名の死に屈することなく。ついでにGitHubでもフォローしてくれ⋯github.com","isoDate":"2024-12-27T05:45:09.000Z","dateMiliSeconds":1735278309000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"2024年 俺が愛した本たち 非技術書編(物語を除く)","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/25/084801","contentSnippet":"この記事は、3-shake Advent Calendar 2024 6日目のエントリ記事です。はじめにこんにちは、nwiizoです。2024年も終わりに近づいています。毎年恒例となった年末の読書振り返りの時期が来ました。今年はいつも以上に多くの本を読みましたが、その中でも技術書以外の本との出会いが、私の世界を大きく広げてくれました。哲学書、ビジネス書、社会科学書など、多岐にわたるジャンルの本に触れることで、新しい視点や考え方を学ぶことができました。なお、今回は物語やノンフィクションについては別の機会に譲り、主にビジネスや思考に関する本を中心にご紹介させていただきます。一見エンジニアリングとは関係のない本の中に、日々の仕事や課題解決に活かせるヒントが数多く隠れていることに気づかされた一年でもありました。本を読むことは知識を得るだけでなく、物事を多角的に捉える力を育んでくれます。様々な分野の本に触れることで、自分の思考の幅が広がり、新しいアイデアや解決策が浮かぶようになってきたように感じています。...とここまで偉そうに書きましたが、実際のところ私は「へぇ～、そうなんだ」とか「なるほど、そういう考え方もあるのか」くらいの気持ちで本を読んでいます。この記事では、2024年に私の心に深く刻まれた非技術書をご紹介したいと思います。これらの本との出会いが、読者の皆さんの新たな読書体験のきっかけになれば幸いです。はじめに昨年以前に紹介した本BIG THINGS　どデカいことを成し遂げたヤツらはなにをしたのか？High Conflict よい対立 悪い対立 世界を二極化させないために「怠惰」なんて存在しない 終わりなき生産性競争から抜け出すための幸福論THINK BIGGER 「最高の発想」を生む方法「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策イシューからはじめよ［改訂版］――知的生産の「シンプルな本質」会って、話すこと。――自分のことはしゃべらない。相手のことも聞き出さない。人生が変わるシンプルな会話術勘違いが人を動かす――教養としての行動経済学入門おわりに昨年以前に紹介した本syu-m-5151.hatenablog.comsyu-m-5151.hatenablog.comsyu-m-5151.hatenablog.comsyu-m-5151.hatenablog.comBIG THINGS　どデカいことを成し遂げたヤツらはなにをしたのか？世間を賑わせたメガプロジェクトの成功と失敗について掘り下げた本です。何が面白いって、メガプロジェクトというのはほぼ確実に上手くいかないのです。予算はオーバーし、納期は遅れ、最後には利益も出ない。しかも規模が大きいだけに、失敗のインパクトも半端ない。でも、そんな中でもたまに劇的に成功するプロジェクトがある。本書は、その差は一体どこにあるのかを探っています。著者が紹介する成功への要因は意外とシンプルです。「ゆっくり考え、すばやく動く」という原則や、「レゴを使ってつくる」という具体的な可視化の手法、「マスタービルダーを雇う（専門家を頼る）」といった実践的なアプローチが示されています。実は、この本の面白さは二重構造になっています。壮大なプロジェクトの成功と失敗の物語として読むと純粋に面白いのですが、自分が経験したことがあるプロジェクトに重ねて読むと...（ちょっと考え込む）まあ、そこは各自の想像にお任せします。特に印象的だったのは、大規模プロジェクトの教訓が、実は小規模なプロジェクトにも当てはまるという指摘です。例えば「小さく試し、成功したら拡大する」というアプローチは、ビジネスからアート、果ては生物の進化まで、不確実性と向き合うあらゆる分野で見られる原則なんですよね。何か新しいことに挑戦しようと考えている人には、特におすすめの一冊です。ただし、現在進行形でプロジェクトの真っ只中にいる人は、読むタイミングを少し考えた方がいいかもしれません。なんてったって、成功率0.5%という現実を突きつけられますからね。BIG THINGS　どデカいことを成し遂げたヤツらはなにをしたのか？作者:ベント・フリウビヤ,ダン・ガードナーサンマーク出版AmazonHigh Conflict よい対立 悪い対立 世界を二極化させないために対立には2つの種類があるということを、この本は教えてくれます。健全な対立は、私たちの成長を促し、相互理解と向上につながります。一方で、不健全な対立（ハイコンフリクト）は、「私たち対彼ら」という二項対立に陥り、問題の本質とは関係のない揚げ足取りや感情的な対立を引き起こします。読んでいて特に対立は感情の問題ではなく、構図の問題だという指摘が印象に残りました。私たちは「相手の感情を変えなければ」と思いがちですが、実は解決すべきは対立という構造そのものなんですね。本書が提案する解決策も興味深いものでした。従来の「逃げる」「戦う」「我慢する」という3つの方法ではなく、第四の道を示してくれます。それは、最終的な意見の一致を目指すのではなく、お互いの話に真摯に耳を傾けること。意見は違っていても、自分の話をちゃんと聞いてもらえたと全員が感じられれば、それが健全な対話への第一歩になるというわけです。読んでいて「よい対立」というのは、実は「よい対話」のことなのかもしれないと思いました。相手と自分の違いを楽しみながら、お互いの考えを知ろうとする姿勢。それが結果的に、建設的な関係性を築くヒントになるのではないでしょうか。ダイアローグ 価値を生み出す組織に変わる対話の技術作者:熊平美香ディスカヴァー・トゥエンティワンAmazonただし、これは理想論に聞こえるかもしれません。実際の現場では、感情的になったり、相手の話を遮ってしまったりすることは日常茶飯事です。でも、だからこそ、この本が教えてくれる対立の構造を理解し、より良い対話を目指すヒントは、とても価値があると感じました。High Conflict よい対立 悪い対立 世界を二極化させないために作者:アマンダ・リプリーディスカヴァー・トゥエンティワンAmazon「怠惰」なんて存在しない 終わりなき生産性競争から抜け出すための幸福論「休むこと」に罪悪感を覚える社会の呪縛について、深い洞察を投げかける一冊です。著者は、「怠惰は悪である」という私たちの思い込みが、実は資本主義社会が生み出した幻想だと指摘します。人の価値は生産性では測れないという当たり前だけど忘れがちな事実です。「もっとできるはずだ」「自分の限界を信じるな」といった私たちが \"真実\" だと思い込んでいる考えが、実は \"ウソ\" かもしれないと思わされます。働くということ　「能力主義」を超えて (集英社新書)作者:勅使川原真衣集英社Amazon特に印象的だったのは、休息は \"サボり\" ではなく、むしろ脳を活性化させる大切な時間だという指摘です。何もしていないように見える時間こそ、実は新しいアイデアが生まれる瞬間だったりします。実はこれは、近年増加している燃え尽き症候群の問題とも深く関係しています。休むことを後ろめたく感じ、常に生産的でなければならないというプレッシャーは、私たちのメンタルヘルスに大きな影響を与えているのです。心療内科医が教える本当の休み方作者:鈴木 裕介アスコムAmazonこれは昨年話題になった『なぜ私たちは燃え尽きてしまうのか』という本でも指摘されていました。バーンアウトは単なる個人の弱さの問題ではなく、仕事が私たちのアイデンティティそのものになってしまっているという、現代社会の構造的な問題なのだと。なぜ私たちは燃え尽きてしまうのか作者:ジョナサン マレシック青土社Amazon実は私も、「もっと頑張れるはずだ」と自分を追い込むタイプでした。でも、そんな生き方って本当に正しいのかな？と考えるきっかけをくれた本です。生産性や成果だけが人生の価値を決めるわけじゃない。この当たり前の事実に、改めて気づかされました。この本は、急がなくていい、そんなに頑張らなくていいと、優しく語りかけてくれます。そして、それは決して「怠けていい」という意味ではなく、むしろ自分らしく、人間らしく生きるための大切な気づきなのだと教えてくれるのです。「怠惰」なんて存在しない 終わりなき生産性競争から抜け出すための幸福論作者:デヴォン・プライスディスカヴァー・トゥエンティワンAmazonTHINK BIGGER 「最高の発想」を生む方法この本は、私たちの「創造性」に対する多くの思い込みを覆してくれる一冊です。「天才のひらめき」という美しい物語は、実は幻想かもしれないという衝撃的な指摘から始まります。著者によれば、イノベーションの本質は「新しいアイデアを無から生み出すこと」ではなく、「既存のアイデアを新しく組み合わせること」なのだそうです。例えば、ピカソが天才的なアーティストとされるのは、同時代の画家マティスとアフリカのビリ人による彫像を巧みに組み合わせて、キュビスムという新しい芸術様式を生み出したからなんですね。この点について、私は広告界の巨人ジェームス・W・ヤングの『アイデアのつくり方』（1940年）から学びました。ヤングは「新しいアイデアとは、既存の要素の新しい組み合わせ以外の何物でもない」と述べています。そして私は、その組み合わせを見つけるには、事物の関連性を見つけ、組み合わせを試行錯誤することが重要だと考えています。アイデアのつくり方作者:ジェームス W.ヤングCCCメディアハウスAmazon特に印象的だったのは、私たちが「創造性を高める」と信じている方法の多くが、実は科学的な根拠に欠けているという指摘です。ブレインストーミングの効果は研究で否定されているとか、オフィス空間を奇抜にしても創造性は上がらないとか。むしろ大切なのは、様々な素材を一つ一つ心の解像度を上げて捉え、向き合うこと。そして、それらの関係性を探り出すことなのです。著者は、アイデアの創造プロセスについて興味深い観察を示してくれます。何気ない見聞き、例えば電車に乗っているとき、風呂に入っているとき、トイレのときなど、ふとした瞬間にアイデアが心の中で飛び込んでくる。でも、これは実は偶然ではなく、それまでの地道な素材集めと向き合いの結果なんだそうです。THINK BIGGER 「最高の発想」を生む方法：コロンビア大学ビジネススクール特別講義 (NewsPicksパブリッシング)作者:シーナ・アイエンガーニューズピックスAmazonこの本は、世の中に溢れている「創造性神話」を丁寧に解きほぐしながら、誰もが実践できる方法論を示してくれます。アイデアを生むには、まず問題を無意識の中で整理し、忘れたような状態にすることも大切なんですね。そして何より、「天才のひらめき」を待つのではなく、地道に知識を蓄え、既存のアイデアを組み合わせていく。そんな着実なアプローチこそが、実は最も創造的な方法なのかもしれません。「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策コミュニケーションの失敗の原因を、認知科学の視点から解き明かしてくれる一冊です。著者は、「話せばわかる」という私たちの思い込みが、実は幻想かもしれないと指摘します。人は自分の都合のいいように誤解する生き物だという指摘です。これは、相手が「悪意を持って誤解している」わけではなく、むしろ 私たち一人一人が持つ「知識や思考の枠組み（スキーマ）」が異なるために起こる自然な現象なんだそうです。例えば、同じ「ネコ」という言葉を聞いても、人によって思い浮かべる映像は全く違います。これと同じように、ビジネスの現場でも、私たちは知らず知らずのうちに、自分のスキーマを通して相手の言葉を解釈しているのです。著者は、コミュニケーションの達人になるためのヒントも示してくれます。ポイントは、「失敗を成長の糧にする」「説明の手間を惜しまない」「相手をコントロールしようとしない」「聞く耳を持つ」といった心構えです。これは決して「相手に合わせろ」という話ではなく、むしろお互いの違いを認識した上で、どう理解し合えるかを考えることの大切さを教えてくれます。この本は、日々のコミュニケーションで「なんでわかってくれないんだろう」と悩む私に、とても実践的なヒントを与えてくれました。結局のところ、完璧な伝達は不可能で、むしろ誤解や聞き違いを前提に、どうコミュニケーションを取るかを考えることが大切なのかもしれません。「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策作者:今井むつみ日経BPAmazonイシューからはじめよ［改訂版］――知的生産の「シンプルな本質」この本は私にとって特別な一冊です。「今この局面でケリをつけるべき問題」を見極めることの大切さを教えてくれた、まさにバイブルと呼べる存在でした。今回の読書振り返りを書くにあたっても、「何を伝えるべきか」を考える際の指針となってくれています。本書の核心は、「真に価値のある仕事は、イシューの設定から始まる」というものです。世の中には問題が山積みですが、その中で「今、本当に答えを出すべき」かつ「答えを出す手段がある」問題は、実はごくわずかです。優れた知的生産には分野を超えて共通の手法があると本書は教えてくれます。ビジネスでも、研究でも、アートでも、本質的な問題を見極めることから始めるという原則は変わりません。これは『熟達論―人はいつまでも学び、成長できる』でも同様の指摘がされています。分野は違えど、真に優れた実践者たちには共通のパターンがあるのです。それは問題の本質を見抜き、そこに向けて地道な努力を重ねる姿勢です。両書を読み進めるうちに、自分の中で「イシュー」を見極めることと「熟達」することの間に深いつながりがあることを感じました。熟達論―人はいつまでも学び、成長できる―作者:為末大新潮社Amazonこの気づきは私の学びの姿勢を大きく変えました。以前は目の前の課題に対して「とにかくやってみる」というアプローチでしたが、今は必ず立ち止まって「本当のイシューは何か」を考えるようになりました。そして、そのイシューに向き合う中で、自分自身の熟達度も少しずつ上がっていくような気がしています。また、本書では「課題解決の2つの型」について深く掘り下げています。ギャップフィル型（あるべき姿が明確な場合）と、ビジョン設定型（そもそもあるべき姿を見極める必要がある場合）という分類は、単なる理論的な整理ではありません。これは実践の場で直面する様々な課題に対して、どのようなアプローチを取るべきかを示す羅針盤となってくれます。多くの失敗は、この2つの型を取り違えることから始まるのかもしれません。今年の読書でも、この本で学んだ「イシューからはじめる」という考え方が、本の選び方や読み方に大きな影響を与えています。一見バラバラに見える本たちも、実は私なりの「イシュー」に基づいて選んでいたことに、この振り返りを書きながら気づきました。それぞれの本が、異なる角度から私の中の「イシュー」に光を当ててくれていたのです。イシューからはじめよ［改訂版］――知的生産の「シンプルな本質」作者:安宅和人英治出版Amazon会って、話すこと。――自分のことはしゃべらない。相手のことも聞き出さない。人生が変わるシンプルな会話術この本との出会いは、私の会話に対する考え方を大きく変えてくれました。「人は他人の話に興味がない」という荒々しいけれど正直な前提から始まり、そこから真摯に「ではなぜ人は会って話すのか」を探っていく展開に引き込まれました。本書で最も印象的だったのは、「外にあるものを一緒に見つめる」という会話の本質についての洞察です。自分のことを話したり、相手のことを聞き出したりする必要はない。むしろ、お互いの外にあるものに目を向け、新しい風景を一緒に発見することが、会話の醍醐味なのだと。実は最近、NON STYLE 石田さんの「答え合わせ」や令和ロマン・髙比良くるまさんの「漫才過剰考察」にハマっていて、面白い掛け合いの「仕組み」についてかなり考えていました。答え合わせ（マガジンハウス新書）作者:石田明マガジンハウスAmazonでも本書を読んで、会話の本質は必ずしもそういった技術的な部分だけではないことに気づかされました。巧みなツッコミやテンポのいい掛け合いも素晴らしいけれど、二人で同じ風景を見つめて「へぇ」と言い合えるような静かな会話にも、また違った味わいがあるんですね。漫才過剰考察作者:令和ロマン・髙比良くるま辰巳出版Amazonこれまで私は「相手に興味を持ってもらえるような話をしなきゃ」「相手の話をもっと引き出さなきゃ」と、どこか力んでいた気がします。でも、本書はそんな会話の構えをすべて取り払ってくれました。漫才のようにオチを付ける必要もない。ツッコミも不要。むしろ、ボケにボケを重ねて「今なんの話してたっけ？」となる方が、会話として自然なのかもしれません。会話は決して「相手を理解する」「自分を理解してもらう」ためのものではない。そう割り切ることで、むしろ自然な会話が生まれる。この逆説的な知恵が、私の日々の会話をより楽しいものにしてくれています。会って、話すこと。――自分のことはしゃべらない。相手のことも聞き出さない。人生が変わるシンプルな会話術作者:田中 泰延ダイヤモンド社Amazon勘違いが人を動かす――教養としての行動経済学入門人はとても愚か。「人は論理や情熱ではなく、認知バイアスによって動く」という衝撃的な視点を示してくれる一冊です。その象徴的な例が、男性用トイレの小便器にハエのマークを描くと飛び散りが激減する「ハウスフライ効果」。私たちは意外なほど、こういった「勘違い」によって行動が変わってしまう生き物なんですね。本書は、普段の生活で遭遇する様々な認知バイアスについて、豊富な事例とともに解説してくれます。例えば、カジノが現金ではなくチップを使う理由。実は、チップを使うと現金を使う時より負けた時の痛みを感じにくくなるそうです。さらにカーペットを長めにして歩くスペードを遅くさせたり、出口への最短ルートをわかりにくくしたり...。私たちの行動を操る仕掛けが、至る所に張り巡らされているんです。特に印象的だったのは、「予期的後悔」についての指摘です。私たちは「将来後悔するかもしれない」という不安から、決断を先送りにしがちです。でも実は、人は将来の感情を過大評価する傾向があり、実際の後悔は想像よりもずっと小さいものだとか。この点については、『変化を嫌う人を動かす』という本でも深く掘り下げられています。人が変化を受け入れられない理由として「惰性」「労力」「感情」「心理的反発」という4つの要因があるそうです。両書を併せて読むことで、人がなぜ現状維持バイアスに縛られやすいのか、より立体的に理解できました。「変化を嫌う人」を動かす:魅力的な提案が受け入れられない4つの理由作者:ロレン・ノードグレン,デイヴィッド・ションタル,船木 謙一(監修)草思社Amazon本書を読んで、自分の行動の多くが実は「論理的な判断」ではなく「認知バイアス」によって左右されていることを実感しました。この気づきは、自分の意思決定を見直すきっかけになると同時に、他者の行動をより深く理解することにもつながります。賢明なのは、これらのバイアスと戦うことではなく、その存在を認識した上で、うまく付き合っていくことなのかもしれません。勘違いが人を動かす――教養としての行動経済学入門作者:エヴァ・ファン・デン・ブルック,ティム・デン・ハイヤーダイヤモンド社Amazonおわりに今年の読書を振り返ってみると、一つの大きなテーマが浮かび上がってきました。それは「人はいかに自分の思い込みに縛られているか」ということです。私たちは普段、意識せずに様々な思い込みの中で生活しています。でも、新しい本と出会うたびに、そんな「当たり前」が少しずつ揺さぶられていくような体験をしました。「へぇ～、そうなんだ」という素直な驚きから始まった読書でしたが、振り返ってみると、それぞれの本が不思議と響き合って、より深い気づきをもたらしてくれたように思います。理論的な本を読んでは実践的な本で確認し、個人的な視点の本を読んでは社会的な視点の本で補完する。そんな読書の往復運動の中で、自分の視野が少しずつ広がっていくのを感じました。来年も、このように自分の「思い込み」を優しく解きほぐしてくれるような本との出会いを楽しみにしています。そして、その体験をまた皆さんと共有できればと思います。最後まで読んでいただき、ありがとうございました。","isoDate":"2024-12-24T23:48:01.000Z","dateMiliSeconds":1735084081000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"2024年 俺が愛した本たち 技術書編","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/23/174750","contentSnippet":"この記事は、3-shake Advent Calendar 2024 24日目のエントリ記事です。はじめにこんにちは、nwiizoです。2024年も残りわずかとなりました。年の瀬に差し掛かるこの時期、1年の歩みを振り返り、時の流れを見つめ直すことは、私にとって特別な意味を持っています。今年は特に、技術書との関わり方に大きな変化がありました。本を紹介する投稿する中で、技術書のみならず、さまざまな分野の書籍を読む機会が大幅に増えました。私の書斎は、いつの間にか技術書のデータセンターと化しました。サーバーラックの代わりに本棚が整然と並び、それぞれの棚には未読の本という名のサーバーがぎっしりと配置されています。これらの「サーバー」は、24時間365日、知識というバックグラウンドプロセスを静かに実行し続けています。既にメモリの使用率は常に100%ですが、まだ、クラッシュすることはありません。クラッシュしたら次の年はこの文章を読むことができません。特に今年は、技術書との向き合い方を見つめ直した1年でした。これまでのように「量」を追い求めるのではなく、一冊一冊を深く理解し、質を重視することに注力しました。技術書は単なる情報の集合体ではなく、先人たちの経験や洞察が凝縮された知恵の結晶です。その知恵を丁寧に咀嚼し、自分の中に取り込む過程が、エンジニアとしての成長に直結することを改めて実感しました。この記事では、2024年に私が出会い、心を揺さぶられた技術書たちを厳選してご紹介します。これらの書籍が、読者の皆様に新たな発見と学びをもたらすきっかけになれば幸いです。はじめに昨年以前に紹介した本2024年に読んでよかった技術書Platform Engineering on KubernetesPlatform EngineeringContinuous DeploymentCloud Observability in ActionLearning OpenTelemetryBecoming SREFundamentals of Data EngineeringTidy First?ソフトウェア開発現場の「失敗」集めてみた。42の失敗事例で学ぶチーム開発のうまい進めかたプログラミングRust 第2版Effective Rustバックエンドエンジニアを目指す人のためのRustReal World HTTP 第3版【改訂新版】システム障害対応の教科書GitHub CI/CD実践ガイドおわりに昨年以前に紹介した本syu-m-5151.hatenablog.comsyu-m-5151.hatenablog.comsyu-m-5151.hatenablog.comsyu-m-5151.hatenablog.com2024年に読んでよかった技術書今年も、私の知識データベースは絶え間なく更新され続けました。読書から得た知識は、ソフトウェアエンジニアとしての実務という名のプロダクション環境で厳密にテストされ、その成果は、いくつかの技術イベントでの登壇という形でデプロイされました。幸いにも、これまでクリティカルな障害が発生したことはありません。私の脳内APIは、多くの技術書から寄せられるリクエストを処理し続けています。レスポンスタイムは決して速いとは言えませんが、スループットは着実に向上しています。そして以下では、2024年に私の知識基盤に大きなアップデートをもたらした技術書を紹介します。これらの書籍は、私に新しい視点やスキルを与え、成長の助けとなりました。speakerdeck.comPlatform Engineering on Kubernetes「Platform Engineering on Kubernetes」は、クラウドネイティブ時代のプラットフォームエンジニアリングの本質と実践を包括的に解説した一冊です。本書は、単なるKubernetesの解説書を超えて、現代のソフトウェア開発組織が直面する課題とその解決策を体系的に示しています。Platform Engineering on Kubernetes (English Edition)作者:Salatino, MauricioManningAmazon本書の核心は、「なぜKubernetes上にプラットフォームを構築する必要があるのか」という根本的な問いに対する答えを提示している点です。著者は、複数のチームが関わり、複数のクラウドプロバイダーへのデプロイを行い、異なるスタックを扱う組織では、Kubernetesの導入だけでは不十分であることを説き、プラットフォームエンジニアリングによってこれらの課題を技術的・組織的に解決する方法を示しています。特に印象的なのは、プラットフォームチームと開発チームの協調に関する著者の洞察です。プラットフォームは単なる技術的な基盤ではなく、開発者の生産性を最大化し、ビジネス価値の迅速な提供を可能にする戦略的な資産として位置づけられています。これは、DevOpsの理想をクラウドネイティブ時代に実現するための具体的なアプローチと言えます。本書は、概念的な解説に留まらず、実践的なステップバイステップのガイドも提供しています。カンファレンスアプリケーションというサンプルを通じて、プラットフォームの設計から実装、運用までを一貫して学ぶことができます。これにより、読者は理論と実践の両面から、プラットフォームエンジニアリングの本質を理解できます。また、本書はCrossplane、ArgoCD、Dapr、OpenFeatureなど、現代のクラウドネイティブツールの活用法も詳しく解説しています。これらのツールを適切に組み合わせることで、開発者体験の向上とインフラストラクチャの効率化を両立できることが示されています。この本を読み進める中で、プラットフォームエンジニアリングが単なる技術的な取り組みを超えて、組織全体のデジタルトランスフォーメーションを推進する原動力となり得ることを実感しました。著者の提示する知見は、エンジニアリング組織の次なるステージを考える上で、貴重な指針となるでしょう。「Platform Engineering on Kubernetes」では、プラットフォームエンジニアリングの技術的側面について深く解説されています。しかし、内部開発者向けのプラットフォームも一つのプロダクトとして捉え、その価値提供を最適化していく視点も重要です。そこで、以下の書籍との併読をお勧めします。プロダクトマネジメントのすべて 事業戦略・IT開発・UXデザイン・マーケティングからチーム・組織運営まで作者:及川 卓也,小城 久美子,曽根原 春樹翔泳社Amazon「プロダクトマネジメントのすべて」は、プロダクトの企画から運用、改善までを包括的に解説した決定版です。本書を通じて、プラットフォームを一つのプロダクトとして捉え、ユーザーである開発者の体験を最適化していくための方法論を学ぶことができます。さらに、プラットフォームチームがどのようにステークホルダーと協働し、組織全体の価値を最大化していくかについても、実践的な知見を得ることができます。両書を組み合わせることで、技術とプロダクトマネジメントの両面から、より効果的なプラットフォームエンジニアリングの実践が可能になるでしょう。Platform Engineering「Platform Engineering: A Guide for Technical, Product, and People Leaders」は、現場での実践知を出発点として、プラットフォームエンジニアリングの本質に迫る実践的なガイドです。技術リーダーから上級管理職まで向けた幅広い読者層に向けて書かれており、個人的にはもう少しだけ広げて開発者やプラットフォームを実際に使う側も読んでも学びのある本だと感じました。Platform Engineering: A Guide for Technical, Product, and People Leaders (English Edition)作者:Fournier, Camille,Nowland, IanO'Reilly MediaAmazon「Platform Engineering on Kubernetes」がKubernetesを基盤とした技術的な実装と運用に重点を置いているのに対し、本書はプラットフォームエンジニアリングをより広い文脈で捉え、組織的・人的側面にも深く踏み込んでいます。例えば、プラットフォームチームの組織的な位置づけ、ステークホルダーとの関係構築、プラットフォーム提供者と利用者の協力関係の構築など、「Platform Engineering on Kubernetes」では詳しく触れられていない領域をカバーしています。特に注目すべきは、本書がプラットフォームの成功を技術的な完成度だけでなく、組織全体への価値提供という観点から評価している点です。プラットフォームの採用を促進し、持続可能な運用を実現するためには、技術的な卓越性に加えて、組織的な課題への対応も重要であることを説いています。そのため、両書を併読することで、技術的な実装から組織的な展開まで、プラットフォームエンジニアリングの全体像を把握することができます。本書を読む前に、「Team Topologies」を一読することを強くお勧めします。「Team Topologies」は、現代のソフトウェア開発組織における効果的なチーム構造とその相互作用のパターンを提示しており、プラットフォームチームの位置づけや役割を理解する上で不可欠な知見を提供してくれます。この基礎的な理解があることで、本書で展開されるプラットフォームエンジニアリングの実践論をより深く理解することができます。チームトポロジー　価値あるソフトウェアをすばやく届ける適応型組織設計作者:マシュー・スケルトン,マニュエル・パイス日本能率協会マネジメントセンターAmazon著者の豊富な経験が凝縮された本書は、単なる表面的な手法の模倣ではなく、実際の現場での試行錯誤から導き出されたプラクティス、そしてその背後にある根本的な原理と思想を探求しています。それが現代のソフトウェア開発組織においていかに革新的な価値を生み出すかを浮き彫りにしている点が特徴的です。本書の真価は、プラットフォームエンジニアリングを単なる技術的な手法の集合としてではなく、日々の実践から得られた知見を体系化し、組織の進化と持続的な成長を促す戦略的な思考基盤として捉えている点にあります。技術的な実装の詳細よりも、組織が現場の文脈に根ざした実践を重ね、そこからプラクティスを抽出し、最終的にプラットフォームエンジニアリングの本質的な原則を理解して創造的に応用していく方法論に重点が置かれています。技術的な側面、特にCloud Nativeな実装に興味がある方には、「Platform Engineering on Kubernetes」がおすすめです。こちらの書籍では、Kubernetesを基盤としたプラットフォームエンジニアリングの実践的なアプローチが詳細に解説されています。両書を併読することで、プラットフォームエンジニアリングの組織的側面と技術的側面の両方を深く理解することができ、より包括的な知識を得ることができるでしょう。本書は、プラットフォームエンジニアリングの現場で直面する本質的な難しさを率直に語っています。具体的には、「技術的に面白いから作る」のではなく現場で真に必要とされるものを見極めて提供するという価値提供の本質、計画の難しさを認識しつつも現場の文脈に応じて適切に実行するという実践知、そして組織の重要なシステムを支える責任を全うするための運用の成熟という現場力の醸成といった課題を挙げています。これらの課題に対して、本書は原則に基づきながらも現場の実態に即した解決の道筋を示しています。最後に、読者として強く感じたのは、プラットフォームエンジニアリングが単なる技術的な課題ではなく、組織的な取り組みとして捉える必要があるという点です。特に、チームの持続可能性とユーザー満足度の両立という観点から、著者の提案する実践的なアプローチは非常に価値があります。本書で提示されているプラクティスは、理想的ではありますが現実的な目標として設定されており、段階的な改善のためのロードマップとしても機能します。特に重要なのは、組織の規模や成熟度に応じて適切なアプローチを選択し、継続的に改善を進めていく姿勢だと考えています。Continuous Deployment「Continuous Deployment: Enable Faster Feedback, Safer Releases, and More Reliable Software 」は、継続的デプロイメントの実践に焦点を当てた包括的なガイドです。継続的デプロイメントは、ソフトウェアパイプラインを完全に自動化し、手動介入を必要としない手法です。この方法により、クオリティーゲートを通過したすべてのコードコミットが自動的に本番環境にデプロイされます。Continuous Deployment: Enable Faster Feedback, Safer Releases, and More Reliable Software (English Edition)作者:Servile, ValentinaO'Reilly MediaAmazon本書の理解をより深めるためには、「Grokking Continuous Delivery」との併読をお勧めします。この本は、継続的デリバリーの基本概念から実践的な実装まで、体系的に解説しています。特に、継続的デプロイメントへの段階的な移行プロセスや、組織文化の変革について、実践的な知見を提供してくれます。両書を読み進めることで、継続的デプロイメントの技術的側面と組織的側面の両方を包括的に理解することができます。Grokking Continuous Delivery (English Edition)作者:Wilson, ChristieManningAmazonこちらの本は日本語版がリリースされています。入門 継続的デリバリー ―テストからリリースまでを安全に自動化するソフトウェアデリバリーのプロセス作者:Christie Wilsonオーム社Amazon本書は、単なる技術的な実装の解説に留まらず、プラットフォームエンジニアリングと開発プロセス全体を変革する可能性について深く掘り下げています。特に、フィーチャーフラグ、カナリーリリース、A/Bテストなどの重要な概念と、それらの実践的な適用方法について詳細な洞察を提供しています。継続的デプロイメントの価値は、ソフトウェア開発の特性と人間の性質を理解することで明確になります。人間は反復作業を得意としませんが、コンピューターシステムはこの種の作業に適しています。継続的デプロイメントは、人間と機械の特性の違いを活かし、相互補完的に活用します。コード変更から本番環境へのデプロイまでを完全に自動化することで、開発者は創造的な問題解決に注力でき、反復的なタスクはシステムに任せることができます。結果として、ソフトウェア開発プロセス全体の効率が向上し、人的ミスのリスクも減少します。本書は、技術的側面だけでなく、組織文化やチーム間の協力体制についても掘り下げています。また、継続的デプロイメントがもたらすソフトウェアのリリースサイクルの短縮や、ユーザーへのフィードバックループの最小化についても解説しています。同時に、コードの品質管理やテスト戦略により高い要求を課すことの重要性も強調しています。強固な自動テスト、モニタリング、迅速なロールバック機能など、継続的デプロイメントを成功させるために不可欠な安全策についても説明しています。実践的な見地からも、本書は開発者が直面する現実的な課題に対する具体的な解決策を提供しています。各章は理論的な基礎から始まり、実際の適用例、そして起こりうる問題とその対処法まで、包括的に解説しています。特に、実際の組織がどのように継続的デプロイメントを導入し、成功を収めているかについての事例研究は、実務に直接活かせる貴重な知見となっています。本書を通じて、継続的デプロイメントが単なる技術的なツールではなく、組織全体の開発文化を変革し、ソフトウェア品質を向上させるための包括的なアプローチであることが理解できます。その実践は、開発効率の向上、リリース品質の改善、そして最終的には顧客満足度の向上につながります。Cloud Observability in Action「Cloud Observability in Action」は、クラウドネイティブ時代におけるオブザーバビリティの概念と実践方法を包括的に解説した一冊です。オブザーバビリティを投資対効果の観点から捉え、データの生成から収集、処理、可視化に至るまでのプロセス全体を俯瞰します。これは、神の視点でシステムを観察できるようになる、デジタル世界の第三の目を手に入れるようなものです。Cloud Observability in Action (English Edition)作者:Hausenblas, MichaelManningAmazonOpenTelemetry、Prometheus、Grafana、Loki、Jaegerなどのオープンソースツールを活用し、誰でも実践的な知見を時間以外の費用をかけずに得られるよう工夫されています。まるで高級な料理のレシピを、コンビニの食材だけで再現する魔法のような本です。著者の豊富な経験に基づくベストプラクティスが随所に盛り込まれ、参考URLも惜しみなく共有されています。システムの監視方法について、何百人もの先人たちが積み上げてきた叡智を一冊に凝縮したような贅沢な内容です。単なるツールの使い方の解説にとどまらず、オブザーバビリティを組織文化として定着させるためのヒントも提供されています。つまり、「システムの見える化」という名の文化革命の指南書とも言えるでしょう。本書を通じて、システムの内部状態を把握・推論する力を身につけることができます。これは、デジタルの迷宮で道に迷った開発者たちに、アリアドネの糸を提供するようなものです。得られた知見をどのように活用するかは読者次第ですが、システムと組織の継続的な進化を支える原動力として、オブザーバビリティを正しく理解し実践することができます。少なくとも、「エラーログを検索すれば何とかなる」という幻想から解放されることは間違いありません。本書は、複雑化するシステムの「見える化」を実現するための、実践的なガイドブックです。これを読まずにオブザーバビリティを始めるのは、暗闇の中でパズルを解こうとするようなものかもしれません。本稿では、各章の要点を丁寧に読み解きながら、私なりの学びと気づきをシェアしていきます。皆様にとっても、オブザーバビリティへの理解を深め、その実践への一歩を踏み出すきっかけとなれば幸いです。Learning OpenTelemetry「Learning OpenTelemetry」は、可観測性という広大な領域に対する実践的な航海図といえます。本書の最も重要な貢献は、OpenTelemetryというテクノロジーを通じて、システムの可観測性をビジネス価値へと変換する具体的な方法論を提示している点です。Learning OpenTelemetry: Setting Up and Operating a Modern Observability System (English Edition)作者:Young, Ted,Parker, AustinO'Reilly MediaAmazon本書を読む際は、オブザーバビリティに関する以下の2冊との併読をお勧めします。まず「Observability Engineering」は、可観測性の基本概念から実践的な実装まで、より広い文脈で解説しています。特に、OpenTelemetryを含む様々な可観測性ツールの位置づけや、組織における可観測性の文化醸成について、包括的な視点を提供してくれます。両書を読み進めることで、技術的な実装の詳細と、より大きな戦略的文脈の両方を理解することができます。Observability Engineering: Achieving Production Excellence (English Edition)作者:Majors, Charity,Fong-Jones, Liz,Miranda, GeorgeO'Reilly MediaAmazonまた、「入門 監視」は、システム監視の基礎から応用まで、実践的な知見を提供してくれます。監視とオブザーバビリティの関係性、メトリクスの収集と分析、アラートの設計など、日々の運用に直結する知識を学ぶことができます。入門 監視 ―モダンなモニタリングのためのデザインパターン作者:Mike JulianオライリージャパンAmazon本書の特筆すべき点は、技術的深度、組織的展開、ビジネス価値という3つの視点を統合的に扱っていることです。技術面では、OpenTelemetryの内部アーキテクチャから実装の詳細まで、体系的な解説を提供しています。特に、トレース、メトリクス、ログの統合方法や、テレメトリパイプラインの設計については、実務で即座に活用できる具体的な知見が豊富です。組織面では、可観測性の導入を単なる技術導入ではなく、組織変革として捉える視点を提供しています。特に、Deep対Wide、Code対Collection、Centralized対Decentralizedという3つの軸に基づく展開戦略は、組織の規模や成熟度に応じた柔軟なアプローチを可能にします。ビジネス面では、テレメトリデータを通じてビジネスの意思決定や改善につなげていく方法について、具体的な指針を示しています。私が実務を通じて特に共感したのは、本書の掲げる「Do no harm, break no alerts」という原則です。可観測性の向上は、既存のシステムや運用プロセスを破壊することなく、段階的に実現していくべきだという主張は、現場の実態に即した賢明なアプローチだと感じます。本書の構成も実践的です。各章は理論的な基礎から始まり、実装の詳細、そして運用上の考慮点へと展開されていきます。特に、各章末のケーススタディやベストプラクティスは、他組織の経験から学ぶ貴重な機会を提供してくれます。最後に、本書の結論部分で言及されている「可観測性の次のフロンティア」についても注目に値します。AIとの統合やテストとしての可観測性など、新しい可能性の提示は、この分野の今後の発展を考える上で重要な示唆を与えてくれます。OpenTelemetryの導入を検討している組織にとって、本書は単なる技術解説書以上の価値を持つ戦略的なガイドブックとなるでしょう。また、すでにOpenTelemetryを導入している組織にとっても、その活用方法を再考し、より高度な可観測性を実現するための有益な指針となることは間違いありません。こちらの本は日本語版がリリースされています。入門 OpenTelemetry ―現代的なオブザーバビリティシステムの構築と運用作者:Ted Young,Austin ParkerオライリージャパンAmazonBecoming SRE「Becoming SRE」は、SRE（Site Reliability Engineering）という職種に対する深い理解と実践的な洞察を提供する画期的な一冊です。本書は、個人がSREとしてのキャリアを築くための道筋と、組織がSREを導入・発展させるための戦略を包括的に解説しています。Becoming SRE: First Steps Toward Reliability for You and Your Organization (English Edition)作者:Blank-Edelman, David N.O'Reilly MediaAmazonSREに関する書籍は数多く出版されていますが、本書の特筆すべき点は、その実践に基づいた具体性と実用性にあります。特に、他のSRE関連書籍が理論や理想的なプラクティスの解説に重点を置く傾向がある中、本書は現場で直面する現実的な課題とその解決策に焦点を当てています。例えば、Googleが提唱したSREの原則やプラクティスを、規模や成熟度の異なる組織でどのように適用していくかについて、具体的なステップとアプローチを示しています。また、SREとしてのキャリアパスや、組織内でのSRE文化の醸成方法など、実務者の視点に立った実践的なアドバイスが豊富に盛り込まれています。syu-m-5151.hatenablog.com本書の価値は、SREという職種を単なる技術的な役割としてではなく、組織の文化や価値観を形作る存在として捉えている点にあります。著者のDavid Blank-Edelman氏は、長年のSREとしての経験を基に、技術とビジネスの両面からSREの本質に迫っています。本書は3つのパートで構成されています。Part Iでは、SREの基本的な概念、文化、そしてマインドセットについて解説しています。特に注目すべきは、SREが目指すべき「適切な信頼性レベル」という考え方です。100%の信頼性を追求するのではなく、ビジネスの要求と照らし合わせながら、最適な信頼性レベルを見極めることの重要性が説かれています。Part IIは、個人がSREになるための具体的なステップを示しています。技術的なスキルセットはもちろん、コミュニケーション能力、問題解決力、そして失敗から学ぶ姿勢など、SREに求められる多面的な資質について詳細に解説されています。特筆すべきは、オンコール対応やインシデント管理といった実務的なトピックについても、豊富な事例とともに具体的なアドバイスが提供されている点です。Part IIIでは、組織としてSREを導入・発展させるための戦略が展開されています。SREの成功は、個々のエンジニアの努力だけでなく、組織全体のサポートと理解が不可欠だという著者の主張は説得力があります。特に興味深いのは、SREの組織的な成熟度を5つのステージで捉えるフレームワークです。各ステージの特徴と課題、そして次のステージへの移行に必要な施策が具体的に示されています。本書が特に強調しているのは、SREにおける「文化」の重要性です。モニタリング、自動化、インシデント対応といった技術的な実践も重要ですが、それらを支える組織文化がなければ、SREは真の力を発揮できません。データ駆動の意思決定、失敗から学ぶ姿勢、部門間の協働、これらの文化的要素をどのように育んでいくかについても、深い洞察が示されています。また、本書はSREの導入と成長における現実的な課題にも正面から向き合っています。技術的な障壁はもちろん、組織の抵抗、リソースの制約、文化の変革の難しさなど、SREが直面する様々な課題に対する具体的な対処法が提示されています。総じて本書は、SREを目指す個人にとってのキャリアガイドであると同時に、組織にとってのSRE導入・発展のロードマップとして機能する実践的な指南書です。著者の豊富な経験に基づくアドバイスは、SREという未知の領域に踏み出そうとする読者にとって、信頼できる道標となるはずです。こちらの本も日本語版がリリースされています。SREをはじめよう ―個人と組織による信頼性獲得への第一歩作者:David N. Blank-EdelmanオライリージャパンAmazonFundamentals of Data Engineering「Fundamentals of Data Engineering」は、データエンジニアリングの基礎から実践までを体系的に解説した包括的な一冊です。データエンジニアリングを「raw dataを取り込み、高品質で一貫性のある情報を生成するシステムとプロセスの開発、実装、維持」と定義し、その全容を詳細に説明しています。Fundamentals of Data Engineering: Plan and Build Robust Data Systems (English Edition)作者:Reis, Joe,Housley, MattO'Reilly MediaAmazon本書は4つのパートで構成されており、Part Iではデータエンジニアリングの基礎と構成要素、Part IIではデータエンジニアリングのライフサイクルの詳細、Part IIIではセキュリティとプライバシー、そして将来の展望を扱っています。特に、データ生成からストレージ、取り込み、変換、提供までの一連のライフサイクルについて、実践的な知見が豊富に盛り込まれています。著者たちは、特定のツールや技術に依存しない原則ベースのアプローチを採用しています。これにより、急速に変化するデータ技術の世界においても、長く有効な知識を提供することに成功しています。データエンジニアは、セキュリティ、データ管理、DataOps、データアーキテクチャ、オーケストレーション、ソフトウェアエンジニアリングの交差点に位置し、これらの要素を統合的に理解し活用する必要があることが強調されています。本書の特筆すべき点は、理論と実践のバランスが絶妙なことです。データエンジニアリングの基本原則を解説しながら、実際のシステム設計や運用における具体的な課題とその解決策も提示しています。また、クラウドファーストの時代におけるデータエンジニアリングの在り方についても深い洞察が示されています。セキュリティとプライバシーに関する章では、データエンジニアリングにおけるセキュリティの重要性と、具体的な実装方法が詳細に解説されています。GDPRなどの規制への対応や、データの匿名化、アクセス制御など、現代のデータエンジニアが直面する重要な課題がカバーされています。最後に、データエンジニアリングの将来に関する章では、業界の動向と今後の展望が示されています。クラウドスケールの「データOS」の出現や、リアルタイムデータ処理と機械学習の融合など、興味深い予測が述べられています。本書は、データエンジニアリングの世界で活躍したい技術者にとって、必携の一冊となるでしょう。体系的な知識の習得と実践的なスキルの向上に大いに役立つ内容となっています。こちらの本も日本語版がリリースされています。データエンジニアリングの基礎 ―データプロジェクトで失敗しないために作者:Joe Reis,Matt HousleyオライリージャパンAmazonTidy First?「Tidy First?」は、エクストリームプログラミングの考案者であり、ソフトウェアパターンの先駆者として知られるKent Beckによる、コードの整理整頓に関する画期的な一冊です。本書は、リファクタリングの新しい考え方として「Tidying（整理整頓）」という概念を提唱し、その実践的なアプローチを示しています。Tidy First?: A Personal Exercise in Empirical Software Design (English Edition)作者:Beck, KentO'Reilly MediaAmazonリファクタリングといえば「リファクタリング 既存のコードを安全に改善する」や「レガシーコードからの脱却」ですがこのリファクタリングの考え方をより小規模で実践的なアプローチへと発展させたものと言えるでしょう。リファクタリング 既存のコードを安全に改善する（第2版）作者:ＭａｒｔｉｎＦｏｗｌｅｒオーム社Amazonレガシーコードからの脱却 ―ソフトウェアの寿命を延ばし価値を高める9つのプラクティス作者:David Scott BernsteinオライリージャパンAmazon本書の核心は、「いつ、どこで、どのようにコードを整理するべきか」という実践的な問いに対する答えを提示している点です。特に注目すべきは、Tidyingをリファクタリングの部分集合として位置づけ、より小規模で安全な改善活動として定義している点です。本書は3つのパートで構成されています。Part 1: Tydingsでは、具体的な整理整頓の手法が示されています。変数名の調整や対称性の確保、不要なコードの削除など、小規模だが効果的な改善活動が詳しく解説されています。これらは、ボーイスカウトの原則（来たときよりも美しく）とも通じる考え方です。Part 2: Managingでは、Tidyingの実践的なマネジメントについて解説されています。特に重要なのは、機能開発の直前にTidyingを行うべきという提言です。これは、料理をする前にキッチンを整理整頓するのと同じように、本題に取り組む前に作業環境を整えることの重要性を示唆しています。また、Tidyingは1時間以内に完了できる規模に抑えるべきという具体的な指針も示されています。Part 3: Theoryでは、Tidyingの理論的な基盤が展開されています。特筆すべきは、経済的な観点からの分析です。NPV（正味現在価値）やオプション理論を用いて、Tidyingの投資対効果を説明しています。また、疎結合と高凝集というソフトウェアアーキテクチャの基本原則との関連も論じられています。また、ソフトウェア設計の基本原則をより深く理解するために、以下の2冊との併読をお勧めします。「Balancing Coupling in Software Design」は、システムの結合度に焦点を当て、モジュール性と複雑性のバランスを取るための実践的なガイドを提供しています。特に、結合度を単なる「悪いもの」としてではなく、システム設計における重要なツールとして捉え直す視点は、Tidyingの経済的価値の考え方と共鳴します。Balancing Coupling in Software Design: Universal Design Principles for Architecting Modular Software Systems (Addison-Wesley Signature Series (Vernon)) (English Edition)作者:Khononov, VladAddison-Wesley ProfessionalAmazonさらに、「A Philosophy of Software Design, 2nd Edition」は、ソフトウェア設計における複雑性の管理について、より哲学的な視点から考察を展開しています。この本は、モジュール分割の原則やインターフェース設計の考え方など、Tidyingの実践を支える理論的な基盤を補完してくれます。A Philosophy of Software Design, 2nd Edition (English Edition)作者:Ousterhout, John K. Amazon本書の真価は、コードの整理整頓を、技術的な活動としてだけでなく、経済的な投資活動として捉える視点を提供している点です。これは、技術的な改善活動の必要性を経営層に説明する際の有効な理論的基盤となります。また、本書は3部作の第1巻として位置づけられており、個人、チーム、組織のレベルでの開発プラクティスを包括的に扱う野心的なプロジェクトの出発点となっています。私にとって、本書は技術的負債の管理に関する新しい視点を提供してくれました。特に、小規模な改善活動を継続的に行うことの重要性と、その活動の経済的な価値を理解する上で、貴重な指針となっています。本書で提唱されているTidyingの概念は、現代のソフトウェア開発における持続可能性の向上に大きく貢献する可能性を秘めています。技術的な改善と経済的な価値創造の両立を目指す実践的なアプローチとして、多くの開発者にとって有益な知見となるでしょう。こちらの本も日本語版がリリースされます。読んでないのですが定評のある翻訳者陣が担当しており、高品質な翻訳が期待できます。Tidy First? ―個人で実践する経験主義的ソフトウェア設計作者:Kent Beckオーム社Amazonソフトウェア開発現場の「失敗」集めてみた。42の失敗事例で学ぶチーム開発のうまい進めかた「ソフトウェア開発現場の「失敗」集めてみた」は、開発現場でありがちな失敗を42の事例としてまとめ上げた、笑いと教訓が詰まった一冊です。本書の特徴は、各エピソードを4コマ漫画付きで紹介しながら、その失敗から学べる教訓と対策を実践的に解説している点にあります。ソフトウェア開発現場の「失敗」集めてみた。 42の失敗事例で学ぶチーム開発のうまい進めかた作者:出石 聡史翔泳社Amazon本書の真髄は、「失敗」を単なる戒めとしてではなく、成長のための貴重な学びの機会として提示している点です。例えば、「全部入りソフトウェア」や「八方美人仕様」といった事例は、読んでいて思わず苦笑してしまうものの、自分の過去や現在の案件と重ね合わせると背筋が凍るような リアルな内容となっています。特に印象的なのは、各失敗事例が企画、仕様、設計・実装、進捗管理、品質管理、リリース後という開発工程に沿って整理されている点です。これにより、どの段階でどのような落とし穴が待ち構えているのかを、体系的に理解することができます。本書の構成は非常に巧みです。各エピソードは、まず4コマ漫画で状況を分かりやすく説明し、続いて失敗の詳細な解説へと進みます。そして、なぜその失敗が起きるのかという原因分析を行い、最後にどうすれば防げるのかという具体的な対策を示すという流れで展開され、読者を笑いながら学びへと導いていきます。時には「あるある...」と共感し、時には「まさか自分も...」と冷や汗をかきながら、気づけば実践的な対策を学んでいられるという、絶妙な構成となっています。本書を読み進めていく中で、開発現場で日々直面する可能性のある様々な失敗のパターンが、読者の経験と重なりながら鮮やかに描き出されていきます。それぞれの事例は、読者が「ああ、これは...」と思わず身につまされるような、リアルな状況として描かれています。ここで思い出したのが、「達人プログラマー 第2版」です。この本もまた、ソフトウェア開発における失敗と成功の本質を深く掘り下げています。両書に共通するのは、失敗を恐れるのではなく、そこから学び、次につなげていく姿勢です。「達人プログラマー」が開発者としての哲学や普遍的な原則を説くのに対し、この本は現場での具体的な失敗事例とその対策に焦点を当てており、互いに補完し合う関係にあると言えるでしょう。達人プログラマー ―熟達に向けたあなたの旅― 第2版作者:David Thomas,Andrew Huntオーム社Amazon本書の真価は、これらの失敗を「笑い」というクッションを通して提示することで、読者が防衛本能を働かせることなく、客観的に問題を理解し、解決策を考えられるようにしている点です。また、各事例に対する具体的な対策は、実務ですぐに活用できる実践的なものとなっています。私自身、本書を読みながら何度も「あ、これ...」と苦笑いしましたが、同時に「明日からこうしよう」という具体的なアクションプランも得ることができました。特に、チームリーダーやプロジェクトマネージャーにとって、この本は「失敗」という観点からプロジェクトを見直す貴重な機会を提供してくれます。本書は、開発現場の失敗から学ぶという姿勢を大切にしながら、その教訓を次の成功へとつなげていく道筋を示してくれる良書です。時には笑い、時には考え込み、そして明日からの行動を変えていく—そんな良い意味での「反省の書」といえるでしょう。プログラミングRust 第2版「プログラミングRust 第2版」は、Rustという言語の深い理解を導く羅針盤のような一冊です。本書は、システムプログラミングの本質に迫りながら、現代的な言語機能を体系的に解説するという野心的な試みに成功しています。プログラミングRust 第2版作者:Jim Blandy,Jason Orendorff,Leonora F. S. TindallオライリージャパンAmazonこの本の特筆すべき点は、Rustの重要な概念を段階的に、かつ包括的に解説していることです。特に所有権とライフタイム、並行処理といったRustの特徴的な機能について、理論的な説明と実践的な例を絶妙なバランスで提供しています。これは、まるで高度な技術文書をコンパイラが最適化するように、複雑な概念を理解しやすい形に変換してくれる働きがあります。本書の構成は、基本的な言語機能から始まり、徐々により高度なトピックへと展開していきます。例えば、非同期プログラミングやトレイト、ジェネリクス、マクロなど、モダンなRustの重要な機能が詳細に解説されています。これは、読者の理解度を段階的にスケールアップさせていく、よく設計されたアーキテクチャのようです。特に印象的なのは、本書がパフォーマンスとメモリ安全性を両立させるためのRustの機能を、システムプログラマの視点から丁寧に解き明かしている点です。これは、高可用性システムの設計原則にも通じる、信頼性とパフォーマンスのトレードオフを実践的に学べる貴重な機会を提供しています。また、本書は2021年のRust Editionに対応しており、最新の言語機能や実践的なプログラミング手法が網羅されています。これは、まるで継続的デリバリーのパイプラインのように、最新の知識を読者に届けてくれます。実務的な観点からも、本書の価値は計り知れません。エラーハンドリング、テスト、デバッグといった実践的なトピックについても、深い洞察と具体的な実装例を提供しています。これらの知識は、本番環境でのRustプログラミングにおいて、インシデントを防ぎ、安定性を確保するための重要な基盤となります。本書は、単なる言語仕様の解説書を超えて、システムプログラミングの本質に迫る良書といえます。その内容は、Rustを学ぶ開発者にとって、強固な基盤となるインフラストラクチャを提供してくれることでしょう。私にとって、本書は技術書のデータセンターの中核を担うサーバーとして機能しています。新しい機能や概念に出会うたびに、本書に立ち返り、その本質的な理解を深めることができます。2025年に予定されているRust 2024 Editionのリリースに向けて、本書の次版がどのように進化していくのか、今から楽しみでなりません。Programming Rust: Fast, Safe Systems Development (English Edition)作者:Blandy, Jim,Orendorff, Jason,Tindall, Leonora F. S.O'ReillyAmazonEffective Rust「Effective Rust」は、Rustのコンパイラが発する警告やエラーの深い理由を解き明かしてくれる、暗号解読書のような一冊です。本書は、単なる文法やパターンの解説を超えて、Rustの設計思想とその根底にある原理を探求することで、より深い理解と実践的なスキルの獲得を可能にします。Effective Rust: 35 Specific Ways to Improve Your Rust Code (English Edition)作者:Drysdale, DavidO'Reilly MediaAmazon本書の真髄は、「なぜそのコードがコンパイラに拒否されるのか」という本質的な問いに対する答えを提供している点です。これは、まるでセキュリティ監査ツールのような役割を果たし、潜在的な問題を事前に検出し、より安全なコードへと導いてくれます。例えば、借用チェッカーとの「戦い」は、実はメモリ安全性を確保するための重要な対話であることを理解させてくれます。特筆すべきは、本書が型システムを通じたデザインパターンを詳細に解説している点です。これは、アプリケーションのアーキテクチャを型安全に設計するための青写真を提供してくれます。例えば、newtypeパターンの活用や、トレイトを用いた共通の振る舞いの表現など、型システムを活用した設計手法を学ぶことができます。また、本書はエラーハンドリングのベストプラクティスについて深い洞察を提供します。OptionやResult型の効果的な使用法から、独自のエラー型の設計まで、堅牢なエラー処理の体系を示してくれます。これは、まるで障害対策のプレイブックのような役割を果たします。実務的な観点からも、本書の価値は計り知れません。依存ライブラリの管理やツールチェーンの活用など、実践的なトピックについても詳しく解説されています。特に、Clippyとの対話を通じたコード品質の向上や、CIシステムの設定など、現代のソフトウェア開発に不可欠な知識が網羅されています。本書は、「とりあえず動く」コードから「より良い」コードへの進化を支援してよりイディオマティックなRustコードへの道筋を示してくれます。私にとって、本書は技術書のデータセンターにおける重要なセキュリティシステムとして機能しています。コードの品質と安全性を確保するためのチェックポイントとして、常に参照すべき存在となっています。特に、「なぜそうすべきか」という根本的な理解を深めることで、より効果的なRustプログラミングが可能になります。こちらの本も日本語版がリリースされています。Effective Rust ―Rustコードを改善し、エコシステムを最大限に活用するための35項目作者:David Drysdaleオーム社Amazonバックエンドエンジニアを目指す人のためのRust「バックエンドエンジニアを目指す人のためのRust」は、単なるRustの入門書を超えて、実践的なプロジェクトを通じてバックエンドエンジニアに必要な知識とスキルを体系的に学べる一冊です。本書は、「なぜバックエンドにRustなのか」という根本的な問いに、具体的なプログラミング体験を通じて答えを提示しています。バックエンドエンジニアを目指す人のためのRust作者:安東 一慈,大西 諒,徳永 裕介,中村 謙弘,山中 雄大翔泳社Amazon「Webバックエンド開発にRustは不要ではないか？」という疑問に対して、本書は実践的な回答を提供します。Rustの型システムとコンパイラによる厳格なチェックは、本番環境での予期せぬエラーを事前に防ぐことができます。また、エラーハンドリングやOption/Result型の扱いなど、Rustの特徴的な機能は、信頼性の高いバックエンドシステムの構築に直接的に貢献します。本書の構成は、学習者の段階的な成長を支援するように綿密に設計されています。計算クイズから始まり、ポーカーゲーム実装でデータ構造を学び、家計簿プログラムでファイルI/Oを理解し、最終的にはTODOアプリの開発とデプロイメントまでを経験できます。各プロジェクトは、バックエンド開発に必要な特定の技術要素に焦点を当てており、理論と実践を効果的に結びつけています。また、本書はCargoによるパッケージ管理、ユニットテスト、リンター、フォーマッターといった実務で重要となる開発ツールの活用方法も丁寧に解説しています。これらのツールは、チーム開発における生産性と品質の向上に直結する重要な要素です。本書を通じて学べる実践的なスキルは、現代のバックエンド開発の現場で直接活用できます。とりわけ、Webアプリケーション開発からデプロイメントまでの一連のプロセスを実際に体験できる点は、実務への橋渡しとして非常に価値があります。最終章では採用面接を想定した内容も含まれており、学習した内容を実際のキャリアにつなげる道筋も示されています。Real World HTTP 第3版「Real World HTTP 第3版」は、HTTPプロトコルの基礎から最新動向まで、体系的かつ実践的に解説した決定版です。本書は、HTTPの歴史的な進化をたどりながら、ブラウザの内部動作やサーバーとのやり取りについて、実例とコードを交えて詳細に解説しています。Real World HTTP 第3版 ―歴史とコードに学ぶインターネットとウェブ技術作者:渋川 よしきオライリージャパンAmazon本書は、辞書的に知りたい項目を調べるのにも、通して読んで体系的に学習するのにも適しています。特に注目すべきは、認証やセキュリティなど、開発者が苦手意識を持ちがちな領域についても、実践的な観点から詳しく解説している点です。サンプルコードはGoを使用していますが、これは動作確認や挙動の理解に焦点を当てたものです。実際の実装例を通じて、HTTPの基本的な仕組みから最新の機能まで、具体的に理解することができます。もう少し入門的な内容としては「［改訂新版］プロになるためのWeb技術入門」をオススメしたいです。10年以上にわたって多くの読者に支持されてきた本書はWebシステムの基礎から最新のSPAまで、体系的かつ段階的に学べる実践的な入門書です。本書は、なぜWebシステムをうまく作ることができないのかという根本的な問いに対して、技術の本質的な理解を通じて答えを導き出そうとしています。サンプルもどうようにGoですし、Goは本能さえあれば読めるので…。［改訂新版］プロになるためのWeb技術入門作者:小森 裕介技術評論社Amazonまた、実装やWeb技術を学べたと思ってアーキテクチャ設計を学ぶ準備が整った方には、「アーキテクトの教科書 価値を生むソフトウェアのアーキテクチャ構築」をお勧めします。本書は、アーキテクチャ設計の本質的な考え方から、実践的な構築手法までを体系的に解説していて入門にはぴったりです。アーキテクトの教科書 価値を生むソフトウェアのアーキテクチャ構築作者:米久保 剛翔泳社AmazonWeb技術やアーキテクチャについて検索エンジンやChatGPTで調べると、求めている答えにたどり着くまでに多くの時間がかかり、また得られる情報が断片的になりがちです。一方、良質な技術書は、その分野の知識を体系的に整理し、読者が見落としがちな重要なポイントも含めて包括的に解説してくれます。さらに、実践的な経験に基づく洞察や、背景にある原理の説明など、オンラインでは得にくい深い知見を提供してくれます。第3版では、より初学者を意識した導入や、スーパーアプリなどプラットフォーム化するウェブに関する新章が追加されています。また、HTTP/3とQUICなど最新の技術動向についても詳しく解説されています。本書の圧倒的な情報量は、単なるボリュームではなく、実務で本当に必要となる知識が凝縮されています。AWSやWebフレームワークでの開発スキルも重要ですが、真のWebエンジニアとして成長するためには、本書で解説されているような基盤となる知識の理解が不可欠です。学び直しにも最適な一冊であり、眺めるだけでも新しい発見が得られます。HTTPやWeb技術の深い理解を目指す若手エンジニアには、まさに必携の書といえるでしょう。【改訂新版】システム障害対応の教科書「システム障害対応の教科書」は、システム障害対応の暗黙知を形式知化し、体系的に解説した画期的な一冊です。本書は、インシデント発生から終息までの一連のプロセスを詳細に解説するだけでなく、組織としての障害対応力向上までを包括的にカバーしています。【改訂新版】システム障害対応の教科書作者:木村 誠明技術評論社Amazon改訂新版では、チームメンバーの教育と育成、障害対応訓練、事故を防ぐ手順書の作り方、エンドユーザ向け情報発信についての新章が追加され、より実践的な内容となっています。特に、ワークブック編の追加により、理論を実践に落とし込むための具体的な手法が提供されており、新人から中堅、マネージャーまで幅広い層に価値のある内容となっています。本書の真価は、システム障害対応における役割と基本動作の明確化にあります。インシデントコマンダー、作業担当者、ユーザ担当者など、各役割の責務と行動規範が詳細に解説されています。また、必要なドキュメントやツール、環境についても具体的な説明があり、すぐに実務に活かせる実践的な知識を得ることができます。特に注目すべきは、組織の障害対応レベル向上と体制作りに関する章です。障害対応力のスキルチェックシートや訓練の実施要領など、組織として継続的に改善していくための具体的な方法論が示されています。また、生成AI技術のシステム運用への応用についても言及されており、最新の技術動向も押さえられています。Appendixでは、実際の難易度の高いシステム障害ケースが紹介されており、ビジネスロジックの障害から大規模インフラ障害、災害時の対応まで、現実的なシナリオに基づいた学びを得ることができます。これらのケーススタディは、理論と実践を結びつける貴重な教材となっています。本書は、システム運用に関わるすべての人にとって、障害対応の基本から応用まで、体系的に学べる決定版といえます。新人エンジニアの教育から、中堅エンジニアのスキル向上、マネージャーの組織運営まで、幅広いニーズに応える内容となっています。運用であればAWS運用入門も今年読んで良かった本なのであわせて紹介しておきます。AWS運用入門　押さえておきたいAWSの基本と運用ノウハウ作者:佐竹 陽一,山﨑 翔平,小倉 大,峯 侑資SBクリエイティブAmazon申し訳ありません。GitHub CI/CD実践ガイドの章は前の章とは独立して新規に追加すべきでした。改めて追加させていただきます：GitHub CI/CD実践ガイド「GitHub CI/CD実践ガイド」は、持続可能なソフトウェア開発を支えるGitHub Actionsの設計と運用について、基礎から実践、そして応用まで体系的に解説した一冊です。本書は、単なるGitHub Actionsの使い方マニュアルを超えて、現代のソフトウェア開発における継続的インテグレーションと継続的デリバリーの本質に迫っています。GitHub CI/CD実践ガイド――持続可能なソフトウェア開発を支えるGitHub Actionsの設計と運用 エンジニア選書作者:野村 友規技術評論社Amazon本書の特徴は、その構成の緻密さにあります。基礎編では、GitHub Actionsの基本概念や構文を丁寧に解説し、実践編では具体的なユースケースに基づいた実装方法を示し、応用編では高度な使い方やセキュリティ、組織としての実践方法を展開しています。この段階的なアプローチにより、読者は自然と実践的なCI/CDの知識を積み上げていくことができます。特筆すべきは、本書がセキュリティと運用の観点を強く意識している点です。GitHub Actionsの基本的な使い方だけでなく、OpenID Connectによるセキュアなクラウド連携、Dependabotによる依存関係の管理、GitHub Appsによるクロスリポジトリアクセスなど、実運用で直面する重要な課題についても深く掘り下げています。本書が提供する知見は、現代のソフトウェア開発において不可欠な継続的デリバリーの実践へと読者を導きます。組織のパフォーマンス向上からバージョン管理戦略、テスト戦略、そしてインフラストラクチャの変更管理まで、包括的な視点でCI/CDの実践方法を解説しています。私にとって本書は、日々のCI/CD運用における信頼できるリファレンスとなっています。実装時の細かな疑問から、アーキテクチャレベルの設計判断まで、様々な場面で本書の知見が活きています。GitHubを利用する開発者にとって、この本は確実に実務の質を高めてくれる一冊となるでしょう。個人的にLearning GitHub Actionsが好きだったので日本語版のような書籍がでてきてくれて嬉しいです。Learning GitHub Actions: Automation and Integration of CI/CD with GitHub (English Edition)作者:Laster, BrentO'Reilly MediaAmazonおわりに2024年、私にとって技術書との関わり方が大きく変化した1年でした。技術書に関してはこれまでのように単に量を追い求めるのではなく、一冊一冊をより深く理解することに注力しました。その過程で、技術書は単なる情報の集合体ではなく、先人たちの経験や洞察が凝縮された知恵の結晶であることを改めて実感しました。今年はプラットフォームエンジニアリング、継続的デプロイメント、オブザーバビリティ、SRE、データエンジニアリングなど、現代のソフトウェアエンジニアリングにおける重要なテーマを深く学ぶことができました。また、技術イベントでの発表や記事執筆に向けて、多くの入門書にも触れる機会があり、そこに込められた読者の理解を深めるための緻密な工夫にも感銘を受けました。特に印象深かったのは、これらの技術書に共通する「実践知の体系化」というアプローチです。例えば、『Platform Engineering』は組織的な実践知を理論化し、『システム障害対応の教科書』は現場の暗黙知を形式知へと昇華させています。また、『プログラミングRust』や『Effective Rust』といった言語関連の書籍も、単なる技術解説を超えて、設計思想や原理の本質的な理解に重点を置いています。これらの本から得た知識は、日々の業務や技術イベントでの発表を通じて実践し、さらにその経験を自分の言葉で発信することで、理解をより深めることができました。来年も引き続き、質の高い技術書との出会いを大切にし、得られた知見を実践し、コミュニティに還元していくことで、エンジニアとしての成長を続けていきたいと考えています。","isoDate":"2024-12-23T08:47:50.000Z","dateMiliSeconds":1734943670000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"初回実行が遅ければ遅延初期化でやればいいじゃない - RustのTUIアプリケーション改善","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/14/121545","contentSnippet":"この記事はRust Advent Calendar 2024 シリーズ3の15日目の記事です。はじめにみなさん、アプリケーションの初回実行の遅さに悩んでいませんか？「初回の検索が遅い...」「起動に時間がかかる...」「ユーザーから苦情が...」といった問題は、多くの開発者が直面する共通の課題です。実は、こういった問題の多くは初期化のタイミングを工夫することで効果的に解決できます。特にRustの場合、遅延初期化の仕組みを積極的に活用することで、パフォーマンスとユーザー体験を大きく改善することが可能です。初期化処理を適切なタイミングで実行することで、アプリケーションの応答性を保ちながら、必要なデータの準備を効率的に行うことができるのです。今回は郵便番号検索アプリケーション（jposta）を具体例として、初期化の最適化手法について詳しく見ていきましょう。この実践的なケーススタディを通じて、効果的な初期化戦略の実装方法を学んでいきます。github.com遅延初期化とは遅延初期化は、「必要になるまで初期化を待つ」という考え方を基本とする重要な最適化テクニックです。アプリケーションの起動時に全てのデータを一度に読み込むのではなく、そのデータが実際に使用されるタイミングまで読み込みを延期することで、システムの効率性を高めることができます。ja.wikipedia.org特に重要な利点として、アプリケーションの起動時間の大幅な短縮が挙げられます。全ての機能を一度に初期化する代わりに、必要な機能から順次初期化することで、ユーザーは最小限の待ち時間でアプリケーションの使用を開始できます。また、大きな設定ファイルの読み込みやデータベース接続の確立、重いライブラリの初期化、キャッシュの構築といったリソース集約的な操作を必要なタイミングまで延期することで、メモリやCPUなどの限られたリソースを効率的に活用することが可能となります。さらに、遅延初期化は複雑な依存関係を持つシステムにおいても効果的です。複数のコンポーネントが互いに依存し合う状況では、初期化の順序が問題となることがありますが、各コンポーネントを必要に応じて初期化することで、この課題を自然に解決できます。加えて、テスト容易性の向上も重要な利点です。必要なコンポーネントだけを初期化できることで、単体テストやモジュールテストが容易になり、テストの実行速度も向上します。また、エラーハンドリングの改善にも貢献します。初期化時のエラーを早期に検出できるだけでなく、実際に使用されないコンポーネントの初期化エラーを回避することができます。運用環境での柔軟性も高まり、システムの一部機能が利用できない状況でも、他の機能を正常に動作させることが可能になります。このように、遅延初期化は現代のソフトウェア開発において、パフォーマンス、保守性、信頼性の面で多くのメリットをもたらす重要な設計パターンとなっています。blog1.mammb.comRustにおける遅延初期化の進化Rustにおける遅延初期化の歴史は、2014年に登場したlazy_staticから始まり、これはマクロベースの実装でスレッドセーフ性に課題があり、型の制約も厳しいものでした。github.comその後、2020年にはonce_cellが登場し、マクロを必要としないシンプルなAPIとスレッドセーフな実装、より柔軟な型のサポートを提供することで、遅延初期化の実装が大きく改善されました。github.comそして2024年になると、LazyCell/LazyLockが標準ライブラリに統合され、さらなる最適化と依存関係の削減が実現され、Rustの遅延初期化機能は新たな段階へと進化を遂げています。blog.rust-lang.orgこのように、Rustの遅延初期化は時代とともに進化し、より使いやすく堅牢な実装へと発展してきました。techblog.paild.co.jp問題の理解：なぜ初期処理が必要か？まず、jpostcode_rsライブラリの実装を見てみましょう：use std::sync::LazyLock;static ADDRESS_MAP: LazyLock<HashMap<String, Vec<Address>>> = LazyLock::new(|| {    let data = include_str!(concat!(env!(\"OUT_DIR\"), \"/address_data.json\"));    let raw_map: HashMap<String, Value> =        serde_json::from_str(data).expect(\"Failed to parse raw data\");    // ...});このコードの重要なポイントは、LazyLockによる遅延初期化を採用することで、JSONデータの初回アクセス時までパースを延期し、必要なタイミングでメモリへの展開を行う設計となっているということです。このコードから分かるように、初回アクセス時のパフォーマンス低下は遅延初期化の仕組みに起因しています。そこで私たちは、この遅延初期化の特性を活用し、ユーザーが実際にアクセスする前に初期化を完了させる戦略を考案しました。解決策：遅延初期化を活用した初期処理従来の初期化パターンfn new() -> App {    let (search_tx, search_rx) = mpsc::channel::<String>();    let (result_tx, result_rx) = mpsc::channel();    thread::spawn(move || {        while let Ok(query) = search_rx.recv() {            // 初回検索時にデータ初期化が発生 = 遅い！        }    });    App { /* ... */ }}改善後：標準ライブラリの機能を活用use std::sync::{LazyLock, Mutex};// グローバルな初期化フラグstatic INITIALIZED: LazyLock<Mutex<bool>> = LazyLock::new(|| Mutex::new(false));impl App {    fn new() -> App {        let (search_tx, search_rx) = mpsc::channel::<String>();        let (result_tx, result_rx) = mpsc::channel();        thread::spawn(move || {            // バックグラウンドで初期化            {                let mut init = INITIALIZED.lock().unwrap();                if !*init {                    // 軽いクエリで事前初期化をトリガー                    let _ = lookup_addresses(\"100\");                    let _ = search_by_address(\"東京\");                    *init = true;                }            }            // 以降の検索は初期化済みのデータを使用            let mut cache: HashMap<String, Vec<String>> = HashMap::new();            while let Ok(query) = search_rx.recv() {                // 通常の検索処理            }        });        App { /* ... */ }    }}この手法の効果とメリットとデメリットこの手法の中核となる標準ライブラリのLazyLockやMutexなどの基本機能は、追加のライブラリを必要としない堅牢な実装を可能にします。既存のRustプログラマーにとって馴染みのある仕組みを使用しているため、コードの理解や保守が容易であり、依存関係も最小限に抑えることができます。また、これらの機能は既にRustチームによって最適化され、徹底的にテストされているため、高いパフォーマンスと信頼性が保証されています。システムの保守性と運用面では、初期化ロジックの集中管理により、状態管理が大幅に簡素化されます。INITIALIZEDフラグを用いた明示的な制御により、初期化状態の追跡が容易になり、デバッグ性も向上します。さらに、初期化処理をバックグラウンドスレッドで実行することで、メインスレッドのブロッキングを避け、UIの即時表示とレスポンシブな操作感を実現できます。スケーラビリティの観点からは、新機能の追加や初期化順序の制御が柔軟に行えるため、システムの成長に合わせた拡張が容易です。Mutexによる適切な同期制御により、複数スレッドからの安全なアクセスが保証され、並行処理との親和性も高くなっています。また、必要なデータの予測的な先読みとメモリ使用の最適化により、効率的なリソース管理が可能です。初期化処理のモジュール化により、新しい機能の追加時も既存コードへの影響を最小限に抑えられ、キャッシュの効果的な活用によって、大規模なアプリケーションでも高いパフォーマンスを維持できます。一方で、この手法にはいくつかの重要な課題も存在します。まず、メモリ使用量の増加が挙げられます。事前初期化アプローチでは、実際には使用されない可能性のあるデータ構造も含めて、すべてのデータをメモリに展開する必要があります。これは特にメモリリソースが限られている環境において深刻な問題となる可能性があり、システムの全体的なパフォーマンスに影響を与える可能性があります。また、起動時のリソース消費も重要な課題です。バックグラウンドでの初期化処理は、システムの起動時により多くのCPUとメモリリソースを必要とします。特にモバイルデバイスやバッテリー駆動の機器では、この追加のリソース消費が電力効率に悪影響を及ぼす可能性があります。ユーザーの使用パターンによっては、この初期化コストが実際の便益を上回ってしまう場合もあります。さらに、実装の複雑性が増加することも大きな課題です。遅延初期化と事前初期化を組み合わせることで、コードベースの複雑性が著しく増加します。特に初期化の順序や依存関係の管理が複雑になり、開発者がシステムの動作を理解し、デバッグすることが困難になる可能性があります。この複雑性は、新しい機能の追加や既存機能の修正時にも影響を及ぼし、開発効率の低下につながる可能性があります。テストの複雑化も見過ごせない問題です。バックグラウンド初期化を含むコードのテストでは、タイミングや状態管理の観点から、適切なテストケースの作成と実行が困難になります。特に並行処理に関連するバグの再現や検証が複雑になり、品質保証のプロセスに追加の負担がかかる可能性があります。最後に、エラーハンドリングの複雑化も重要な課題です。バックグラウンドでの初期化中に発生したエラーの適切な処理と、それに対するユーザーへの適切なフィードバック提供が技術的な課題となります。エラーが発生した場合の回復処理や、部分的な機能提供の実装も複雑になり、システムの信頼性と保守性に影響を与える可能性があります。このように、標準ライブラリの機能を活用した実装は多くの利点をもたらす一方で、システムの要件や制約に応じて、これらのデメリットを慎重に検討する必要があります。実装時には、これらのトレードオフを考慮しながら、適切な設計判断を行うことが重要となります。実装時の注意点デッドロックの防止{  // スコープによるロックの制限    let mut init = INITIALIZED.lock().unwrap();    if !*init {        *init = true;    }}  // ロックの自動解放初期化の冪等性if !*init {    // 複数回実行されても安全な実装に    let _ = lookup_addresses(\"100\");    *init = true;}まとめ私たちは「初回アクセスが遅いなら、事前に必要な処理を済ませておこう」というシンプルながら実用的なアプローチについて、Rustの標準ライブラリの遅延初期化機構を通じて検討してきました。この手法には、メモリ使用量の増加やコードの複雑化といった課題も存在しますが、適切に実装することで大きな効果が期待できます。標準ライブラリの機能を活用し、依存関係を最小限に抑えながら、スレッドセーフな実装を実現することで、効率的かつ安全な初期化処理が可能となります。このように、遅延初期化と事前初期化を組み合わせたアプローチは、システムの特性や要件に応じて検討すべき重要な最適化パターンの一つと言えるでしょう。参考文献The Rust Standard Library - std::sync::LazyLockThe Rust Standard Library - std::cell::LazyCellRust Performance Book","isoDate":"2024-12-14T03:15:45.000Z","dateMiliSeconds":1734146145000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Rust 再学習戦記","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/12/013950","contentSnippet":"プログラミング言語の再入門とは、未知の大地への探求というよりも、私たちが知っているはずの領域を新たな視点で見つめ直す営みです。それは初めての出会いのような激しい高揚感とは異なり、むしろ静かな再発見の過程といえるでしょう。この記事は3-shake Advent Calendar 2024 シリーズ2の12日目の記事です。はじめに2017年、私の心にRustという言語が静かに灯りを点しました。その光は、システムプログラミングの深い理解への憧れを呼び覚まし、私を導いていきました。情熱に突き動かされるように、DevOpsツールの創造から始まり、パケット解析の探究へ、そしてWebフレームワークの実装へと、私の歩みは広がっていきました。高速な実行速度と安全性という輝きに心を奪われながらも、未熟なエコシステムという現実が私たちの前に立ちはだかりました。パッケージの追従に心を砕き、破壊的な変更に耐え、そして孤独なメンテナンスの重みを感じながら、私は一時の別れを告げることを選びました。しかし2024年を迎えた今、私の目の前で世界は確かな変化を見せています。Rustの開発者満足度は非常に高い一方で、実務での採用はまだ限定的です。これは、現時点ではRustを業務で使用している開発者が比較的少なく、主に技術的な興味や言語の特徴に惹かれて自発的に選択している人が多いためかもしれません。まぁ何はともあれ、私もその魅力に惹かれた1人のエンジニア。最新のRustを探究すべく、再入門することにしました。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazonなぜ今、Rustなのか技術的な成熟Rustのエコシステムは大きく進化し、この数年で安定性が著しく向上しています。パッケージの破壊的変更は目に見えて減少し、Zero To Production In Rustをはじめとした実践的な運用ガイドの登場により、本番環境での運用ノウハウが充実してきました。さらに、日本語での技術記事や登壇資料も増え、日本語でのコミュニケーションも充実してきています。主要パッケージの品質向上と運用実績の蓄積により、開発環境全体の信頼性は大幅に高まっています。また、言語サーバーの進化やツールチェーンの充実により、開発効率も飛躍的に向上しました。実践的な機能面においても、目覚ましい進歩が見られます。エラーハンドリングの改善やWebAssemblyサポートの強化により、クロスプラットフォーム対応も一層充実しました。また、コンパイラの最適化改善による実行時オーバーヘッドの最小化や、所有権システムによるメモリ安全性の保証など、Rustの基本的な強みはさらに磨きがかかっています。特に、非同期プログラミングのエコシステムは大きく成熟し、堅牢な基盤が確立されています。また、2025年には2024 Rdition がリリースされる。SREとしての展望今後は、Rustで構築されたマイクロサービスや高性能なバックエンドサービスのためのインフラ構築や運用の機会が増えていくことが予想されます。特に、コンテナ環境でのデプロイメントやクラウドネイティブな環境でのインフラ構築において、Rustアプリケーションの特性を最大限に活かすための設計が求められるでしょう。例えば、Rustの低メモリ消費という特徴を活かしたコンテナリソースの最適化や、高速な実行速度を考慮したオートスケーリングの設計など、アプリケーションの特性に合わせたインフラストラクチャの構築が重要になってきます。また、モニタリングやログ収集といった運用基盤においても、Rustアプリケーションに適した構成を検討していく必要があるでしょう。SREとしてRustのプロダクションデプロイメントに関わる場合は、Zero To Production In Rustを参照することをお勧めします。この書籍では、Rustアプリケーションの本番環境への展開に関する実践的なガイドラインが提供されています。www.zero2prod.comRustの再入門のための学習コンテンツ再入門にあたり、Rustの最新のプラクティスやエコシステムの変化をキャッチアップするため、いくつかの資料に取り組みました。特に有用だった書籍を紹介していきます。書籍の良さは情報を俯瞰できる点にあると考えています。わからない点があればLLMに質問することができますので⋯。なお、この記事はRustの基礎知識がある方向けの再入門という観点で資料を選定しているため、完全な初学者向けの内容は含んでいません。参照したドキュメントや内容の詳細については、Xで共有しているドキュメントをご確認ください。プログラミングRust 第2版 を読んで可能な限り手を動かす会を実施します。https://t.co/rmUpbPtK9O— nwiizo (@nwiizo) 2024年11月21日   読んだ本についての定義についてはこちらを参考にしてほしいです。読んでいない本について堂々と語る方法 (ちくま学芸文庫)作者:ピエール・バイヤール,大浦康介筑摩書房Amazonまた、yuk1tydさんのドキュメントは2021年時点の情報ですが、現在も十分に有用な内容となっているためおすすめです。blog-dry.com書籍Programming Rust, 2nd EditionO'Reilly Mediaから出版されている本書は、Rustの基本的な概念から高度な機能まで包括的に解説する定番の教科書です。特に所有権やライフタイム、並行処理といったRustの特徴的な機能について、実践的な例を交えながら詳細に説明されています。本当に再入門してから何度も読んでいる。生成AIに聞くか本を読むか実際に書いていくかの三択である。Programming Rust: Fast, Safe Systems Development作者:Blandy, Jim,Orendorff, Jason,Tindall, Leonora F SO'Reilly MediaAmazon2021年の第2版では、Rust 2021 Editionに対応し、非同期プログラミングやトレイト、ジェネリクス、マクロなど、モダンなRustの重要な機能が大幅に加筆されました。特に、パフォーマンスとメモリ安全性を両立させるためのRustの機能を、システムプログラマの視点から解説している点が特徴です。再三にはなるが2024 Rdition がリリースされる。それに合わせて再び書籍が出されるのが楽しみである。3年毎にリリースがあるのは早すぎず遅すぎずちょうど嬉しい。これまでと違う学び方をしたら挫折せずにRustを学べた話 / Programming Rust techramen24conf LTでも紹介されているように、本書は体系的な学習を可能にする構成と、実践的な例示の豊富さが特徴です。特に、Rustの概念モデルを丁寧に解説している点は、言語仕様の深い理解につながります。再入門時の体系的な知識のアップデートに最適な一冊といえるでしょう。 speakerdeck.comまた、日本語の書籍も出ているので感謝すべきである。プログラミングRust 第2版作者:Jim Blandy,Jason Orendorff,Leonora F. S. TindallオライリージャパンAmazonバックエンドエンジニアを目指す人のためのRust翔泳社から出版されているこの入門書は、実践的なプロジェクトを通じてRustを学ぶアプローチを採用しています。計算クイズからTODOアプリまで、段階的に難易度を上げながら、バックエンドエンジニアに必要な技術要素をカバーしている点が特徴です。バックエンドエンジニアを目指す人のためのRust作者:安東 一慈,大西 諒,徳永 裕介,中村 謙弘,山中 雄大翔泳社Amazon本書の優れている点は、各プロジェクトを通じて特定のRustの概念を深く掘り下げる構成にあります。例えば、ポーカーゲームの実装を通じてデータ構造の理解を深め、家計簿プログラムでファイルI/Oを学び、画像処理ツールで並列処理を実践的に理解できます。また、Cargoによるパッケージ管理、ユニットテスト、リンター、フォーマッターといった実務で重要となる開発ツールの活用方法も丁寧に解説されています。特筆すべきは、エラーハンドリングやOption/Result型の扱いなど、Rustの特徴的な機能を実際のユースケースに即して学べる点です。さらに、Webアプリケーション開発からデプロイメントまでをカバーしており、現代のバックエンド開発の実践的なスキルが身につく構成となっています。ただし、この本はプログラミング言語としてのRustの入門書として優れているものの、プログラミング未経験者にはRust自体の学習難度が高いため、他の言語での開発経験がある方に特にお勧めします。体系的な構成と実践的なプロジェクトを通じた学習アプローチは、技術書の模範となる一冊といえるでしょう。www.estie.jpコミュニティと情報源Rustの再入門において、コミュニティへの参加は技術的な成長と最新動向の把握に重要な役割を果たしています。日本のRustコミュニティは活発な技術交流が行われています。Rust.TokyoRust.Tokyoは日本最大のRustカンファレンスで、年に一度開催される重要なイベントです。私は再入門直後にこのカンファレンスに参加することになり、登壇資料の準備に追われる事態となりましたが、結果的に学習のよい動機付けとなりました。カンファレンスでは、企業での採用事例や実装のベストプラクティス、パフォーマンスチューニングの知見など、実践的な内容が数多く共有されます。また、国内外のRustコミュニティのメンバーとの交流を通じて、最新のトレンドやツール、開発手法について直接学ぶ機会も得られます。Rust-jp ZulipRust-jp Zulipは、日本のRustコミュニティの中心的なコミュニケーション基盤です。SlackやDiscordと異なり、トピックベースの会話構造を持つZulipを採用することで、過去の議論や質問への回答を効率的に検索できる点が特徴です。このプラットフォームでは、初心者向けの基本的な質問から、高度な実装の相談まで、幅広いディスカッションが日本語で行われています。特に、実務での問題解決やコードレビュー、アーキテクチャの相談など、実践的な議論が活発に行われており、再入門者にとって貴重な学習リソースとなっています。学びの記録2017年の実践パケット解析の実装Webフレームワーク検証Rust関連記事一覧2024 年やったことRustでterraform plan/apply のターゲット指定を簡単にするツールを作ってみた - tfocusの仕組みと使い方退屈なことはRust Build Scripts にやらせようRustで郵便番号・住所検索TUIツールを開発した - jpostaRustによる郵便番号検索API (yubin_api) の技術解説tfocusexpjpostcode_rsおわりに2017年の経験は、今となっては貴重な財産です。言語に入門し、一度は挫折を経験しながらもプロダクトへの導入に挑戦したこと、そして結果的に撤退を選択せざるを得なかったことは、私にとって大きな学びとなりました。この貴重な経験と適切な判断へと導いてくれた当時のメンターには感謝しています。パッケージ管理の困難さ、破壊的変更への対応、そして継続的な開発の課題 - これらの経験があったからこそ、現在のRustエコシステムの進化をより深く理解できています。Rustは単なるプログラミング言語の進化を超えて、エコシステム全体として大きく成長しました。特に、かつて私が直面した課題の多くが、コミュニティの成熟とツールチェーンの進化によって解決されつつあります。実践的なユースケースの蓄積は、次世代のシステム開発における新たな可能性を示唆しています。Rust 2024エディションのリリースを控え、言語とエコシステムはさらなる進化を遂げようとしています。SREとしても、このような発展を続けるRustの動向を把握し、実践的な知識を蓄積していくことは、将来への重要な投資になると確信しています。この記事を読んでいる方々も、ぜひこの成長と進化の過程に参加してみませんか？初めての方も、かつて離れた方も、今こそRustと再会するベストなタイミングかもしれません。","isoDate":"2024-12-11T16:39:50.000Z","dateMiliSeconds":1733935190000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Rustによる郵便番号検索API (yubin_api) の技術解説","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/04/233641","contentSnippet":"こちらの記事は Rust Advent Calendar 2024 シリーズ 3 7日目の記事です！qiita.comはじめにRustを使用したWebアプリケーション開発は、高いパフォーマンスと堅牢性を両立させる方法として注目を集めています。本記事では、日本の郵便番号システムにアクセスするRESTful API「yubin_api」の実装を通じて、Rustの実践的な開発手法を解説します。workspace_2024/yubin_api at main · nwiizo/workspace_2024 · GitHubこのプロジェクトでは、axumを使用したWebサーバーの構築、非同期プログラミング（async/await）、構造化されたエラーハンドリングを実装しています。また、プロダクション環境を想定したメトリクス収集とモニタリング、型安全なAPIデザインにも焦点を当てています。ちなみに元ライブラリーの実装についてはsyumai さんの実装を全面的に参考にさせていただいております。blog.syum.ai1. プロジェクトの構成まず、Cargo.tomlの依存関係から見ていきましょう：[dependencies]# Webフレームワーク関連axum = { version = \"0.7\", features = [\"macros\"] }  # Webフレームワークtokio = { version = \"1.0\", features = [\"full\"] }   # 非同期ランタイムtower = { version = \"0.4\", features = [\"full\"] }   # HTTPサービス抽象化tower-http = { version = \"0.5\", features = [\"cors\", \"trace\", \"limit\", \"request-id\"] }# ロギングと監視tracing = \"0.1\"                # ログ出力tracing-subscriber = \"0.3\"     # ログ設定metrics = \"0.21\"              # メトリクス収集metrics-exporter-prometheus = \"0.12\"  # Prometheus形式出力# シリアライズ/デシリアライズserde = { version = \"1.0\", features = [\"derive\"] }serde_json = \"1.0\"# ユーティリティthiserror = \"1.0\"   # エラー定義uuid = { version = \"1.0\", features = [\"v4\"] }  # ユニークID生成utoipa = { version = \"4.1\", features = [\"uuid\"] }  # OpenAPI生成# 郵便番号データベースjpostcode_rs = \"0.1.3\"2. エラー処理の実装（error.rs）エラー処理は、APIの信頼性を確保する重要な部分です：use axum::{    http::StatusCode,    response::{IntoResponse, Response},    Json,};use thiserror::Error;use tracing::warn;// APIのエラー型を定義#[derive(Debug, Error)]pub enum ApiError {    #[error(\"Invalid postal code format\")]    InvalidPostalCode,    #[error(\"Address not found\")]    NotFound,    #[error(\"Internal server error: {0}\")]    Internal(String),}// エラーをHTTPレスポンスに変換する実装impl IntoResponse for ApiError {    fn into_response(self) -> Response {        // エラーの種類に応じてステータスコードを設定        let (status, error_message) = match self {            ApiError::InvalidPostalCode => (StatusCode::BAD_REQUEST, self.to_string()),            ApiError::NotFound => (StatusCode::NOT_FOUND, self.to_string()),            ApiError::Internal(ref e) => {                // 内部エラーはログに記録                warn!(\"Internal server error: {}\", e);                (                    StatusCode::INTERNAL_SERVER_ERROR,                    \"Internal server error\".to_string(),                )            }        };        // JSONレスポンスの構築        let body = Json(serde_json::json!({            \"error\": error_message,            \"status\": status.as_u16(),            // エラー追跡用のユニークID            \"request_id\": uuid::Uuid::new_v4().to_string()        }));        (status, body).into_response()    }}3. データモデルの定義（models.rs）APIで使用するデータ構造を定義します：use serde::{Deserialize, Serialize};// 住所情報のレスポンス構造体#[derive(Debug, Serialize, Deserialize, utoipa::ToSchema)]pub struct AddressResponse {    pub postal_code: String,    pub prefecture: String,    pub prefecture_kana: String,    pub prefecture_code: i32,    pub city: String,    pub city_kana: String,    pub town: String,    pub town_kana: String,    pub street: Option<String>,    pub office_name: Option<String>,    pub office_name_kana: Option<String>,}// jpostcode_rsのAddress型からの変換を実装impl From<jpostcode_rs::Address> for AddressResponse {    fn from(addr: jpostcode_rs::Address) -> Self {        AddressResponse {            postal_code: addr.postcode,            prefecture: addr.prefecture,            prefecture_kana: addr.prefecture_kana,            prefecture_code: addr.prefecture_code,            city: addr.city,            city_kana: addr.city_kana,            town: addr.town,            town_kana: addr.town_kana,            street: addr.street,            office_name: addr.office_name,            office_name_kana: addr.office_name_kana,        }    }}// 住所検索用のクエリ構造体#[derive(Debug, Deserialize, utoipa::ToSchema)]pub struct AddressQuery {    pub query: String,    #[serde(default = \"default_limit\")]    pub limit: usize,}// デフォルトの検索結果制限数fn default_limit() -> usize {    10}4. メトリクス収集の設定（metrics.rs）アプリケーションのパフォーマンスを監視するためのメトリクス設定：use metrics::{describe_counter, describe_histogram, register_counter, register_histogram};use metrics_exporter_prometheus::PrometheusBuilder;pub fn setup_metrics() {    // リクエスト数のカウンター    describe_counter!(        \"yubin_api_postal_lookups_total\",        \"Total number of postal code lookups\"    );    describe_counter!(        \"yubin_api_address_searches_total\",        \"Total number of address searches\"    );    // レスポンス時間のヒストグラム    describe_histogram!(        \"yubin_api_postal_lookup_duration_seconds\",        \"Duration of postal code lookups in seconds\"    );    describe_histogram!(        \"yubin_api_address_search_duration_seconds\",        \"Duration of address searches in seconds\"    );    // メトリクスの登録    register_counter!(\"yubin_api_postal_lookups_total\");    register_counter!(\"yubin_api_address_searches_total\");    register_histogram!(\"yubin_api_postal_lookup_duration_seconds\");    register_histogram!(\"yubin_api_address_search_duration_seconds\");    // Prometheusレコーダーの設定    PrometheusBuilder::new()        .install()        .expect(\"Failed to install Prometheus recorder\");}Rustの知っておいたほうがいいポイント解説(前編)属性マクロの使用#[derive(...)]: 自動実装の導入#[error(...)]: エラーメッセージの定義#[serde(...)]: シリアライズ設定トレイトの実装From<T>: 型変換の実装IntoResponse: HTTPレスポンスへの変換Error: カスタムエラー型の定義ジェネリクスとライフタイムOption<T>: 省略可能な値の表現Result<T, E>: エラーハンドリングVec<T>: 可変長配列の使用型システムの活用カスタム構造体の定義列挙型によるエラー表現デフォルト値の実装Rust初学者のためのyubin_api実装解説 - 後編5. APIルートの実装（routes.rs）APIの実際のエンドポイントを実装します：use axum::{extract::Path, http::StatusCode, response::IntoResponse, Json};use metrics::{counter, histogram};use tracing::info;// ヘルスチェックエンドポイントpub async fn health_check() -> impl IntoResponse {    StatusCode::OK}// 郵便番号検索エンドポイントpub async fn lookup_by_postal_code(    Path(code): Path<String>,  // URLパスからパラメータを取得) -> Result<Json<Vec<AddressResponse>>, ApiError> {    // リクエストのログ記録    info!(\"Looking up postal code: {}\", code);        // メトリクスのカウントアップ    counter!(\"yubin_api_postal_lookups_total\", 1);        // 処理時間の計測開始    let start = std::time::Instant::now();    // 郵便番号検索の実行    let result = jpostcode_rs::lookup_address(&code).map_err(|e| match e {        jpostcode_rs::JPostError::InvalidFormat => ApiError::InvalidPostalCode,        jpostcode_rs::JPostError::NotFound => ApiError::NotFound,    })?;    // 処理時間の計測と記録    let duration = start.elapsed().as_secs_f64();    histogram!(\"yubin_api_postal_lookup_duration_seconds\", duration);    // 結果の返却    Ok(Json(result.into_iter().map(Into::into).collect()))}// 住所検索エンドポイントpub async fn search_by_address(    Json(query): Json<AddressQuery>,  // リクエストボディからのJSONパース) -> Result<Json<Vec<AddressResponse>>, ApiError> {    info!(\"Searching address with query: {}\", query.query);        // 入力値の検証    if query.query.trim().is_empty() {        return Err(ApiError::InvalidPostalCode);    }    counter!(\"yubin_api_address_searches_total\", 1);    let start = std::time::Instant::now();    // 住所検索の実行    let mut results: Vec<AddressResponse> = jpostcode_rs::search_by_address(&query.query)        .into_iter()        .map(Into::into)        .collect();    // 結果数の制限適用    results.truncate(query.limit);    let duration = start.elapsed().as_secs_f64();    histogram!(\"yubin_api_address_search_duration_seconds\", duration);    Ok(Json(results))}6. メインアプリケーションの実装（main.rs）アプリケーションのエントリーポイントとサーバーの設定：use axum::{routing::{get, post}, Router};use std::net::SocketAddr;use tower::ServiceBuilder;use tower_http::{    cors::{Any, CorsLayer},    trace::{DefaultMakeSpan, DefaultOnResponse, TraceLayer},};use tracing::info;#[tokio::main]async fn main() {    // ロギングの初期化    tracing_subscriber::fmt()        .with_env_filter(            tracing_subscriber::EnvFilter::try_from_default_env()                .unwrap_or_else(|_| \"yubin_api=debug,tower_http=debug\".into()),        )        .init();    // メトリクス収集の初期化    setup_metrics();    // リクエストトレース設定    let trace_layer = TraceLayer::new_for_http()        .make_span_with(DefaultMakeSpan::new().include_headers(true))        .on_response(DefaultOnResponse::new().include_headers(true));    // CORS設定    let cors = CorsLayer::new()        .allow_methods(Any)        .allow_headers(Any)        .allow_origin(Any);    // ルーターの設定    let app = Router::new()        .route(\"/health\", get(health_check))        .route(\"/postal/:code\", get(lookup_by_postal_code))        .route(\"/address/search\", post(search_by_address))        .layer(ServiceBuilder::new()            .layer(trace_layer)            .layer(cors));    // サーバーアドレスの設定    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));    info!(\"Server listening on {}\", addr);    // サーバーの起動    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();    axum::serve(listener, app).await.unwrap();}7. 重要な実装パターンの解説非同期処理// 非同期関数の定義pub async fn lookup_by_postal_code(...) -> Result<...> {    // 非同期処理の実行    let result = jpostcode_rs::lookup_address(&code)?;    // ...}// 非同期ランタイムの設定#[tokio::main]async fn main() {    // ...}エラーハンドリング// Result型を使用したエラー処理let result = jpostcode_rs::lookup_address(&code).map_err(|e| match e {    JPostError::InvalidFormat => ApiError::InvalidPostalCode,    JPostError::NotFound => ApiError::NotFound,})?;ミドルウェアの構成let app = Router::new()    .route(...)    .layer(ServiceBuilder::new()        .layer(trace_layer)        .layer(cors));8. API使用例郵便番号による検索curl http://localhost:3000/postal/1000001レスポンス例：[  {    \"postal_code\": \"1000001\",    \"prefecture\": \"東京都\",    \"city\": \"千代田区\",    \"town\": \"千代田\",    ...  }]住所による検索curl -X POST http://localhost:3000/address/search \\  -H \"Content-Type: application/json\" \\  -d '{\"query\": \"東京都千代田区\", \"limit\": 10}'9. Rustの知っておいたほうがいいポイント解説(後編)非同期プログラミングasync/awaitの使用方法tokioランタイムの理解非同期関数の定義と呼び出しエラーハンドリングパターンResult型の活用エラー変換のベストプラクティスエラーの伝播（?演算子）HTTPサーバーの実装ルーティング設定ミドルウェアの活用リクエスト/レスポンスの処理テスト可能な設計モジュール分割依存性の分離エラー処理の一貫性おわりにyubin_apiの実装を通じて、Rustによる実践的なWeb API開発の全体像を見てきました。このプロジェクトでは、カスタムエラー型の定義や型安全なデータ変換、トレイトの実装といった堅牢な型システムの活用を行いました。また、tokioによる非同期ランタイムやasync/awaitの効果的な使用、エラーハンドリングとの統合などの非同期プログラミングの実践も重要な要素となっています。さらに、メトリクス収集や構造化ログ、エラートラッキングといった運用面の考慮など、重要な概念と技術を学ぶことができました。このプロジェクトは、単なる郵便番号検索APIの実装を超えて、Rustの実践的な使用方法と、プロダクション品質のWebサービス開発の基本を学ぶ良い例となっています。","isoDate":"2024-12-04T14:36:41.000Z","dateMiliSeconds":1733323001000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Rustで郵便番号・住所検索TUIツールを開発した - jposta","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/03/230030","contentSnippet":"こちらの記事は Rust Advent Calendar 2024 シリーズ 3 5日目の記事です！qiita.comはじめにこんにちは！jposta を紹介させてください。jpostaは、日本の郵便番号・住所をターミナルから手軽に検索できるTUIツール 🔍 です。Rustで書かれており ⚡、使いやすさを重視してリアルタイム検索を実装しました 🖥️。jposta の動作イメージ元ライブラリーの実装についてはsyumai さんの実装を全面的に参考にさせていただいております。美しい実装すぎて震えました。blog.syum.ai機能紹介この小さなツールでは、郵便番号から住所の簡単検索 🏠 はもちろん、住所からの郵便番号検索 🔢 もラクラクできます。入力しながらサクサク表示されるリアルタイム検索 ⚡ や、キーボードだけでスイスイ操作 ⌨️ が可能で、スクロールもサクサク動き 📜、もちろん日本語もバッチリ対応 🗾 しています。ぜひGitHubをチェックしてみてください！github.comインストールcargo install --git https://github.com/nwiizo/jpostaもしくはcargo install jpostaこちら、みんなだいすきcrate.ioにちゃんとあげました。https://crates.io/crates/jposta基本操作Tab: 郵便番号/住所検索モード切替↑↓: 結果スクロールEsc: 終了検索モード郵便番号検索数字を入力すると自動で該当する住所を表示部分一致対応（\"100\"で始まる郵便番号すべて等）住所検索漢字やかなで住所を入力部分一致対応（\"渋谷\"等）Rustでの実装解説1. 基本構造の定義#[derive(Clone)]enum InputMode {    Postal,   // 郵便番号検索    Address,  // 住所検索}struct App {    input: String,    results: Vec<String>,    input_mode: InputMode,    scroll_state: ScrollbarState,    scroll_position: u16,    search_tx: mpsc::Sender<String>,    result_rx: mpsc::Receiver<Vec<String>>,}InputModeは検索モードを表す列挙型です。Cloneトレイトを導出することで、値のコピーが可能になります。App構造体はアプリケーションの状態を管理します。input: 現在の入力文字列results: 検索結果の配列input_mode: 現在の検索モードscroll_stateとscroll_position: スクロール状態の管理search_txとresult_rx: スレッド間通信用のチャンネル2. アプリケーションの初期化impl App {    fn new() -> App {        let (search_tx, search_rx) = mpsc::channel::<String>();        let (result_tx, result_rx) = mpsc::channel();        thread::spawn(move || {            let mut last_query = String::new();            let mut input_mode = InputMode::Postal;                        while let Ok(query) = search_rx.recv() {                // 検索処理（後述）            }        });        App {            input: String::new(),            results: Vec::new(),            input_mode: InputMode::Postal,            scroll_state: ScrollbarState::default(),            scroll_position: 0,            search_tx,            result_rx,        }    }}new()関数では、2つのチャンネルを作成（検索クエリ用と結果用）検索処理を行うワーカースレッドを起動初期状態のAppインスタンスを返す3. 検索処理の実装// 検索スレッド内の処理if query.starts_with(\"MODE_CHANGE:\") {    input_mode = match &query[11..] {        \"postal\" => InputMode::Postal,        _ => InputMode::Address,    };    continue;}if query == last_query { continue; }last_query = query.clone();if query.is_empty() {    let _ = result_tx.send(Vec::new());    continue;}thread::sleep(Duration::from_millis(100));let results = match input_mode {    InputMode::Postal => lookup_addresses(&query)        .map(|addresses| {            addresses                .into_iter()                .map(|addr| addr.formatted_with_kana())                .collect()        })        .unwrap_or_default(),    InputMode::Address => search_by_address(&query)        .into_iter()        .map(|addr| addr.formatted_with_kana())        .collect(),};let _ = result_tx.send(results);検索処理では、モード変更メッセージの確認と処理重複クエリのスキップ空クエリの即時処理ディバウンス処理（100ms）モードに応じた検索実行結果の送信4. UIとイベント処理fn main() -> io::Result<()> {    enable_raw_mode()?;    let mut stdout = stdout();    execute!(stdout, EnterAlternateScreen)?;    let backend = CrosstermBackend::new(stdout);    let mut terminal = Terminal::new(backend)?;    let mut app = App::new();    loop {        app.check_results();        terminal.draw(|f| {            let chunks = Layout::default()                .direction(Direction::Vertical)                .constraints([                    Constraint::Length(3),                    Constraint::Min(0)                ])                .split(f.size());            // 入力欄の描画            let input_block = Block::default()                .title(match app.input_mode {                    InputMode::Postal => \"郵便番号検索\",                    InputMode::Address => \"住所検索\",                })                .borders(Borders::ALL);                        let input = Paragraph::new(app.input.as_str())                .block(input_block)                .style(Style::default().fg(Color::Yellow));            f.render_widget(input, chunks[0]);            // 結果表示の描画            let results_block = Block::default()                .title(format!(\"検索結果 ({} 件)\", app.results.len()))                .borders(Borders::ALL);                        let results = Paragraph::new(app.results.join(\"\\n\"))                .block(results_block)                .scroll((app.scroll_position, 0));            f.render_widget(results, chunks[1]);        })?;        // キー入力処理        if let Event::Key(key) = event::read()? {            match key.code {                KeyCode::Char(c) => {                    app.input.push(c);                    app.search();                }                KeyCode::Backspace => {                    app.input.pop();                    app.search();                }                KeyCode::Up => app.scroll_up(),                KeyCode::Down => app.scroll_down(),                KeyCode::Tab => app.change_mode(match app.input_mode {                    InputMode::Postal => InputMode::Address,                    InputMode::Address => InputMode::Postal,                }),                KeyCode::Esc => break,                _ => {}            }        }    }    // 終了処理    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;    disable_raw_mode()?;    Ok(())}UIとイベント処理では、ターミナルの初期化メインループ検索結果の確認画面描画キー入力処理終了時のクリーンアップ5. 補助機能の実装impl App {    fn search(&mut self) {        let _ = self.search_tx.send(self.input.clone());    }    fn check_results(&mut self) {        if let Ok(new_results) = self.result_rx.try_recv() {            self.results = new_results;            self.scroll_position = 0;            self.scroll_state = ScrollbarState::new(self.results.len());        }    }    fn scroll_up(&mut self) {        self.scroll_position = self.scroll_position.saturating_sub(1);    }    fn scroll_down(&mut self) {        if !self.results.is_empty() {            self.scroll_position = self                .scroll_position                .saturating_add(1)                .min((self.results.len() as u16).saturating_sub(1));        }    }    fn change_mode(&mut self, mode: InputMode) {        self.input_mode = mode;        let mode_str = match self.input_mode {            InputMode::Postal => \"postal\",            InputMode::Address => \"address\",        };        let _ = self.search_tx.send(format!(\"MODE_CHANGE:{}\", mode_str));        self.input.clear();        self.results.clear();    }}補助機能として、1. 検索リクエストの送信2. 検索結果の確認と更新3. スクロール処理4. モード切替処理これらの機能により、スムーズな検索体験を実現しています。使用ライブラリratatui: TUI（テキストユーザーインターフェース）フレームワークcrossterm: ターミナル操作ライブラリjpostcode_rs: 郵便番号データ処理ライブラリRust学習リソース1. 基礎学習The Rust Programming Language - 公式ガイドブックRust by Example - 実例で学ぶRustRustlings - 対話型学習ツール2. 基本概念構造体（Structs）列挙型（Enums）メソッド実装3. メモリ管理所有権システム参照と借用4. 言語機能パターンマッチングクロージャ5. エラー処理と型システムエラー処理Result型境界チェック演算子さいごにこのプロジェクトは、Rustの実践的な学習と日本の住所システムへの理解を深める良い機会となりました 📚。非同期処理やTUIの実装を通じて、Rustの強力な型システムと安全性を活かしたコーディングを実践できました ⚡。ぜひ使ってみて、フィードバックをいただければ幸いです 🙏。プルリクエストも大歓迎です 🎉！ソースコード🦀GitHub - jposta","isoDate":"2024-12-03T14:00:30.000Z","dateMiliSeconds":1733234430000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"退屈なことはRust Build Scripts にやらせよう","link":"https://syu-m-5151.hatenablog.com/entry/2024/12/03/143149","contentSnippet":"こちらの記事は Rust Advent Calendar 2024 シリーズ 3 3日目の記事です！qiita.comはじめにRustのビルドスクリプト（build.rs）は、コンパイル前のデータ処理や環境設定を自動化する強力なツールです。しかし、大いなる力には、大いなる責任が伴います。コードの生成、リソースの最適化、プラットフォーム固有の設定管理など、ビルド時の様々なタスクを効率的に処理できます。今回は、そのユースケースの1つとして、郵便番号データを処理するビルドスクリプトの実装を詳しく解説します。この例を通じて、build.rsの基本的な使い方から実践的な活用方法まで、段階的に理解を深めていきましょう。doc.rust-lang.orgはじめにユースケース：郵便番号データの処理実装の全体像実装の詳細解説1. ファイル変更の監視設定2. パスの設定3. データの処理4. 結果の出力生成したデータの利用方法1. アプリケーションでのデータ読み込み2. 検索機能の実装build.rsの主要な機能1. 環境変数の設定2. リンカ設定3. コードの生成実践的な利用シーン1. 設定ファイルの統合と生成2. プロトコル定義ファイルの生成3. アセットファイルの埋め込み4. データベースマイグレーションファイルの統合参考資料まとめユースケース：郵便番号データの処理このビルドスクリプトは、複数のJSONファイルに分散された郵便番号データを1つのファイルにマージする処理を行います。github.com実装の全体像use serde_json::Value;use std::collections::HashMap;use std::fs;use std::path::Path;use walkdir::WalkDir;fn main() {    println!(\"cargo:rerun-if-changed=jpostcode-data/data/json\");    let json_dir = Path::new(\"jpostcode-data/data/json\");    let out_dir = std::env::var(\"OUT_DIR\").unwrap();    let dest_path = Path::new(&out_dir).join(\"address_data.json\");    let mut merged_data = HashMap::new();    // ... データ処理ロジック ...}実装の詳細解説1. ファイル変更の監視設定println!(\"cargo:rerun-if-changed=jpostcode-data/data/json\");この行は、指定したディレクトリ内のファイルが変更された場合にのみビルドスクリプトを再実行するように設定します。これにより、不必要なビルド時間を削減できます。2. パスの設定let json_dir = Path::new(\"jpostcode-data/data/json\");let out_dir = std::env::var(\"OUT_DIR\").unwrap();let dest_path = Path::new(&out_dir).join(\"address_data.json\");json_dir: 入力となるJSONファイルが格納されているディレクトリout_dir: Cargoが提供するビルド出力ディレクトリdest_path: 生成されるファイルの出力先3. データの処理for entry in WalkDir::new(json_dir).into_iter().filter_map(|e| e.ok()) {    if entry.file_type().is_file()        && entry.path().extension().map_or(false, |ext| ext == \"json\")    {        let content = fs::read_to_string(entry.path()).unwrap();        let file_data: HashMap<String, Value> = serde_json::from_str(&content).unwrap();        let prefix = entry.path().file_stem().unwrap().to_str().unwrap();        for (suffix, data) in file_data {            let full_postcode = format!(\"{}{}\", prefix, suffix);            merged_data.insert(full_postcode, data);        }    }}このコードブロックでは以下の処理を行っています。WalkDirを使用してディレクトリを再帰的に走査JSONファイルのみを対象にフィルタリング各ファイルの内容を読み込みとパースファイル名とデータを組み合わせて完全な郵便番号を生成マージされたデータに追加4. 結果の出力fs::write(dest_path, serde_json::to_string(&merged_data).unwrap()).unwrap();処理したデータを1つのJSONファイルとして出力します。生成したデータの利用方法1. アプリケーションでのデータ読み込みuse once_cell::sync::Lazy;use serde::{Deserialize, Serialize};use std::collections::HashMap;#[derive(Debug, Serialize, Deserialize)]struct Address {    postcode: String,    prefecture: String,    city: String,    // ... 他のフィールド}static ADDRESS_MAP: Lazy<HashMap<String, Vec<Address>>> = Lazy::new(|| {    let data = include_str!(concat!(env!(\"OUT_DIR\"), \"/address_data.json\"));    serde_json::from_str(data).expect(\"Failed to parse address data\")});2. 検索機能の実装fn lookup_address(postal_code: &str) -> Option<&Vec<Address>> {    ADDRESS_MAP.get(postal_code)}fn search_by_prefecture(prefecture: &str) -> Vec<&Address> {    ADDRESS_MAP        .values()        .flat_map(|addresses| addresses.iter())        .filter(|addr| addr.prefecture == prefecture)        .collect()}build.rsの主要な機能1. 環境変数の設定// コンパイル時の条件設定println!(\"cargo:rustc-cfg=feature=\\\"custom_feature\\\"\");// 環境変数の設定println!(\"cargo:rustc-env=APP_VERSION=1.0.0\");2. リンカ設定// 外部ライブラリのリンクprintln!(\"cargo:rustc-link-lib=sqlite3\");println!(\"cargo:rustc-link-search=native=/usr/local/lib\");3. コードの生成// バージョン情報の生成let version_code = format!(    \"pub const VERSION: &str = \\\"{}\\\";\\n\",    env!(\"CARGO_PKG_VERSION\"));fs::write(\"version.rs\", version_code)?;実践的な利用シーン1. 設定ファイルの統合と生成複数の環境向けの設定ファイルを1つに統合する例：use std::collections::HashMap;use serde_json::Value;fn main() {    println!(\"cargo:rerun-if-changed=config/\");        let environments = [\"development\", \"staging\", \"production\"];    let mut merged_config = HashMap::new();        for env in environments {        let config_path = format!(\"config/{}.json\", env);        let config_content = std::fs::read_to_string(&config_path).unwrap();        let config: Value = serde_json::from_str(&config_content).unwrap();                merged_config.insert(env, config);    }        let out_dir = std::env::var(\"OUT_DIR\").unwrap();    let dest_path = Path::new(&out_dir).join(\"config.rs\");        // 設定をRustのコードとして出力    let config_code = format!(        \"pub static CONFIG: Lazy<HashMap<&str, Value>> = Lazy::new(|| {{            serde_json::from_str({}).unwrap()        }});\",        serde_json::to_string(&merged_config).unwrap()    );        std::fs::write(dest_path, config_code).unwrap();}使用例：// main.rsuse once_cell::sync::Lazy;include!(concat!(env!(\"OUT_DIR\"), \"/config.rs\"));fn get_database_url(env: &str) -> String {    CONFIG[env][\"database\"][\"url\"].as_str().unwrap().to_string()}2. プロトコル定義ファイルの生成Protocol Buffersの定義ファイルからRustコードを生成する例：use std::process::Command;fn main() {    println!(\"cargo:rerun-if-changed=proto/\");        // protoファイルのコンパイル    let status = Command::new(\"protoc\")        .args(&[            \"--rust_out=src/generated\",            \"--proto_path=proto\",            \"service.proto\"        ])        .status()        .unwrap();            if !status.success() {        panic!(\"Failed to compile proto files\");    }        // 生成されたコードをモジュールとして登録    let mod_content = r#\"        pub mod generated {            include!(\"generated/service.rs\");        }    \"#;        std::fs::write(\"src/proto_mod.rs\", mod_content).unwrap();}使用例：// lib.rsmod proto_mod;use proto_mod::generated::{UserRequest, UserResponse};pub async fn handle_user_request(req: UserRequest) -> UserResponse {    // プロトコル定義に基づいた処理}3. アセットファイルの埋め込み画像やテキストファイルをバイナリに埋め込む例：use std::collections::HashMap;use base64;fn main() {    println!(\"cargo:rerun-if-changed=assets/\");        let mut assets = HashMap::new();        // 画像ファイルの埋め込み    for entry in std::fs::read_dir(\"assets\").unwrap() {        let entry = entry.unwrap();        let path = entry.path();                if path.extension().map_or(false, |ext| ext == \"png\" || ext == \"jpg\") {            let content = std::fs::read(&path).unwrap();            let encoded = base64::encode(&content);                        let asset_name = path.file_name().unwrap().to_str().unwrap();            assets.insert(asset_name.to_string(), encoded);        }    }        // アセットデータをRustコードとして出力    let out_dir = std::env::var(\"OUT_DIR\").unwrap();    let dest_path = Path::new(&out_dir).join(\"assets.rs\");        let assets_code = format!(        \"pub static ASSETS: Lazy<HashMap<String, String>> = Lazy::new(|| {{            let mut m = HashMap::new();            {}            m        }});\",        assets.iter().map(|(k, v)| {            format!(\"m.insert(\\\"{}\\\".to_string(), \\\"{}\\\".to_string());\", k, v)        }).collect::<Vec<_>>().join(\"\\n\")    );        std::fs::write(dest_path, assets_code).unwrap();}使用例：// lib.rsuse once_cell::sync::Lazy;include!(concat!(env!(\"OUT_DIR\"), \"/assets.rs\"));pub fn get_image_data(name: &str) -> Option<Vec<u8>> {    ASSETS.get(name)        .map(|encoded| base64::decode(encoded).unwrap())}4. データベースマイグレーションファイルの統合SQLマイグレーションファイルを1つのモジュールにまとめる例：fn main() {    println!(\"cargo:rerun-if-changed=migrations/\");        let mut migrations = Vec::new();        // マイグレーションファイルの収集    for entry in std::fs::read_dir(\"migrations\").unwrap() {        let entry = entry.unwrap();        let path = entry.path();                if path.extension().map_or(false, |ext| ext == \"sql\") {            let version = path.file_stem().unwrap().to_str().unwrap()                .split('_').next().unwrap();            let content = std::fs::read_to_string(&path).unwrap();                        migrations.push((version.to_string(), content));        }    }        // マイグレーションをRustコードとして出力    let migrations_code = format!(        \"pub static MIGRATIONS: &[(&str, &str)] = &[{}];\",        migrations.iter()            .map(|(ver, sql)| format!(\"(\\\"{}\\\", \\\"{}\\\")\", ver, sql.replace(\"\\\"\", \"\\\\\\\"\")))            .collect::<Vec<_>>()            .join(\",\\n\")    );        let out_dir = std::env::var(\"OUT_DIR\").unwrap();    let dest_path = Path::new(&out_dir).join(\"migrations.rs\");    std::fs::write(dest_path, migrations_code).unwrap();}使用例：// database.rsinclude!(concat!(env!(\"OUT_DIR\"), \"/migrations.rs\"));pub async fn run_migrations(db: &SqlitePool) -> Result<()> {    for (version, sql) in MIGRATIONS {        db.execute(sql).await?;        println!(\"Applied migration version {}\", version);    }    Ok(())}これらの例は、build.rsの実践的な使用方法を示しています。各例で以下のような利点があります。コンパイル時のリソース最適化開発時の利便性向上ランタイムパフォーマンスの改善コードの保守性向上実際のプロジェクトでは、これらの手法を組み合わせたり、プロジェクトの要件に合わせてカスタマイズしたりすることで、より効率的な開発環境を構築できます。しかし、魔環境もしくはビルド地獄を顕現させることもできるので注意が必要だと思いました。参考資料The Cargo Book - Build ScriptsRust By Example - Build Scriptsまとめこのビルドスクリプトの実装例を通じて、build.rsの有用性が明確になりました。コンパイル時のデータ最適化や複数ファイルの統合処理、動的なコード生成、そしてプラットフォーム固有の設定管理など、多岐にわたる機能を提供します。実際のプロジェクトでは、これらの機能を組み合わせることで、効率的な開発環境とビルドプロセスを実現できます。build.rsを活用することで、コンパイル時に必要なリソースの最適化や設定の自動化が可能となり、開発効率の向上とコードの保守性改善に大きく貢献します。","isoDate":"2024-12-03T05:31:49.000Z","dateMiliSeconds":1733203909000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"3-shake Advent Calendar 2024 やっていきます #3SHAKE","link":"https://syu-m-5151.hatenablog.com/entry/2024/11/30/142710","contentSnippet":"こんにちは、nwiizoです。晩秋の肌寒さが身にしみるこの11月も今日で終わりですね。ついこの前、昨年のAdvent Calendarで記事埋めを依頼され、慌ただしく準備した記憶が鮮明です。まったく、時の流れとは不思議なものです。今年もスリーシェイクのAdvent Calendarを開催することができます。この企画が実現したのは、ひとえに社内の方々の温かいご協力の賜物であり、その事実に深い感謝の念を抱いております。qiita.comスリーシェイクは「インフラをシンプルにしてイノベーションを起こす」というビジョンのもと、クラウド、セキュリティ、データ連携、HR領域で4つのサービスを展開しているテクノロジーカンパニーです。3-shake.com先日、シリーズB追加ラウンドとしてNTTデータ、SCSKから10億円の資金調達を実施し、資本業務提携を締結するニュースが出るなど、着実に成長を続けています。prtimes.jp今年のAdvent Calendarでも、エンジニアの技術的な記事だけでなく、スリーシェイクで働く様々な職種のメンバーによる記事をお届けする予定です。エンジニア以外にも営業、カスタマーサクセス、広報、経営企画など、多様なバックグラウンドを持つメンバーたちが、それぞれの視点からスリーシェイクでの経験や日々の発見を共有していきます。なぜ技術的な記事に限定しないのか。それは、私たちが目指すイノベーションには、技術だけでなく、様々な専門性や視点が必要だと考えているからです。このAdvent Calendarを通じて、スリーシェイクがどのような会社で、どんな人たちが働いているのか、より深く知っていただければ幸いです。記事の更新情報は、スリーシェイクの公式Xアカウント（@3shake_Inc）でお知らせしていきますので、ぜひフォローをお願いします！また、Advent Calendarも合わせてチェックしていただければと思います。成長を続けるスリーシェイクの「今」を知るきっかけとして、どうぞお楽しみください！jobs-3-shake.com","isoDate":"2024-11-30T05:27:10.000Z","dateMiliSeconds":1732944430000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"メインテーマはKubernetes","link":"https://speakerdeck.com/nwiizo/meintemahakubernetes","contentSnippet":"2024年16:20-17:00（Track A）にて「メインテーマはKubernetes」というタイトルで登壇します。\r\rイベント名: Cloud Native Days Winter 2024\r\r公式URL:https://event.cloudnativedays.jp/cndw2024/\r\rセッションURL:https://event.cloudnativedays.jp/cndw2024/talks/2373","isoDate":"2024-11-28T05:00:00.000Z","dateMiliSeconds":1732770000000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Neovimのイベントタイミングガイド","link":"https://syu-m-5151.hatenablog.com/entry/2024/11/27/023303","contentSnippet":"はじめにNeovimでの設定やプラグイン開発において、適切なタイミングでコードを実行することは非常に重要です。このガイドでは、Neovimの主要なイベントについて、実用的な例を交えながら解説します。1. 起動時のイベント系統Neovimの起動プロセスで最も重要なイベントはVimEnterです。これは全ての初期化処理（vimrcの読み込み、プラグインの初期化など）が完了した後に発火します：vim.api.nvim_create_autocmd(\"VimEnter\", {  callback = function()    -- プラグインの初期化    -- カラースキームの設定    -- ステータスラインの設定など  end,})2. バッファ操作のイベント系統バッファの作成から読み込みまでの主要なイベント：BufNew: バッファ作成直後BufAdd: バッファリストへの追加時BufReadPre: ファイル読み込み前BufReadPost: ファイル読み込み後BufEnter: バッファアクティブ化時vim.api.nvim_create_autocmd(\"BufReadPost\", {  pattern = \"*\",  callback = function()    -- ファイル読み込み後の処理    -- 最後のカーソル位置の復元など  end,})3. 編集モードのイベント系統テキスト編集に関連する主要なイベント：InsertEnter: 挿入モード開始時TextChangedI: 挿入モードでテキスト変更時InsertLeave: 挿入モード終了時TextChanged: ノーマルモードでテキスト変更時vim.api.nvim_create_autocmd(\"InsertEnter\", {  pattern = \"*\",  callback = function()    -- 挿入モード開始時の設定    -- 相対行番号の無効化など  end,})4. ファイル保存のイベント系統ファイル保存時の処理フロー：BufWritePre: 保存前BufWrite: 保存処理中BufWritePost: 保存後vim.api.nvim_create_autocmd(\"BufWritePre\", {  pattern = \"*\",  callback = function()    -- 保存前の自動整形    -- 末尾の空白除去など  end,})5. 終了時のイベント系統Neovim終了時の処理順序：QuitPre: 終了コマンド実行時VimLeavePre: 終了処理開始前VimLeave: 最終終了処理時vim.api.nvim_create_autocmd(\"VimLeavePre\", {  callback = function()    -- セッション保存    -- 未保存バッファの保存など  end,})実践的なサンプルコード以下は、よくある設定パターンの例です：-- ファイルタイプ別の設定vim.api.nvim_create_autocmd(\"FileType\", {  pattern = {\"python\", \"lua\", \"rust\"},  callback = function()    local settings = {      python = { indent = 4, expandtab = true },      lua = { indent = 2, expandtab = true },      rust = { indent = 4, expandtab = true }    }    local ft = vim.bo.filetype    if settings[ft] then      vim.bo.shiftwidth = settings[ft].indent      vim.bo.expandtab = settings[ft].expandtab    end  end,})-- 自動保存の設定vim.api.nvim_create_autocmd({\"InsertLeave\", \"TextChanged\"}, {  pattern = \"*\",  callback = function()    if vim.bo.modified and vim.bo.buftype == \"\" then      vim.cmd(\"silent! write\")    end  end,})-- 最後のカーソル位置を復元vim.api.nvim_create_autocmd(\"BufReadPost\", {  pattern = \"*\",  callback = function()    local last_pos = vim.fn.line(\"'\\\"\")    if last_pos > 0 and last_pos <= vim.fn.line(\"$\") then      vim.cmd('normal! g`\"')    end  end,})注意点イベントは適切な順序で処理される必要があります重い処理は非同期で行うことを推奨しますパターンマッチングを活用して、必要なファイルタイプのみで実行するようにしますvim.schedule()を使用して、UIブロッキングを避けます参考文献Neovim オートコマンドドキュメントAutocmd | 5. eventsNeovim Lua API リファレンスnvim_create_autocmd())","isoDate":"2024-11-26T17:33:03.000Z","dateMiliSeconds":1732642383000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Rustでterraform plan/apply のターゲット指定を簡単にするツールを作ってみた - tfocusの仕組みと使い方","link":"https://syu-m-5151.hatenablog.com/entry/2024/11/27/004309","contentSnippet":"1. はじめにこんにちは、nwiizoです。本記事では、Terraformで特定のリソースだけをplan/applyするためのインタラクティブCLIツール「tfocus」の設計と実装について、Rustの学習という観点も交えながら詳しく解説していきます。github.comまた、良さそうであればGithub Starsをいただきたいです。2. 背景と動機2.1 開発の契機大規模なTerraformコードベースでの作業において、様々な課題に直面することがあります。本番環境で特定リソースにトラブルが発生した際の調査や、開発中の変更を検証する場合、また大規模な変更を段階的に適用する必要がある場合などが典型的な例です。従来のTerraform CLIでも-targetオプションでリソースを指定できますが、正確なリソースパスを記述する必要があり、緊急時の運用には適していません。特に本番環境でのインシデント対応時には、迅速かつ正確なリソース指定が求められます。developer.hashicorp.com2.2 解決したい問題ツールの開発にあたり、複数の課題解決を目指しています。まずリソース選択を直感的に行えるようにすることで、運用者の負担を軽減します。同時に操作ミスを未然に防ぐ仕組みを導入し、安全性を確保します。また、緊急時にも迅速な対応ができるインターフェースを実現し、効率的なデバッグ作業を可能にすることで、運用効率の向上を図ります。3. 技術スタックの選定3.1 Rustを選んだ理由Rustを採用した理由は複数あります。まず、ゼロコスト抽象化による高いパフォーマンスを実現できることが挙げられます。また、強力な型システムと所有権モデルにより、メモリ安全性を確保できます。さらに、様々なOS向けにネイティブバイナリを生成できるクロスプラットフォーム対応も重要な選定理由となりました。豊富なクレートが利用可能な充実したエコシステムも、開発効率を高める要因となっています。最後に、純粋な学習目的として、小規模なツール開発を通じてRustの理解を深めることも目指しています。何かを引用するために書籍を貼ったが何を引用したいか忘れてしまった(がぎりぎりでこのブログを書いている為に調べることができない)。達人プログラマー ―熟達に向けたあなたの旅― 第2版作者:David Thomas,Andrew Huntオーム社Amazon3.2 主要な依存クレート[dependencies]walkdir = \"2.3\"      # ファイルシステム走査regex = \"1.5\"        # パターンマッチングclap = \"4.4\"         # CLIパーサーthiserror = \"1.0\"    # エラー型colored = \"2.0\"      # カラー出力crossterm = \"0.27\"   # TUIfuzzy-matcher = \"0.3\" # あいまい検索doc.rust-lang.org各クレートの選定理由：walkdir: 効率的な再帰的ファイル走査を提供regex: 高速で柔軟なパターンマッチングが可能clap: 型安全なCLI引数パーサーthiserror: エラー型の簡潔な定義crossterm: プラットフォーム独立なTUI実装fuzzy-matcher: 使いやすいあいまい検索機能4. 実装の詳細4.1 アーキテクチャ設計プロジェクトは機能ごとに明確に分離された以下のモジュール構成を採用しています：src/├── cli.rs        # CLIインターフェース├── display.rs    # 表示処理├── error.rs      # エラー型├── executor.rs   # Terraform実行├── input.rs      # 入力処理├── main.rs       # エントリーポイント├── project.rs    # プロジェクト解析├── selector.rs   # リソース選択UI└── types.rs      # 共通型定義各モジュールの責務：cli.rs: コマンドライン引数の定義と解析#[derive(Parser)]#[command(author, version, about)]pub struct Cli {    /// Terraformディレクトリのパス    #[arg(short, long, default_value = \".\")]    pub path: PathBuf,    /// 実行する操作    #[arg(short, long)]    pub operation: Option<Operation>,    /// 詳細出力の有効化    #[arg(short, long)]    pub verbose: bool,}project.rs: Terraformファイルの解析impl TerraformProject {    pub fn parse_directory(path: &Path) -> Result<Self> {        let mut project = TerraformProject::new();        for file_path in Self::find_terraform_files(path)? {            project.parse_file(&file_path)?;        }        Ok(project)    }    fn parse_file(&mut self, path: &Path) -> Result<()> {        let content = fs::read_to_string(path)?;        self.parse_resources(&content, path)?;        self.parse_modules(&content, path)?;        Ok(())    }}4.2 エラーハンドリング型安全なエラーハンドリングを実現するため、カスタムエラー型を定義：#[derive(Error, Debug)]pub enum TfocusError {    #[error(\"IO error: {0}\")]    Io(#[from] std::io::Error),    #[error(\"Failed to parse terraform file: {0}\")]    ParseError(String),    #[error(\"Invalid target selection\")]    InvalidTargetSelection,    #[error(\"Terraform command failed: {0}\")]    TerraformError(String),    #[error(\"No terraform files found\")]    NoTerraformFiles,}4.3 リソース選択UIの実装fuzzy検索を活用した効率的なリソース選択：impl Selector {    fn filter_items(&mut self) {        let query = self.query.to_lowercase();        let mut matches: Vec<(usize, i64)> = self            .items            .iter()            .enumerate()            .filter_map(|(index, item)| {                self.matcher                    .fuzzy_match(&item.search_text.to_lowercase(), &query)                    .map(|score| (index, score))            })            .collect();                // スコアでソート        matches.sort_by_key(|&(_, score)| -score);        self.filtered_items = matches.into_iter()            .map(|(index, _)| index)            .collect();    }    fn render_screen(&mut self) -> Result<()> {        let mut stdout = stdout();        execute!(            stdout,            terminal::Clear(ClearType::All),            cursor::MoveTo(0, 0)        )?;                self.render_search_box()?;        self.render_items()?;        self.render_status_line()?;                stdout.flush()?;        Ok(())    }}4.4 パフォーマンス最適化実行速度とメモリ使用量の最適化：[profile.release]opt-level = 3        # 最高レベルの最適化lto = true          # リンク時最適化codegen-units = 1   # 単一コード生成ユニットstrip = true        # バイナリサイズ削減5. Rustから学ぶシステム設計tfocusの実装を通じて学べるRustの重要概念プログラミングRust 第2版作者:Jim Blandy,Jason Orendorff,Leonora F. S. TindallオライリージャパンAmazon5.1 所有権とライフタイムリソースの効率的な管理：impl Resource {    pub fn full_name(&self) -> String {        if self.is_module {            format!(\"module.{}\", self.name)        } else {            format!(\"{}.{}\", self.resource_type, self.name)        }    }}5.2 エラー伝播?演算子を使用した簡潔なエラーハンドリング：pub fn execute_terraform_command(    operation: &Operation,    target_options: &[String],) -> Result<()> {    let mut command = Command::new(\"terraform\");    command.arg(operation.to_string());        for target in target_options {        command.arg(target);    }        let status = command.spawn()?.wait()?;        if status.success() {        Ok(())    } else {        Err(TfocusError::TerraformError(            \"Command execution failed\".to_string()        ))    }}5.3 トレイトの活用共通インターフェースの定義：pub trait Display {    fn render(&self) -> Result<()>;    fn update(&mut self) -> Result<()>;}6. まとめ6.1 現在の成果このプロジェクトは現在、直感的なリソース選択UIを実現し、クロスプラットフォームでの利用を可能にしています。また、効率的なメモリ使用を実現するとともに、型安全なエラーハンドリングを導入することで、安定性の向上にも成功しています。6.2 今後の展開使われるようになったらやっていきたいこと。機能拡張の面では、依存関係の可視化機能を導入し、リソース状態をより詳細に表示できるようにしたいと考えています。さらに、バッチ処理のサポートを追加することで、大規模な処理にも対応できるようにしていきます。品質向上については、テストカバレッジを拡大し、システム全体のパフォーマンスを最適化していく予定です。また、エラーメッセージをより分かりやすく改善することで、ユーザー体験の向上を図ります。ドキュメント整備においては、API文書を充実させ、初心者向けのチュートリアルを作成していきます。さらに、実際の使用シーンを想定したユースケース集を整備することで、ユーザーの理解促進を支援していきたいと考えています。おわりにtfocusの開発を通じて、RustとTerraformの実践的な活用方法を示しました。このツールが皆様のインフラ運用の一助となれば幸いです。コードはGitHubで公開しています：nwiizo/tfocusフィードバックやコントリビューションをお待ちしています。","isoDate":"2024-11-26T15:43:09.000Z","dateMiliSeconds":1732635789000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"SREの前に","link":"https://speakerdeck.com/nwiizo/srenoqian-ni","contentSnippet":"2024年11月06日(水) 18:00～19:00の予定に遅刻してしまい、大変申し訳ございませんでした。お詫びとして、当初非公開予定であった資料を公開させていただきます。元々、公開する予定ではなかったので補足が足りない部分などあると思いますのでご容赦下さい。\r\rブログなどで補足情報出すかもなので気になればフォローしてください\r- https://syu-m-5151.hatenablog.com/\r- https://x.com/nwiizo\r\r\rSREの前に - 運用の原理と方法論\r公式URL: https://talent.supporterz.jp/events/2ed2656a-13ab-409c-a1d9-df8383be25fd/","isoDate":"2024-11-06T05:00:00.000Z","dateMiliSeconds":1730869200000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"2024年版 運用者たちのLLM","link":"https://speakerdeck.com/nwiizo/2024nian-ban-yun-yong-zhe-tatinollm","contentSnippet":"Cloud Operator Days 2024 クロージングイベント\rhttps://cloudopsdays.com/closing/\r\rとても、端的に言うと「プロンプトエンジニアリングをしよう」って話。\rこの発表資料は、LLM（大規模言語モデル）によるIT運用の可能性と課題を探っています。AIOpsの概念を基に、LLMがインシデント対応、ドキュメンテーション、コード分析などの運用タスクをどのように改善できるかを説明しています。同時に、LLMの「幻覚」や不完全性といった課題も指摘し、適切な利用方法やプロンプトエンジニアリングの重要性を強調しています。\r\r登壇時ブログ\rhttps://syu-m-5151.hatenablog.com/entry/2024/09/06/154607","isoDate":"2024-09-06T04:00:00.000Z","dateMiliSeconds":1725595200000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Platform Engineering と SRE の門 ","link":"https://speakerdeck.com/nwiizo/platform-engineering-to-sre-nomen","contentSnippet":"Platform Engineering とSREの門 というタイトルで登壇しました。入門のタイポではありません。\r\rイベント名: Platform Engineering Kaigi 2024\rイベントURL:https://www.cnia.io/pek2024/\r\r登壇ブログ:『Platform Engineering とSREの門』という間違ったみたいなタイトルで登壇しました。 #PEK2024\rhttps://syu-m-5151.hatenablog.com/entry/2024/07/09/215147","isoDate":"2024-07-09T04:00:00.000Z","dateMiliSeconds":1720497600000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"運用者の各領域で向き合うLLM","link":"https://speakerdeck.com/nwiizo/yun-yong-zhe-noge-ling-yu-dexiang-kihe-ullm","contentSnippet":"運用者の各領域で向き合うLLM というタイトルで登壇しました。\r\rイベント名: Cloud Operator Days Tokyo 2024 \rイベントURL:https://cloudopsdays.com/","isoDate":"2024-06-28T04:00:00.000Z","dateMiliSeconds":1719547200000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"可観測性ガイダンス","link":"https://speakerdeck.com/nwiizo/ke-guan-ce-xing-kaitansu","contentSnippet":"可観測性ガイダンスというタイトルで登壇してきました。\r\rイベント名: オブザーバビリティ再入門 - 大切さと高め方を知ろう！\rイベントURL: https://mackerelio.connpass.com/event/316449/\r\r\r# ブログでいくつかの可観測性に関する書籍のまとめを投稿しました。\r5年後には標準になっている可観測性のこと - Learning Opentelemetry の読書感想文\rhttps://syu-m-5151.hatenablog.com/entry/2024/04/16/180511\r\rもう一度読むObservability Engineering\rhttps://syu-m-5151.hatenablog.com/entry/2024/05/06/090014\r\r盲目的に始めないためのオブザーバビリティ実践ガイド - Cloud Observability in Actionの読書感想文\rhttps://syu-m-5151.hatenablog.com/entry/2024/05/10/121047","isoDate":"2024-06-04T04:00:00.000Z","dateMiliSeconds":1717473600000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"書を捨てよ、現場へ出よう","link":"https://speakerdeck.com/nwiizo/shu-woshe-teyo-xian-chang-hechu-you","contentSnippet":"書を捨てよ、現場へ出よう このSRE本がすごい！2024年 LT版というタイトルで登壇してきました。\r\rSREたちの廊下〜あなたの現場での悩み、あの本にヒントがあるかも〜\rhttps://findy.connpass.com/event/311323/\r\r元ブログはこちら\r\rこのSRE本がすごい！2024年版\rhttps://syu-m-5151.hatenablog.com/entry/2024/01/26/165255\r\r登壇ブログはこちら\r\r『読書とは、能力、知識ではなく 問いを獲得するための行為』みたいな内容で登壇しました。\rhttps://syu-m-5151.hatenablog.com/entry/2024/03/13/164951","isoDate":"2024-03-12T04:00:00.000Z","dateMiliSeconds":1710216000000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"走馬灯のIaCは考えておいて","link":"https://speakerdeck.com/nwiizo/zou-ma-deng-noiachakao-eteoite","contentSnippet":"走馬灯のIaCは考えておいてというタイトルで登壇してきました\r\r技術的負債に向き合う Online Conference\rhttps://findy.connpass.com/event/297813/\r\r走馬灯のセトリは考えておいての短編はどれも面白いのでオススメです。\rhttps://www.hayakawa-online.co.jp/shopdetail/000000015282/\r\r登壇ブログ |『走馬灯のIaCは考えておいて』というタイトルで登壇しました。\rhttps://syu-m-5151.hatenablog.com/entry/2023/11/21/132144","isoDate":"2023-11-21T05:00:00.000Z","dateMiliSeconds":1700542800000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"SREとPlatform Engineerの交差点","link":"https://speakerdeck.com/nwiizo/sretoplatform-engineernojiao-chai-dian","contentSnippet":"Platform Engineering Meetup #5 #PFEM\rhttps://platformengineering.connpass.com/event/295048/ \r\rSREとPlatform Engineerの交差点: 2つの領域の交差と組織への適用 というタイトルで登壇します。\r\r登壇ブログ |『SREとPlatform Engineerの交差点:2つの領域の交差と組織への適用』というタイトルで登壇しました\rhttps://syu-m-5151.hatenablog.com/entry/2023/10/05/233555\r\rグレイラットの殺人 ワシントン・ポーが面白かったのでオススメです。\rhttps://www.hayakawa-online.co.jp/shopdetail/000000015569/","isoDate":"2023-10-05T04:00:00.000Z","dateMiliSeconds":1696478400000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"SREからPlatform Engineerへの拡大","link":"https://speakerdeck.com/nwiizo/srekaraplatform-engineerhenokuo-da","contentSnippet":"SREからPlatform Engineerへの拡大 というタイトルで登壇してきました\r\rCloud Operator Days Tokyo 2023 運用の新時代　〜Effortless Operation〜\rhttps://cloudopsdays.com/\r\rクラウドインフラ運用技術者のための年次イベント「Cloud Operator Days Tokyo 2023」の見所を紹介\rhttps://cloud.watch.impress.co.jp/docs/news/1518302.html\r\rSREからPlatform Engineerへの拡大 というタイトルで登壇しました - じゃあ、おうちで学べる  https://syu-m-5151.hatenablog.com/entry/2023/08/10/150412 \r\r登壇しかないので20分しかないのでｷﾞｭｯとしてしまいました。","isoDate":"2023-08-09T04:00:00.000Z","dateMiliSeconds":1691553600000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"k8sgpt Deep Dive: KubernetesクラスタのAI駆動型分析について","link":"https://speakerdeck.com/nwiizo/k8sgpt-deep-dive-kuberneteskurasutanoaiqu-dong-xing-fen-xi-nituite","contentSnippet":"k8sgpt Deep Dive: KubernetesクラスタのAI駆動型分析についてというタイトルで登壇しました\r\r2023年8月3日 CloudNative Days Fukuoka 2023\rhttps://event.cloudnativedays.jp/cndf2023\r\rk8sgpt Deep Dive: KubernetesクラスタのAI駆動型分析について\rhttps://event.cloudnativedays.jp/cndf2023/talks/1885\r\rK8sGPT Deep Dive というタイトルで登壇しました #CNDF - じゃあ、おうちで学べる  \rhttps://syu-m-5151.hatenablog.com/entry/2023/08/03/155326","isoDate":"2023-08-03T04:00:00.000Z","dateMiliSeconds":1691035200000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Cloud Native の作法","link":"https://speakerdeck.com/nwiizo/cloud-native-nozuo-fa","contentSnippet":"2023年7月13日 \r\r成熟度モデルを活用したCloud Nativeへの道筋 という副題で登壇します #開発生産性con_findy\rhttps://syu-m-5151.hatenablog.com/entry/2023/07/13/131433\r\r\r開発生産性Conference の登壇資料\rhttps://findy.connpass.com/event/283417/","isoDate":"2023-07-13T04:00:00.000Z","dateMiliSeconds":1689220800000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"2023年もSRE再考と叫びなさい‼️","link":"https://speakerdeck.com/nwiizo/2023nian-mosrezai-kao-tojiao-binasai","contentSnippet":"2023年もSRE再考と叫びなさい‼️ SREの跡を求めず SREの求めたるところを求めよ というタイトルで登壇してきました\r\r2023年3月3日 エンジニア文化祭 2023\rhttps://forkwell.connpass.com/event/272596/\r\r『2023年もSRE再考と叫びなさい!!』というタイトルで登壇しました - じゃあ、おうちで学べる\rhttps://syu-m-5151.hatenablog.com/entry/2023/03/03/105049","isoDate":"2023-03-03T05:00:00.000Z","dateMiliSeconds":1677819600000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"自由研究には向かないウェブオペレーション ","link":"https://speakerdeck.com/nwiizo/zi-you-yan-jiu-nihaxiang-kanaiuebuoperesiyon","contentSnippet":"自由研究には向かないウェブオペレーション サイト運用管理を取り巻く環境の変化 Cloud Native時代に考えるLinux オペレーション というタイトルで登壇してきました。\r\r2023年2月18日\r【今更聞けない】Linuxのしくみ - Forkwell Library #16\rhttps://forkwell.connpass.com/event/273179/\r\rあとがき\r『自由研究には向かないウェブオペレーション』というタイトルで登壇しました。\rhttps://syu-m-5151.hatenablog.com/entry/2023/02/18/201252","isoDate":"2023-02-18T05:00:00.000Z","dateMiliSeconds":1676696400000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":" ポストモーテムはじめました","link":"https://speakerdeck.com/nwiizo/posutomotemuhazimemasita","contentSnippet":"ポストモーテムはじめました - 良いポストモーテムを執筆するために必要な5つのポイント というタイトルで登壇してきました。\r\r2023年02月09日\rインシデントにどう対応してきたか？みんなで学ぶポストモーテム Lunch LT\rhttps://findy.connpass.com/event/273197/\r\r『ポストモーテムはじめました』というタイトルで登壇しました。 - じゃあ、おうちで学べる  \rhttps://syu-m-5151.hatenablog.com/entry/2023/02/09/113316","isoDate":"2023-02-09T05:00:00.000Z","dateMiliSeconds":1675918800000,"authorName":"nwiizo","authorId":"nwiizo"},{"title":"Observability Conference 2022 に登壇しました","link":"https://zenn.dev/nwiizo/articles/d837b78914de23","contentSnippet":"「Dapr の概念と実装から学ぶ Observability への招待」 というタイトルで登壇します。https://event.cloudnativedays.jp/o11y2022/talks/1382:embed:cite セッション概要Dapr は CloudNative な技術を背景に持つ分散アプリケーションランタイムです。本セッションでは Dapr の Observability に関する各種機能と、その実装について解説していきます。さらにスリーシェイクの Dapr と Observability への取り組みに関してもご紹介します。Dapr の機能でカバーできる点...","isoDate":"2022-03-11T04:02:18.000Z","dateMiliSeconds":1646971338000,"authorName":"nwiizo","authorId":"nwiizo"}]},"__N_SSG":true}