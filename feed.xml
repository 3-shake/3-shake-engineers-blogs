<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Sun, 09 Mar 2025 22:31:29 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[MCPでLLMに行動させる - Terraformを例とした tfmcp の紹介]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/03/09/020057</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/03/09/020057</guid>
            <pubDate>Sat, 08 Mar 2025 17:00:57 GMT</pubDate>
            <content:encoded><![CDATA[はじめにこんにちは！今回は、私が最近開発した tfmcp というツールを紹介します。これは Terraform を LLM（大規模言語モデル）から操作できるようにするツールで、Model Context Protocol (MCP) を活用しています。github.comこのブログが良ければ読者になったり、GitHub リポジトリにStarをいただけると開発の励みになります。より良いツール開発のためのフィードバックもお待ちしています！MCP とは何か？記事を始める前に、まず MCP (Model Context Protocol) について簡単に説明しましょう。MCP についてより詳しい情報は、公式ドキュメント modelcontextprotocol.io や Anthropic の Model Context Protocol に関する記事 を参照してください。MCP は Cline や Cursor などの LLM クライアントが外部サービスと連携するためのプロトコルです。従来の LLM は学習したデータに基づいて「考える」ことしかできませんでしたが、MCP を通じて外部と連携し、「行動する」能力を持つことができます。具体的には、MCP を使うことで以下のようなことが可能になります。Notion のファイル編集Supabase のデータベースクエリCloudflare のステータスチェックローカルファイルの編集や操作mcpserver.ccMCP がプロトコルとして統一されていることで、LLM プロバイダーやサービスを柔軟に切り替えることができるという大きなメリットがあります。MCP の仕組みMCP は基本的に JSON-RPC ベースのプロトコルで、詳細な仕様は modelcontextprotocol.io/docs/concepts/transports#message-format で確認できます。主要な構成要素は以下のとおりです。リソース（Resources）：データへのアクセスを提供（REST API の GET に相当）ツール（Tools）：アクションの実行を可能にする（REST API の POST に相当）プロンプト（Prompts）：LLM がどのようにサービスを使うべきかのガイダンスMCP の実装をサポートするための公式 SDK が複数の言語で提供されています(2024年3月9日 現在)。TypeScript SDKPython SDKKotlin SDKJava SDKしかし、MCP は標準的な JSON-RPC プロトコルをベースとしているため、任意のプログラミング言語で独自に実装することも可能です。本プロジェクト tfmcp では、Rust で実装しています。ちなみにJSON−RPCについて詳しく知りたい場合は「Real World HTTP 第3版」を読むととても勉強になるのでオススメです。Real World HTTP 第3版 ―歴史とコードに学ぶインターネットとウェブ技術作者:渋川 よしきオライリージャパンAmazonJSON-RPC の基本MCP は JSON-RPC 2.0 仕様に基づいており、以下の3種類のメッセージ形式が使われます。リクエスト：クライアントからサーバーへの要求{     "jsonrpc": "2.0",     "id": 1,     "method": "tools/call",     "params": { /* パラメータ */ }}レスポンス：サーバーからクライアントへの応答{     "jsonrpc": "2.0",     "id": 1,     "result": { /* 結果オブジェクト */ }}エラー時：{     "jsonrpc": "2.0",     "id": 1,     "error": {       "code": -32700,       "message": "エラーメッセージ"  }}通知：レスポンスを必要としないサーバーからの一方的なメッセージ{     "jsonrpc": "2.0",     "method": "$/log",     "params": { /* パラメータ */ }}tfmcp: Terraform を LLM から操作するさて、本題の tfmcp の紹介に移ります。tfmcp は Model Context Protocol を活用して、LLM（特に Claude Desktop など）から Terraform の操作を可能にするツールです。tfmcp の主な機能tfmcp を使うと、以下のようなことが可能になります。Terraform 設定ファイルの読み取りプロジェクト内の .tf ファイルを解析し構造を理解Terraform プランの解析terraform plan の結果を解析して LLM に伝えるTerraform の適用設定をインフラに適用する terraform apply を実行状態管理Terraform の状態ファイルを管理・読み取り設定ファイルの作成・修正新しい Terraform 設定の作成や既存の設定の変更デモClaude Desktop と連携している tfmcp のデモを見てみましょう：このデモでは、Claude が自然言語で Terraform プロジェクトを操作し、分析、実行しています。インストール方法tfmcp は Rust で書かれており、Cargo を使って簡単にインストールできます。cargo install tfmcpソースからのインストールも可能です。# リポジトリをクローンgit clone https://github.com/nwiizo/tfmcpcd tfmcp# ビルドとインストールcargo install --path .Claude Desktop との連携方法Claude Desktop と tfmcp を連携するには、以下の手順を行います。まず、tfmcp をインストールします。bashcargo install tfmcpインストールされた tfmcp 実行ファイルのパスを見つけます。bashwhich tfmcpClaude Desktop の設定ファイルを開き、以下の設定を追加します。{     "mcpServers": {       "tfmcp": {         "command": "/path/to/your/tfmcp",  // 実際のパスに置き換えてください         "args": ["mcp"],         "env": {           "HOME": "/Users/yourusername",  // あなたのユーザー名に置き換えてください           "PATH": "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin",           "TERRAFORM_DIR": "/path/to/your/terraform/project"  // オプション：Terraformプロジェクトのパス      }    }  }}Claude Desktop を再起動し、tfmcp ツールを有効にします。もし Terraform プロジェクトが存在しない場合、tfmcp は自動的に ~/terraform に基本的なサンプルプロジェクトを作成します。使用例tfmcp の使い方や詳細なドキュメントは GitHub リポジトリの README で確認できます。以下のようなシナリオで特に役立ちます。Terraform 設定の説明と理解「このプロジェクトで使われている Terraform リソースを分析して」設定の検証とトラブルシューティング「この Terraform プロジェクトのエラーを見つけて修正して」インフラの計画と適用「このプランを実行するとどうなるか説明して」「この変更を適用して結果を報告して」設定の自動生成「S3バケットとIAMポリシーを作成する Terraform コードを書いて」セキュリティに関する考慮事項tfmcp を使用する際には、以下の点に注意が必要です。tfmcp は Terraform コマンドをユーザーに代わって実行するため、インフラの作成、変更、削除が可能です本番環境では、適切な IAM 権限やロール境界を使用することを検討してくださいAI によって生成された Terraform プランは、適用前に必ず確認してくださいTerraform の状態ファイルに含まれる機密情報が AI アシスタントからアクセス可能になる可能性がありますMCP自体のセキュリティリスクMCPはLLMにローカル環境への強いアクセス権を付与するので、本質的にセキュリティ上の懸念があります。普通にもう狙ってきていると思いますのでむやみやたらにインストールするのはやめましょう。サードパーティMCPサーバーのリスク: 信頼できない「野良MCPサーバー」をインストールすると、マルウェアや情報漏洩のリスクが高まります。MCPサーバーはローカルファイルシステムや他のリソースへのアクセス権を持つため、悪意のあるコードを実行される可能性があります。権限の過剰付与: MCPサーバーが必要以上の権限を持つと、攻撃者がLLMとの対話を通じてシステムリソースに不正アクセスする可能性があります。データ漏洩のリスク: ローカルファイルやクレデンシャルなどの機密情報が、LLMとの対話を通じて外部に漏洩する可能性があります。プロンプトインジェクション攻撃: 悪意あるプロンプトを通じて、MCPサーバーに予期しない操作を実行させるリスクがあります。安全なMCP利用のための注意事項以下の対策を実施することで、MCPの安全な利用が多少、可能になります。それでも完璧ではないです。金払ってくれるなら作ってやるから連絡してくれ。信頼できるソースからのみMCPサーバーをインストール: 公式リポジトリや信頼できる開発者からのMCPサーバーのみを使用し、コードを確認してから実行してください。最小権限の原則を適用: MCPサーバーには必要最小限の権限のみを付与し、特に本番環境や機密データへのアクセスは制限してください。サンドボックス環境での実行: 可能であれば、MCPサーバーを隔離された環境で実行し、重要なシステムやデータへのアクセスを制限してください。監査ログの有効化: MCPサーバーを通じて実行されたすべてのコマンドや操作を記録し、不審な活動がないかを定期的に確認してください。機密情報のフィルタリング: LLMに送信される前に、APIキーやパスワードなどの機密情報を検出・削除するメカニズムを実装してください。定期的なセキュリティレビュー: MCPサーバーの設定やコードを定期的にレビューし、セキュリティの脆弱性がないかを確認してください。tfmcpを含むMCPサーバーは強力なツールですが、その力は適切に管理されなければリスクにもなり得ます。特に初めての利用時は、非本番環境でのテストから始め、リスクを理解した上で徐々に本番環境への導入を検討することをお勧めします。tfmcp の技術的詳細と実装tfmcp の内部実装について詳しく説明します。全体アーキテクチャtfmcp は大きく分けて以下のコンポーネントから構成されています。tfmcp├── config      - 設定管理├── core        - コアロジック├── mcp         - MCPプロトコル実装├── shared      - 共通ユーティリティ└── terraform   - Terraform連携主要コンポーネントの詳細1. MCP サーバー (src/mcp/)MCPサーバーは、LLMクライアント（Claude Desktopなど）との通信を処理する部分です。主に以下のファイルから構成されています。handler.rs: MCPリクエストの処理とレスポンスの生成stdio.rs: 標準入出力を使った通信の実装handler.rs の核となる部分は McpHandler 構造体で、リクエストに応じて適切なTerraformコマンドを実行します。pub struct McpHandler<'a> {    tfmcp: &'a mut TfMcp,    initialized: bool,}impl<'a> McpHandler<'a> {    // ...    async fn handle_tools_call(        &mut self,        transport: &StdioTransport,        id: u64,        params_val: serde_json::Value,    ) -> anyhow::Result<()> {        let name = params_val            .get("name")            .and_then(|v| v.as_str())            .unwrap_or("");        match name {            "list_terraform_resources" => {                self.handle_list_terraform_resources(transport, id).await?;         }            "analyze_terraform" => {                self.handle_analyze_terraform(transport, id, &params_val).await?;         }            "get_terraform_plan" => {                self.handle_get_terraform_plan(transport, id).await?;         }            // 他のツール処理...     }        Ok(()) }        // 各ツールの実装...}MCPのリクエスト/レスポンスフローを図示すると次のようになります。2. Terraform サービス (src/terraform/)Terraformとの実際の連携を担当するコンポーネントです。主に以下のファイルで構成されています。service.rs: Terraformコマンドの実行とその結果の解析model.rs: Terraformの設定やステート用のデータモデルTerraformService 構造体が主要なインターフェースを提供します。pub struct TerraformService {    terraform_path: PathBuf,  // terraform実行ファイルのパス    project_directory: PathBuf,  // Terraformプロジェクトのディレクトリ}impl TerraformService {    // 初期化    pub fn new(        terraform_path: PathBuf,        project_directory: PathBuf,    ) -> Result<Self, TerraformError> {        // ... 検証ロジック ... }    // プロジェクトディレクトリの変更    pub fn change_project_directory(        &mut self,        new_directory: PathBuf,    ) -> Result<(), TerraformError> {        // ... ディレクトリ変更ロジック ... }    // Terraformコマンドの実行    pub async fn apply(&self, auto_approve: bool) -> anyhow::Result<String> {        let mut args = vec!["apply", "-no-color"];        if auto_approve {            args.push("-auto-approve");     }        let output = Command::new(&self.terraform_path)            .args(&args)            .current_dir(&self.project_directory)            .output()?;        // ... 出力処理 ... }    // 設定ファイルの解析    pub async fn analyze_configurations(&self) -> anyhow::Result<TerraformAnalysis> {        // ... 解析ロジック ... }    // その他のメソッド...}3. コア (src/core/)TfMcp 構造体は、アプリケーションの中心的なコントローラーとして機能し、MCPハンドラーとTerraformサービスを橋渡しします。pub struct TfMcp {    config: Config,    terraform_service: TerraformService,}impl TfMcp {    pub fn new(config_path: Option<String>, project_dir: Option<String>) -> anyhow::Result<Self> {        // ... 初期化ロジック ... }    pub async fn launch_mcp(&mut self) -> anyhow::Result<()> {        // ... MCPサーバー起動ロジック ... }    // Terraformサービスへの橋渡し    pub async fn analyze_terraform(&mut self) -> anyhow::Result<()> {        let analysis = self.terraform_service.analyze_configurations().await?;        println!("{}", serde_json::to_string_pretty(&analysis)?);        Ok(()) }    // その他のメソッド...}4. 設定管理 (src/config/)アプリケーションの設定を管理します。設定ファイルからの読み込みと、デフォルト設定の提供を担当します。pub struct Config {    pub terraform: TerraformConfig,    pub mcp: McpConfig,}pub fn init_default() -> anyhow::Result<Config> {    // ... デフォルト設定ロジック ...}pub fn init_from_path(path: &str) -> anyhow::Result<Config> {    // ... 設定ファイル読み込みロジック ...}実装の特徴高速なパフォーマンス：Rust のエコシステムを活用した高速な処理自動セットアップ：必要に応じてサンプル Terraform プロジェクトを自動作成エラー処理：適切なエラーメッセージとロギングプロジェクトディレクトリの動的切り替え：実行中にプロジェクトディレクトリを変更可能Rust での JSON-RPC 2.0 実装tfmcp では Rust で JSON-RPC 2.0 を実装するために、標準的なアプローチを採用しています。以下は JSON-RPC メッセージの定義と処理の詳細な実装方法です。1. 依存パッケージの設定まず、Cargo.toml に必要な依存関係を定義します。[dependencies]serde = { version = "1.0", features = ["derive"] }serde_json = "1.0"anyhow = "1.0"thiserror = "1.0"tokio = { version = "1.0", features = ["full"] }futures = "0.3"async-trait = "0.1"2. メッセージ構造体とエラー型の定義use serde::{Deserialize, Serialize};use std::pin::Pin;use std::sync::{Arc, Mutex};use tokio::sync::broadcast;use futures::Stream;use async_trait::async_trait;// JSON-RPC エラーコード#[derive(Debug)]#[allow(dead_code)]pub enum JsonRpcErrorCode {    ParseError = -32700,    InvalidRequest = -32600,    MethodNotFound = -32601,    InvalidParams = -32602,    InternalError = -32603,    // カスタムエラーコード（-32000 から -32099 の範囲）    TerraformNotFound = -32000,    InvalidProjectDirectory = -32001,}// トランスポートエラー#[derive(thiserror::Error, Debug, Clone)]pub enum Error {    #[error("IO error: {0}")]    Io(String),        #[error("Serialization error: {0}")]    Serialization(String),        #[error("Other error: {0}")]    Other(String),}// JSON-RPC メッセージ#[derive(Debug, Clone, Serialize, Deserialize)]#[serde(untagged)]pub enum Message {    Request {        #[serde(rename = "jsonrpc")]        jsonrpc: String,        #[serde(rename = "method")]        method: String,        #[serde(rename = "id")]        id: u64,        #[serde(rename = "params")]        #[serde(skip_serializing_if = "Option::is_none")]        params: Option<serde_json::Value>, },    Notification {        #[serde(rename = "jsonrpc")]        jsonrpc: String,        #[serde(rename = "method")]        method: String,        #[serde(rename = "params")]        #[serde(skip_serializing_if = "Option::is_none")]        params: Option<serde_json::Value>, },    Response {        #[serde(rename = "jsonrpc")]        jsonrpc: String,        #[serde(rename = "id")]        id: u64,        #[serde(rename = "result")]        #[serde(skip_serializing_if = "Option::is_none")]        result: Option<serde_json::Value>,        #[serde(rename = "error")]        #[serde(skip_serializing_if = "Option::is_none")]        error: Option<serde_json::Value>, },}ここで重要なのは：#[serde(untagged)] アノテーションにより、3種類のメッセージタイプを同じ列挙型で表現#[serde(skip_serializing_if = "Option::is_none")] で null 値のフィールドを出力しない設定thiserror を使った明確なエラー型の定義3. トランスポートトレイトとその実装JSON-RPC メッセージの送受信を行うための抽象インターフェースとして、トランスポートトレイトを定義します。#[async_trait]pub trait Transport: Send + Sync {    // メッセージを送信する    async fn send(&self, message: Message) -> Result<(), Error>;        // メッセージストリームを受け取る    fn receive(&self) -> Pin<Box<dyn Stream<Item = Result<Message, Error>> + Send>>;        // トランスポートを閉じる    async fn close(&self) -> Result<(), Error>;}標準入出力を使ったトランスポート実装例：pub struct StdioTransport {    stdout: Arc<Mutex<std::io::Stdout>>,    receiver: broadcast::Receiver<Result<Message, Error>>,}impl StdioTransport {    pub fn new() -> (Self, broadcast::Sender<Result<Message, Error>>) {        let (sender, receiver) = broadcast::channel(100);        let transport = Self {            stdout: Arc::new(Mutex::new(std::io::stdout())),            receiver,     };        // 標準入力からの読み取りをバックグラウンドで実行        let stdin = tokio::io::stdin();        let mut reader = tokio::io::BufReader::new(stdin);        let sender_clone = sender.clone();        tokio::spawn(async move {            let mut line = String::new();            loop {                line.clear();                match reader.read_line(&mut line).await {                    Ok(0) => break, // EOF                    Ok(_) => {                        // 空白を除去して解析の問題を回避                        let trimmed_line = line.trim();                        eprintln!("[DEBUG] Received JSON: {}", trimmed_line);                                                // JSON-RPC メッセージを解析                        let parsed = parse_json_message(trimmed_line);                        if sender_clone.send(parsed).is_err() {                            eprintln!("[ERROR] Failed to send parsed message to channel");                            break;                     }                 }                    Err(e) => {                        eprintln!("[ERROR] Error reading from stdin: {}", e);                        let _ = sender_clone.send(Err(Error::Io(                            format!("Error reading from stdin: {}", e))                        ));                        break;                 }             }         }     });        (transport, sender) }}#[async_trait]impl Transport for StdioTransport {    async fn send(&self, message: Message) -> Result<(), Error> {        let mut stdout = self.stdout.lock()            .map_err(|_| Error::Other("Failed to lock stdout".into()))?;        // メッセージを JSON 文字列に変換        let json = match serde_json::to_string(&message) {            Ok(s) => s,            Err(e) => return Err(Error::Serialization(                format!("JSON serialization error: {}", e)            )),     };        // デバッグログ用に送信するJSONを出力        let truncated_json = if json.len() > 500 {            format!("{}... (truncated)", &json[0..500])     } else {            json.clone()     };        eprintln!("[DEBUG] Sending JSON: {}", truncated_json);        // JSON 文字列を改行付きで出力し、フラッシュ        if let Err(e) = writeln!(stdout, "{}", json) {            return Err(Error::Io(format!("Failed to write to stdout: {}", e)));     }        if let Err(e) = stdout.flush() {            return Err(Error::Io(format!("Failed to flush stdout: {}", e)));     }        Ok(()) }    fn receive(&self) -> Pin<Box<dyn Stream<Item = Result<Message, Error>> + Send>> {        let rx = self.receiver.resubscribe();        Box::pin(futures::stream::unfold(rx, |mut rx| async move {            match rx.recv().await {                Ok(msg) => Some((msg, rx)),                Err(_) => None,         }     })) }    async fn close(&self) -> Result<(), Error> {        Ok(()) }}よりロバストなJSONパース処理の実装：// エラー対応の改善されたJSONメッセージパース関数fn parse_json_message(json_string: &str) -> Result<Message, Error> {    // 空入力のバリデーション    if json_string.is_empty() {        return Err(Error::Serialization("Empty JSON string".into())); }    // 一般的なJSON問題を修正    let mut processed_json = json_string.to_string();    // 問題のある空白文字を除去    processed_json = processed_json.replace(['\n', '\r', '\t'], " ");    // エスケープされていないバックスラッシュと引用符の処理    if processed_json.contains("\\\\") || processed_json.contains("\\\"") {        processed_json = processed_json            .replace("\\\\", "\\")            .replace("\\\"", "\""); }    // 修正された文字列で解析を試行    let parse_result = serde_json::from_str::<Message>(&processed_json);    match parse_result {        Ok(msg) => Ok(msg),        Err(e) => {            eprintln!("[ERROR] JSON parse error: {}. Input: {}", e, processed_json);            // 追加診断情報の提供            if let Ok(value) = serde_json::from_str::<serde_json::Value>(&processed_json) {                eprintln!("[DEBUG] JSON parsed as generic value: {:?}", value);         } else {                eprintln!("[ERROR] Could not parse JSON even as generic value");         }            Err(Error::Serialization(format!("JSON parse error: {}", e)))     } }}4. リクエスト処理とメソッドディスパッチMCP サーバー内でのリクエスト処理は、メソッド名に基づいてディスパッチ（振り分け）します。pub struct McpHandler<'a> {    tfmcp: &'a mut TfMcp,    initialized: bool,}impl<'a> McpHandler<'a> {    pub fn new(tfmcp: &'a mut TfMcp) -> Self {        Self {            tfmcp,            initialized: false,     } }    pub async fn launch_mcp(&mut self, transport: &StdioTransport) -> anyhow::Result<()> {        let mut stream = transport.receive();        logging::info("MCP stdio transport server started. Waiting for JSON messages on stdin...");                // メッセージループ        while let Some(msg_result) = stream.next().await {            match msg_result {                Ok(Message::Request { id, method, params, .. }) => {                    logging::debug(&format!(                        "Got Request: id={}, method={}, params={:?}",                        id, method, params                    ));                    // 初期化リクエストの特別処理                    if method == "initialize" {                        if let Err(err) = self.handle_initialize(transport, id).await {                            logging::error(&format!("Error handling initialize request: {}", err));                     }                        self.initialized = true;                        continue;                 }                    // 他のすべてのリクエストでは、初期化されていることを確認                    if !self.initialized {                        self.send_error_response(                            transport,                            id,                            JsonRpcErrorCode::InvalidRequest,                            "Server not initialized. Send 'initialize' request first.".to_string(),                        ).await?;                        continue;                 }                    // リクエスト処理の実行                    if let Err(err) = self.handle_request(transport, id, method, params).await {                        logging::error(&format!("Error handling request: {:?}", err));                        self.send_error_response(                            transport,                            id,                            JsonRpcErrorCode::InternalError,                            format!("Failed to handle request: {}", err),                        ).await?;                 }             }                Ok(Message::Notification { method, params, .. }) => {                    logging::debug(&format!("Got Notification: method={}, params={:?}", method, params));                    // 通知の処理（必要に応じて）             }                Ok(Message::Response { id, result, error, .. }) => {                    logging::debug(&format!(                        "Got Response: id={}, result={:?}, error={:?}",                        id, result, error                    ));                    // レスポンスの処理（必要に応じて）             }                Err(e) => {                    logging::error(&format!("Error receiving message: {:?}", e));             }         }     }        Ok(()) }    async fn handle_request(        &mut self,        transport: &StdioTransport,        id: u64,        method: String,        params: Option<serde_json::Value>,    ) -> anyhow::Result<()> {        match &*method {            "initialize" => self.handle_initialize(transport, id).await?,            "tools/list" => self.handle_tools_list(transport, id).await?,            "tools/call" => {                if let Some(params_val) = params {                    self.handle_tools_call(transport, id, params_val).await?;             }         }            "resources/list" => self.handle_resources_list(transport, id).await?,            "prompts/list" => self.handle_prompts_list(transport, id).await?,            _ => {                self.send_error_response(                    transport,                    id,                    JsonRpcErrorCode::MethodNotFound,                    format!("Method not found: {}", method),                ).await?;         }     }        Ok(()) }}5. レスポンス送信メソッド成功レスポンスとエラーレスポンスのヘルパーメソッド：impl<'a> McpHandler<'a> {    // テキストコンテンツを持つレスポンスを送信    async fn send_text_response(        &self,        transport: &StdioTransport,        id: u64,        text: &str,    ) -> anyhow::Result<()> {        logging::info(&format!("Sending text response for id {}", id));        // 適切に構造化されたテキストレスポンスを作成        let response = Message::Response {            jsonrpc: "2.0".to_string(),            id,            result: Some(json!({                "content": [{                    "type": "text",                    "text": text             }]         })),            error: None,     };        // レスポンスをログに記録（デバッグ用）        if let Ok(json_str) = serde_json::to_string_pretty(&response) {            logging::debug(&format!("Sending text response: {}", json_str));     }        // レスポンスを送信        match transport.send(response).await {            Ok(_) => {                logging::info("Text response sent successfully");                Ok(())         }            Err(e) => {                logging::error(&format!("Failed to send text response: {}", e));                Err(anyhow::anyhow!("Failed to send text response: {}", e))         }     } }    // エラーレスポンスを送信    async fn send_error_response(        &self,        transport: &StdioTransport,        id: u64,        code: JsonRpcErrorCode,        message: String,    ) -> anyhow::Result<()> {        logging::warn(&format!(            "Sending error response for id {}: {}",            id, message        ));        // 適切に構造化されたエラーレスポンスを作成        let response = Message::Response {            jsonrpc: "2.0".to_string(),            id,            result: None,            error: Some(json!({                "code": code as i32,                "message": message         })),     };        // レスポンスをログに記録（デバッグ用）        if let Ok(json_str) = serde_json::to_string_pretty(&response) {            logging::debug(&format!("Sending error response: {}", json_str));     }        // レスポンスを送信        match transport.send(response).await {            Ok(_) => {                logging::info("Error response sent successfully");                Ok(())         }            Err(e) => {                logging::error(&format!("Failed to send error response: {}", e));                Err(anyhow::anyhow!("Failed to send error response: {}", e))         }     } }}6. 具体的なメソッドハンドラの実装例例として、tools/list メソッドのハンドラ実装：async fn handle_tools_list(&self, transport: &StdioTransport, id: u64) -> anyhow::Result<()> {    // ツール一覧を含むJSONを取得    let tools_value: serde_json::Value = serde_json::from_str(TOOLS_JSON)        .expect("tools.json must be valid JSON");    // レスポンスを作成して送信    let response = Message::Response {        jsonrpc: "2.0".to_string(),        id,        result: Some(tools_value),        error: None, };    transport.send(response).await?;    Ok(())}ツール呼び出しハンドラの実装例：async fn handle_tools_call(    &mut self,    transport: &StdioTransport,    id: u64,    params_val: serde_json::Value,) -> anyhow::Result<()> {    let name = params_val        .get("name")        .and_then(|v| v.as_str())        .unwrap_or("");    logging::info(&format!("Handling tools/call for tool: {}", name));    match name {        "get_terraform_plan" => {            // Terraform プランを取得            match self.tfmcp.get_terraform_plan().await {                Ok(plan) => {                    // 結果のJSONを構築                    let result_json = json!({ "plan": plan });                    let obj_as_str = serde_json::to_string(&result_json)?;                                        // テキストレスポンスとして送信                    self.send_text_response(transport, id, &obj_as_str).await?;             }                Err(err) => {                    // エラーレスポンスを送信                    self.send_error_response(                        transport,                        id,                        JsonRpcErrorCode::InternalError,                        format!("Failed to get Terraform plan: {}", err),                    ).await?;             }         }     }        // 他のツールハンドラ...        _ => {            self.send_error_response(                transport,                id,                JsonRpcErrorCode::MethodNotFound,                format!("Tool not found: {}", name),            ).await?;     } }    Ok(())}これらのコードパターンにより、tfmcp は MCP プロトコルの JSON-RPC メッセージを効率的に処理し、Terraform コマンドの実行結果をクライアントに返すことができます。Rust の主要な利点としては以下が挙げられます。型安全性: serde による強力なシリアライズ/デシリアライズの型検証強力なエラーハンドリング: Result 型と thiserror によるエラー処理非同期処理: tokio と async/await による効率的な非同期I/Oトレイトベースの抽象化: Transport トレイトによる異なる通信方式のサポートメモリ安全性: ランタイムの安全性とパフォーマンスおわりにtfmcp は、Terraform と LLM の統合における最初の一歩です。MCP（Model Context Protocol）に関して色々説明してきましたが、すごく簡単に言うなら「LLMのためのAPIサーバー」です。この技術を活用することで、インフラストラクチャの管理に自然言語インターフェースをもたらし、複雑な IaC (Infrastructure as Code) の作業を簡素化することができます。Model Context Protocol は、AIモデルがローカル環境のリソースやツールに安全にアクセスするための架け橋となります。実装自体はシンプルなJSON-RPCベースのプロトコルなので、皆さんも自分の得意な分野や業務で使えるMCPサーバーを実装してみてください。AIとのコラボレーションの可能性が大きく広がるはずです。Rust による実装は、型安全性、堅牢なエラー処理、効率的な非同期処理など、多くの利点をもたらしています。特に通信プロトコルの実装において、これらの特性は重要な役割を果たし、AIとツールの間のやり取りをスムーズかつ確実に行うための信頼性の高い基盤となっています。とても楽しいです。また、こちらも応援お願いします。こちらCfPを書きました。皆様の応援が力になるので投票お願いします。生成AIによるCloud Native 基盤構築の可能性と実践的ガードレールの敷設について | CloudNative Days Summer 2025 https://t.co/vs2EfE2m41 #CNDS2025— nwiizo (@nwiizo) 2025年2月25日   あ、会社にも所属していて技術支援もやっているので興味があれば話をしましょうやー！sreake.com各種参考リンクModel Context Protocol 公式ドキュメントMCP メッセージフォーマットとトランスポート仕様MCP GitHub リポジトリMCP TypeScript SDKAnthropic の MCP 紹介記事Cline における MCP の解説記事MCPで広がるLLM　~Clineでの動作原理~]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Qiitaの自己紹介欄に何書く？　というポエム]]></title>
            <link>https://qiita.com/masaru-komiyama/items/781912e64e09d5ac8e90</link>
            <guid>https://qiita.com/masaru-komiyama/items/781912e64e09d5ac8e90</guid>
            <pubDate>Fri, 07 Mar 2025 13:22:22 GMT</pubDate>
            <content:encoded><![CDATA[はじめに皆様、こんばんは。カラーコードの覚え方 や、適当なプログラムを書いた共有に超初級編などと銘打つ記事 など、 ふと頭によぎった技術ネタや、興味が湧いた技術ネタなど、一貫性の無いネタを自由に…]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[無限技術的負債 - Taming Your Dragon: Addressing Your Technical Debt の読書感想文]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/03/07/133504</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/03/07/133504</guid>
            <pubDate>Fri, 07 Mar 2025 04:35:04 GMT</pubDate>
            <content:encoded><![CDATA[はじめに「Taming Your Dragon: Addressing Your Technical Debt」を読み終えて、技術的負債という厄介な問題への理解が大きく深まりました。この本は2024年7月にO'Reillyから出版され、技術的負債というドラゴンの正体とその退治法について包括的に解説しています。多くのエンジニアにとって身近な「誰がこんなコードを書いたんだ！...あ、私か」という経験から始まり、技術的負債の本質と効果的な管理方法へと読者を導いてくれます。learning.oreilly.com私たちエンジニアは普段、「美しいコードを書く芸術家」か「とりあえず動けばOKの実務家」かという二択で自分を見がちです。しかし実際には、納期に追われて「まぁ動くからいっか」と書いたコードが、数ヶ月後に「誰だこんな恐ろしいものを作ったのは！」という悲鳴に変わる悪夢のループから抜け出せないことも多いのではないでしょうか。これこそが「技術的負債」という悪魔もしくはドラゴンの卵が孵化する瞬間です。平凡なプログラマー・nwiizoは、ある日、長年使われてきた古い社内システム「Ｃシステム」でごく普通のプログラム部品を追加しようとしたところ、突然画面にエラーメッセージが溢れ、システムが完全に動かなくなってしまいます。会社の先輩プログラマーたちから、この巨大で一体化した管理システムを操作する権限をもらいましたが、すでに修正すべき不具合リストには何百もの未解決問題が積み上がっている状態で、自分の問題が解決される順番はいつになるかわかりません。nwiizoはシステム停止の警告に悩まされながら待ち続けますが、調査するうちにこのシステムの内部構造が信じられないほど複雑に絡み合っていることに気づきます。プログラムの中には決まった数値をむやみに書き換える人、テスト用の環境で好き勝手に変更する人、コードの整理に奮闘する人、緊急の修正を求めて管理者に詰め寄る人など、様々な混乱が広がっていました。nwiizoは問題を見つけるための様々な道具を使いますが、なぜかシステムの根本からの改善は「前例がない」と許可されません。この状況から逃げ出そうとしても、このシステムの外側には、この古いシステムに頼って動いている無数の小さなサービスプログラムが広がっていました。まるで古い城の土台が崩れかけているのに、その上に次々と新しい部屋を増築しているような状態です。nwiizoは気づきます。今はまさに《技術的負債の時代》、すべてのコードが少しずつ劣化し、誰も全体を理解できない環境に自分はいるのだと。あなたも、きっと「誰がこんなコードを書いたんだ！」と頭を抱えながらチケットキューに並んだことがあるでしょう。あるいは数ヶ月前の自分が書いたハードコードされた値を見て「これ誰が書いたんだ？...あ、私か」と冷や汗をかいたことがあるはずです。安心してください、あなたやnwiizoだけではありません。私たちは皆、技術的負債というドラゴンの前で怯えているのです。技術的負債の起源と本質「技術的負債」という言葉は近年広く使われるようになりましたが、その明確な定義はなく、理解が曖昧なまま用いられることが多いのが現状です。Ward Cunningham氏が技術的負債の概念の生みの親と言われていますが、最初に"負債"という言葉を用いたのは1992年のOOPSLA '92 Experience Reportでした。「最初のバージョンをリリースすることは、ある意味で借金を背負うようなものです」興味深いことに、レポート全体を見てもdebt（負債）としか言及しておらず、technical（技術的）という言葉は付いていません。後に彼自身がWikiで解説しているように、このメタファーが生まれた背景は純粋に学術的なものではなく、職場でのコミュニケーションにおいて、金融ソフトウェアを開発していた彼が上司に説明するために使った「金融の例え話」だったのです。t_wadaさんによる翻訳記事でも詳しく解説されています。その後、いつ頃からか「技術的負債（Technical Debt）」という言葉が広まっていきましたが、いつ誰が最初に「技術的」を付け加えたのかは明確ではありません。Cunningham氏は技術的負債について次のように説明しています。「ソフトウェアを急いでリリースし、開発過程で様々な気づきを得ても、それらの学びをコードに反映しないケースは数多くあります。これは返済不要だと思って借金をするようなものです。たとえばクレジットカードの場合、そんなことを続けていれば、最終的には収入のすべてが利息の支払いに消え、実質的な購買力はゼロになってしまうでしょう」「負債というメタファーの本質は、その返済能力にあります。これをうまく活用できるかどうかは、問題を理解した時点でリファクタリングできるような、きちんと構造化されたコードを書けるかどうかにかかっているのです」技術的負債に抱く多くの人のイメージはネガティブなものですが、Cunningham氏の説明にはそのようなニュアンスはありません。彼はあくまで「リファクタリング可能な十分に設計されたコード」を前提に話しており、「不摂生により病気になってしまった」ようなネガティブな状況ではなく、「成長して身体に合わなくなった服や靴を替える」ような状況をイメージしていたのです。乱雑なコードは技術的負債なのか？『Clean Architecture』などのCleanシリーズでお馴染みのRobert C. Martin氏（通称ボブおじさん）は、技術的負債と単なる乱雑さを明確に区別しています。「乱雑さは技術的負債ではありません。乱雑さはただの乱雑さです。技術的負債は意識的な選択の結果であり、戦略的な理由から生じるものです。リスクはあっても将来的な価値があります。一方、乱雑なコードを作る決断は合理的ではなく、ただの怠慢と不注意から生じるものであり、将来的な価値はありません」Martin氏も、Ward Cunningham氏と同様に雑なコードには賛成しておらず、「技術的負債は戦略的に選択されるものであり、単なる乱雑さとは異なる」と強調しています。技術的負債の多角的理解Martin Fowler氏は技術的負債の四象限という概念を提唱し、「無鉄砲／慎重」と「意図的／不注意」という二つの軸で負債を分類しました。この四象限フレームワークは、技術的負債をより体系的に考えるための重要なツールです。例えば「慎重・意図的」な負債は、ビジネス価値を早期に提供するための意識的な選択である一方、「無鉄砲・不注意」な負債は単に悪い設計の結果として発生します。Fowler氏によれば、技術的負債の議論において重要なのは次の点です。「設計上の問題が負債に当たるかどうかを議論するよりも、負債というメタファーがその問題を考えたり議論したりする助けになるかどうかを考えるべきです。このメタファーの大きな利点は、技術者以外の人々にも理解されやすい点にあります」また、Fowler氏は別の記事TechnicalDebtでも技術的負債について考察し、次のような洞察を提供しています。「品質の低いコードは、驚くほど早く影響を及ぼします。緊急の機能追加が遅延するのです。技術的負債を蓄積したチームは、コード品質の向上に時間をかけたチームよりも、結果的に開発のペースが落ちてしまいます」これは技術的負債の重要な側面を示しています。負債の影響は将来の問題だけでなく、すぐに現在の開発速度にも影響を与えるのです。技術的負債は本質的に技術的問題というよりもトレードオフの意思決定問題です。負債のメタファーはソフトウェア開発の状況を非技術者にも説明しやすくする点で有用ですが、全ての状況に当てはまるわけではありません。金融の負債に対する理解は人によって異なり、ソフトウェア開発のすべての側面を金融の仕組みで説明することには限界があります。本書「Taming Your Dragon」では、技術的負債の本質、その影響、そして効果的な管理方法について詳しく解説されています。短期的な利益（機能の早期リリース）と長期的なコスト（保守性の低下）のバランスをどう取るべきか、組織全体でどのように技術的負債に取り組むべきかなど、実践的なアプローチが示されています。心の準備はいいですか？ nwiizoと同じように、コードの迷宮へと足を踏み入れる勇気を持ちましょう！Part I Exploring Technical Debt1. What Is Technical Debt?基本概念の再定義技術的負債は本質的に技術的問題ではなくトレードオフの意思決定問題です。Technopediaによれば「容易だが限定的な解決策を選択した際に発生する将来的な再作業のコスト」と定義されます。つまり、単なる「悪いコード」ではなく、短期的利益（機能追加や早期納品）と長期的コスト（保守性低下）の間の意識的選択の結果です。Taming Your Dragon: Addressing Your Technical Debt (English Edition)作者:Brown, Dr. Andrew RichardApressAmazon昨今のソフトウェア開発現場では、何か問題が発生すると「技術的負債のせいだ」と安易に結論づける風潮が見られます。しかし、この「技術的負債」という言葉が本来の意味から逸脱し、単なる言い訳や責任転嫁の道具になっていないでしょうか。すべての問題が技術的負債に起因するという考え方は、複雑な開発現場の実態を過度に単純化している可能性があります。実際には、プロジェクト管理の不備、要件定義の曖昧さ、あるいは単純な実装ミスなど、多様な要因が問題の背景に存在することが多いのです。技術的負債の玉ねぎモデル著者が提案する多層構造モデルは、技術的負債を複数の層で捉えます。Figure 1-1 The technical debt onion model より引用テクニカル層はコードやアーキテクチャの問題、トレードオフ層は個人の意思決定メカニズム、システム層は組織構造の影響、さらに経済学/ゲーム理論層と厄介な問題層（複雑で一義的解決策のない問題）があります。このモデルが示唆するのは、技術的負債を持続的に管理するには全ての層に取り組む必要があるということです。表面的な修正だけでは、時間の経過とともに元の状態に戻ってしまいます。技術的負債の分類法Fowlerの4象限（慎重/無謀 × 意図的/無意識的）は代表的な分類です。Figure 1-2 The technical debt quadrant より引用金利率による分類も実用的です。高金利負債は放置すると急速にコスト増大する領域、低金利負債は影響が限定的な領域、無金利負債は実質的な影響がない領域です。レベルによる分類では、アーキテクチャ負債（最もコストが高い）、コード負債、その他の負債に区分されます。SDLCステージによる分類はどの開発段階で負債が発生したかを示し、トレードオフの種類による分類は何と引き換えに負債を受け入れたかを明らかにします。負債管理の実践的アプローチ高金利負債から優先的に返済することが重要です。頻繁に変更される中核コンポーネントの負債を最優先すべきです。技術的負債の影響を経営層が理解できる言葉で表現することも効果的です。「このリファクタリングを後回しにすると保守コストが20%増加します」など、具体的な数字で示すと説得力が増します。がこのときにはやはり数字的な根拠が必要です。組織構造の影響を理解することも大切です。コンウェイの法則を認識し、部門横断的視点で負債を可視化する必要があります。継続的な管理プロセスを確立することも不可欠です。単発の対処ではなくシステムとしての改善が求められます。まとめ技術的負債を効果的に管理するには、技術者だけでなく、マネージャーやステークホルダーを含めた組織全体の協力が必要です。単一のモデルや手法に頼るのではなく、複数の視点を統合し状況に応じて適切なアプローチを選択できるアダプティブな姿勢が鍵となります。2. Why You Need to Address Technical Debt負債の二面性を理解する技術的負債は必ずしも「悪」ではないです。著者は金融負債との類似性を指摘し、適切に管理された技術的負債が組織に価値をもたらす場合もあると説明しています。家を購入するためのモーゲージのように、戦略的に活用すれば事業価値を生み出すことができるのです。しかし、「返済できない負債」「より良い代替手段がある場合」「間違った資金調達を選んだ場合」には問題が発生します。この金融アナロジーは非技術系の経営層にも理解しやすく、共通認識を築く上で役立つと感じました。『良い戦略、悪い戦略』は技術的負債の考え方と深く関連しています。ルメルトが説く「良い戦略」の本質—正確な診断、明確な指針、一貫した行動—は、技術的負債の管理にも直接応用できます。「良い負債」は明確な目的と返済計画を持つ戦略的選択であり、「悪い負債」は単なる近視眼的回避策です。ルメルトが強調する「選択の重要性」は、技術的リソースの配分や優先順位付けにおける難しい決断と共鳴します。技術的負債を単なる技術問題ではなく、組織の戦略的選択として捉える視点を提供する一冊です。良い戦略、悪い戦略 (日本経済新聞出版)作者:リチャード・Ｐ・ルメルト日経BPAmazon長期的影響の驚くべき事例著者が紹介する「スペースシャトルの設計が古代ローマの馬車の車輪幅に影響された」という事例は衝撃的でした。この例えは初期の技術的決定が予想をはるかに超えて長期間にわたり影響するという重要な教訓を伝えています。私自身も過去のプロジェクトで、初期データモデルの制約が何年も後の開発に影響し続ける状況を経験しました。アーキテクトとして、目前の問題解決だけでなく未来の開発者の自由度を考慮する責任があると再認識しました。企業競争力への致命的影響Netscape Navigatorの例は技術的負債の危険性を如実に示しています。80%の市場シェアを持ちながら、負債対処のための完全な書き直しで3年もの遅延が発生し、市場を失った事例は「技術的負債における破産宣告」として説得力があります。著者が経験したHMVでの事例も興味深く、プロジェクト工数の約1/3が技術的負債対応に費やされていた実態には驚かされました。特に設計段階ではなく「コーディング段階」で発見される予期せぬ負債が問題となり、短期的な回避策が長期的な負債増大につながるという悪循環が明確に説明されています。技術的負債がもたらす「六つの悪魔」著者が挙げる負債の影響は現場感覚に近く、共感できました：追加コスト - すべてのプロジェクトで負債対応のコストが発生開発テンポと納品の遅延 - 予定どおりの進行が困難になる予測可能性の低下 - 不明確な負債状況が見積もり精度を下げる非現実的なスケジュール - 「技術から遠い人ほど正確な数字を要求する一方で技術的負債に無頓着」という指摘は的確プロジェクト中止 - 負債返済コストが事業価値を上回り計画が頓挫負債のスパイラル - 遅延挽回のために更なる負債を生み出す悪循環特に負債の影響が線形ではなく、ある閾値を超えると急激に開発効率が低下するという点は実務経験とも合致し、説得力がありました。組織的問題としての技術的負債本章で最も重要な気づきは、技術的負債は技術的問題以上に組織的な問題であるという点です。HMVの事例から、意思決定プロセス、予算サイクル、部門間連携の重要性が浮き彫りになります。プロジェクトが遅れると意思決定者がリスクを取りがちになる心理的変化や、部門間のコミュニケーション不足がもたらすアーキテクチャの不整合など、組織的な要因が技術的負債を増大させる構造が明確に示されています。まとめこの章から得られた実践的な提言として、以下の点を自分のプロジェクトに取り入れたいと考えます。負債の可視化と測定による共通理解の促進継続的なリファクタリングを日常的な開発サイクルに組み込む文化の構築「良い負債」と「悪い負債」を区別する戦略的な負債管理組織全体の課題として取り組む組織的アプローチの採用「馬の尻幅」の影響が2000年続いたように、今日の技術的決定は将来に大きな影響を及ぼすという教訓は、アーキテクトとしての責任を再認識させる貴重な気づきでした。3. Why Has Technical Debt Proved So Resistant to Solutions?技術的負債への誤解多くの組織が技術的負債を単なる「技術的問題」として捉える誤解が本章の核心です。著者は「暗闇で鍵を失くした酔っ払いが街灯の下だけを探す」という例えを用いて、私たちが解決策を間違った場所で探していることを鋭く指摘しています。ソフトウェアアーキテクトとして、この指摘に強く共感します。日々の業務でチームが「このコードは技術的負債だから修正しよう」と議論するとき、多くの場合「悪いコード」を直すことだけに注力し、なぜそのコードが生まれたのか、背景にあるトレードオフの判断や組織的要因を見落としがちです。また過信効果（overconfidence effect）の指摘も的確です。技術的負債を金融負債のアナロジーで理解しているため、実際より理解していると錯覚し、深い探求を怠ることがあります。ライト、ついてますか　問題発見の人間学作者:ドナルド・C・ゴース,ジェラルド・M・ワインバーグ共立出版Amazon技術的負債ライフサイクルの誤認著者が提示する技術的負債のライフサイクル図は非常に啓発的でした。Figure 3-1 Technical debt life cycle, starting from when it is created より引用一般的な理解（Figure 3-1）では、技術的負債の作成から始まるライフサイクルを想定していますが、これは不完全です。Figure 3-2 Technical debt life cycle, beginning with events that led to its creation より引用著者が示す完全なライフサイクル（Figure 3-2）では、組織構造の作成→プロジェクトの見積もり→プロジェクトの遅延といった前半部分が無視されていることが明らかになります。私自身の経験でも、技術的負債はコードが書かれるずっと前から、不適切な見積もりや無理なスケジュール、チーム間の不十分なコミュニケーションなどにより発生しています。にもかかわらず、多くの組織は「悪いコード」だけを見て、「なぜ開発者はこんなコードを書いたのか」と問い、真の原因を見逃しています。近因と究極因の区別著者の「近因（proximate cause）と究極因（ultimate cause）」の区別についての議論は大変示唆に富んでいます。事故調査の例を用いて、近因（心臓停止）と究極因（飲酒運転）を区別する重要性を説明していますが、これは技術的負債の分析にも当てはまります。究極因を追求することが技術的負債対策の本質だという指摘は核心を突いています。「5つのなぜ」テクニックを用いて深く掘り下げることで、表面的な「悪いコード」という近因を超え、組織構造や意思決定プロセスといった根本原因に到達できます。実務では、近因で分析を終わらせることが多いのは、責任の所在が明確になり、組織の自己反省を避けられるという「便利さ」があるためです。しかし、これでは同じ問題が繰り返し発生することになります。「重要だが緊急ではない」問題としての技術的負債アイゼンハワー大統領の「私には2種類の問題がある：緊急なものと重要なもの。緊急なものは重要ではなく、重要なものは決して緊急ではない」という言葉を引用した著者の分析は、技術的負債の優先順位付けの難しさを見事に表しています。技術的負債は典型的な「重要だが緊急ではない」問題です。著者の本の執筆（重要だが締め切りまで9ヶ月ある）と会議の資料作成（重要性は低いが数日後に必要）の比較は、緊急性が優先順位付けを支配する現実を示しています。私のチームでも、新機能開発やバグ修正などの「緊急」タスクが、リファクタリングやアーキテクチャ改善より常に優先されます。技術的負債が十分に蓄積されてシステムが機能不全になってようやく「緊急」問題となりますが、その時には対処コストが膨大になっています。成果が見えにくい技術的負債対策「誰も起こらなかった問題を修正したことに対して称賛されることはない」というネルソン・レペニングの言葉は、技術的負債対策の本質的な困難さを表しています。技術的負債削減の効果はすぐには現れず、多くの領域に分散するため、明確に債務削減プログラムに起因するものとして認識されにくいのです。また恩恵を受ける側も、そのメリットを認識せず、あるいは自分たちの努力の結果と捉える傾向があります。大規模リファクタリングプロジェクトを実施しても「何も変わっていない」と評価された経験は、多くの開発者が共感するでしょう。「問題が発生しなかった」ことを証明するのは非常に難しいのです。「銀の弾丸」が存在しない現実フレッド・ブルックスの「人月の神話」を引用した著者の指摘は的確です。技術的負債削減には「銀の弾丸」は存在せず、前払いの努力と投資が必要なのです。技術的負債の中心的な問いは「技術的負債を減らしたいですか？」ではなく「将来の技術的負債負担を減らすために今日何を犠牲にする準備がありますか？」という点にあります。この視点の転換は非常に重要です。現代のソフトウェア開発では、新フレームワークやAIなど「銀の弾丸」として喧伝される解決策が次々と現れる中で、地道な技術的負債対策は地味に見えがちです。しかし、真の改善には継続的な取り組みが不可欠なのです。技術的問題として捉えたい心理「We Desperately Want Technical Debt to Be a Technical Problem」というセクションは、私たちの心理を鋭く突いています。マネージャーや経営陣は技術的負債を技術的問題として捉えることで、「エキサイティングな」新規イニシアチブに集中できます。技術者も、現在のトレードオフ決定の一部として認めるよりも「後で対処する問題」として先送りしたいのです。この心理は痛いほど身に覚えがあります。ビジネス側は「スコープクリープを許可した決定」や「見積もりの甘さ」による影響を認めたくなく、技術者も「ビジネス側の圧力」を責任転嫁の理由にする傾向があります。技術的負債を組織全体の共同責任として捉え改善していく視点が必要だという著者の提言は、深く共感します。変化管理としての技術的負債対策技術的負債削減の取り組みが組織変革の一種であるという著者の指摘は非常に重要です。大きな改善を得るためには技術的負債が作られる原因に焦点を当てる必要があります。組織構造やトレードオフ決定のプロセス、プロジェクト見積もりの方法などに対処する必要があるのです。この視点は私のアプローチを変えました。技術的負債対策を単なる技術的改善ではなく組織変革として捉え、変化に対する抵抗を予測し対処する計画を立てることの重要性を認識しました。総括と実践への示唆本章から得た最も重要な教訓は、技術的負債を単なる技術的問題ではなく、組織的課題として捉える必要性です。技術的負債への効果的な対処には：技術的負債の真の性質と根本原因への理解を深める組織全体の問題として認識し、全体で取り組む変化管理の手法を取り入れ、抵抗に対処する成果を可能な限り可視化し、継続的な取り組みのモチベーションを維持するこれらの教訓を自分のプロジェクトに適用し、技術的負債に対するより効果的なアプローチを構築していきたいと思います。Part II Understanding the Technical Debt Problem4. The Broken Analogy問題理解におけるアナロジーの役割アナロジー（類推）は複雑な問題を理解する強力なツールです。著者はヨハネス・ケプラーの例を挙げ、惑星運動の法則発見までの道のりで、彼が熱、光、磁気力、渦巻く水流など様々なアナロジーを試し、検証し、限界を見極めていった過程を紹介しています。ケプラーの方法論で重要なのは、単一のアナロジーに固執せず、複数のアナロジーを「容赦なく検証」し、より良いものを見つけては前のものを捨てる姿勢です。著者はこれを技術的負債への我々のアプローチと対比し、「金融負債へのアナロジーの欠陥を容赦なく検証し、より良いアナロジーのために捨てているだろうか？」と問いかけています。著者は良いアナロジーには「親しみやすさ」と「代表性（正確さ）」のバランスが必要と指摘します。この観点から評価すると、技術的負債の金融負債アナロジーは「親しみやすいが正確性が低い」象限Aに位置します。ビジネス関係者の初期理解には役立つものの、誤解を招く恐れがあるのです。特に上記のアナロジーに関する議論と関連して、本書は抽象化によって本質を見抜き、具体例を通じて理解を深める方法を提供しています。ケプラーが様々なアナロジーを試し、捨て、より良いものを見つけていったプロセスは、まさに具体と抽象の間を行き来する思考法の実践例といえるでしょう。具体と抽象作者:細谷 功dZERO（インプレス）Amazon金融負債アナロジーの限界金融負債アナロジーがビジネス関係者の理解を助けた理由は、「財務」がビジネスの共通言語であることと、多くの人が個人的に金融負債を経験していることにあります。このアナロジーが正しく機能する側面として：- 返済が通常必要である- 時間とともにコストが増大する- その存在が他の活動を制限する- 高レベルの負債は深刻な負担となるしかし問題は、「私たちが正確性よりも理解のしやすさを優先した」ことにあります。著者はより正確な技術的負債の例えとして「特殊な車のローン」を提案しています。このローンでは借りた金額がわからず、返済時期も不明確で、金利も部分によって異なり、返済計画は外部イベントに左右され、さらに親族にはクレジットカードが無料配布されるという恐ろしいものです。代替アナロジー：肥満問題著者が提案する最初の代替アナロジーは「肥満問題」です。肥満は技術的負債と次の点で類似しています。直接的・間接的な影響：肥満は直接的（余分な体重による機械的ストレス）または間接的（ホルモンや代謝の変化）に影響します。技術的負債も同様に直接的（修正作業）または間接的（経済的に成り立たなくなるプロジェクト）に問題を引き起こします。自己強化的性質：極度の肥満は運動能力を低下させ、さらに肥満解消を困難にします。高レベルの技術的負債も同様に自己強化的になります。根本的な誤解：1970年代の肥満対策は脂肪摂取量の削減に焦点を当て、食品業界は脂肪を減らす代わりに糖分を増やした結果、肥満は増加しました。技術的負債も同様に、要因を技術的なものだけと考えると、特定の要因を監視する一方で他の要因を見逃すリスクがあります。肥満アナロジーからは「システムマッピング」という有用なツールも得られます。イギリス政府の肥満問題への「システムアトラス」アプローチは、技術的負債の異なる側面を地図化する際にも応用できるでしょう。その他の代替アナロジー環境汚染アナロジーは、「汚染を生み出す決定をする者とその恩恵を受ける者が同一である一方、その結果に苦しむ者は決定に関与していない」という重要な洞察をもたらします。技術的負債も同様に、負債を生み出す決定をする人は恩恵を受けますが、対処コストを負担するのは別の人々です。依存症アナロジーでは、著者は「技術的負債を増やす結果をもたらす行動への依存」を指摘します。例えば納期を守るために技術的負債を増やす決断を繰り返し、その悪影響を認識しながらも止められない状態です。摩擦アナロジーはフォン・クラウゼヴィッツの「戦争論」から取られています。クラウゼヴィッツは「戦争では全てが単純だが、単純なことが難しい」と述べ、戦場での摩擦を「無数の小さな困難の蓄積」と説明しました。技術的負債の影響も同様に、最も単純なタスクさえ困難にします。クラウゼヴィッツは摩擦は常に存在し完全に排除できないものだと指摘しつつ、最小化する努力を怠るべきではないと主張しました。この洞察は技術的負債管理にも当てはまります。複数アナロジーの実践的活用この章から得た最も重要な教訓は、単一のアナロジーに縛られず、複数の視点から技術的負債を理解する必要性です。技術的負債はその「玉ねぎモデル」が示すように多層的な問題であり、各層には異なるアナロジーが適しているのです。私の実務経験からも、ビジネス関係者との初期対話では金融アナロジーを使いつつ、より深い議論では段階的に他のアナロジーを導入することが効果的だと感じています。例えば：技術的負債を予算化する際には金融アナロジー負債の蓄積メカニズムを説明する際には依存症アナロジー開発プロセスへの影響を説明する際には摩擦アナロジー技術的負債のトレードオフを議論する際に異なるアナロジーを意識的に使い分けることで、より生産的な議論が可能になります。例えば「この機能を期限までに実装するために技術的負債を受け入れるか」という古典的なトレードオフを、単に「借金を増やすか」としてではなく、「システムを肥満させるか」「摩擦を増やすか」「汚染物質を放出するか」といった多様な視点から検討することで、より豊かな議論が可能になります。複数のアナロジーを使いこなせるアーキテクトは、技術チームとビジネス側の双方と効果的にコミュニケーションを取り、組織全体で技術的負債に対する共通理解を形成することができるでしょう。それこそが継続的な技術的負債管理への第一歩となります。5. Technical Debt As a Trade-Off Problem技術的負債と人間の意思決定メカニズム技術的負債は単なる技術問題ではなく、人間の意思決定メカニズムに根ざしたトレードオフ問題です。著者は技術的負債の「玉ねぎモデル」の第2層である「トレードオフ層」を詳細に分析し、特に「アフェクト・ヒューリスティック」と呼ばれる感情に基づく直感的判断の影響を掘り下げています。私たちの意思決定能力は進化の過程で発達したものです。祖先が直面していた環境では「速さ」「質の低い情報でも機能すること」「認知的負荷が低いこと」が重要でした。これにより私たちの意思決定の大部分は無意識下で行われるという重要な特性が生まれました。意識的な論理的思考はあまりにも遅く、情報処理に限界があるためです。カーネマンの「ファスト&スロー」は人間の思考を「システム1」（速い、直観的）と「システム2」（遅い、論理的）に分類しています。技術的負債の文脈では、即時の問題解決を優先するシステム1の思考が、長期的な技術的健全性より優先されがちです。時間や認知的制約から、多くの技術的決断は直感に頼ることになり、これが技術的負債の発生につながります。この人間の意思決定メカニズムを理解することが、技術的負債への効果的な対策に重要です。ファスト＆スロー　（上）作者:ダニエル カーネマン,村井 章子早川書房Amazonアフェクト・ヒューリスティックの重要性アフェクト・ヒューリスティックは、現在の感情的印象を利用して意思決定を導く心理的ショートカットです。私たちが「直感」や「腹の感覚」と呼ぶものの正体です。このヒューリスティックの重要な特性は①感情を用いること②「感覚」を通して行動を仲介すること③高速であること④変化に抵抗し経験を通してのみ変化すること⑤意識的評価が不可能であることです。私たちが論理的な決断をしていると思っていても、実際には感情的システムがすでに決断を下しており、理性はただそれを正当化しているに過ぎないのです。技術的負債の蓄積を促す意思決定の非対称性著者が提示する例は非常に示唆的です。プロダクトオーナーが技術的負債を増やす新機能を開発するかどうかを決断する場面で：機能開発を選択した場合の利益は「即時的」「確実」「具体的」「自分が経験する」「感情的」という特性を持ちます。これらは強い感情的印象を生み出し、アフェクト・ヒューリスティックに強く影響します。対照的に、技術的負債を避けることの利益は「将来的」「不確実」「無形」「他者が経験する」「理性的」という特性を持ちます。これらは感情にほとんど訴えず、理性的システムにのみ響きます。この非対称性によって、意思決定において技術的負債の側面がほとんど考慮されないという問題が生じます。これが技術的負債が過度に蓄積する構造的要因の一つであり、私自身のプロジェクト経験とも強く共鳴します。喫煙予防プログラムからの教訓喫煙予防プログラムの事例は技術的負債管理に重要な示唆を与えます。当初の論理的なメッセージは効果が限定的でしたが、タバコパッケージに喫煙の生々しい害を視覚的に表現するなど、感情に訴えかける戦略に転換して初めて成功しました。喫煙の利益と害の構造は技術的負債のトレードオフと全く同じです。この教訓から、技術的負債を避ける決断に影響を与えたいなら、論理よりも感情に訴えかける必要があると理解できます。精密さと価値の問題著者が導入する「精密さ」と「価値」の概念も重要です。音楽辞典の例を用いて、比較可能な状態では内容を重視し、比較できない状態では精密に評価できる表面的な属性に重きを置く傾向があると指摘しています。新機能や早期納品の利益は高い精密さをもって評価できますが、技術的負債の回避による利益は精密さを欠いています。このため、不確実で無形な技術的負債の重要性が過小評価されがちなのです。チャレンジャー宇宙船事故の例からも、精密に表現できない懸念が無視される危険性が理解できます。これは技術リーダーとして、技術的負債の影響をより具体的かつ精密に表現する工夫が必要だと強く感じさせる部分です。技術的負債管理のための実践的アプローチ著者が紹介する「ユリシーズ契約」は非常に実践的です。将来の自分を特定の状況下で拘束するための事前のコミットメントとして、例えばスプリント中に生じた技術的負債が閾値を超えた場合、次のスプリントに返済タスクを含めることを事前に約束する方法は、すぐに実践できそうです。「同時決定vs連続決定」の概念も興味深いです。複数の決定を同時に行うと、多様化バイアスにより健康的な選択肢（技術的負債の返済）を含める傾向があるという指摘は、スプリント計画の改善に応用できそうです。また、プロジェクトの状況がリスク選好に与える影響についての洞察も重要です。プロジェクトがスケジュール通りの場合はリスク回避的、遅延している場合はリスク追求的になるという傾向は、日々のプロジェクト管理で強く実感するところです。6. Technical Debt As a Systems Problemシステム思考による技術的負債の理解技術的負債は単なる技術的問題ではなく、組織的なシステム問題として捉えるべきです。第6章では、「玉ねぎモデル」の「システム層」に焦点を当て、組織内のシステム構造と個人の役割がどのように技術的負債の蓄積に寄与するかを分析しています。Figure 6-1 The technical debt onion model より引用著者はドネラ・メドウズの定義を引用し、システムを「一貫して組織化され相互接続されたパターンまたは構造で特徴的な一連の振る舞いを生み出す要素または部品の集合」と説明します。システムの振る舞いは外部要因よりも内部構造によって決定されるという点が重要です。ソフトウェア開発の文脈では、プロジェクトチームや組織構造自体もシステムとして捉える視点が必要です。ITシステムと社会システムの決定的な違いは、社会システム内のコンポーネント（個人）が「独自の目標を追求する能力」を持つことです。この違いはシステムの複雑性と予測不可能性を大幅に増大させます。企業変革のジレンマ　「構造的無能化」はなぜ起きるのか (日本経済新聞出版)作者:宇田川元一日経BPAmazon生物学の例から学ぶシステム的視点Y染色体と胎盤の関係という生物学的例は、目標が競合するシステムコンポーネントがどのように予期せぬ結果をもたらすかを説明しています。一夫多妻制と一夫一婦制のマウスの交配実験は、ソフトウェア開発に直接的な類推を持ちます。プロジェクト（胎児）は最も有利な状態で「生まれる」ことを望み、組織的リソースを最大限に得ようとします。一方で組織（母親）はシステムを維持し将来的な機能を提供し続けるために健全な状態を保とうとします。この拮抗する目標がバランスを崩すと技術的負債の過剰な蓄積につながるのです。「過剰と崩壊」のパターン著者は技術的負債問題の中心に「過剰と崩壊」というパターンがあると主張します。これは再生可能なリソースが持続可能なレベルを超えて利用され、回復不可能なほど枯渇する状態です。古代文明の崩壊や商業漁業における乱獲と同様のパターンがソフトウェア開発にも現れます。ソフトウェア開発における「過剰」とは、タスク完了率の持続不可能なレベルへの引き上げを意味します。プロジェクトが圧力を受けると、補助的活動（良質な要件作成、効果的なテスト、過度な技術的負債の回避など）が放棄されるか最小限に抑えられます。これにより一時的な見かけ上の進捗改善がありますが、長期的には効率の低下と「消火活動モード」と呼ばれる状態への転落を招きます。過剰と崩壊は特に危険です。なぜなら一度崩壊が始まると回復は非常に困難だからです。北海のタラ資源が崩壊すると漁業をすべて停止しても回復しないかもしれないように、プロジェクトが消火活動モードに陥ると、技術的負債の蓄積を止めても既存の負債が残存し回復を妨げるのです。役割による制約と技術的負債著者はシェイクスピアの「世界は舞台、人は皆役者」という言葉を引用し、私たちがソフトウェアプロジェクトにおいて独立した個人としてではなく「役割を演じる人」として意思決定を行うことを指摘します。個人は組織の長期的な利益に反すると認識していても、その役割に合致した決定を下すよう制約されることがあります。プロジェクトマネージャーは締め切りを守るプレッシャーから、長期的な技術的負債を増やす決断をせざるを得ないことがあります。同様に開発者も技術的負債を溜めることの長期的な影響を理解していても、スケジュールプレッシャーから短期的な解決策を選ばざるを得ません。特に重要なのは「基本的帰属の誤り」と呼ばれる認知バイアスです。私たちは他者の行動を彼らの状況や役割ではなく性格に帰属させがちですが、多くの場合、技術的負債を増やす決断は個人の性格ではなく、システム内の役割による制約によるものなのです。プロジェクト見積もりと技術的負債技術的負債の増加に大きく寄与する要因の一つはプロジェクトの過小評価です。著者は入札プロセスの構造がいかに過小評価を生み出すかを説明します。評価チームは可能な限り低い見積もりを望み、入札チームは競争に勝つために最低の入札を提出しようとします。この相互作用は不現実な見積もりを生み出し、プロジェクトの遅延と圧力の増加につながります。過小評価されたプロジェクトは二つの問題に直面します。一つはスケジュールの遅れであり、これは圧力と補助的活動の放棄を引き起こします。もう一つは「フィクション」の創造です。プロジェクト関係者の多くは見積もりが間違っていることを認識していますが、その事実を公に認めることを避けるため、フィクションが維持され、重要な問題が無視されることになるのです。政策抵抗と意図せぬ結果著者は「政策抵抗（policy resistance）」という概念を紹介します。これはシステム内のアクターがルールやポリシーを回避する方法を見つけたり、ポリシー変更によって意図された利益を無効にするような行動を取ることを指します。英国政府の「20%の追加見積もり」政策の例は示唆に富んでいます。この政策に対する抵抗は、まず元の見積もりが約20%削減されてから20%が追加され、結果として提出される見積もりは以前とほぼ同じになります。次に「20%の余裕がある」という誤った認識が生まれ、機能の追加（スコープクリープ）を促進し、結果としてプロジェクトはさらに予算超過と遅延に陥るのです。システム思考なしで導入される政策がいかに期待と反対の結果をもたらすかを示す重要な例です。技術的負債登録簿を確立・維持することが実際には技術的負債の減少ではなく増加につながる可能性があるという反直感的な発見も同様の原理によるものです。システム思考による技術的負債管理技術的負債に対するシステム思考を実践するために、著者はいくつかのアプローチを提案しています。組織構造の見直し：役割間の目標の対立を最小化し、組織全体の長期的目標と個人の目標を整合させる過小評価を避けるメカニズム：見積もりプロセスと入札/選択プロセスを分離し、より現実的な見積もりを促進する補助的活動の価値を可視化：リファクタリング、自動テスト、ドキュメンテーションなどの活動の価値を示すメトリクスを導入「過剰と崩壊」のサインを早期に検出：技術的負債の増加率、バグ発生率、機能実装時間などの指標を追跡この章から得られる最も重要な洞察は、技術的負債の蓄積を促進しているのは個人の意思決定ではなく組織システムの構造であるという理解です。短期的な生産性向上のために補助的活動を放棄すると、長期的には持続可能性の低下と崩壊を招きます。技術的負債管理は単なる技術的な問題解決ではなく、組織全体のシステム設計の問題として取り組むべきなのです。7. Technical Debt As an Economics Problem経済学的視点による新たな洞察技術的負債を経済学の視点から分析することで新たな洞察と解決策が得られるというのが本章の核心です。著者は「玉ねぎモデル」の「経済学またはゲーム理論の層」に焦点を当て、八つの経済学的問題を通して技術的負債の根本的要因を探っています。Figure 7-1 The technical debt onion model より引用経済学的視点を採用する三つの利点として、新鮮な視点による新たな洞察の獲得、1776年のアダム・スミス以来蓄積された膨大な経済学の知見の活用、そして上級ステークホルダーとの共通言語の確立が挙げられています。「経済学は共通の権威ある言語を提供する」という著者の主張に強く共感します。技術チームが「あの人が作業をサボったせいでバグが増えた」といった非難の応酬をしても生産的な解決には至りません。しかし「これはプリンシパル・エージェント問題の一例で情報の非対称性と利害の不一致から生じている」と分析すれば、冷静な議論と建設的な対策が可能になります。企業変革のジレンマ　「構造的無能化」はなぜ起きるのか (日本経済新聞出版)作者:宇田川元一日経BPAmazonプリンシパル・エージェント問題プリンシパル・エージェント問題はエージェント（代理人）がプリンシパル（依頼者）の代わりに行動する際に生じる利害や優先事項の対立を指します。この問題が発生するには「利害の不一致」「情報の非対称性」「プリンシパルがエージェントに影響を与える手段の欠如」のうち少なくとも一つが存在する必要があります。技術的負債の文脈では「利害の不一致」と「情報の非対称性」が特に顕著です。負債のないコードを書くことはプリンシパル（ステークホルダー）にとって有益ですがエージェント（開発チーム）にとっては追加の労力を要します。また多くのステークホルダーやプロジェクトリーダーは技術スキルや経験が不足しているため情報の観察が困難です。複数のプリンシパルが存在する場合この問題はさらに複雑になります。マトリックス管理やビジネス部門、プロジェクトサポートとメンテナンスオペレーション、アーキテクチャチームなど複数のステークホルダーが関与するプロジェクトでは「集合行動問題」が発生します。解決策として「自分の作ったドッグフードを食べる」アプローチがあります。開発チームが通常のハイパーケア期間を超えて自分たちのコードをサポートし維持する責任を持つことで、利害の一致を促進できます。コモンズの悲劇コモンズの悲劇は限られた共有資源の過剰使用に関する概念です。共有地を利用する牧畜業者は新たな動物を追加すると個人はその動物からの利益をすべて享受する一方で、共有地へのダメージはすべての人に分散されます。そのため各牧畜業者が個別に合理的な選択をすると共有地は劣化または破壊されてしまいます。技術的な資産を「コモンズ」とみなすと、組織は同様のジレンマに直面します。各関係者は高品質で負債の少ない技術資産を重視しますが、負債を増やす行動から多くの価値を得ることもできます。例えばプロダクトオーナーがテスト削減の代償として追加機能を詰め込んだり、開発者がコードを再利用する代わりにコピー＆ペーストしたりする行為です。この問題に対する解決策の本質は、すべての技術的資産の明確な所有権を確立することです。また適切な組織文化と社会規範があると、個人は協力してより良い解決策を見つける傾向があります。外部性の問題外部性は一方の当事者が他方の当事者に対しコストや便益を押し付けることができる状況を指します。一般的な例は汚染です。自動車は健康被害というコストを都市住民に押し付けます。著者の元同僚のプロジェクトマネージャーの「それは私の問題じゃない！」という発言はまさに外部性を示しています。このマネージャーは他者に外部性を押し付けることができ、相手はそれを阻止する力がないことを示していました。著者はHMVでの製品を複数のジャンルで表示するプロジェクトを例に挙げます。重複テーブルを作成するという解決策はステークホルダーがプロジェクトチームに押し付けた外部性の例です。クリスマスコードフリーズ前にプロジェクトを完了できましたが、サポートチームに週次データ取り込みのための開発者の時間という継続的な外部コストが課されました。解決策は技術的資産の周囲でより良い財産権を定義し、外部性とは何かについての認識を高めることです。短期主義の影響短期主義は「将来への影響よりも現在の利益や利点だけを考慮する思考や計画の方法」です。外部性とは異なり、コストを課す者と負担する者が同じ当事者である点が特徴です。短期主義は技術的負債と特に関係が深いです。なぜなら負債の返済は常に将来のことであり、便益は通常現在のものだからです。技術的負債項目の返済のコスト便益タイムラインを示したグラフでは、短い期間ではコスト便益曲線が負のままであることが示されています。プロジェクトの期間が短い場合、負債を返済することはプロジェクトにとって価値がありません（組織全体の観点からは価値があるかもしれませんが）。短期主義への対策として、プロジェクトの意思決定者に彼らの視野を現在のプロジェクトを超えて拡大させること、技術的負債のトレードオフ決定を外部関係者ではなく従業員によって行うようにすること、アーキテクチャチームをより多く関与させることが提案されています。小さな決断の専制小さな決断の専制は「個別には小さく重要でない決断の集積が最適でも望ましくもない結果をもたらす現象」を指します。ニューヨーク州イサカの鉄道サービス撤退の例では、多くの乗客が便利な時だけ他の交通手段を選ぶ小さな決断を積み重ねた結果、鉄道は経済的に維持不可能になりました。この問題は特にコーディングに関連しています。開発者は毎回のコード作成や修正時に膨大な数の小さな決断を下します。それぞれの決断は小さなものですが、集合的には大きな意味を持ちます。理想的には重要な決断は階層的な意思決定レベルで行われるべきですが、作業中の実務者が一連の小さな一見無害な決断を行い、結果として重要な決断が事後的に蓄積されることがあります。解決策として、組織の技術アーキテクチャ能力を開発し保護すること、小さな決断の集積が意図しない重要な決断をもたらしていないかコードレビューで確認することが有効です。忍び寄る正常性忍び寄る正常性は「大きな変化や逸脱が小さな漸進的変化を通じて起こるため気づかれない現象」を指します。フォルクスワーゲンの排出ガススキャンダルはこの概念の例です。エンジニアのグループが排出ガス試験などの特定の状況下で排出量を減らすように車のソフトウェアに複数の小さな調整を加えました。ダイアン・ヴォーンはこれを「逸脱の正常化」と呼び、リスクを正当化するための根拠を徐々に調整して増大させることを指します。スペースシャトル・チャレンジャー号の事故もこの例です。技術的負債の文脈では、忍び寄る正常性は「緊急」の問題への対応時に徐々に導入される行動によって起こり得ます。緊急事態が過ぎた後もその行動は元に戻らず、新しい「正常」となります。解決策として「弱いシグナルに注意を払うこと」「不合理に楽観的になる衝動に抵抗すること」「システムオペレーターが安心して発言できること」「監視は終わりのないプロセスであることを認識すること」などが提案されています。アナーキーの代償アナーキーの代償は「システム内のエージェントの自己利益的行動によりシステムの効率がどれだけ低下するかを測定するもの」です。道路交通システムの例では、個々のエージェントが自分のルートを選択できる場合に平均移動時間が増加します。技術的負債に関しても、個人が技術的負債に影響する決断をする際、自分の利益を最大化しますが他者に「増加した移動時間」に相当する負債を残します。極端な場合、アナーキーの究極的な代償はシステムの崩壊です。解決策はアナーキーの代償が高い決断を集中化することです。コーディング標準、技術設計権限、コードレビューポリシーなどの集中的な方針も有効です。モラルハザードモラルハザードは「人々がリスクの全コストを負担しない場合、より多くのリスクを取る状況」を指します。エコノミストのポール・クルーグマンはこれを「ある人がリスクをどれだけ取るかを決定する一方で、物事が悪化した場合のコストを他の誰かが負担する状況」と説明しています。著者は保育所の例を挙げています。保育所は親の遅刻を減らすために罰金を導入しましたが、予想に反して遅刻は増加しました。以前は親は教師との「社会的契約」に基づき遅刻を避けていましたが、罰金システムの導入は社会的契約を取引的なものに置き換え、親はもはや罪悪感を感じることなく遅刻して罰金を支払うことを選んだのです。技術的負債の登録簿を作成すると技術的負債のレベルが減少するのではなく増加する可能性があるというのもモラルハザードの例です。登録簿の作成により負債の作成が正当化され、通常は対処されていたものが登録簿に記載されるようになります。解決策として、組織がソフトウェア開発プロセスの変更を行う前に、それらのプロセスが社会的契約にどの程度依存しているか考慮することが重要です。経済学的視点の活用著者は最後に経済学的問題の活用方法として三つの行動方針を提案しています。各問題に対して提案された解決策を試してみる議論と言語を経済学的なものに変える技術的負債や他のソフトウェア開発問題に対する解決策のためにさらに経済学的パズルを探求する経済学の言語を使用することで、ステークホルダーとの効果的なコミュニケーションが可能になるという点は特に重要です。「外部性」「プリンシパル・エージェント問題」「コモンズの悲劇」といった言葉を使うことで、問題の真の原因とどのように効果的で永続的な解決策を開発するかについての建設的な議論が促進されます。経済学の視点から技術的負債を理解することで、単なる技術的問題としてではなく、組織構造と意思決定プロセスの問題として捉え直す視点が得られるのです。8. Technical Debt As a Wicked Problem技術的負債の最深層技術的負債は単なる技術的問題ではなく、社会的複雑性に起因する「厄介な問題（wicked problem）」であるという視点が本章の中心テーマです。著者はこの「玉ねぎモデル」の最内層に焦点を当て、技術的負債問題が永続化する根本原因を探っています。Figure 8-1 The technical debt onion model より引用冒頭で引用されるジェラルド・ワインバーグの言葉「問題がどのように見えるか、何が問題か、他の人が何と言おうと、それは常に人間の問題である」は、技術的負債の本質を端的に表しています。技術的な問題に見えても、その根底には人間の問題があるのです。気候変動の例は示唆に富んでいます。40年以上認識されながらも効果的な解決に至っていない気候変動は、異なるステークホルダー間で見解が分かれ、単純な解決策が通用しない典型的な厄介な問題です。EU圏内の製造業への排出規制が却って全体の排出量増加につながった事例は、意図せぬ結果をもたらす介入の典型例として技術的負債対策にも重要な教訓を提供します。イシューからはじめよ［改訂版］――知的生産の「シンプルな本質」作者:安宅和人英治出版Amazon厄介な問題の8つの特性著者は厄介な問題と手なずけられた問題を対比しています。クロスワードパズルがどんなに難しくても十分な知識があれば解ける「手なずけられた問題」であるのに対し、技術的負債は「厄介な問題」に該当します。その特性として：問題は解決策を見つけた後でしか理解できない：技術的負債の原因がプロジェクト遅延なのか、誤ったトレードオフなのか、外部性の問題なのかは、解決策を試してみないと見えてこない循環性があります。ステークホルダーは根本的に異なる世界観を持つ：プロダクトオーナーは顧客からの急ぎの要求に重点を置く一方、開発者は技術的負債による制約に囲まれています。この異なる世界観が問題理解を複雑にします。問題の理解の仕方が試す解決策を決定する：各ステークホルダーの世界観によって問題の捉え方が異なり、それに基づいて異なる解決策を提案します。ビジネス側と技術側の分断がここから生じます。解決策は真か偽かではなく良いか悪いかで判断される：技術的負債の解決策に明確な「正解」はなく、各自の世界観に基づいた「より良い」解決策があるだけです。解決策がうまくいったかどうかの即時的で決定的なテストがない：解決策の結果は長期間にわたって現れ、初期には良くても後に悪影響が判明することがあります。あらゆる解決策は「一発勝負」である：厄介な問題への介入は取り返しのつかない結果をもたらすこともあります。厄介な問題は他の厄介な問題と相互に関連している：技術的負債は見積もりやプロジェクト遅延と密接に関連し、互いに循環的に影響し合います。いつ止めるべきかを知る方法がない：問題が十分に理解されているかの明確な基準がなく、多くの場合、時間や予算の制約で対応が中断されます。これらの特性は、技術的負債が単純な技術的修正では解決できない複雑な問題であることを示しています。社会的複雑性と組織的分断著者は「社会的複雑性」の概念を導入し、問題に関わるプレイヤーの数と多様性がさらなる複雑さを生み出すと指摘します。Jeff Conklinの等式「分断 = 厄介さ × 社会的複雑性」が示すように、厄介な問題と社会的複雑性の組み合わせが組織内の分断を引き起こします。単独で問題に取り組む場合、「問題を理解していない」ことは探求の過程として現れますが、複数のステークホルダーが関わると、「理解の欠如」が組織的分断として現れます。この分断を悪化させる要因として「過信効果」と「確証バイアス」が挙げられています。「デザインのジレンマ」として「あるべき姿」と「できること」の間の緊張関係も指摘されています。大規模な組織では「あるべき姿」を追求するグループ（マーケティング、営業など）と「できること」に焦点を当てるグループ（技術系部門）が分断され、互いに対立する文化的戦争が起きやすくなります。この分断の最も確実な指標は「非難」です。技術的負債問題が「統合的な視点」ではなく、互いに責任を押し付け合う「非難文化」として現れる様子が描写されています。解決へのアプローチ著者は厄介な問題への対処法として、「手なずけられた問題のコレクションとして扱う」アプローチの限界を指摘しています。技術的負債登録簿の作成と負債返済チームの設立は一時的な改善をもたらすかもしれませんが、問題は周囲に変形し、長期的な解決には至らない可能性があります。より効果的なアプローチは組織の分断問題に取り組むことです。著者は「共有理解」から「共有コミットメント」へと進む道筋を示しています。共有理解は全員が合意することではなく、互いの立場を十分に理解し、知的な対話ができる状態を指します。この分断への対処ツールとして「ダイアログマッピング」や「議論マッピング」の活用が提案されています。Rationaleなどの議論マッピングソフトウェアを使用して、複雑な問題に関する異なる視点を構造化することで、共有理解の構築を促進できます。技術的負債が単なる技術的問題ではなく、社会的複雑性を持つ厄介な問題であるという本章の視点は、問題の本質理解に大きく貢献します。8つの特性を通じて技術的負債の複雑さを体系的に整理し、問題解決の難しさの根源を「組織的分断」として特定している点は非常に示唆に富みます。特に重要なのは、技術的負債の「社会的複雑性」の側面です。技術的負債を効果的に管理するためには、単に技術的な解決策を見つけるだけでなく、組織全体の協力を促進する「共有理解」と「共有コミットメント」の構築が不可欠です。技術的負債を「人間の問題」として捉え直すことは、この厄介な問題への効果的なアプローチの第一歩となるのです。9. Common Technical Debt Anti-patterns循環するアンチパターンの理解技術的負債は単発的な意思決定ではなく、継続的な決断の連鎖によって蓄積されるという視点が本章の核心です。著者は技術的負債を増大させる10のアンチパターンを因果ループ図を用いて詳細に分析し、効果的な介入ポイントとレバレッジポイントを特定しています。冒頭で紹介される「There's a Hole in My Bucket」という童謡の例えは、技術的負債アンチパターンの循環的な性質を端的に表しています。バケツの穴を修理するという単純な問題が、相互接続した問題の連鎖に発展し、最終的には元の問題に戻るという循環性は、技術的負債問題の本質を示しています。特に重要なのは「後期介入のコスト」という概念です。技術的負債も早期に対処しなければ対処自体が困難になるという悪循環に陥ります。プロジェクトの緊急性を優先してテストコードを後回しにすると、技術的負債返済のためのリソースを確保すること自体が困難になる事例は、多くの開発者が経験していることでしょう。ジェームズ・クリアー式 複利で伸びる1つの習慣作者:ジェームズ・クリアーパンローリング株式会社Amazon因果ループ図の力著者は技術的負債アンチパターンを可視化する手法として因果ループ図（Causal Loop Diagram: CLD）を紹介しています。CLDは変数と因果関係を矢印で表現し、「+」（正の関係）と「-」（負の関係）の記号でその影響を示します。アンチパターンの探索と可視化は三つの面で有益です。問題の理解を深める介入ポイントとレバレッジポイントを特定する異なるステークホルダー間の共通理解を促進する特に共通理解の構築は実務上極めて重要です。技術的負債に関する最大の課題は、ビジネス側と技術側の認識の乖離にあります。技術チームが危機感を持って訴える問題が、ビジネス側には「技術者の完璧主義」と誤解されることが多いからです。見積もり罠見積もり罠（Estimation Trap）は、見積もり誤差→プロジェクト遅延→短期目標への集中→技術的負債の増加→見積もり誤差という自己強化ループを形成します。特に注目すべきは「プロジェクト遅延→短期目標への集中」の接続です。プロジェクトが遅延すると人々の心理状態が「利益」から「損失」のマインドセットに切り替わります。これはプロスペクト理論が示すように、人のリスク志向を「リスク回避的」から「リスク追求的」に変え、非合理的行動を促進します。レバレッジポイントとしては、見積もり誤差の縮小、プロジェクト遅延時の再スケジューリング、技術的負債の後処理（ユリシーズ契約）などが挙げられています。特に「ユリシーズ契約」は、事前に自分の行動を縛る仕組みを導入する実践的手法として注目に値します。最後のレースの誘惑最後のレースの日（Last Race of the Day）は賭け事における現象から名付けられたアンチパターンです。競馬で大きく負けている状況では「確率は低いが全額取り戻せる可能性のある選択肢」が選ばれやすくなります。プロジェクトでも遅延状態ではチームのリスク志向が変化し、「すべての遅れを取り戻せる可能性は低いが魅力的な選択肢」を選んでしまいがちです。「新しいフレームワークで生産性が3倍になる」といった根拠の薄い見積もりに基づく決断が、結果的に状況をさらに悪化させる事例は少なくありません。道徳的信任効果道徳的信任効果（Moral Credential Effect）は過去に良い行いをした人が無意識のうちに「次は少し悪いことをしても良い」と思ってしまう心理です。技術的負債の文脈では「予期せぬ技術的負債への対処→チームの美徳意識→負債を作る資格があるという感覚→技術的負債の増加」という循環を形成します。リファクタリングスプリントの直後に「少しくらい負債を作っても良い」という雰囲気が蔓延する現象は、この効果の現れです。これを防ぐには技術的負債の管理を一時的なキャンペーンではなく継続的なプロセスとして位置付ける文化形成が必要です。割れ窓理論と学習性無力感割れ窓理論は環境の悪化が更なる悪化を招くという社会学的概念で、技術的負債の文脈では「すでに負債がある環境ではさらに負債を作っても構わない」という心理が働きます。「レガシーコードに新しいレガシーコードを追加しても問題ない」という考え方がその例です。一方学習性無力感はネガティブな体験の繰り返しによって無力感を学習してしまう心理です。バグ追跡システムに報告したバグが対応されないことを繰り返し経験すると「どうせ報告しても意味がない」とバグ報告をやめてしまいます。対策として「ズブロケンウインドウポリシー（Zero Broken Windows Policy）」の導入が効果的です。どんな小さな問題でも放置せず即座に対応するという方針は、技術チームの当事者意識を高め、負債の増加を抑制します。目標文化と社会的手抜き目標文化（Goal Culture）は過度に目標を強調することで逆効果を招くアンチパターンです。目標への過度な集中は行動変化（OKR代用効果、社会的手抜き）を引き起こし、結果的に目標達成に失敗します。社会的手抜き（Social Loafing）はグループ内では個人が単独の時より努力しなくなる傾向を指します。著者はこれを「怠惰」ではなく「リソース配分の問題」として捉えています。多くの開発者が過度な作業負荷の中で自身の作業を優先し、他者に恩恵をもたらす作業に労力を投じない選択をするのです。OKRと代用効果OKRと代用効果（OKRs and the Surrogation Effect）は指標への過度な集中による弊害を示しています。代用効果とは戦略的目標を表す指標が目標そのものに取って代わる現象で、グッドハートの法則「指標が目標になると指標としての価値を失う」として知られています。1904年の客船ゼネラル・スローカム号の火災事故は、最低重量基準を満たすため救命胴衣に鉄の棒を入れたことが逆に沈下を招いた事例で、「真の目的を見失い指標だけを満たそうとする」行為の危険性を示しています。ソフトウェア開発では「コードカバレッジ率」を指標として重視すると、テストの質ではなく量だけを追求する行動を促してしまう問題が起こります。技術的負債の文脈では代用効果は特に危険です。技術的負債の測定が難しいため「測定されない」部分が軽視される傾向があるからです。消火活動への転落消火活動への転落（Descent into Firefighting）はネルソン・レペニングの研究に基づくアンチパターンで、同じリソースを使いながら効率的なモードから非効率なモードへと転落するプロセスを示しています。作業を「補助的作業」と「不可欠な作業」に分けると、あるプロジェクトが遅延した場合、他のプロジェクトから人員を引き抜いて不可欠な作業を完了させることがあります。しかしその結果、次のプロジェクトでは補助的作業が不十分となり、更なる問題が発生するという連鎖が始まります。特定のポイントを超えると組織は「非効率な消火活動モード」に陥り、回復が極めて困難になります。テストチームが手動テストに追われ、自動テスト構築のための時間を確保できない状態などが典型例です。環境制約の問題限定環境（Limited Environments）アンチパターンは特に大規模組織で見られる問題です。十分なテスト環境が不足していると、プロジェクトは不適切な環境で作業を進めることを強いられます。これは開発・テストの非効率さ、バグの発見遅延、技術的負債の増加につながります。このアンチパターンの恐ろしさは、次のプロジェクトも同じサイクルを繰り返すことで、負のループが組織内に定着してしまう点です。レバレッジポイントとしては「利用可能な環境より多くのプロジェクトをスケジュールしない」「コンテナ化技術を導入して環境生成を容易にする」などが挙げられます。プロトタイプからの負債プロトタイプからの負債（Prototype into Debt）は多くのプロジェクトが陥る典型的なアンチパターンです。プロトタイプは本来「学習のため」に作られるもので技術的負債は高くても問題ありませんが、多くの場合プロトタイプが製品として使われてしまいます。これはプロジェクトがスケジュール圧力に晒されていたり、製品開発にかかる時間を過小評価していたりする場合に起こりやすくなります。フレデリック・ブルックスの「人月の神話」で言及されている「捨てる覚悟で作れ（Plan to throw one away）」という助言が適切なレバレッジポイントとなります。因果ループ図を活用した共通理解の構築著者が提案する因果ループ図を用いたワークショップは、技術的負債問題への効果的なアプローチです。これにより、技術チームとビジネスチームが共通理解を形成し、相互の協力関係を構築することができます。技術的負債管理において重要なのは「問題の根本原因を理解する」ことです。表面的な症状ではなく、組織的・心理的要因に踏み込んだ著者のアプローチは、技術的負債が単なる技術的問題ではなく、組織全体のシステム的な問題であることを浮き彫りにしています。10. Modeling Technical Debt with System Modeling Toolsシミュレーションで見える負債の動的性質技術的負債は静的な問題ではなく動的プロセスとして理解すべきというのが本章の核心です。著者は動的モデリングツールを用いたシミュレーションによって、技術的負債の蓄積とその影響を可視化する手法を紹介しています。ジョージ・ボックスの「すべてのモデルは間違っているが、一部は有用である」という言葉から始まるこの章は、正確な予測よりも理解の促進に重点を置いています。技術的負債の動的モデルを構築する目的は、①共有理解の構築②意思決定結果の探索③関係者のメンタルモデルの強化にあると説明されています。特に重要なのは「WYSIATI（What You See Is All There Is）」というダニエル・カーネマンの概念です。多くの組織で技術的負債が「目に見えない問題」として過小評価される現実があります。見えない問題は存在しないも同然であり、動的モデルはこの「見えないコスト」を具体的な形で示す強力なツールになります。Vensimを用いた技術的負債モデル著者はモデル構築ツールとしてVensimを紹介し、具体的なモデル構築とシミュレーション実行の手順を解説しています。技術的負債モデルの基本構造は「Work Remaining（残作業）」「Work Accomplished（完了した作業）」「Undiscovered Rework（未発見の手戻り）」という3つのストック（箱）と、それらを結ぶフロー（パイプライン）で構成されています。技術的負債を表現するために「fighting fires（消火活動）」というフローと「Technical Debt（技術的負債）」というストックが追加され、「スケジュール圧力」などの変数がこのフローに影響する仕組みになっています。シミュレーション結果から得られる洞察は非常に興味深いものです。特に「予定完了日を8か月から10か月に延長すると、実際の完了が15か月から12.5か月に短縮される」という一見反直感的な結果は印象的でした。この現象の原因は作業品質にあります。非現実的に短い納期は急速なスケジュール圧力の増加を招き、時間外労働の増加から疲労が生じます。これが品質低下と手戻りの増加、さらには生産性の低下をもたらすのです。実際のシミュレーションでは、品質が0.5の水準まで落ち込み、作業の約50%が誤りを含み手戻りが必要になるという恐ろしい状況が示されました。現在の利益と将来のコスト技術的負債のシミュレーションで最も示唆に富む部分は、「負債が現在と将来のプロジェクトに与える異なる影響」の可視化です。モデルでは技術的負債を増やす設定にすると、最初のプロジェクトは約10%短縮され費用も10%削減できます。しかし後続プロジェクトでは技術的負債が「摩擦」として作用し、作業の流れを妨げるため、完了までの時間とコストが大幅に増加します。この洞察はフォン・クラウゼヴィッツの「戦争論」における「摩擦」の概念に類似しています。十分な量の摩擦が蓄積すると、軍隊もソフトウェアチームも投入努力に関わらず何も達成できなくなるのです。シミュレーションでは技術的負債の蓄積によって3つ目のプロジェクトでは7百万ポンドのコスト超過が発生し、場合によってはプロジェクトが完了不能になることが示されました。著者は伝統的なプロジェクト管理の「鉄の三角形」（コスト・範囲・時間）を拡張する視点も提供しています。プロジェクトには少なくとも2つの追加次元「品質」と「技術的負債」があり、三角形に影響することなくこれらを調整できるという洞察は重要です。測定されるのは三角形の目に見える属性だけであり、技術的負債は測定されないため、「何が測定されるかが管理される」という原則に従うと、ほとんど管理されないことになります。社会的手抜きのモデル著者はもう一つのモデル「Social Loafing（社会的手抜き）」も紹介しています。このモデルでは要件・設計・コーディング・テストという開発パイプラインを通して作業がどのように流れるかシミュレーションします。各作業グループは「協力レベル」と「品質レベル」を調整できますが、上流グループが協力や品質を犠牲にして自分たちの作業を早く完了させると、下流グループの生産性が大きく低下する影響が示されています。このモデルから得られる教訓は、個々のグループが自分たちのゴールを最適化しようとする行動が、全体としての成果を損なう可能性があるということです。ウォーターフォール型の開発ではこの問題が顕著になりやすく、一方でアジャイルプロセスでは完了した作業への注目度が高く、個人が「社会的手抜き」に走るインセンティブが少ないと著者は指摘しています。シミュレーションの価値と実践的アプローチ本章を通じて著者が伝えようとしている最も重要なメッセージは「動的シミュレーションによって得られる反直感的な洞察の価値」です。例えば「納期延長が実はプロジェクト短縮につながる」「技術的負債が現在のプロジェクトには有益だが将来のプロジェクトには壊滅的」といった知見は、静的な分析だけでは得られません。動的シミュレーションの強みは「仮想実験場」として機能することです。実際のプロジェクトでは様々な条件を変えて実験することはほぼ不可能ですが、シミュレーションでは数分で多数のバリエーションを試すことができます。コントロールスライダーを調整するだけで、完了予定日・作業品質・技術的負債レベルの変更が、リワークの量・品質の変動・生産性などに与える影響をリアルタイムで観察できるのです。著者はモデル構築を純粋な技術プロセスではなく共有理解を構築するための協働活動として捉えることを強調しています。ビジネスアナリストがビジネスプロセスをマッピングするように、質問を投げかけ、組織・システム・プロセスの動作を理解し、小さなモデルを構築して徐々に機能を追加していくアプローチが推奨されています。特に重要なのは、モデルの動作と特性について事前に関係者の合意を得ることです。シミュレーションが予期せぬ結果や望ましくない結果を生み出した場合に、ステークホルダーがモデルの妥当性を否定したくなる可能性がありますが、事前に合意が得られていれば反論しにくくなります。シミュレーションの力と限界本章で紹介されたシミュレーション手法は、技術的負債の影響を「見える化」する強力なツールですが、いくつかの限界もあります。現実の組織では「2つ先のプロジェクト」よりも目先の納期が優先される状況が多く、将来コストの可視化だけでは意思決定に影響しない場合があります。また、モデルの妥当性検証にも課題があります。技術的負債のような長期的影響を持つ問題は検証サイクルが長く、「モデルが正しかった」と確認できるまでに年単位の時間がかかります。この間にモデルへの信頼が低下すると、継続的な活用が困難になります。とはいえ、シミュレーションモデルは技術的決断の「将来への影響を可視化する窓」として、組織の意思決定能力を向上させる強力なツールです。静的な図や文書だけでは伝えにくい技術的負債の長期的影響や反直感的な振る舞いをシミュレーションを通じて示すことで、組織内の共通理解構築に貢献します。技術的負債管理における動的シミュレーションの価値は、今後ますます高まるでしょう。「見えないコスト」を可視化し、長期的な視点を提供するこのアプローチは、短期的な利益にフォーカスしがちな現代の開発環境において、特に重要な役割を果たすと考えられます。Part III Tackling Technical Debt11. Safely Convincing Everyone変革の難しさと危険性技術的負債への対処には組織全体の協力が必要だが、変革を起こすことには危険が伴うというのが本章の核心です。著者はマキャベリの「新しい秩序を導入することほど危険で成功が不確かなものはない」という言葉から始め、「安全に」「説得する」「全員を」という三つの重要な視点を提供しています。本章の焦点は、技術的な解決策そのものではなく、その解決策を組織に受け入れてもらうための人間的、社会的側面にあります。セメルワイスという19世紀の医師の悲劇的な事例を通じて、いかに優れたアイデアであっても実装に失敗する可能性があることを示しています。「変化を嫌う人」を動かす:魅力的な提案が受け入れられない4つの理由作者:ロレン・ノードグレン,デイヴィッド・ションタル,船木 謙一(監修)草思社Amazonセメルワイスの教訓19世紀ウィーンの産科医イグナーツ・セメルワイスは、医師が解剖後に手を洗わずに出産を介助することが産褥熱の原因だと突き止めました。塩素化石灰溶液による手洗いを導入すると死亡率が90%減少するという驚異的な成果を上げたにもかかわらず、彼の発見は同僚医師たちに激しく拒絶されました。セメルワイスの理論は当時の主流だった「四体液の不均衡」という病気観と矛盾し、因果関係の説明も不十分でした。さらに医師が「紳士の手」が病気を運ぶという考えに憤慨したことなども障壁となりました。しかし最も致命的だったのは、彼が医学界の重要人物を敵に回してしまったことです。自分の発見を無視する同僚たちを「無責任な殺人者」と非難した結果、彼は精神病院に閉じ込められて死亡するという悲惨な末路をたどりました。この事例から新たなアイデアを導入する際の障壁は必ずしも合理的なものだけではないことがわかります。技術的に優れた解決策であっても、組織の既存パラダイムや人々のプライドと衝突すれば受け入れられないのです。視点の転換セメルワイスの事例から生まれた「セメルワイス反射」は、現在の信念や枠組みに矛盾する新しい証拠を拒絶する認知バイアスを指します。著者は、単にセメルワイスの同僚たちを非合理的だと非難するのではなく、自分をセメルワイスの同僚の立場に置いて考える重要性を強調しています。当時の視点からすれば、セメルワイスの提案した「死体粒子」という因果メカニズムは、科学的進歩ではなく魔術的・迷信的思考への回帰に見えたかもしれません。目に見えない微小なものが人間を殺すという考えは、当時は非合理的に思えたのです。この視点転換から著者は、セメルワイスがより効果的に同僚を説得するために取るべきだった六つの行動を提案しています。同僚を疎外しないこと、より良いコミュニケーションを図ること、「紳士医師」の感受性に配慮すること、支持者の連合を構築すること、好機を待つこと、そして異なるコミュニティに働きかけることです。これらの教訓は技術的負債への取り組みにも直接適用できます。例えば「同僚を疎外しない」というポイントは、現代の事故調査から学んだ「すべての関係者は安全に作業しようとしていた」「当時の視点から見れば全員の行動には理由があった」という前提に基づいています。技術的負債問題でも同様に、関係者を非難するのではなく、彼らがそのような決断をした背景を理解することが重要です。理解してから理解される著者はスティーブン・コヴィーの「7つの習慣」から「理解してから理解される」という原則を引用しています。技術的負債を減らすためには、それを生み出した意思決定プロセスを変える必要があり、関係者がなぜそのような決断をしたのかを深く理解することから始めるべきです。前述の事故調査の原則「当時の視点から見れば全員の行動には理由があった」に則り、技術的負債を生み出した意思決定者が当時のコンテキストで最善と思える選択をしたと考えるべきです。インタビューやワークショップでの時間の大部分は、非難ではなく関係者が直面していた状況と制約を理解することに費やすべきです。著者はさらに「外部性の問題」にも触れています。外部性とは一方の当事者が他方に一方的にコストを押し付けられる状況です。利益を得る側は外部性の継続を望み、それを正当化しようとします。一方でコスト負担側も「誰も自分たちを責められない」「複雑すぎて誰にも理解できない」状態に安住してしまう共依存関係に陥ることもあります。共通理解の構築著者はジェラルド・ワインバーグの「チームのすべてのメンバーが問題の共通理解を持つまで、あらゆる解決の試みは単なる無駄なエネルギーである」という言葉を引用し、技術的負債への取り組みにはワークショップを通じた共通理解の構築が不可欠だと強調しています。共有理解の構築は一人ずつ始めることが推奨されています。まず一対一の面談を通じて各関係者の視点を深く理解し、後のワークショップでの議論の基盤を作ります。個別のインタビューでは、大勢の前では言えない率直な意見も出やすくなります。収集した情報はMiroやLucidchartなどの視覚的コラボレーションツールに記録し、インタビューの過程で徐々に全体像を構築していきます。この共有可視化プロセスが「共有理解」から「共有コミットメント」への移行を助けます。共通理解の構築には「問題基盤情報システム(IBIS)」「対話マッピング」「議論マッピング」などのツールが有効です。これらは利害関係者間の異なる視点を構造化し、建設的な対話を促進します。組織の準備状況への配慮時には組織が変革の準備ができていないこともあります。その場合著者は「変化の段階的理論モデル」を参考に「前熟考段階」に対処することを提案しています。前熟考段階では個人や組織は変化について真剣に考えていません。彼らは現状を守ろうとし、変化のプレッシャーに防衛的になります。ここで強制的な変革を試みるとかえって逆効果となり、「バックファイア効果」（反証的証拠に直面すると既存の信念を強化する傾向）を引き起こす可能性があります。このような状況では大きな変革を強制するのではなく、限定的な戦術的改善にとどめ、将来の介入のための扉を開けておくことが賢明です。セメルワイスの反省点として、彼が同僚を疎外したことで今後の協力可能性を閉ざしてしまったことが挙げられています。安全に説得するためのチェックリスト著者は章の最後に「安全に全員を説得するためのチェックリスト」を提供しています。同僚を疎外していないか、コミュニケーションは明確で促進されているか、全員と関わっているか、個別にステークホルダーと関わっているか、支持者の連合を構築したか、現在は好機か、そして組織が変革の準備ができていない場合も扉を開けておいたかといった点を確認するものです。技術的負債への取り組みは技術的問題というよりも人間の問題です。変革を成功させるためには論理的な正しさだけでなく、感情面への配慮と組織文化の理解が不可欠です。セメルワイスの悲劇から学び、私たちは「安全に全員を説得する」という困難だが不可欠なステップを通じて、技術的負債という厄介な問題に効果的に対処することができるでしょう。技術的負債の問題提起時に非難の言葉を避け、当時の意思決定の文脈を理解し、一対一の対話から始め、視覚的なツールを活用して異なる視点を統合し、組織の準備状況を見極めるというアプローチは、日々の実践に取り入れるべき重要な教訓です。12. A Program to Address Technical Debt技術的負債対策の体系的アプローチ技術的負債に対処する難しさは技術的問題ではないにもかかわらず、責任が高度に技術的な人々に委ねられることが多いという著者の指摘は、問題の本質を見事に捉えています。この章では、技術的負債への対処方法から実際の介入プログラムの構築へと視点を移し、持続可能な取り組みのためのロードマップを提示しています。著者は技術的負債削減プログラムのフレームワークとして6つの主要ステップを提案しています。予備情報収集、問題理解のためのワークショップ、追加情報収集、ソリューション開発のためのワークショップ、パイロットソリューション、そして展開と安定化です。このフレームワークはコード修正などの技術的解決策に直接飛びつく前に、組織の理解と準備状況の評価に時間を割いている点が特徴的です。Figure 12-2 The technical debt reduction program framework より引用私の経験でも技術的アプローチだけでは持続的な改善は達成できないことを実感してきました。コード解析ツールとアーキテクチャ設計を導入したにもかかわらず、数ヶ月後には元の状態に逆戻りしてしまったプロジェクトで、組織の意思決定プロセスと開発文化に焦点を当て直した結果、持続的な改善を実現できました。【ITIL4公認】ITIL 4の基本 図解と実践作者:中 寛之日経BPAmazon準備状況の評価と問題理解予備情報収集ステップでは組織の変化への準備状況を評価することが最重要課題です。組織が準備不足の状態で技術的負債削減プログラムを開始することは逆効果となり、将来の改善機会を損なう可能性があります。また現状に至った理由を理解することで、問題の根本原因に対処できます。問題理解のためのワークショップでは「共有かつ集合的な理解」の構築を目指します。全てのステークホルダーを関与させることで異なる情報を集め、後のプロセスでの協力を確保します。ワークショップではグループを意図的に混合し、異なる分野の人々が代替的な視点を探求する機会を作ることも推奨されています。あるプロジェクトでは運用チームとプロダクト企画チームが同じグループになることで、「リリースの頻度を上げたい」と「システム安定性を確保したい」という相反する要望の矛盾が明らかになり、共通の解決策を模索するきっかけとなりました。解決策の開発と実装ソリューション開発のワークショップでは潜在的な解決策を探索し、最終的にパイロットとして試す解決策を特定します。この段階でも全てのステークホルダーを関与させることが不可欠です。技術チームだけで解決策を設計すると、実装段階で大きな抵抗に直面するリスクがあります。パイロットソリューションの段階では小規模な実験を通して解決策の有効性を検証します。「早期の成功をステークホルダーに報告すること」が特に重要です。技術的負債の削減は通常すぐに目に見える成果を生み出さないため、小さな成功を強調し可視化することが変革を推進する勢いを維持するのに役立ちます。あるクライアントでは技術的負債対策の効果を「開発速度インデックス」という指標で可視化し経営陣に定期報告しました。リファクタリング後の開発速度向上というデータが次のフェーズの予算確保に決定的な役割を果たしました。継続的な改善サイクル著者は技術的負債問題を「一度のサイクルで解決することはできない」と明言しています。技術的負債は「厄介な問題」であり、「解決するというよりむしろ管理する」べきものです。循環するフレームワークを提示し、技術的負債管理が継続的プロセスであることを示しています。一つのサイクルが完了すると問題の性質が変化するため、次のサイクルを開始する必要があります。本章は技術的負債管理を継続的サイクルとして捉える包括的なフレームワークを提示しています。特に重要なのは技術的負債が技術的な問題ではなく変更管理の問題であるという認識です。どんなに優れた技術的解決策も、組織の意思決定プロセスや文化が変わらなければ持続的な改善は実現できません。技術的負債管理は終わりのない旅です。完璧に負債のない状態を目指すのではなく、「管理可能でビジネス価値の創出を妨げない」レベルを維持することが現実的な目標となります。アーキテクトの役割は単に技術的解決策を設計するだけでなく、組織全体がこの永続的な旅を効果的に進められるよう導くことにあります。13. Preliminary Information Gathering遅延満足と組織文化技術的負債への対処は本質的に遅延満足（delayed gratification）の問題であるという洞察は、本章の重要な出発点です。「企業版マシュマロテスト」という概念を通じて、著者は技術的負債管理と組織の忍耐力の関係を描き出しています。「今すぐ一つのマシュマロ」か「後で二つのマシュマロ」かという選択は、開発現場では「今すぐリリースするために技術的負債を増やすか」「時間をかけて適切な実装をし長期的な保守性を確保するか」という決断に直結します。著者が指摘するように、この能力は個人だけでなく組織文化にも依存します。私の経験からも技術的負債管理に成功している組織は、異口同音に「我慢できる文化」を持っています。ある金融テクノロジー企業では経営陣が四半期ごとに「技術的健全性レビュー」を義務付け、短期的な機能開発と長期的な技術投資のバランスを取る仕組みを構築していました。これにより技術チームは「リリース延期」という難しい決断にビジネス側の理解を得やすくなりました。マシュマロテストは単なる比喩ではなく実際の診断ツールとして活用できます。著者が提案する質問を通じて組織の「遅延満足度」を測定し、現実的な改善計画を立てられることは大きな価値があります。ダイアローグ 価値を生み出す組織に変わる対話の技術作者:熊平美香ディスカヴァー・トゥエンティワンAmazon技術的負債の現状把握著者は技術的負債の現状を理解するための5つの質問に焦点を当てています。①技術的負債はどれくらいあるか ②どのように獲得されたか ③組織はどこで痛みを感じているか ④コード関連の技術的負債は何か ⑤アーキテクチャ関連の技術的負債は何か。これらの問いは技術的負債の量だけでなく質や原因まで掘り下げる包括的なアプローチを提供しています。技術的負債の量を測定する手段として著者は「技術的負債レジスター」の活用を提案しています。興味深いのはレジスターの存在だけでなく「更新されているか」も重要視している点です。レジスターが更新されていないという事実自体が組織の技術的負債に対する姿勢を物語っています。著者がシャーロック・ホームズの「吠えなかった犬」の例えを用いて情報の不在も重要なデータだと指摘するのは見事です。私の実務経験からもこの体系的な情報収集アプローチの価値は明らかです。技術的負債の量的測定に加え異なるステークホルダーから多角的に情報を収集することで初めて全体像が見えてきます。ある金融機関では統合的な「技術的負債ヒートマップ」を作成し、組織のどの部分がどのような負債に苦しんでいるかを可視化したことでリソース配分の適正化が実現しました。負債のタイプと消火活動文化著者は技術的負債をコード関連とアーキテクチャ関連に分類して調査することを推奨しています。特に「アーキテクチャ関連の負債が最も高価な技術的負債」であり、多くの場合プロジェクトの初期段階で作られるという指摘は重要です。予算や時間の制約が厳しい場合、アーキテクチャの妥協が行われやすく、長期的なコストが発生します。マイクロサービスアーキテクチャが普及した現代のソフトウェア開発においてもこの問題は顕著です。サービス境界の不適切な設計はシステム全体の複雑性を高め保守コストを増大させます。私の経験では技術的負債の優先順位付けにおいてアーキテクチャとコードの区別は極めて重要です。アーキテクチャの負債は放置すると影響範囲が指数関数的に広がる一方、コードレベルの負債は比較的局所的な影響にとどまります。「消火活動による負債蓄積」のセクションは組織行動の観点から技術的負債の蓄積メカニズムを解説しています。著者は消火活動を「以前に確立された計画や優先事項を無視して問題発生時に反応的修正的なアプローチを適用する管理タイプ」と定義します。消火活動文化の特徴として著者は「技術的負債の長期的影響に関する議論が異端視される」点を指摘しています。現場からの「将来の問題」への懸念が「今の問題を解決できなければ将来なんてない！」という短期的思考に押しつぶされてしまうのです。また「英雄的な消火活動者を過度に称賛する」文化が消火活動を永続化させる危険性も指摘されています。私の経験では「消火活動モード」への転落は予想以上に速く起こります。ある製造業のシステム開発では、最初の遅延発生から2週間でチーム全体が消火活動モードに陥り、テスト活動削減や設計文書の放棄といった悪循環が始まりました。消火活動からの脱却は極めて困難であり、「消火活動モードへの転落を防ぐ」予防策の重要性を痛感しました。効率的な介入点と変革への準備本章の後半で著者は組織の理解に基づく「前進方法の決定」に焦点を当てています。特に「レバレッジポイント」の探索は効率的な技術的負債管理において核心的な考え方です。これは小さな変更で大きな効果をもたらす可能性のある点を指し、効率的な改善の鍵となります。著者は「少なくとも2つの前進方法のアイデアを持って」ワークショップに臨むことを推奨しています。これはエンジニアリング的なアプローチだけでなく組織変革としての準備も必要だという認識を示しています。また「トレードオフの理解」「システムの理解」「潜在的なレバレッジポイントの理解」という段階的なアプローチも実践的です。私のアーキテクト実務においてもレバレッジポイントの特定は技術的負債管理の核心です。あるeコマースシステムでは「商品カタログサービス」がボトルネックとなっていることを特定し、集中的にリファクタリングすることで全体のパフォーマンスが劇的に向上しました。すべての負債に均等にリソースを配分するのではなく「最大の効果をもたらす負債」に集中することが重要です。著者は技術的負債対策プログラムを人々の変化への準備という観点からも考察しています。予備情報収集の段階で「技術的負債が管理された組織ではどのように違うか」を説明することが重要です。より予測可能で迅速なソフトウェア開発というビジョンを共有し、必要な規律や方針変更についても前もって議論しておくべきです。特に興味深いのはソフトウェアシミュレーションモデルの活用提案です。技術的負債の動的側面を探索するためのシミュレーションツールは抽象的な概念を具体的に示す強力な手段となります。個人にモデルを見せて実験させることで、組織の開発プロセスとの類似点や相違点について議論を促進できます。情報収集の重要性本章の核心は適切な情報収集が効果的な技術的負債管理プログラムの基盤だという点です。単なる「悪いコード」の列挙ではなく、組織文化や意思決定プロセスも含めた多角的な調査が不可欠となります。著者は本章の最後に予備情報収集の成果として「質問への回答」「インタビューノート」「初期的な発見事項」が期待されると述べています。ここからさらに組織の技術的負債特性やその原因、そして現在のレベルに関する「感覚」を発展させるべきだと強調しています。これは現代のDevOps文化における「継続的な改善」の概念とも整合します。私の経験では技術的負債管理を一時的なプロジェクトではなく継続的なプロセスとして位置づけることが成功の鍵です。あるSaaS企業では「リファクタリングフライデー」という慣行を導入し、毎週金曜日の半日を技術的負債の返済に充てることで負債が累積する前に対処する文化を構築しました。このような継続的な取り組みを支えるのが本章で説明されている予備情報収集のプロセスです。状況を正確に把握し効果的なレバレッジポイントを特定することで限られたリソースで最大の効果を得ることができます。技術的負債に関する深い理解なしには持続可能な対策は不可能なのです。「測定なくして管理なし」という原則は技術的負債管理にも当てはまります。技術的負債の効果的な管理には正確な現状把握が必須であり、多角的なデータ収集が必要です。組織の遅延満足能力を正直に評価し、技術的負債レジスターを整備し定期的に更新し、コード関連とアーキテクチャ関連の負債を区別して対処し、消火活動文化から脱却するための環境改善を行うというアプローチが有効です。予備情報収集が次の「問題理解ワークショップ」への準備であるという著者の指摘は重要です。情報収集は単独の活動ではなく組織全体の共通理解と行動変革への第一歩なのです。技術的負債管理は技術問題ではなく組織全体の問題だという認識が本章全体を通して強調されています。14. Workshop for Problem Understanding技術的負債への共通理解を構築するワークショップ技術的負債問題を組織全体で理解するためのワークショップは、技術的負債対策プログラムの核心部分です。著者は2日間のワークショップアジェンダを提示し、予備情報収集で得られた知見をもとに組織内の全関係者が技術的負債の本質とその原因を共通理解するためのプロセスを詳細に解説しています。このアジェンダは技術的負債の多層的な性質を反映した構成になっています。1日目は「イントロダクション」「トレードオフ決定の理解」「システム効果の理解」「アンチパターン」をカバーし、2日目は「経済学的視点からの負債」「厄介な問題・社会的複雑性・分断」「総合的な問題理解」へと進みます。この構成は技術的負債「玉ねぎモデル」の層構造と見事に対応しており、単に「コードが汚い」という表面的な理解から、徐々に深層の原因へと参加者の理解を導く流れになっています。私はこのアプローチに強く共感します。これまで多くの組織で技術的負債対策が失敗したのは、問題の本質的な理解なしに表面的な対処に終始したからです。まず、ちゃんと聴く。　コミュニケーションの質が変わる｢聴く｣と｢伝える｣の黄金比作者:櫻井将日本能率協会マネジメントセンターAmazonトレードオフ決定の理解「Understanding Trade-Off Decisions」セクションは特に印象的です。ここでは参加者がアフェクト・ヒューリスティックを用いて意思決定していることへの気づきを促し、技術的負債蓄積の心理学的要因に焦点を当てています。著者はChristopher Hseeの実験を再現する演習から始めることで、参加者の関心を引き理論的な説明へとスムーズに移行しています。この手法はワークショップ設計において非常に効果的です。参加者は自分自身の意思決定傾向を体験的に把握することで、理論の説明により深く共感できるようになります。私が以前ファシリテートしたワークショップでも同様のアプローチを試みました。参加者に複数の選択肢（技術負債を増やして納期を守るか、技術的健全性を保って納期をずらすか）を提示し実際に選択してもらった後で、意思決定パターンを分析したのです。この体験は多くの参加者にとって目からウロコの瞬間となりました。著者はタバコの健康警告メッセージの例も挙げ、技術的負債の問題を理性ではなく感情に訴えかける形で伝える重要性を説明しています。また「ユリシーズ契約」「同時決定vs連続決定」「プリモーテム技法」などの概念も紹介され、参加者がより効果的な意思決定を行うための具体的なツールを提供しています。システム思考とシミュレーション「Understanding Systems Effects」セクションでは、システムの内部構造が外部の影響よりもその行動パターンを決定づけるという重要な洞察を提供しています。著者はITシステムと社会的システムの決定的な違いとして「社会的システムの構成要素は独自の目標を持ち追求できる」点を強調しています。このセクションで紹介されるVensimモデルリーダーを使用した技術的負債シミュレーションモデルは、参加者に動的なシステム挙動を体験的に理解させる強力なツールです。「過剰と崩壊（overshoot and collapse）」のような一見予測困難なシステム行動パターンを視覚化することで、参加者は技術的負債の長期的影響をより直感的に把握できるようになります。私の経験からもこうしたシミュレーションの効果は絶大です。ある金融機関でのプロジェクトでは、技術的負債の蓄積が開発速度に与える影響をシミュレーションモデルで示しました。最初は順調に進むプロジェクトが負債の蓄積とともに徐々に減速し、最終的には機能停止する様子を可視化したことで、経営層が技術的負債対策の重要性を納得したのです。アンチパターンと因果ループ図「Anti-patterns」セクションでは技術的負債を増加させる行動パターンと因果ループ図（CLD）の概念が紹介されています。著者は参加者が自ら「推定トラップ」のCLDを構築する演習を提案しています。この体験型のアプローチは参加者が概念を自分のものとして内在化するのに役立ちます。私のアーキテクト経験でもCLDは複雑な組織的問題を説明するのに非常に有効でした。あるプロジェクトでは「テスト自動化の後回し→手動テスト負荷の増大→テスト自動化に使える時間の減少→さらなる手動テスト依存」という悪循環をCLDで可視化しました。これによりチームは問題の本質が単なる「リソース不足」ではなく「システム構造」にあることを理解し、解決策を見出すことができたのです。経済学的視点と厄介な問題「Technical Debt from an Economics PoV」セクションでは、経済学の概念を用いて技術的負債問題を考察します。著者はHMVでの経験談を通じて「それは私の問題じゃない！」という反応を「外部性」という経済学的概念で説明し、問題の本質が個人の性格ではなくシステム構造にあることを示しています。8つの経済学的問題（プリンシパル・エージェント問題、コモンズの悲劇、外部性、短期主義、小さな決断の専制、忍び寄る正常性、アナーキーの代償、モラルハザード）は技術的負債への新たな視点を提供します。「Wicked Problems, Social Complexity, and Fragmentation」セクションでは技術的負債問題の最も深い層に焦点を当てています。「デザインの二分法」の概念、つまり「あるべき姿」を追求するグループと「できること」に焦点を当てるグループが対立する構図は、多くの組織で見られる現象であり、技術的負債問題においてもビジネス側と技術側のこの対立が根本的な課題となっていることが多いのです。ワークショップの準備と実施「Putting It All Together」セクションでは、著者は「ワークショップが解決策モードに走るのを避ける」ことを強調しています。これは極めて重要なポイントです。問題解決に慣れた技術者はすぐに解決策を提案したがりますが、拙速な解決策は表面的な対処に終わりがちです。問題理解のフェーズで十分に時間をかけることが長期的には効率的なアプローチとなります。後半の「Workshop Preparation」セクションはワークショップの成功に不可欠な準備について詳細なガイダンスを提供しています。ワークショップへの準備に3〜10倍の時間をかけるべきだというアドバイスは現実的で経験に基づいたものだと感じます。また「一人ひとりが最初の30分間に発言する機会を作る」という具体的なテクニックは参加率を高めるための有効な戦略です。第14章のワークショップアプローチの最大の価値は、技術的負債問題を「知識」のレベルから「理解」のレベルへと深める点にあります。参加者は講義を聞くだけでなく、体験的な演習やグループディスカッションを通じて技術的負債の多層的な性質を内在化します。この共通理解が次の「追加情報収集」と「解決策開発」への強固な基盤となるのです。15. Additional Information Gathering and Sensemaking組織の政治的側面の理解第15章で最も印象的だったのは「政治的側面（Political Landscape）の理解」に重点を置いている点です。技術的負債は純粋に技術的な問題ではなく、組織的・政治的な側面を持つという認識は極めて重要です。著者が指摘するように「情報が欠けているように見える場合、実際には隠されていたり偽装されていたりする」ことが多々あります。著者のHMVでのエピソードは非常に示唆に富んでいます。テスターに二画面を与えることが「スクリーン羨望（screen envy）」という理由で拒否された話は、技術的な合理性と組織的な現実の乖離を見事に示しています。Javaデベロッパーに特別感を与えるために二画面を許可し、他のスタッフには認めないという決定は技術的には全く意味がありません。しかし組織の暗黙のヒエラルキーを維持するという政治的観点からは合理的だったのです。私の経験でも同様の状況に遭遇したことがあります。あるプロジェクトではアーキテクチャの重大な欠陥が明らかになったにもかかわらず修正案が拒否され続けました。後になって判明したのはその設計が特定の上級管理職のアイデアだったこと。その人物のプライドを守るために欠陥のあるアーキテクチャが維持されていたのです。こうした人間的要素は純粋に技術的なアプローチでは解決できません。著者の「マインドマップを作成して異なる派閥や彼らの目的、相互関係を把握する」というアドバイスは極めて実用的です。ただし著者が警告するように「共有または誰でもアクセスできる場所に置かないこと」は重要です。こうした政治的分析は誤解を招く恐れがあるため慎重に扱う必要があります。反脆弱性[上]――不確実な世界を生き延びる唯一の考え方作者:ナシーム・ニコラス・タレブダイヤモンド社Amazon情報収集とセンスメイキング「不足情報への対応」セクションでは、組織の政治的側面を理解した上で必要な情報を収集する方法について解説しています。私にとって最も共感できるのは「全ての不足情報を入手することは不可能だと認識すべき」という指摘です。ソフトウェア開発では完璧な情報を持つことは幻想にすぎません。著者の「WMD（大量破壊兵器）の証拠がすべて揃わなくても他国に侵攻するなら、技術的負債についてすべての情報がなくてもワークショップを進めてもよいはず」という皮肉交じりの発言は痛烈です。完璧な情報を待っていては何も始められません。得られる最善の情報で前進する勇気も必要なのです。「意味づけ：全てが意味するものは何か？」セクションは、集めた情報から構造と意味を見出すプロセスを扱っています。著者は様々な技法を紹介していますが、特に興味深いのは非正統的な方法への言及です。「退屈」を創造的なツールとして活用するという発想は新鮮です。問題について考えすぎて退屈になるまで考え、次に完全に忘れて違うことをする。そして睡眠をとった後に戻ってくると新たな洞察が得られるかもしれないというアプローチは、私も経験的に効果を実感しています。センスメイキングプロセスで特に価値があるのは「仮説を検証する」というアプローチです。仮説を立て裏付けるデータを収集するだけでなく、仮説が間違っていることを示す可能性のあるデータも意識的に探すという姿勢は、健全な批判的思考を促します。解決策の形成と検証「潜在的な解決策の形成」セクションでは、技術的負債対策の二つの主要なアプローチ「既存の負債の削減」と「新たな負債の作成回避」のバランスを強調しています。著者は短期的な成果を示すために既存の負債に対処することの重要性を認めつつも、長期的には負債作成プロセスそのものの変革が必要だと述べています。HMVのJukeboxプロジェクトの例はこの原則を完璧に示しています。C#で開発されたシステムをJavaで再実装することで既存の負債は解消されましたが、「IT部門を完全に含めずに戦略的イニシアティブを開始する」という根本原因は解決されなかったのです。結果として新たな負債が作られ続けました。「センスメイキング→潜在的解決策の形成→ステークホルダーフィードバック→リファイン」という反復的なプロセスは特に価値があります。このフィードバックループを通じてステークホルダーの賛同を得つつ解決策を洗練させるアプローチは、変革管理の基本原則に沿っています。私の経験では技術的負債対策プログラムが失敗する最大の理由はこの反復的プロセスの欠如です。多くの場合技術チームが「完璧な」解決策を考案し一方的に導入しようとしますが、ステークホルダーの関与なしでは抵抗に遭い挫折します。小さなフィードバックループを何度も回し、各ステークホルダーが「自分の提案が取り入れられた」と感じる機会を作ることが成功への鍵です。「動的シミュレーションモデル」セクションは、技術的負債の影響を可視化する強力なツールについて言及しています。私の経験では技術的負債の影響を客観的に示すことはステークホルダーの説得において最大の課題の一つです。シミュレーションモデルを通じて負債の蓄積がどのように開発速度の低下や品質問題に結びつくかを視覚的に示すことができれば説得力は格段に高まります。技術を超えた人間の問題この章を通じて最も強調されているのは、技術的負債が単なる技術的問題ではなく「人間の問題」だという点です。著者がジェラルド・ワインバーグの「常に人間の問題である」という言葉を引用しているように、技術的負債の背後には常に人間の決断や人間関係の力学があります。技術偏重のアプローチでは組織の政治的側面や人間の心理を無視してしまうため、効果的な解決は難しくなります。セメルワイスの悲劇的な例が示すように、科学的に正しいソリューションでも人間的な側面を無視すれば拒絶されるリスクがあるのです。私が技術的負債対策プログラムで最も重視するのはこの「人間中心」のアプローチです。技術的に最適な解決策より、組織文化や政治的現実に適合した実行可能な解決策を優先します。また変革の速度も重要です。急激な変化は抵抗を招くため、「ボイルドフロッグ」アプローチとも呼ばれる緩やかな変化が効果的であることが多いです。第15章は技術的負債対策プログラムにおける「問題理解」と「解決策開発」の間の重要なステップを詳細に解説しています。特に重要なのは、技術的負債を単なる技術問題としてではなく、組織的・政治的な問題として捉える視点です。「情報が隠されている可能性」「政治的力学の影響」「完璧な情報の入手不可能性」といった現実を認識したうえでの対応が必要になります。技術的負債対策の成功はアーキテクチャの適切さやコードの質だけでなく、組織の政治的現実への適応力にも大きく依存します。セメルワイスの悲劇を繰り返さないためにも、「それは安全にできるか？」という問いを常に念頭に置き、人間中心のアプローチを心がけることが不可欠です。16. Workshops for Solution Development解決策開発ワークショップの目的と構造第16章は技術的負債対策プログラムの重要な段階である解決策開発ワークショップに焦点を当てています。ワークショップの目的を明確にすることが最も重要であり、著者は「パイロットプロジェクト段階に持ち込める潜在的な解決策をもってワークショップを終えること」という明確な目標を設定しています。著者が提供する1日のワークショップアジェンダは「リキャップと更新」からスタートし、「第一の候補介入策の探索」「第二・第三の介入策の探索」「要約と次のステップ」へと続く論理的な流れになっています。特に「既存の負債への対処 vs 新たな負債の作成回避」というセクションは技術的負債管理の二つの主要アプローチのバランスを考慮する重要性を強調しています。PowerPointスライドデックの活用に関する著者の提案も実用的です。「自分のプレゼンテーションスタイルを反映するように各スライドを修正する」というアドバイスは単なるテンプレートの使用を超えた個人化の重要性を示しています。私が組織でワークショップを実施した経験からも十分な準備が成功の鍵であることを強く実感しています。物語思考　「やりたいこと」が見つからなくて悩む人のキャリア設計術 (幻冬舎単行本)作者:けんすう（古川健介）幻冬舎Amazon前回の理解を振り返る「リキャップと更新」セクションは前回のワークショップの成果と追加調査結果を共有するための重要なステップです。技術的負債の「玉ねぎモデル」の復習は特に重要であり、「技術的負債は技術的問題か？」という問いに対して全員が「No!」と答えるよう促すアプローチは核心的な理解を確認する効果的な方法です。前回のワークショップの結果と追加調査の発見を共有するセクションでは、著者は「ワークショップの方向性を形作る機会」としての側面を強調しています。これは単なる情報共有ではなく、議論を生産的な方向に導くための戦略的なステップです。重要あるいは実りの多い領域を強調し、他の領域にはあまり重点を置かないことでファシリテーターはワークショップの焦点を効果的に調整できます。私の経験でもこのような「方向付け」は極めて重要です。あるプロジェクトでは技術的負債の様々な側面を検討していましたが、全てを同等に扱うと議論が発散してしまいました。そこで特にビジネスインパクトの高いアーキテクチャの整合性に焦点を当てることで、具体的な改善策を効率的に策定することができました。候補介入策の探索と評価「最初の候補介入策の探索」セクションでは、最も有望な技術的負債管理介入策を深掘りします。候補介入策の選択にはドット投票法の使用が推奨されています。各参加者が一定数の投票権を持ち自分が優先したい項目に割り当てるこの手法は、直観的かつ民主的な優先順位付け方法です。ファシリテートされた議論では、介入策の明確な問題/介入ステートメントの作成から始めることが推奨されています。例えば「プロジェクトの過小評価はプロジェクトの遅延につながり技術的負債を生み出す。当組織はプロジェクト見積もりを技術的負債作成の要因でなくなるまで改善する」といった形式です。このような明確なステートメントが議論の焦点を絞り、具体的な行動計画の形成を促進します。解決策アプローチのアイデア生成には「1-2-4-All」とブレインストーミングを組み合わせる方法が提案されています。この手法は個人での思考からペアディスカッション、さらに4人グループでの議論へと段階的に拡大していくアプローチで、多様な視点を集めつつグループダイナミクスを効果的に活用できます。有用なワークショップ技法著者が提案する「有用なワークショップ技法」は実務者にとって貴重なツールキットです。「厄介な質問（Wicked Questions）」は対立する現実を両方とも認める質問を形成する手法です。例えば「技術的負債を減らしながら同時にベロシティをどう維持するか？」といった形式の質問は、矛盾するように見える目標間の創造的な緊張を生み出します。「TRIZ」（発明的問題解決の理論）は特に興味深い手法です。この手法では「最悪の結果を確実にする方法」を特定し、次に「現在行っている活動で最初のリストに似ているもの」を見つけ、最後にそれらの活動を停止する方法を考えます。「技術的負債でいっぱいのITシステムを確実に構築するには？」といった逆説的な問いかけは既存の思考パターンを破壊する効果があります。「チェスタートンのフェンス」は既存のセットアップの理由を完全に理解するまで変更を加えるべきではないという原則です。著者がスイスの製薬会社のシステム移行プロジェクトで経験した教訓（使われていないと思われたインターフェースを削除した結果、ヨーロッパ中の工場が停止した）は非常に印象的です。技術的負債対策においても、既存の「負債」が何らかの重要な目的を果たしている可能性を常に考慮する必要があります。フォローアップと成果の確保著者は「ワークショップの準備」「セッション後のフォローアップ」「アウトプット」といった実践的な側面も詳細に解説しています。特に「Peter Druckerの誤用を借りれば『測定されるものは管理される』。確実に誰かが特定された小さな改善策をフォローアップすることを参加者に知らせなさい」というアドバイスは重要です。ワークショップの成果として著者は「パイロットまたは承認を求めるための1〜3の介入策」「将来のワークショップのための候補介入策リスト」「ワークショップ参加者が実行できる小さな項目のリスト」などの具体的なアウトプットを挙げています。私の経験から最も価値があるのは「ワークショップ参加者が実行できる小さな項目のリスト」です。大規模な組織的変革は時間がかかりますが、小さな改善は即座に実施でき成功体験を積み重ねることができます。第16章で最も重要なメッセージは参加者に「主体性（agency）」を持たせることです。技術的負債は圧倒的で手に負えないように見えることが多く、無力感や諦めを生み出します。しかし著者が提案するワークショップアプローチは参加者が自分たちの裁量でできることに焦点を当て、具体的な行動計画を形成することで主体性を回復させるのです。17. Pilot Solutionsパイロットプロジェクトの危険性と留意点第17章は技術的負債対策プログラムの実験的な試行段階に焦点を当てています。パイロットプロジェクトの危険性への警告から始まり、著者はマキャベリの「新しいものを導入するほど危険で不確実なものはない…改革者は古い条件下で成功した全ての人々を敵に回すからだ」という言葉を引用し、変革の難しさを強調しています。最も印象に残るのは「自身の利益のために悲劇を利用しようとする人がいるのなら、自組織内の誰かがパイロットプロジェクトを自己利益のために利用しようとすることは間違いない」という警告です。これは実務経験からも強く共感できるポイントです。以前関わったプロジェクトでは技術的負債対策パイロットの結果が特定のチームの予算削減を正当化する「証拠」として利用されかけたことがありました。パイロットの位置づけについて著者はCynefinフレームワークを参照し、技術的負債問題が「複雑（COMPLEX）」な領域に位置することを示しています。このような領域では完全に制御された実験が不可能であり、介入自体が問題の性質を変えてしまうことも考慮すべきです。そのため「介入が状況を悪化させるよりも改善する可能性が高い」という程度の証明で十分だとする著者の実用的なアプローチは説得力があります。リーン・スタートアップ　ムダのない起業プロセスでイノベーションを生みだす作者:エリック リース日経BPAmazonデータを活用した解決策の検証著者はパイロットプロジェクトなしで技術的負債を管理できる二つの状況を検討しています。一つはソリューション開発ワークショップで参加者が自分たちの権限内でできると特定した小さな項目のみに対処する方法、もう一つは過去のプロジェクトデータを使用する方法です。過去プロジェクトのデータを使用した例として、遅延した二つのプロジェクトの技術的負債蓄積パターンの違いが示されています。正確に見積もられたプロジェクト（20%遅延）では技術的負債が全期間を通じて均等に蓄積されていましたが、不正確な見積りのプロジェクト（60%遅延）では当初の締め切りを過ぎた後に技術的負債の蓄積率が急激に上昇していました。これは単なる印象や主観ではなく実際のデータに基づく証拠であり、技術的負債の管理において「プロジェクト遅延防止」が重要な戦略であることを示しています。この分析アプローチは現代のソフトウェア開発環境でも直接応用可能です。ユリシーズ契約を用いた負債管理著者はパイロットプロジェクトの具体例として「ユリシーズ契約」の実装と評価を提案しています。ユリシーズ契約とは将来の特定条件下で自分自身を拘束するために自発的に締結する合意です。技術的負債の文脈では、戦術的なプロジェクト問題を解決するために技術的負債を作成することを許容しつつ、その負債を返済するための時間と資金を確保するメカニズムを提供します。著者が提案するユリシーズ契約の設計で考慮すべき点は「望ましい行動を奨励し望ましくない行動を抑制する」という原則に基づき、高い透明性、高コスト負債の回避、組織全体にとって有利な場合のみ負債を受け入れるといった望ましい行動を促進する仕組みが必要だと指摘しています。特に興味深いのは「負債のコストをどのように分担するか」についての考察です。全てのコストを組織が負担するとプロジェクトはあらゆるものを技術的負債登録簿に追加しようとする一方、全てのコストをプロジェクトが負担するとほとんどの技術的負債項目が隠されて透明性が失われるというジレンマが生じます。これは単純な技術的問題ではなく、組織的なインセンティブ設計の問題であることを示しています。実務的には私はこのようなユリシーズ契約を「技術的負債バジェット」という形で実装したことがあります。各プロジェクトには一定量の「負債クレジット」が割り当てられ、期限内に納品する必要がある場合に「借用」できる仕組みです。重要なのはこの「借用」が明示的に記録され、返済計画が事前に合意されることです。パイロットの実施と結果分析著者はパイロットプロジェクト選定の基準として「適時性」「協力的なチーム」「小規模」「緊急性が低い」「短期間」といった要素を挙げています。特に注目すべきは「プロジェクトが遅延した場合実験が忘れられるリスク」や「さらに悪いことにスケジュール遅延の責任転嫁に使われるリスク」という警告です。パイロットプロジェクト実施の際、著者は「プロジェクト自体ではなく介入による技術的負債蓄積の変化に関する情報収集」に焦点を当てるべきと強調しています。プロジェクト運営自体に巻き込まれないよう注意しつつ、プロジェクトチームが持つ洞察や価値観を活用することが推奨されています。結果分析においては「これは正しい方向への一歩だったか」「コストよりも大きな助けになったか」という二つの基本的な質問に答えることを目指すべきです。また報告書は「忙しく注意力散漫なステークホルダー」を念頭に置き、明確で簡潔なメッセージを含めることが重要です。「人は数字が好き」「人はストーリーも好き」という著者の指摘は組織でのコミュニケーション経験からも非常に的確です。本章の最も重要なメッセージは技術的負債管理が単なる技術的問題ではなく、組織全体のプロセスと文化に関わる変革だということです。著者が提案するユリシーズ契約や段階的なパイロットプロジェクトアプローチはこの複雑な変革をより管理可能な形で実施するための実用的な方法です。最終的には組織の文化や構造に適合した「型」を見つけることが成功への鍵となります。技術的負債という「厄介な問題」に対処するための万能解決策は存在しませんが、明示的な契約、データに基づく意思決定、小規模から始めて学習するという原則を取り入れることで、組織は自分たちに適した持続可能な技術的負債管理アプローチを見つけることができるでしょう。18. Rollout and Stabilization組織変革としての技術的負債管理第18章は技術的負債削減プログラムの最終段階、組織全体への展開と定着に焦点を当てています。技術的負債への対処は単なる技術問題ではなく、組織全体の変革を必要とする取り組みであることが強調されています。マキャベリの「新しい秩序を導入することほど困難で危険で成功が不確かなものはない」という言葉は、技術的負債への取り組みにも当てはまります。変革管理の難しさは単に既存の負債を技術的に解決することではなく、人々の働き方を変えることにあるのです。技術的負債の解消が困難である理由は多岐にわたります。多くの人は技術的負債を技術問題と誤解し、本質がトレードオフ問題であることを認識していません。また常に他の「緊急」事項が優先される状況や、華々しい成果を上げにくい地道な取り組みであることも組織的な推進力を弱めています。技術的負債の返済に多額の投資を行う組織でさえ、その成果を定着させるためのプロセス変革に失敗するケースが多いのです。コッターの8ステップ変革プロセス本章ではジョン・コッターの8ステップ変革プロセスに焦点を当てています。このモデルは実証済みで広く使われ、豊富な文献とリソースがあり、関連経験を持つ変革管理の専門家も多いことから選ばれています。コッターのモデルはコミュニケーションと関係者の同意獲得に重点を置いています。明確な8つのステップが用意されていること、シンプルな実装方法、ステークホルダーの参画への強い焦点、緊急性の感覚を創出する点が利点として挙げられています。変革の8ステップとその実践緊急性の確立は技術的負債への取り組みにおいて特に難しい課題です。アイゼンハワー大統領の区分で言えば、技術的負債は「重要だが緊急でない問題」に該当します。効果的な緊急性を確立するためには、技術的負債の組織へのコスト試算、負債が引き起こした具体的な事例を物語として伝えるアプローチ、異なるレベルの技術的負債が開発コストに与える影響を動的シミュレーションモデルで可視化する方法などが有効です。ただし誇張された緊急性を作り出すことは「組織変革疲労」を引き起こす危険があります。著者は絶え間ない変革状態にあった組織での経験から、BOHICA(「また来たぞ、身構えろ」の意)という現場エンジニアの諦めの姿勢について触れています。強力な指導連合の形成も重要です。変革を成功させるには「強力」で「指導」する「連合」が必要です。パワーは変革を実行するための十分な権限を持ち、指導力は組織全体を導く能力、連合は技術的負債問題に取り組む共通の目的を持った集団を意味します。ビジョンの創造とコミュニケーションでは、明確で魅力的で信頼できるビジョンが必要です。このビジョンがあまりに複雑だったり曖昧だったりして5分以内で相手に伝えられないようでは失敗の原因となります。技術者向けには「負債に縛られずに望まれる機能を最良の方法で実装できる」というビジョン、利害関係者には「予測可能性と約束通りの機能提供」というビジョンを伝えるなど、対象によって異なるメッセージが必要かもしれません。ビジョンに基づく行動の促進においては、組織構造や強力な抵抗勢力がもたらす障壁を取り除く必要があります。変革への最大の障壁は現状に既得権益を持つ人々の抵抗です。例えばスプリントから無理やり追加のストーリーを絞り出すプロダクトマネージャー、実現不可能と知りながら受注する営業チーム、遅延プロジェクトで品質より機能を優先するステークホルダー、火消し作業に終始し根本的な改善に取り組まない「ヒーロー」など様々なパターンがあります。短期的成果の創出と定着化も欠かせません。ステークホルダーは合理的な期間内に改善の兆候が見えなければ変革への道を継続することはできません。そのため技術的負債削減プログラムには早期の成果を示せる取り組みを含めるべきです。これらの改善に貢献したチームメンバーを称えることで他のメンバーにも変革への動機付けができます。新しいアプローチの制度化が最終目標です。早期の成果による信頼性の向上を活用し、技術的負債の蓄積につながるシステム構造や方針の変更を主張しましょう。技術的負債の文脈では見積りプロセスの改善など根本的な原因に対処する変更が多く該当します。変革の成功要因変革プロジェクトの成功に共通する重要な要素には、測定可能なステークホルダーの目標の定義、全関係者への効果的なコミュニケーション、効果的なトレーニングプログラムの作成、抵抗の監視と対処、進捗の監視と微調整があります。技術的負債の解消は技術だけの問題ではなく組織全体の変革を必要とすることをこの章は強調しています。コッターの8ステップモデルは効果的な変革管理の枠組みを提供していますが、重要なのは組織の文化や特性に合わせたアプローチをとることです。技術的負債は連続的な問題であり、一度解決すれば終わりというものではありません。持続可能な解決策の構築には組織全体の継続的な取り組みとスキル構築が求められています。19. Conclusion魔法のボタンは存在しない著者は魅力的な比喩で最終章を始めています。もし寿命を延ばすボタンや体重を減らすボタンがあれば誰もが迷わず押すでしょう。しかしそのようなボタンは存在せず、健康的な生活習慣や適切な運動プログラムの継続が唯一の道です。同様にソフトウェアシステムの寿命を延ばす魔法のボタンも存在しません。一部のベンダーは「魔法の解決策」を売り込もうとしますがそれは幻想にすぎません。技術的負債に対する現実的なアプローチは「頭蓋骨に穴をあける」ような原始的な対症療法ではなく、世界の捉え方自体を変えることから始まります。慢性的な頭痛を食事や生活習慣、予防薬の組み合わせで治療するように、技術的負債も根本的な原因理解と持続的な対策が必要なのです。この取り組みには努力と満足の遅延が必要ですが、確かな道筋は存在します。ジェームズ・クリアー式 複利で伸びる1つの習慣作者:ジェームズ・クリアーパンローリング株式会社Amazon技術的負債の本質技術的負債の問題に立ち向かう際の最初の障壁は「負債」という類推自体の限界です。金融債務との類推は技術的でない利害関係者とのコミュニケーションに役立ちましたが、同時に誤解も生み出しました。この類推は技術的負債を主に「技術的な問題」と捉えさせますが、実際は「トレードオフの問題」なのです。新機能、早期デリバリー、直接コスト削減と引き換えに負債を抱え込む意思決定が本質的な課題です。トレードオフ決定は「affect heuristic（直感的判断）」に基づいて行われ、潜在意識で処理されるため歪みが生じやすく自覚することも困難です。本書を通じて学んだように、技術的負債はこの意思決定プロセスの歪みが組織システム内で増幅される結果なのです。技術的負債は単なる個人の意思決定の問題ではなく「システム問題」です。判断を行う個人は真空の中ではなく組織というシステムの中で意思決定を行います。彼らの役割とそれに伴う評価基準が負債に関する判断を歪めるのです。この問題が「厄介な問題（wicked problem）」であり、組織の社会的複雑性と相まって断片化したグループ間の対立を生み出すのです。技術的負債管理がもたらす恩恵こうした複雑な問題にもかかわらず、技術的負債を管理し高価なソフトウェアシステムの寿命を延ばすプログラムを構築することは可能です。技術的負債管理プログラムの構築が組織にもたらす三つの大きな恩恵を著者は強調しています。システムの寿命を50%以上延長することによる大幅なコスト削減。IT開発は既に組織予算の相当部分を占めており、人工知能など新技術の普及によってその割合は今後も増加することが予想されます。大規模なITプロジェクトによる混乱の減少。システム置き換えのような大規模プロジェクトはビジネスに大きな混乱をもたらしますが、技術的負債管理によりそうした必要性を減らすことができます。リスクの低減。ITおよびソフトウェアプロジェクトは本質的にリスクが高く、多くのプロジェクトが失敗します。機能しているシステムを技術的負債管理によって継続的に機能させ寿命を延ばすことは、組織にとってはるかにリスクの低い選択なのです。旅路への励まし著者は「技術的負債というドラゴンを飼いならす」ことが組織に大きな優位性をもたらすと結論づけています。そして読者への最後のメッセージとして「幸運」ではなく「勇気」を願っています。これは技術的負債との闘いが幸運頼みではなく、勇気を持って取り組むべき旅であることを示唆しています。技術的負債管理は単純な技術的解決や一時的な対策ではなく、組織の働き方、意思決定プロセス、評価システムにまで及ぶ包括的な変革です。それは困難な旅となりますが、組織の競争力、ソフトウェア資産の寿命、業務効率の向上に繋がる価値ある挑戦なのです。おわりにお疲れさまでした！長い旅路の末、ようやく技術的負債というドラゴンの本質が見えてきましたね。「単なる汚いコードでしょ？」と思っていた方は、それが実は「トレードオフの意思決定問題」「組織のシステム問題」「経済学的問題」そして「厄介な問題（wicked problem）」という複数の顔を持つ複雑な生き物だったことに気づかれたでしょう。私たちは皆、技術的負債という名の「マシュマロテスト」の前に立たされています。「今すぐひとつのマシュマロを食べるか、我慢して後で二つ食べるか」というあの有名な実験です。ソフトウェア開発の世界では「今すぐリリースして技術的負債を増やすか、時間をかけて正しく実装するか」という選択を迫られるわけです。もっとも、現実はそう単純ではありません。我慢して「正しく実装」したとしても、ビジネス要件の変更や技術の進化によって、約束の「二つ目のマシュマロ」が手に入らないこともあります。それでも、多くのプロジェクトは「締め切りが明日！」という時間の圧力の前に、リスクを考慮せずマシュマロを見るなり飛びつく3歳児のような選択をしがちです。「技術的負債を瞬時に返済できる魔法のボタン」を探し求めていた方には残念なお知らせがあります。最新のAI技術によってハードコードされた値の検出と修正は容易になりつつありますが、それでも技術的負債の全体を一瞬で解消するボタンはありません。チケットキューの山を一気に片付けるドラゴンボールでさえ、集めるのに時間と努力が必要なのです！あるのは地道なリファクタリングと品質管理という、継続的な改善活動だけです。でも、その「毎日続けること」こそが実は魔法なのかもしれません。無限病院 医院作者:韓 松早川書房Amazon最後まで読んでくれて本当にありがとうございます。途中で挫折せずに付き合ってくれたことに感謝しています。読者になってくれたら更に感謝です。Xまでフォロワーしてくれたら泣いているかもしれません。ドラゴンとの共存 - もうひとつのエピローグこの話の終わりに、もうひとつの物語を聞いてください。あれから3年が経ち、nwiizoの姿は大きく変わっていました。かつて彼を悩ませた「Cシステム」は、いまや彼が手なずけた技術的負債のドラゴンとなっていたのです。「どうしたんだ？また新機能の追加か？」nwiizoは画面の向こうのドラゴンに話しかけます。ドラゴンは小さく息を吐き、コード上に赤い警告を表示しました。「ありがとう、気づかなかった。この依存関係を追加したら循環参照になるところだった」nwiizoが最初にCシステムと対峙した日、彼はこのドラゴンを倒そうとしていました。「すべてを書き換えれば解決する」と、純粋すぎる情熱に燃えていたのです。しかし時間をかけて彼は大切な真実に気づきました。ドラゴンは倒すものではなく、共存するものだったのです。オフィスの壁には今、大きな「負債マップ」が掲げられています。技術的負債の「玉ねぎモデル」に基づき、技術層・トレードオフ層・システム層・経済学層・厄介な問題層という同心円が描かれています。チームメンバーはここに付箋を貼り、「高金利負債」には赤いマーカーで印をつけます。毎週金曜日の午後、彼らは「ドラゴンとのお茶会」と呼ばれるセッションを開きます。プロダクトオーナー、開発者、テスター、運用担当者が一堂に会し、今週作った負債と返済した負債について語り合うのです。「先週、納期を優先してユニットテストを省略したよね」とQAリードが言います。「うん、『ユリシーズ契約』に基づいて記録したよ。来週のスプリントで返済する約束をした」と開発者が答えます。nwiizoは微笑みながらこのやり取りを見ています。かつてはタブー視されていた「負債を作る決断」が、今は透明性を持って議論されているのです。彼の机の上には、「厄介な問題への挑み方」という本が開かれています。そこには彼の手書きのメモがあります。「技術的負債は複雑な問題だ。誰もが自分の視点から『解決策』を持っているが、誰も全体を見通せていない。重要なのは対話だ。異なる世界観を持つ人々が理解し合う場を作ること。」ある日、新入社員がnwiizoに尋ねました。「先輩、どうしてこんなに古いシステムを使っているんですか？最新のフレームワークで書き直せば、もっと効率的になると思いますが...」nwiizoはコーヒーを一口飲み、穏やかに答えました。「君はドラゴンを倒したいのかな？」新入社員は困惑した表情を浮かべます。「ドラゴンとは技術的負債のことだ。確かに彼は時に厄介で、時に怖い。でも実は私たちのプロジェクトの歴史そのものでもある。何年もの経験と学びが詰まった叡智だ。」nwiizoは立ち上がり、壁のチャートを指さしました。「見てごらん。私たちはすでに負債の70%を返済した。残りの30%は『低金利負債』か、あるいは返済コストが便益を上回る部分だ。完璧に負債ゼロのシステムを作ることが目標ではない。ビジネス価値を最大化しながら『管理可能な負債』を維持することが重要なんだ。」新入社員は考え込みます。「でも、いつか全部書き換える日は来るんですか？」「もちろん、その日は来るだろう。でも焦る必要はない。大切なのは毎日少しずつドラゴンと会話すること。負債を理解し、管理し、時には交渉することだ。それが本当の『ドラゴン使い』の仕事なんだよ。」その日の夕方、オフィスを出るnwiizoは、デスクの上のノートに次のスプリントの計画を書き残しました：「負債返済：20%、新機能：60%、実験：20%」ドラゴンは消えることはありませんでした。しかし今や、彼は恐れるべき敵ではなく、ともに歩むパートナーになっていたのです。時に手を焼かせるが、その炎は道を照らす光にもなる——そんな不思議な共存関係を築いたnwiizoの物語は、多くのエンジニアの心の支えとなったといいます。あなたのプロジェクトにも、きっとドラゴンは潜んでいるでしょう。それを倒そうとするのではなく、手なずけることを考えてみてはいかがでしょうか。最初の一歩は、ドラゴンの目を見て「こんにちは」と言うことから始まります。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[StageCrewとは？マルチモーダルAIツールを触ってみた]]></title>
            <link>https://sreake.com/blog/research-multi-modal-tool-stagecrew/</link>
            <guid>https://sreake.com/blog/research-multi-modal-tool-stagecrew/</guid>
            <pubDate>Thu, 06 Mar 2025 11:13:20 GMT</pubDate>
            <content:encoded><![CDATA[StageCrew™️とは StageCrew™（https://stagecrew.ai/）は、システム監視やログ収集、トランザクションのトレースといった各種管理ツールに対するアクセスを自動化、インシデント発生時の対応 […]The post StageCrewとは？マルチモーダルAIツールを触ってみた first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[LookMLって定数を定義できるの?]]></title>
            <link>https://zenn.dev/nedoko_dok0dko/articles/6d6bacc1a294b9</link>
            <guid>https://zenn.dev/nedoko_dok0dko/articles/6d6bacc1a294b9</guid>
            <pubDate>Thu, 06 Mar 2025 10:53:04 GMT</pubDate>
            <content:encoded><![CDATA[whatLookMLで定数を定義する事ができるのか調べてみた個人ログ Q.LookMLって定数を定義できるの?A. できるLookMLも他のプログラミング言語と同じように定数を設定できる。 定数の定義とマニフェストファイル マニフェストファイルLookMLにおいて、定数はマニフェストファイルというファイルを作成することによって定義する事ができる。https://cloud.google.com/looker/docs/lookml-project-files?hl=ja#project_manifest_filesマニフェストファイルは、定数の定義以外にも...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[標準入出力テストを可視化するTUIツールの開発をした。]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/03/04/160714</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/03/04/160714</guid>
            <pubDate>Tue, 04 Mar 2025 07:07:14 GMT</pubDate>
            <content:encoded><![CDATA[yamori demo gifgithub.comはじめに「あー、もう！競プロでテストの為にSolverを分けるの、マジで面倒くさい！」これが私がYamoriを作ったきっかけです。正直に言いましょう。私は怠け者です。AtCoderで問題を解くたびに、問題ごとにSolverを分けて、いちいちmain.rsを書き換えて...という作業が本当に億劫でした。標準入力でサクッとテストできないものかと常々思っていたのです。「標準入力でサクッとテストできないかな」と思いながら、コピペして実行して、出力を目視で確認する日々。ある日、特に複雑な問題で間違えたとき、「あれ？どのテストケースで落ちたっけ？」と混乱し、絶望的な気分になりました。そんな「プログラマーの怠惰」から生まれたのがYamoriです。「ヤモリ」という名前は、元々YAMLでテスト定義を書こうと思ったからです。（まあ、実際には「山守」という意味で、テストが私のコードを守ってくれるという願いも込めていますが、カッコいい理由なんて後付けです）「これでスッキリする！」という淡い期待競技プログラミングで使うRustのプログラムをテストするためだけに、Rustでテストツールを開発するという本末転倒な状況に、私は何の違和感も覚えませんでした。これぞ「釘を打つために、まず金槌を作るプログラマー」の鑑です。「単純な標準入出力のテストツールなんて、週末でサクッと作れるでしょ！」この甘い考えが、のちに何週間もの苦闘を招くとは思いもよりませんでした。ターミナルUIという沼「コマンドラインでテキスト出力するだけじゃつまらない。せっかくだから可視化もしたい！」この「せっかくだから」という言葉は、エンジニアの時間を無限に吸い取る魔法の呪文です。ratutuiというライブラリを見つけた瞬間、私は沼にハマりました。「タブがあって、色付きで、差分も表示できて、履歴も見れて...」気づけば、単純なテストツールのはずが、フルスクリーンのターミナルUIアプリケーションに進化していました。vim風のキーバインドを実装しながら「これ、競プロのテストに使うんだよね？」と自問自答する日々。言い訳のような機能たち最終的に、Yamoriには「競プロのテスト」という本来の目的を超えた様々な機能が実装されました：TOML/YAML形式のテスト定義（JSONじゃダメだったの？）履歴追跡機能（過去のテスト結果を見返す時間があるなら問題を解けよ）リリースモード切替（競プロでリリースビルド？本気？）カラフルな差分表示（赤と緑でお祭り気分）キーボードショートカット（vimmerの執着心）これらの機能を実装しながら、脳内では常に「ただテストするだけなのに...」というツッコミが再生され続けていました。しかし、完成したときの満足感は格別でした。最初のテストケースが緑色で「PASS」と表示されたとき、「こんなの作る時間があったら、もう10問解けてたな」と思いつつも、心のどこかでは「でも、これからはテストが楽になる！」という正当化が始まっていました。大切なものは ほしいものより先にきた結局のところ、Yamoriの開発は「標準入力でテストしたい」という単純な欲求から始まり、いつの間にか「立派なターミナルUIアプリ」へと成長しました。本当に必要だったのは単純なシェルスクリプトだったかもしれませんが、この回り道があったからこそ、Rustの理解も深まり、新しいライブラリにも触れられました。「効率的に競プロを解きたい」という目的からは大きく外れましたが、「プログラミングを楽しむ」という本質的な目的は達成できたのではないでしょうか。そして何より、次回のコンテストでテストケースを流し込むとき、「よっしゃYamori様様やな！」と密かに自己満足に浸れるのです。Yamoriを使ってみたいという変わり者の方は：cargo install yamoriで、この過剰なテストツールをインストールできます。あなたのターミナルをカラフルに彩るヤモリをぜひ体験してください！...そして私のように「本末転倒なツール開発」の罠に陥らないよう、ご注意を。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[KotlinでAndroidアプリを作ってみる（超初級編）]]></title>
            <link>https://qiita.com/masaru-komiyama/items/8231c0e69d9fb54909aa</link>
            <guid>https://qiita.com/masaru-komiyama/items/8231c0e69d9fb54909aa</guid>
            <pubDate>Mon, 03 Mar 2025 13:22:04 GMT</pubDate>
            <content:encoded><![CDATA[インフラ屋でもクソアプリを作りたくなる夜があるじゃない！と、言うことで本日は手元のMac端末でKotlinを触ってみようと思います。超初級編なので、あまり深い記事は期待しないでください。とりあ…]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[技術的負債と立ち向かう前に知っておいてもいいこと]]></title>
            <link>https://sreake.com/blog/think-about-technical-debt/</link>
            <guid>https://sreake.com/blog/think-about-technical-debt/</guid>
            <pubDate>Mon, 03 Mar 2025 10:46:12 GMT</pubDate>
            <content:encoded><![CDATA[はじめに こんにちは、nwiizoです。開発チームの会話の中で「これは技術的負債だから後で対処しよう」という言葉をよく耳にします。納期に追われるプロジェクトでは、この「後で」が永遠の「いつか」になりがちです。結果として多 […]The post 技術的負債と立ち向かう前に知っておいてもいいこと first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ユーザーストーリーにこだわって、プロダクトバックログをスクラムチームが行う作業の唯一の情報源として成立させる]]></title>
            <link>https://sreake.com/blog/step-up-product-backlog-and-user-story-development/</link>
            <guid>https://sreake.com/blog/step-up-product-backlog-and-user-story-development/</guid>
            <pubDate>Mon, 03 Mar 2025 01:17:49 GMT</pubDate>
            <content:encoded><![CDATA[Sreake事業部アプリケーション開発チームの安本です。 現在、スクラムでアプリケーション開発の概念検証（Proof of Concept; PoC）を進めています。 本記事では、スクラム開発を行っているチーム向けに、私 […]The post ユーザーストーリーにこだわって、プロダクトバックログをスクラムチームが行う作業の唯一の情報源として成立させる first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[くちあだきみあむはしきぎ]]></title>
            <link>https://qiita.com/masaru-komiyama/items/0160cf23fbe2576f869c</link>
            <guid>https://qiita.com/masaru-komiyama/items/0160cf23fbe2576f869c</guid>
            <pubDate>Sun, 02 Mar 2025 12:57:49 GMT</pubDate>
            <content:encoded><![CDATA[おい！タイトルバグってんぞ！　と思われた皆様。安心してください。バグっておりません。電気回路を嗜んだ方なら、何かあったときについ口ずさんでしまう復活の呪文（まぁ色んな意味で記憶を呼び起こす呪文なの…]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[2025/02/28] #kubenews 今週のKubernetes + Cloud Native + その他ニュース]]></title>
            <link>https://zenn.dev/bells17/articles/k8s-cloud-native-and-other-20250228</link>
            <guid>https://zenn.dev/bells17/articles/k8s-cloud-native-and-other-20250228</guid>
            <pubDate>Fri, 28 Feb 2025 10:19:14 GMT</pubDate>
            <content:encoded><![CDATA[#kubenewsの2025年02月28日の回で話す、@bells17が最近気になったニュース記事をまとめたものです。自分が気になった今週のKubernetes + Cloud Native + その他なニュースをまるっとまとめておいて、その中から時間内に話せるものを話そうと思ってます。この記事自体はざっと読んで書いてるものが多いので、詳細はリンクとかで貼ってる記事の中を読んでもらった方が正確です。配信URL:https://www.youtube.com/live/e4qQt7sQ46Y 告知とかニュースっぽいもの コードを読んで理解するko buildhttps...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AIエージェント元年@日本生成AIユーザ会]]></title>
            <link>https://speakerdeck.com/shukob/aiezientoyuan-nian-at-ri-ben-sheng-cheng-aiyuzahui</link>
            <guid>https://speakerdeck.com/shukob/aiezientoyuan-nian-at-ri-ben-sheng-cheng-aiyuzahui</guid>
            <pubDate>Fri, 28 Feb 2025 05:00:00 GMT</pubDate>
            <content:encoded><![CDATA[https://genai-users.connpass.com/event/344332/2024年は生成AIが世の中に浸透した1年でしたが、2025年はAIエージェント元年と言われています。生成AIはチャットベースで受け身なものでしたが、AIエージェントは自律的にタスクを分解しこなすことができます。そのインパクトは計り知れません。生成AIの概略を説明した後、AIエージェントの紹介をします。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Neovimで使うCopilotのモデルをClaudeに変更する苦労話 - 技術ブログ未満の個人的体験談]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/02/27/184558</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/02/27/184558</guid>
            <pubDate>Thu, 27 Feb 2025 09:45:58 GMT</pubDate>
            <content:encoded><![CDATA[免責事項: この記事は個人的な発見と試行錯誤を記録したものであり、正式なドキュメントに基づく推奨設定ではありません。ここで紹介する方法を実際の環境に適用する際は、十分な検証と自己責任でお願いします。はじめにこんにちは、Neovimユーザーのnwiizoです。今回は、NeovimでCopilotを使う際にAIモデルをClaudeに変更しようとして遭遇した「ちょっとした冒険」について共有したいと思います。最近、mizchiさんの最高のブログを読んだ。zenn.devこの記事を読んで魂を揺さぶられた。だが、まだVSCodeには移行しない。Neovimを使い続けることを決意した。揺らいだ。しかし、Neovim環境でもCopilotのAIモデルを自由に変更できたほうが良いと思い、特にClaudeモデルを試してみることにした。やりたかったこと最近、GitHub Copilotが Claude-3.7-sonnetなどのAnthropicのモデルをサポートするようになり、コーディング支援にもっと高度なAIの力を借りたいと思いました。GitHubの公式ドキュメント「Copilot Chat の AI モデルを変更する」によると、Copilot ChatのデフォルトLLMを別のモデルに変更できるようになっています。私のNeovim環境ではyetone/avante.nvimを使用してCopilotとの対話を行っていたので、このプラグインの設定でモデルを変更しようとしました。syu-m-5151.hatenablog.com最初の試み（失敗）まず試したのは、avante.nvimの設定で直接モデルを指定する方法です：{    "yetone/avante.nvim",    event = "VeryLazy",    lazy = false,    version = false,    opts = {      provider = "copilot", -- copilotを使用      auto_suggestions_provider = "copilot",      copilot = {        endpoint = "https://api.githubcopilot.com",        model = "claude-3.7-sonnet", -- ここでClaudeモデルを指定        timeout = 30000,        temperature = 0,        max_tokens = 4096,      },      -- 以下省略...    },    -- 依存関係などの設定...}しかし、この設定を適用してもなぜか期待通りの動作をしませんでした。デバッグを試みましたが、avante.nvimの設定だけではモデルの変更がうまく反映されていないようでした。というかこのような設定はたぶんなくて⋯。解決策：CopilotChat.nvimの力を借りる調査を進めるうちに、面倒になってCopilotC-Nvim/CopilotChat.nvimというプラグインの設定も変更しようと思いました。このプラグインはCopilotのチャットインターフェースを提供するもので、モデル設定も直接サポートしています。試しに以下の設定を追加してみました：-- Copilotチャット用の設定{  "CopilotC-Nvim/CopilotChat.nvim",  event = { "VeryLazy" },  branch = "main",  dependencies = {    { "zbirenbaum/copilot.lua" },    { "nvim-lua/plenary.nvim" },  },  opts = {    model = "claude-3.7-sonnet", -- モデル名を指定    debug = true, -- デバッグを有効化  },}そして驚いたことに、この設定を追加した後、avante.nvim側でもClaudeモデルが使われるようになりました！どうやら、CopilotChat.nvimの設定がcopilot.luaの基本設定に影響を与え、それがavante.nvimにも「引きずられて」反映されたようです。【注意】これは技術ブログ未満の個人的な発見であり、正式なドキュメントに基づくものではありません。このような依存関係による予期せぬ影響は、本番環境では深刻な問題を引き起こす可能性があります。設定の影響範囲を十分理解せずに適用すれば、システム全体に致命的な影響を及ぼす可能性があることを肝に銘じてください。なぜこうなったのか？正確な理由は不明ですが、おそらく両方のプラグインが同じzbirenbaum/copilot.luaに依存しており、この共通の依存関係を通じて設定が共有されたのだと思われます。CopilotChat.nvimがより直接的にCopilot APIとの連携部分を制御しているため、そちらでの設定が優先されたのでしょう。教訓Neovimのプラグインエコシステムでは、依存関係の連鎖によって予想外の相互作用が発生することがあります。今回のケースでは幸いにも望んだ結果につながりましたが、これは完全に「技術ブログ未満」の個人的な発見に過ぎません。警告: このような依存関係の連鎖による予期せぬ相互作用は、本番環境では極めて危険です。プラグイン間の隠れた依存関係による設定の「引きずり」は、デバッグが困難な問題を引き起こし、最悪の場合、本番システムの停止や重大なセキュリティ問題につながる可能性があります。設定変更の影響範囲を完全に理解しないまま適用することは、言わば地雷原を歩くようなものであることを忘れないでください。他の方も同様の状況に遭遇した場合、両方のプラグインを併用する方法が一つの解決策になるかもしれません。最終的な設定結局、私の設定はavante.nvimとCopilotChat.nvimの両方を含む形になりました：-- avante.nvimの設定（一部省略）{    "yetone/avante.nvim",    -- 省略...    opts = {      provider = "copilot",      auto_suggestions_provider = "copilot",      copilot = {        endpoint = "https://api.githubcopilot.com",        model = "claude-3.7-sonnet",        -- 省略...      },    },    -- 省略...},-- CopilotChat.nvimの設定{  "CopilotC-Nvim/CopilotChat.nvim",  event = { "VeryLazy" },  branch = "main",  dependencies = {    { "zbirenbaum/copilot.lua" },    { "nvim-lua/plenary.nvim" },  },  opts = {    model = "claude-3.7-sonnet",    debug = true,  },},これでNeovimでのコーディング体験がClaudeの能力で強化され、より的確なコード提案や説明が得られるようになりました。Neovimの設定は時に「魔法」のように思えることもありますが、それも含めて楽しいハック体験の一部なのでしょう。注：この記事は2025年2月時点の情報に基づいています。Copilotの仕様やプラグインの動作は変更される可能性があります。参考リンクGitHub Copilot Chat の AI モデルを変更する方法yetone/avante.nvimCopilotC-Nvim/CopilotChat.nvimzbirenbaum/copilot.lua]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google Cloud Model Armorによるプロンプトインジェクション対策]]></title>
            <link>https://sreake.com/blog/prompt-injection-protection-with-google-cloud-model-armor/</link>
            <guid>https://sreake.com/blog/prompt-injection-protection-with-google-cloud-model-armor/</guid>
            <pubDate>Thu, 27 Feb 2025 02:14:57 GMT</pubDate>
            <content:encoded><![CDATA[はじめに 昨年2024年は生成AIアプリケーションの開発が本格化し、RAG（Retrieval-Augmented Generation）が爆発的に流行した年でした。今年2025年はAIエージェントの年になると考えられて […]The post Google Cloud Model Armorによるプロンプトインジェクション対策 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AI時代におけるMLOpsのTips]]></title>
            <link>https://speakerdeck.com/shukob/aishi-dai-niokerumlopsnotips</link>
            <guid>https://speakerdeck.com/shukob/aishi-dai-niokerumlopsnotips</guid>
            <pubDate>Sat, 22 Feb 2025 05:00:00 GMT</pubDate>
            <content:encoded><![CDATA[https://event.ospn.jp/osc2025-spring/session/2017030AI時代におけるMLOpsのTips 〜 MLOpsを加速させるOSS 〜オープンソースカンファレンス2025 Tokyo/SpringライトニングトークにてKubeflowの紹介などMLOpsの話をさせていただきました。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AIエージェント元年]]></title>
            <link>https://speakerdeck.com/shukob/aiezientoyuan-nian</link>
            <guid>https://speakerdeck.com/shukob/aiezientoyuan-nian</guid>
            <pubDate>Fri, 21 Feb 2025 05:00:00 GMT</pubDate>
            <content:encoded><![CDATA[https://genai-users.connpass.com/event/344292/2024年は生成AIが世の中に浸透した1年でしたが、2025年はAIエージェント元年と言われています。生成AIはチャットベースで受け身なものでしたが、AIエージェントは自律的にタスクを分解しこなすことができます。そのインパクトは計り知れません。生成AIの概略を説明した後、AIエージェントの紹介をします。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コンテナサプライチェーンセキュリティ]]></title>
            <link>https://speakerdeck.com/kyohmizu/kontenasapuraitiensekiyuritei</link>
            <guid>https://speakerdeck.com/kyohmizu/kontenasapuraitiensekiyuritei</guid>
            <pubDate>Fri, 21 Feb 2025 05:00:00 GMT</pubDate>
            <content:encoded><![CDATA[イベント登壇資料です。2025/02/21 #CNCJhttps://cncj-security.connpass.com/event/341812/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[OpenClarityの裏側を知りたい]]></title>
            <link>https://speakerdeck.com/kojake_300/openclaritynoli-ce-wozhi-ritai-fe15f317-ff7b-4f9e-acd4-8d389e3ebed8</link>
            <guid>https://speakerdeck.com/kojake_300/openclaritynoli-ce-wozhi-ritai-fe15f317-ff7b-4f9e-acd4-8d389e3ebed8</guid>
            <pubDate>Thu, 20 Feb 2025 05:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[🦀 Automating Rust Dependency Management - A Deep Dive into cargo-autodd]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/02/20/121157</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/02/20/121157</guid>
            <pubDate>Thu, 20 Feb 2025 03:11:57 GMT</pubDate>
            <content:encoded><![CDATA[📖 IntroductionWhen developing Rust projects, we frequently need to add new crates or remove unused ones. While Rust provides the cargo add command as a standard tool for managing dependencies from the command line:cargo add serde --features deriveHowever, cargo add requires manual execution and doesn't detect or remove unused dependencies. To further automate this dependency management process, I developed "cargo-autodd" 🚀.I developed "cargo-autodd", a CLI tool to automate dependency management in Rust. It analyzes use statements and extern crates to add required crates to Cargo.toml. Release planned this week with nvim support.https://t.co/ZNfOu4AxEd pic.twitter.com/Tsh0KzEiZV— nwiizo (@nwiizo) 2025年2月16日   🎯 What is cargo-autodd?cargo-autodd is a tool that automatically analyzes Rust source code to detect required dependencies and updates Cargo.toml accordingly.github.comKey features include:🔍 Analysis of use statements and extern crate declarations in source code🤖 Automatic detection of required crates⬆️ Addition of latest stable versions to Cargo.toml🗑️ Removal of unused crates⚡ Advanced analysis using rust-analyzer (optional)🛠️ Technical Details📊 Project Structure AnalysisThe analysis is centered around the DependencyManager struct, which has the following fields:struct DependencyManager {    project_root: PathBuf,  // Project root directory    cargo_toml: PathBuf,    // Path to Cargo.toml}🔄 Dependency Analysis ProcessThe analyze_dependencies method performs analysis in three stages:🚀 rust-analyzer Analysis (Priority)let output = Command::new("rust-analyzer")    .arg("analysis")    .arg("--workspace")    .current_dir(&self.project_root)    .output()?;📝 Regex Analysis (Fallback)let use_regex = Regex::new(r"use\s+([a-zA-Z_][a-zA-Z0-9_]*)(::|\s|;)")?;let extern_regex = Regex::new(r"extern\s+crate\s+([a-zA-Z_][a-zA-Z0-9_]*)")?;✅ Result Aggregation and VerificationRecords usage locations and feature flags for each detected crateExcludes standard library cratesEliminates duplicates📝 Cargo.toml Update MechanismThe update_cargo_toml method updates dependencies through the following steps:📖 Reading Current Dependencieslet content = fs::read_to_string(&self.cargo_toml)?;let mut doc = content.parse::<DocumentMut>()?;➕ Adding New Dependenciesfor (name, crate_ref) in crate_refs {    if !current_deps.contains(name) && !is_std_crate(name) {        self.add_dependency(&mut doc, crate_ref)?;    }}➖ Removing Unused DependenciesPreserves essential dependencies specified by is_essential_depfn is_essential_dep(name: &str) -> bool {    let essential_deps = [        "serde",        "tokio",        "anyhow",        "thiserror",        "async-trait",        "futures",    ];    essential_deps.contains(&name)}📈 Version Management DetailsVersion management is handled by the get_latest_version method with the following features:🌐 Fetching Latest Version from crates.io APIlet url = format!("https://crates.io/api/v1/crates/{}/versions", crate_name);🚫 Excluding Yanked Versionslet latest_version = response    .versions    .iter()    .find(|v| !v.yanked)?;🔢 Applying Semantic VersioningSpecifies only major and minor versionsAllows automatic patch version updatesOk(format!("^{}.{}.0", version.major, version.minor))📚 Best Practices and Usage Guidelines🔧 PreparationInstall rust-analyzer (recommended)Ensure project builds successfully🚀 Execution StepsRun cargo autodd in the project root directoryReview the changesPay special attention to version specificationsVerify dependency consistency with cargo check🔍 TroubleshootingFalls back to regex analysis if rust-analyzer is unavailableManually correct any falsely detected dependencies🔮 Future PlansFuture enhancements planned for cargo-autodd include:🔍 Enhanced AnalysisMacro expansion and dependency analysisMore accurate feature flag detectionConsideration of conditional compilation (cfg attributes)📦 Extended Dependency ManagementAutomatic management of dev-dependenciesEnhanced workspace supportAutomatic version conflict resolution💻 Improved Developer ExperienceEditor integration (e.g., VSCode extension)More detailed dependency graph visualizationCI automation options🎉 Conclusioncargo-autodd is a powerful tool for automating dependency management in Rust projects. Its strengths can be summarized in three key areas:⚡ Enhanced EfficiencyEliminates manual dependency management overheadMaintains project dependencies at latest necessary versionsImproves maintainability through automated version management🔒 Ensured SafetyAccurate dependency analysis using rust-analyzerProper handling of semantic versioningProtection of essential dependencies🎯 Improved Developer ExperienceSimple usage patternReduced maintenance time through automationClear visualization of project dependenciesThese features allow developers to focus more on essential coding tasks. As an open-source project, it continues to evolve through community feedback and contributions.cargo-autodd is expected to become an increasingly important tool as the Rust ecosystem matures. We hope it serves as an effective solution to the challenge of dependency management for many developers in the Rust community. 🚀日本語版:syu-m-5151.hatenablog.com]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rustの依存関係管理を自動化する - cargo-autoddの紹介]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/02/20/120339</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/02/20/120339</guid>
            <pubDate>Thu, 20 Feb 2025 03:03:39 GMT</pubDate>
            <content:encoded><![CDATA[はじめにRustプロジェクトを開発していると、新しいクレートを追加したり不要なクレートを削除したりする作業は頻繁に発生します。現在、Rustにはcargo addというコマンドが標準で用意されており、コマンドラインから依存関係を追加することができます。cargo add serde --features deriveしかし、cargo addは手動での実行が必要で、また使用していない依存関係の検出や削除は行いません。この依存関係の管理をさらに自動化できないか？という思いから開発したのが「cargo-autodd」です。Rustで開発する際の面倒な依存関係管理を自動化するツール「cargo-autodd」を開発しました。ソースコード内のuse文やextern crate宣言を解析し、必要なクレートを自動でCargo.tomlに追加します。先ほど作ったのでバグや不具合があると思うのでPRお願いします。テストもない。https://t.co/ZNfOu4AxEd pic.twitter.com/RbQNyp0K8H— nwiizo (@nwiizo) 2025年2月16日   cargo-autoddとはcargo-autoddは、Rustのソースコードを解析して必要な依存関係を自動的に検出し、Cargo.tomlを更新するツールです。github.com主な特徴は以下の通りです：ソースコード内のuse文とextern crate宣言を解析必要なクレートを自動検出Cargo.tomlに最新の安定バージョンを追加未使用のクレートを削除rust-analyzerを活用した高度な解析（オプション）技術的な詳細プロジェクト構造の解析プロジェクトの解析はDependencyManager構造体を中心に行われます。この構造体は以下のようなフィールドを持ちます：struct DependencyManager {    project_root: PathBuf,  // プロジェクトのルートディレクトリ    cargo_toml: PathBuf,    // Cargo.tomlのパス}依存関係の解析プロセスanalyze_dependenciesメソッドは、以下の3段階で依存関係を解析します：rust-analyzerによる解析（優先）let output = Command::new("rust-analyzer")    .arg("analysis")    .arg("--workspace")    .current_dir(&self.project_root)    .output()?;正規表現による解析（フォールバック）let use_regex = Regex::new(r"use\s+([a-zA-Z_][a-zA-Z0-9_]*)(::|\s|;)")?;let extern_regex = Regex::new(r"extern\s+crate\s+([a-zA-Z_][a-zA-Z0-9_]*)")?;結果の集約と検証検出された各クレートに対して、使用箇所とフィーチャーフラグを記録標準ライブラリのクレートを除外重複を排除Cargo.tomlの更新メカニズムupdate_cargo_tomlメソッドは、以下の手順で依存関係を更新します：現在の依存関係の読み取りlet content = fs::read_to_string(&self.cargo_toml)?;let mut doc = content.parse::<DocumentMut>()?;新規依存関係の追加for (name, crate_ref) in crate_refs {    if !current_deps.contains(name) && !is_std_crate(name) {        self.add_dependency(&mut doc, crate_ref)?;    }}未使用依存関係の削除ただし、is_essential_depで指定された重要な依存関係は保持fn is_essential_dep(name: &str) -> bool {    let essential_deps = [        "serde",        "tokio",        "anyhow",        "thiserror",        "async-trait",        "futures",    ];    essential_deps.contains(&name)}バージョン管理の詳細バージョン管理はget_latest_versionメソッドで行われ、以下の特徴があります：crates.ioのAPIを使用した最新バージョンの取得let url = format!("https://crates.io/api/v1/crates/{}/versions", crate_name);Yank済みバージョンの除外let latest_version = response    .versions    .iter()    .find(|v| !v.yanked)?;セマンティックバージョニングの適用メジャーバージョンとマイナーバージョンのみを指定パッチバージョンは自動更新可能にOk(format!("^{}.{}.0", version.major, version.minor))ベストプラクティスと使用上の注意点事前準備rust-analyzerのインストール（推奨）プロジェクトのビルドが通っていることを確認実行手順プロジェクトのルートディレクトリでcargo autoddを実行変更内容を必ず確認特にバージョン指定に注意を払うcargo checkで依存関係の整合性を検証トラブルシューティングrust-analyzerが使用できない場合は正規表現による解析にフォールバック誤検出された依存関係は手動で修正今後の展望cargo-autoddの将来的な機能拡張として、以下を計画しています：解析機能の強化マクロの展開とその依存関係の解析より正確なフィーチャーフラグの自動検出条件付きコンパイル（cfg属性）の考慮依存関係管理の拡張開発依存関係（dev-dependencies）の自動管理ワークスペース対応の強化バージョン競合の自動解決開発者体験の向上エディターへの組み込み（VSCode拡張など）より詳細な依存関係グラフの可視化CIでの自動実行オプションまとめcargo-autoddは、Rustプロジェクトにおける依存関係管理の自動化を実現する強力なツールです。その特徴は以下の点にあります：効率性の向上手動での依存関係管理の煩わしさを解消プロジェクトの依存関係を常に最新かつ必要最小限に保持バージョン管理の自動化による保守性の向上安全性の確保rust-analyzerを活用した正確な依存関係の解析セマンティックバージョニングの適切な処理重要な依存関係の保護機能開発者体験の改善シンプルな使用方法自動化による作業時間の削減プロジェクトの依存関係の可視化これらの機能により、開発者はより本質的なコーディング作業に集中できるようになります。また、オープンソースプロジェクトとして公開されているため、コミュニティからのフィードバックや貢献を受け入れながら、さらなる機能改善を進めていく予定です。cargo-autoddは、Rustエコシステムの成熟に伴い、より重要なツールとなることが期待されます。依存関係管理の自動化という課題に対する一つの解決策として、多くの開発者の方々に活用していただければ幸いです。English Edition:syu-m-5151.hatenablog.com]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コードを読んで理解するko build]]></title>
            <link>https://speakerdeck.com/bells17/kotowodu-nteli-jie-suruko-build</link>
            <guid>https://speakerdeck.com/bells17/kotowodu-nteli-jie-suruko-build</guid>
            <pubDate>Wed, 19 Feb 2025 05:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Jagu'e'r Cloud Native #17 ハイブリッド Meetup ~ 推しの CNCF プロジェクトを紹介するぜ LT ~ の登壇資料です。https://jaguer-cloud-native.connpass.com/event/342024/参考リンク・画像など引用元一覧https://ko.build/ https://github.com/ko-build/ko https://github.com/google/go-containerregistry https://github.com/sigstore/cosign https://github.com/opencontainers/image-spec https://github.com/cncf/sandbox/issues/17 https://github.com/ko-build/ko/issues/791 https://github.com/cncf/sandbox/issues/163 https://github.com/cncf/artwork/blob/main/projects/ko/stacked/color/ko-stacked-color.png https://github.com/cncf/artwork/blob/main/projects/ko/icon/color/ko-icon-color.png]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CNCFの公式ブログ「Japan’s CNCF DevStats 2024」にて、スリーシェイク所属のエンジニア2名がCNCFプロジェクトでの貢献者TOP10にランクイン]]></title>
            <link>https://sreake.com/blog/rank-among-top-contributors-to-cncf-projects-in-japan/</link>
            <guid>https://sreake.com/blog/rank-among-top-contributors-to-cncf-projects-in-japan/</guid>
            <pubDate>Tue, 18 Feb 2025 01:00:00 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）は、 CNCF（Cloud Native Computing Foundation）の公式ブログ「Japan’s CNCF DevStats 2024」にて、スリーシェイク所属のエンジニア 早川大貴・長澤翼（以下早川・長澤）がCNCFプロジェクトでの貢献者TOP10にランクインしたことをお知らせします。The post CNCFの公式ブログ「Japan’s CNCF DevStats 2024」にて、スリーシェイク所属のエンジニア2名がCNCFプロジェクトでの貢献者TOP10にランクイン first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AWS SAM と GitHub Actions で爆速でサーバーレス API をデプロイする]]></title>
            <link>https://sreake.com/blog/aws-sam-quick-deploy-with-github-actions/</link>
            <guid>https://sreake.com/blog/aws-sam-quick-deploy-with-github-actions/</guid>
            <pubDate>Sun, 16 Feb 2025 23:00:00 GMT</pubDate>
            <content:encoded><![CDATA[こんにちは。スリーシェイクの小林です。 本日は AWS Serverless Application Model（以下、AWS SAM）と GitHub Actions を用いて サーバーレス API の作成からデプロイ […]The post AWS SAM と GitHub Actions で爆速でサーバーレス API をデプロイする first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[goroutineによる頻出並行処理パターン2選]]></title>
            <link>https://zenn.dev/kamos/articles/c334faad2d3b33</link>
            <guid>https://zenn.dev/kamos/articles/c334faad2d3b33</guid>
            <pubDate>Sun, 16 Feb 2025 08:56:32 GMT</pubDate>
            <content:encoded><![CDATA[はじめにgoruotineはgo言語の軽量スレッドの仕組みであり、並行処理が比較的簡単に実装できます。しかしその自由度の高さから、慣れていない人にとってはどのように実装したらよいのか、という迷いが生まれてしまいます。その中でもよく使う並行処理のパターンは決まっており、今回はよく自分が使うパターンを2つ紹介します。 前提こういう遅くて、エラーも起こる関数をテーマにします。func slowFunction(arg string) (string, error) {	fmt.Printf("SLOW FUNCTION START: %s\n", arg)	start :=...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[自分ばっかり大変と思ってるときは気をつけたほうがいい]]></title>
            <link>https://nnaka2992.hatenablog.com/entry/2025/02/16/140946</link>
            <guid>https://nnaka2992.hatenablog.com/entry/2025/02/16/140946</guid>
            <pubDate>Sun, 16 Feb 2025 05:09:46 GMT</pubDate>
            <content:encoded><![CDATA[仕事をしていて数年ほどたつと自分はこんなに頑張ってるのに評価が低いと思うタイミングが来る。これは後々そんなことはなかったと気がつくものの、そのタイミングにいる間は不適当な評価を受けていると思いがちで、自尊心が肥大しがちである。自分ばっかり頑張っていると感じたときは、自分の仕事が本当に価値を生んでいるのかという観点に立ち返ったほうがいい。やらなくてもいい仕事に忙殺されていないか？ 楽してると思ってる人は本質的な仕事に集中しているのではないか？これはイシューからはじめよでいうところの犬の道に陥っている状態である。自分だけ大変と思っているときは、実際には価値を生み出していないにも限らず、仕事量によ達成感を成果と勘違いしていることが多い。自分ばっかり大変だ、となっているときは価値の低いことに時間を投入していないか見つめ直そうという自戒。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[【基礎】 GoでSpannerを使う]]></title>
            <link>https://zenn.dev/kamos/articles/b06c3ef3de894a</link>
            <guid>https://zenn.dev/kamos/articles/b06c3ef3de894a</guid>
            <pubDate>Sun, 16 Feb 2025 03:29:52 GMT</pubDate>
            <content:encoded><![CDATA[はじめにGoogleのSpannerデータベースはまだまだ知名度が低く、日本語での文献も豊富ではないため、いざ使うとなるとかなり苦労する技術です。ここでは最低限の概念を説明することにつとめ、通常利用においてSpannerのハードルを下げようと思いこの記事を執筆しました。基本的には以下の資料に載っている情報かと思いますが、実際にソースコードを見るとドキュメントの更新が追いついていない部分が多い印象でした。そのためクライアントライブラリのソースコードに可能な限り追従し、できるだけ平易な文章でまとめようと思います。https://cloud.google.com/spanner/do...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[runwasi の cgroup に関する Issue 調査]]></title>
            <link>https://zenn.dev/z63d/articles/48eb53ca4e8467</link>
            <guid>https://zenn.dev/z63d/articles/48eb53ca4e8467</guid>
            <pubDate>Fri, 14 Feb 2025 13:44:01 GMT</pubDate>
            <content:encoded><![CDATA[概要runwasi で cgroup に関する Issue があり、それについての調査の記録です。忘れないように。OCI Runtime ~ コンテナプロセス周りのデバッグのコツを少しつかめた。cgroup に関しても学ぶことが多かった。 runwasirunwasi は Kubernetes で Ｗasm を動かすための shim をつくるライブラリ & いくつかの Wasm runtime 用の shim です。runwasi については以前 Kubernetes Meetup Tokyo #68 KubeCon NA 2024 Recap で話した時の資料と...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[nwiizo はなぜ同じPlatform Engineeringを語るのに、2つの異なる資料を作ったのか #devsumi #PFEM]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/02/14/071127</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/02/14/071127</guid>
            <pubDate>Thu, 13 Feb 2025 22:11:27 GMT</pubDate>
            <content:encoded><![CDATA[はじめにこんにちは、nwiizoです。2025年2月13日に2つのイベントで登壇する機会をいただきました。これは私が翻訳に関わった「Kubernetesで実践するPlatform Engineering」の発売を記念した販促登壇でしたが、原著者さんが書籍の内容自体について話をされると知っていたので、私はPlatform Engineeringという分野に関する自分なりの考えや経験を共有させていただく内容にしました。Kubernetesで実践する Platform Engineering作者:Mauricio Salatino翔泳社Amazon2つの異なるイベントでの発表同日に性質の異なる2つのイベントで話をさせていただきました。Developers Summitでは「インフラをつくるとはどういうことなのか、あるいはPlatform Engineeringについて」というタイトルで、幅広い技術者の方々に向けてPlatform Engineeringの基本的な考え方から実践的なアプローチまでをお話ししました。 speakerdeck.com一方、PFEM特別回では「Platform Engineeringは自由のめまい - 技術の選択における不確実性と向き合う」というテーマで、より専門的な視点からPlatform Engineeringの課題や可能性について話をしました。ただ、この回は資料作りや登壇などの疲れもピークに達していて、本来伝えたかったことと違う説明をしてしまった部分もあったように思います。 speakerdeck.com翻訳作業から得た気づき今回の発表の背景には、「Kubernetesで実践するPlatform Engineering」の翻訳作業があります。2025年2月19日に翔泳社から発売されるこの本は、"Platform Engineering on Kubernetes"の日本語翻訳版で、3-shake の同僚と一緒に取り組んだプロジェクトです。翻訳作業を通じて、Platform Engineeringの課題や可能性について考える機会を多く得ることができました。原著者のsalaboyさんのハンズオンや過去の発表資料、記事を読む中で、Platform Engineeringに対する彼の考え方を学ばせていただきました。実際に一緒に登壇する機会もいただき、私の拙い英会話力にも関わらず温かく接していただいたことも貴重な経験でした。登壇から学んだこと今回の登壇準備と実践を通じて、技術共有における重要な気づきがありました。最も重要だと感じたのは、聴衆のバックグラウンドに合わせて内容を適切に調整することです。Developers SummitとPFEM特別回では、参加者層が大きく異なりました。Developers Summitでは、DevOpsやPlatform Engineeringに詳しくない参加者が多く、日常的な開発における具体的な問題点から入り、それをPlatform Engineeringの文脈で捉え直すことで基礎的な理解を促しました。一方、PFEM特別回では参加者との間に共通認識があったため、より実践的な課題や技術的解決策について深く掘り下げることができました。この違いは技術資料の作成にも影響しました。資料作成では、「知的な発見」と「理解するためのコスト」のバランスが重要です。知的な発見とは「なるほど、そういう考え方があったのか」という新しい視点を得られる瞬間ですが、その発見に至るまでの説明が複雑すぎると理解へのコストが大きくなりすぎてしまいます。多くの技術プレゼンテーションでは既知の問題とその解決策を列挙することに終始しがちですが、それだけでは予想外の学びには至りません。予想外の学びこそが、聴衆の心に残る知的な発見として認知されやすいのです。ここで重要なのは、単に「よくある課題とその解決策」を並べるだけでなく、「明確には意識していなかったけれど、言われてみれば確かにそうだった」という新たな気づきを提供することです。例えば、日々の開発で感じている不便さを Platform Engineering の文脈で捉え直すことで、それが個人の問題ではなく構造的な課題だったと気づく瞬間を作り出せます。かといって基礎的な前提ばかりでは、聴衆にとって新しい気づきが得られません。Developers Summitでは基礎と新知見のバランスを重視し、PFEM特別回では基礎的な説明を最小限に抑え、より深い技術的な議論に時間を割きました。それ以外の「イライラ」「焦り」「困惑」といった感情は、むしろ読者の集中力を削ぎ、本質的な学びを妨げてしまう。技術資料は、共感と発見のポジティブな体験に徹するべきなのだ。確かに、高度な実装や複雑な概念を詰め込んだ資料を作ることは可能だ。しかし、そのような難解な内容は、読者の理解を遠ざけ、結果として伝えたい本質が埋もれてしまう。読者の多くがこのような否定的な感情を抱く資料は、作成者の自己満足に過ぎないと言えるでしょう。2025年ならではの発見として、Xのアルゴリズム変更により画像が優先表示されるようになった現在、印象に残るスライドを含めることが効果的です。複雑な概念を一枚の図で表現することで、SNS上での共有や議論が促進され、発表後もコミュニティでの対話が継続する可能性が高まります。また、Platform Engineeringという新しい分野では、技術コミュニティにおける「共通言語」の重要性も実感しました。Developers Summitではキーとなる概念を具体例と共に丁寧に説明し、PFEM特別回では既存の共通言語を活用してより専門的な議論を展開しました。知識を一方的に伝えるのではなく、参加者との対話を通じて互いに学び合える場を作ることを心がけ、翻訳者兼登壇者としての過剰な発言は控えました。この経験を通じて、技術を伝えることは単なる知識の転送ではなく、聴衆のコンテキストに寄り添いながら対話を生み出すプロセスだと実感しました。イベントの性質や参加者層によって求められる内容や深さが異なることを学び、今後もこの気づきを活かしながら効果的な技術共有を目指していきます。おわりに2つのイベントでの発表資料は異なる切り口で作成しましたが、どちらも力を入れて準備させていただきました。より詳細な内容についてはぜひ資料をご覧いただければと思います。また、完全版については機会があればお話させていただきたいと考えていますので、ご興味がありましたらぜひご依頼ください。最後に、この経験を通じて得られた知見を今後の活動にも活かしていきたいと考えています。ご清聴いただいた皆様、そして貴重な機会を提供してくださった関係者の皆様に心より感謝申し上げます。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[インフラをつくるとはどういうことなのか、 あるいはPlatform Engineeringについて]]></title>
            <link>https://speakerdeck.com/nwiizo/inhurawotukurutohadouiukotonanoka-aruihaplatform-engineeringnituite</link>
            <guid>https://speakerdeck.com/nwiizo/inhurawotukurutohadouiukotonanoka-aruihaplatform-engineeringnituite</guid>
            <pubDate>Thu, 13 Feb 2025 05:00:00 GMT</pubDate>
            <content:encoded><![CDATA[2025年02月13日 Developers Summit 2025 13-E-4 にて「インフラをつくるとはどういうことなのか、 あるいはPlatform Engineeringについて - Platform Engineeringの効果的な基盤構築のアプローチ」というタイトルで登壇します。同日にPFEM特別回 でも登壇するのですが資料頑張って作ったのでそっちも読んでください。完全版は機会があればお話するので依頼してください。イベント名:  Developers Summit 2025公式URL: https://event.shoeisha.jp/devsumi/20250213セッションURL: https://event.shoeisha.jp/devsumi/20250213/session/5546登壇ブログ: https://syu-m-5151.hatenablog.com/entry/2025/02/14/071127]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[国内４大通信キャリアのビジネスまとめ表]]></title>
            <link>https://qiita.com/masaru-komiyama/items/07b8eec241e41c1e0ebb</link>
            <guid>https://qiita.com/masaru-komiyama/items/07b8eec241e41c1e0ebb</guid>
            <pubDate>Thu, 13 Feb 2025 01:24:19 GMT</pubDate>
            <content:encoded><![CDATA[ふと、「国内通信キャリア各社のビジネスってどうなってるんだろう。サクッと確認したいからまとまった表があるといいなぁ」　と検索した際、あまり良い情報がヒットしなかった ＆ AI使っても微妙な結果しか得…]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Platform Engineeringは自由のめまい ]]></title>
            <link>https://speakerdeck.com/nwiizo/platform-engineeringhazi-you-nomemai</link>
            <guid>https://speakerdeck.com/nwiizo/platform-engineeringhazi-you-nomemai</guid>
            <pubDate>Wed, 12 Feb 2025 05:00:00 GMT</pubDate>
            <content:encoded><![CDATA[2025年02月13日 Kubernetesで実践するPlatform Engineering発売記念！ PFEM特別回にて「Platform Engineeringは自由のめまい - 技術の選択における不確実性と向き合う」というタイトルで登壇します。同日にDevelopers Summit 2025 でも登壇したのですが資料頑張って作ったのでそっちも読んでください。イベント名: Kubernetesで実践するPlatform Engineering発売記念！ PFEM特別回公式URL: https://platformengineering.connpass.com/event/342670/登壇ブログ: https://syu-m-5151.hatenablog.com/entry/2025/02/14/071127]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Neovimで始めるGitHub Copilot - copilot.lua による Language Server の設定方法]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/02/11/183337</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/02/11/183337</guid>
            <pubDate>Tue, 11 Feb 2025 09:33:37 GMT</pubDate>
            <content:encoded><![CDATA[github.blogこの設定は一時的なものであり、LSPのインストーラーが対応したらそちらで対応してください。github.comはじめに2025年2月10日、GitHubはCopilot Language Server SDKを公開しました。これは、エディタやIDEがLanguage Server Protocol（LSP）を通じてGitHub Copilotと連携できるものです。このリリースは、開発者がより柔軟にCopilotを利用できるようになる重要な一歩です。今までGitHub CopilotはVS Code、Visual Studio、JetBrains IDEs、Vim/Neovim、そして最近ではXcodeでも利用可能でしたが、これらのエディタすべてがCopilot Language Serverを使用して実装されていました。GitHubは開発者の選択肢を重視し、好みのエディタでCopilotを使用できるようにすることを目指しているみたいです。Copilotの進化NeovimでのCopilot利用は、以前はgithub/copilot.vimを通じて行われていました。このVimscriptベースのプラグインは、多くの開発者に利用されてきた公式の実装です。その後、Lua APIを活用したzbirenbaum/copilot.luaが登場しましたが、これも内部的にはcopilot.vimを通じてGitHub Copilotと通信を行っていました。このアーキテクチャでは、copilot.luaがNeovimのモダンなLua APIを活用した柔軟なインターフェースを提供し、バックエンドではcopilot.vimが実際のCopilotサービスとの通信を担当するという二層構造になっていました。そして今回のLanguage Server SDKの公開により、エディタとCopilotの連携方法が標準化され、直接Language Server Protocolを介してCopilotと通信できるようになりました。これにより、中間レイヤーが不要になり、より効率的で安定した実装が可能になりました。前提条件Neovim 0.8.0以上Node.js 18.x以上GitHubアカウント（Copilotのサブスクリプション）インストール手順1. Copilot Language Serverのインストールまず、Neovimの設定ディレクトリにCopilot用のディレクトリを作成し、Language Serverをインストールします。# Copilot用ディレクトリの作成mkdir -p ~/.config/nvim/copilot/# Language Serverのインストールnpm install @github/copilot-language-server -g --prefix ~/.config/nvim/copilot/# 実行権限の付与chmod +x ~/.config/nvim/copilot/bin/copilot-language-server2. Neovimプラグインのインストールlazy.nvimを使用している場合、以下の設定を~/.config/nvim/lua/plugins/copilot.luaに追加します。return {  "zbirenbaum/copilot.lua",  lazy = false,  priority = 1000,  config = function()    require("copilot").setup {      suggestion = { enabled = false },      panel = { enabled = false },      server_opts_overrides = {        trace = "verbose",        cmd = {          vim.fn.expand("~/.config/nvim/copilot/bin/copilot-language-server"),          "--stdio"        },        settings = {          advanced = {            listCount = 10,            inlineSuggestCount = 3,          },        },      },      filetypes = {        yaml = true,        markdown = true,        help = false,        gitcommit = true,        gitrebase = true,        hgcommit = false,        svn = false,        cvs = false,        ["."] = false,        ["*"] = true,      },    }  end,}3. 認証設定Neovimを起動後、以下のコマンドで認証を行います。:Copilot authブラウザが開き、GitHubアカウントでの認証が求められます。認証が完了すると、Copilotが使用可能になります。設定の説明設定の主要なポイントを解説します。この設定は私の設定ファイルなので自由に設定してください。suggestionとpanelenabled = false: デフォルトのサジェスト機能を無効化していますserver_opts_overridescmd: インストールしたLanguage Serverのパスと起動オプションを指定vim.fn.expand("~/.config/nvim/copilot/bin/copilot-language-server"): Language Serverの実行ファイルのパスを指定。vim.fn.expand()関数を使用して~をホームディレクトリに展開"--stdio": Language Serverが標準入出力（stdio）を使用してNeovimと通信することを指定するオプションsettings.advanced:   - settings.advanced:listCount: 候補の表示数（10個）inlineSuggestCount: インラインサジェストの数（3個）filetypes各ファイルタイプでのCopilotの有効/無効を設定["*"] = true: デフォルトですべてのファイルタイプで有効トラブルシューティングLanguage Serverが見つからない場合Error: Language server is not installed or not executableパスが正しいか確認実行権限が付与されているか確認chmod +xコマンドで実行権限を付与認証エラーの場合:Copilot authを再実行GitHubアカウントのサブスクリプション状態を確認まとめGitHub Copilot Language Server SDKの公開により、Neovimでより直接的にCopilotを利用できるようになりました。これまでのcopilot.vimを経由する方式から、直接Language Server Protocolを使用する方式への移行により、より効率的で保守性の高い実装が可能になりました。新しいSDKはnpmjs.comで公開されており、誰でも利用可能です。この変更により、エディタ開発者はより簡単にCopilotを統合でき、ユーザーはより安定した開発体験を得られるようになります。また、この方法は本来であれば不要でありlspconfigにコントリビューションすればよい()。github.com参考リンクGitHub Copilot Language Server SDK announcementCopilot.lua DocumentationLanguage Server Protocol SpecificationGitHub Copilot.vim]]></content:encoded>
        </item>
    </channel>
</rss>