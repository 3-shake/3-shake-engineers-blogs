<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Mon, 23 Dec 2024 22:33:26 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[RのSys.time()でミリ秒以下を表示する]]></title>
            <link>https://blog.atusy.net/2024/12/24/r-time-subsec/</link>
            <guid>https://blog.atusy.net/2024/12/24/r-time-subsec/</guid>
            <pubDate>Tue, 24 Dec 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Sys.time()でミリ秒以下を表示するには、digits.secオプションか、format関数を使うといいよ。いずれも最大でマイクロ秒までの表示に対応。データの実態を知ってると、ナノ秒以下の情報も取得可能。ただし、精度はOS依存。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[これまで作成してきたGopherくん基板を振り返る]]></title>
            <link>https://zenn.dev/satoken/articles/gopher-board-history</link>
            <guid>https://zenn.dev/satoken/articles/gopher-board-history</guid>
            <pubDate>Mon, 23 Dec 2024 16:00:44 GMT</pubDate>
            <content:encoded><![CDATA[この記事はTinyGo Advent Calendar 2024 24日目の記事です。 はじめにこれまでいろいろと作成してきたGopherくん基板の歴史を振り返ってみようと思います。 初期記念すべき最初のGopher基板は失敗でした笑笑深圳で買ったきたATmega32u4を使う基板を作ろうとしましたが、線を引き忘れて失敗しました。基板にチップを乗っけるよりも、既成品のマイコンボードを組み込むほうが楽だなと思い次に行きます。次に作ったのはArduino Pro miniを組み込んだものでした。どうしてPro miniを選んだのかは思い出せません。これは問題なく動き...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2024年 俺が愛した本たち 技術書編]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/12/23/174750</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/12/23/174750</guid>
            <pubDate>Mon, 23 Dec 2024 08:47:50 GMT</pubDate>
            <content:encoded><![CDATA[この記事は、3-shake Advent Calendar 2024 24日目のエントリ記事です。はじめに2024年も残りわずかとなりました。年の瀬に差し掛かるこの時期、1年の歩みを振り返り、時の流れを見つめ直すことは、私にとって特別な意味を持っています。今年は特に、技術書との関わり方に大きな変化がありました。本を紹介する投稿する中で、技術書のみならず、さまざまな分野の書籍を読む機会が大幅に増えました。私の書斎は、いつの間にか技術書のデータセンターと化しました。サーバーラックの代わりに本棚が整然と並び、それぞれの棚には未読の本という名のサーバーがぎっしりと配置されています。これらの「サーバー」は、24時間365日、知識というバックグラウンドプロセスを静かに実行し続けています。メモリの使用率は常に100%ですが、まだ、クラッシュすることはありません。クラッシュしたら次の年はこの文章を読むことができません。特に今年は、技術書との向き合い方を見つめ直した1年でした。これまでのように「量」を追い求めるのではなく、一冊一冊を深く理解し、質を重視することに注力しました。技術書は単なる情報の集合体ではなく、先人たちの経験や洞察が凝縮された知恵の結晶です。その知恵を丁寧に咀嚼し、自分の中に取り込む過程が、エンジニアとしての成長に直結することを改めて実感しました。この記事では、2024年に私が出会い、心を揺さぶられた技術書たちを厳選してご紹介します。これらの書籍が、読者の皆様に新たな発見と学びをもたらすきっかけになれば幸いです。はじめに昨年以前に読んだ本2024年に読んでよかった技術書Platform Engineering on KubernetesPlatform EngineeringContinuous DeploymentCloud Observability in ActionLearning OpenTelemetryBecoming SREFundamentals of Data EngineeringTidy First?プログラミングRust 第2版Effective Rustバックエンドエンジニアを目指す人のためのRustReal World HTTP 第3版【改訂新版】システム障害対応の教科書おわりに昨年以前に読んだ本syu-m-5151.hatenablog.comsyu-m-5151.hatenablog.comsyu-m-5151.hatenablog.com2024年に読んでよかった技術書今年も、私の知識データベースは絶え間なく更新され続けました。読書から得た知識は、ソフトウェアエンジニアとしての実務という名のプロダクション環境で厳密にテストされ、その成果は、いくつかの技術イベントでの登壇という形でデプロイされました。幸いにも、これまでクリティカルな障害が発生したことはありません。私の脳内APIは、多くの技術書から寄せられるリクエストを処理し続けています。レスポンスタイムは決して速いとは言えませんが、スループットは着実に向上しています。そして以下では、2024年に私の知識基盤に大きなアップデートをもたらした技術書を紹介します。これらの書籍は、私に新しい視点やスキルを与え、成長の助けとなりました。speakerdeck.comPlatform Engineering on Kubernetes「Platform Engineering on Kubernetes」は、クラウドネイティブ時代のプラットフォームエンジニアリングの本質と実践を包括的に解説した一冊です。本書は、単なるKubernetesの解説書を超えて、現代のソフトウェア開発組織が直面する課題とその解決策を体系的に示しています。Platform Engineering on Kubernetes (English Edition)作者:Salatino, MauricioManningAmazon本書の核心は、「なぜKubernetes上にプラットフォームを構築する必要があるのか」という根本的な問いに対する答えを提示している点です。著者は、複数のチームが関わり、複数のクラウドプロバイダーへのデプロイを行い、異なるスタックを扱う組織では、Kubernetesの導入だけでは不十分であることを説き、プラットフォームエンジニアリングによってこれらの課題を技術的・組織的に解決する方法を示しています。特に印象的なのは、プラットフォームチームと開発チームの協調に関する著者の洞察です。プラットフォームは単なる技術的な基盤ではなく、開発者の生産性を最大化し、ビジネス価値の迅速な提供を可能にする戦略的な資産として位置づけられています。これは、DevOpsの理想をクラウドネイティブ時代に実現するための具体的なアプローチと言えます。本書は、概念的な解説に留まらず、実践的なステップバイステップのガイドも提供しています。カンファレンスアプリケーションというサンプルを通じて、プラットフォームの設計から実装、運用までを一貫して学ぶことができます。これにより、読者は理論と実践の両面から、プラットフォームエンジニアリングの本質を理解できます。また、本書はCrossplane、ArgoCD、Dapr、OpenFeatureなど、現代のクラウドネイティブツールの活用法も詳しく解説しています。これらのツールを適切に組み合わせることで、開発者体験の向上とインフラストラクチャの効率化を両立できることが示されています。この本を読み進める中で、プラットフォームエンジニアリングが単なる技術的な取り組みを超えて、組織全体のデジタルトランスフォーメーションを推進する原動力となり得ることを実感しました。著者の提示する知見は、エンジニアリング組織の次なるステージを考える上で、貴重な指針となるでしょう。Platform Engineering「Platform Engineering: A Guide for Technical, Product, and People Leaders」は、現場での実践知を出発点として、プラットフォームエンジニアリングの本質に迫る実践的なガイドです。技術リーダーから上級管理職まで向けた幅広い読者層に向けて書かれており、個人的にはもう少しだけ広げて開発者やプラットフォームを実際に使う側も読んでも学びのある本だと感じました。Platform Engineering: A Guide for Technical, Product, and People Leaders (English Edition)作者:Fournier, Camille,Nowland, IanO'Reilly MediaAmazon本書を読む前に、「Team Topologies」を一読することを強くお勧めします。「Team Topologies」は、現代のソフトウェア開発組織における効果的なチーム構造とその相互作用のパターンを提示しており、プラットフォームチームの位置づけや役割を理解する上で不可欠な知見を提供してくれます。この基礎的な理解があることで、本書で展開されるプラットフォームエンジニアリングの実践論をより深く理解することができます。チームトポロジー　価値あるソフトウェアをすばやく届ける適応型組織設計作者:マシュー・スケルトン,マニュエル・パイス日本能率協会マネジメントセンターAmazon著者のの豊富な経験が凝縮された本書は、単なる表面的な手法の模倣ではなく、実際の現場での試行錯誤から導き出されたプラクティス、そしてその背後にある根本的な原理と思想を探求しています。それが現代のソフトウェア開発組織においていかに革新的な価値を生み出すかを浮き彫りにしている点が特徴的です。本書の真価は、プラットフォームエンジニアリングを単なる技術的な手法の集合としてではなく、日々の実践から得られた知見を体系化し、組織の進化と持続的な成長を促す戦略的な思考基盤として捉えている点にあります。技術的な実装の詳細よりも、組織が現場の文脈に根ざした実践を重ね、そこからプラクティスを抽出し、最終的にプラットフォームエンジニアリングの本質的な原則を理解して創造的に応用していく方法論に重点が置かれています。技術的な側面、特にCloud Nativeな実装に興味がある方には、「Platform Engineering on Kubernetes」がおすすめです。こちらの書籍では、Kubernetesを基盤としたプラットフォームエンジニアリングの実践的なアプローチが詳細に解説されています。両書を併読することで、プラットフォームエンジニアリングの組織的側面と技術的側面の両方を深く理解することができ、より包括的な知識を得ることができるでしょう。本書は、プラットフォームエンジニアリングの現場で直面する本質的な難しさを率直に語っています。具体的には、「技術的に面白いから作る」のではなく現場で真に必要とされるものを見極めて提供するという価値提供の本質、計画の難しさを認識しつつも現場の文脈に応じて適切に実行するという実践知、そして組織の重要なシステムを支える責任を全うするための運用の成熟という現場力の醸成といった課題を挙げています。これらの課題に対して、本書は原則に基づきながらも現場の実態に即した解決の道筋を示しています。最後に、読者として強く感じたのは、プラットフォームエンジニアリングが単なる技術的な課題ではなく、組織的な取り組みとして捉える必要があるという点です。特に、チームの持続可能性とユーザー満足度の両立という観点から、著者の提案する実践的なアプローチは非常に価値があります。本書で提示されているプラクティスは、理想的ではありますが現実的な目標として設定されており、段階的な改善のためのロードマップとしても機能します。特に重要なのは、組織の規模や成熟度に応じて適切なアプローチを選択し、継続的に改善を進めていく姿勢だと考えています。Continuous Deployment「Continuous Deployment」は、継続的デプロイメントの実践に焦点を当てた包括的なガイドです。継続的デプロイメントは、ソフトウェアパイプラインを完全に自動化し、手動介入を必要としない手法です。この方法により、クオリティーゲートを通過したすべてのコードコミットが自動的に本番環境にデプロイされます。Continuous Deployment: Enable Faster Feedback, Safer Releases, and More Reliable Software (English Edition)作者:Servile, ValentinaO'Reilly MediaAmazon本書の理解をより深めるためには、「Grokking Continuous Delivery」との併読をお勧めします。この本は、継続的デリバリーの基本概念から実践的な実装まで、体系的に解説しています。特に、継続的デプロイメントへの段階的な移行プロセスや、組織文化の変革について、実践的な知見を提供してくれます。両書を読み進めることで、継続的デプロイメントの技術的側面と組織的側面の両方を包括的に理解することができます。Grokking Continuous Delivery (English Edition)作者:Wilson, ChristieManningAmazonこちらの本は日本語版がリリースされています。入門 継続的デリバリー ―テストからリリースまでを安全に自動化するソフトウェアデリバリーのプロセス作者:Christie Wilsonオーム社Amazon本書は、単なる技術的な実装の解説に留まらず、プラットフォームエンジニアリングと開発プロセス全体を変革する可能性について深く掘り下げています。特に、フィーチャーフラグ、カナリーリリース、A/Bテストなどの重要な概念と、それらの実践的な適用方法について詳細な洞察を提供しています。継続的デプロイメントの価値は、ソフトウェア開発の特性と人間の性質を理解することで明確になります。人間は反復作業を得意としませんが、コンピューターシステムはこの種の作業に適しています。継続的デプロイメントは、人間と機械の特性の違いを活かし、相互補完的に活用します。コード変更から本番環境へのデプロイまでを完全に自動化することで、開発者は創造的な問題解決に注力でき、反復的なタスクはシステムに任せることができます。結果として、ソフトウェア開発プロセス全体の効率が向上し、人的ミスのリスクも減少します。本書は、技術的側面だけでなく、組織文化やチーム間の協力体制についても掘り下げています。また、継続的デプロイメントがもたらすソフトウェアのリリースサイクルの短縮や、ユーザーへのフィードバックループの最小化についても解説しています。同時に、コードの品質管理やテスト戦略により高い要求を課すことの重要性も強調しています。強固な自動テスト、モニタリング、迅速なロールバック機能など、継続的デプロイメントを成功させるために不可欠な安全策についても説明しています。実践的な見地からも、本書は開発者が直面する現実的な課題に対する具体的な解決策を提供しています。各章は理論的な基礎から始まり、実際の適用例、そして起こりうる問題とその対処法まで、包括的に解説しています。特に、実際の組織がどのように継続的デプロイメントを導入し、成功を収めているかについての事例研究は、実務に直接活かせる貴重な知見となっています。本書を通じて、継続的デプロイメントが単なる技術的なツールではなく、組織全体の開発文化を変革し、ソフトウェア品質を向上させるための包括的なアプローチであることが理解できます。その実践は、開発効率の向上、リリース品質の改善、そして最終的には顧客満足度の向上につながります。Cloud Observability in Action「Cloud Observability in Action」は、クラウドネイティブ時代におけるオブザーバビリティの概念と実践方法を包括的に解説した一冊です。オブザーバビリティを投資対効果の観点から捉え、データの生成から収集、処理、可視化に至るまでのプロセス全体を俯瞰します。これは、神の視点でシステムを観察できるようになる、デジタル世界の第三の目を手に入れるようなものです。Cloud Observability in Action (English Edition)作者:Hausenblas, MichaelManningAmazonOpenTelemetry、Prometheus、Grafana、Loki、Jaegerなどのオープンソースツールを活用し、誰でも実践的な知見を時間以外の費用をかけずに得られるよう工夫されています。まるで高級な料理のレシピを、コンビニの食材だけで再現する魔法のような本です。著者の豊富な経験に基づくベストプラクティスが随所に盛り込まれ、参考URLも惜しみなく共有されています。システムの監視方法について、何百人もの先人たちが積み上げてきた叡智を一冊に凝縮したような贅沢な内容です。単なるツールの使い方の解説にとどまらず、オブザーバビリティを組織文化として定着させるためのヒントも提供されています。つまり、「システムの見える化」という名の文化革命の指南書とも言えるでしょう。本書を通じて、システムの内部状態を把握・推論する力を身につけることができます。これは、デジタルの迷宮で道に迷った開発者たちに、アリアドネの糸を提供するようなものです。得られた知見をどのように活用するかは読者次第ですが、システムと組織の継続的な進化を支える原動力として、オブザーバビリティを正しく理解し実践することができます。少なくとも、「エラーログを検索すれば何とかなる」という幻想から解放されることは間違いありません。本書は、複雑化するシステムの「見える化」を実現するための、実践的なガイドブックです。これを読まずにオブザーバビリティを始めるのは、暗闇の中でパズルを解こうとするようなものかもしれません。本稿では、各章の要点を丁寧に読み解きながら、私なりの学びと気づきをシェアしていきます。皆様にとっても、オブザーバビリティへの理解を深め、その実践への一歩を踏み出すきっかけとなれば幸いです。Learning OpenTelemetry「Learning OpenTelemetry」は、可観測性という広大な領域に対する実践的な航海図といえます。本書の最も重要な貢献は、OpenTelemetryというテクノロジーを通じて、システムの可観測性をビジネス価値へと変換する具体的な方法論を提示している点です。Learning OpenTelemetry: Setting Up and Operating a Modern Observability System (English Edition)作者:Young, Ted,Parker, AustinO'Reilly MediaAmazon本書を読む際は、オブザーバビリティに関する以下の2冊との併読をお勧めします。まず「Observability Engineering」は、可観測性の基本概念から実践的な実装まで、より広い文脈で解説しています。特に、OpenTelemetryを含む様々な可観測性ツールの位置づけや、組織における可観測性の文化醸成について、包括的な視点を提供してくれます。両書を読み進めることで、技術的な実装の詳細と、より大きな戦略的文脈の両方を理解することができます。Observability Engineering: Achieving Production Excellence (English Edition)作者:Majors, Charity,Fong-Jones, Liz,Miranda, GeorgeO'Reilly MediaAmazonまた、「入門 監視」は、システム監視の基礎から応用まで、実践的な知見を提供してくれます。監視とオブザーバビリティの関係性、メトリクスの収集と分析、アラートの設計など、日々の運用に直結する知識を学ぶことができます。入門 監視 ―モダンなモニタリングのためのデザインパターン作者:Mike JulianオライリージャパンAmazon本書の特筆すべき点は、技術的深度、組織的展開、ビジネス価値という3つの視点を統合的に扱っていることです。技術面では、OpenTelemetryの内部アーキテクチャから実装の詳細まで、体系的な解説を提供しています。特に、トレース、メトリクス、ログの統合方法や、テレメトリパイプラインの設計については、実務で即座に活用できる具体的な知見が豊富です。組織面では、可観測性の導入を単なる技術導入ではなく、組織変革として捉える視点を提供しています。特に、Deep対Wide、Code対Collection、Centralized対Decentralizedという3つの軸に基づく展開戦略は、組織の規模や成熟度に応じた柔軟なアプローチを可能にします。ビジネス面では、テレメトリデータを通じてビジネスの意思決定や改善につなげていく方法について、具体的な指針を示しています。私が実務を通じて特に共感したのは、本書の掲げる「Do no harm, break no alerts」という原則です。可観測性の向上は、既存のシステムや運用プロセスを破壊することなく、段階的に実現していくべきだという主張は、現場の実態に即した賢明なアプローチだと感じます。本書の構成も実践的です。各章は理論的な基礎から始まり、実装の詳細、そして運用上の考慮点へと展開されていきます。特に、各章末のケーススタディやベストプラクティスは、他組織の経験から学ぶ貴重な機会を提供してくれます。最後に、本書の結論部分で言及されている「可観測性の次のフロンティア」についても注目に値します。AIとの統合やテストとしての可観測性など、新しい可能性の提示は、この分野の今後の発展を考える上で重要な示唆を与えてくれます。OpenTelemetryの導入を検討している組織にとって、本書は単なる技術解説書以上の価値を持つ戦略的なガイドブックとなるでしょう。また、すでにOpenTelemetryを導入している組織にとっても、その活用方法を再考し、より高度な可観測性を実現するための有益な指針となることは間違いありません。こちらの本は日本語版がリリースされています。入門 OpenTelemetry ―現代的なオブザーバビリティシステムの構築と運用作者:Ted Young,Austin ParkerオライリージャパンAmazonBecoming SRE「Becoming SRE」は、SRE（Site Reliability Engineering）という職種に対する深い理解と実践的な洞察を提供する画期的な一冊です。本書は、個人がSREとしてのキャリアを築くための道筋と、組織がSREを導入・発展させるための戦略を包括的に解説しています。Becoming SRE: First Steps Toward Reliability for You and Your Organization (English Edition)作者:Blank-Edelman, David N.O'Reilly MediaAmazonSREに関する書籍は数多く出版されていますが、本書の特筆すべき点は、その実践に基づいた具体性と実用性にあります。特に、他のSRE関連書籍が理論や理想的なプラクティスの解説に重点を置く傾向がある中、本書は現場で直面する現実的な課題とその解決策に焦点を当てています。例えば、Googleが提唱したSREの原則やプラクティスを、規模や成熟度の異なる組織でどのように適用していくかについて、具体的なステップとアプローチを示しています。また、SREとしてのキャリアパスや、組織内でのSRE文化の醸成方法など、実務者の視点に立った実践的なアドバイスが豊富に盛り込まれています。syu-m-5151.hatenablog.com本書の価値は、SREという職種を単なる技術的な役割としてではなく、組織の文化や価値観を形作る存在として捉えている点にあります。著者のDavid Blank-Edelman氏は、長年のSREとしての経験を基に、技術とビジネスの両面からSREの本質に迫っています。本書は3つのパートで構成されています。Part Iでは、SREの基本的な概念、文化、そしてマインドセットについて解説しています。特に注目すべきは、SREが目指すべき「適切な信頼性レベル」という考え方です。100%の信頼性を追求するのではなく、ビジネスの要求と照らし合わせながら、最適な信頼性レベルを見極めることの重要性が説かれています。Part IIは、個人がSREになるための具体的なステップを示しています。技術的なスキルセットはもちろん、コミュニケーション能力、問題解決力、そして失敗から学ぶ姿勢など、SREに求められる多面的な資質について詳細に解説されています。特筆すべきは、オンコール対応やインシデント管理といった実務的なトピックについても、豊富な事例とともに具体的なアドバイスが提供されている点です。Part IIIでは、組織としてSREを導入・発展させるための戦略が展開されています。SREの成功は、個々のエンジニアの努力だけでなく、組織全体のサポートと理解が不可欠だという著者の主張は説得力があります。特に興味深いのは、SREの組織的な成熟度を5つのステージで捉えるフレームワークです。各ステージの特徴と課題、そして次のステージへの移行に必要な施策が具体的に示されています。本書が特に強調しているのは、SREにおける「文化」の重要性です。モニタリング、自動化、インシデント対応といった技術的な実践も重要ですが、それらを支える組織文化がなければ、SREは真の力を発揮できません。データ駆動の意思決定、失敗から学ぶ姿勢、部門間の協働、これらの文化的要素をどのように育んでいくかについても、深い洞察が示されています。また、本書はSREの導入と成長における現実的な課題にも正面から向き合っています。技術的な障壁はもちろん、組織の抵抗、リソースの制約、文化の変革の難しさなど、SREが直面する様々な課題に対する具体的な対処法が提示されています。総じて本書は、SREを目指す個人にとってのキャリアガイドであると同時に、組織にとってのSRE導入・発展のロードマップとして機能する実践的な指南書です。著者の豊富な経験に基づくアドバイスは、SREという未知の領域に踏み出そうとする読者にとって、信頼できる道標となるはずです。こちらの本も日本語版がリリースされています。SREをはじめよう ―個人と組織による信頼性獲得への第一歩作者:David N. Blank-EdelmanオライリージャパンAmazonFundamentals of Data Engineering「Fundamentals of Data Engineering」は、データエンジニアリングの基礎から実践までを体系的に解説した包括的な一冊です。データエンジニアリングを「raw dataを取り込み、高品質で一貫性のある情報を生成するシステムとプロセスの開発、実装、維持」と定義し、その全容を詳細に説明しています。Fundamentals of Data Engineering: Plan and Build Robust Data Systems (English Edition)作者:Reis, Joe,Housley, MattO'Reilly MediaAmazon本書は4つのパートで構成されており、Part Iではデータエンジニアリングの基礎と構成要素、Part IIではデータエンジニアリングのライフサイクルの詳細、Part IIIではセキュリティとプライバシー、そして将来の展望を扱っています。特に、データ生成からストレージ、取り込み、変換、提供までの一連のライフサイクルについて、実践的な知見が豊富に盛り込まれています。著者たちは、特定のツールや技術に依存しない原則ベースのアプローチを採用しています。これにより、急速に変化するデータ技術の世界においても、長く有効な知識を提供することに成功しています。データエンジニアは、セキュリティ、データ管理、DataOps、データアーキテクチャ、オーケストレーション、ソフトウェアエンジニアリングの交差点に位置し、これらの要素を統合的に理解し活用する必要があることが強調されています。本書の特筆すべき点は、理論と実践のバランスが絶妙なことです。データエンジニアリングの基本原則を解説しながら、実際のシステム設計や運用における具体的な課題とその解決策も提示しています。また、クラウドファーストの時代におけるデータエンジニアリングの在り方についても深い洞察が示されています。セキュリティとプライバシーに関する章では、データエンジニアリングにおけるセキュリティの重要性と、具体的な実装方法が詳細に解説されています。GDPRなどの規制への対応や、データの匿名化、アクセス制御など、現代のデータエンジニアが直面する重要な課題がカバーされています。最後に、データエンジニアリングの将来に関する章では、業界の動向と今後の展望が示されています。クラウドスケールの「データOS」の出現や、リアルタイムデータ処理と機械学習の融合など、興味深い予測が述べられています。本書は、データエンジニアリングの世界で活躍したい技術者にとって、必携の一冊となるでしょう。体系的な知識の習得と実践的なスキルの向上に大いに役立つ内容となっています。こちらの本も日本語版がリリースされています。データエンジニアリングの基礎 ―データプロジェクトで失敗しないために作者:Joe Reis,Matt HousleyオライリージャパンAmazonTidy First?「Tidy First?」は、エクストリームプログラミングの考案者であり、ソフトウェアパターンの先駆者として知られるKent Beckによる、コードの整理整頓に関する画期的な一冊です。本書は、リファクタリングの新しい考え方として「Tidying（整理整頓）」という概念を提唱し、その実践的なアプローチを示しています。Tidy First?: A Personal Exercise in Empirical Software Design (English Edition)作者:Beck, KentO'Reilly MediaAmazonリファクタリングといえば「リファクタリング 既存のコードを安全に改善する」ですがこのリファクタリングの考え方をより小規模で実践的なアプローチへと発展させたものと言えるでしょう。リファクタリング 既存のコードを安全に改善する（第2版）作者:ＭａｒｔｉｎＦｏｗｌｅｒオーム社Amazon本書の核心は、「いつ、どこで、どのようにコードを整理するべきか」という実践的な問いに対する答えを提示している点です。特に注目すべきは、Tidyingをリファクタリングの部分集合として位置づけ、より小規模で安全な改善活動として定義している点です。本書は3つのパートで構成されています。Part 1: Tydingsでは、具体的な整理整頓の手法が示されています。変数名の調整や対称性の確保、不要なコードの削除など、小規模だが効果的な改善活動が詳しく解説されています。これらは、ボーイスカウトの原則（来たときよりも美しく）とも通じる考え方です。Part 2: Managingでは、Tidyingの実践的なマネジメントについて解説されています。特に重要なのは、機能開発の直前にTidyingを行うべきという提言です。これは、料理をする前にキッチンを整理整頓するのと同じように、本題に取り組む前に作業環境を整えることの重要性を示唆しています。また、Tidyingは1時間以内に完了できる規模に抑えるべきという具体的な指針も示されています。Part 3: Theoryでは、Tidyingの理論的な基盤が展開されています。特筆すべきは、経済的な観点からの分析です。NPV（正味現在価値）やオプション理論を用いて、Tidyingの投資対効果を説明しています。また、疎結合と高凝集というソフトウェアアーキテクチャの基本原則との関連も論じられています。本書の真価は、コードの整理整頓を、技術的な活動としてだけでなく、経済的な投資活動として捉える視点を提供している点です。これは、技術的な改善活動の必要性を経営層に説明する際の有効な理論的基盤となります。また、本書は3部作の第1巻として位置づけられており、個人、チーム、組織のレベルでの開発プラクティスを包括的に扱う野心的なプロジェクトの出発点となっています。私にとって、本書は技術的負債の管理に関する新しい視点を提供してくれました。特に、小規模な改善活動を継続的に行うことの重要性と、その活動の経済的な価値を理解する上で、貴重な指針となっています。本書で提唱されているTidyingの概念は、現代のソフトウェア開発における持続可能性の向上に大きく貢献する可能性を秘めています。技術的な改善と経済的な価値創造の両立を目指す実践的なアプローチとして、多くの開発者にとって有益な知見となるでしょう。こちらの本も日本語版がリリースされます。読んでないのですが定評のある翻訳者陣が担当しており、高品質な翻訳が期待できます。Tidy First? ―個人で実践する経験主義的ソフトウェア設計作者:Kent Beckオーム社AmazonプログラミングRust 第2版「プログラミングRust 第2版」は、Rustという言語の深い理解を導く羅針盤のような一冊です。本書は、システムプログラミングの本質に迫りながら、現代的な言語機能を体系的に解説するという野心的な試みに成功しています。プログラミングRust 第2版作者:Jim Blandy,Jason Orendorff,Leonora F. S. TindallオライリージャパンAmazonこの本の特筆すべき点は、Rustの重要な概念を段階的に、かつ包括的に解説していることです。特に所有権とライフタイム、並行処理といったRustの特徴的な機能について、理論的な説明と実践的な例を絶妙なバランスで提供しています。これは、まるで高度な技術文書をコンパイラが最適化するように、複雑な概念を理解しやすい形に変換してくれる働きがあります。本書の構成は、基本的な言語機能から始まり、徐々により高度なトピックへと展開していきます。例えば、非同期プログラミングやトレイト、ジェネリクス、マクロなど、モダンなRustの重要な機能が詳細に解説されています。これは、読者の理解度を段階的にスケールアップさせていく、よく設計されたアーキテクチャのようです。特に印象的なのは、本書がパフォーマンスとメモリ安全性を両立させるためのRustの機能を、システムプログラマの視点から丁寧に解き明かしている点です。これは、高可用性システムの設計原則にも通じる、信頼性とパフォーマンスのトレードオフを実践的に学べる貴重な機会を提供しています。また、本書は2021年のRust Editionに対応しており、最新の言語機能や実践的なプログラミング手法が網羅されています。これは、まるで継続的デリバリーのパイプラインのように、最新の知識を読者に届けてくれます。実務的な観点からも、本書の価値は計り知れません。エラーハンドリング、テスト、デバッグといった実践的なトピックについても、深い洞察と具体的な実装例を提供しています。これらの知識は、本番環境でのRustプログラミングにおいて、インシデントを防ぎ、安定性を確保するための重要な基盤となります。本書は、単なる言語仕様の解説書を超えて、システムプログラミングの本質に迫る良書といえます。その内容は、Rustを学ぶ開発者にとって、強固な基盤となるインフラストラクチャを提供してくれることでしょう。私にとって、本書は技術書のデータセンターの中核を担うサーバーとして機能しています。新しい機能や概念に出会うたびに、本書に立ち返り、その本質的な理解を深めることができます。2025年に予定されているRust 2024 Editionのリリースに向けて、本書の次版がどのように進化していくのか、今から楽しみでなりません。Programming Rust: Fast, Safe Systems Development (English Edition)作者:Blandy, Jim,Orendorff, Jason,Tindall, Leonora F. S.O'ReillyAmazonEffective Rust「Effective Rust」は、Rustのコンパイラが発する警告やエラーの深い理由を解き明かしてくれる、暗号解読書のような一冊です。本書は、単なる文法やパターンの解説を超えて、Rustの設計思想とその根底にある原理を探求することで、より深い理解と実践的なスキルの獲得を可能にします。Effective Rust: 35 Specific Ways to Improve Your Rust Code (English Edition)作者:Drysdale, DavidO'Reilly MediaAmazon本書の真髄は、「なぜそのコードがコンパイラに拒否されるのか」という本質的な問いに対する答えを提供している点です。これは、まるでセキュリティ監査ツールのような役割を果たし、潜在的な問題を事前に検出し、より安全なコードへと導いてくれます。例えば、借用チェッカーとの「戦い」は、実はメモリ安全性を確保するための重要な対話であることを理解させてくれます。特筆すべきは、本書が型システムを通じたデザインパターンを詳細に解説している点です。これは、アプリケーションのアーキテクチャを型安全に設計するための青写真を提供してくれます。例えば、newtypeパターンの活用や、トレイトを用いた共通の振る舞いの表現など、型システムを活用した設計手法を学ぶことができます。また、本書はエラーハンドリングのベストプラクティスについて深い洞察を提供します。OptionやResult型の効果的な使用法から、独自のエラー型の設計まで、堅牢なエラー処理の体系を示してくれます。これは、まるで障害対策のプレイブックのような役割を果たします。実務的な観点からも、本書の価値は計り知れません。依存ライブラリの管理やツールチェーンの活用など、実践的なトピックについても詳しく解説されています。特に、Clippyとの対話を通じたコード品質の向上や、CIシステムの設定など、現代のソフトウェア開発に不可欠な知識が網羅されています。本書は、「とりあえず動く」コードから「より良い」コードへの進化を支援してよりイディオマティックなRustコードへの道筋を示してくれます。私にとって、本書は技術書のデータセンターにおける重要なセキュリティシステムとして機能しています。コードの品質と安全性を確保するためのチェックポイントとして、常に参照すべき存在となっています。特に、「なぜそうすべきか」という根本的な理解を深めることで、より効果的なRustプログラミングが可能になります。こちらの本も日本語版がリリースされています。Effective Rust ―Rustコードを改善し、エコシステムを最大限に活用するための35項目作者:David Drysdaleオーム社Amazonバックエンドエンジニアを目指す人のためのRust「バックエンドエンジニアを目指す人のためのRust」は、単なるRustの入門書を超えて、実践的なプロジェクトを通じてバックエンドエンジニアに必要な知識とスキルを体系的に学べる一冊です。本書は、「なぜバックエンドにRustなのか」という根本的な問いに、具体的なプログラミング体験を通じて答えを提示しています。バックエンドエンジニアを目指す人のためのRust作者:安東 一慈,大西 諒,徳永 裕介,中村 謙弘,山中 雄大翔泳社Amazon「Webバックエンド開発にRustは不要ではないか？」という疑問に対して、本書は実践的な回答を提供します。Rustの型システムとコンパイラによる厳格なチェックは、本番環境での予期せぬエラーを事前に防ぐことができます。また、エラーハンドリングやOption/Result型の扱いなど、Rustの特徴的な機能は、信頼性の高いバックエンドシステムの構築に直接的に貢献します。本書の構成は、学習者の段階的な成長を支援するように綿密に設計されています。計算クイズから始まり、ポーカーゲーム実装でデータ構造を学び、家計簿プログラムでファイルI/Oを理解し、最終的にはTODOアプリの開発とデプロイメントまでを経験できます。各プロジェクトは、バックエンド開発に必要な特定の技術要素に焦点を当てており、理論と実践を効果的に結びつけています。また、本書はCargoによるパッケージ管理、ユニットテスト、リンター、フォーマッターといった実務で重要となる開発ツールの活用方法も丁寧に解説しています。これらのツールは、チーム開発における生産性と品質の向上に直結する重要な要素です。本書を通じて学べる実践的なスキルは、現代のバックエンド開発の現場で直接活用できます。とりわけ、Webアプリケーション開発からデプロイメントまでの一連のプロセスを実際に体験できる点は、実務への橋渡しとして非常に価値があります。最終章では採用面接を想定した内容も含まれており、学習した内容を実際のキャリアにつなげる道筋も示されています。Real World HTTP 第3版「Real World HTTP 第3版」は、HTTPプロトコルの基礎から最新動向まで、体系的かつ実践的に解説した決定版です。本書は、HTTPの歴史的な進化をたどりながら、ブラウザの内部動作やサーバーとのやり取りについて、実例とコードを交えて詳細に解説しています。Real World HTTP 第3版 ―歴史とコードに学ぶインターネットとウェブ技術作者:渋川 よしきオライリージャパンAmazon本書は、辞書的に知りたい項目を調べるのにも、通して読んで体系的に学習するのにも適しています。特に注目すべきは、認証やセキュリティなど、開発者が苦手意識を持ちがちな領域についても、実践的な観点から詳しく解説している点です。サンプルコードはGoを使用していますが、これは動作確認や挙動の理解に焦点を当てたものです。実際の実装例を通じて、HTTPの基本的な仕組みから最新の機能まで、具体的に理解することができます。Web技術について検索エンジンやChatGPTで調べると、初心者向けの断片的な情報や、質問の範囲内でしか答えが得られません。一方、本書は体系的な知識を提供し、読者が気付いていない重要な点も含めて包括的に解説しています。第3版では、より初学者を意識した導入や、スーパーアプリなどプラットフォーム化するウェブに関する新章が追加されました。また、HTTP/3とQUICなど最新の技術動向についても詳しく解説されています。本書の圧倒的な情報量は、単なるボリュームではなく、実務で本当に必要となる知識が凝縮されています。AWSやWebフレームワークでの開発スキルも重要ですが、真のWebエンジニアとして成長するためには、本書で解説されているような基盤となる知識の理解が不可欠です。学び直しにも最適な一冊であり、眺めるだけでも新しい発見が得られます。HTTPやWeb技術の深い理解を目指す若手エンジニアには、まさに必携の書といえるでしょう。【改訂新版】システム障害対応の教科書「システム障害対応の教科書」は、システム障害対応の暗黙知を形式知化し、体系的に解説した画期的な一冊です。本書は、インシデント発生から終息までの一連のプロセスを詳細に解説するだけでなく、組織としての障害対応力向上までを包括的にカバーしています。【改訂新版】システム障害対応の教科書作者:木村 誠明技術評論社Amazon改訂新版では、チームメンバーの教育と育成、障害対応訓練、事故を防ぐ手順書の作り方、エンドユーザ向け情報発信についての新章が追加され、より実践的な内容となっています。特に、ワークブック編の追加により、理論を実践に落とし込むための具体的な手法が提供されており、新人から中堅、マネージャーまで幅広い層に価値のある内容となっています。本書の真価は、システム障害対応における役割と基本動作の明確化にあります。インシデントコマンダー、作業担当者、ユーザ担当者など、各役割の責務と行動規範が詳細に解説されています。また、必要なドキュメントやツール、環境についても具体的な説明があり、すぐに実務に活かせる実践的な知識を得ることができます。特に注目すべきは、組織の障害対応レベル向上と体制作りに関する章です。障害対応力のスキルチェックシートや訓練の実施要領など、組織として継続的に改善していくための具体的な方法論が示されています。また、生成AI技術のシステム運用への応用についても言及されており、最新の技術動向も押さえられています。Appendixでは、実際の難易度の高いシステム障害ケースが紹介されており、ビジネスロジックの障害から大規模インフラ障害、災害時の対応まで、現実的なシナリオに基づいた学びを得ることができます。これらのケーススタディは、理論と実践を結びつける貴重な教材となっています。本書は、システム運用に関わるすべての人にとって、障害対応の基本から応用まで、体系的に学べる決定版といえます。新人エンジニアの教育から、中堅エンジニアのスキル向上、マネージャーの組織運営まで、幅広いニーズに応える内容となっています。おわりに2024年、私にとって技術書との関わり方が大きく変化した1年でした。これまでのように単に量を追い求めるのではなく、一冊一冊をより深く理解することに注力しました。特に今年読んだ技術書は、プラットフォームエンジニアリング、継続的デプロイメント、オブザーバビリティ、SRE、データエンジニアリングなど、現代のソフトウェアエンジニアリングにおける重要なテーマを網羅しています。これらの本は、理論的な知識だけでなく、実践的なノウハウや組織的な視点も提供してくれました。今年読んで特に印象に残った技術書に共通するのは、「実践知の体系化」という特徴です。現場のベテランエンジニアたちが長年培ってきた経験と知見を、次世代に継承可能な形で整理し体系化しています。例えば、『Platform Engineering』は現場での経験を理論化し、『システム障害対応の教科書』は暗黙知を形式知に変換しています。『プログラミングRust』や『Effective Rust』などの言語関連の書籍も、単なる技術解説を超えて、設計思想や原理の理解に重点を置いています。これらの本から得た知識は、日々の業務や技術イベントでの発表を通じて実践に活かすことができました。また、本を通じて学んだことを自分の言葉で発信することで、理解をより深めることができたと感じています。来年も引き続き、質の高い技術書との出会いを大切にしていきたいと思います。そして、得られた知見を実践し、さらにはコミュニティに還元していくことで、エンジニアとしての成長を続けていきたいと考えています。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[vim-jpラジオ#24聞いた - OSS活動するVimmer]]></title>
            <link>https://blog.atusy.net/2024/12/23/vim-jp-radioa-24/</link>
            <guid>https://blog.atusy.net/2024/12/23/vim-jp-radioa-24/</guid>
            <pubDate>Mon, 23 Dec 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[アカデミア系Vimmerの飽くなき挑戦を感じられる刺激的な回。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Workforce Identity + Auth0 で Vertex AI Search の ACL 制御を行う]]></title>
            <link>https://zenn.dev/satohjohn/articles/a422ee68dd3485</link>
            <guid>https://zenn.dev/satohjohn/articles/a422ee68dd3485</guid>
            <pubDate>Sun, 22 Dec 2024 18:03:43 GMT</pubDate>
            <content:encoded><![CDATA[3-shake AdventCalendar 第2シーズン 23日目の記事になります。2回目の登場です。今回は真面目な(?)技術記事になります。私としては前回書いた記事も大真面目でしたが。 概要今回やりたいこととしては、ウェブアプリケーション上で Id Provider(以後 IdP) 認証をして、その結果を利用して Vertex AI Agent Builder の Search 機能(以後めんどいので旧称の Vertex AI Search として説明) の ACL による検索の権限管理を行うというものです。今回 IdP として Auth0 を利用します。そのため、少し A...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AWS Signerにおけるコンテナ署名の実装]]></title>
            <link>https://blog.masasuzu.net/entry/2024/12/22/132803</link>
            <guid>https://blog.masasuzu.net/entry/2024/12/22/132803</guid>
            <pubDate>Sun, 22 Dec 2024 04:28:03 GMT</pubDate>
            <content:encoded><![CDATA[この記事は3-shake Advent Calendar 2024の22日目の記事です。AWS Signerを使ったコンテナイメージの署名処理を扱った案件があったのでこちらの紹介となります。ただ、後述するように完成には至ってないです。それでもAWS Signerを使った署名処理と署名検証についての概要をお伝えできるかなと思います。今回のシステムはAWS ECS で Web サービスを運用しています。GitHub Actions を利用してデプロイを行っています。構成としては至ってベーシックな形になっています。今回、コンテナイメージのセキュリティ強化のため、ECR に保存されているイメージが改竄されていないことを保証する要件が追加されました。この記事では、AWS Signer を用いたコンテナイメージの署名と検証の実装、そして現状の課題と今後について記述します。AWS SignerとはWhat is AWS Signer? - AWS SignerAWS Signer はフルマネージドなコード署名サービスです。従来は Lambda 関数などで利用されていましたが、2023年の6月にECRのイメージ署名にも対応しました。AWS がコンテナイメージへの署名を導入Notary ProjectのNotation CLIを用いることで、ECRに保存されているコンテナイメージを署名することができ、署名ファイルをコンテナイメージとともにECRに保存できます。これによりコンテナイメージの真正性と完全性を検証することができます。ECS × AWS Signer を使ったイメージ署名ワークフローを試してみた - Speaker Deckなお、AWS Signerによるイメージ署名に゙関してはNRI ネットコム様のスライドに詳しく書かれているのでこちらを参照するとより理解が深まります。デプロイフロー変更前デプロイフローとしてはGitHub Actionsでレポジトリ内のソースをdocker buildしたものをECRにpushし、ECS Serviceにデプロイするシンプルなワークフローになります。変更前変更後このワークフローにコンテナイメージ署名の処理を追加します。notationコマンドにSigner Profileのarnを指定して、署名と検証をそれぞれ行う形になります。今回は、GitHub Actions ワークフローに AWS Signer を使った処理を組み込みます。ECRにpushしたイメージに対して署名を行うように変更しました。署名したあとに署名検証を行うことになります。後述しますが、これだけだと本来は不完全なものです。変更後実装ここから実装を見て行きます。先述したワークフローに帰るために以下の変更が必要となります。インフラ側AWS Signer Profileの追加デプロイ用IAM RoleにAWS Signer Profileへのアクセス権の追加デプロイ側署名処理の追加Terraformインフラ側の変更を見ていきましょう。追加箇所としてはSigner Profileの追加とGitHub Actions用のIAM Policyへの権限追加となります。変更箇所以外は今回は割愛しています。platform_idを"Notation-OCI-SHA384-ECDSA"に指定してSigner Profileを作成します。レポジトリ名をProfile名にしており、レポジトリ名が - 区切りで、Profile名が - を使えないという事情で _ への置換処理をしています。Siner Profileresource "aws_signer_signing_profile" "main" {  platform_id = "Notation-OCI-SHA384-ECDSA"  # profile名に-が使えないので置換  name = replace(var.repository_name, "-", "_")}先に作ったSigner Profileへの"signer:GetSigningProfile"と"signer:SignPayload"の許可をデプロイ用のRoleのPolicyに付与します。GitHub Actions用IAM Roledata "aws_iam_policy_document" "deploy_policy" {  #前略  # イメージ署名  # Inline policies for Signer - AWS Signer  # https://docs.aws.amazon.com/ja_jp/signer/latest/developerguide/authen-inlinepolicies.html  statement {    sid    = "SignImage"    effect = "Allow"    actions = [      "signer:GetSigningProfile",      "signer:SignPayload"    ]    resources = [      var.signer_profile_arn    ]  }  # 後略}デプロイsigner policyのファイルをあらかじめ作っておきます。このPolicyを利用して、署名検証を行います。.github/aws/signer_policy.json{    "version":"1.0",    "trustPolicies":[      {          "name":"aws-signer-tp",          "registryScopes":[            "*"          ],          "signatureVerification":{            "level":"strict"          },          "trustStores":[            "signingAuthority:aws-signer-ts"          ],          "trustedIdentities":[            "arn:aws:signer:${region}:${account_id}:/signing-profiles/${profile_name}"          ]      }    ]}既存のECSのデプロイワークフローにnotationのインストール、イメージ署名処理、イメージ署名検証の処理を追記します。リリースブランチにpushされたことを契機にデプロイが走る形です。.github/workflows/deploy.yamlname: Deploy to ECSon:  push:    branches: ['release']env:  AWS_REGION: ap-northeast-1  ECR_REPOSITORY: ${レポジトリ名}  SIGNER_PROFILE_ARN: ${Signer Profile ARN}  SIGNER_POLICY_JSON: .github/aws/signer_policy.jsonjobs:  deploy:    name: Deploy to ECR, ECS    runs-on: ubuntu-latest    steps:      ### 前略      - name: Setup Notation        run: |          wget https://d2hvyiie56hcat.cloudfront.net/linux/amd64/installer/deb/latest/aws-signer-notation-cli_amd64.deb          sudo dpkg -i aws-signer-notation-cli_amd64.deb      - name: Sign image        env:          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}          IMAGE_TAG: ${{ github.sha }}        run: |          notation sign $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG --plugin "com.amazonaws.signer.notation.plugin" --id "$SIGNER_PROFILE_ARN"      - name: Verify image        env:          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}          IMAGE_TAG: ${{ github.sha }}        run: |          notation policy import $SIGNER_POLICY_JSON          notation verify $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG      ### 後略課題ここまででイメージの署名処理および署名検証の実装はできました。しかしながら、いくつか課題があります。CIとCDの分離先の実装を見るとわかるのですが、署名したイメージを即時署名検証していることがわかります。これは同じイメージに対して行われているため、実質的な検証にはなっていません。真の改竄検知のためには、CI/CD パイプラインを分離し、デプロイ時に別途署名検証を行う必要があります。また、pushしたコンテナイメージの脆弱性チェックもデプロイ前に行うことが望ましいです。そこで下記のように変更したいところです。ただ、デプロイのフローが変わってしまうので、調整が必要でまだ手をつけていない状態になります。理想正規手順以外でデプロイされたイメージの検証さらに、正規のデプロイフロー以外で起動されたタスクのイメージ検証も課題です。署名されていないイメージが起動されていても何もチェックができていない状態です。これに対するアプローチとしては、EventBridgeでタスクが起動したイベントを拾って、イメージの署名をチェックし、検証できなかったものに゙関しては処理を行う(タスクの停止や通知など)という方法があります。これはContainers on AWSで紹介されているので、この方法を実装できたらと考えています。Container image signing and verification using AWS Signer for Amazon ECS and AWS Fargate | Containers on AWS署名検証のサービス統合ここまで見ていて気付いたかもしれませんが、ECS Serviceがタスクを起動するときに署名されているかどうかをチェックするようにECSサービスと統合されていれば、独自に署名検証を実装する必要はありません。このへん、Google CloudのBinary Authorizationはサービスと統合されているので、署名検証を自前で書く必要がないと理解してます。AWSもサービスと統合して楽に使えるようになることを期待してます。Binary Authorization の概要  |  Google Cloudまとめ現状でできていることは以下のとおりです。ECRへpushしたイメージの署名処理現状課題となっているものは以下のとおりです。CI/CDの分離署名されていないコンテナイメージが起動されていないかのチェックこの記事では、AWS Signer を用いたコンテナイメージの署名実装と、残された課題について説明しました。まだできていないことが多いですが、まずビルドしたイメージに対して署名を行うという第一歩を踏み出しました。ここから署名検証の仕組みを強化し、よりセキュアなコンテナ運用を実現するために、引き続き改善に取り組んでいきたいと思ってます。参考リンクAWS がコンテナイメージへの署名を導入AWS Signer と Amazon EKS におけるコンテナイメージ署名の提供開始 | Amazon Web Services ブログECS × AWS Signer を使ったイメージ署名ワークフローを試してみた - Speaker DeckSign container images in Signer - AWS SignerContainer image signing and verification using AWS Signer for Amazon ECS and AWS Fargate | Containers on AWSBinary Authorization の概要  |  Google Cloud]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[kyoto.goのマスコット基板を作って京都行って配ってきた]]></title>
            <link>https://zenn.dev/satoken/articles/kyoto-go-board</link>
            <guid>https://zenn.dev/satoken/articles/kyoto-go-board</guid>
            <pubDate>Sat, 21 Dec 2024 16:04:00 GMT</pubDate>
            <content:encoded><![CDATA[この記事はTinyGo Advent Calendar 2024 22日目の記事です。 はじめにkyoto.goは京都を中心に活動しているGoコミュニティで、毎回楽しく参加させてもらってます。https://kyotogo.hatenablog.com/entry/2024/11/16/112621kyoto.goのマスコットがお茶飲んでいるGopher君です。今回kyoto.goのお茶のみGopherくんの基板を勝手に作って、京都に行って配ってきました。この記事では基板の組み立て方と動かし方を説明します。https://kyotogo.connpass.com/eve...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイク所属の早川大貴がクラウドネイティブ技術を推進するCNCF Ambassadorsに就任]]></title>
            <link>https://sreake.com/blog/cncf_ambassadors/</link>
            <guid>https://sreake.com/blog/cncf_ambassadors/</guid>
            <pubDate>Fri, 20 Dec 2024 08:39:11 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）所属の早川大貴が、クラウドネイティブ技術を推進するCNCF Ambassadorsに就任したことをお知らせします。The post スリーシェイク所属の早川大貴がクラウドネイティブ技術を推進するCNCF Ambassadorsに就任 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[生成AIでGitHubソースコード取得して仕様書を作成]]></title>
            <link>https://speakerdeck.com/shukob/sheng-cheng-aidegithubsosukodoqu-de-siteshi-yang-shu-wozuo-cheng</link>
            <guid>https://speakerdeck.com/shukob/sheng-cheng-aidegithubsosukodoqu-de-siteshi-yang-shu-wozuo-cheng</guid>
            <pubDate>Fri, 20 Dec 2024 05:00:00 GMT</pubDate>
            <content:encoded><![CDATA[https://generative-ai-conf.connpass.com/event/335205/2024生成AI革命期を振り返る忘年会にて、「生成AIでGitHubソースコード取得して仕様書を作成する」というテーマでLTさせていただきました。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Cloudflareで管理しているドメインのアクセス解析をGraphQLでやってみる]]></title>
            <link>https://blog.atusy.net/2024/12/20/cloudflare-graphql-analytics-api/</link>
            <guid>https://blog.atusy.net/2024/12/20/cloudflare-graphql-analytics-api/</guid>
            <pubDate>Fri, 20 Dec 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Cloudflareのダッシュボード上で確認できるWeb Analyticsの生データが欲しかったので、方法を調べてみた。ベースとなるクエリはブラウザの開発者ツールからコピペできるので便利。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[今までアウトプットしてこなかった私が、今年からアウトプットを始めてわかったこと]]></title>
            <link>https://speakerdeck.com/melanmeg/jin-madeautopututositekonakatutasi-ga-jin-nian-karaautopututowoshi-metewakatutakoto</link>
            <guid>https://speakerdeck.com/melanmeg/jin-madeautopututositekonakatutasi-ga-jin-nian-karaautopututowoshi-metewakatutakoto</guid>
            <pubDate>Thu, 19 Dec 2024 05:00:00 GMT</pubDate>
            <content:encoded><![CDATA[イベント: https://findy.connpass.com/event/335692/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[KueueによるKubernetesネイティブなジョブ制御を試してみる]]></title>
            <link>https://sreake.com/blog/kueue-kubernetes-native-job-control/</link>
            <guid>https://sreake.com/blog/kueue-kubernetes-native-job-control/</guid>
            <pubDate>Thu, 19 Dec 2024 03:05:13 GMT</pubDate>
            <content:encoded><![CDATA[Kueue KueueはKubernetesのSIG-Schedulingのサブプロジェクトとして開発が進められている、クラスター内のバッチ・HPC・AI/MLといったジョブのキューイングを提供するAPIとコントローラの […]The post KueueによるKubernetesネイティブなジョブ制御を試してみる first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[dplyrでグループ単位にデータフレームを操作する]]></title>
            <link>https://blog.atusy.net/2024/12/19/dplyr-groupby/</link>
            <guid>https://blog.atusy.net/2024/12/19/dplyr-groupby/</guid>
            <pubDate>Thu, 19 Dec 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[dplyr::summarize, dplyr::mutate, dplyr::filterなどの関数の.by引数を使うと、グループごとに計算ができて非常に便利。mutateやfilterでグループ処理できると、集計が一気に捗ると思うのでいくつか例を紹介する。dplyr::group_by関数でも同じことができるけど、dplyr::ungroupを忘れると思わぬ挙動に繋がることもあるので注意。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[俺のガチってるdotfiles紹介]]></title>
            <link>https://zenn.dev/melanmeg/articles/dd0b9606352fb9</link>
            <guid>https://zenn.dev/melanmeg/articles/dd0b9606352fb9</guid>
            <pubDate>Tue, 17 Dec 2024 22:00:02 GMT</pubDate>
            <content:encoded><![CDATA[はじめにどうもです。3-shake の melanmeg です今回は dotfiles 紹介です。エンジニアにとっては、dotfiles は作業効率を上げるための 自分用チートシート のように感じています。もしくは これまで コツコツと積み上げてきた財産 ...ですかね。普段から使い慣れた環境をどこでも再現できるようにしておくことで、複数の端末で素早く自分好みの環境を用意できます！シェルやVSCodeのカスタマイズ、Gitの便利設定、そして新しいVMでの簡単なセットアップ方法を紹介します。dotfiles管理の魅力を共有し、皆さんの環境構築がもっと楽しくなればと思います🙇...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[プロンプトエンジニアリング プログラミング ハンズオン]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/12/17/185729</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/12/17/185729</guid>
            <pubDate>Tue, 17 Dec 2024 09:57:29 GMT</pubDate>
            <content:encoded><![CDATA[genai-users.connpass.comこの記事は上記勉強会の資料です。shu-kob.hateblo.jp↑上記記事を参考にサービスアカウントの設定をしてください。※ Google Cloudの無料期間が終了していると、課金されますが、ハンズオンの内容だけだと数百円もいかないと考えています。料金は確実には言えないので、Google Cloudはご自身の責任でご使用ください。github.com↑今回のサンプルコードgit clone https://github.com/shu-kob/prompt_engineeringcd prompt_engineeringpip install vertexaiLangChainを使わずVertex AIのライブラリを使用シンプルなVertex AIでGeminiを実行project_id = "PROJECT_ID" # 書き換える実行python3 generate_content.pyresponse = model.generate_content(  "プロンプトエンジニアリングとは")プロンプトを変更して実行してみましょう。Zero Shot プロンプティングproject_id = "PROJECT_ID" # 書き換える実行python3 zero_shot_prompting.pyprompt = """以下はニュース記事のタイトルです。「政治」「経済」「芸能」「スポーツ」「科学」「その他」のうち1つに分類してください。回答だけ一言で出力してください===========================紅白出場歌手の選考基準 NHK公開"""プロンプトを変更して実行してみましょう。Few Shot プロンプティングproject_id = "PROJECT_ID" # 書き換える実行python3 few_shot_prompting.pyprompt = """以下はニュース記事のタイトルです。「政治」「経済」「芸能」「スポーツ」「科学」「その他」のうち1つに分類してください。回答だけ一言で出力してください===========================「紅白出場歌手の選考基準 NHK公開」===========================以下は例です「G20 バイデン氏不在で集合写真」:政治「岡田将生&高畑充希結婚 SNS反応」:芸能"""プロンプトを変更して実行してみましょう。LangChainを使用langchain_google_vertexai を使用pip install langchain_google_vertexaipython3 invoke.pymessages = [  ("human", "ネコの鳴き真似をしてください。"),]プロンプトを変更して実行してみましょう。PromptTemplateを使用pip install langchain_corepip install pydantic==2.9.0実行python3 prompt_template.pyプロンプトテンプレートやQuestionを変更して実行してみましょう。ChatPromptTemplateを使用実行python3 chat_prompt_template.pyprompt_template = ChatPromptTemplate.from_messages([    ("system", "ステップバイステップで考えてください。"),    ("human", "{question}"),])question = """10 + 2 * 3 - 4 * 2"""システムプロンプトやQuestionを変更して実行してみましょう。参考資料python.langchain.compython.langchain.com参考文献LangChainとLangGraphによるRAG・AIエージェント［実践］入門Google Gemini 1.5／LlamaIndex／LangChain 人工知能プログラミング実践入門]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Cloud Run GPU 上の PaliGemma2 に私の娘は可愛いと言わせるまで]]></title>
            <link>https://zenn.dev/satohjohn/articles/33b27212b3a55e</link>
            <guid>https://zenn.dev/satohjohn/articles/33b27212b3a55e</guid>
            <pubDate>Mon, 16 Dec 2024 11:20:30 GMT</pubDate>
            <content:encoded><![CDATA[この記事は 3-shake Advent Calendar 2024 シーズン1 16日目の記事 & Jagu'e'r Advent Calendar 2024 4日目の記事 になります。3-shake に入社してそろそろ丸2年が経過しようとしており、感慨深く思っております。こういうカレンダーをちゃんと埋められているのをみていても、アウトプットという形で自己研鑽や表現を行う素晴らしいメンバーが多いなと日々日々感じております。そんな中で書けるのも良い経験だと感じております。という前置きを入れつつ、今回は生成 AI の中でも OSS でマルチモーダルな LLM である PaliG...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[週間アトデ 2024-12-16]]></title>
            <link>https://blog.atusy.net/2024/12/16/atodeyomanakata/</link>
            <guid>https://blog.atusy.net/2024/12/16/atodeyomanakata/</guid>
            <pubDate>Mon, 16 Dec 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[アトデヨム、ウソジャナイ、ヨムノタノシー]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[KubeCon NA 2024: Goodbye etcd! Running Kubernetes on Distributed PostgreSQLのセッションレポート]]></title>
            <link>https://nnaka2992.hatenablog.com/entry/2024/12/15/goodbyte_etcd_running_kubernetes_on_distributed_postgresql</link>
            <guid>https://nnaka2992.hatenablog.com/entry/2024/12/15/goodbyte_etcd_running_kubernetes_on_distributed_postgresql</guid>
            <pubDate>Sun, 15 Dec 2024 14:16:36 GMT</pubDate>
            <content:encoded><![CDATA[この記事は以下アドベントカレンダー15日目の記事です。3-shake Advent Calendar 2024 シリーズ2Kubernetes Advent Calendar 2024 シリーズ2Goodbye etcd! Running Kubernetes on Distributed PostgreSQL セッションレポートセッション概要 https://kccncna2024.sched.com/event/1i7rt/goodbye-etcd-running-kubernetes-on-distributed-postgresql-denis-magda-yugabyteセッション動画 www.youtube.comこのセッションはKubernetesクラスタのメタデータストアとして利用されるetcdをDistributed PostgreSQLであるYugabyteDBに置き換えた方法を紹介し、デモを行っています。What's etcd?セッションはetcdの解説から始まりました。etcdは分散可能で可用性の高いキーバリューストアであり、シンプルながらも強力なデータベースとして機能します。Raftプロトコルを用いることで、複数のマシンやVMで構成されたクラスタ全体にわたって変更を複製し、ノード障害発生時にも一貫したデータと継続的な動作を保証します。Kubernetesはこのetcdをメタデータストアとして活用し、サービスのポート数やデプロイメントのPod数といったクラスタの状態を管理しています。このセクションはetcdの役割を明確に示し、Kubernetesにおける重要性を理解する上で有用でした。etcdがKubernetesの心臓部と言える重要な役割を担っていることを再認識させられました。Why some are not happy with etcdetcdは多くのKubernetesクラスタで標準的に利用されていますが、大規模環境（100～1000ノード）ではスケーラビリティに課題があることが指摘されました。このようなケースでは、etcdから分散データベースへの移行が必要となります。さらに、etcdプロジェクトへのコントリビュータ不足も懸念材料として挙げられており、Kubernetesが必要とする機能追加への対応が遅れる可能性が示唆されました。このセクションは、etcdの潜在的な問題点を浮き彫りにし、代替手段を検討する必要性を示唆しています。特に大規模運用を想定している場合、etcdのスケーラビリティの限界は深刻な問題になり得ます。KineKineはKubernetesクラスタとリレーショナルデータベース間の仲介役として機能するシミュレータレイヤです。etcd APIをSQLに変換することで、PostgreSQLやMySQLのようなリレーショナルデータベースをKubernetesのメタデータストアとして利用可能にします。Kubernetes APIサーバーが発行したetcd APIをKineがSQLに変換し、データベースに実行することで、etcdの代替を実現します。このセクションはKineの動作原理を簡潔に説明し、リレーショナルデータベースをKubernetesと統合する仕組みを理解する上で重要です。Kineの存在によって、既存のデータベース基盤を活用したKubernetes運用が可能になります。Hands-onデモ環境はGoogle Cloud上の3つのCompute Engine（us-westリージョンの異なるゾーン）に構築されたk3sクラスタで、純粋なPostgreSQLと分散型PostgreSQLであるYugabyteDBの2つのシナリオが示されました。純粋なPostgreSQLは単一VMで、YugabyteDBは3台のVMで実行され、マルチゾーン、マルチリージョン、マルチクラウド/オンプレミス環境への拡張可能性が示唆されました。このセクションはデモ環境の概要を説明し、異なるデータベース構成でのKubernetes運用の可能性を示しています。実環境に近い構成でのデモは、KineとYugabyteDBの有効性を理解する上で非常に役立ちます。Kubernetes on Pure PostgreSQLyoutu.beこのデモでは、PostgreSQLが動作するサーバ上でk3sを実行し、Kineが必要とするオブジェクトがPostgreSQLに作成される様子、そしてk3s自体の動作確認が示されました。既存のPostgreSQL環境へのKubernetesの導入を検討する際に、このデモは具体的な手順と動作イメージを提供してくれます。データベース管理者にとって、Kineによるデータベースへの影響を視覚的に確認できる点は非常に重要です。Kubernetes on YugabyteDBYugabyteDBとは？YugabyteDBは、PostgreSQL互換の分散SQLデータベースです。クエリレイヤはPostgreSQLからフォークされ、ストレージレイヤはLSMツリーベースの実装1を採用しています。複数サーバ・複数リージョンでの運用が可能で、クエリ分散やノード障害時の継続動作を実現します。etcdと同様にRaftプロトコルを利用することで、データの一貫性を確保し、ネットワーク分断時のスプリットブレインにも対応します。このセクションはYugabyteDBの特徴を説明し、高可用性と分散性を備えたデータベースとしての利点を明確に示しています。etcdの代替としてYugabyteDBを検討する際に、この情報は非常に重要です。デモyoutu.beYugabyteDBクラスタ上でk3sを実行するデモでは、PostgreSQLの場合とほぼ同様の手順でKubernetesを起動できることが示されました。YugabyteDBのダッシュボードを用いて、データベースの情報やKineが作成した情報を確認できる点も強調されました。さらに、Kubernetesのサンプルアプリを起動することで、etcdベースのKubernetesと同等の動作が確認されました。1台のCompute Engineを停止させることでYugabyteDBノードの障害をシミュレートし、データベースとKubernetesが継続して動作することを実証しました。このデモは、YugabyteDBの耐障害性と高可用性を視覚的に示し、実運用環境での信頼性を裏付けています。結論このセッションは、KineとYugabyteDBを用いることで、etcdの代替としてリレーショナルデータベースをKubernetesのメタデータストアとして利用できることを示しました。特に、YugabyteDBの分散性と耐障害性は、大規模Kubernetesクラスタの運用においてetcdのスケーラビリティやコントリビュータ不足といった課題を解決する可能性を示唆しています。ただし、YugabyteDBの導入には運用コストや学習コストといった新たな課題も発生するため、etcdとの比較検討が必要です。同様にセッションではKineをネイティブに利用しているk3sを利用していますが、k3sはあくまでKubernetesの軽量ディストリビューションであるため完全に同じものではないため、本当にk3sで良いのかという比較検討も必要になります。またセッション内では100を超えるノードから構成されるKubernetesクラスタではetcdのスケーラビリティが足りず、他のメタデータストアが必要になると紹介していますが、なぜ必要になるかは説明が不足していると感じました。これはKubernetesクラスタが大規模化することでAPIサーバが発行するクエリがetcdの対応可能な10000 rpsを越え始めるためです。より詳細な説明はGoogle Cloudの65000ノードを越えるGKEクラスタをSpannerでホストしていることを紹介しているブログが参考になるでしょう。cloud.google.com]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Kubernetes The Hard Wayにトライする]]></title>
            <link>https://zenn.dev/moz_sec/articles/0dbb3b7dd08ab3</link>
            <guid>https://zenn.dev/moz_sec/articles/0dbb3b7dd08ab3</guid>
            <pubDate>Sun, 15 Dec 2024 12:14:59 GMT</pubDate>
            <content:encoded><![CDATA[KuberenetesKubernetesとは、複数のコンピュータでコンテナをいい感じに動かしてくれるものです。Kubernetesの説明はいろんなサイトに書いてあるため、そちらを参照してください。公式サイトも参考になります。https://kubernetes.io/docs/concepts/overview/ Kuberentes The Hard WayKubernetes The Hard Wayとは、kubeadmやkubesplayのような、クラスタ構築ツールに頼らず、コンテナランタイムや各コンポーネントを自分でインストールして、設定をし、Kubernetes...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Reckoner における Datadog Error Tracking の活用事例]]></title>
            <link>https://zenn.dev/nomadblacky/articles/1901ceb9154c7b</link>
            <guid>https://zenn.dev/nomadblacky/articles/1901ceb9154c7b</guid>
            <pubDate>Sun, 15 Dec 2024 10:35:38 GMT</pubDate>
            <content:encoded><![CDATA[この記事は、3-shake Advent Calendar 2024 の 15 日目の記事です。 はじめに私の所属する株式会社スリーシェイクでは、Reckoner というデータパイプライン構築の SaaS を開発しています。https://reckoner.io/「SaaSをつなぐ。業務が変わる。ビジネスが進化する。」直感的なユーザーインターフェイスで、多種多様な SaaS のデータをつなぎ合わせることで、データ活用・データの民主化を実現します。Reckoner では多種多様な連携先に対応しているため、様々なエラーが発生する可能性があります。そのため、エラーの迅速な発見と...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Japan.R 2024に参加した]]></title>
            <link>https://blog.atusy.net/2024/12/15/japanr-2024/</link>
            <guid>https://blog.atusy.net/2024/12/15/japanr-2024/</guid>
            <pubDate>Sun, 15 Dec 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Hadley氏を筆頭に、本番環境や実務でRを使う話が多くて印象深かった回。色々な話を聞けてよかった。2019年以来のオフライン開催で久しくお会いしていなかった方とお話できたこと、光栄にも私に会ってみたかったという方に挨拶頂けたりブログが参考になったと言っていただけたこと、発表に対して直に感想をやりとりできたことなど、現地入りしてよかったなあと思います。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[KubeCon NA 2024: Database DevOps: CD for Stateful Applicationsのセッションレポート]]></title>
            <link>https://nnaka2992.hatenablog.com/entry/2024/12/14/database_devops_cd_for_stateful_applications</link>
            <guid>https://nnaka2992.hatenablog.com/entry/2024/12/14/database_devops_cd_for_stateful_applications</guid>
            <pubDate>Sat, 14 Dec 2024 18:55:02 GMT</pubDate>
            <content:encoded><![CDATA[この記事は以下アドベントカレンダー14日目の記事です。3-shake Advent Calendar 2024 シリーズ2Kubernetes Advent Calendar 2024 シリーズ1Database DevOps: CD for Stateful Applications セッションレポートセッション概要:https://kccncna2024.sched.com/event/1i7na/database-devops-cd-for-stateful-applications-stephen-atwell-harnessio-christopher-crow-pure-storage?linkback=grid-fullセッションスライドhttps://static.sched.com/hosted_files/kccncna2024/86/Harness-Portworx%20Kubecon%202024.pdfこの記事内の画像は全てこのスライドより引用しています。セッション動画  www.youtube.comこのレポートでは、KubeCon + CloudNativeCon North America 2024 のセッション「Database DevOps: CD for Stateful Applications」の内容をまとめたもので、DatabaseのDevOpsとステートフルアプリケーションの継続的デリバリについてです。データベースCDの課題と解決策セッションでは、データパイプラインのデータテストをデリバリパイプラインに統合することの重要性が強調されていました。従来、データベースのテストは、BIツールなどを用いたカスタマイズされた方法で行われることが多かったようですが、最も信頼性の高いテスト方法は、新旧バージョンで同じデータに対してテストを実行することだとスピーカーは主張していました。そして、Kubernetesはこのようなテストを大幅に簡略化できるとのことでした。この主張は、データベースの変更がアプリケーション全体に及ぼす影響を正確に把握し、本番環境へのデプロイ前に潜在的な問題を早期に発見するために非常に重要です。Kubernetesによるデータベース運用の進化セッションで紹介されたアーキテクチャの進化は、Kubernetesがデータベース運用にもたらす利点を明確に示していました。初期のアーキテクチャでは、アプリケーション、データベース、インフラストラクチャの変更が個別に管理されていましたが、発展したアーキテクチャでは、これらが統合されたCI/CDパイプラインで管理されています。この統合により、アプリケーション、データベース、インフラストラクチャの変更をE2Eでテストできるようになり、本番環境へのデプロイリスクを大幅に軽減できます。このアーキテクチャの進化は、マイクロサービスアーキテクチャやクラウドネイティブ開発との親和性が高いと言えます。マイクロサービスでは、個々のサービスが独立してデプロイされるため、データベースの変更が他のサービスに及ぼす影響を正確に把握することが重要です。Kubernetesはこのような複雑な依存関係を管理し、安全なデプロイを実現するための強力なプラットフォームを提供します。デモのオーバービューセッションでは、具体的なスキーママイグレーションのシナリオを例に、ダウンタイムゼロでのデータベース変更を実現する方法が紹介されていました。WarehouseテーブルのLocationカラムの衝突問題を解決するために、CityとStateカラムを追加し、Locationカラムとの同期をトリガーで実現する方法は、実務で非常に役立つアプローチです。この手法は、データベースの変更によるアプリケーションへの影響を最小限に抑え、ユーザー体験を損なうことなくシステムを進化させることを可能にします。デモで利用されるCDパイプラインデモで適用されるデータベースへの変更個人的にはこのようなユースケースのテストシナリオは複雑になることが多いと考えていたため、自動化を行うには相当のカスタマイズが必要になると思っていたので、この後のデモの手軽さには非常に驚かされました。デモのハイライトとHarnessの活用youtu.beこのセッションはデモが全体のほとんどを閉めています。デモ開始時点のリンクがブログ記事の中盤にあるので、デモ部分だけでもご覧になることを強く推奨します。セッションのデモでは、Harnessというツールが使用され、変更プロセスとロールバック手順が分かりやすく可視化されていました。Harnessは、GitLab CI/CDやGitHub ActionsのようなUIを提供し、各ステップの成功/失敗を容易に確認できる点が優れていると感じました。特に、ArgoCDとの連携によるデータベースとアプリケーションの協調動作は、複雑なデプロイプロセスを簡素化する上で非常に効果的です。デモで紹介された、望ましい状態になっていないことを確認し、変更を加えるプロセスは、実践的な知見を提供していました。また、データベースの変更セットの一部として事前にロールバック手順を定義しておくことは、本番環境での予期せぬ問題発生時に迅速な対応を可能にするベストプラクティスと言えるでしょう。LiquibaseやFlywayなどのツールはこのような機能を提供しており、データベースDevOpsの実践において不可欠です。HarnessではデータベースのDevOpsをアプリケーション、インフラストラクチャー込みで実現しており、非常に理想的なツールのように見えました。一方でこのセッションのスピーカーのひとりはHarnes.ioのエンジニアであるため、ポジショントークや見せたい部分しか見せていないことが十分考えられるので全てを鵜呑みにするのは危険です。それを差し引いても興味深いデモだったので、セッションで紹介された技術スタックを検証してみたいと思っています。まとめこのセッションは、Kubernetesとツールを活用することで、データベースの変更を安全かつ効率的に行う方法を示していました。E2Eテスト、ダウンタイムゼロのスキーママイグレーション、そしてロールバック手順の自動化は、データベースDevOpsを実現するための重要な要素です。これらの手法を適切に組み合わせることで、開発速度を向上させながら、システムの安定性と信頼性を維持することが可能になります。しかし、ここで紹介された手法は全ての状況に適用できるわけではありません。例えば、大規模なデータベースや複雑なトランザクション処理を行うシステムでは、ダウンタイムゼロのマイグレーションが困難な場合があります。そのようなケースでは、段階的なロールアウトやカナリアリリースなどの手法を検討する必要があります. また、ツールの導入や運用にはコストがかかるため、組織の規模やリソースに合わせて適切なツールを選択することが重要です。今後のデータベース運用においては、自動化と可観測性をさらに強化し、自己修復機能を備えた自律的なデータベース運用を目指していくことが重要だと考えます。Kubernetesやクラウドネイティブ技術は、この目標を実現するための基盤となるでしょう。またこのセッションを見るまで、個人的にDatabase on KubernetesはKubernetesを利用している組織でマネージドデータベースのコストを安くしたい場合や、データを自分たちのコントロールできる場所におきたい時に利用する選択肢と思っていました。しかしデータベースをKubenetesにデプロイすることでアプリケーションと密接に結合したテストを簡単に行えることがわかり、データベースの運用コストさえ許容できれば、他のメリットがなくてもデータベースをKubernetesで運用するのは十分ありなのではないかと意見が変わりました。今後は単なるデータベースのホスティング環境としてのKubernetes以外の部分にも注目していきたいです。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[初回実行が遅ければ遅延初期化でやればいいじゃない - RustのTUIアプリケーション改善]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/12/14/121545</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/12/14/121545</guid>
            <pubDate>Sat, 14 Dec 2024 03:15:45 GMT</pubDate>
            <content:encoded><![CDATA[この記事はRust Advent Calendar 2024 シリーズ3の15日目の記事です。はじめにみなさん、アプリケーションの初回実行の遅さに悩んでいませんか？「初回の検索が遅い...」「起動に時間がかかる...」「ユーザーから苦情が...」といった問題は、多くの開発者が直面する共通の課題です。実は、こういった問題の多くは初期化のタイミングを工夫することで効果的に解決できます。特にRustの場合、遅延初期化の仕組みを積極的に活用することで、パフォーマンスとユーザー体験を大きく改善することが可能です。初期化処理を適切なタイミングで実行することで、アプリケーションの応答性を保ちながら、必要なデータの準備を効率的に行うことができるのです。今回は郵便番号検索アプリケーション（jposta）を具体例として、初期化の最適化手法について詳しく見ていきましょう。この実践的なケーススタディを通じて、効果的な初期化戦略の実装方法を学んでいきます。github.com遅延初期化とは遅延初期化は、「必要になるまで初期化を待つ」という考え方を基本とする重要な最適化テクニックです。アプリケーションの起動時に全てのデータを一度に読み込むのではなく、そのデータが実際に使用されるタイミングまで読み込みを延期することで、システムの効率性を高めることができます。ja.wikipedia.org特に重要な利点として、アプリケーションの起動時間の大幅な短縮が挙げられます。全ての機能を一度に初期化する代わりに、必要な機能から順次初期化することで、ユーザーは最小限の待ち時間でアプリケーションの使用を開始できます。また、大きな設定ファイルの読み込みやデータベース接続の確立、重いライブラリの初期化、キャッシュの構築といったリソース集約的な操作を必要なタイミングまで延期することで、メモリやCPUなどの限られたリソースを効率的に活用することが可能となります。さらに、遅延初期化は複雑な依存関係を持つシステムにおいても効果的です。複数のコンポーネントが互いに依存し合う状況では、初期化の順序が問題となることがありますが、各コンポーネントを必要に応じて初期化することで、この課題を自然に解決できます。加えて、テスト容易性の向上も重要な利点です。必要なコンポーネントだけを初期化できることで、単体テストやモジュールテストが容易になり、テストの実行速度も向上します。また、エラーハンドリングの改善にも貢献します。初期化時のエラーを早期に検出できるだけでなく、実際に使用されないコンポーネントの初期化エラーを回避することができます。運用環境での柔軟性も高まり、システムの一部機能が利用できない状況でも、他の機能を正常に動作させることが可能になります。このように、遅延初期化は現代のソフトウェア開発において、パフォーマンス、保守性、信頼性の面で多くのメリットをもたらす重要な設計パターンとなっています。blog1.mammb.comRustにおける遅延初期化の進化Rustにおける遅延初期化の歴史は、2014年に登場したlazy_staticから始まり、これはマクロベースの実装でスレッドセーフ性に課題があり、型の制約も厳しいものでした。github.comその後、2020年にはonce_cellが登場し、マクロを必要としないシンプルなAPIとスレッドセーフな実装、より柔軟な型のサポートを提供することで、遅延初期化の実装が大きく改善されました。github.comそして2024年になると、LazyCell/LazyLockが標準ライブラリに統合され、さらなる最適化と依存関係の削減が実現され、Rustの遅延初期化機能は新たな段階へと進化を遂げています。blog.rust-lang.orgこのように、Rustの遅延初期化は時代とともに進化し、より使いやすく堅牢な実装へと発展してきました。techblog.paild.co.jp問題の理解：なぜ初期処理が必要か？まず、jpostcode_rsライブラリの実装を見てみましょう：use std::sync::LazyLock;static ADDRESS_MAP: LazyLock<HashMap<String, Vec<Address>>> = LazyLock::new(|| {    let data = include_str!(concat!(env!("OUT_DIR"), "/address_data.json"));    let raw_map: HashMap<String, Value> =        serde_json::from_str(data).expect("Failed to parse raw data");    // ...});このコードの重要なポイントは、LazyLockによる遅延初期化を採用することで、JSONデータの初回アクセス時までパースを延期し、必要なタイミングでメモリへの展開を行う設計となっているということです。このコードから分かるように、初回アクセス時のパフォーマンス低下は遅延初期化の仕組みに起因しています。そこで私たちは、この遅延初期化の特性を活用し、ユーザーが実際にアクセスする前に初期化を完了させる戦略を考案しました。解決策：遅延初期化を活用した初期処理従来の初期化パターンfn new() -> App {    let (search_tx, search_rx) = mpsc::channel::<String>();    let (result_tx, result_rx) = mpsc::channel();    thread::spawn(move || {        while let Ok(query) = search_rx.recv() {            // 初回検索時にデータ初期化が発生 = 遅い！        }    });    App { /* ... */ }}改善後：標準ライブラリの機能を活用use std::sync::{LazyLock, Mutex};// グローバルな初期化フラグstatic INITIALIZED: LazyLock<Mutex<bool>> = LazyLock::new(|| Mutex::new(false));impl App {    fn new() -> App {        let (search_tx, search_rx) = mpsc::channel::<String>();        let (result_tx, result_rx) = mpsc::channel();        thread::spawn(move || {            // バックグラウンドで初期化            {                let mut init = INITIALIZED.lock().unwrap();                if !*init {                    // 軽いクエリで事前初期化をトリガー                    let _ = lookup_addresses("100");                    let _ = search_by_address("東京");                    *init = true;                }            }            // 以降の検索は初期化済みのデータを使用            let mut cache: HashMap<String, Vec<String>> = HashMap::new();            while let Ok(query) = search_rx.recv() {                // 通常の検索処理            }        });        App { /* ... */ }    }}この手法の効果とメリットとデメリットこの手法の中核となる標準ライブラリのLazyLockやMutexなどの基本機能は、追加のライブラリを必要としない堅牢な実装を可能にします。既存のRustプログラマーにとって馴染みのある仕組みを使用しているため、コードの理解や保守が容易であり、依存関係も最小限に抑えることができます。また、これらの機能は既にRustチームによって最適化され、徹底的にテストされているため、高いパフォーマンスと信頼性が保証されています。システムの保守性と運用面では、初期化ロジックの集中管理により、状態管理が大幅に簡素化されます。INITIALIZEDフラグを用いた明示的な制御により、初期化状態の追跡が容易になり、デバッグ性も向上します。さらに、初期化処理をバックグラウンドスレッドで実行することで、メインスレッドのブロッキングを避け、UIの即時表示とレスポンシブな操作感を実現できます。スケーラビリティの観点からは、新機能の追加や初期化順序の制御が柔軟に行えるため、システムの成長に合わせた拡張が容易です。Mutexによる適切な同期制御により、複数スレッドからの安全なアクセスが保証され、並行処理との親和性も高くなっています。また、必要なデータの予測的な先読みとメモリ使用の最適化により、効率的なリソース管理が可能です。初期化処理のモジュール化により、新しい機能の追加時も既存コードへの影響を最小限に抑えられ、キャッシュの効果的な活用によって、大規模なアプリケーションでも高いパフォーマンスを維持できます。一方で、この手法にはいくつかの重要な課題も存在します。まず、メモリ使用量の増加が挙げられます。事前初期化アプローチでは、実際には使用されない可能性のあるデータ構造も含めて、すべてのデータをメモリに展開する必要があります。これは特にメモリリソースが限られている環境において深刻な問題となる可能性があり、システムの全体的なパフォーマンスに影響を与える可能性があります。また、起動時のリソース消費も重要な課題です。バックグラウンドでの初期化処理は、システムの起動時により多くのCPUとメモリリソースを必要とします。特にモバイルデバイスやバッテリー駆動の機器では、この追加のリソース消費が電力効率に悪影響を及ぼす可能性があります。ユーザーの使用パターンによっては、この初期化コストが実際の便益を上回ってしまう場合もあります。さらに、実装の複雑性が増加することも大きな課題です。遅延初期化と事前初期化を組み合わせることで、コードベースの複雑性が著しく増加します。特に初期化の順序や依存関係の管理が複雑になり、開発者がシステムの動作を理解し、デバッグすることが困難になる可能性があります。この複雑性は、新しい機能の追加や既存機能の修正時にも影響を及ぼし、開発効率の低下につながる可能性があります。テストの複雑化も見過ごせない問題です。バックグラウンド初期化を含むコードのテストでは、タイミングや状態管理の観点から、適切なテストケースの作成と実行が困難になります。特に並行処理に関連するバグの再現や検証が複雑になり、品質保証のプロセスに追加の負担がかかる可能性があります。最後に、エラーハンドリングの複雑化も重要な課題です。バックグラウンドでの初期化中に発生したエラーの適切な処理と、それに対するユーザーへの適切なフィードバック提供が技術的な課題となります。エラーが発生した場合の回復処理や、部分的な機能提供の実装も複雑になり、システムの信頼性と保守性に影響を与える可能性があります。このように、標準ライブラリの機能を活用した実装は多くの利点をもたらす一方で、システムの要件や制約に応じて、これらのデメリットを慎重に検討する必要があります。実装時には、これらのトレードオフを考慮しながら、適切な設計判断を行うことが重要となります。実装時の注意点デッドロックの防止{  // スコープによるロックの制限    let mut init = INITIALIZED.lock().unwrap();    if !*init {        *init = true;    }}  // ロックの自動解放初期化の冪等性if !*init {    // 複数回実行されても安全な実装に    let _ = lookup_addresses("100");    *init = true;}まとめ私たちは「初回アクセスが遅いなら、事前に必要な処理を済ませておこう」というシンプルながら実用的なアプローチについて、Rustの標準ライブラリの遅延初期化機構を通じて検討してきました。この手法には、メモリ使用量の増加やコードの複雑化といった課題も存在しますが、適切に実装することで大きな効果が期待できます。標準ライブラリの機能を活用し、依存関係を最小限に抑えながら、スレッドセーフな実装を実現することで、効率的かつ安全な初期化処理が可能となります。このように、遅延初期化と事前初期化を組み合わせたアプローチは、システムの特性や要件に応じて検討すべき重要な最適化パターンの一つと言えるでしょう。参考文献The Rust Standard Library - std::sync::LazyLockThe Rust Standard Library - std::cell::LazyCellRust Performance Book]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Cloud Deploy で Cloud Run functions に継続的デリバリーする]]></title>
            <link>https://zenn.dev/kimitsu/articles/cloud-deploy-cloud-run-functions</link>
            <guid>https://zenn.dev/kimitsu/articles/cloud-deploy-cloud-run-functions</guid>
            <pubDate>Sat, 14 Dec 2024 01:17:49 GMT</pubDate>
            <content:encoded><![CDATA[Cloud Deploy は継続的デリバリーを行うための Google Cloud のフルマネージドサービスです。標準では Google Kubernetes Engine と Cloud Run (service と job) へのデプロイをサポートしていますが、カスタムターゲットを定義することでそれ以外の対象にもデプロイすることができます。今回はカスタムターゲットを利用して Cloud Run functions へのデプロイを自動化してみます。本記事では Cloud Deploy の基本的な概念（ターゲット、リリース、デプロイパイプラインなど）については説明しません。これら...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[KubeCon NA 2024: Building Resilience: Effective Backup and Disaster Recovery for Vector Databases on Kubernetes のセッションレポート]]></title>
            <link>https://nnaka2992.hatenablog.com/entry/2024/12/13/building_resilienc_effective_backup_and_disaster_recovery_for_database_on_lubernetes</link>
            <guid>https://nnaka2992.hatenablog.com/entry/2024/12/13/building_resilienc_effective_backup_and_disaster_recovery_for_database_on_lubernetes</guid>
            <pubDate>Fri, 13 Dec 2024 08:57:05 GMT</pubDate>
            <content:encoded><![CDATA[この記事は以下アドベントカレンダー13日目の記事です。3-shake Advent Calendar 2024 シリーズ2Kubernetes Advent Calendar 2024 シリーズ2Building Resilience: Effective Backup and Disaster Recovery for Vector Databases on Kubernetes セッションレポートセッション概要:https://kccncna2024.sched.com/event/1i7kn/when-life-gives-you-containers-make-an-open-source-rds-a-kubernetes-love-story-sergey-pronin-perconawww.youtube.comKubeCon + CloudNativeCon North America 2024 のセッション "Building Resilience: Effective Backup and Disaster Recovery for Vector Databases on Kubernetes" は、AI アプリケーションにおけるベクトルデータベースの重要性と、Kubernetes 上での堅牢なデータ保護戦略の必要性を強調した示唆に富む内容でした。マーケティング的な観点や、聴衆の興味を引くためといった理由からかタイトルでベクトルデータベースとなっていますが、バックアップの部分ではあらゆるデータベースやステートフルワークロードに応用ができる内容でした。AI and Kubernetesセッションは、AI がアプリケーションにもたらす変革的な影響についての概説から始まりました。リソース需要予測による動的スケーリング、異常検知によるセキュリティ向上、UX の改善、そして事前の障害予測による可用性向上など、AI はアプリケーションのあらゆる側面を最適化する可能性を秘めています。そして、これらのメリットを実現する上で、Kubernetes が最適なプラットフォームとして位置づけられています。迅速なデプロイ、高可用性とスケーラビリティ、可搬性と柔軟性、分散ワークロード管理の効率化、そして効率的なバックアップとリカバリといった Kubernetes の特徴は、AI ワークロードの運用に不可欠な要素です。特に、データベースを Kubernetes 上で運用する組織が増加しているという Data on Kubernetes のレポートの言及は、AI/ML ワークロードとデータベース運用の密接な関係性を示唆しており、データベースエンジニアとして注目すべき点でした。Kubernetes がステートフルなアプリケーションの運用基盤として成熟しつつあることを改めて認識させられました。Kubernetes上でAIアプリケーションをデプロイする理由セッションでは、Kubernetes上でAIアプリケーションをデプロイする理由として、迅速なデプロイ、高可用性とスケーラビリティ、可搬性と柔軟性、分散ワークロードの管理の効率化、効率的なバックアップとリカバリ、そしてエコシステムとコミュニティの発展が挙げられていました。これらの利点は、クラウドネイティブな開発と運用を目指す上で非常に重要です。特に、マイクロサービスアーキテクチャを採用する際に、Kubernetes はサービスのデプロイと管理を簡素化し、スケーラビリティと可用性を向上させる上で強力なツールとなります。さらに、ベクトルデータベースのようなステートフルなサービスを Kubernetes 上で運用することで、データの永続性と可用性を確保し、AI アプリケーションの信頼性を向上させることができます。Vector Databases and RAGセッションの中核を成すのが、ベクトルデータベースと RAG (Retrieval Augmented Generation) の解説です。非構造化データの増加に伴い、従来のデータベースでは対応が難しくなってきた画像、テキスト、音声といったデータの効率的な処理が求められています。ベクトルデータベースは、これらの非構造化データをベクトル表現に変換し、類似度検索によって関連性の高い情報を高速に取得することを可能にします。Embedding Model を用いたベクトル化によって、意味的な検索が可能になり、AI アプリケーションの精度と効率性が向上する点が強調されていました。特に、生成 AI アプリケーションにおけるハルシネーション軽減とコンテキスト付与におけるベクトルデータベースの役割は重要です。RAG は、ベクトルデータベースを用いて関連情報を取得し、生成 AI の出力に信頼性を与える手法として紹介されており、今後の AI アプリケーション開発において不可欠な要素となるでしょう。ベクトルデータベースのユースケースセッションでは、ベクトルデータベースのユースケースとして、検索エンジン、画像検索、推薦アルゴリズム、異常検知、そしてチャットボットなどの生成 AI アプリケーションが挙げられていました。これらのユースケースは、現代のアプリケーション開発において非常に重要であり、ベクトルデータベースの適用範囲の広さを示しています。特に、マイクロサービスアーキテクチャにおいて、ベクトルデータベースを独立したサービスとして提供することで、様々なサービスから容易にアクセスできるようになり、システム全体の柔軟性と拡張性を向上させることができます。また、DevOps/SRE の実践においては、ベクトルデータベースの監視と運用を自動化することで、システムの信頼性と可用性を向上させることができます。Data Protectionデータ保護は、Kubernetes 上で運用されるベクトルデータベースにとって不可欠な要素です。データの整合性とセキュリティ、災害復旧、コストと時間の効率化、バージョンコントロール、そしてコンプライアンス規制への準拠など、データ保護は多岐にわたるメリットを提供します。セッションでは、Kubernetes 上でのベクトルデータベースのデータ保護方法として、ストレージスナップショット、データサービスを利用したストレージスナップショット、データサービスレベルのスナップショット、そしてこれらの組み合わせが紹介されました。PVC を利用した永続化データの保護は、Kubernetes ネイティブなデータ保護戦略を構築する上で重要なポイントです。Kanister のようなデータ保護ワークフロー管理ツールは、バックアップとリストアの手順を抽象化し、自動化することで、運用効率を大幅に向上させることができます。Kanister の Blueprint、Profile、ActionSet といった CRD を活用することで、柔軟なデータ保護ワークフローを定義し、Kubernetes の宣言的な運用を実現できます。Kanisterの動作Kanister の動作は、ActionSet が Controller に動作を開始するようにトリガーし、Controller が Blueprint を参照して定義されたオペレーションに従ってベクトルデータベースからバックアップを取得し、オブジェクトストレージに保存するという流れで実行されます。動作完了後、Controller は ActionSet に完了を伝え、ActionSet がユーザーに完了を通知します。この自動化されたワークフローは、データベースエンジニアの運用負荷を軽減し、ヒューマンエラーのリスクを最小限に抑える上で非常に有効です。また、バックアップとリストアのプロセスをコード化することで、再現性と信頼性を向上させることができます。Demoデモでは、書籍推薦チャットボット BookNest を例に、PostgreSQL と PGVector を利用したベクトルデータベースのバックアップとリストアのワークフローが紹介されました。提供された図とデモ動画は、Kanister を用いたデータ保護の実践的な方法を理解する上で非常に役立ちました。具体的な構成例を示すことで、視聴者は自身の環境に合わせたデータ保護戦略を検討する際の参考にすることができます。また、デモを通じて Kanister の操作方法やワークフローの定義方法を視覚的に理解することができ、実践的な知識を深めることができます。Kanister の Blueprint は Kubernetes の manifest 内で ShellScript を書くようなイメージでかけるため、すでに Kubernetesを利用している組織であれば利用に大きなハードルは少なそうだと感じました。Operator 化されたデータベースでは大きなメリットはないかもしれないですが、そうでないデータベースのバックアップや、Operator を使っていても複数の種類がある場合オペレーションの使用ツールの共通化という面で十分メリットがあるでしょう。Call to Actionセッションの締めくくりとして、AI アプリケーションとベクトルデータベースの重要性、そしてデータ保護の必要性が改めて強調されました。データ保護を Day 0 Operation と位置づけるというメッセージは、システム設計の初期段階からデータ保護を考慮することの重要性を示唆しています。システムの保守性、スケーラビリティ、セキュリティを確保する上で、データ保護は不可欠な要素であり、アプリケーション開発ライフサイクル全体を通じて考慮する必要があります。まとめこのセッションは、AI アプリケーションにおけるベクトルデータベースの重要性と、Kubernetes 上での堅牢なデータ保護戦略の構築方法について、具体的な例を交えながら分かりやすく解説していました。特に、Kanister のようなデータ保護ツールを活用することで、複雑なバックアップとリカバリのワークフローを簡素化し、自動化できる点が印象的でした。データベースを Kubernetes 上で運用する際には、データ保護を Day 0 Operation として捉え、Kanister のようなツールを活用することで、システムの信頼性と可用性を向上させることができます. セッションで提示された情報は、今後のデータベース運用戦略を検討する上で非常に貴重な示唆を与えてくれました。このセッションで扱われなかった点として、ベクトルデータベースの選択基準やパフォーマンスチューニング、そして異なるベクトルデータベースにおけるデータ保護戦略の差異などが挙げられます。今後のセッションでは、これらの点についても掘り下げて議論されることを期待します。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ｻｯとかざして即起動! 推しグッズを神曲再生アイテムに(*°∀°)]]></title>
            <link>https://zenn.dev/nedoko_dok0dko/articles/9db9d10902ec03</link>
            <guid>https://zenn.dev/nedoko_dok0dko/articles/9db9d10902ec03</guid>
            <pubDate>Thu, 12 Dec 2024 15:00:01 GMT</pubDate>
            <content:encoded><![CDATA[※3-shake Advent Calendar 2024の13日目のエントリー記事です。本日、12月13日は金曜日。世の中では「ジェイソンの日」なんて言われています。とはいえ、生まれてこの方ジェイソンの映画を見ることがなかったためこの手の話についてはかなり縁遠い気がしていします。(JSONの方先に連想しちゃいますし)むしろ「華金だーー＼(^o^)／」くらいしか考えていません。それしかありません。そんな社会人です。さて、今年もやってまいりましたアドベントカレンダー。2024年も引き続き参加させていただく運びとなりました。テーマは前回同様「技術・非技術関係なし!自由!」ということ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Japan.R 2024で地域コミュニティのOsaka.Rについて発表した]]></title>
            <link>https://blog.atusy.net/2024/12/12/japanr-logging/</link>
            <guid>https://blog.atusy.net/2024/12/12/japanr-logging/</guid>
            <pubDate>Thu, 12 Dec 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[前の発表で力尽きてて、何も考えずに楽しくお話しちゃった回。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rust 再学習戦記]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/12/12/013950</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/12/12/013950</guid>
            <pubDate>Wed, 11 Dec 2024 16:39:50 GMT</pubDate>
            <content:encoded><![CDATA[プログラミング言語の再入門とは、未知の大地への探求というよりも、私たちが知っているはずの領域を新たな視点で見つめ直す営みです。それは初めての出会いのような激しい高揚感とは異なり、むしろ静かな再発見の過程といえるでしょう。この記事は3-shake Advent Calendar 2024 シリーズ2の12日目の記事です。はじめに2017年、私の心にRustという言語が静かに灯りを点しました。その光は、システムプログラミングの深い理解への憧れを呼び覚まし、私を導いていきました。情熱に突き動かされるように、DevOpsツールの創造から始まり、パケット解析の探究へ、そしてWebフレームワークの実装へと、私の歩みは広がっていきました。高速な実行速度と安全性という輝きに心を奪われながらも、未熟なエコシステムという現実が私たちの前に立ちはだかりました。パッケージの追従に心を砕き、破壊的な変更に耐え、そして孤独なメンテナンスの重みを感じながら、私は一時の別れを告げることを選びました。しかし2024年を迎えた今、私の目の前で世界は確かな変化を見せています。Rustの開発者満足度は非常に高い一方で、実務での採用はまだ限定的です。これは、現時点ではRustを業務で使用している開発者が比較的少なく、主に技術的な興味や言語の特徴に惹かれて自発的に選択している人が多いためかもしれません。まぁ何はともあれ、私もその魅力に惹かれた1人のエンジニア。最新のRustを探究すべく、再入門することにしました。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazonなぜ今、Rustなのか技術的な成熟Rustのエコシステムは大きく進化し、この数年で安定性が著しく向上しています。パッケージの破壊的変更は目に見えて減少し、Zero To Production In Rustをはじめとした実践的な運用ガイドの登場により、本番環境での運用ノウハウが充実してきました。さらに、日本語での技術記事や登壇資料も増え、日本語でのコミュニケーションも充実してきています。主要パッケージの品質向上と運用実績の蓄積により、開発環境全体の信頼性は大幅に高まっています。また、言語サーバーの進化やツールチェーンの充実により、開発効率も飛躍的に向上しました。実践的な機能面においても、目覚ましい進歩が見られます。エラーハンドリングの改善やWebAssemblyサポートの強化により、クロスプラットフォーム対応も一層充実しました。また、コンパイラの最適化改善による実行時オーバーヘッドの最小化や、所有権システムによるメモリ安全性の保証など、Rustの基本的な強みはさらに磨きがかかっています。特に、非同期プログラミングのエコシステムは大きく成熟し、堅牢な基盤が確立されています。また、2025年には2024 Rdition がリリースされる。SREとしての展望今後は、Rustで構築されたマイクロサービスや高性能なバックエンドサービスのためのインフラ構築や運用の機会が増えていくことが予想されます。特に、コンテナ環境でのデプロイメントやクラウドネイティブな環境でのインフラ構築において、Rustアプリケーションの特性を最大限に活かすための設計が求められるでしょう。例えば、Rustの低メモリ消費という特徴を活かしたコンテナリソースの最適化や、高速な実行速度を考慮したオートスケーリングの設計など、アプリケーションの特性に合わせたインフラストラクチャの構築が重要になってきます。また、モニタリングやログ収集といった運用基盤においても、Rustアプリケーションに適した構成を検討していく必要があるでしょう。SREとしてRustのプロダクションデプロイメントに関わる場合は、Zero To Production In Rustを参照することをお勧めします。この書籍では、Rustアプリケーションの本番環境への展開に関する実践的なガイドラインが提供されています。www.zero2prod.comRustの再入門のための学習コンテンツ再入門にあたり、Rustの最新のプラクティスやエコシステムの変化をキャッチアップするため、いくつかの資料に取り組みました。特に有用だった書籍を紹介していきます。書籍の良さは情報を俯瞰できる点にあると考えています。わからない点があればLLMに質問することができますので⋯。なお、この記事はRustの基礎知識がある方向けの再入門という観点で資料を選定しているため、完全な初学者向けの内容は含んでいません。参照したドキュメントや内容の詳細については、Xで共有しているドキュメントをご確認ください。プログラミングRust 第2版 を読んで可能な限り手を動かす会を実施します。https://t.co/rmUpbPtK9O— nwiizo (@nwiizo) 2024年11月21日   読んだ本についての定義についてはこちらを参考にしてほしいです。読んでいない本について堂々と語る方法 (ちくま学芸文庫)作者:ピエール・バイヤール,大浦康介筑摩書房Amazonまた、yuk1tydさんのドキュメントは2021年時点の情報ですが、現在も十分に有用な内容となっているためおすすめです。blog-dry.com書籍Programming Rust, 2nd EditionO'Reilly Mediaから出版されている本書は、Rustの基本的な概念から高度な機能まで包括的に解説する定番の教科書です。特に所有権やライフタイム、並行処理といったRustの特徴的な機能について、実践的な例を交えながら詳細に説明されています。本当に再入門してから何度も読んでいる。生成AIに聞くか本を読むか実際に書いていくかの三択である。Programming Rust: Fast, Safe Systems Development作者:Blandy, Jim,Orendorff, Jason,Tindall, Leonora F SO'Reilly MediaAmazon2021年の第2版では、Rust 2021 Editionに対応し、非同期プログラミングやトレイト、ジェネリクス、マクロなど、モダンなRustの重要な機能が大幅に加筆されました。特に、パフォーマンスとメモリ安全性を両立させるためのRustの機能を、システムプログラマの視点から解説している点が特徴です。再三にはなるが2024 Rdition がリリースされる。それに合わせて再び書籍が出されるのが楽しみである。3年毎にリリースがあるのは早すぎず遅すぎずちょうど嬉しい。これまでと違う学び方をしたら挫折せずにRustを学べた話 / Programming Rust techramen24conf LTでも紹介されているように、本書は体系的な学習を可能にする構成と、実践的な例示の豊富さが特徴です。特に、Rustの概念モデルを丁寧に解説している点は、言語仕様の深い理解につながります。再入門時の体系的な知識のアップデートに最適な一冊といえるでしょう。 speakerdeck.comまた、日本語の書籍も出ているので感謝すべきである。プログラミングRust 第2版作者:Jim Blandy,Jason Orendorff,Leonora F. S. TindallオライリージャパンAmazonバックエンドエンジニアを目指す人のためのRust翔泳社から出版されているこの入門書は、実践的なプロジェクトを通じてRustを学ぶアプローチを採用しています。計算クイズからTODOアプリまで、段階的に難易度を上げながら、バックエンドエンジニアに必要な技術要素をカバーしている点が特徴です。バックエンドエンジニアを目指す人のためのRust作者:安東 一慈,大西 諒,徳永 裕介,中村 謙弘,山中 雄大翔泳社Amazon本書の優れている点は、各プロジェクトを通じて特定のRustの概念を深く掘り下げる構成にあります。例えば、ポーカーゲームの実装を通じてデータ構造の理解を深め、家計簿プログラムでファイルI/Oを学び、画像処理ツールで並列処理を実践的に理解できます。また、Cargoによるパッケージ管理、ユニットテスト、リンター、フォーマッターといった実務で重要となる開発ツールの活用方法も丁寧に解説されています。特筆すべきは、エラーハンドリングやOption/Result型の扱いなど、Rustの特徴的な機能を実際のユースケースに即して学べる点です。さらに、Webアプリケーション開発からデプロイメントまでをカバーしており、現代のバックエンド開発の実践的なスキルが身につく構成となっています。ただし、この本はプログラミング言語としてのRustの入門書として優れているものの、プログラミング未経験者にはRust自体の学習難度が高いため、他の言語での開発経験がある方に特にお勧めします。体系的な構成と実践的なプロジェクトを通じた学習アプローチは、技術書の模範となる一冊といえるでしょう。www.estie.jpコミュニティと情報源Rustの再入門において、コミュニティへの参加は技術的な成長と最新動向の把握に重要な役割を果たしています。日本のRustコミュニティは活発な技術交流が行われています。Rust.TokyoRust.Tokyoは日本最大のRustカンファレンスで、年に一度開催される重要なイベントです。私は再入門直後にこのカンファレンスに参加することになり、登壇資料の準備に追われる事態となりましたが、結果的に学習のよい動機付けとなりました。カンファレンスでは、企業での採用事例や実装のベストプラクティス、パフォーマンスチューニングの知見など、実践的な内容が数多く共有されます。また、国内外のRustコミュニティのメンバーとの交流を通じて、最新のトレンドやツール、開発手法について直接学ぶ機会も得られます。Rust-jp ZulipRust-jp Zulipは、日本のRustコミュニティの中心的なコミュニケーション基盤です。SlackやDiscordと異なり、トピックベースの会話構造を持つZulipを採用することで、過去の議論や質問への回答を効率的に検索できる点が特徴です。このプラットフォームでは、初心者向けの基本的な質問から、高度な実装の相談まで、幅広いディスカッションが日本語で行われています。特に、実務での問題解決やコードレビュー、アーキテクチャの相談など、実践的な議論が活発に行われており、再入門者にとって貴重な学習リソースとなっています。学びの記録2017年の実践パケット解析の実装Webフレームワーク検証Rust関連記事一覧2024 年やったことRustでterraform plan/apply のターゲット指定を簡単にするツールを作ってみた - tfocusの仕組みと使い方退屈なことはRust Build Scripts にやらせようRustで郵便番号・住所検索TUIツールを開発した - jpostaRustによる郵便番号検索API (yubin_api) の技術解説tfocusexpjpostcode_rsおわりに2017年の経験は、今となっては貴重な財産です。言語に入門し、一度は挫折を経験しながらもプロダクトへの導入に挑戦したこと、そして結果的に撤退を選択せざるを得なかったことは、私にとって大きな学びとなりました。この貴重な経験と適切な判断へと導いてくれた当時のメンターには感謝しています。パッケージ管理の困難さ、破壊的変更への対応、そして継続的な開発の課題 - これらの経験があったからこそ、現在のRustエコシステムの進化をより深く理解できています。Rustは単なるプログラミング言語の進化を超えて、エコシステム全体として大きく成長しました。特に、かつて私が直面した課題の多くが、コミュニティの成熟とツールチェーンの進化によって解決されつつあります。実践的なユースケースの蓄積は、次世代のシステム開発における新たな可能性を示唆しています。Rust 2024エディションのリリースを控え、言語とエコシステムはさらなる進化を遂げようとしています。SREとしても、このような発展を続けるRustの動向を把握し、実践的な知識を蓄積していくことは、将来への重要な投資になると確信しています。この記事を読んでいる方々も、ぜひこの成長と進化の過程に参加してみませんか？初めての方も、かつて離れた方も、今こそRustと再会するベストなタイミングかもしれません。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GolangからPagerdutyのインシデントを発砲する]]></title>
            <link>https://zenn.dev/tayusa/articles/9091399d6a9018</link>
            <guid>https://zenn.dev/tayusa/articles/9091399d6a9018</guid>
            <pubDate>Wed, 11 Dec 2024 13:30:34 GMT</pubDate>
            <content:encoded><![CDATA[目的Golangで作成したアプリケーションからPagerdutyの任意のインシデントを発砲する Event API v2https://developer.pagerduty.com/docs/3d063fd4814a6-events-api-v2-overview高信頼性、高可用性の非同期APIでシステムからマシンイベントを取り込みます。このAPIに送られたイベントは最終的にPagerDutyサービスにルーティングされ処理されます Event Types Alert監視システムの問題。 既存のアラートを確認または解決するためにイベントを送信することができる...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google Cloud monitoringのアラートをGitHub Issueに通知する]]></title>
            <link>https://kechigon.hatenablog.com/entry/2024/12/11/182649</link>
            <guid>https://kechigon.hatenablog.com/entry/2024/12/11/182649</guid>
            <pubDate>Wed, 11 Dec 2024 09:26:49 GMT</pubDate>
            <content:encoded><![CDATA[タイトルの通り、Google Cloud monitoringのアラートをGitHub Issueに通知するシステムの構築方法を紹介します。terrafromを使って作成します。コードはGitHubリポジトリにまとまっています。github.comこのコードをapplyすることで、Webサービス(EasyBuggy)、監視、アラートをIssueに持っていくパイプラインがデプロイされます。システム図このような構成をとっています。main.tf早速コードを紹介していきます。このファイルでは、EasyBuggyという脆弱なWebサービスをGCEにデプロイします。terraform {  required_providers {    google = {        source = "hashicorp/google"        version = "5.39.0"    }  }}provider "google" {  credentials = var.credential_file  project     = var.project  region      = var.region}resource "google_compute_instance" "easybuggy" {  name         = "easybuggy-instance"  machine_type = "n1-standard-1"  zone         = var.zone  boot_disk {    initialize_params {      image = "debian-cloud/debian-11"    }  }  network_interface {    network = "default"        access_config {}  }  metadata = {    "enable-osconfig" = "true"  }     metadata_startup_script = <<EOF#!/bin/bashsudo apt-get updatefor pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do sudo apt-get remove $pkg; donesudo apt-get install -y ca-certificates curl git sudo install -m 0755 -d /etc/apt/keyringssudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.ascsudo chmod a+r /etc/apt/keyrings/docker.ascecho \  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian \  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \sudo tee /etc/apt/sources.list.d/docker.list > /dev/nullsudo apt-get updatesudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-pluginsudo git clone https://github.com/k-tamura/easybuggy.gitcd easybuggysudo docker build . -t easybuggy:local sudo docker run -p 8080:8080 easybuggy:local EOF}resource "google_compute_firewall" "allow-home-ip" {  name    = "allow-home-ip"  network = "default"   allow {    protocol = "tcp"    ports    = ["8080"]  }  source_ranges = [var.my_ip]}output "instance_ip" {  value = google_compute_instance.easybuggy.network_interface[0].access_config[0].nat_ip}monitoring.tfこちらのファイルでは監視、アラートをIssueに持っていくパイプラインをデプロイします。main.tfでデプロイしたインスタンスのCPU使用率が80%を超えるとアラートが発生します。resource "google_pubsub_topic" "alerts_topic" {  name = "alerts-topic"}resource "google_pubsub_subscription" "alerts_subscription" {  name  = "alerts-subscription"  topic = google_pubsub_topic.alerts_topic.name}resource "google_monitoring_notification_channel" "pubsub_channel" {  display_name = "Pub/Sub to Cloud Function"  type         = "pubsub"  labels = {    "topic" = google_pubsub_topic.alerts_topic.id  }}resource "google_pubsub_topic_iam_binding" "alerts_topic_publisher" {  topic = google_pubsub_topic.alerts_topic.name  role    = "roles/pubsub.publisher"  members = [    "serviceAccount:service-${var.project_id}@gcp-sa-monitoring-notification.iam.gserviceaccount.com"  ]}resource "google_storage_bucket" "easybuggy_monitoring_function_bucket" {  name          = "easybubby_monitoring-functions-bucket"  location      = "ASIA-NORTHEAST1"  force_destroy = true}resource "google_storage_bucket_object" "function_source_object" {  name   = "function-source.zip"  bucket = google_storage_bucket.easybuggy_monitoring_function_bucket.name  source = "function-source.zip"}resource "google_cloudfunctions_function" "issue_creator_function" {  name        = "issue-creator-function"  description = "Receive Pub/Sub message from Google Cloud Monitoring and create a GitHub issue"  runtime    = "python39"  source_archive_bucket = google_storage_bucket.easybuggy_monitoring_function_bucket.name  source_archive_object = google_storage_bucket_object.function_source_object.name  entry_point           = "main"  region                = var.region  environment_variables = {    "GITHUB_API_TOKEN" = var.github_api_token    "GITHUB_REPO"      = var.github_repo    "GITHUB_OWNER"     = var.github_owner  }  event_trigger {    event_type = "providers/cloud.pubsub/eventTypes/topic.publish"    resource   = google_pubsub_topic.alerts_topic.id  }}resource "google_monitoring_alert_policy" "cpu_usage_policy" {  display_name = "High CPU Utilization Alert"  combiner     = "OR"  conditions {    display_name  = "CPU usage over 80%"    condition_threshold {      filter          = "metric.type=\"compute.googleapis.com/instance/cpu/utilization\" AND resource.type=\"gce_instance\""      duration        = "60s"      comparison      = "COMPARISON_GT"      threshold_value = 0.8      }  }  enabled = true  notification_channels = [google_monitoring_notification_channel.pubsub_channel.id]}main.pyfunctionsで実行されるコードです。pub/subから受け取ったデータからアラートのtitleとbodyを抜き出してGithub Issueにポストします。import base64import jsonimport osimport loggingimport requestsfrom flask import Flask, requestapp = Flask(__name__)GITHUB_API_TOKEN = os.environ.get('GITHUB_API_TOKEN')GITHUB_REPO = os.environ.get('GITHUB_REPO')GITHUB_OWNER = os.environ.get('GITHUB_OWNER')logging.basicConfig(level=logging.INFO)logger = logging.getLogger(__name__)def create_github_issue(data):    issue_title = f"Alert: {data['incident']['incident_id']}"    issue_body = data['incident']['summary']    logger.info(f"Creating issue with title: {issue_title} body: {issue_body}")    response = requests.post(        f"https://api.github.com/repos/{GITHUB_OWNER}/{GITHUB_REPO}/issues",        headers={            "Authorization": f"token {GITHUB_API_TOKEN}",            "Accept": "application/vnd.github.v3+json",        },        json={            "title": issue_title,            "body": issue_body,        },    )    if response.status_code == 201:        logger.info("Issue created successfully")        return "Issue created successfully", 201    else:        logger.error(f"Failed to create issue: {response.content}")        return f"Failed to create issue: {response.content}", response.status_code@app.route('/', methods=['POST'])def main(d, context): #Need to receive arguments    envelope = request.get_json()        if not envelope:        logger.error("No envelope received")        return "Bad Request", 400        logger.info(f"envelope: {envelope}")    pubsub_data = envelope.get('data', {})    logger.info(f"pub_sub_data")    if not pubsub_data:        logger.error(f"No outside data received: ")        return "Bad Request", 400    try:        data_base64 = pubsub_data.get('data', '')        if not data_base64:            raise ValueError("No data field in outside data")                data = base64.b64decode(data_base64.encode('utf-8')).decode('utf-8')        logger.info(f"Decoded data: {data}")        data = json.loads(data)                logger.info(f"Received data: {data}")    except Exception as e:        logger.error(f"Error processing message: {e}")        return "Bad Request", 400        return create_github_issue(data)if __name__ == "__main__":    app.run()デプロイ内容を理解したらterraform applyしましょう。アプライが成功したらインスタンスIPが表示されます。動作確認http://instance_ip:8080にブラウザでアクセスするとこのような画面になります。「無限ループ」のリンクを押し、無限ループを発生させましょう。CPU使用率が80%を超えたことを確認し、GitHub Issueを確認すると、アラートが通知されています。以上がGoogle Cloud monitoringのアラートをGitHub Issueに通知する流れとなります。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Kube-schedulerプラグインCoschedulingを体験してみた]]></title>
            <link>https://zenn.dev/k_nagase/articles/co_scheduling</link>
            <guid>https://zenn.dev/k_nagase/articles/co_scheduling</guid>
            <pubDate>Wed, 11 Dec 2024 01:00:01 GMT</pubDate>
            <content:encoded><![CDATA[本記事は 3-shake Advent Calendar 2024 シリーズ 1 の 11 日目の記事です。 はじめにここ最近Kubernetesのスケジューリングについて調査する機会があり、その一環でスケジューラープラグインの1つであるCoschedulingについても調査しました。この時の調査と簡単なハンズオンについてこの記事でまとめてみたいと思います。Kubernetesのコントロールプレーンの1コンポーネントであるスケジューラはpluginによる機能拡張が可能です。プラグインは以下のリポジトリにまとまっています。https://github.com/kubernetes...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド一発で、本格的なおうちKubernetesを構築する]]></title>
            <link>https://speakerdeck.com/melanmeg/komando-fa-de-ben-ge-de-naoutikuberneteswogou-zhu-suru</link>
            <guid>https://speakerdeck.com/melanmeg/komando-fa-de-ben-ge-de-naoutikuberneteswogou-zhu-suru</guid>
            <pubDate>Tue, 10 Dec 2024 05:00:00 GMT</pubDate>
            <content:encoded><![CDATA[作成したリポジトリ：https://github.com/melanmeg/k8s_1-30_on_noble参考：https://github.com/unchama/kube-cluster-on-proxmoxhttps://k8sh.net/arch/https://www.server-world.info/query?os=Ubuntu_24.04&p=kubernetes&f=1https://www.youtube.com/watch?v=7BLmtR1nhcY]]></content:encoded>
        </item>
    </channel>
</rss>