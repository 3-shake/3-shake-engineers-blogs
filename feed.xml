<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Wed, 09 Jul 2025 22:35:58 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[mypy: type checker for python]]></title>
            <link>https://daisuke1024akagawa.medium.com/mypy-type-checker-for-python-0cafa6124ad6?source=rss-c54ac439ad2b------2</link>
            <guid>https://daisuke1024akagawa.medium.com/mypy-type-checker-for-python-0cafa6124ad6?source=rss-c54ac439ad2b------2</guid>
            <pubDate>Wed, 09 Jul 2025 12:51:38 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Apache Gumpとはなんなのか？]]></title>
            <link>https://zenn.dev/akasan/articles/5691b542781fb1</link>
            <guid>https://zenn.dev/akasan/articles/5691b542781fb1</guid>
            <pubDate>Wed, 09 Jul 2025 10:38:01 GMT</pubDate>
            <content:encoded><![CDATA[今回はApache Gumpについて調べてみました。 今回も以下のツールを使って対象プロジェクトを決めました！https://zenn.dev/akasan/articles/7e30ad266c02c4※ 本企画に関する記事の目的は、それぞれのプロジェクトを本格的に深ぼるのではなく、プロジェクト名⇆どんな内容かをパッと思い出せるようにすることを目指します！※ とはいえ深ぼってみたいプロジェクトがあればどんどん複数連載になると思います。 Apache Gumpとは？公式サイトによるとThe Apache Gump continuous integration tool w...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Kubernetes上の異なるPodにFastAPIサーバを立てて通信させてみた]]></title>
            <link>https://zenn.dev/akasan/articles/a65b74f47a204d</link>
            <guid>https://zenn.dev/akasan/articles/a65b74f47a204d</guid>
            <pubDate>Tue, 08 Jul 2025 13:37:14 GMT</pubDate>
            <content:encoded><![CDATA[今回は、Kubernetes上で異なるFastAPIサーバを立てて、片方のFastAPIサーバにアクセスすると別のFastAPIサーバにアクセスされる環境を作ってみました。まだマイクロサービスを構築した経験が少ないので、まずはシンプルな構成から始めてみます。 今回のシステム構成今回は以下のような構成でシステムを構築します。Google CloudのGKE上でシステムを構成DockerイメージはArtifact Registryに保存FastAPIサーバは二種類建てるパブリックアクセスをするためのサーバパブリックサーバからアクセスされるが、クラスタ内に閉じているプライベ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Apache Sqoopとはなんなのか？]]></title>
            <link>https://zenn.dev/akasan/articles/a4ad368de2cd4a</link>
            <guid>https://zenn.dev/akasan/articles/a4ad368de2cd4a</guid>
            <pubDate>Mon, 07 Jul 2025 12:53:39 GMT</pubDate>
            <content:encoded><![CDATA[今回はApache Sqoopについて調べてみました。 今回も以下のツールを使って対象プロジェクトを決めました！https://zenn.dev/akasan/articles/7e30ad266c02c4※ 本企画に関する記事の目的は、それぞれのプロジェクトを本格的に深ぼるのではなく、プロジェクト名⇆どんな内容かをパッと思い出せるようにすることを目指します！※ とはいえ深ぼってみたいプロジェクトがあればどんどん複数連載になると思います。 Apache Sqoopとは？Apache Sqoopとは公式ページによると、Apache Sqoop(TM) is a tool d...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイク、NVIDIA Inception に参加]]></title>
            <link>https://sreake.com/blog/nvidia-inception/</link>
            <guid>https://sreake.com/blog/nvidia-inception/</guid>
            <pubDate>Mon, 07 Jul 2025 10:29:15 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）は、テクノロジーの進歩によって業界に革命を起こすスタートアップ企業を育成するプログラムであるNVIDIA Inceptionに参加しました。The post スリーシェイク、NVIDIA Inception に参加 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[OpenLLMetryへの入門]]></title>
            <link>https://zenn.dev/akasan/articles/aaf96c46284db0</link>
            <guid>https://zenn.dev/akasan/articles/aaf96c46284db0</guid>
            <pubDate>Sun, 06 Jul 2025 04:14:09 GMT</pubDate>
            <content:encoded><![CDATA[今回はLLMアプリケーションのオブザーバビリティを実現するためのOpenLLMetryについて紹介しようと思います。 OpenLLMetryとは？OpenLLMetryとは、OpenTelemetryをベースに構築されており、LLMアプリケーションに関してオブザーバビリティを提供してくれるツールになります。OpenTelemetryの拡張であることから、既存のアプリケーション監視基盤の形式を踏襲しつつLLMに適したオブザーバビリティを導入することができます。 早速使ってみましょうOpenLLMetryはtraceloopによって展開されており、公式サイトおよびGitHubレポ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[正義のエンジニアという幻想 - 媚びないことと無礼の境界線]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/07/05/132411</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/07/05/132411</guid>
            <pubDate>Sat, 05 Jul 2025 04:24:11 GMT</pubDate>
            <content:encoded><![CDATA[はじめに私はかつて、自分の技術思想とキャリア戦略が100%正しいと信じて疑いませんでした。そして、それを受け入れない企業、同僚たちが100%間違っていると本気で思っていたのです。今思えば、それはソフトウェアエンジニアという職業に就いた多くの若い人が陥る、ある種の思春期的な錯覚だったのかもしれません。技術的な正しさを盾に、社会的な配慮を無視し、人間関係の機微を「非論理的」と切り捨てていました(エンジニアの論理的なんて往々にして論理的ではないのに)。この記事は、かつての私のような「正義のエンジニア」だった自分への懺悔であり、同じ過ちを犯している人たちへの警鐘でもあります。媚びないことと無礼であることの区別もつかないまま、技術的優位性を振りかざしていた—そんな恥ずかしい過去を、今こそ正直に振り返ってみたいと思います。DD(どっちもどっち)論 「解決できない問題」には理由がある (WPB eBooks)作者:橘玲集英社Amazonこのブログが良ければ読者になったり、nwiizoのXやGithubをフォロワーしてくれると嬉しいです。では、早速はじめていきます。技術的正しさという名の傲慢「なぜこんな非効率的な実装をするんですか？」「もっと良い方法があるのに...」「技術的にはこっちの方が正しいんですけどね」そんな恥知らずな言葉を、私は何度口にしたことでしょう。普段は配慮できるつもりでいたのに、技術的な議論になると、つい正論を優先してしまう癖がありました。先輩が現実的な理由を説明してくれているのに、心の中では「でも技術的には間違ってる」と思ってしまう。コードレビューで「ここはこう書いた方が綺麗ですよ」と、相手の状況を考えずにコメントしてしまう。政治的な理由で技術選定が決まれば、会議後に同期に「エンジニアリングの敗北だよね」と吐き捨てる。ビジネス判断を優先する同僚を見ては「技術者として魂を売ってる」と心の中で見下す。「技術的に正しいことを追求するのがエンジニアの仕事」「妥協したらそこで終わり」「コードが全てを物語る」今思い返すと顔から火が出るような発言の数々。技術的な正論を振りかざすことが、エンジニアとしての誠実さだと勘違いしていたのです。技術的に正しいことを言っているのだから、それが最優先されるべき—そう信じていました。でも問題は、私が「技術的正しさ」だけが唯一の評価軸だと思い込んでいたことでした。ビジネス価値、チームの状況、スケジュールの制約—これらも同じくらい重要な要素です。しかし、当時の私にはそのバランス感覚が足りませんでした。コードレビューでは技術的な理想を押し付けがちで、会議では「でも技術的には...」という前置きで反対意見を述べることが多かった。新人が質問してきても、「まずはドキュメント読んでみて」と突き放してしまうことも。今思えば、技術的に正しいことを伝えようとしているつもりで、実際には相手の立場に立てていなかっただけでした。これからの「正義」の話をしよう ──いまを生き延びるための哲学 (ハヤカワ・ノンフィクション文庫)作者:マイケル・サンデル早川書房Amazon最も痛いのは、エンジニアリングの視点でしか物事を見られなかったことです。採用面接の後には必ず「技術力が低い人を採用すべきじゃない」と文句を言い、ビジネス感覚や調整能力の価値なんて考えもしませんでした。技術選定の会議では「Rustを使うべき」「マイクロサービスにすべき」と主張するものの、採用の難しさや運用コストの話が出ると「それは別の問題」と切り捨てる。ビジネスの成長段階や組織の体力を考えない、机上の空論ばかりでした。「もっとモダンな開発環境を」「もっと厳密なレビュープロセスを」と理想論を語りながら、それが非エンジニアとの協業や意思決定スピードにどう影響するかは無視。技術は事業を加速させる手段なのに、私の頭の中では技術それ自体が目的化していたのです。そして同僚が現実的な判断をすると「ビジネスに魂を売った」と心の中で見下す。実際は、私こそが現実を見ていなかったのです。幸い、私の意見が採用されることはほとんどありませんでしたが、今思えばそれで良かったのでしょう。理想のキャリアという妄想私は自分のキャリア構築が完璧だと思い込んでいました。GitHubでOSS活動をし、技術ブログを書き、勉強会で登壇する。これこそが「エンジニア」の歩むべき道だと信じて疑いませんでした。かっこよかったんだと思います。憧れていたんだと思います。社内政治に長けた人を見ては「技術力のない政治屋」と心の中で罵り、クライアントとの関係構築に努める人を「営業エンジニア」と揶揄していました。チームの和を大切にする人なんて「ぬるま湯に浸かっている」としか思えなかったのです。さらに滑稽だったのは、自分の行動が最も正しいと信じていたことです。会社の不満をオープンに書き、技術的な批判を遠慮なく投稿し、「透明性」と「正直さ」を標榜していました。それが「媚びない姿勢」だと勘違いしていたのです。しかし実際には、それは単なる社会性の欠如でした。批判と中傷の違いも、建設的な議論と単なる文句の違いも理解していませんでした。「なぜ私の正論が受け入れられないのか」と憤りながら、自分のコミュニケーション能力の低さには全く気づいていなかったのです。High Conflict よい対立 悪い対立 世界を二極化させないために作者:アマンダ・リプリーディスカヴァー・トゥエンティワンAmazon現実を100%否定する愚かさ最も恥ずかしいのは、自分の理想が受け入れられない現実を「100%間違っている」と断じていたことです。レガシーシステムを見ては「なぜこんなゴミを使い続けるんだ」、古い技術スタックに「この会社に未来はない」、ビジネス優先の判断に「エンジニアリングの敗北」—すべてを否定的に捉えていました。私は自分以外の判断基準を認められませんでした。 技術的に正しくないものは全て間違いで、それを許容する人たちも間違っている。そんな狭い視野でしか物事を見られなかったのです。同期との飲み会では不満ばかりこぼしていました。「うちの会社、まだSVN使ってるんだよ。Git使えないエンジニアの会社とか終わってる」「テストコード書かない文化とか、プロの仕事じゃない」「ウォーターフォールとか、時代遅れもいいところ」プロジェクトで問題が起きれば「マネジメントが技術を理解していないから」、自分の提案が通らなければ「この会社は技術を軽視している」、期待した評価が得られなければ「エンジニアが正当に評価されない組織」—全ての原因を外部に求めていました。自分が提案した新技術が却下されれば「老害が変化を恐れている」と憤り、レガシーコードの改修を任されれば「俺の才能の無駄遣い」と不満を漏らし、ドキュメント作成を頼まれれば「エンジニアの仕事じゃない」と文句を言う。でも振り返ってみれば明らかです。問題は私自身にありました。 技術的な正しさだけを追求し、ビジネス的な制約や組織の事情を理解しようとしなかった。技術力があることと、組織で価値を生み出すことは別物です。そんな視野の狭さが、多くの問題を生み出していたのです。正しいことを言うことと、相手に受け入れられる形で伝えることも別物です。そんな基本的なことすら理解していなかったのです。転機となった出来事幸運なことに、私は比較的早い段階で痛い目に遭い、良いメンターに出会うことができました(というか強い人)。あるコードレビューで、私がいつものように「このコード、正直ひどくないですか？全部書き直した方が早いです」とコメントしたとき、シニアエンジニアが個別に連絡をくれました。「君の指摘は技術的には正しい。でも、そのコメントを見た人がどう感じるか考えたことある？彼は他のタスクも抱えながら、期限に間に合わせようと必死だった。君のコメントは、その努力を全否定している」その言葉にハッとしました。私は技術的な正しさばかりを見て、人の気持ちを踏みにじっていたのです。別の機会には、マネージャーが1on1で厳しい指摘をしました。「君は優秀だ。でも、チームメンバーが君を避け始めている。それでいいの？技術力があっても、一人では何も作れないよ」(とても良いフィードバックをしてくれる良いマネージャーでした)ある技術選定の会議で、私の提案があっさり却下されたこともありました。技術的には明らかに優れていたはずなのに。後で分かったのは、採用された同僚が事前に全ての関係者の不安を聞き出し、丁寧に説明して回っていたということ。私は正しさだけを主張し、人を動かす努力を怠っていたのです。そして最も衝撃的だったのは、年次が上がって後輩ができたときのことです。私の何気ない「それは違うよ」という一言で、新卒エンジニアが完全に萎縮してしまいました。その後、彼は私に質問することを避けるようになり、分からないことを抱え込むように。私は、かつて自分が嫌っていた「怖い先輩」になっていたのです。これらの経験が重なって、ようやく理解しました。技術力は重要だが、それをどう使うかはもっと重要。正しいことを、正しい方法で伝えられなければ、それはただの暴力だということを。「変化を嫌う人」を動かす:魅力的な提案が受け入れられない4つの理由作者:ロレン・ノードグレン,デイヴィッド・ションタル,船木 謙一(監修)草思社Amazon媚びないと無礼の致命的な混同「私は媚びない」—それが私のアイデンティティでした。しかし今思えば、それは単に「無礼で無神経だった」だけです。普段は普通に接することができても、技術的な話題になると途端に配慮が吹き飛んでいました。「このコード、正直レベル低くないですか？」「え、まだjQuery使ってるんですか？今どき？」「Excelで管理とか、エンジニアリング組織として恥ずかしくないんですか」コードレビューでは、つい「このままマージするの、正直抵抗あります」と書いてしまう。会議での議論では他の人の意見を尊重しつつも、心の中では「技術的にナンセンス」と思っていることが顔に出てしまう。ペアプログラミングでは、相手のアプローチを見て「あー、それはちょっと...」と否定的な反応をしてしまう。質問されても「それは基本なので自分で調べた方が身につきますよ」と突き放す。同僚との雑談では「うちの技術レベル、正直物足りない」「もっと技術にこだわる会社に行きたい」などと不満を漏らし、それを「健全な問題意識」だと勘違いしていたのです。媚びないことと、相手を尊重することは両立します。 でも当時の私にはその区別がつきませんでした。率直であることと配慮がないことを混同し、技術的な正しさを盾に、人としての礼儀を忘れていました。最も痛いのは、SNSでの振る舞いです。「エンジニアは技術で語るべき」という信念のもと、技術以外の要素をすべて否定していました。ビジネス的な判断を「技術の敗北」と断じ、人間関係の構築を「非生産的」と切り捨てていました。そんな態度が「カッコいい」「筋が通っている」と本気で思っていたのです。今思えば、ただの社会不適合者でした。頭の悪い反抗期の言い訳私は様々な言い訳を用意していました。「エンジニアは成果で評価されるべきだから人間関係は二の次」「技術的に正しいことが最優先だから言い方なんて些細な問題」「実力があれば多少の態度の悪さは許される」「媚びるくらいなら孤立した方がマシ」これらはすべて、自分の社会性の欠如を正当化するための、頭の悪い言い訳でした。 まるで反抗期の中学生が「大人は汚い」と言い訳するように、私は「技術的正しさ」を盾に、自分の未熟さを隠していたのです。社内の勉強会では「政治的な理由で技術選定するのは技術者への冒涜」「日本の会社はエンジニアを大切にしない」などと大げさな批判を展開し、それを「問題提起」だと思い込んでいました。特に恥ずかしいのは、これらの言い訳を「エンジニアの美学」として語っていたことです。「媚びない技術者の生き方」「技術に嘘をつかない姿勢」「純粋なエンジニアリング」—そんな青臭いタイトルでブログを書き、勉強会で熱弁していました。同じような考えを持つ人たちとエコーチェンバーを形成し、「俺たちだけが本物のエンジニア」「周りは技術を理解していない」「いつか俺たちの時代が来る」—そんな幼稚な選民思想に酔いしれていたのです。でも実際は、技術は手段であって目的ではないという当たり前のことから目を背け、自分の社会性のなさを「美学」で糊塗していただけでした。その結果として何を得たでしょうか。確かに一部の「同志」は得られました。でも多くの機会を失い、多くの人間関係を壊し、多くの成長のチャンスを逃してしまいました。譲れないもののために、譲るものを決めるやがて私は真剣に考えるようになりました。自分が本当に譲れないものは何か？私にとって譲れないのは技術的な誠実さ、つまり嘘はつかない、質の低いコードは書かないということ。そしてユーザーファースト、エンドユーザーの利益を最優先すること。さらに継続的な学習、常に新しいことを学び続けることでした。これ以外は、状況に応じて柔軟に対応することにしました。本質を守るために、形式では妥協する。これが私の新しい戦略でした。表現方法では本音を建前でオブラートに包むようになりました。タイミングも最適な時期を待つように。プロセスでは目的のためなら遠回りも受け入れ、形式的には無駄に見える会議や書類も必要なら対応するようになりました。他者と働く──「わかりあえなさ」から始める組織論 (NewsPicksパブリッシング)作者:宇田川元一ニューズピックスAmazon技術は手段、したたかに生きる戦略そしてもう一つ、重要な気づきがありました。技術は手段であって目的ではないということです。私自身、技術的な興味に駆動されています。新しい技術を学ぶことが楽しいし、エレガントなコードを書くことに喜びを感じます。正直に言えば、ビジネス価値なんてどうでもよくて、ただ面白い技術を触っていたいだけなのです。でも、お金をもらって仕事をする以上、建前上それが主目的とは言いづらい。だからこそ「したたかにやろうぜ」という考え方が大切なのです。つまり、組織が求める「成果」という枠組みを利用して、自分の技術的好奇心を満たすということ。表向きは「ビジネス価値の創出」を掲げながら、実際には「面白い技術で遊ぶ」ための正当性を確保する。これは嘘をついているのではなく、異なる価値観を持つ人々が共存するための知恵なのです。例えば、「パフォーマンス改善」という大義名分のもとで、最新のフレームワークを導入する。「開発効率の向上」という建前で、面白そうなツールチェーンを構築する。「技術的負債の解消」という錦の御旗を掲げて、自分が書きたいようにコードを書き直す。重要なのは、これらの建前が単なる口実ではなく、実際に価値を生み出すことです。新技術で遊びながら、本当にちゃんとパフォーマンスを改善する。好きなツールを使いながら、実際に開発効率を上げる。コードを書き直しながら、本当に保守性を向上させる。「プロフェッショナルとして責任を果たします」と胸を張りながら、心の中では「やった！これで堂々とRustが書ける！」と小躍りする。この二重構造こそが、エンジニアとしてのしたたかさです。組織は成果を得て満足し、私たちは技術的満足を得る。Win-Winの関係を作り出すこと。それは決して不誠実ではなく、むしろ異なる価値観を持つ者同士が、お互いの利益を最大化する賢明な戦略なのです。これは「技術への情熱」と「ビジネスへの責任」を両立させる、システムをハックする大人のやり方です。スタッフエンジニア　マネジメントを超えるリーダーシップ作者:Will Larson日経BPAmazonエンジニアとしてたぶん大切なこと今になってようやく分かります。エンジニアとして本当に大切なのは、技術力と人間力のバランス、そして戦略的なしたたかさだということが。技術的に正しいことを、相手が受け入れられる形で伝える。それは媚びることではなく、プロフェッショナルとしての基本的なスキルです。組織の制約を理解しながら、最適な解決策を見つける。それは妥協ではなく、現実的な問題解決能力です。異なる価値観を持つ人たちと協力して価値を生み出す。それは迎合ではなく、チームワークです。自分の意見を持ちながら、相手の意見にも耳を傾ける。それは弱さではなく、成熟した大人の態度です。そして何より、自分の技術的興味を満たしながら、組織の目的も達成する。このしたたかさこそが、長期的に見て最も賢い生き方だと思うのです。具体的に言えば、「セキュリティ強化」という名目で面白いツールを導入し、「運用効率化」という建前で自動化の仕組みを作り、「将来の拡張性」という理由で好きなアーキテクチャを採用する。でも重要なのは、これらが本当に価値を生み出すこと。セキュリティは本当に強化され、運用は本当に効率化され、システムは本当に拡張しやすくなる。つまり、自分の欲望と組織の利益を一致させる技術を身につけるということ。これは詐欺ではなく、むしろ最高のプロフェッショナリズムです。なぜなら、エンジニアが情熱を持って取り組んだ仕事こそが、最高の成果を生み出すからです。また、「媚びない」ことと「無礼」であることは全く違います。 前者は信念を持つことであり、後者は単なる社会性の欠如です。同様に、「したたか」であることと「ずる賢い」ことも違います。前者は双方の利益を最大化する戦略的思考であり、後者は単なる利己主義です。そして「技術への純粋な愛」と「ビジネスへの貢献」は対立するものではなく、うまくブレンドすることで、より強力な推進力になるのです。あと、技術士倫理綱領などを読むのもオススメです。今の私は、技術的な議論をする際も相手への敬意を忘れません。自分の意見を主張する際も、相手の立場を考慮します。SNSでの発言も、建設的で前向きなものを心がけています。そして、自分の技術的興味を追求しながら、それをビジネス価値に変換する方法を常に考えています。これは「売れた」「丸くなった」のではありません。ようやく大人になったのです。そして、本当の意味で強くなったのです。パーティーが終わって、中年が始まる作者:pha幻冬舎Amazonおわりに「お前も結局、体制に飲み込まれたのか」—かつての私なら、今の私をそう批判したでしょう。しかし、それでいいのです。技術的な純粋さを追求することと、社会的な成熟を遂げることは矛盾しません。むしろ、両方を兼ね備えてこそ、プロの仕事と言えるのではないでしょうか。私はもう「正義のエンジニア」ではありません。ただの、少しだけ成長したエンジニアです。技術への情熱は変わりませんが、それを表現する方法は大きく変わりました。そして、その情熱を現実世界で活かす術を身につけました。媚びないことと無礼の区別がつかなかった、頭の悪い反抗期は流石に終わりました。これからは、人としてちゃんとしたのを前提にしたエンジニアを目指します。正しいことを、正しい方法で、正しいタイミングで実現できるエンジニアに。そして、かつての私のような若いエンジニアを見かけたら、優しく、でもはっきりと伝えたいと思います。「君の気持ちはよく分かる。でも、もっといい方法があるよ。一緒にしたたかにやっていこうぜ」と。多分昔の私だったら「は？日和って迎合した負け犬が何言ってんの？」「技術を捨てて政治に走った元エンジニアの戯言でしょ」「そうやって妥協を重ねた結果が今のレガシーシステムなんだよ」とか思って、心の中で見下しながら表面上は「はい、参考にします」って適当に流すんでしょうね。まあ、それでいいんです。私も通った道だから。いつか痛い目に遭って、ようやく気づくでしょう。自分が単なる視野の狭いガキだったってことに。その時になって初めて、この言葉の意味が分かるはずです。けど大人として言う義務があるので言っておきました。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[kustomizeを使ってみた]]></title>
            <link>https://zenn.dev/akasan/articles/7686dd6d542595</link>
            <guid>https://zenn.dev/akasan/articles/7686dd6d542595</guid>
            <pubDate>Sat, 05 Jul 2025 04:23:57 GMT</pubDate>
            <content:encoded><![CDATA[今回はkubernetesの宣言的なマネジメントをできるkustomizeを使ってみました。kubernetesを最近よく使うなかでとても目にするので、今回チュートリアルをやってみました。 kustomizeとは？公式ページによるとKustomize is a standalone tool to customize Kubernetes objects through a kustomization file.ということで、kustomizationファイルを通じてkubernetesオブジェクトをカスタマイズするスタンドアロンツールということです。kubectlの1.1...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[mypyでPythonの型チェックをしてみた]]></title>
            <link>https://zenn.dev/akasan/articles/ae29fc6022402b</link>
            <guid>https://zenn.dev/akasan/articles/ae29fc6022402b</guid>
            <pubDate>Fri, 04 Jul 2025 13:37:08 GMT</pubDate>
            <content:encoded><![CDATA[今回はPythonの型チェックをできるmypyを使ってみたので紹介します。 mypyとは？mypyはPythonの静的型チェックツールになります。Pythonは動的型付言語であり、データ型の厳密なチェックが基本的にされません。実装の難易度を下げて柔軟なコーディングができる反面、データ型の間違いによるエラーが発生するかどうかが実行するまでわからないという弱点があります。mypyを使うことにより、静的型チェックを実施することができるので、データ型の扱い方のミスなどを事前に気づくことができます。https://github.com/python/mypy 使ってみる インストー...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[grypeを使ってdockerイメージの脆弱性診断してみた]]></title>
            <link>https://zenn.dev/akasan/articles/c34a95cf1b8c13</link>
            <guid>https://zenn.dev/akasan/articles/c34a95cf1b8c13</guid>
            <pubDate>Thu, 03 Jul 2025 14:29:55 GMT</pubDate>
            <content:encoded><![CDATA[今回はgrypeを使って、dockerイメージの脆弱性を検知してみました。 grypeとは？公式GitHubによると、A vulnerability scanner for container images and filesystems. Easily install the binary to try it out. Works with Syft, the powerful SBOM (software bill of materials) tool for container images and filesystems.ということで、コンテナイメージとファイルシス...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ローカルエディタからワンクリックでGoogle Cloud Workstationに接続する方法]]></title>
            <link>https://qiita.com/aminevg/items/27f55b1809b6629567f6</link>
            <guid>https://qiita.com/aminevg/items/27f55b1809b6629567f6</guid>
            <pubDate>Wed, 02 Jul 2025 13:43:33 GMT</pubDate>
            <content:encoded><![CDATA[背景皆さんは、Google Cloud Workstationsという製品はご存知ですか？「フルマネージド開発環境」を提供していて、セキュリティの強化や開発者のオンボーディングの加速を期待できる製品です。クラウド上の開発環境ということもあって、ブラウザ内での開...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[openai-agents-pythonを使ってマルチエージェントシステムを作ってみた]]></title>
            <link>https://zenn.dev/akasan/articles/9c36321eefbb1a</link>
            <guid>https://zenn.dev/akasan/articles/9c36321eefbb1a</guid>
            <pubDate>Wed, 02 Jul 2025 13:07:39 GMT</pubDate>
            <content:encoded><![CDATA[今回は、マルチエージェントワークフローを開発するためのライブラリであるopenai-agents-pythondを使ってみたので紹介します。 openai-agents-pythonとは？公式GitHubによると、The OpenAI Agents SDK is a lightweight yet powerful framework for building multi-agent workflows. It is provider-agnostic, supporting the OpenAI Responses and Chat Completions APIs, as ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[kindでローカルでKubernetesを用いてFastAPIサーバを立ち上げる]]></title>
            <link>https://zenn.dev/akasan/articles/1633f745945c56</link>
            <guid>https://zenn.dev/akasan/articles/1633f745945c56</guid>
            <pubDate>Tue, 01 Jul 2025 13:15:57 GMT</pubDate>
            <content:encoded><![CDATA[今回はDockerを利用してローカルでKubernetes環境を構築できるkindを用いて、FastAPIサーバを実装してみました。 kindとは？公式ページによると、kind is a tool for running local Kubernetes clusters using Docker container “nodes”.kind was primarily designed for testing Kubernetes itself, but may be used for local development or CI.ということで、Dockerコンテナを...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：kdash]]></title>
            <link>https://zenn.dev/akasan/articles/b520532e647f6d</link>
            <guid>https://zenn.dev/akasan/articles/b520532e647f6d</guid>
            <pubDate>Mon, 30 Jun 2025 12:31:31 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第11回目は、kdashというコマンドを紹介します。kdashを使うことでターミナル上でKubernetesのダッシュボードを作成できます。なお、第10回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/841dcbd5c409d5 kdashとは公式GitHubによると、A simple terminal dashboard for Kubernetes built with Rustということで、Rust製ののターミナルで動くKubernetesのダッシュボードということです。...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[「あつまれ Lookerの森 #3」 オンサイト行ってきました記録]]></title>
            <link>https://zenn.dev/nedoko_dok0dko/articles/5da95def70336b</link>
            <guid>https://zenn.dev/nedoko_dok0dko/articles/5da95def70336b</guid>
            <pubDate>Mon, 30 Jun 2025 11:21:02 GMT</pubDate>
            <content:encoded><![CDATA[what6/27に開催された「あつまれ Lookerの森 #3」のオンサイト参加ログです当日の雰囲気や登壇者の方々の発表内容等を簡単にまとめたものになります あつまれ Lookerの森とはJagu'e'rのデータ利活用分科会が主催するLookerにフォーカスを当てた勉強会です※ Jagu'e'r: Google Cloudのユーザー会。Lookerだけでなく様々なGoogle Cloud製品に関したコミュニティやイベントを企画・開催しています今回は3回目ということでしたが、私は初めての参加でした。コミュニティイベントというのも初参加だったため、「どんな雰囲気なのだ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[生成AIで物語を書くためにプロンプトの制約や原則について学ぶ、という話をしてきました #女オタ生成AI部]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/30/171149</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/30/171149</guid>
            <pubDate>Mon, 30 Jun 2025 08:11:49 GMT</pubDate>
            <content:encoded><![CDATA[はじめに2025年6月29日、「#女オタ生成AIハッカソン 2025 夏の陣@東京」なる場において、「生成AIで小説を書くためにプロンプトの制約や原則について学ぶ」という題目で登壇させていただく機会を得た。ハヤカワ五味さんからお声がけいただいた時、私の中でエンジニアとしての好奇心が強く刺激された。エンジニアリングの視点から生成AIの本質を解き明かすことで、創作者の皆様に新しい視点を提供できるのではないか。異なる分野の知見を融合させることで、何か面白いことが起きるかもしれない。そんな期待を胸に、私は登壇に臨んだのであった。(これは嘘で前日不安で酒を飲みすぎた⋯。)note.com実は、プログラミングの世界では既に大きな変革が進行している。Tim O'Reillyが最近発表した「The End of Programming as We Know It」という論考が示すように、AIの登場によってプログラマーの役割は根本的に変わりつつある。もはや我々は、コードを一行一行書く職人ではなく、AIという「デジタルワーカー」を指揮するマネージャーへと変貌しているのだ。www.oreilly.comこの変革は、単なる技術的な進化ではない。O'Reillyが指摘するように、プログラミングの歴史は常に「終わり」と「始まり」の連続であった。物理回路の接続から始まり、バイナリコード、アセンブリ言語、高級言語へと進化するたびに、「プログラミングの終わり」が宣言されてきた。しかし実際には、プログラマーの数は減るどころか増え続けてきたのである。そして今、同じ変革の波が創作の世界にも押し寄せようとしている。資料準備を進める中で、ある確信が生まれた。これは創作の新しい扉が開かれる瞬間なのだと。新しい道具が生まれるたびに、それは既存の方法を否定するのではなく、創作の可能性を拡張してきた。筆から万年筆へ、タイプライターからワープロへ。そして今、AIという新しい道具が加わることで、より多くの人が創作に参加できるようになり、これまでとは異なる表現の可能性が開かれようとしている。(その片鱗を見たのはハッカソンでも同じでアイディアが高速に実現される世界で我々は何をアウトプットするかまだわからない。他人にとって価値のあるものをアウトプットしなくてよくて自分の為にアウトプットできるため)syu-m-5151.hatenablog.comこのブログや登壇資料が良ければ読者になったり、nwiizoのXやGithubをフォロワーしてくれると嬉しいです。では、早速はじめていきます。登壇資料普通に業界違いで難産。良い資料になったと思うので興味があれば読んでほしいです。 speakerdeck.com👻女オタ生成AIハッカソン2025夏東京「生成AIで小説を書くためにプロンプトの制約や原則について学ぶ」というタイトルで登壇します。こちら、資料になります。#女オタ生成AI部 #女オタ生成AIハッカソンhttps://t.co/lisoeFt69h— nwiizo (@nwiizo) 2025年6月29日   登壇で伝えたかったこと、伝えきれなかったこと久しぶりにエモい気持ちになったので散文を書くわね〜！登壇当日、会場では思いがけない出会いもあった。以前書いた「20代最後の一週間を生きるエンジニア」のブログ記事について、複数の参加者から「あの記事、良かったです」と声をかけていただいたのだ。嬉しかったです(小並)。syu-m-5151.hatenablog.comプロンプトエンジニアリングは「技芸」である30分という限られた時間で私が最も強調したかったのは、プロンプトエンジニアリングを単なる「知識」としてではなく、「技芸」として捉えることの重要性であった。楽譜を読めても楽器が弾けるわけではないように、プロンプトの書き方を知識として学んでも、実際に良い小説が書けるわけではない。これは自明の理である。実際に手を動かし、失敗し、その失敗から学ぶ。この地道な繰り返しによってのみ、AIとの対話の「呼吸」とでも言うべきものが身につくのである。経済史学者James Bessenが産業革命時代の織物工場を研究して発見したように、新しい技術の導入は単純な置き換えではない。「Learning by doing」、実践を通じた学習こそが、真の生産性向上をもたらすのだ。AIツールを前にした創作者も同じである。マニュアルを読むだけでは不十分で、実際に使い、失敗し、その経験から学ぶことで初めて、新しい創作の技芸が身につく。登壇では、5つの原則やら段階的アプローチやら、CHARACTER.mdによる管理手法やらを体系的に説明した。これらはすべて重要な「型」である。しかしながら、型を知ることと、型を使いこなすことは天と地ほども違うのだ。重要なのは、新しいツールを恐れずに試し続ける姿勢である。「プロンプトエンジニアリング」から「コンテキストエンジニアリング」へ登壇の準備をしていた頃、私は「プロンプトエンジニアリング」という用語に対してある種の違和感を抱いていた。この用語は多くの人にとって「チャットボットに何かを入力すること」という浅い理解に留まってしまうからだ。最近、技術界隈では「コンテキストエンジニアリング」という新しい用語が注目されている。これは「LLMでタスクを解決可能にするためのすべてのコンテキストを提供する技芸」であり、私が登壇で伝えたかった本質により近いものだった。実際、産業レベルのLLMアプリケーションでは、タスクの説明、few-shot examples、RAG（Retrieval-Augmented Generation）、関連データ、ツール、状態、履歴など、膨大な情報を適切に組み合わせる必要がある。これはまさに「コンテキストの設計」に他ならない。www.philschmid.desimonwillison.net小説創作におけるコンテキストの実践私が小説創作でAIを使う際に最も苦労したのは、この「コンテキストの設計」であった。単純に「感動的なシーンを書いて」と指示するだけでは、後述するような「死んだ」文章しか生成されない。しかし、適切なコンテキストを提供することで、AIの出力は劇的に変化するのである。「魔法のような」AI体験は、適切なタスクに適切なコンテキストを提供することで生まれるのだ。創作においても同様で、以下のような要素を組み合わせる必要がある。キャラクターの背景情報：CHARACTER.mdファイルに記録した詳細なプロフィール、過去の経験、価値観、言葉遣いの特徴。これらは、そのキャラクターが「どのような状況でどのような反応を示すか」という行動パターンの基盤となる。現在の状況とその前後関係：単発のシーンではなく、「なぜこの状況に至ったのか」「この後どうなるのか」という流れの中での位置づけ。AIの「Lost in the Middle現象」を考慮すると、この前後関係の提供が特に重要になる。否定的なコンテキスト：「〜のような展開は避けてほしい」「〜という表現は使わないでほしい」という制約を明示することで、AIの出力をより精密にコントロールできる。重要なのは、「必要な時に必要なものだけを渡す」という情報の最適化である。すべての情報を羅列するのではなく、「今このタスクに最も重要な情報は何か」を常に意識する必要がある。コンテキストエンジニアリングの本質この経験を通じて理解したのは、コンテキストエンジニアリングが単なる技術的な手法ではなく、創作者の思考を明確化する営みであるということだった。AIに何を依頼するかを考える過程で、自分の創作意図を明確化し、読者への配慮を具体化し、物語の構造を客観視することになる。これらはすべて、AIを使わない創作においても重要なスキルである。つまり、コンテキストエンジニアリングの習得は、創作者としての総合的な能力向上につながるのである。従来の「プロンプトエンジニアリング」が「AIに何を言うか」に焦点を当てていたのに対し、「コンテキストエンジニアリング」は「AIが最適な判断を下すために、どのような情報環境を構築するか」という視点を提供する。これは、AIを「指示に従う道具」から「情報を基に判断する協働者」へと捉え直すことを意味している。結果として、AIとの協働は単なる「効率化」を超えて、新しい創作の可能性を開拓する営みへと発展するのである。技術の進歩と共に、我々創作者に求められるのは、より深い思考と、より明確な意図、そしてより豊かな想像力なのかもしれない。エンジニアが作った道具を、創作者がいかに手懐けるか生成AIツールの多くは、悲しいかな、エンジニアによって作られている。論理的な命令を期待し、構造化された入力を前提とし、エラーメッセージも技術用語で埋め尽くされている始末である。しかし、実は「お作法」を少し知るだけで、AIツールは格段に使いやすくなる。例えば、「悲しい場面を書いて」と頼むより、「主人公が大切な人を失った直後の場面を書いて。雨が降っている。主人公は泣いていない」と具体的に指示する。これ「明確な指示」の出し方だ。巷でよく聞かれたのは「なぜAIは私の意図を理解してくれないのか」という質問だった。答えは簡単で、AIは文脈を読む能力が人間より劣るからだ。現状だとそういうような機能がないからだ。だからこそ、エンジニアたちが日常的に使っているような「具体的に書く」という習慣が役立つ。「感動的な場面」ではなく「涙を流しながら笑う場面」と書く。さらに「500文字以内で」といった制約を明示したり、「村上春樹のような文体で」と参考例を示したりすることで、AIの出力は見違えるほど良くなる。 speakerdeck.com最初は「なんでこんな面倒くさいことを」と思うと思う。しかし慣れてくると、この「明確な指示」は創作においても有益だと気づいてもらえると思います。何よりも自分が何を書きたいのか、どんな効果を狙っているのかを言語化する訓練になるのだ。このような技能を身につけた創作者は、AIを自在に操れるようになる。エンジニアの作法を知ることは、新しい筆の使い方を覚えることに他ならないのである。小説創作で見えてきたAIの限界と可能性なぜAI生成の小説は「死んでいる」のか登壇準備において、私は実際に様々な小説を生成させてみた。その結果、強烈な違和感に襲われることとなった。文法は完璧、語彙も豊富、構成も整っている。しかしながら、物語として致命的に「死んでいる」のである。この原因を分析してみると、いくつかの根本的な問題が浮かび上がってきた。まず第一に、AIはすべてを同じ重要度で書いてしまうという悪癖がある。人間が文章を書く際には、無意識のうちに情報の重要度を判断し、メリハリをつけるものだ。重要なシーンは詳しく、そうでない部分は簡潔に。これは物語の基本中の基本である。しかるにAIは、すべてを同じトーンで淡々と出力してしまう。キャラクターの初登場シーンも、日常の何気ない描写も、クライマックスの決戦も、すべて同じ密度で書かれてしまうのだ。これでは読者の感情が動くはずもない。悪文の構造　――機能的な文章とは (ちくま学芸文庫)作者:千早耿一郎筑摩書房Amazon続いて、具体的なイメージの欠如という問題がある。AIは統計的に「ありそうな」文章を生成することには長けているが、具体的なイメージを喚起する描写となると、からきし駄目なのである。試しに状況を設定して「感動的な再会シーン」を書かせてみると、返ってくるのは「長い時を経て、二人は再会した。お互いの顔を見つめ、言葉を失った。感動的な瞬間だった」といった具合である。なんたる空虚さであろうか。どこで再会したのか、何年ぶりなのか、どんな表情をしていたのか、まるで分からない。何よりも感動的な再会のシーンに感動的とか言うな。www.uniqlo.comそして最も深刻なのは、感情の流れが不自然極まりないことである。「私は激怒した。でも彼の笑顔を見るとなぜか許してしまった」などという文章を平然と出力してくる。人間の感情がこんなに単純なわけがあろうか。怒りから許しへの変化には、必ず心理的なプロセスというものがある(ないならない理由がある)。葛藤し、ためらい、そして決断に至る。これらの微妙な心の機微を、AIは出力できないのである。しかし、ここで重要な視点の転換が必要だ。これらの問題は、AIの限界というよりも、我々がAIとどう協働するかという課題なのである。AIの特性を理解し、その限界を創造的に活用する創作者は、かつてない表現の可能性を手にすることができる。実践で発見した「創造的な失敗」の価値しかしながら、悪いことばかりではなかった。登壇準備の過程で、実に興味深い発見があったのである。「内向的だが本の話題では饒舌になる図書館司書」というキャラクター設定を与えたところ、AIが「本について語るときだけ関西弁になる」という解釈をしてきたのだ。最初は「なんじゃそりゃ」と思った。私の意図とはまるで違う。しかし、よくよく考えてみると、これはこれで面白いではないか。緊張がほぐれると地が出る、という人間の特性を、思いがけない形で表現している。私の貧相な想像力では到達し得なかった地点である。三体 (ハヤカワ文庫SF)作者:劉 慈欣早川書房Amazonこのように、AIの「誤解」を単純に修正するのではなく、「なぜそう解釈したのか」を深く考察することで、新しい創造の種が見つかることがある。これは、孤独な創作活動では得られない、実に貴重な刺激なのである。ただし、ここにも重要な前提がある。この「創造的な失敗」を活かせるのは、もともと創作の素養がある者だけなのだ。面白さの基準を持たない者には、AIの珍妙な出力はただの失敗作にしか見えない。結局のところ、AIは使い手の創造性を増幅する装置であって、無から有を生み出す魔法の箱ではないのである。AIは、我々に新しい形の「批評性」を要求しているのかもしれない。単にAIの出力を受け入れるのではなく、それを批判的に検討し、創造的に発展させる。そうした対話的な創作プロセスこそが、AI時代の技芸なのである。制約を創造性に変える妙技登壇で最も伝えたかったメッセージの一つが、「制約は創造性の敵ではない」ということであった。LLMには明確な制約がある。長い文脈を保持できない「Lost in the Middle現象」により、物語の中盤の情報を忘れやすい。複数の矛盾する要求を同時に処理することも苦手で、「優しくて厳しい」といった複雑なキャラクターを描くのが困難である。さらに、人格の内的一貫性を理解できないため、キャラクターの行動に矛盾が生じやすいのである。しかしながら、これらの制約を深く理解し、それを前提とした創作システムを構築することで、新しい可能性が開けてくるのだ。例えば、「Lost in the Middle現象」への対処として、章ごとに独立した構造を採用し、各章の冒頭でキャラクターの核となる設定を再確認する。複雑なキャラクターは段階的に構築し、まず単一の特徴から始めて、徐々に矛盾や葛藤を追加していく。一貫性の問題は、CHARACTER.mdのような外部ファイルで設定を管理し、常に参照できるようにする。これらの工夫は、単なる「対症療法」ではない。むしろ、創作プロセスをより意識的で、構造的なものに変える契機となった。俳句が5-7-5という厳格な制約の中で研ぎ澄まされた表現を生み出すように、AIの制約を創造的に活用することができるのである。実際、AIツールを使いこなす創作者たちは、「より野心的になれる」と口を揃える。かつては一人では手に負えなかった規模の物語も、AIとの協働により実現可能になった。制約があるからこそ、その枠内で最大限の創造性を発揮しようとする。これこそが、新しい時代の創作の醍醐味なのかもしれない。同じ問題、異なる現れ方個人のブログで感じる違和感実のところ、私が最初に生成AIの違和感を感じたのは、小説ではなく技術ブログであった。最近、個人の技術ブログを読んでいると、明らかに生成AIで書かれたと思しき記事に出会うことが増えた。書籍レベルではまだそういった文章に遭遇していないが、個人のブログでは実に顕著である。その特徴たるや、過度に丁寧で教科書的な説明、「〜することができます」「〜となっています」といった定型句の連発、具体的な経験談の欠如、そしてどこかで読んだような一般論の羅列である。構造レベルでは正しく整理されているのだが、内容レベルで「生成AIっぽさ」が滲み出てしまうのである。github.comこれは生成AI自体が悪いのではない。むしろ、AIに丸投げして終わらせてしまう姿勢こそが問題なのだ。AIが生成した「薄い」文章で満足してしまうのか、それとも、そこから一歩踏み込んで、自分の経験と思考を注ぎ込むのか。その選択が、新しい時代の創作者を分けるのかもしれない。nomolk.hatenablog.comなぜ技術ブログでもAIは「薄い」のか技術ブログで価値があるのは、実際に手を動かした者にしか書けない内容である。「公式ドキュメント通りにやったのに動かなくて、3時間悩んだ末に環境変数の設定ミスだと気づいた」という失敗談。「このライブラリ、最初は使いにくいと思ったけど、慣れると手放せなくなった」という使用感の変化。「本番環境でこの実装をしたら、予想外の負荷がかかって大変なことになった」という痛い経験。これらはすべて「失敗」や「試行錯誤」の生々しい記録である。AIには、こうした血の通った経験がない。本当に情報を適当に収集してきてそれをもとに記事を書く。ゆえに、どんなに正確そうな情報を出力しても、薄っぺらく感じるのである。興味深いことに、小説創作で発見した問題点（強弱の欠如、具体性の不在、経験の欠落）は、技術ブログでもまったく同じように現れる。ジャンルは違えども、「読者に価値を提供する」という本質は同じなのだから、当然といえば当然である。しかし希望もある。実際、技術ブログプラットフォームのZennもガイドラインで「生成AIを活用して執筆することは禁止していません。著者の皆さまには、より質の高い記事を執筆するために生成AIを活用してほしい」と明言している。重要なのは、AIを「下書きツール」として活用し、そこに自分の経験をちゃんと肉付けしていくことなのだ。そうした使い方をしている技術者も増えてきた。AIが骨組みを作り、人間が血肉を与える。この協働こそが、新しい時代の文章作成スタイルなのである。プラットフォーム側も理解しているように、問題はAIを使うことではなく、AIに丸投げして雑魚いコンテンツを乱造することなのだ。人間とAIの新しい関係AIは新しい筆であり、書き手は人間登壇の締めくくりで私が強調したのは、AIは新しい種類の筆に過ぎないということであった。いかに優れた筆があろうとも、それだけでは良い作品は生まれないのである。ここで残酷な真実を述べねばならない。生成AIを使っても、面白くない人間は面白い文章を出せないのだ。面白くない人間が何人集まっても面白い物語は生まれない。たまたま面白いものが出ることはあるかもしれないが、それは偶然の産物に過ぎない。なぜなら、AIに何を指示するか、出力されたものから何を選ぶか、それをどう磨き上げるか、すべては使い手の感性と経験に依存するからである。優れた筆を持っても書道の心得がなければ美しい文字は書けないように、AIという高性能な筆を持っても、創作の素養がなければ読者の心を動かす文章は生まれないのである。syu-m-5151.hatenablog.comAIが得意とするのは、大量の選択肢を高速で生成すること、文法的に正しい文章を作ること、構造化された情報を整理すること、そして疲れを知らずに作業を継続することである。まことに便利な道具ではあるが、所詮は道具に過ぎない。一方、人間にしかできないのは、経験に基づいた判断を下すこと、読者との感情的な共感を創出すること、文脈を超えた創造的な飛躍をすること、そして何より「なぜ書くのか」という意味を付与することである。これらは、どんなに技術が進歩しようとも、人間の領分として残り続けるであろう。興味深いことに、現代のテック企業では、プログラマーはすでに「デジタルワーカーのマネージャー」として機能している。検索エンジンやSNSで実際の作業をしているのは、アルゴリズムやプログラムなのだ。同様に、AI時代の創作者も、AIという「デジタル創作者」のマネージャーとなる。単に命令を下すのではなく、創造的な方向性を示し、品質を管理し、最終的な責任を負う。これは、創作者の役割の終わりではなく、新たな始まりなのである。この役割分担を深く理解し、適切に協働することで、一人では到達し得ない創作の境地に踏み込むことができるのである。技芸として身につけるということ生成AIを使った創作は、まさに新しい楽器を習得するようなものである。最初はぎこちなく、思い通りの音が出ない。しかしながら、練習を重ねることで、少しずつ自分の表現ができるようになっていく。重要なのは、AIを魔法の道具だと勘違いしないことである。制約を理解し、その制約の中で最大限の表現を追求する。失敗を恐れず、むしろ失敗から学ぶ。自分の経験と感性を注ぎ込んで、生きた文章に変える。これこそが、私が登壇で伝えたかった「技芸としてのプロンプトエンジニアリング」の真髄なのである。おわりに30分という限られた時間では、技術的な手法の説明に多くの時間を割くことになった。しかしながら、本当に伝えたかったのは、その向こう側にある創作の喜びである。今の生成AIは確かに多くの制約を持っている。しかし、その制約を理解し、創造的に活用することで、新しい物語の形が生まれる。エンジニアが作った道具を、その利便性や限界を理解した上で創作者が使いこなす。その過程で生まれる予想外の発見や、創造的な喜びを目の当たりにできたことは、私にとって大きな収穫であった。何よりも、かつて自分がものづくりをしていた時の感動を思い出させてくれた。今回のハッカソンは、まさにその理想が体現された場だった。「有意義な集まりを開くために最も必要なのは、目的の設定である」という言葉があるが、ここに集まったのはアウトプットへの強烈な渇望を持つオタクたちであり、わずか数時間で次々と作品を生み出していく光景は圧巻であった。参加者たちは、生成AIという新しい道具を前に、恐れることなく手を動かし続けた。「とりあえず試してみよう」「これ面白いかも」「失敗したけど、この部分は使える」——そんな言葉が飛び交う会場は、就活のためでも履歴書に書くためでもなく、創作への純粋な情熱で満ちていた。最高の集い方――記憶に残る体験をデザインする作者:プリヤ・パーカープレジデント社Amazonこれこそがハッカソンという形式の真価である。完成度よりも実験精神を、批評よりも創造を優先する。参加者全員が「作り手」として対等に立ち、失敗を笑い合い、成功を称え合う。そうした瞬間の積み重ねが、新しい創作共同体を形成していくのだ。考えてみれば、オタクとは本来、アウトプットへの衝動を抑えきれない人々のことではなかったか。好きなものについて語り、二次創作し、同人誌を作り、コミケで頒布する。その根底にあるのは「作らずにはいられない」という純粋な欲求である。生成AIは、その欲求を解放する新たな回路となりつつある。技術的なハードルが下がることで、より多くの人が「作り手」として参加できるようになったのだ。思えば、文化や共同体というものは、常に変化し続けるものである。かつて「オタク」と呼ばれた共同体が変質し、消滅したとしても、創作への情熱は形を変えて受け継がれていく。2006年にロフトプラスワンで「オタク・イズ・デッド」が宣言されてから約20年、我々は新しい創作の時代を迎えているのかもしれない(その後の展開もあるが)。誌 「オタク イズ デッド」 岡田斗司夫GENERICAmazonwww.youtube.com経済史学者James Bessenの研究によれば、産業革命時代の織物工場でも同様の現象が起きていた。熟練職人が機械に置き換えられたとき、実は新しい種類の熟練労働者が生まれていたのだ。重要なのは「Learning by doing」、実践を通じて新しい技術を身につけることであった。技術革新と不平等の1000年史　上作者:ダロン アセモグル,サイモン ジョンソン早川書房Amazon技術革新と不平等の1000年史　下作者:ダロン アセモグル,サイモン ジョンソン早川書房Amazonこの洞察は、生成AIと創作の関係にも当てはまる。AIは我々の仕事を奪うのではなく、より高次の創造性に集中できるようにしてくれる。プログラマーがAIと協働して新しいソフトウェアを生み出すように、創作者もAIと協働して新しい物語を紡ぐ。どちらも「新しい筆」を手にした人間が、より野心的なプロジェクトに挑戦できるようになったということなのだ。歴史が示すように、新しい技術が創作を容易にするとき、需要の増加はしばしば雇用の増加につながる。より多くの人が物語を読み、より多くの人が物語を書く。AIは創作者を置き換えるのではなく、創作の可能性を無限に広げてくれるのである。この記事や発表が、生成AIと創作の間で試行錯誤している方々の一助となれば幸いである。小説でも、技術ブログでも、大切なのは「読者に何を伝えたいか」という根本的な問いである。AIはその表現を助けてくれる道具に過ぎない。また、制約は創造性の敵ではない。むしろ、制約を深く理解し、それと対話することで、新しい表現の地平が開けるのである。そして何より重要なのは、新しいツールを恐れずに使い続けることだ。「Learning by doing」の精神で、失敗を恐れずに実践を重ねる者こそが、この新しい時代の創作者となるのである。そして最後に、どうしても伝えておきたいことがある。再三いうがAIという最高級の筆を手にしても、書き手に伝えたいことがなければ、読者の心に響く文章は生まれない。技術の進歩は創作を爆発させるが、同時に「なぜ書くのか」「何を伝えたいのか」という根本的な問いをより鮮明に浮かび上がらせる。生成AIは、面白くない人間を面白くはしてくれない。それは、我々自身が面白くなる努力から逃れる言い訳にはならないのである。本記事は、2025年6月29日の「#女オタ生成AIハッカソン 2025 夏の陣@東京」での登壇内容を踏まえ、イベントでの発見や登壇では話せなかった内容を中心に書き下ろしたものです。登壇準備の過程で作成したai-story-forgeというプロジェクトも公開しています。実際のプロンプトテンプレートやワークフローの実装例として、参考にしていただければ幸いです。ご意見・ご感想は @nwiizoまでお寄せください。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Gemini Code Assist for GitHubでPrisma ORMのデータモデリングをレビューする]]></title>
            <link>https://sreake.com/blog/gemini-code-assist-prisma-review/</link>
            <guid>https://sreake.com/blog/gemini-code-assist-prisma-review/</guid>
            <pubDate>Mon, 30 Jun 2025 06:59:22 GMT</pubDate>
            <content:encoded><![CDATA[一般的にデータベースの変更はアプリケーションの変更に比べると影響が大きく、慎重な対応が求められます。またcreatedAtのデフォルト値など、実行タイミングにより値が変動する設定をし忘れた場合、元の値を復元することは困難 […]The post Gemini Code Assist for GitHubでPrisma ORMのデータモデリングをレビューする first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイク所属のエンジニアが「2025 Japan All AWS Certifications Engineers」に選出]]></title>
            <link>https://sreake.com/blog/2025-japan-all-aws-certifications-engineers/</link>
            <guid>https://sreake.com/blog/2025-japan-all-aws-certifications-engineers/</guid>
            <pubDate>Mon, 30 Jun 2025 01:00:00 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）は、スリーシェイク所属のエンジニア鈴木 勝史が、「2025 Japan All AWS Certifications Engineers」に選出されたことをお知らせします。The post スリーシェイク所属のエンジニアが「2025 Japan All AWS Certifications Engineers」に選出 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：scc]]></title>
            <link>https://zenn.dev/akasan/articles/841dcbd5c409d5</link>
            <guid>https://zenn.dev/akasan/articles/841dcbd5c409d5</guid>
            <pubDate>Sun, 29 Jun 2025 08:31:50 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ記念すべき第10回目は、sccというコマンドを紹介します。どのような種類のファイルがどれくらいの行数で記述されているかなどを取得できるコマンドとなっています。なお、第9回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/facccc0169d83b sccとは？sccとは公式GitHubによると、A tool similar to cloc, sloccount and tokei. For counting the lines of code, blank lines, commen...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[生成AIで小説を書くためにプロンプトの制約や原則について学ぶ / prompt-engineering-for-ai-fiction ]]></title>
            <link>https://speakerdeck.com/nwiizo/prompt-engineering-for-ai-fiction</link>
            <guid>https://speakerdeck.com/nwiizo/prompt-engineering-for-ai-fiction</guid>
            <pubDate>Sun, 29 Jun 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[諸君、聞かれよ。本日、私は「女オタ生成AIハッカソン2025夏東京」なる前代未聞の催しにて、生まれて初めて登壇することと相成った。かつての私は純朴なプログラマーであり、「変数名を30分悩んだ挙句、結局tmpにする」という、実に平凡な悩みを抱える程度の技術者であったのだ。歳月は容赦なく流れ、今や私はプロンプトエンジニアリングという名の魔境に足を踏み入れた哀れな求道者となり果てた。昨夜も丑三つ時まで、私は薄暗い書斎でディスプレイの冷たき光に照らされながら、「なぜ生成AIは『簡潔に』と百回唱えても、源氏物語の長文を生成するのか」という哲学的難題と格闘していたのである。30分という持ち時間に対し50枚のスライドを用意するという、まるで賽の河原で石を積む如き徒労に及んでいる。そのうち半分は「プロンプトという名の現代呪術における失敗例集」と題した、私の苦悩の結晶である。ああ、AIとの対話とは、かくも人間の正気を奪うものなのか。---ブログも書いた。生成AIで物語を書くためにプロンプトの制約や原則について学ぶ、という話をしてきました #女オタ生成AI部https://syu-m-5151.hatenablog.com/entry/2025/06/30/171149]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：terminalizer]]></title>
            <link>https://zenn.dev/akasan/articles/facccc0169d83b</link>
            <guid>https://zenn.dev/akasan/articles/facccc0169d83b</guid>
            <pubDate>Sat, 28 Jun 2025 06:45:37 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第9回目は、terminalizerというコマンドを紹介します。ターミナルでの作業を録画し、GIFアニメーションを作成するためのツールです。なお、第8回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/0bcf36a4251a96 terminalizerとは？terminalizerとは公式の説明によると、Record your terminal and generate animated gif images or share a web player link www.termi...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Ollamaを使ってみた]]></title>
            <link>https://zenn.dev/akasan/articles/389d6234af1c9c</link>
            <guid>https://zenn.dev/akasan/articles/389d6234af1c9c</guid>
            <pubDate>Fri, 27 Jun 2025 13:28:45 GMT</pubDate>
            <content:encoded><![CDATA[今回はLLMをローカルで動かすためのツールであるOllamaを使ってみました。 Ollamaとは？公式サイトは以下になっており、GitHubも提供されています。Ollamaを使うとローカルでLLMを動かせるようになるため、メモリは結構消費しますが、高速に推論させることができます。https://ollama.com/https://github.com/ollama/ollama 対応モデル一覧記事執筆時点では以下のページで公開されており、様々なモデルが提供されています。代表的なモデルは以下でしょうか。deepseek-r1gemma3qwen3llama3...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Snowflakeで始めるリージョン間データ共有]]></title>
            <link>https://sreake.com/blog/inter-region-data-sharing-with-snowflake/</link>
            <guid>https://sreake.com/blog/inter-region-data-sharing-with-snowflake/</guid>
            <pubDate>Fri, 27 Jun 2025 10:08:28 GMT</pubDate>
            <content:encoded><![CDATA[はじめに 組織内のSnowflakeアカウント同士で安全にリージョン間データ共有をするなら、LIST機能のOrganizational listingsを使うのが非常におすすめです。 この記事ではSnowflakeがサポ […]The post Snowflakeで始めるリージョン間データ共有 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[論文紹介：『Commercial LLM Agents Are Already Vulnerable to Simple Yet Dangerous Attacks』]]></title>
            <link>https://sreake.com/blog/commercial-llm-agents-are-already-vulnerable-to-simple-yet-dangerous-attacks/</link>
            <guid>https://sreake.com/blog/commercial-llm-agents-are-already-vulnerable-to-simple-yet-dangerous-attacks/</guid>
            <pubDate>Fri, 27 Jun 2025 07:55:50 GMT</pubDate>
            <content:encoded><![CDATA[今回は、LLMエージェントシステムの脆弱性に関して述べられている論文の紹介をさせていただきます。3-shakeではさまざまな勉強会が開かれており、今回紹介する論文も勉強会で取り上げた題材となっています。エージェントシステ […]The post 論文紹介：『Commercial LLM Agents Are Already Vulnerable to Simple Yet Dangerous Attacks』 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Terraformを使ってVPC内のCloud Runサービス間で通信させる]]></title>
            <link>https://qiita.com/aminevg/items/4912c95b795c6739d703</link>
            <guid>https://qiita.com/aminevg/items/4912c95b795c6739d703</guid>
            <pubDate>Fri, 27 Jun 2025 07:26:55 GMT</pubDate>
            <content:encoded><![CDATA[背景Cloud Runはサーバーレスでコンテナを動かせる便利なサービスですが、複数のサービスを連携させようとすると、ネットワーク構成で悩むことがあります。例えば、フロントエンドは一般公開し、バックエンドは内部ネットワークからのみアクセス可能にしたい場合VPC内の...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AI にどんなコードを書かれても大丈夫！DevContainer+mise で築く「壊されても安心でユニバーサル」な開発環境]]></title>
            <link>https://sreake.com/blog/safe-universal-dev-env-with-devcontainer-mise/</link>
            <guid>https://sreake.com/blog/safe-universal-dev-env-with-devcontainer-mise/</guid>
            <pubDate>Thu, 26 Jun 2025 13:16:14 GMT</pubDate>
            <content:encoded><![CDATA[はじめに：生成 AI 時代の新たな悩み 「ChatGPT、このバグを直して！」 「GitHub Copilot、この機能を実装して！」 そんなふうに生成 AI に頼んでコードを書いてもらったら、気づいたら開発環境がぐちゃ […]The post AI にどんなコードを書かれても大丈夫！DevContainer+mise で築く「壊されても安心でユニバーサル」な開発環境 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Claude CodeのSlash Commandsで日報を作成する]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/26/220245</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/26/220245</guid>
            <pubDate>Thu, 26 Jun 2025 13:02:45 GMT</pubDate>
            <content:encoded><![CDATA[〜日報をサボってしまう人のための解決策〜日報、めんどくさいよね正直に言います。日報書くの、めんどくさいですよね。僕も毎日終業時に「あれ、今日何やったっけ...」ってなって、GitHubでクローズしたIssue探したり、Slackでミーティングの議事録掘り返したり、Jiraのチケット確認したり...。正確に書こうとすると、気づいたら15分とか経ってるんですよね。しかも、やっと書き終わったと思ったら「あ、そういえば午前中にあのバグ直したの書き忘れた」「レビューで指摘もらった内容も書かなきゃ」みたいなことがしょっちゅう。正直、この作業が苦痛すぎて、サボっちゃう日もありました。「明日まとめて書けばいいや」って思って、結局3日分まとめて書く羽目になったり...（そして当然、細かいことは忘れてる）。でも最近、Claude Codeのカスタムslash commandsを使い始めてから、この苦行から解放されたんです。作業しながらサクッと記録できるようになって、もう日報をサボることがなくなりました。今回は、僕が実際に使ってる日報システムを紹介します。このブログが良ければ読者になったり、nwiizoのXやGithubをフォロワーしてくれると嬉しいです。では、早速はじめていきます。Claude Codeのslash commandsって何？Claude Codeには、よく使うプロンプトをコマンド化できる機能があるんです。簡単に言うと、Markdownファイルを特定のフォルダに置くだけで、オリジナルコマンドが作れちゃいます。この機能について詳しく知りたい人は、こちらの記事がめちゃくちゃ参考になります()。syu-m-5151.hatenablog.comカスタムコマンドの仕組みから活用法、トラブルシューティングまで網羅的にまとまってて、僕も参考にさせてもらってます。特に、v1.0.25でプレフィックスが不要になったとか、frontmatterでdescription書く方法とか、知らなかったTipsがたくさんありました。で、今回はこの機能を使って日報を楽にする方法を紹介します。# こんな感じで使える/nippo-add バグ直した！僕の日報の悩みと解決策フィードバックと内省は成長に欠かせない要素です。頭では理解していても、いざ日報を書くとなると腰が重くなってしまう。「成長したい」という願望と「面倒くさい」という本音の狭間で揺れ動く——そんな矛盾を私自身も抱えています。 speakerdeck.comBefore：苦痛すぎてサボる悪循環終業時に「さて、日報書くか...」と思っても、GitHubで今日クローズしたIssueを探すSlackでミーティングの議事録を掘り返すJiraでチケットのステータス確認「あれ、午前中何してたっけ...」と記憶を辿るやっと書き始める書いてる途中で「そういえば...」と思い出して追記この作業が苦痛すぎて、つい「今日はいいや...」ってサボっちゃうんですよね。で、翌日になると、昨日の記憶があいまい「えーと、昨日の分も書かなきゃ...」さらに苦痛度アップまた今日もサボる最悪のときは3日分まとめて書く羽目に。当然、細かいことは全部忘れてて、「Issue対応しました」みたいな雑な日報になっちゃう。After：作業中にポチポチ記録Claude Codeで作業してる最中に/nippo-add バグ#123修正完了。nullチェック忘れてた。恥ずかしい...これだけ！後でAIが整形してくれるから、とりあえず記録しとけばOK。何が変わったか、その場で記録するから苦痛じゃないIssue番号もその場で記録するから探さなくていい感情も新鮮なうちに残せる/nippo-finalize で自動整形もうサボらない！（これが一番大きい）（今だけの可能性すらある）でも、日報を書く心理的ハードルがめちゃくちゃ下がりました。実際に作った3つのコマンド僕が使ってるのは、たった3つのコマンドです。実は本当はもっと詳しく作り込んでて、プロジェクト固有の処理とか、社内のテンプレートに合わせた出力とか入れてるんですが、汎用的に使えそうな部分だけ抜き出して紹介します。これでも十分使えるはず！1. /nippo-add - とにかく記録作業中に思いついたことを何でも突っ込みます。.claude/commands/nippo-add.md（またはホームディレクトリの~/.claude/commands/nippo-add.md）に以下の内容を保存：# 日報に追記する現在の日報ファイル（/tmp/nippo.$(date +%Y-%m-%d).md）に以下の内容を追記してください。## 追記する内容: $ARGUMENTSまず、日報ファイルが存在するか確認し、存在しない場合は新規作成してください。### 新規作成の場合のテンプレート:---markdown# 日報 $(date +%Y年%m月%d日)## 📝 作業ログ### $(date +%H:%M) - 初回記録$ARGUMENTS---## 🎯 今日の目標- [ ] （後で記入）## 📊 進捗状況（セッション終了時に記入）## 💡 学びと気づき（随時追記）## 🚀 明日への申し送り（本日終了時に記入）---### 既存ファイルへの追記の場合:1. 「## 📝 作業ログ」セクションを探す2. そのセクションの最後に以下の形式で追記:--markdown### $(date +%H:%M) - $ARGUMENTS の要約（20文字以内）$ARGUMENTS---### 特別な処理:- もし `$ARGUMENTS` に「振り返り:」が含まれる場合は、「## 💡 学びと気づき」セクションに追記- もし `$ARGUMENTS` に「明日:」が含まれる場合は、「## 🚀 明日への申し送り」セクションに追記- もし `$ARGUMENTS` に「目標達成:」が含まれる場合は、「## 🎯 今日の目標」セクションの該当項目にチェックを入れるポイントは、「振り返り:」とか「明日:」ってキーワードをつけると、自動的に適切なセクションに振り分けてくれること。これ、地味に便利。あと、Issue番号とかPR番号も一緒に書いておけば、後で「あれどのIssueだっけ？」ってGitHub探し回らなくて済みます。2. /nippo-finalize - AIに仕上げてもらう終業時に実行すると、散らかった作業ログから、ちゃんとした日報を作ってくれます：# 日報を完成させる本日の日報（/tmp/nippo.$(date +%Y-%m-%d).md）を完成させます。## 実行内容:1. **進捗状況の集計**   - 作業ログから本日の活動を分析   - 達成した項目と未達成の項目を整理2. **各セクションの補完**   - 空欄になっているセクションを埋める   - 作業ログから重要なポイントを抽出[以下省略...]これがすごいのは、書き忘れた「よかったこと」とか「改善点」を、作業ログから勝手に抽出してくれるところ。「あー、そういえばそれも書かなきゃ」みたいなのがなくなりました。3. /nippo-show - 確認用単純に今日の日報を表示。週次サマリーも見れます。実際の1日の流れ朝イチ$ /nippo-add スタンドアップ終了。今日は#456と#457に取り組む。#456から着手午前中のコーディング$ /nippo-add #456 実装開始。思ったより複雑...$ /nippo-add うーん、原因がわからん。デバッガで追ってみる$ /nippo-add やった！原因判明。非同期処理のタイミングの問題だった$ /nippo-add 振り返り: async/awaitの理解が甘かった。MDN読み直そうPRレビュー$ /nippo-add PR #234 レビュー完了。セキュリティ的な懸念点を指摘$ /nippo-add 自分のPR #235 もレビュー依頼出した昼休み後$ /nippo-add 定例MTG: スプリントの進捗確認。予定通り進んでることを報告$ /nippo-add 田中さんに相談したら一瞬で解決策を教えてくれた。さすが...$ /nippo-add #456 修正完了！テストも全部通った！PR作成 → #789夕方$ /nippo-add PR #789 にレビューコメントもらった。明日対応する$ /nippo-add 明日: #789のレビュー対応、#457の実装、ドキュメント更新$ /nippo-finalizeたったこれだけ！その場その場で記録するから、もうGitHubとSlackを行ったり来たりする必要なし。個人用コマンドとして設定する方法さっきのスクショにあるように、~/.claude/commands/に置けば、どのプロジェクトでも使えるようになります。これがめちゃくちゃ便利。# ホームディレクトリに個人用コマンドを作成mkdir -p ~/.claude/commandscd ~/.claude/commands# 3つのファイルを作成touch nippo-add.md nippo-finalize.md nippo-show.mdあとは上記の内容をコピペすれば完了！これの何が良いかって：- 会社のプロジェクトでも個人プロジェクトでも同じコマンド- プロジェクト切り替えても日報は一つ（/tmp/nippo-YYYY-MM-DD.mdに統一）- 複数プロジェクトまたいで作業した日も、一つの日報にまとまる実際、僕は午前中は会社のプロジェクト、午後は個人のOSS開発とかやることもあるんですが、全部一つの日報にまとまるから管理が楽です。使ってみて分かったコツ1. Issue番号やPR番号も一緒に記録後で見返すとき、めちゃくちゃ便利です。/nippo-add #456 修正完了。レビュー待ち/nippo-add PR #789 のレビュー対応完了。CIも通った！2. 恥ずかしがらずに感情も記録# これだと味気ない/nippo-add バグ修正完了# 感情も入れると後で読み返して楽しい/nippo-add バグ修正完了！3時間も悩んだけど解決してスッキリ！3. ミーティングの要点もその場でミーティング終わったら、議事録作る前にサクッと：/nippo-add 定例MTG: 来週のリリース内容確認。自分は認証機能を担当/nippo-add 振り返り: スプリントの振り返りで工数見積もりの甘さを指摘された。次は1.5倍で見積もる4. 失敗も正直に書く完璧な日報より、失敗も含めた正直な日報の方が、後で振り返ったときに学びが多いです。/nippo-add やらかした...本番DBに接続してた。幸い読み取りだけだったけど冷や汗/nippo-add 振り返り: 環境変数の確認を怠った。チェックリスト作ろう5. 細かいことでも記録「これくらい書かなくてもいいか」と思うようなことも、意外と後で役立ちます。/nippo-add VS Codeの新しい拡張機能試した。Error Lensめっちゃ便利/nippo-add TypeScriptのバージョン上げたらビルド時間が20%短縮されたトラブルシューティング「コマンドが認識されない！」僕も最初これでハマりました。原因は大体：- ファイルの拡張子が.mdじゃない（.txtにしちゃってた）- ファイル名にスペース入れちゃってる- Claude Code再起動し忘れ「$ARGUMENTSが展開されない」これも罠。$ARGUMENTSは完全一致じゃないとダメです。$arguments（小文字）とか${ARGUMENTS}（波括弧付き）は動きません。もっと自動化できるけど？究極的にはnippo-addすら自動化できるっちゃできるんですよね⋯。実際、僕も「PR作成したら自動で日報に追記」みたいなの試してみたことあります。でも結局、感情とか気づきは自分で書きたいんですよね。「やった！」とか「これハマった...」みたいな。だから今は、技術的には自動化できる部分も、あえて手動で /nippo-add してます。その方が振り返りの質が高くなる気がして。でも、チームや人によっては完全自動化もアリかも。特に定型的な作業が多いチームとか。このへんは好みと文化次第ですね。まとめ正直、このシステムを使い始めてから、日報を書くのが苦じゃなくなりました。むしろ、1日の成果を振り返るのが楽しみになってる自分がいます。一番の変化は、Before: 日報書くの面倒 → サボる → 翌日もっと面倒 → またサボる（悪循環）After: その場で記録 → 苦痛じゃない → 毎日続く → 習慣になる（好循環）特に良いのは、記憶が新鮮なうちに記録できる（Issue番号も間違えない）感情も含めて残せる（これ重要）AIが整形してくれるから、雑に書いてもOK毎日の成長が見える化される何より、サボらなくなった！(今だけだとしても)もし「日報めんどくさい...」「つい後回しにしちゃう...」「3日分まとめて書いてる...」って人がいたら、ぜひ試してみてください。最初の設定は10分もかからないし、その後の精神的な楽さを考えたら、圧倒的にコスパ良いです。あと、チームで使うとさらに面白いです。みんなの「振り返り」を読むと、「あー、そこで悩んでたのか」とか「その解決方法は思いつかなかった」とか、学びが多いんですよね。日報を「苦痛な義務」から「成長ツール」に変える。Claude Codeのslash commandsなら、それができます。Happy Logging! 🚀P.S. この記事書いてて思ったけど、ブログも/blog-addみたいなコマンド作ったら楽になりそう...今度やってみよう。というか日報をというお題からあなたの問題を解決するヒントを得てください。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GKEでFastAPIサーバを公開してみた]]></title>
            <link>https://zenn.dev/akasan/articles/6618da4fe05367</link>
            <guid>https://zenn.dev/akasan/articles/6618da4fe05367</guid>
            <pubDate>Thu, 26 Jun 2025 12:51:30 GMT</pubDate>
            <content:encoded><![CDATA[今回はkubernetesの練習を兼ねて、FastAPIサーバをGKE上にデプロイしてみました。 GKEへのFastAPIサーバのデプロイ システム構成今回はレプリカ数を1としてFastAPIサーバをGKE上で構築します。ロードバランサーサービスを利用して外部公開しました。 Google Cloudの設定ここではプロジェクトは作成済みであるとします。まず、Dockerイメージを保管するためのArtifact Registryを作成します。gcloud artifacts repositories create fastapi-repo --repository-fo...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Gemini cli が出たっぽいので cloud run deploy までやってみるぞ]]></title>
            <link>https://zenn.dev/satohjohn/articles/4d205e445714cf</link>
            <guid>https://zenn.dev/satohjohn/articles/4d205e445714cf</guid>
            <pubDate>Wed, 25 Jun 2025 16:15:27 GMT</pubDate>
            <content:encoded><![CDATA[概要Gemini cli ってのが出ました。https://github.com/google-gemini/gemini-cli基本的には Gemini code assist をローカルでも使えるようなイメージを感じています。（間違ってたらすいません)https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/30分程度とりま調べた限りでまとめます。無料という言葉に人間は弱いのだよ。 表題の通りやってみる。とりま npm -g でインストールしたら ge...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[PyEnchantを使ってスペルチェックをしてみた]]></title>
            <link>https://zenn.dev/akasan/articles/09c84177fc5884</link>
            <guid>https://zenn.dev/akasan/articles/09c84177fc5884</guid>
            <pubDate>Wed, 25 Jun 2025 14:11:47 GMT</pubDate>
            <content:encoded><![CDATA[今回はPyEnchantを使って英語のスペルチェックをしてみました。 PyEnchantとは？公式GitHubによると、Enchantは単語のスペルをチェックし、スペルミスがある場合は修正候補を提示するライブラリのようです。ispell、aspell、MySpellなど、多くの一般的なスペルチェックパッケージに対応しており、複数の辞書や言語に対応できる柔軟性も備えています。例えばHeloと入力した時にHelloじゃないですか？と提示してくれるイメージです。ユースケースとしては、例えば英語を対象とした言語モデルを作るときに、存在していない単語を学習に利用しないために、不正確な単語が...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Claude Code の .claude/commands/**.md は設定した方がいい]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/25/062736</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/25/062736</guid>
            <pubDate>Tue, 24 Jun 2025 21:27:36 GMT</pubDate>
            <content:encoded><![CDATA[はじめにClaude Code でよく同じコメントを打ってませんか？「毎回『テスト実行して、lint チェックして、問題なければコミットして』って言うの面倒だな」とか「プロジェクトごとに決まった手順があるんだけど、毎回説明するのダルい」とか思ったことないですか？そんなあなたに朗報です。Claude Code にはカスタムスラッシュコマンドという機能があって、よく使うプロンプトをコマンド化できるんです。しかも設定は超簡単。Markdownファイルを置くだけ。手順書やMakefileが自然言語で書ける時代ですね⋯。docs.anthropic.com正直なところ、この機能を知ったときは「え、こんな便利な機能あったの？」って感じでした。公式ドキュメントをちゃんと読んでない自分を殴りたくなりました。というか書くって言って書いてはいてかなり前なのにいろいろやることがあって公開は遅れました。人生とは難しいものです。というわけで今回は、.claude/commands/**.md の設定方法と、実際に私が使っている設定を紹介します。あなたの開発効率が爆上がりすること間違いなしです。このブログが良ければ読者になったり、nwiizoのXやGithubをフォロワーしてくれると嬉しいです。では、早速はじめていきます。はじめにカスタムスラッシュコマンドとは何か2種類のコマンドスコープとプレフィックスフリーな呼び出しなぜカスタムコマンドが必要なのか1. 一貫性の担保と再現性2. チーム開発での標準化とオンボーディング3. 複雑な作業の自動化と時間節約4. 引数による柔軟性と再利用性5. プロンプトのバージョン管理6. コンテキストとベストプラクティスの埋め込み7. エラー処理とロールバックの自動化基本的な使い方ステップ1：ディレクトリ作成ステップ2：コマンドファイル作成ステップ3：実行サンプル集：プロに学ぶコマンド設計プロフェッショナルなコマンドテンプレート集Sphinxドキュメント自動化の実例私の例1. 複雑なビルドプロセスの自動化2. セキュリティチェック3. リリース準備高度な活用法ネームスペースの活用Orchestratorパターンコマンド作成のベストプラクティス1. 明確で具体的に2. エラーハンドリングを明記3. 出力フォーマットを指定4. コンテキストを含める実際のRustプロジェクト用コマンド例知っておくと便利なTipsGit管理についてコマンドの長さと複雑さ命名の競合についてコマンドの説明を追加するトラブルシューティングコマンドが認識されない時引数が正しく渡されない時ファイルの権限問題まとめ参考リンク📣 アップデート情報（v1.0.25）/project:や/user:というプレフィックスが必要でしたが、v1.0.25からはプレフィックス不要で直接コマンド名を入力できるようになりました。また、コマンド検出の安定性も向上しています。謝辞:検証のタイミングと公開のタイミングがズレた為ぬこぬこさんがアップデート情報を教えてくれました。ありがとうございます。カスタムスラッシュコマンドとは何かまず基本から。Claude Code には元々いくつかのビルトインコマンドがあります。/help     # ヘルプを表示/clear    # 会話履歴をクリア/memory   # CLAUDE.mdを編集/cost     # トークン使用量を確認/mcp      # MCP関連（v1.0.24で改善）これらに加えて、自分でコマンドを定義できるのがカスタムスラッシュコマンドです。仕組みは簡単で、.claude/commands/ ディレクトリにMarkdownファイルを置くとファイル名がコマンド名になり、ファイルの中身がプロンプトとして使われます。例えば、.claude/commands/test-and-commit.md というファイルを作れば、/test-and-commit というコマンドが使えるようになります。v1.0.25での表示形式：コマンドを入力すると、以下のような形式で候補が表示されます：/test-and-commit     Test and Commit (project)コマンド名の後に、Markdownファイルの最初の見出し（# Test and Commit）が説明として表示され、最後の (project) はプロジェクトスコープのコマンドであることを示します。2種類のコマンドスコープとプレフィックスフリーな呼び出しカスタムコマンドには2つのスコープがあります。プロジェクトコマンド（推奨）は .claude/commands/ に配置し、プロジェクト固有の作業に使います。チームで共有でき、表示形式は /command-name     Command Description (project) となります。個人コマンドは ~/.claude/commands/ に配置し、全プロジェクトで使う個人的なコマンドに適しています。表示形式は /command-name     Command Description (user) となります。v1.0.25以降の呼び出し方法：# 新しい方法（v1.0.25以降）/test-and-commit# 従来の方法（後方互換性のため引き続き使用可能）/project:test-and-commit  # プロジェクトコマンド/user:test-and-commit     # 個人コマンドv1.0.25のアップデートにより、どちらのスコープのコマンドもプレフィックスなしで呼び出せるようになりました。同名のコマンドが複数のスコープに存在する場合は、プロジェクトコマンドが優先されます。明示的にスコープを指定したい場合は、従来通りプレフィックスを使用することも可能です。私は基本的にプロジェクトコマンドを使ってます。Gitで管理できるし、チームメンバーと共有できるから。なぜカスタムコマンドが必要なのか「プロンプトをコピペすればいいじゃん」と思うかもしれません。そう思ってた時期が僕にもありました。でも実際に使ってみると、カスタムコマンドには大きなメリットがあります。1. 一貫性の担保と再現性毎回微妙に違うプロンプトを打つと、AIの挙動も微妙に変わります。カスタムコマンドなら、常に同じプロンプトが実行されるので、結果が安定します。実例：# 悪い例（毎回微妙に違う）"テスト実行して問題なければコミットして""テストを走らせてからコミットお願い""test実行→コミット"# 良い例（カスタムコマンド）/test-and-commit# → 常に同じ手順で、同じ品質チェックが実行される特に、AIモデルがアップデートされても、コマンドの指示が明確なので動作が安定します。2. チーム開発での標準化とオンボーディング「PRを作るときはこの手順で」「デプロイ前にはこのチェックを」みたいなチームのルールを、コマンドとして標準化できます。新しいメンバーが入ってきても、コマンドを実行するだけでOK。具体的な効果：新人の立ち上がり時間: 2週間 → 2日レビュー指摘の減少: 「lint忘れてます」「テスト回してください」がゼロにドキュメント不要: コマンド自体が生きたドキュメント# 新人でも初日から正しい手順でPRが作れる/create-pr feature/user-authentication3. 複雑な作業の自動化と時間節約長いプロンプトや、複数ステップの作業をワンコマンドで実行できます。私の場合、「テスト→lint→型チェック→コミット」という一連の流れを1つのコマンドにまとめてます。時間節約の実例：手動の場合（毎回入力）:- プロンプト入力: 30秒- 指示の修正や追加: 20秒- 合計: 50秒 × 1日20回 = 約17分/日カスタムコマンドの場合:- コマンド入力: 3秒- 節約時間: 47秒 × 20回 = 約16分/日- 年間節約時間: 約64時間！4. 引数による柔軟性と再利用性$ARGUMENTS プレースホルダーを使えば、動的な値を渡せます。同じコマンドを様々な状況で使い回せます。# コンポーネント作成/create-component Button/create-component Modal/create-component Card# API エンドポイント作成/create-api users GET/create-api products POST/create-api orders DELETE5. プロンプトのバージョン管理カスタムコマンドはGitで管理できるので、プロンプトの改善履歴が追跡できます。# プロンプトの改善が見える化されるgit log .claude/commands/test-and-commit.md# チームでプロンプトを改善git checkout -b improve-test-command# コマンドを編集git commit -m "feat: add performance test to test-and-commit command"6. コンテキストとベストプラクティスの埋め込みプロジェクト固有の知識や制約をコマンドに埋め込めます。# プロジェクト固有の知識を含むコマンド例This is a Next.js 14 project using:- App Router (not Pages Router)- Server Components by default- Tailwind CSS for styling- Prisma for database- Our custom design system components from @/components/ui/Always consider these when implementing features.7. エラー処理とロールバックの自動化手動だと忘れがちなエラー処理も、コマンドに組み込んでおけば安心です。If any test fails:1. Run the failed test in isolation with verbose output2. Check if it's a flaky test (run 3 times)3. If consistently failing, rollback any changes made4. Generate an error report with:   - Failed test name and file   - Error message and stack trace   - Git diff of changes madeこれらのメリットを一度体験すると、もうカスタムコマンドなしの開発には戻れません。最初の設定に10分かけるだけで、その後の開発効率が劇的に向上します。基本的な使い方では、実際にカスタムコマンドを作ってみましょう。ステップ1：ディレクトリ作成mkdir -p .claude/commandsステップ2：コマンドファイル作成例として、テストを実行してからコミットするコマンドを作ります。.claude/commands/test-and-commit.md:# Test and CommitPlease follow these steps:1. Run all tests using `npm test`2. If tests pass, check for linting issues with `npm run lint`3. If both pass, create a commit with a descriptive message4. Show me the test results and commit hashMake sure to stop if any step fails and show me the error.ポイント：- ファイルの最初の見出し（# Test and Commit）がコマンドの説明として表示されます- この説明は、コマンド選択時に /test-and-commit     Test and Commit (project) のような形で表示されます- 分かりやすい見出しを付けることで、コマンドの用途が一目で分かるようになりますステップ3：実行# v1.0.25以降（推奨）/test-and-commit# 従来の方法（引き続き使用可能）/project:test-and-commitたったこれだけ！簡単でしょ？サンプル集：プロに学ぶコマンド設計まず、素晴らしいサンプルリポジトリを紹介します。プロフェッショナルなコマンドテンプレート集Claude-Command-Suiteは、ソフトウェア開発のベストプラクティスに基づいた、包括的なカスタムコマンドのコレクションです。主要なコマンド：コードレビュー系/code-review - 包括的なコード品質評価/architecture-review - システムアーキテクチャ分析/security-audit - セキュリティ脆弱性評価/performance-audit - パフォーマンスボトルネック特定開発ワークフロー系/create-feature - 機能開発の全工程を自動化/fix-issue - GitHub issue解決ワークフロー/refactor-code - 安全なリファクタリング/debug-error - 体系的なデバッグアプローチこれらのコマンドは、Anthropic公式のベストプラクティスに準拠しており、そのまま使えるクオリティです。インストールもinstall.sh が配備されております。Sphinxドキュメント自動化の実例drillerさんの記事では、Sphinxを使ったドキュメント生成を自動化する実践的な例が紹介されています。3つのコマンドでドキュメント管理を完全自動化：/sphinx-create - プロジェクト初期化/sphinx-update - 設定更新/sphinx-build - ドキュメントビルド特に素晴らしいのは、複雑なSphinxの設定を.claude/docs/config/に外部化している点。これにより、Sphinxを知らない人でも簡単にドキュメントを生成できます。私の例私が実際に使っているコマンドもいくつか紹介します。ccswarmというプロジェクトで使ってるものです。1. 複雑なビルドプロセスの自動化.claude/commands/build-all.md:# Build All TargetsBuild all components of the ccswarm project in the correct order:1. Clean previous builds: `rm -rf dist/`2. Build shared libraries first3. Build main application4. Build plugins5. Run integration tests6. Generate build reportShow progress for each step and summarize any warnings or errors at the end.このコマンドで、複雑な依存関係があるプロジェクトでも、正しい順序でビルドできます。2. セキュリティチェック.claude/commands/security-check.md:# Security AuditPerform a comprehensive security check:1. Run `npm audit` and analyze vulnerabilities2. Check for exposed secrets using git-secrets3. Scan for common security anti-patterns in the code4. Review authentication and authorization logic5. Generate a security report with recommendationsFocus on critical and high severity issues first.定期的なセキュリティチェックも、コマンド一発で実行できます。3. リリース準備.claude/commands/prepare-release.md:# Prepare ReleasePrepare for a new release with version: $ARGUMENTSSteps:1. Update version in package.json2. Generate CHANGELOG.md from git commits3. Run full test suite4. Build production bundle5. Create git tag6. Generate release notesIf any step fails, rollback changes and notify me.使用例：# v1.0.25以降/prepare-release v1.2.0# 従来の方法/project:prepare-release v1.2.0高度な活用法ネームスペースの活用サブディレクトリを使えば、コマンドを整理できます：.claude/commands/├── frontend/│   ├── component.md      # /component (project:frontend)│   └── style-check.md    # /style-check (project:frontend)├── backend/│   ├── migration.md      # /migration (project:backend)│   └── api-test.md       # /api-test (project:backend)└── deploy/    ├── staging.md        # /staging (project:deploy)    └── production.md     # /production (project:deploy)v1.0.25での変更点：- サブディレクトリ内のコマンドもファイル名だけで呼び出せるようになりました- コマンド候補の表示形式：    /component        Create Component (project:frontend)  /style-check      Style Check (project:frontend)  /migration        Database Migration (project:backend) - Markdownファイルの最初の見出しが説明として表示されます- 括弧内にディレクトリ構造が表示され、どこに配置されているか一目で分かります同名のコマンドが複数のディレクトリにある場合の動作：- すべての候補が表示され、選択できます- 例：frontend/test.md と backend/test.md がある場合、/test と入力すると両方が候補として表示されます大規模プロジェクトでは、この構造化が本当に役立ちます。ディレクトリで論理的に整理しつつ、シンプルなコマンド名で呼び出せるベストな仕組みです。Orchestratorパターンmizchiさんの記事で紹介されている、複雑なタスクを分解実行するパターンも超便利です。.claude/commands/orchestrator.md:# OrchestratorSplit complex tasks into sequential steps, where each step can contain multiple parallel subtasks.[詳細な実装は長いので省略]これを使うと、「分析→並列実行→結果統合」みたいな複雑なワークフローも自動化できます。コマンド作成のベストプラクティス使ってみてこんなふうにするとみたいなやつです。1. 明確で具体的に# 悪い例Do the usual checks and commit# 良い例（Rustプロジェクトの場合）1. Run `cargo test` and ensure all tests pass2. Run `cargo clippy -- -D warnings` and fix any lints3. Run `cargo fmt --check` for formatting validation4. Run `cargo check` for compilation errors5. If all pass, commit with conventional commit format2. エラーハンドリングを明記If any step fails:- Stop execution immediately- Show the full error message with cargo's verbose output- For test failures, show the specific test name and assertion- For clippy warnings, provide the lint name and suggested fix- Do NOT proceed to the next step3. 出力フォーマットを指定After completion, provide a summary in this format:- Tests: ✅ Passed (42/42)- Clippy: ✅ No warnings- Format: ✅ Properly formatted- Build: ✅ Clean compilation- Commit: abc123 - feat: add new parser module4. コンテキストを含めるThis is a Rust project using:- Rust 2021 edition- Clippy with pedantic lints enabled- cargo-nextest for parallel test execution- Conventional commits- workspace with multiple cratesKeep these constraints in mind when executing commands.この辺はプロンプトエンジニアリングの原則に近いです。生成AIのプロンプトエンジニアリング ―信頼できる生成AIの出力を得るための普遍的な入力の原則作者:James Phoenix,Mike Taylor,田村 広平（監訳）,大野 真一朗（監訳）,砂長谷 健（翻訳）,土井 健（翻訳）,大貫 峻平（翻訳）,石山 将成（翻訳）オライリージャパンAmazon実際のRustプロジェクト用コマンド例Rustのベストプラクティスに基づいた、より実践的なコマンドを紹介します：.claude/commands/rust-check-all.md:# Comprehensive Rust CheckPerform a complete quality check for this Rust project using modern best practices.## Environment checkFirst, check for optimal tooling:- Verify cargo-nextest is installed (suggest installation if missing)- Check for cargo-audit availability- Confirm clippy and rustfmt are available## Pre-flight checks1. **Working directory status**   - Run `git status --porcelain` to check for uncommitted changes   - If changes exist, list them clearly   - Ensure we're on the correct branch2. **Dependency status**   - Run `cargo tree --duplicate` to find duplicate dependencies   - Check for outdated dependencies with `cargo outdated` if available   - Note any security advisories## Quality checks sequence1. **Fast syntax check**   - Run `cargo check --all-targets --all-features`   - This is the fastest way to catch compilation errors   - Stop immediately if this fails2. **Format check**   - Run `cargo fmt --all -- --check`   - If formatting issues found:     - Show diff of required changes     - Offer to fix automatically with `cargo fmt --all`3. **Clippy analysis (progressive)**   First, standard lints:   - Run `cargo clippy --all-targets --all-features -- -D warnings`      If user requests pedantic mode:   - Run `cargo clippy --all-targets --all-features -- -W clippy::pedantic`   - Group warnings by category (style, complexity, performance, etc.)   - For each warning, show:     - File and line number     - The specific lint rule     - A brief explanation of why it matters4. **Test execution (optimized)**   Check for cargo-nextest first:   - If available: `cargo nextest run --all-features`     - Benefits: Faster execution, better output, automatic retry support   - If not available: `cargo test --all-features`      For test failures:   - Show test name and module path   - Display assertion failure details   - Include relevant source code snippet   - If using nextest, note any flaky tests (passed on retry)5. **Documentation check**   - Run `cargo doc --no-deps --all-features --document-private-items`   - Check for broken intra-doc links   - Verify all public APIs have documentation   - Run doctests: `cargo test --doc`6. **Benchmarks** (if present)   - Check for benches with `cargo bench --no-run`   - If benchmarks exist, offer to run them7. **Security audit**   If cargo-audit is installed:   - Run `cargo audit --deny warnings`   - Group vulnerabilities by severity   - Provide upgrade recommendations## Advanced checks (optional)8. **Build optimization check**   - Analyze Cargo.toml for optimization opportunities   - Check if release profile is properly configured   - Look for unnecessary features being compiled9. **Code coverage** (if requested)   - Check for cargo-tarpaulin or cargo-llvm-cov   - Offer to generate coverage report## Summary formatAfter all checks complete, provide a comprehensive summary:---🦀 Rust Project Quality Report================================📊 Project: {name} v{version}Checks Summary:📋 Syntax:       ✅ Clean📐 Format:       ✅ Properly formatted🔍 Clippy:       ⚠️  3 warnings (2 style, 1 complexity)🧪 Tests:        ✅ 156/156 passed (4.2s)📚 Docs:         ✅ 100% documented🔒 Security:     ✅ No known vulnerabilities⚡ Performance:  ℹ️  Consider enabling lto in releaseClippy Warnings Summary:- redundant_closure_for_method_calls (2 occurrences)- unnecessary_wraps (1 occurrence)Test Performance:- Fastest: test_parse_simple (12ms)- Slowest: integration::test_full_workflow (823ms)- Total duration: 4.2s (with nextest parallelization)Recommendations:1. Address clippy warnings for cleaner code2. Consider splitting slow integration tests3. Enable link-time optimization for release buildsReady to commit! Suggested message:"test: improve parser coverage and fix edge cases"---## Error handling- If any critical check fails (syntax, tests, security):  - Stop execution and focus on that issue  - Provide specific fix suggestions  - Offer relevant documentation links- For non-critical issues (style, some clippy warnings):  - Continue checking but note them in summary  - Prioritize fixes by impact## Performance tips- Use `cargo check` before `cargo build`- Leverage cargo-nextest for 30-60% faster test runs- Consider `sccache` for faster rebuilds- Use `--jobs` flag for parallel compilationこのコマンドは、cargo-nextestという高速なテストランナーや、Clippyのpedanticモードなどのより厳格なリントを活用しています。また、セキュリティ監査や依存関係のチェックなど、実際のプロジェクトで必要な包括的なチェックを含んでいます。知っておくと便利なTipsGit管理についてコマンドファイルは必ずGitに含めるべきです。.claude/commands/ はプロジェクトの一部として管理することで、チーム全体で同じワークフローを共有できます。これがカスタムコマンドの大きなメリットの一つです。個人的な設定が必要な場合は、~/.claude/commands/ に個人用コマンドを配置するか、.gitignore に特定のコマンドを追加する方法があります。例えば、個人的なデバッグ用コマンドなどは共有する必要がないかもしれません。コマンドの長さと複雑さMarkdownファイルなので、必要なだけ詳細に書くことができます。1000行のコマンドでも問題なく動作します。ただし、あまりに複雑になってきた場合は、複数のコマンドに分割することを検討してください。保守性を考えると、1つのコマンドは1つの明確な目的を持つべきです。命名の競合についてv1.0.25以降、プレフィックスが不要になったことで、ビルトインコマンドとの名前の競合に注意が必要です。ただし、カスタムコマンドがビルトインコマンドと同名の場合でも、ビルトインコマンドが優先されるため、システムが壊れることはありません。プロジェクトコマンドと個人コマンドで同名のものがある場合、プロジェクトコマンドが優先されます。明示的にスコープを指定したい場合は、従来通りプレフィックスを使用できます：/user:build    # 個人コマンドを明示的に指定/project:build # プロジェクトコマンドを明示的に指定コマンドの説明を追加する@budougumi0617さんに教えていただいた便利な機能があります。Markdownファイルの先頭にfrontmatterを記述することで、コマンド一覧により詳細な説明を表示できます。使い方：---description: "プロジェクトの全コンポーネントを正しい順序でビルドし、テストを実行します"---# Build All TargetsBuild all components of the ccswarm project in the correct order:[以下、コマンドの内容]表示例：/build-all     Build All Targets - プロジェクトの全コンポーネントを正しい順序でビルドし、テストを実行します (project)このように、frontmatterのdescriptionフィールドに記載した内容が、コマンド候補の一覧に表示されます。これにより、標準のスラッシュコマンドのように、コマンドを選択する前にその用途を詳しく確認できます。特に複数の似たようなコマンドがある場合、この説明があることで適切なコマンドを素早く選択できるようになります。チーム開発では、新しいメンバーがコマンドの用途を理解しやすくなるという利点もあります。mdにfrontmatterでdescription書いておくと、一覧表示したときに標準スラッシュコマンドのように概要が表示されるので便利でした！https://t.co/8WNTEZQK0L— Yoichiro Shimizu (@budougumi0617) 2025年6月25日   トラブルシューティングコマンドが認識されない時まず確認すべきは、ファイルの拡張子が.mdになっているかどうかです。.markdownや.txtでは認識されません。また、ファイル名に特殊文字（スペースや日本語など）が含まれていると問題が起きることがあります。v1.0.25ではコマンド検出の安定性が改善されているため、以前よりも認識の問題は少なくなっています。それでも認識されない場合は、Claude Codeを再起動してみてください。引数が正しく渡されない時$ARGUMENTSプレースホルダーは完全一致である必要があります。$arguments（小文字）${ARGUMENTS}（ブレース付き）$ARGS（省略形）これらはすべて動作しません。必ず$ARGUMENTSと記述してください。ファイルの権限問題ファイルの読み取り権限が必要です。コンテナなどの別権限で実行する時に頭の片隅にあると良いかもですがこれすらもClaude Codeが解決してくれそうな気もしますので忘れてもよいです。chmod 644 .claude/commands/*.mdまとめClaude Codeのカスタムコマンドは、設定が簡単なのに効果は絶大です。そしてv1.0.25のアップデートでさらに使いやすくなりました。特に重要なポイントとして、Markdownファイルを置くだけで使えるという手軽さがあります。v1.0.25からプレフィックス不要で呼び出せるようになり、プロジェクト固有の作業を標準化できるため、チーム開発での一貫性を保てます。さらに、複雑な作業も1コマンドで実行可能になり、コマンド検出の安定性が向上しました。まだ設定してない人は、今すぐ.claude/commands/ディレクトリを作って、よく使うプロンプトをコマンド化してみてください。きっと「なんで今まで使ってなかったんだろう」って思うはずです。私も最初は「まあ、そのうち設定すればいいか」と思ってました。でも一度使い始めたら、もう元には戻れません。開発効率が文字通り爆上がりします。そして、良いコマンドができたらぜひ共有してください。Claude-Command-Suiteのようなリポジトリが増えれば、みんなの開発がもっと楽になるはずです。最新のClaude Codeを使って、より快適な開発体験を手に入れましょう！参考リンクClaude Code Slash Commands 公式ドキュメントClaude-Command-Suite - プロフェッショナルなコマンドテンプレート集Claude Codeのカスタムスラッシュコマンドでドキュメント作成を効率化するClaude Code 版 Orchestrator で複雑なタスクをステップ実行する私のプロジェクト例 (ccswarm)Claude Code CLI UsageClaude Code Memory Management]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Apache Rollerとはなんなのか？]]></title>
            <link>https://zenn.dev/akasan/articles/ae458c49fb7c76</link>
            <guid>https://zenn.dev/akasan/articles/ae458c49fb7c76</guid>
            <pubDate>Tue, 24 Jun 2025 11:57:02 GMT</pubDate>
            <content:encoded><![CDATA[今回はApache Rollerについて調べてみました。 今回も以下のツールを使って対象プロジェクトを決めました！https://zenn.dev/akasan/articles/7e30ad266c02c4※ 本企画に関する記事の目的は、それぞれのプロジェクトを本格的に深ぼるのではなく、プロジェクト名⇆どんな内容かをパッと思い出せるようにすることを目指します！※ とはいえ深ぼってみたいプロジェクトがあればどんどん複数連載になると思います。 Apache Rollerとは？公式ページによると、Apache Roller is a Java-based, full-feat...]]></content:encoded>
        </item>
    </channel>
</rss>