<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Tue, 25 Jul 2023 18:30:37 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[YugabyteDBのドキュメントを全部読む Day1]]></title>
            <link>https://nnaka2992.hatenablog.com/entry/reading_yugabytedb_docs_1</link>
            <guid>https://nnaka2992.hatenablog.com/entry/reading_yugabytedb_docs_1</guid>
            <pubDate>Tue, 25 Jul 2023 15:01:52 GMT</pubDate>
            <content:encoded><![CDATA[Day1最近Twitter改めXで「俺はDBのドキュメント端から端まで読んで強くなった」というX's1を複数みかけました。周りのエンジニアに一歩差をつける方法として、フレームワークやミドルウェアやライブラリのドキュメントを最初から最後までちゃんと読む、というのがあって、これはマジでコスパ抜群です。— 徳永広夢 (@tokuhirom) July 21, 2023 確かに私のRedisはこれ。 https://t.co/2y1E01aLGw— maru (@maruloop) July 22, 2023 私のMySQLもこれ。 https://t.co/BxiOjeQVPk— yoku0825 (@yoku0825) July 22, 2023 俺のpostgresqlもこれ。 https://t.co/URRjyXCpGI— そーだい@初代ALF (@soudai1025) July 22, 2023 PostgreSQL系NewSQLで最強になりたいのでYugabyteDBのドキュメントを順番に読んで行きます。ドキュメントはv2.19に対応したものです。手始めにArchitectureの一番先頭にあるDesign goalsから読みはじめます。Design goalsYugabyteDBは以下を達成することを目標としている。1. 分散トランザクションを提供しながら強い一貫性を保証する。2. Query APIを再発明せず、既存のクエリ言語への互換を達成する。3. 高いパフォーマンスを保証する。4. 地理的に分散したデプロイを可能にする。5. Cloud Native Databaseとしてデザインする。一貫性分断耐性YugabyteDBはCAPの定理で言えばCPを中心に高い可用性を供えたデータベースネットワーク分断などを起因とするSplit BrainはRaft Group内であたらしいリーダーを選出することで対応している。YugabyteDBではLeader Leaseという障害が発生しても常に一つのリーダが存在することを保証する仕組みを実装している。直列化可能性single-row Linearizable writeをサポートしている。ACIDトランザクションYugabyteDBではSeriarizable、Repetable Read、Read Committed Isolationの三つの分離レベルをサポートしている。YSQL APIではこれら3つの分離レベルをサポートしているが、YCQLではRepeatable Readのみに対応している。Query APIYugabyteDBではYSQLとYCQLという2種類のQuery APIをサポートしている。YSQLYSQLはPostgreSQLに互換したAPIでPostgreSQLのクエリレイヤを再利用している。新しい変更は互換性を崩さない。YSQLは新しいPostgreSQLに互換しつづけることを目標としている。YCQLYCQLはCassandraのクエイ言語から派生した半リレーショナルなクエリ言語で、Webスケールな膨大なwriteに対応してスケールし素早いデータ取得を目標としている。パフォーマンスC++で実装されているため高いパフォーマンスと巨大なHeap(RAM)をCacheとして利用できる。SSDとNVMeに最適化している。高いWriteスループットとクライアントの同時実行性、高いデータ密度、増加し続けるデータへの対応を目標としている。地理的分散Zone、Multi Region、Multi Cloudいずれにも対応している。これに対応するために、ノード障害やトラヒックのルーティングなどに対応できる必要がある。クラウドネイティブアーキテクチャパブリッククラウドやオンプレミスで利用される一般てきなハードウェアで利用可能にする。原子時計のような特別なものに依存しない。Kubernatesに対応している。OSSで提供している。https://twitter.com/SawyerMerritt/status/1683365478582951936↩]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Terraformでmapにkeyが含まれないときにスキップしたい]]></title>
            <link>https://zenn.dev/nnaka2992/articles/skip_when_key_does_not_exists_in_map_terraform</link>
            <guid>https://zenn.dev/nnaka2992/articles/skip_when_key_does_not_exists_in_map_terraform</guid>
            <pubDate>Sat, 22 Jul 2023 14:53:12 GMT</pubDate>
            <content:encoded><![CDATA[Google CloudではPublic IPを利用した際に割り振られる可能性のあるCIDRの一覧がcloud.jsonでJSON形式で公開されています。この記事は雑な検証用のTerraformで承認済みネットワークにasia-notheast1のCIDRを全部登録してやろうとしたとき、上記のJSONファイルからscopeがasia-northeast1のprefixes.ipv4Prefixを抜きだそうとしたときにハマったのでその対応方法のメモです 結論以下のような感じで書いたら対応できました。contains(keys(hoge), "fuga") # hogeのkeyにh...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Four Keys とは？考え方から導入まで徹底検証してみた]]></title>
            <link>https://sreake.com/blog/learn-about-four-keys/</link>
            <guid>https://sreake.com/blog/learn-about-four-keys/</guid>
            <pubDate>Fri, 21 Jul 2023 09:56:19 GMT</pubDate>
            <content:encoded><![CDATA[はじめに Sreake事業部でインターンをしている村山です。私は以前に、2022年のAccelerate State of DevOps Reportについて調査を行いました。DevOps Reportでは、Four K […]The post Four Keys とは？考え方から導入まで徹底検証してみた first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Kubernetes の upstream のキャッチアップ]]></title>
            <link>https://zenn.dev/toversus/articles/52b107ab103712</link>
            <guid>https://zenn.dev/toversus/articles/52b107ab103712</guid>
            <pubDate>Thu, 20 Jul 2023 10:18:32 GMT</pubDate>
            <content:encoded><![CDATA[先日、Kubernetes Meetup Tokyo #59 で「KEP から眺める Kubernetes」というタイトルで発表しました。発表の後で Kubernetes の upstream のキャッチアップ方法について質問を受けました。その場で回答はしたのですが、ちょうど社内の共有会で似たような話をしたところだったので、加筆修正したものを公開しておきます。 はじめにKubernetes の upstream を追いかけ始めて 1 年ちょっと経ったので、その経験をまとめます。Kubernetes の upstream やエコシステムを観察しているだけで、コントリビュータではありま...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CLIの実行結果を正しく理解することを促すツールを作成しました。]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2023/07/19/162657</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2023/07/19/162657</guid>
            <pubDate>Wed, 19 Jul 2023 07:26:57 GMT</pubDate>
            <content:encoded><![CDATA[概要AIの技術は目覚ましい進歩を遂げています。特に自然言語処理（NLP）の分野では、GPT-4のようなモデルが人間に近いレベルで文章を理解し、生成することができるようになりました。しかし、これらのモデルを日々の業務や作業にどのように活用すればよいのか、多くの人々がまだ手探りの状態です。一方、コマンドラインは、システム管理者やソフトウェア開発者にとって重要なツールです。コマンドラインからシステムの状態を調べたり、プログラムを実行したりするためには、これらで利用するコマンドの理解とそれらを十分に使いこなすことが必要です。netflixtechblog.comアフィリエイトでも何でもなく運用で利用するコマンドについてはLinuCなどもあるので教材を読むだけでもおすすめしたい。linuc.orgでは、AIがコマンドプロンプトの結果を理解し、それを人間がより理解しやすい形で説明することができたら、どうでしょうか？ここで、AICommandを紹介します。AICommandは、コマンドプロンプトの実行とその結果の解釈を統合したツールであり、AIの力を借りてコマンドプロンプトの結果を理解する新しい試みです。今回の記事では、このAICommandについて詳しく見ていきましょう。シェルコマンドの実行とその結果をOpenAIのGPTモデルに結果を送信し解説を要求するGo製CLIツールです。コマンドの処理状況も視覚的に表示します。 pic.twitter.com/5q6jqyWbsx— nwiizo (@nwiizo) 2023年7月18日  AICommandの紹介AICommandは、コマンドプロンプトの結果を人間が理解しやすい形に解釈するための新しいツールです。OpenAIの強力な自然言語処理モデルを使用して、コマンドラインから得られた情報を詳細に解析し、その結果を説明します。これにより、複雑なコマンドの実行結果も、非専門家でも簡単に理解できるようになります。github.comコマンドプロンプトは非常に強力で、システムの管理やデータの分析には欠かせないツールですが、その結果を正しく理解するには専門知識が必要で、学習コストが高いという課題がありました。しかし、AICommandを使えば、そのハードルが大きく下がります。たとえば、システムのログを確認するためのコマンドを実行した結果を、AIが解釈し、重要なポイントをハイライトしてくれます。さらに、その結果がどういう意味を持つのか、何が原因でそうなったのかといった情報も提供してくれます。このように、AICommandは、AIの能力を利用して、コマンドプロンプトの利用をより手軽で、より理解しやすいものに変えることを目指しています。ソフトウェア開発者やシステム管理者だけでなく、コマンドラインを利用するすべての人々にとって、新たな可能性を広げるツールとなることを目指します。option で日本語にも対応してます。 pic.twitter.com/AkEHh5syPx— nwiizo (@nwiizo) 2023年7月19日  Setup 🔧AICommandはGo言語で書かれているため、Goの開発環境が必要です。まず、Goがまだインストールされていない場合は、公式のインストールガイドに従ってGoをインストールしてください。Install aicommandGoがインストールされたら、次にAICommandをインストールします。go install github.com/nwiizo/aicommand@latestSet the your_api_keyAICommandはOpenAIのGPTモデルを使用しますので、OpenAIのAPIキーが必要となります。OpenAIのアカウントを持っていてAPIキーを取得済みの場合は、そのAPIキーを使用します。まだAPIキーを取得していない場合は、OpenAIの公式ドキュメントを参照してAPIキーを取得してください。APIキーを取得したら、そのキーを環境変数 OPENAI_API_KEYに設定します。設定方法は以下の通りです：export OPENAI_API_KEY=your_api_keyUsage ⏳コマンドの実行とその結果の解釈を行うには、次のように execute コマンドに続けて実行したいコマンドを引数として与えます。コマンドは(ダブル)クオーテーションで囲む必要があります。aicommand execute "your-shell-command"たとえば、ディレクトリの内容をリストする ls -la コマンドの結果を解釈させたい場合は、次のように実行します。aicommand execute "ls -la"すると、AICommandは ls -la コマンドを実行し、その結果を解釈して人間が理解しやすい形で説明します。また、解釈結果の言語を指定したい場合は、 --language または-lオプションを使用します。現在、英語（en）と日本語（ja）がサポートされています。デフォルトの言語は英語です。aicommand execute --language ja "ls -la"さらに、使用するGPTモデルを指定することも可能です。これは --model または -m オプションで指定します。デフォルトは gpt-3.5-turbo です。aicommand execute --model gpt-3.5-turbo "ls -la"これでAICommandの基本的な使用方法について説明しました。コマンドプロンプトの結果の解釈がこれまで以上に手軽になり、より深い理解が可能になります。AICommandの可能性🤖AICommandは、私たちが普段利用しているコマンドプロンプトをOpenAIのGPTモデルと組み合わせることで新たな可能性を生み出します。たとえば、複雑なコマンドを実行した結果の意味を理解することが困難な場合や、ログの解析、データ分析などで結果をより深く理解するための手助けとなります。また、様々なプログラムやスクリプトの実行結果を人間が理解できる形で説明してくれるため、デバッグやエラー解析の作業を効率化することが可能です。AICommandを利用すれば、テクニカルな知識がなくてもコマンドラインから得られる情報を理解しやすくなるかもしれません。結論🦾AICommandは、AIとCLI（Command Line Interface）の架け橋となるツールであり、この2つの強力なテクノロジーを組み合わせることで、未知の課題に対して新たな視点を提供します。さまざまなバックグラウンドを持つユーザーがコマンドラインから得られる情報をより容易に理解できるようになることで、これまで手が出せなかった問題に取り組む手助けをしてくれるでしょう。しかし、その一方で、AICommandはコマンドプロンプトの出力を人間が理解できる形で解釈するツールであるため、その解釈は絶対的な真実を表すものではありません。AICommandの解釈結果は参考の一つと考え、最終的な意思決定はユーザー自身の判断に任せるべきです。以上のことを念頭に置いて、AICommandを活用すれば、新たな視点からコマンドラインの世界を探索することが可能になるでしょう。ソフトウェア開発にChatGPTは使えるのか？――設計からコーディングまでAIの限界を探る作者:小野 哲技術評論社AmazonCloudNative Days Fukuoka 2023 にて登壇余談なのですが"k8sgpt Deep Dive: KubernetesクラスタのAI駆動型分析について” というタイトルで登壇を行います。event.cloudnativedays.jp参考AI時代に向けたクラウドにおける信頼性エンジニアリングの未来構想 / DICOMO2022 6A-1AICommand GitHubリポジトリOpenAIsashabaranov/go-openai]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[成熟度モデルを活用したCloud Nativeへの道筋 という副題で登壇します #開発生産性con_findy]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2023/07/13/131433</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2023/07/13/131433</guid>
            <pubDate>Thu, 13 Jul 2023 04:14:33 GMT</pubDate>
            <content:encoded><![CDATA[概要開発生産性Conferenceというイベントに『Cloud Native の作法 - 成熟度モデルを活用したCloud Nativeへの道筋』というタイトルで登壇しました。生産性に関するイベントなんですけど現場のエンジニアをやっている僕には開発生産性について語ることってあんまりないようなーって思いながら最近、成熟度モデルについて調べていたのでこのタイトルにしました。途中で開発生産性について語るのを諦めてガッツリ資料を作り直しましたので生暖かく見守ってください。あと、ちょっと前に書籍を送って頂きましたが📖 Twitter での告知を忘れていたのでしておきます。読んだ感想としては入門書では決してないですが成熟度モデルでいうとレベル2の段階では読んでほしいと思う書籍になります。また、豊富にドキュメントへのリンクが貼ってあるのでKubernetesという荒野に道を示す地図になると思います(この文章はChatGPTではなく俺が生成した)。Kubernetesの知識地図 —— 現場での基礎から本番運用まで作者:青山 真也,小竹 智士,長谷川 誠,川部 勝也,岩井 佑樹,杉浦 智基技術評論社Amazon資料登壇資料になります。このブログの目的は参考資料をいちいち探さなくていいようにありますのでご活用ください。 speakerdeck.com参考文献Cloud Native Maturity ModelCloud Native TransformationDesign Patterns for Cloud Native ApplicationsIntro to the Cloud Native Maturity Model - Danielle Cook, Simon Forster, Robbie Glenn & John FormanSRE サイトリライアビリティエンジニアリングが”ザックリ”「すっきり」分かる本: Googleが実践している新DevOps方法論SRE サイトリライアビリティエンジニアリングサイトリライアビリティワークブックCloud Native成熟度モデルがWeb公開されましたWhat's the Difference Between DevOps and SRE?Solving Reliability Fears with Site Reliability EngineeringReliability When Everything Is a Platform: Why You Need to SRE Your CustomersThe History of DevOps ReportsEffective DevOpsPlatform Engineeringへの招待Platform Team と 社内政治 〜 出でよ、Platform Champion 〜 / Platform Team and Internal Politics - Platform Engineering Meetup #2Platform Engineering at MercariEMPOWERED 普通のチームが並外れた製品を生み出すプロダクトリーダーシッププロダクトマネジメントのすべて 事業戦略・IT開発・UXデザイン・マーケティングからチーム・組織運営まで正しいものを正しくつくる　プロダクトをつくるとはどういうことなのか、あるいはアジャイルのその先についてエンジニアリング組織論への招待　～不確実性に向き合う思考と組織のリファクタリング]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[OpenAI APIを利用してパブリッククラウドの権限要約をしてくれるCLIコマンドを作成した]]></title>
            <link>https://sreake.com/blog/summarize-permission-with-openai/</link>
            <guid>https://sreake.com/blog/summarize-permission-with-openai/</guid>
            <pubDate>Tue, 11 Jul 2023 07:01:52 GMT</pubDate>
            <content:encoded><![CDATA[はじめに Sreake事業部の橋本です。前回の記事から引き続き、OpenAIのGPTモデルを利用してDevOps、SREの領域でのtext AIの有効活用を考えていきます。 運用の自動化、構築支援などに活用できると嬉しい […]The post OpenAI APIを利用してパブリッククラウドの権限要約をしてくれるCLIコマンドを作成した first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[メールが届いたら Google Home で音声で通知する]]></title>
            <link>https://blog.1q77.com/2023/07/ses-lambda-and-cloud-pubsub/</link>
            <guid>https://blog.1q77.com/2023/07/ses-lambda-and-cloud-pubsub/</guid>
            <pubDate>Mon, 10 Jul 2023 14:25:35 GMT</pubDate>
            <content:encoded><![CDATA[以前、「 LINE に送ったメッセージを Google Home に読み上げさせる」という記事を書きました。 その時に作ったものに家にあるラズパイで Cloud PubSub を subscribe してメッセージが届いたらその内容を Text-to-Speach で]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[【Terraform🧑‍🚀】tfstateファイル分割パターンとディレクトリー構成設計]]></title>
            <link>https://hiroki-hasegawa.hatenablog.jp/entry/2023/07/05/001756</link>
            <guid>https://hiroki-hasegawa.hatenablog.jp/entry/2023/07/05/001756</guid>
            <pubDate>Tue, 04 Jul 2023 15:17:56 GMT</pubDate>
            <content:encoded><![CDATA[この記事から得られる知識01. はじめに02. なぜ tfstate ファイルを分割するのか分割していない場合分割している場合03. tfstate ファイルの分割分割の境目状態の依存関係図依存関係図とは依存関係の表現▼ 依存関係の表現記法▼ 依存関係がない場合▼ 依存関係がある場合04. tfstate ファイルに基づくその他の設計リポジトリ 🏭 の設計リポジトリ分割ディレクトリー 📂 構成リモートバックエンド 🪣 の設計リモートバックエンド分割ディレクトリー構成05. 状態の依存関係の定義方法terraform_remote_stateブロックの場合terraform_remote_stateブロックによる依存状態の依存関係図リポジトリのディレクトリー構成リモートバックエンドのディレクトリー構成AWSリソース別のdataブロックの場合AWSリソース別のdataブロックによる依存状態の依存関係図リポジトリのディレクトリー構成リモートバックエンドのディレクトリー構成06. tfstate ファイルの分割パターン概要ディレクトリー構成との関係についてリポジトリの場合リモートバックエンドの場合07. 上層の分割 (必須)上層の分割についてプロバイダーのアカウント別この分割方法について【プロバイダーアカウント別】状態の依存関係図【プロバイダーアカウント別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合▼ 同じリポジトリの場合【プロバイダーアカウント別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合▼ 同じリモートバックエンドの場合08. 下層の分割 (必須)下層の分割について実行環境別この分割方法について【実行環境別】状態の依存関係図【実行環境別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合▼ 同じリポジトリの場合【実行環境別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合▼ 同じリモートバックエンド x AWSアカウント別に異なる実行環境 の場合▼ 同じリモートバックエンド x 単一のAWSアカウント内に全ての実行環境 の場合09. 中間層の分割 (任意)中間層の分割について同じテナントのプロダクト別この分割方法について【同じテナントのプロダクト別】状態の依存関係図【同じテナントのプロダクト別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合▼ 同じリポジトリの場合【同じテナントのプロダクト別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合▼ 同じリモートバックエンドの場合運用チーム責務範囲別この分割方法について【チーム別】状態の依存関係図【チーム別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合▼ 同じリポジトリの場合【チーム別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合▼ 同じリモートバックエンドの場合プロダクトのサブコンポーネント別この分割方法について【サブコンポーネント別】状態の依存関係図【サブコンポーネント別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合▼ 同じリポジトリの場合【サブコンポーネント別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合▼ 同じリモートバックエンドの場合AWSリソースの種類グループ別この分割方法について【種類グループ別】状態の依存関係図【種類グループ別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合▼ 同じリポジトリの場合【種類グループ別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合▼ 同じリモートバックエンドの場合AWSリソースの状態の変更頻度グループ別この分割方法について【変更頻度グループ別】状態の依存関係図【変更頻度グループ別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合▼ 同じリポジトリの場合【変更頻度グループ別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合▼ 同じリモートバックエンドの場合運用チーム責務範囲別 × プロダクトサブコンポーネント別この分割方法について【チーム別 × サブコンポーネント別】状態の依存関係図【チーム別 × サブコンポーネント別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合▼ 同じリポジトリの場合【チーム別 × サブコンポーネント別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合▼ 同じリモートバックエンドの場合10. おわりに謝辞この記事から得られる知識この記事を読むと、以下を "完全に理解" できます✌️Terraformのtfstateファイルを分割する目的と、分割パターンについて (AWS向け)Terraformのリポジトリやリモートバックエンドのディレクトリー構成の設計について01. はじめに前世でもう少し徳を積んでいれば、Mitchell Hashimoto として生まれることができたのに!!さて最近の業務で、全プロダクトの技術基盤開発チームに携わっており、チームが使っているTerraform🧑🏻‍🚀のリポジトリをリプレイスする作業を担当しました。このリポジトリでは単一のtfstateファイルが状態を持ち過ぎている課題を抱えていたため、課題に合った適切な分割パターンでリプレイスしました。今回は、この時に整理した分割パターン (AWS向け) を記事で解説しました。もちろん、GoogleCloudやAzureでも読み換えていただければ、同じように適用できます。知る限りの分割パターンを記載したところ、文量がエグいことになってしまったので、気になる分割パターンだけ拾って帰っていただけると嬉しいです🙏それでは、もりもり布教していきます😗02. なぜ tfstate ファイルを分割するのか%%{init: { 'theme': "default", 'themeVariables': { 'commitLabelFontSize': '13px' }}}%%gitGraph   commit id: "8c8e6"   commit id: "0e3c3"     branch feature/foo     checkout feature/foo     commit id: "4e9e8"     commit id: "fooさんがApply"   checkout main     branch feature/bar     commit id: "barさんがPlan"   checkout main   commit id: "e74d6"     branch feature/baz     commit id: "bazさんがPlan"分割していない場合そもそも、なぜtfstateファイルを分割する必要があるのでしょうか。tfstateファイルを分割しなかったと仮定します。様々なインフラコンポーネントを単一のtfstateファイルで状態を持つ場合、1回のterraformコマンド全てのコンポーネントの状態を操作できて楽です。ただし、複数の作業ブランチがある状況だと煩わしいことが起こります。各作業ブランチでインフラコンポーネントの状態を変更しかけていると、terraformコマンドでtargetオプションが必要になります。分割している場合一方で、tfstateファイルをいい感じに分割したと仮定します。各作業ブランチでは、まるで暗黙的にtargetオプションがついたように、他の作業ブランチの影響を受けずにterraformコマンドを実行できます。よって、各tfstateファイルを操作できる管理者は互いに影響を受けずに、terraformコマンドの結果を得られるようになります。Terraform: Up & Running: Writing Infrastructure As CodeOrganizing With Multiple States - DevOps with Terraform - CloudCasts03. tfstate ファイルの分割分割の境目それでは、tfstateファイルの分割の境界はどのようにして見つければよいのでしょうか。これを見つけるコツは、他の状態にできるだけ依存しないリソースの関係 に注目することだと考えています。ここでいう依存とは、tfstateファイルが他のtfstateファイルの状態を使用することです。tfstateファイルの分割パターンについては後述します。アーキテクチャの文脈では、他を使用することを『依存』と表現します。そのため便宜上、tfstateファイルでも同じ用語で表現することにしました。@tmknom さんが述べている通り、Terraformをよりよく設計するためには、『ソフトウェアの基礎知識』が必要です👍状態の依存関係図依存関係図とは分割したtfstateファイル間の状態の依存関係を表現した図です。プロバイダーのアカウントの状態をtfstateファイルで管理していることを想像してみてください。%%{init:{'theme':'default'}}%%flowchart TB    subgraph AWSアカウント        foo["tfstateファイル"]    end似たものとしてterraform graphコマンドによるグラフがありますが、これはリソース間の依存関係図です。tfstateファイル間で相互に依存関係があるからといって、個別のリソース間で循環参照が起こってしまうというわけではないです。続いて、依存関係がある場合と無い場合で、どのような依存関係図になるかを紹介していきます。Command: graph | Terraform | HashiCorp Developer依存関係の表現▼ 依存関係の表現記法tfstateファイル間で状態の依存関係がある場合、これを図で表現すると分割の状況がわかりやすくなります。『依存』は、---> (波線矢印) で表現することとします。設定値の参照数が少ないほどよいです。依存関係がある場合については、後述します。アーキテクチャの文脈では、『依存』を---> (波線矢印) で表現します。そのため便宜上、tfstateファイルでも同じ記号で表現することにしました👍▼ 依存関係がない場合例えば、AWSリソースからなるプロダクトをいくつかのtfstateファイル (foo-tfstate、bar-tfstate、baz-tfstate) に分割したと仮定します。ここで仮定した状況では、 tfstate ファイル間に依存関係はないとします。そのため、想定される状態の依存関係図は以下の通りになります。tfstateファイル間に依存関係がない状況がベストです。---title: tfstateファイル間に依存関係はない---%%{init:{'theme':'default'}}%%flowchart TB    subgraph AWSアカウント        foo["foo-tfstate"]        bar["bar-tfstate"]    end▼ 依存関係がある場合同様に分割したと仮定します。ここで仮定した状況では、 foo-tfstate ➡︎ bar-tfstate の方向に依存しているとします。そのため、---> (波線矢印) を使用して、想定される状態の依存関係図は以下の通りになります。なお、依存方向は状況によって異なることをご容赦ください。---title: foo-tfstateファイルは、bar-tfstateファイルに依存---%%{init:{'theme':'default'}}%%flowchart TD    subgraph AWSアカウント        foo["foo-tfstate"]        bar["bar-tfstate"]    end    foo -. 依存 .-> bar04. tfstate ファイルに基づくその他の設計リポジトリ 🏭 の設計リポジトリ分割リポジトリの分割は、tfstateファイル分割に基づいて設計しましょう。異なるリポジトリにtfstateファイルをおいた方がよい場合については、分割パターン で説明しています。🏭 foo-repository/├── backend.tf # fooコンポーネントの状態を持つ terraform.tfstate ファイルを指定する...🏭 bar-repository/├── backend.tf # barコンポーネントの状態を持つ terraform.tfstate ファイルを指定する...ディレクトリー 📂 構成リポジトリ内のディレクトリー構成も、tfstateファイル分割に基づいて設計しましょう。率直に言うと、Terraformのディレクトリー構成のパターンは無数にあります。そのため、基準なしにディレクトリー構成を考えると何でもあり になってしまいます。一方で、tfstateファイル分割に基づいて設計することにより、明確なディレクトリー構成パターン として抽出できるようになります。🏭 repository/├── 📂 foo/│    ├── backend.tf # fooコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    ...│└── 📂 bar/      ├── backend.tf # barコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      ...Terraformには、そのリポジトリ内だけでブロック (例：resource、data) のセットを使い回すことを目的とした、ローカルモジュールがあります。今回、これのディレクトリー構成は設計に含めていません。混同しやすいのですが、tfstateファイル分割に基づくディレクトリー構成とローカルモジュール内のそれは、全く別のテーマとして切り離して考えることができます👍リモートバックエンド 🪣 の設計リモートバックエンド分割本記事では、リモートバックエンドとしてAWS S3バケットを使用することを想定しています。リモートバックエンドの分割は、tfstateファイル分割に基づいて設計しましょう。異なるリモートバックエンドにtfstateファイルをおいた方がよい場合については、分割パターン で説明しています。🪣 foo-bucket/│└── terraform.tfstate # fooコンポーネントの状態を持つ🪣 bar-bucket/│└── terraform.tfstate # barコンポーネントの状態を持つディレクトリー構成リモートバックエンド内のディレクトリー構成も、tfstateファイル分割に基づいて設計しましょう。🪣 bucket/├── 📂 foo/│    └── terraform.tfstate # fooコンポーネントの状態を持つ│└── 📂 bar/      └── terraform.tfstate # barコンポーネントの状態を持つ05. 状態の依存関係の定義方法terraform_remote_stateブロックの場合terraform_remote_stateブロックによる依存terraform_remote_stateブロックには、以下のメリデメがあります。 アーキテクチャ特性  メリット                                                                           デメリット                                                                                                                                                            可読性                 -                                                                                  terraform_remote_stateブロックに加えて、outputブロックも実装が必要である。                                                                                        拡張性                 依存先のAWSリソースに関わらず、同じterraform_remote_stateブロックを使い回せる。  -                                                                                                                                                                     保守性                 -                                                                                  依存先と依存元の間でTerraformのバージョンに差がありすぎると、tfstateファイル間で互換性がなくなり、terraform_remote_stateブロックの処理が失敗する。 本記事では、 terraform_remote_state ブロックを使用して、状態の依存関係を定義 していきます。tfstateファイルが他のtfstateファイルに依存する方法として、後述のAWSリソース別のdataブロックがあります。The terraform_remote_state Data Source | Terraform | HashiCorp Developer状態の依存関係図例えば、AWSリソースからなるプロダクトをいくつかのtfstateファイル (foo-tfstate、bar-tfstate) に分割したと仮定します。ここで仮定した状況では、bar-tfstateファイルはVPCの状態を持っており、 foo-tfstate ファイルは bar-tfstate ファイルに依存しているとします。そのため、想定される状態の依存関係図は以下の通りになります。なお、依存方向は状況によって異なることをご容赦ください。---title: terraform_remote_stateブロックを使用した依存関係---%%{init:{'theme':'default'}}%%flowchart TD    subgraph bucket        foo["foo-tfstate"]        bar["bar-tfstate"]    end    foo -. VPCの状態に依存 .-> barリポジトリのディレクトリー構成tfstateファイル分割に基づいて、リポジトリのディレクトリー構成例は以下の通りになります。ディレクトリーの設計方法は、分割パターン で説明しています。🏭 repository/├── 📂 foo/│    ├── backend.tf # fooコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    ├── remote_state.tf # terraform_remote_stateブロックを使用し、bar-tfstate ファイルに依存する│    ├── provider.tf│    ...│└── 📂 bar/      ├── backend.tf # barコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      ├── output.tf # 他の tfstate ファイルから依存される      ├── provider.tf      ...foo-tfstateファイルがbar-tfstateファイルに依存するために必要な実装は、以下の通りになります。# fooリソースの状態は、bar-tfstate ファイルで持つresource "example" "foo" {  # fooリソースは、bar-tfstate ファイルのVPCに依存する  vpc_id = data.terraform_remote_state.bar.outputs.bar_vpc_id  ...}# VPCの状態は、bar-tfstate ファイルで持つdata "terraform_remote_state" "bar" { backend= "s3"  config = {    bucket = "bar-tfstate"    key    = "bar/terraform.tfstate"    region = "ap-northeast-1"  }}# VPCの状態は、bar-tfstate ファイルで持つoutput "bar_vpc_id" {  value = aws_vpc.bar.id}resource "aws_vpc" "bar" {  ...}リモートバックエンドのディレクトリー構成tfstateファイル分割に基づいて、リモートバックエンド内のディレクトリー構成例は以下の通りになります。🪣 bucket/├── 📂 foo│    └── terraform.tfstate # fooコンポーネントの状態を持つ│└── 📂 bar      └── terraform.tfstate # barコンポーネントの状態を持つAWSリソース別のdataブロックの場合AWSリソース別のdataブロックによる依存dataブロックには、以下のメリデメがあります。 アーキテクチャ特性  メリット                                                                                                                                        デメリット                                                         可読性                 dataブロックの実装のみが必要である。                                                                                                          -                                                                  拡張性                 -                                                                                                                                               依存先のAWSリソース別にdataブロックが必要である。                保守性                 依存先と依存元の間でTerraformのバージョンに差があっても、tfstateファイル間で直接的に依存するわけではないため、バージョン差の影響を受けない。  -                                                   今回は使用しませんが、依存関係の他の定義方法として、AWSリソース別のdataブロックがあります。これは、tfstateファイルが自身以外 (例：コンソール画面、他のtfstateファイル) で作成されたAWSリソースの状態に依存するために使用できます。terraform_remote_stateブロックとは異なり、直接的にはtfstateファイルに依存しません。dataブロックの場合は、実際のAWSリソースの状態に依存することにより、間接的にAWSリソースのtfstateファイルに依存することになります。Data Sources - Configuration Language | Terraform | HashiCorp Developer状態の依存関係図例えば、dataブロックも同様にして、AWSリソースからなるプロダクトをいくつかのtfstateファイル (foo-tfstate、bar-tfstate) に分割したと仮定します。ここで仮定した状況では、bar-tfstateファイルはVPCの状態を持っており、 foo-tfstate ファイルは bar-tfstate ファイルに依存しているとします。想定される状態の依存関係図は以下の通りになります。なお、依存方向は状況によって異なることをご容赦ください。---title: dataブロックを使用した依存関係---%%{init:{'theme':'default'}}%%flowchart TD    subgraph bucket        foo["foo-tfstate"]        bar["bar-tfstate"]    end    foo -. VPCの状態に依存 .-> barリポジトリのディレクトリー構成ディレクトリー構成は、tfstateファイル分割に基づいて、以下の通りになります。🏭 repository/├── 📂 foo/│    ├── backend.tf # fooコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    ├── data.tf # dataブロックを使用し、bar-tfstate ファイルに依存する│    ├── provider.tf│    ...│└── 📂 bar/      ├── backend.tf # barコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      ├── provider.tf      ...foo-tfstateファイルがbar-tfstateファイルに依存するために必要な実装は、以下の通りになります。# fooリソースの状態は、foo-tfstate ファイルで持つresource "example" "foo" {  # fooリソースは、bar-tfstate ファイルのVPCに依存する  vpc_id     = data.aws_vpc.bar.id}# VPCの状態は、bar-tfstate ファイルで持つdata "aws_vpc" "bar" {  filter {    name   = "tag:Name"    values = ["<bar-tfstateが持つVPCの名前>"]  }}リモートバックエンドのディレクトリー構成tfstateファイル分割に基づいて、リモートバックエンド内のディレクトリー構成例は以下の通りになります。🪣 bucket/├── 📂 foo│    └── terraform.tfstate # fooコンポーネントの状態を持つ│└── 📂 bar      └── terraform.tfstate # barコンポーネントの状態を持つ06. tfstate ファイルの分割パターン概要前述の通り、tfstateファイルの分割の境界は、『他の状態にできるだけ依存しないリソースの関係』から見つけることができます。分割しすぎると terraform_remote_stateブロック地獄 になるため、細かすぎず粗すぎない適切な境界を見つけていきましょう。今回は、私が考える分割パターンをいくつか紹介します。なお、全てが実用的なパターンというわけでないので、推奨するものを ⭕️ としています。必須・任意tfstate分割パターン大分類tfstate分割パターン小分類推奨対応するリポジトリ構成 🏭対応するリモートバックエンド構成 🪣  必須上層プロバイダーのアカウント別⭕️リポジトリ自体または上層ディレクトリーリモートバックエンド自体または上層ディレクトリー  下層実行環境別⭕️下層ディレクトリー下層ディレクトリー  任意中間層同じテナント内のプロダクト別中間層ディレクトリー中間層ディレクトリー  運用チーム責務範囲別⭕️  プロダクトのサブコンポーネント別⭕️  AWSリソースの種類グループ別  AWSリソースの状態の変更頻度グループ別  運用チーム責務範囲別プロダクトのサブコンポーネント別の組み合わせ⭕️  ディレクトリー構成との関係についてリポジトリの場合記事内のここ で、リポジトリ内のディレクトリー構成はtfstateファイル分割に基づいて設計するべき、という説明をしました。tfstateファイルの分割パターンは、上層/下層/中間層 の層に大別できます。これらの層は、以下の通りリポジトリ自体・ディレクトリー構成の設計方法に影響します。# リポジトリ自体を分割する場合🏭 上層/├── 📂 中間層/│    ├── 📂 下層/│    │    ├── backend.tfvars # 分割された terraform.tfstate ファイルを指定する│    │    ...│    │...# リポジトリ内のディレクトリを分割する場合🏭 リポジトリ/├── 📂 上層/│    ├── 📂 中間層/│    │    ├── 📂 下層/│    │    │    ├── backend.tfvars # 分割された terraform.tfstate ファイルを指定する│    │    │    ...│    │    │...リモートバックエンドの場合記事内のここ で、リモートバックエンドのディレクトリ構成についても言及しました。これらの層は、以下の通りリモートバックエンド自体・ディレクトリー構成の設計方法に影響します。# リモートバックエンド自体を分割する場合🪣 上層/├── 📂 中間層/│    ├── 📂 下層/│    │    └── terraform.tfstate # 分割された状態を持つ│    ││    │...# リモートバックエンド内のディレクトリを分割する場合🪣 bucket/├── 📂 上層/│    ├── 📂 中間層/│    │    ├── 📂 下層/│    │    │    └── terraform.tfstate # 分割された状態を持つ│    │    ││    │    │...07. 上層の分割 (必須)上層の分割について上層の分割は 必須 です。Terraformに携わる管理者の数が少なくても採用した方がよいです。tfstateファイルをパターンに応じて分割し、これに基づいてディレクトリー・リモートバックエンドも設計しましょう。プロバイダーのアカウント別この分割方法について上層分割の中でも、基本的な方法の1つです。プロバイダーのアカウント別にtfstateファイルを分割し、上層もこれに基づいて設計します。この分割方法により、各プロバイダーの管理者が互いに影響を受けずに、terraformコマンドの結果を得られるようになります。tfstateファイルで状態を管理せざるを得ない場合があります。例えば、Kubernetesのプロバイダーは、EKSと同じtfstateファイルで管理した方がよいです👍Terraform Registry【プロバイダーアカウント別】状態の依存関係図例えば、以下のプロバイダーを使用したい状況と仮定します。主要プロバイダー (AWS)アプリ/インフラ監視プロバイダー (Datadog)ジョブ監視プロバイダー (Healthchecks)インシデント管理プロバイダー (PagerDuty)ここで仮定した状況では、各プロバイダーの tfstate ファイル間で状態が相互に依存しているとします。AWSリソース間の相互依存ではないので、循環参照は起こりません。そのため、想定される状態の依存関係図は以下の通りになります。なお、依存方向は状況によって異なることをご容赦ください。---title: プロバイダーのアカウント別---%%{init:{'theme':'default'}}%%flowchart LR    subgraph PagerDuty        pagerDuty["tfstate"]    end    subgraph Healthchecks        healthchecks["tfstate"]    end    subgraph Datadog        datadog["tfstate"]    end    subgraph AWS        aws["tfstate"]    end    aws -...-> datadog    aws -...-> healthchecks    aws -...-> pagerDuty    datadog -...-> aws    healthchecks -...-> aws    pagerDuty -...-> aws【プロバイダーアカウント別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合プロバイダーアカウント別に分割したtfstateファイルを、異なるリポジトリで管理します。例えば、tfstateファイル分割に基づいて、リポジトリのディレクトリー構成例は以下の通りになります。前述の依存関係図の状況と仮定します。🏭 aws-repository/├── backend.tf # AWSの状態を持つ terraform.tfstate ファイルを指定する├── output.tf # 他の tfstate ファイルから依存される├── remote_state.tf # 他の tfstate ファイルに依存する├── provider.tf...🏭 datadog-repository/├── backend.tf # Datadogの状態を持つ terraform.tfstate ファイルを指定する├── output.tf # 他の tfstate ファイルから依存される├── remote_state.tf # 他の tfstate ファイルに依存する├── provider.tf...🏭 healthchecks-repository/├── backend.tf # Healthchecksの状態を持つ terraform.tfstate ファイルを指定する├── output.tf # 他の tfstate ファイルから依存される├── remote_state.tf # 他の tfstate ファイルに依存する├── provider.tf...🏭 pagerduty-repository/├── backend.tf # PagerDutyの状態を持つ terraform.tfstate ファイルを指定する├── output.tf # 他の tfstate ファイルから依存される├── remote_state.tf # 他の tfstate ファイルに依存する├── provider.tf...▼ 同じリポジトリの場合プロバイダーアカウント別に分割したtfstateファイルを、同じリポジトリで管理します。例えば、tfstateファイル分割に基づいて、リポジトリのディレクトリー構成例は以下の通りになります。前述の依存関係図の状況と仮定します。🏭 repository/├── 📂 aws/│    ├── backend.tf # AWSの状態を持つ terraform.tfstate ファイルを指定する│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── provider.tf│    ...│├── 📂 datadog/│    ├── backend.tf # Datadogの状態を持つ terraform.tfstate ファイルを指定する│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── provider.tf│    ...│├── 📂 healthchecks/│    ├── backend.tf # Healthchecksの状態を持つ terraform.tfstate ファイルを指定する│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── provider.tf│    ...│└── 📂 pagerduty/      ├── backend.tf # PagerDutyの状態を持つ terraform.tfstate ファイルを指定する      ├── output.tf # 他の tfstate ファイルから依存される      ├── remote_state.tf # 他の tfstate ファイルに依存する      ├── provider.tf      ...【プロバイダーアカウント別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合プロバイダーアカウント別に分割したtfstateファイルを、異なるリモートバックエンドで管理します。例えば、tfstateファイル分割に基づいて、リモートバックエンド内のディレクトリー構成例は以下の通りになります。前述の依存関係図の状況と仮定します。🪣 aws-bucket/│└── terraform.tfstate # AWSの状態を持つ🪣 datadog-bucket/│└── terraform.tfstate # Datadogの状態を持つ🪣 healthchecks-bucket/│└── terraform.tfstate # Healthchecksの状態を持つ🪣 pagerduty-bucket/│└── terraform.tfstate # PagerDutyの状態を持つ▼ 同じリモートバックエンドの場合プロバイダーアカウント別に分割したtfstateファイルを、同じリモートバックエンドで管理します。例えば、tfstateファイル分割に基づいて、リモートバックエンド内のディレクトリー構成例は以下の通りになります。前述の依存関係図の状況と仮定します。🪣 bucket/├── 📂 aws│    └── terraform.tfstate # AWSの状態を持つ│├── 📂 datadog│    └── terraform.tfstate # Datadogの状態を持つ│├── 📂 healthchecks│    └── terraform.tfstate # Healthchecksの状態を持つ│└── 📂 pagerduty      └── terraform.tfstate # PagerDutyの状態を持つ08. 下層の分割 (必須)下層の分割について下層の分割は 必須 です。Terraformに携わる管理者の数が少なくても採用した方がよいです。tfstateファイルをパターンに応じて分割し、これに基づいてディレクトリー・リモートバックエンドも設計しましょう。実行環境別この分割方法について下層分割の中でも、基本的な方法の1つです。実行環境別にtfstateファイルを分割し、下層もこれに基づいて設計します。この分割方法により、各実行環境の管理者が互いに影響を受けずに、terraformコマンドの結果を得られるようになります。Terraform: Up & Running; Writing Infrastructure As CodeHow to manage Terraform state. A guide to file layout, isolation, and… | by Yevgeniy Brikman | Gruntwork【実行環境別】状態の依存関係図例えば、以下の実行環境を構築したい状況と仮定します。Tes環境 (検証環境)Stg環境 (ユーザー受け入れ環境)Prd環境 (本番環境)かつ、以下のプロバイダーを使用したい状況と仮定します。主要プロバイダー (AWS)アプリ/インフラ監視プロバイダー (Datadog)ジョブ監視プロバイダー (Healthchecks)インシデント管理プロバイダー (PagerDuty)ここで仮定した状況では、各実行環境の tfstate ファイルは他の実行環境には依存していないとします。そのため、想定される状態の依存関係図は以下の通りになります。なお、依存方向は状況によって異なることをご容赦ください。---title: 実行環境別---%%{init:{'theme':'default'}}%%flowchart LR    subgraph PagerDuty        pagerDuty["tfstate"]    end    subgraph Healthchecks        healthchecks["tfstate"]    end    subgraph Datadog        datadog["tfstate"]    end    subgraph AWS        subgraph tes-bucket            tes["tfstate"]        end        subgraph stg-bucket            stg["tfstate"]        end        subgraph prd-bucket            prd["tfstate"]        end    end    tes -...-> datadog    tes -...-> healthchecks    tes -...-> pagerDuty    datadog -...-> tes    healthchecks -...-> tes    pagerDuty -...-> tes【実行環境別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合プロバイダーアカウント別にtfstateファイルを分割することは必須としているため、その上でディレクトリー構成を考えます。例えば、tfstateファイル分割に基づいて、リポジトリのディレクトリー構成例は以下の通りになります。前述の依存関係図の状況と仮定します。🏭 aws-repository/├── output.tf # 他の tfstate ファイルから依存される├── remote_state.tf # 他の tfstate ファイルに依存する├── provider.tf├── 📂 tes/ # Tes環境│    ├── backend.tfvars # AWSのTes環境の状態を持つ terraform.tfstate ファイルを指定する│    ...│├── 📂 stg/ # Stg環境└── 📂 prd/ # Prd環境🏭 datadog-repository/├── output.tf # 他の tfstate ファイルから依存される├── remote_state.tf # 他の tfstate ファイルに依存する├── provider.tf├── 📂 tes/│    ├── backend.tfvars # DatadogのTes環境の状態を持つ terraform.tfstate ファイルを指定する│    ...│├── 📂 stg/└── 📂 prd/🏭 healthchecks-repository/├── output.tf # 他の tfstate ファイルから依存される├── remote_state.tf # 他の tfstate ファイルに依存する├── provider.tf├── 📂 tes/│    ├── backend.tfvars # HealthchecsのTes環境の状態を持つ terraform.tfstate ファイルを指定する│    ...│├── 📂 stg/└── 📂 prd/🏭 pagerduty-repository/├── output.tf # 他の tfstate ファイルから依存される├── remote_state.tf # 他の tfstate ファイルに依存する├── provider.tf├── 📂 tes/│    ├── backend.tfvars # PagerDutyのTes環境の状態を持つ terraform.tfstate ファイルを指定する│    ...│├── 📂 stg/└── 📂 prd/▼ 同じリポジトリの場合プロバイダーアカウント別にtfstateファイルを分割することは必須としているため、その上でディレクトリー構成を考えます。例えば、tfstateファイル分割に基づいて、リポジトリのディレクトリー構成例は以下の通りになります。前述の依存関係図の状況と仮定します。🏭 repository/├── 📂 aws/│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── provider.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # AWSのTes環境の状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    └── 📂 prd/ # Prd環境│├── 📂 datadog/│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── provider.tf│    ├── 📂 tes/│    │    ├── backend.tfvars # DatadogのTes環境の状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/│    └── 📂 prd/│├── 📂 healthchecks/│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── provider.tf│    ├── 📂 tes/│    │    ├── backend.tfvars # HealthchecksのTes環境の状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/│    └── 📂 prd/│└── 📂 pagerduty/      ├── output.tf # 他の tfstate ファイルから依存される      ├── remote_state.tf # 他の tfstate ファイルに依存する      ├── provider.tf      ├── 📂 tes/      │    ├── backend.tfvars # PagerDutyのTes環境の状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      ├── 📂 stg/      └── 📂 prd/【実行環境別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合実行環境別に分割したtfstateファイルを、異なるリモートバックエンドで管理します。tfstateファイル分割に基づいて、リモートバックエンド内のディレクトリー構成例は以下の通りになります。例えば、前述の依存関係図の状況と仮定します。🪣 tes-aws-bucket/│└── terraform.tfstate # AWSのTes環境の状態を持つ🪣 tes-datadog-bucket/│└── terraform.tfstate # DatadogのTes環境の状態を持つ🪣 tes-healthchecks-bucket/│└── terraform.tfstate # HealthchecksのTes環境の状態を持つ🪣 tes-pagerduty-bucket/│└── terraform.tfstate # PagerDutyのTes環境の状態を持つ▼ 同じリモートバックエンド x AWSアカウント別に異なる実行環境 の場合プロバイダーアカウント別に分割したtfstateファイルを、同じリモートバックエンドで管理します。また、AWSアカウント別に異なる実行環境を構築していると仮定します。例えば、tfstateファイル分割に基づいて、リモートバックエンド内のディレクトリー構成例は以下の通りになります。前述の依存関係図の状況と仮定します。# Tes環境用バケットの場合🪣 tes-bucket/├── 📂 aws/│    └── terraform.tfstate # AWSのTes環境の状態を持つ│├── 📂 datadog/│    └── terraform.tfstate # DatadogのTes環境の状態を持つ│├── 📂 healthchecks/│    └── terraform.tfstate # HealthchecksのTes環境の状態を持つ│└── 📂 pagerduty/      └── terraform.tfstate # PagerDutyのTes環境の状態を持つ# Stg環境用バケットの場合🪣 stg-bucket/│...# Prd環境用バケットの場合🪣 prd-bucket/│...▼ 同じリモートバックエンド x 単一のAWSアカウント内に全ての実行環境 の場合プロバイダーアカウント別に分割したtfstateファイルを、同じリモートバックエンドで管理します。また、単一のAWSアカウント内に全実行環境を構築しているとします。例えば、tfstateファイル分割に基づいて、リモートバックエンド内のディレクトリー構成例は以下の通りになります。前述の依存関係図の状況と仮定します。🪣 bucket/├── 📂 aws/│    ├── 📂 tes/ # Tes環境│    │    └── terraform.tfstate # AWSのTes環境の状態を持つ│    ││    ├── 📂 stg/ # Stg環境│    └── 📂 prd/ # Prd環境│├── 📂 datadog/│    ├── 📂 tes/│    │    └── terraform.tfstate # DatadogのTes環境の状態を持つ│    ││    ├── 📂 stg/│    └── 📂 prd/│├── 📂 healthchecks/│    ├── 📂 tes/│    │    └── terraform.tfstate # HealthchecksのTes環境の状態を持つ│    ││    ├── 📂 stg/│    └── 📂 prd/│└── 📂 pagerduty/      ├── 📂 tes/      │    └── terraform.tfstate # PagerDutyのTes環境の状態を持つ      │      ├── 📂 stg/      └── 📂 prd/09. 中間層の分割 (任意)中間層の分割について中間層の分割は 任意 です。Terraformに携わる管理者が多くなるほど、効力を発揮します。同じテナントのプロダクト別この分割方法について同じテナント (例：同じAWSアカウントの同じVPC) 内に複数の小さなプロダクトがある場合に、プロダクト別でtfstateファイルを分割し、中間層もこれに基づいて設計します。ここでいうプロダクトは、アプリを動かすプラットフォーム (例：EKS、ECS、AppRunner、EC2) とそれを取り巻くAWSリソースを指しています。この分割方法により、各プロダクトの管理者が互いに影響を受けずに、terraformコマンドの結果を得られるようになります。AWSの設計プラクティスとしてプロダクトごとにVPCを分けた方がよいため、この分割方法を採用することは少ないかもしれません。ただ現実として、各プロダクトの使用するIPアドレス数が少なく、またプロダクト別にVPCを分割するのが煩雑という現場はあります😭【同じテナントのプロダクト別】状態の依存関係図例えば、以下のプロダクトに分割した状況と仮定します。fooプロダクトbarプロダクト共有networkコンポーネント (例：VPC、Route53)ここで仮定した状況では、各プロダクトの tfstate ファイルの依存は一方向最終的に、共有networkコンポーネントの tfstate ファイルに依存しているとします。そのため、想定される状態の依存関係図は以下の通りになります。なお、依存方向は状況によって異なることをご容赦ください。---title: 同じテナントのプロダクト別---%%{init:{'theme':'default'}}%%flowchart TB    subgraph AWS        subgraph tes-bucket            foo-product["foo-product-tfstate<br>(アプリを動かすプラットフォームのAWSリソース)"]-..->network            bar-product["bar-product-tfstate<br>(アプリを動かすプラットフォームのAWSリソース)"]-..->network            network["network-tfstate<br>(Route53, VPC)"]        end    subgraph stg-bucket        stg["tfstate"]    end    subgraph prd-bucket        prd["tfstate"]    end    end【同じテナントのプロダクト別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合この場合では、同じテナントのプロダクト別に分割したtfstateファイルを、異なるリポジトリで管理します。例えば、tfstateファイル分割に基づいて、リポジトリのディレクトリー構成例は以下の通りになります。前述の依存関係図の状況と仮定します。# fooプロダクトの tfstate ファイルのリポジトリ🏭 aws-foo-product-repository/├── provider.tf├── remote_state.tf # 他の tfstate ファイルに依存する├── 📂 tes/ # Tes環境│    ├── backend.tfvars # fooプロダクトの状態を持つ terraform.tfstate ファイルを指定する│    ...│├── 📂 stg/ # Stg環境│    ├── backend.tfvars # fooプロダクトの状態を持つ terraform.tfstate ファイルを指定する│    ...│└── 📂 prd/ # Prd環境      ├── backend.tfvars # fooプロダクトの状態を持つ terraform.tfstate ファイルを指定する      ...# barプロダクトの tfstate ファイルのリポジトリ🏭 aws-bar-product-repository/├── provider.tf├── remote_state.tf # 他の tfstate ファイルに依存する├── 📂 tes/ # Tes環境│    ├── backend.tfvars # barプロダクトの状態を持つ terraform.tfstate ファイルを指定する│    ...│├── 📂 stg/ # Stg環境│    ├── backend.tfvars # barプロダクトの状態を持つ terraform.tfstate ファイルを指定する│    ...│└── 📂 prd/ # Prd環境      ├── backend.tfvars # barプロダクトの状態を持つ terraform.tfstate ファイルを指定する      ...# 共有networkコンポーネントの tfstate ファイルのリポジトリ🏭 aws-network-repository/├── provider.tf├── output.tf # 他の tfstate ファイルから依存される├── route53.tf├── vpc.tf├── 📂 tes/ # Tes環境│    ├── backend.tfvars # networkコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    ...│├── 📂 stg/ # Stg環境│    ├── backend.tfvars # networkコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    ...│└── 📂 prd/ # Prd環境      ├── backend.tfvars # networkコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      ...▼ 同じリポジトリの場合この場合では、同じテナントのプロダクト別に分割したtfstateファイルを、同じリポジトリで管理します。例えば、tfstateファイル分割に基づいて、リポジトリのディレクトリー構成例は以下の通りになります。前述の依存関係図の状況と仮定します。🏭 aws-repository/├── 📂 foo-product/│    ├── provider.tf│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # fooプロダクトの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # fooプロダクトの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # fooプロダクトの状態を持つ terraform.tfstate ファイルを指定する│          ...│├── 📂 bar-product/│    ├── provider.tf│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # barプロダクトの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # barプロダクトの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # barプロダクトの状態を持つ terraform.tfstate ファイルを指定する│          ...│└── 📂 network      ├── provider.tf      ├── output.tf # 他の tfstate ファイルから依存される      ├── route53.tf      ├── vpc.tf      ├── 📂 tes/ # Tes環境      │    ├── backend.tfvars # networkコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      ├── 📂 stg/ # Stg環境      │    ├── backend.tfvars # networkコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      └── 📂 prd/ # Prd環境           ├── backend.tfvars # networkコンポーネントの状態を持つ terraform.tfstate ファイルを指定する           ...【同じテナントのプロダクト別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合同じテナントのプロダクト別の場合、異なるリモートバックエンドで管理するとバックエンドが増え過ぎてしまいます。そのため、これはお勧めしません。▼ 同じリモートバックエンドの場合この場合では、同じテナントのプロダクト別に分割したtfstateファイルを、異なるリモートバックエンドで管理します。例えば、tfstateファイル分割に基づいて、リモートバックエンド内のディレクトリー構成例は以下の通りになります。前述の依存関係図の状況と仮定します。# Tes環境用バケットの場合🪣 tes-bucket/├── 📂 foo-product│    └── terraform.tfstate # fooプロダクトの状態を持つ│├── 📂 bar-product│    └── terraform.tfstate # barプロダクトの状態を持つ│└── 📂 network      └── terraform.tfstate # networkコンポーネントの状態を持つ# Stg環境用バケットの場合🪣 stg-bucket/│...# Prd環境用バケットの場合🪣 prd-bucket/│...運用チーム責務範囲別この分割方法について運用チーム (例：アプリチーム、インフラチーム) のAWSリソースの責務範囲別でtfstateファイルを分割し、中間層もこれに基づいて設計します。この分割方法により、各運用チームが互いに影響を受けずに、terraformコマンドの結果を得られるようになります。AWS CloudFormation best practices - AWS CloudFormationTerraform in Action (English Edition)AWSドキュメント・著名な書籍で紹介されています。Terraformに携わるチームが複数ある非常に大規模なプロダクトほど効力を発揮します。実際に私も現在進行形で採用しており、非常に実用的と考えています👍【チーム別】状態の依存関係図例えば、以下の運用チームに分割した状況と仮定します。frontendチーム (アプリのフロントエンド領域担当)backendチーム (アプリのバックエンド領域担当)sreチーム (インフラ領域担当)ここで仮定した状況では、各チームが管理する tfstate ファイル間で状態が相互に依存しているとします。AWSリソース間の相互依存ではないので、循環参照は起こりません。そのため、想定される状態の依存関係図は以下の通りになります。なお、依存方向は状況によって異なることをご容赦ください。---title: 運用チーム責務範囲別---%%{init:{'theme':'default'}}%%flowchart TB    subgraph AWS        subgraph tes-bucket            frontend["frontend-team-tfstate<br>(CloudFront, S3, など)"]            backend["backend-team-tfstate<br>(API Gateway, ElastiCache, RDS, SES, SNS, など)"]            sre["sre-team-tfstate<br>(ALB, CloudWatch, EC2, ECS, EKS, IAM, VPC, など)"]            frontend-..->sre            backend-..->sre            sre-..->frontend            sre-..->backend        end    subgraph stg-bucket        stg["tfstate"]    end    subgraph prd-bucket        prd["tfstate"]    end    end【チーム別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合この場合では、運用チーム責務範囲別に分割したtfstateファイルを、同じリポジトリで管理します。例えば、tfstateファイル分割に基づいて、リポジトリのディレクトリー構成例は以下の通りになります。この例では、状態の依存関係図と同じ状況を仮定しています。🏭 aws-frontend-team-repository/ # frontendチーム├── provider.tf├── output.tf # 他の tfstate ファイルから依存される├── remote_state.tf # 他の tfstate ファイルに依存する├── cloudfront.tf├── s3.tf├── 📂 tes/ # Tes環境│    ├── backend.tfvars # frontendチームの状態を持つ terraform.tfstate ファイルを指定する│    ...│├── 📂 stg/ # Stg環境│    ├── backend.tfvars # frontendチームの状態を持つ terraform.tfstate ファイルを指定する│    ...│└── 📂 prd/ # Prd環境      ├── backend.tfvars # frontendチームの状態を持つ terraform.tfstate ファイルを指定する      ...🏭 aws-backend-team-repository/ # backendチーム├── provider.tf├── output.tf # 他の tfstate ファイルから依存される├── remote_state.tf # 他の tfstate ファイルに依存する├── elasticache.tf├── ses.tf├── sns.tf├── rds.tf├── 📂 tes│    ├── backend.tfvars # backendチームの状態を持つ terraform.tfstate ファイルを指定する│    ...│├── 📂 stg│    ├── backend.tfvars # backendチームの状態を持つ terraform.tfstate ファイルを指定する│    ...│└── 📂 prd      ├── backend.tfvars # backendチームの状態を持つ terraform.tfstate ファイルを指定する       ...🏭 aws-sre-team-repository/ # sreチーム├── provider.tf├── output.tf # 他の tfstate ファイルから依存される├── remote_state.tf # 他の tfstate ファイルに依存する├── alb.tf├── cloudwatch.tf├── ec2.tf├── ecs.tf├── eks.tf├── iam.tf├── vpc.tf├── 📂 tes│    ├── backend.tfvars # sreチームの状態を持つ terraform.tfstate ファイルを指定する│    ...│├── 📂 stg│    ├── backend.tfvars # sreチームの状態を持つ terraform.tfstate ファイルを指定する│    ...│└── 📂 prd      ├── backend.tfvars # sreチームの状態を持つ terraform.tfstate ファイルを指定する      ...▼ 同じリポジトリの場合この場合では、運用チーム責務範囲別に分割したtfstateファイルを、異なるリポジトリで管理します。例えば、tfstateファイル分割に基づいて、リポジトリのディレクトリー構成例は以下の通りになります。この例では、状態の依存関係図と同じ状況を仮定しています。🏭 aws-repository/├── 📂 frontend-team # frontendチーム│    ├── provider.tf│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── cloudfront.tf│    ├── s3.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # frontendチームの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # frontendチームの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # frontendチームの状態を持つ terraform.tfstate ファイルを指定する│          ...│├── 📂 backend-team # backendチーム│    ├── provider.tf│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── elasticache.tf│    ├── ses.tf│    ├── sns.tf│    ├── rds.tf│    ├── 📂 tes│    │    ├── backend.tfvars # backendチームの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg│    │    ├── backend.tfvars # backendチームの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd│          ├── backend.tfvars # backendチームの状態を持つ terraform.tfstate ファイルを指定する│          ...│└── 📂 sre-team # sreチーム      ├── provider.tf      ├── output.tf # 他の tfstate ファイルから依存される      ├── remote_state.tf # 他の tfstate ファイルに依存する      ├── alb.tf      ├── cloudwatch.tf      ├── ec2.tf      ├── ecs.tf      ├── eks.tf      ├── iam.tf      ├── vpc.tf      ├── 📂 tes      │    ├── backend.tfvars # sreチームの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      ├── 📂 stg      │    ├── backend.tfvars # sreチームの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      └── 📂 prd           ├── backend.tfvars # sreチームの状態を持つ terraform.tfstate ファイルを指定する           ...【チーム別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合運用チーム責務範囲別の場合、異なるリモートバックエンドで管理するとバックエンドが増え過ぎてしまいます。そのため、これはお勧めしません。▼ 同じリモートバックエンドの場合この場合では、プロバイダーアカウント別に分割したtfstateファイルを、異なるリモートバックエンドで管理します。例えば、tfstateファイル分割に基づいて、リモートバックエンド内のディレクトリー構成例は以下の通りになります。この例では、状態の依存関係図と同じ状況を仮定しています。# Tes環境用バケットの場合🪣 tes-bucket/├── 📂 frontend-team│    └── terraform.tfstate # frontendチームの状態を持つ│├── 📂 backend-team│    └── terraform.tfstate # backendチームの状態を持つ│└── 📂 sre-team      └── terraform.tfstate # sreチームの状態を持つ# Stg環境用バケットの場合🪣 stg-bucket/│...# Prd環境用バケットの場合🪣 prd-bucket/│...プロダクトのサブコンポーネント別この分割方法についてプロダクトのサブコンポーネント (例：アプリ、ネットワーク、認証/認可、監視、など) 別でtfstateファイルを分割し、中間層もこれに基づいて設計します。この分割方法により、サブコンポーネントの管理者が互いに影響を受けずに、terraformコマンドの結果を得られるようになります。11 Things I wish I knew before working with Terraform – part 1Terraform organization — Part I : What if you split your components ? | by Amine Charot | Mediumコンポーネントは、分けようと思えばいくらでも細分化できてしまいます。細分化した数だけterraform_remote_stateブロック地獄になっていくため、適切な数 (3〜5個くらい) にしておくように注意が必要です。この分割方法は、後述のAWSリソースの種類グループとごっちゃになってしまう場合があるため、プロダクトのサブコンポーネントとして意識的に分割させる必要があります👍【サブコンポーネント別】状態の依存関係図例えば、以下のサブコンポーネントに分割した状況と仮定します。application (Web3層系)auth (認証/認可系)monitor (監視系)network (ネットワーク系)ここで仮定した状況では、各プロダクトの tfstate ファイルの依存は一方向最終的に、networkサブコンポーネントやauthサブコンポーネントの tfstate ファイルに依存しているとします。そのため、想定される状態の依存関係図は以下の通りになります。なお、依存方向は状況によって異なることをご容赦ください。---title: プロダクトのサブコンポーネント別---%%{init:{'theme':'default'}}%%flowchart TB    subgraph AWS        subgraph tes-bucket            application["application-tfstate<br>Web3層と周辺AWSリソース<br>(ALB, APIGateway, CloudFront, EC2, ECS, EKS, RDS, S3, SNS, など)"]            auth["auth-tfstate<br>(IAMなど)"]            monitor["monitor-tfstate<br>(CloudWatch, など)"]            network["network-tfstate<br>(Route53, VPC, など)"]            application-..->network            application-..->auth            monitor-..->application        end        subgraph stg-bucket            stg["tfstate"]        end        subgraph prd-bucket            prd["tfstate"]        end        end【サブコンポーネント別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合プロダクトのサブコンポーネント別の分割パターンの場合、異なるリポジトリで管理するとリポジトリが増え過ぎてしまいます。そのため、これはお勧めしません。▼ 同じリポジトリの場合この場合では、プロダクトのサブコンポーネント別に分割したtfstateファイルを、同じリポジトリで管理します。例えば、tfstateファイル分割に基づいて、リポジトリのディレクトリー構成例は以下の通りになります。この例では、状態の依存関係図と同じ状況を仮定しています。🏭 aws-repository/├── 📂 application/│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── provider.tf│    ├── alb.tf│    ├── cloudfront.tf│    ├── ec2.tf│    ├── ecs.tf│    ├── eks.tf│    ├── ses.tf│    ├── sns.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # applicationコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # applicationコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # applicationコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│          ...│├── 📂 auth/│    ├── provider.tf│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── iam.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # authコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # authコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # authコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│          ...│├── 📂 monitor/│    ├── provider.tf│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── cloudwatch.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # monitorコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # monitorコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # monitorコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│          ...│└── 📂 network      ├── provider.tf      ├── output.tf # 他の tfstate ファイルから依存される      ├── route53.tf      ├── vpc.tf      ├── 📂 tes/ # Tes環境      │    ├── backend.tfvars # networkコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      ├── 📂 stg/ # Stg環境      │    ├── backend.tfvars # networkコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      └── 📂 prd/ # Prd環境           ├── backend.tfvars # networkコンポーネントの状態を持つ terraform.tfstate ファイルを指定する           ...【サブコンポーネント別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合プロダクトのサブコンポーネント別の分割パターンの場合、異なるリモートバックエンドで管理するとバックエンドが増え過ぎてしまいます。そのため、これはお勧めしません。▼ 同じリモートバックエンドの場合この場合では、プロダクトのサブコンポーネント別に分割したtfstateファイルを、異なるリモートバックエンドで管理します。例えば、tfstateファイル分割に基づいて、リモートバックエンド内のディレクトリー構成例は以下の通りになります。この例では、状態の依存関係図と同じ状況を仮定しています。# Tes環境用バケットの場合🪣 tes-bucket/├── 📂 application│    └── terraform.tfstate # applicationコンポーネントの状態を持つ│├── 📂 auth│    └── terraform.tfstate # authコンポーネントの状態を持つ│├── 📂 monitor│    └── terraform.tfstate # monitorコンポーネントの状態を持つ│└── 📂 network      └── terraform.tfstate # networkコンポーネントの状態を持つ# Stg環境用バケットの場合🪣 stg-bucket/│...# Prd環境用バケットの場合🪣 prd-bucket/│...AWSリソースの種類グループ別この分割方法についてAWSリソースの種類グループ別でtfstateファイルを分割し、中間層もこれに基づいて設計します。この分割方法により、各AWSリソースの種類グループも管理者が互いに影響を受けずに、terraformコマンドの結果を得られるようになります。AWSリソースの種類グループは、分けようと思えばいくらでも細分化できてしまいます。細分化した数だけterraform_remote_stateブロック地獄になっていくため、適切な数 (3〜5個くらい) にしておくように注意が必要です。特にこの分割方法は、グループ数がどんどん増えていく可能性があります😇【種類グループ別】状態の依存関係図例えば、以下の種類グループに分割した状況と仮定します。application (Webサーバー、Appサーバー系)auth (認証/認可系)datastore (DBサーバー系)cicd (CI/CD系)monitor (監視系)network (ネットワーク系)ここで仮定した状況では、各プロダクトのtfstateファイルの依存は一方向最終的に、networkグループやauthグループの tfstate ファイルに依存しているとします。そのため、想定される状態の依存関係図は以下の通りになります。なお、依存方向は状況によって異なることをご容赦ください。---title: AWSリソースの種類グループ別---%%{init:{'theme':'default'}}%%flowchart TB    subgraph AWS        subgraph tes-bucket            application["application-tfstate<br>例: ALB, API Gateway, CloudFront, EC2, ECS, EKS, SNS, など"]            auth["auth-tfstate<br>例: IAM, など"]            cicd["cicd-tfstate<br>例: Code3兄弟, など"]            monitor["monitor-tfstate<br>例: CloudWatch, など"]            network["network-tfstate<br>例: Route53, VPC, など"]            datastore["datastore-tfstate<br>例: ElastiCache, RDS, S3, など"]            application-....->auth            application-..->datastore            application-...->network            cicd-..->application            datastore-..->network            monitor-..->application            monitor-..->datastore       end    subgraph stg-bucket        stg["tfstate"]    end    subgraph prd-bucket        prd["tfstate"]    end    end【種類グループ別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合AWSリソースの種類グループ別の分割パターンの場合、異なるリポジトリで管理するとリポジトリが増え過ぎてしまいます。そのため、これはお勧めしません。▼ 同じリポジトリの場合この場合では、AWSリソースの種類グループ別に分割したtfstateファイルを、同じリポジトリで管理します。例えば、tfstateファイル分割に基づいて、リポジトリのディレクトリー構成例は以下の通りになります。この例では、状態の依存関係図と同じ状況を仮定しています。🏭 aws-repository/├── 📂 application/│    ├── provider.tf│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── alb.tf│    ├── api_gateway.tf│    ├── cloudfront.tf│    ├── ec2.tf│    ├── ecs.tf│    ├── eks.tf│    ├── ses.tf│    ├── sns.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # applicationコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # applicationコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # applicationコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│          ...│├── 📂 auth/│    ├── provider.tf│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── iam.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # authコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # authコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # authコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│          ...│├── 📂 cicd/│    ├── provider.tf│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── codebuild.tf│    ├── codecommit.tf│    ├── codedeploy.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # cicdコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # cicdコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # cicdコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│          ...│├── 📂 datastore/│    ├── provider.tf│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── elasticache.tf│    ├── rds.tf│    ├── s3.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # datastoreコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # datastoreコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # datastoreコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│          ...│├── 📂 monitor/│    ├── provider.tf│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── cloudwatch.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # monitorコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # monitorコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # monitorコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│          ...│└── 📂 network      ├── provider.tf      ├── output.tf # 他の tfstate ファイルから参照できるように、outputブロックを定義する      ├── route53.tf      ├── vpc.tf      ├── 📂 tes/ # Tes環境      │    ├── backend.tfvars # networkコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      ├── 📂 stg/ # Stg環境      │    ├── backend.tfvars # networkコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      └── 📂 prd/ # Prd環境           ├── backend.tfvars # networkコンポーネントの状態を持つ terraform.tfstate ファイルを指定する           ...【種類グループ別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合AWSリソースの種類グループ別の分割パターンの場合、異なるリモートバックエンドで管理するとバックエンドが増え過ぎてしまいます。そのため、これはお勧めしません。▼ 同じリモートバックエンドの場合この場合では、AWSリソースの種類グループ別に分割したtfstateファイルを、異なるリモートバックエンドで管理します。例えば、tfstateファイル分割に基づいて、リモートバックエンド内のディレクトリー構成例は以下の通りになります。この例では、状態の依存関係図と同じ状況を仮定しています。# Tes環境用バケットの場合🪣 tes-bucket/├── 📂 application│    └── terraform.tfstate # applicationコンポーネントの状態を持つ│├── 📂 auth│    └── terraform.tfstate # authコンポーネントの状態を持つ│├── 📂 cicd│    └── terraform.tfstate # cicdコンポーネントの状態を持つ│├── 📂 datastore│    └── terraform.tfstate # datastoreコンポーネントの状態を持つ│├── 📂 monitor│    └── terraform.tfstate # monitorコンポーネントの状態を持つ│└── 📂 network      └── terraform.tfstate # networkコンポーネントの状態を持つ# Stg環境用バケットの場合🪣 stg-bucket/│...# Prd環境用バケットの場合🪣 prd-bucket/│...AWSリソースの状態の変更頻度グループ別この分割方法についてAWSリソースの状態の変更頻度グループ別でtfstateファイルを分割し、中間層もこれに基づいて設計します。この分割方法により、各変更頻度グループの管理者が互いに影響を受けずに、terraformコマンドの結果を得られるようになります。oneplane comments on Best way to approach splitting up the state file【変更頻度グループ別】状態の依存関係図例えば、以下の変更頻度グループに分割した状況と仮定します。変更高頻度グループ変更中頻度グループ変更低頻度グループここで仮定した状況では、各プロダクトのtfstateファイルの依存は一方向最終的に、変更低頻度グループの tfstate ファイルに依存しているとします。そのため、想定される状態の依存関係図は以下の通りになります。なお、依存方向は状況によって異なることをご容赦ください。---title: AWSリソースの状態の変更頻度グループ別---%%{init:{'theme':'default'}}%%flowchart TB    subgraph AWS        subgraph tes-bucket            high["high-freq-tfstate<br>例: API Gateway, CloudFront, CloudWatch, IAM"]            middle["middle-freq-tfstate<br>例: ALB, EC2, ECS, EKS, ElastiCache, RDS, S3, SES, SNS"]            low["low-freq-tfstate<br>例: Route53, VPC"]            high-...->low            middle-..->low        end    subgraph stg-bucket        stg["tfstate"]    end    subgraph prd-bucket        prd["tfstate"]    end    end【変更頻度グループ別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合AWSリソースの変更頻度グループ別の分割パターンの場合、異なるリポジトリで管理するとリポジトリが増え過ぎてしまいます。そのため、これはお勧めしません。▼ 同じリポジトリの場合この場合では、AWSリソースの変更頻度グループ別に分割したtfstateファイルを、同じリポジトリで管理します。例えば、tfstateファイル分割に基づいて、リポジトリのディレクトリー構成例は以下の通りになります。この例では、状態の依存関係図と同じ状況を仮定しています。🏭 aws-repository/├── 📂 high-freq # 高頻度変更グループ│    ├── provider.tf│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── api_gateway.tf│    ├── cloudfront.tf│    ├── cloudwatch.tf│    ├── ec2.tf│    ├── ecs.tf│    ├── eks.tf│    ├── iam.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # high-freqコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # high-freqコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # high-freqコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│          ...│├── 📂 low-freq # 低頻度変更グループ│    ├── provider.tf│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── route53.tf│    ├── vpc.tf│    ├── 📂 tes│    │    ├── backend.tfvars # low-freqコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg│    │    ├── backend.tfvars # low-freqコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd│          ├── backend.tfvars # low-freqコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│          ...│└── 📂 middle-freq # 中頻度変更グループ (高頻度とも低頻度とも言えないリソース)      ├── provider.tf      ├── remote_state.tf # 他の tfstate ファイルに依存する      ├── elasticache.tf      ├── rds.tf      ├── s3.tf      ├── ses.tf      ├── 📂 tes      │    ├── backend.tfvars # middle-freqコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      ├── 📂 stg      │    ├── backend.tfvars # middle-freqコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      └── 📂 prd           ├── backend.tfvars # middle-freqコンポーネントの状態を持つ terraform.tfstate ファイルを指定する           ...【変更頻度グループ別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合AWSリソースの変更頻度グループ別の分割パターンの場合、異なるリモートバックエンドで管理するとバックエンドが増え過ぎてしまいます。そのため、これはお勧めしません。▼ 同じリモートバックエンドの場合この場合では、AWSリソースの変更頻度グループ別に分割したtfstateファイルを、異なるリモートバックエンドで管理します。例えば、tfstateファイル分割に基づいて、リモートバックエンド内のディレクトリー構成例は以下の通りになります。この例では、状態の依存関係図と同じ状況を仮定しています。# Tes環境用バケットの場合🪣 tes-bucket/├── 📂 high-freq│    └── terraform.tfstate # high-freqコンポーネントの状態を持つ│├── 📂 middle-freq│    └── terraform.tfstate # middle-freqコンポーネントの状態を持つ│└── 📂 low-freq      └── terraform.tfstate # low-freqコンポーネントの状態を持つ# Stg環境用バケットの場合🪣 stg-bucket/│...# Prd環境用バケットの場合🪣 prd-bucket/│...運用チーム責務範囲別 × プロダクトサブコンポーネント別この分割方法について運用チーム責務範囲別とプロダクトサブコンポーネント別を組み合わせてtfstateファイルを分割し、中間層もこれに基づいて設計します。この分割方法により、各運用チーム内のサブコンポーネントの管理者が互いに影響を受けずに、terraformコマンドの結果を得られるようになります。【チーム別 × サブコンポーネント別】状態の依存関係図以下の運用チームに分割した状況と仮定します。また、各運用チームでTerraformを変更できる管理者が相当数するため、プロダクトのサブコンポーネント別にも分割したとします。frontendチームapplicationmonitorbackendチームapplicationmonitorsreチームapplicationauthmonitornetworkここで仮定した状況では、各プロダクトのtfstateファイルの依存は一方向最終的に、sreチームの管理する tfstate ファイルに依存しているとします。そのため、想定される状態の依存関係図は以下の通りになります。なお、依存方向は状況によって異なることをご容赦ください。---title: 運用チーム責務範囲別 × プロダクトサブコンポーネント別---%%{init:{'theme':'default'}}%%flowchart TB    subgraph AWS        subgraph tes-bucket            subgraph frontend-team               frontendApplication["application-tfstate<br>(CloudFront, S3, など)"]               frontendMonitor["monitor-tfstate<br>(CloudWatch, など)"]            end            subgraph backend-team                backendApplication["application-tfstate<br>(API Gateway, ElastiCache, RDS, SES, SNS, など)"]                backendMonitor["monitor-tfstate<br>(CloudWatch, など)"]            end            subgraph sre-team                sreApplication["application-tfstate<br>Web3層と周辺AWSリソース<br>(ALB, EC2, ECS, EKS, SNS, など)"]                auth["auth-tfstate<br>(IAM, など)"]                sreMonitor["monitor-tfstate<br>(CloudWatch, など)"]                network["network-tfstate<br>(Route53, VPC, など)"]            end            frontendApplication-...->network            sreApplication-...->auth            sreApplication-...->network            backendApplication-...->auth            backendApplication-...->network            frontendMonitor-...->frontendApplication            sreMonitor-...->sreApplication            backendMonitor-...->backendApplication        end    subgraph stg-bucket        stg["tfstate"]    end    subgraph prd-bucket        prd["tfstate"]    end    end【チーム別 × サブコンポーネント別】リポジトリのディレクトリー構成▼ 異なるリポジトリの場合この場合では、運用チーム責務範囲別とプロダクトサブコンポーネント別を組み合わせて分割したtfstateファイルを、同じリポジトリで管理します。例えば、tfstateファイル分割に基づいて、リポジトリのディレクトリー構成例は以下の通りになります。この例では、状態の依存関係図と同じ状況を仮定しています。🏭 aws-frontend-team-repository/├── 📂 application/│    ├── provider.tf│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── cloudfront.tf│    ├── ses.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # frontendチームが管理するapplicationコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # frontendチームが管理するapplicationコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # frontendチームが管理するapplicationコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│          ...│└── 📂 monitor/      ├── provider.tf      ├── remote_state.tf # 他の tfstate ファイルに依存する      ├── cloudwatch.tf      ├── 📂 tes/ # Tes環境      │    ├── backend.tfvars # frontendチームが管理するmonitorコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      ├── 📂 stg/ # Stg環境      │    ├── backend.tfvars # frontendチームが管理するmonitorコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      └── 📂 prd/ # Prd環境            ├── backend.tfvars # frontendチームが管理するmonitorコンポーネントの状態を持つ terraform.tfstate ファイルを指定する            ...🏭 aws-backend-team-repository/├── 📂 application/│    ├── provider.tf│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── api_gateway.tf│    ├── elasticache.tf│    ├── rds.tf│    ├── ses.tf│    ├── sns.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # backendチームが管理するapplicationコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # backendチームが管理するapplicationコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # backendチームが管理するapplicationコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│          ...│└── 📂 monitor/      ├── provider.tf      ├── remote_state.tf # 他の tfstate ファイルに依存する      ├── cloudwatch.tf      ├── 📂 tes/ # Tes環境      │    ├── backend.tfvars # backendチームが管理するmonitorコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      ├── 📂 stg/ # Stg環境      │    ├── backend.tfvars # backendチームが管理するmonitorコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      └── 📂 prd/ # Prd環境            ├── backend.tfvars # backendチームが管理するmonitorコンポーネントの状態を持つ terraform.tfstate ファイルを指定する            ...🏭 aws-sre-team-repository/├── 📂 application/│    ├── provider.tf│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── alb.tf│    ├── ec2.tf│    ├── ecs.tf│    ├── eks.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # sreチームが管理するapplicationコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # sreチームが管理するapplicationコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # sreチームが管理するapplicationコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│          ...│├── 📂 auth/│    ├── provider.tf│    ├── output.tf # 他の tfstate ファイルから依存される│    ├── iam.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # sreチームが管理するauthコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # sreチームが管理するauthコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # sreチームが管理するauthコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│          ...│├── 📂 monitor/│    ├── provider.tf│    ├── remote_state.tf # 他の tfstate ファイルに依存する│    ├── cloudwatch.tf│    ├── 📂 tes/ # Tes環境│    │    ├── backend.tfvars # sreチームが管理するmonitorコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    ├── 📂 stg/ # Stg環境│    │    ├── backend.tfvars # sreチームが管理するmonitorコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│    │    ...│    ││    └── 📂 prd/ # Prd環境│          ├── backend.tfvars # sreチームが管理するmonitorコンポーネントの状態を持つ terraform.tfstate ファイルを指定する│          ...│└── 📂 network      ├── provider.tf      ├── output.tf # 他の tfstate ファイルから依存される      ├── route53.tf      ├── vpc.tf      ├── 📂 tes/ # Tes環境      │    ├── backend.tfvars # sreチームが管理するnetworkコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      ├── 📂 stg/ # Stg環境      │    ├── backend.tfvars # sreチームが管理するnetworkコンポーネントの状態を持つ terraform.tfstate ファイルを指定する      │    ...      │      └── 📂 prd/ # Prd環境            ├── backend.tfvars # sreチームが管理するnetworkコンポーネントの状態を持つ terraform.tfstate ファイルを指定する            ...▼ 同じリポジトリの場合運用チーム責務範囲別とプロダクトサブコンポーネント別を組み合わせる分割パターンの場合、同じリポジトリで管理するとリポジトリが巨大になってしまいます。そのため、これはお勧めしません。【チーム別 × サブコンポーネント別】リモートバックエンドのディレクトリー構成▼ 異なるリモートバックエンドの場合運用チーム責務範囲別とプロダクトサブコンポーネント別を組み合わせる分割パターンの場合、異なるリモートバックエンドで管理するとバックエンドが増え過ぎてしまいます。そのため、これはお勧めしません。▼ 同じリモートバックエンドの場合この場合では、運用チーム責務範囲別とプロダクトサブコンポーネント別を組み合わせて分割したtfstateファイルを、異なるリモートバックエンドで管理します。例えば、tfstateファイル分割に基づいて、リモートバックエンド内のディレクトリー構成例は以下の通りになります。この例では、状態の依存関係図と同じ状況を仮定しています。# Tes環境用バケットの場合🪣 tes-bucket/├── 📂 frontend-team│    ├── 📂 application│    │    └── terraform.tfstate # frontendチームが管理するapplicationコンポーネントの状態を持つ│    ││    └── 📂 monitor│         └── terraform.tfstate # frontendチームが管理するmonitorコンポーネントの状態を持つ│├── 📂 backend-team│    ├── 📂 application│    │    └── terraform.tfstate # backendチームが管理するapplicationコンポーネントの状態を持つ│    ││    └── 📂 monitor│          └── terraform.tfstate # backendチームが管理するmonitorコンポーネントの状態を持つ│└── 📂 sre-team      ├── 📂 application      │    └── terraform.tfstate # sreチームが管理するapplicationコンポーネントの状態を持つ      │      ├── 📂 auth      │    └── terraform.tfstate # sreチームが管理するauthコンポーネントの状態を持つ      │      ├── 📂 monitor      │    └── terraform.tfstate # sreチームが管理するmonitorコンポーネントの状態を持つ      │      └── 📂 network            └── terraform.tfstate # sreチームが管理するnetworkコンポーネントの状態を持つ# Stg環境用バケットの場合🪣 stg-bucket/│...# Prd環境用バケットの場合🪣 prd-bucket/│...10. おわりにTerraformのtfstateファイルの分割パターンをもりもり布教しました。ぜひ採用してみたい分割パターンはあったでしょうか。Terraformの開発現場の具体的な要件は千差万別であり、特にtfstateファイル間の状態の依存関係は様々です。もし、この記事を参考に設計してくださる方は、分割パターンを現場に落とし込んで解釈いただけると幸いです🙇🏻‍「自分を信じても…信頼に足る仲間を信じても…誰にもわからない…」(お友達の@nwiizo, 2023, Terraform Modules で再利用できるので最高ではないでしょうか？)謝辞今回、Terraformの分割パターンの収集にあたり、以下の方々からの意見・実装方法も参考にさせていただきました。@kiyo_12_07 さん@masasuzu さん@tozastation さん(アルファベット順)この場で感謝申し上げます🙇🏻‍]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[光に負けルナ~Google Cloudでのマルチリージョンデータベースについて~]]></title>
            <link>https://zenn.dev/nnaka2992/articles/to_beat_light_speed_on_google_cloud_databases</link>
            <guid>https://zenn.dev/nnaka2992/articles/to_beat_light_speed_on_google_cloud_databases</guid>
            <pubDate>Mon, 03 Jul 2023 15:39:08 GMT</pubDate>
            <content:encoded><![CDATA[クラウドを利用する一番のメリットの一つとしてオンデマンドでリソースを調達し、アクセス負荷に応じてスケールイン・アウト出来ることが上げられます。そのため大体のアプリケーションではシングルリージョンまたは隣接するリージョン2~3程度で運用を始めることが多いと思います。(日本の場合asia-northeast-1とasia-northeast-2など)アプリケーションがグローバルに拡大すると、それだけ物理的な距離が広がりユーザ・サーバ間のアクセスにかかる時間が拡大します。例えばユーザ・サーバ共に日本にある場合(沖縄・北海道間約3,000km)、ネットワークによる遅延は片道約15ms以下...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイクに入社しました！]]></title>
            <link>https://bells17.medium.com/3-shake-279ea982b977?source=rss-713cf42ce34d------2</link>
            <guid>https://bells17.medium.com/3-shake-279ea982b977?source=rss-713cf42ce34d------2</guid>
            <pubDate>Mon, 03 Jul 2023 14:10:50 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[SREの専門家が集まったチームで『SREの探求』の社内輪読会を完遂しました。]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2023/07/03/094713</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2023/07/03/094713</guid>
            <pubDate>Mon, 03 Jul 2023 00:47:13 GMT</pubDate>
            <content:encoded><![CDATA[🍡 前回の記事syu-m-5151.hatenablog.com🐶 はじめにこんにちは。株式会社スリーシェイク Sreake 事業部に所属している@nwiizo です。Sreake事業部は技術力が求められる領域で豊富な経験を持つSREの専門家が集まったチームです。事業部にはさまざまな背景を持つSREの専門家が多く在籍してます。しかし、そのSREの専門家達とは案件が一緒にならなかったり、能動的に質問をしなければSREに関する意見や知見を聞けませんでした。SREの探求 ―様々な企業におけるサイトリライアビリティエンジニアリングの導入と実践オライリージャパンAmazonそんな、課題がある中で半年前に各案件で得た知見や経験を各メンバーで出し合える会がもっと(社内で技術共有会はあるため)あると良いと思いました。そこで社内チャットで有志を募り 『輪読会について考える会』を行いました。社内チャットで運営を募ると一瞬で集まったので良い組織だと思いました。※『輪読会の各話』の議事録が見れるTOPページです。🐵 各メンバーの感想と今後のアクションsugoude途中からの参加でしたが、楽しく役立つ輪読会でした。特に16章17章はDBREに関する内容でしたので当事者意識を持って参加し、有意義な時間になりました。個人的には、途中からの参加でしたので、SREの探求を再演してもらえたら嬉しいです。hash_gen選定理由としてみんなSRE本は読んでるだろうという点もあったと思いますが、様々なケースと向き合ってきたSreake事業がある3-shakeだからこそSREの探求を輪読する価値があったと思いました。様々な事例に対して我々の場合はどうやって提案していけばよいかという会話が多かったことが印象に残っています。日々のアウトプットでも技術フォーカスの内容に加えて具体的な経験例を社内に積極的にフィードバックしていくことでこのいい習慣を続けていけたらと思っています。SatohJohn入社してまもなくというのも有り、そこまでSREの用語に対して詳しくなかったため、この本を読むことで、どうしてそれらの用語が必要なのかが深掘りできたきがしました。また、個人的にGoogle CloudのDevOpsの試験を受けることが有り、その際にもこの本での話題が役に立ちました。今後アプリケーション開発にSREの考えを入れられるようにするのに、ちょうどよい粒度だったと感じております。tozastationインターンの方が参加したタイミングだけ出れたのでそのエピソードで...! Sreake 事業部だけでなく、他事業部も巻き込んで開催していたのが素敵だなと思いました。Sreake の仕事を知ってもらうであったり、他事業部にも SRE を取り込んでもらうなどさまざまな意見交換が生まれる場だったじゃないかと思います。インターンの方も声を上げてくれたのがさらに良かったです！次のテーマも応援してます！nnaka2992DBRE兼SRE見習いとしてSRE活動をしている自分にとっては、データベース以外でのSREの取り組みを技術・ヒューマンスキル両方の面から学べる本でした。弊社のような不特定多数の組織に対するSREの導入サポートを行う企業では、それぞれの組織に合わせたSREの適用が必要となります。様々なSRE実践例を扱う本書籍は自分の知見を深める面でも、SREとしての引き出しを増やす面でも素晴らしい書籍でした。今後はあくまでこの書籍はある組織での最適解としてリファレンスしながら、それぞれの組織で最適となるSREの探求を続けられればと思います。とあるメンバーすごい有意義な時間でした。Sreake内で自分は人数も組織も大きな組織でどうやって既存の組織にSREを導入するか？を考えているので、様々なプラクティスを知れたのは良い体験でした。輪読で学んだことをお客様に話すと「なるほど！」と言ってもらえることも多々ありました。🐦 まとめ今回の読書会は、新しい知識共有のコミュニティーを作り上げながら実施しました。毎週1回、定められた時間にオンラインに集まり、担当者が1章ずつ読みまとめ、それについて話し合うのです。そして、その議論の過程をドキュメントに記録し、印象に残った部分をいつでも見返せるように保存しておけます。感想はもちろん、一人一人異なりますが、それぞれが課題や組織に向かって解決策を考えていくのがとても面白かったです。その結果、同じ本を読んでいても、それぞれ異なるアクションを考え出すことができました。このようなコミュニティを活用した議論と輪読により、活発な意見交換をしながら特殊なミームが発生したり楽しく読書を進めることができました。これからも、このスタイルの読書会は続けていく予定です。皆さんも、一緒に働くメンバーと読書会を試してみてはいかがでしょうか？新たな知識共有の体験、その刺激を味わってほしいです。弊社の採用サイトも載せておきますjobs-3-shake.com]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Copilotでらくらくコードリーディング]]></title>
            <link>https://zenn.dev/nnaka2992/articles/code_reading_with_copilot</link>
            <guid>https://zenn.dev/nnaka2992/articles/code_reading_with_copilot</guid>
            <pubDate>Wed, 28 Jun 2023 14:41:21 GMT</pubDate>
            <content:encoded><![CDATA[GitHub Copilot便利ですね。2021年にTechnical Previewとして発表された時から便利だ便利だと言われていたGitHub Copilotに、2023年の4月末ごろからデビューしました。デビューしたは良いものの最近は仕事ではコーディングよりアーキテクト的な方面でのお仕事が多かったり、個人の時間でもコーディングするよりOSSのコードを読むことのほうが多くコーディングのアシスタントツールとしては使いこなせていません。そのため最近はPostgreSQLのコードを読むときのアシスタントとして利用することが多いです。なのでこの記事ではCopilotでコードリーディン...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Cloud RunのSidecarでJVMのmetricsの取得してみた]]></title>
            <link>https://zenn.dev/satohjohn/articles/25bc5879de7832</link>
            <guid>https://zenn.dev/satohjohn/articles/25bc5879de7832</guid>
            <pubDate>Wed, 28 Jun 2023 12:03:00 GMT</pubDate>
            <content:encoded><![CDATA[概要Cloud Runのmetricsをデフォルトで取得している指標(metrics)以外の指標が他に欲しい場合、どうするのが良いのかを考えてみました。ちょうどCloud RunのSidecar機能がでたので、それを使います。他の指標を、ここではJVMのmetricsとします。Cloud Run上のJVMのmetricsが取れて何が嬉しいのかについては、一旦考えません。後にCloud Runの最大起動時間が増えた場合は、意味があるかもしれません。 構成図にすると以下のような感じになります。Cloud RunでSpring Bootアプリケーションを立ち上げClou...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ロクに勉強してこなかったエンジニアが輪読会参加とかPCA受験に向けて勉強とかしてみた話]]></title>
            <link>https://qiita.com/bayobayo0324/items/56f93f50fa0115dc4d6d</link>
            <guid>https://qiita.com/bayobayo0324/items/56f93f50fa0115dc4d6d</guid>
            <pubDate>Tue, 27 Jun 2023 12:31:17 GMT</pubDate>
            <content:encoded><![CDATA[この記事について40歳でフリーランスから転職をきっかけに会社員エンジニアになって、社内のエンジニアの熱意に影響を受けて勉強をはじめてみた中年エンジニアの感想とか気づきとかです。先に結論勉強する…]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[PagerDutyがたくさん機能追加しているみたいなのでまとめてみた]]></title>
            <link>https://sreake.com/blog/pagerduty-release-updates/</link>
            <guid>https://sreake.com/blog/pagerduty-release-updates/</guid>
            <pubDate>Tue, 27 Jun 2023 06:38:36 GMT</pubDate>
            <content:encoded><![CDATA[はじめに PagerDutyはインシデントの管理、オンコール通知のサービスとして、とても優秀なサービスです。直近も、様々な新機能が出ていますが、旧機能から新機能への移行も同時に行われています。 弊社では、PagerDut […]The post PagerDutyがたくさん機能追加しているみたいなのでまとめてみた first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Terraformで実践するAWS IAM Identity Center（AWS Single Sign-On）のユーザー管理戦略]]></title>
            <link>https://qiita.com/yokoo-an209/items/569ac1ba517b076e8cde</link>
            <guid>https://qiita.com/yokoo-an209/items/569ac1ba517b076e8cde</guid>
            <pubDate>Wed, 21 Jun 2023 04:05:23 GMT</pubDate>
            <content:encoded><![CDATA[はじめにAWS IAM Identity Center（AWS Single Sign-On）を使用して、ユーザー管理を考えていく上で、Terraformを使用して構成管理を実現しようと思います。作成したコードはgithub上に上がっているので、ご参考ください…]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[アプリ開発者のための kubectl 講座]]></title>
            <link>https://zenn.dev/toshikish/articles/6a06017747cbba</link>
            <guid>https://zenn.dev/toshikish/articles/6a06017747cbba</guid>
            <pubDate>Mon, 19 Jun 2023 06:03:18 GMT</pubDate>
            <content:encoded><![CDATA[これは何Kubernetes クラスタ管理者とアプリケーション開発者が分業しているプロジェクトで，開発者が必ずしも Kubernetes に詳しくない場合を想定し，開発時に使いそうな kubectl のコマンドをまとめたものです。クラスタ管理者から開発者にこのドキュメントを適宜改変して渡し，開発者がある程度自立して操作できるようになることで，管理者への問い合わせ負荷を減らすのが狙いです。場合によってはハンズオンで講座を開いてもよいでしょう。 ドキュメント案ここでは Amazon EKS でクラスタを構築する場合の例を示します。別のインフラに構築している場合は適宜書き換え...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[夏に向けて、体もコンテナイメージも減量（軽量化）させよう！]]></title>
            <link>https://qiita.com/yokoo-an209/items/0297808af40c1a74928e</link>
            <guid>https://qiita.com/yokoo-an209/items/0297808af40c1a74928e</guid>
            <pubDate>Mon, 19 Jun 2023 02:46:48 GMT</pubDate>
            <content:encoded><![CDATA[はじめにdockerで構築しているNext.jsのフロントエンドアプリケーションのimageをAmazon ECRにpushしようとしたときに、pushのあまりの遅さにびっくりしたのがことの発端で…]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Terraform 静的検査ツール比較]]></title>
            <link>https://zenn.dev/tayusa/articles/9829faf765ab67</link>
            <guid>https://zenn.dev/tayusa/articles/9829faf765ab67</guid>
            <pubDate>Thu, 15 Jun 2023 17:00:00 GMT</pubDate>
            <content:encoded><![CDATA[対象tfsectflintKICSCheckovSnyk tfsechttps://github.com/aquasecurity/tfsechttps://aquasecurity.github.io/tfsec/v1.28.1 特徴CI系公式のdocker imageがあるhttps://github.com/aquasecurity/tfsec#use-with-dockerGitHub Actionがあるhttps://github.com/aquasecurity/tfsec-pr-commenter-actionGitH...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[editcap で tcpdump のキャプチャファイルから指定の時間帯を切り出す]]></title>
            <link>https://blog.1q77.com/2023/06/editcap/</link>
            <guid>https://blog.1q77.com/2023/06/editcap/</guid>
            <pubDate>Thu, 15 Jun 2023 14:46:42 GMT</pubDate>
            <content:encoded><![CDATA[ちょっと大きめ (時間範囲の広い) pcap ファイルがあって、wireshark で見るにしてもちょっと大きすぎるなということがありました。 見たい時間帯だけに絞ったファイル]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitHub の Reusable workflow で working-directory に変数を使う]]></title>
            <link>https://zenn.dev/toshikish/articles/be970407f02098</link>
            <guid>https://zenn.dev/toshikish/articles/be970407f02098</guid>
            <pubDate>Thu, 15 Jun 2023 05:22:24 GMT</pubDate>
            <content:encoded><![CDATA[やりたいことGitHub Actions の reusable workflow で，作業ディレクトリを入力変数で変えたい場合を考えます。on:  workflow_call:    inputs:      workdir:        required: true        type: string うまくいかない方法ワークフロー全体のステップのデフォルト設定 defaults.run.working-directory では，現時点ではコンテキストと式が許可されていません。したがって，入力変数でディレクトリ名を受け取って上記に入れても動作しません。...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[KubeconformをGitLab CIに組み込んで、k8sのマニフェストがAPIの仕様に沿うか検査する]]></title>
            <link>https://zenn.dev/tayusa/articles/1aa96e6ceb838a</link>
            <guid>https://zenn.dev/tayusa/articles/1aa96e6ceb838a</guid>
            <pubDate>Sun, 11 Jun 2023 17:19:45 GMT</pubDate>
            <content:encoded><![CDATA[はじめにk8sマニフェストを普段管理していないメンバーがマニフェストのファイルを変更する場面があります。その際のレビューを出来るだけ自動化したくkubeconformを導入しました。 KubeconformマニフェストがAPIの仕様に沿うか検査してくれます。https://github.com/yannh/kubeconform自分でスキーマを用意すればIstio、Argo Rollouts、Argo Workflowsのような外部のAPIも検査できます。 スキーマの生成スキーマの生成はpythonのスクリプトが用意されているので、これをCRDを引数で渡し実行しま...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[plutoをGitLab CIに組み込んで非推奨のk8s apiVersionを検出する]]></title>
            <link>https://zenn.dev/tayusa/articles/79a3f54d8f21bc</link>
            <guid>https://zenn.dev/tayusa/articles/79a3f54d8f21bc</guid>
            <pubDate>Sun, 11 Jun 2023 17:18:13 GMT</pubDate>
            <content:encoded><![CDATA[はじめにk8sのバージョンが上がるとAPIが再編成されたりアップグレードされたりします。新しいAPIが出ると古いAPIは非推奨になり最終的には削除されます。なので、k8sのバージョンアップ時はDeprecated API Migration Guideなどを見て非推奨のapiVersionが使われていないか確認して時には修正する必要があります。https://kubernetes.io/docs/reference/using-api/deprecation-guide/例CronJob の batch/v1beta1 -> batch/v1 plutoplu...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Istio Canary Upgrade by Helm]]></title>
            <link>https://zenn.dev/tayusa/articles/03cf961e2409bd</link>
            <guid>https://zenn.dev/tayusa/articles/03cf961e2409bd</guid>
            <pubDate>Sun, 11 Jun 2023 17:17:37 GMT</pubDate>
            <content:encoded><![CDATA[前提helmfileを利用istioのrevisionTagを利用関係のない設定は省略 Upgradeの前にInstall ディレクトリ構成├── helmfile_istio-base.yaml├── helmfile_istio-ingressgateway.yaml├── helmfile_istiod-1-16-0.yaml└── values    ├── istio-base.yaml    ├── istio-ingressgateway.yaml    └── istiod.yaml helmfile helmfile_isti...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Helmに入門したので、躓いたところを振り返る]]></title>
            <link>https://zenn.dev/tayusa/articles/e9285c6c4c09a1</link>
            <guid>https://zenn.dev/tayusa/articles/e9285c6c4c09a1</guid>
            <pubDate>Sun, 11 Jun 2023 17:16:25 GMT</pubDate>
            <content:encoded><![CDATA[はじめにアプリのマニフェストを管理するのにKustomizeを使っていたのですが、同じようなマニフェストが乱立したので管理を楽にするためにHelmに移行しました。Helmを一から書いたのは初めてだったので、躓いた点をここに残します。 quote関数の進数変換0から始まる数値をquote関数を使って文字列にすると進数変換が起こり想定した値ではなくなる下記のようなtemplateでidとして0000000060のような値を渡すと、8進数として解釈され10進数である48に変換されてしまいます。...id: {{ .id | quote }}...0から始まる数値はtem...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Go言語でNetlinkを少し触った話]]></title>
            <link>https://zenn.dev/bells17/articles/netlink-goexample</link>
            <guid>https://zenn.dev/bells17/articles/netlink-goexample</guid>
            <pubDate>Thu, 08 Jun 2023 18:03:10 GMT</pubDate>
            <content:encoded><![CDATA[Go言語でNetlinkを少し触ったのでメモ。具体的にはGo言語でNetlinkというネットワーク関連のライブラリを使ってStatic Routeを設定したりするサンプルを作ったりした。https://github.com/bells17/netlink-gosample Netlinkとは調べた範囲だと、Linuxカーネルのサブシステムの1つで、ルーティングテーブルの管理などのネットワーク関連の設定などを行う際に利用されるもの、という理解をしている。Netlinkは、Linuxカーネルとユーザ空間プロセス間の、またはカーネル内の通信を提供するためのIPC（Inter-pro...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Kubernetes 1.27 以降のバッチ処理の改善]]></title>
            <link>https://zenn.dev/toversus/articles/d6065bea460871</link>
            <guid>https://zenn.dev/toversus/articles/d6065bea460871</guid>
            <pubDate>Thu, 08 Jun 2023 03:46:32 GMT</pubDate>
            <content:encoded><![CDATA[Kubernetes 1.27 以降で実装済みまたは予定されているバッチ処理の改善に繋がる KEP や Kubernetes のサブプロジェクトの現状を見ていきます。 KEP-3673: Kubelet limit of Parallel Image Pulls!Kubernetes 1.27 時点でアルファ機能です。1.28 でベータを目指していますが、設定はデフォルトで無効化されています。Pod の起動にノードのスケールアウトが必要な場合に、Pod の起動時間の短縮が期待できます。バッチ処理の Pod が一斉に起動するケースで恩恵を受けられそうです。Kubelet は...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[asdf の代わりに rtx を使う]]></title>
            <link>https://blog.1q77.com/2023/06/rtx/</link>
            <guid>https://blog.1q77.com/2023/06/rtx/</guid>
            <pubDate>Wed, 07 Jun 2023 01:25:11 GMT</pubDate>
            <content:encoded><![CDATA[nodeenv とか rbenv とか tfenv とか XXenv がそれぞれ .xxx-version というファイルにそのディレクトリ配下で使用する software の version を指定するという仕様があり、それらをまとめてやってくれる asdf というツールが登場]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[お前のパケットはもう死んでいる。TCPに死亡フラグを実装してみた]]></title>
            <link>https://zenn.dev/satoken/articles/golang-rfc9401</link>
            <guid>https://zenn.dev/satoken/articles/golang-rfc9401</guid>
            <pubDate>Wed, 07 Jun 2023 00:32:17 GMT</pubDate>
            <content:encoded><![CDATA[はじめにプロトコルの仕様などIETFが発行しているRFCにはジョークRFCというものが存在しています。伝書鳩でIP通信するとか、コーヒーポットを制御するなどが有名です。鳥類キャリアによるIPHyper Text Coffee Pot Control Protocol (HTCPCP/1.0) 日本語訳今年そんなジョークRFCに、TCPに死亡フラグを実装するというRFC9401が追加されました。The Addition of the Death (DTH) Flag to TCP 日本語訳この記事ではこのTCPに死亡フラグを実装するというRFC9401を真面目に実装してみ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[OpenAI API を利用して Terraform から構成図っぽい Mermaid を出力してくれるコマンドを作った話]]></title>
            <link>https://sreake.com/blog/mermaid-with-openai-api/</link>
            <guid>https://sreake.com/blog/mermaid-with-openai-api/</guid>
            <pubDate>Tue, 06 Jun 2023 02:44:12 GMT</pubDate>
            <content:encoded><![CDATA[前段 Sreake事業部の橋本です。 ChatGPTで話題のOpenAIのモデルは、現在画像の取り扱いはまだ発展途上です。文章から画像を作るAPIや画像入力が検討されていますが、システム運用にクリティカルに使えそうになる […]The post OpenAI API を利用して Terraform から構成図っぽい Mermaid を出力してくれるコマンドを作った話 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Redis公式のGoクライアントライブラリrueidisを試してみた]]></title>
            <link>https://qiita.com/bayobayo0324/items/8ac3e27eef360a316ad2</link>
            <guid>https://qiita.com/bayobayo0324/items/8ac3e27eef360a316ad2</guid>
            <pubDate>Wed, 31 May 2023 12:02:25 GMT</pubDate>
            <content:encoded><![CDATA[This 記事 is 何？Twitterぼんやり見てたらRedis公式のGo用クライアントライブラリが出てたとかで、自身のプロジェクトにどの程度簡単に入れられるのかなーと思い試してみました。公式…]]></content:encoded>
        </item>
    </channel>
</rss>