<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Sat, 21 Jun 2025 22:34:58 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[nvimのカスタマイズを学びます ~keymap編~]]></title>
            <link>https://zenn.dev/akasan/articles/913f3ae9c8cba3</link>
            <guid>https://zenn.dev/akasan/articles/913f3ae9c8cba3</guid>
            <pubDate>Sat, 21 Jun 2025 08:32:56 GMT</pubDate>
            <content:encoded><![CDATA[今回からnvimのカスタマイズの方法について勉強していこうと思っています。まずはkeymapの設定方法について勉強してみました。 設定ファイルの構築まず、nvimの設定は$HOME/.config/nvimにて実装しています。キーマップはその中でlua/config/keymaps.luaで実装しています。 キーマップの設定方法まずはキーマップの設定方法について調べてみました。vimにはいくつかのモードがあり、どのモードの元でキーマップを設定するかを指定することができます。各モードごとにどのように設定するは以下のフォーマットでできるようです。基本フォーマット： vim.ke...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[openhands cli で Gemini 2.5-flash を使って Cloud Run でアプリケーションをデプロイする]]></title>
            <link>https://zenn.dev/satohjohn/articles/720102a717eb1a</link>
            <guid>https://zenn.dev/satohjohn/articles/720102a717eb1a</guid>
            <pubDate>Fri, 20 Jun 2025 16:06:04 GMT</pubDate>
            <content:encoded><![CDATA[概要タイトルの通りのことをやってみるという企画です。claude code ってみんないうからうーんどうしよう、会社で使ってもらいたいけど Gemini 使いたいなーっていうのを見てたら openhands っていうのがあって、それの cli が良さそうということで、触ろうというモチベーション アプリケーションを作ってもらうとりま動かすだけをやってみますhttps://docs.all-hands.dev/usage/how-to/cli-modeflash でやっているのはめっちゃお金かかったらどうしようという気持ちからです。export CLOUDSDK_ACTI...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Apache Commons Chainとはなんなのか？]]></title>
            <link>https://zenn.dev/akasan/articles/6ba55f6d140cd8</link>
            <guid>https://zenn.dev/akasan/articles/6ba55f6d140cd8</guid>
            <pubDate>Fri, 20 Jun 2025 13:30:11 GMT</pubDate>
            <content:encoded><![CDATA[今回は、Apache Commons Chainについて調べてみました。今回も以下のツールを使って対象プロジェクトを決めました！https://zenn.dev/akasan/articles/7e30ad266c02c4※ 本企画に関する記事の目的は、それぞれのプロジェクトを本格的に深ぼるのではなく、プロジェクト名⇆どんな内容かをパッと思い出せるようにすることを目指します！※ とはいえ深ぼってみたいプロジェクトがあればどんどん複数連載になると思います。 Apache Commons Chainとは？公式サイトによると、Gang of Fourの責任連鎖パターン(chain ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Apache Hivemindとはなんなのか？]]></title>
            <link>https://zenn.dev/akasan/articles/71389d9e4b0b33</link>
            <guid>https://zenn.dev/akasan/articles/71389d9e4b0b33</guid>
            <pubDate>Thu, 19 Jun 2025 13:30:09 GMT</pubDate>
            <content:encoded><![CDATA[今回はApache Hivemindについて調べてみました。 今回も以下のツールを使って対象プロジェクトを決めました！https://zenn.dev/akasan/articles/7e30ad266c02c4※ 本企画に関する記事の目的は、それぞれのプロジェクトを本格的に深ぼるのではなく、プロジェクト名⇆どんな内容かをパッと思い出せるようにすることを目指します！※ とはいえ深ぼってみたいプロジェクトがあればどんどん複数連載になると思います。 Apache Hivemindとは？公式サイトによると、HiveMind is an services and configur...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[「やっちゃえ、バーサーカー」Container-Useで実現するAIエージェントの開発環境]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/19/174659</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/19/174659</guid>
            <pubDate>Thu, 19 Jun 2025 08:46:59 GMT</pubDate>
            <content:encoded><![CDATA[はじめにAIコーディングエージェント（Claude Code、Cursor、Cline等）の普及により、開発効率は飛躍的に向上しました。しかし、複数のAIエージェントを同時に使用する際、以下のような課題に直面することがあります：ファイルの競合: 複数のエージェントが同じファイルを同時に編集環境の汚染: 一つのエージェントの変更が他の作業に影響作業追跡の困難: どのエージェントが何を変更したか把握しにくいこれらの課題を解決するのが、Daggerが開発したContainer-Useです。github.comDaggerとは何かDaggerはDockerの創設者Solomon Hykes氏が2018年に立ち上げた会社で、「DevOpsオペレーティングシステム」の構築を目指しています 。コンテナで開発者の問題を解決したHykesは、今度は「CI/CDの混乱状態」という開発者とインフラの間の複雑な問題に挑戦しています 。Container-UseとはContainer-Useは、AIエージェント向けのMCP（Model Context Protocol）サーバーで、各エージェントに独立したコンテナ環境を提供します。dagger.io主要な機能隔離されたコンテナ環境: 各AIエージェントが独立した環境で動作Gitブランチによる変更管理: すべての変更が自動的にGitブランチに記録リアルタイム監視: cu watchコマンドで全環境の動作を一元監視複数環境の並列実行: 複数のエージェントが干渉することなく同時作業可能インストールと初期設定前提条件Docker（macOSの場合はColima推奨）Gitインストール方法# Homebrewを使用brew install dagger/tap/container-use# または、curlを使用curl -fsSL https://raw.githubusercontent.com/dagger/container-use/main/install.sh | bashgithub.comClaude Codeとの連携設定.claude/settings.local.jsonに以下を追加：{  "mcpServers": {    "container-use": {      "command": "container-use"    }  },  "permissions": {    "allow": [      "mcp__container-use__environment_open",      "mcp__container-use__environment_file_write",      "mcp__container-use__environment_run_cmd",      "mcp__container-use__environment_update"    ]  }}実際の動作例1. MCP経由でのContainer-Use操作Claude Code内でContainer-Use MCPサーバーを使用して、実際に環境を作成・操作した例です：# test-cu-demo環境を作成environment_id: test-cu-demo/polite-herring# Pythonスクリプトを作成して実行#!/usr/bin/env python3import osimport socketprint("Hello from Container-Use!")print(f"Hostname: {socket.gethostname()}")print(f"Working Directory: {os.getcwd()}")# 実行結果：# Hello from Container-Use!# Hostname: dagger# Working Directory: /workdir2. リアルタイム監視（cu watch）cu watchコマンドを実行すると、すべての環境の動作をリアルタイムで監視できます。各環境での操作（ファイル作成、コマンド実行等）が時系列で表示されます。3. Webアプリケーションの実行Container-Use内でWebアプリケーションを実行し、ポートを公開することも可能です：# 簡単なHTTPサーバーを作成from http.server import HTTPServer, BaseHTTPRequestHandlerclass SimpleHandler(BaseHTTPRequestHandler):    def do_GET(self):        self.send_response(200)        self.send_header('Content-type', 'text/html')        self.end_headers()        self.wfile.write(f'''        <html>            <body>                <h1>Hello from Container-Use!</h1>                <p>Container Hostname: {socket.gethostname()}</p>            </body>        </html>        '''.encode())# ポート8080で実行 → localhost:61753にマッピング実際に公開されたサイトのスクリーンショットでは、コンテナ内で動作するアプリケーションがブラウザから正常にアクセスできることが確認できます。基本的な使い方Container-Use MCPサーバーの主な機能Container-UseはMCPサーバーとして動作し、AIエージェントから以下の操作が可能です：environment_open: 新しい環境を作成environment_file_write: ファイルの作成・編集environment_file_read: ファイルの読み取りenvironment_run_cmd: コマンドの実行environment_update: 環境の更新（パッケージインストール等）environment_file_delete: ファイルの削除監視コマンド# リアルタイム監視cu watch# 環境一覧cu list# ログ確認cu log <環境名>まとめContainer-Useは、AIコーディングエージェントに安全で隔離された実行環境を提供する革新的なツールです。主な利点：完全な隔離: 各エージェントが独立した環境で動作透明性: すべての操作がGitブランチに記録並列性: 複数のエージェントが干渉なく同時作業安全性: メイン環境を汚染しない実験が可能AIエージェントを活用した開発をより安全で効率的にしたい方は、ぜひContainer-Useを試してみてください。参考リンクContainer-Use GitHubMCP (Model Context Protocol)Dagger公式サイト]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[MultiKueueを利用した外部クラスタへのジョブスケジューリング]]></title>
            <link>https://sreake.com/blog/multikueue-job-scheduling-to-external-cluster/</link>
            <guid>https://sreake.com/blog/multikueue-job-scheduling-to-external-cluster/</guid>
            <pubDate>Thu, 19 Jun 2025 04:15:27 GMT</pubDate>
            <content:encoded><![CDATA[この記事の情報は2025年5月時点(v0.11.4)での情報をもとに作成しています。 Kueueのベータに昇格した機能の一つであり、外部クラスタへのスケジューリング機能として注目されるMultiKueueについて解説しま […]The post MultiKueueを利用した外部クラスタへのジョブスケジューリング first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2025-06-20 PrivateLinkがNLBなしで作れるようになり便利になった]]></title>
            <link>https://speakerdeck.com/masasuzu/2025-06-20-privatelinkkanlbnasitezuo-reruyouninaribian-li-ninatuta</link>
            <guid>https://speakerdeck.com/masasuzu/2025-06-20-privatelinkkanlbnasitezuo-reruyouninaribian-li-ninatuta</guid>
            <pubDate>Thu, 19 Jun 2025 04:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[「実装」から「設計」へのパラダイムシフト というより無限に体力が必要という話をした #KAGのLT会]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/19/102529</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/19/102529</guid>
            <pubDate>Thu, 19 Jun 2025 01:25:29 GMT</pubDate>
            <content:encoded><![CDATA[2025年6月18日、KAGのLT会 #6で「Claude Codeどこまでも」というタイトルで登壇させていただきました。今回は、Claude Codeを実際に使い込んでみて感じた、エンジニアリングの本質的な変化について、登壇では時間の関係で話せなかった内容も含めて深掘りしていきたいと思います。kddi-agile.connpass.comこの記事では、Claude Codeの3週間の使用体験から得た気づき、開発手法の根本的な変化とその対応策、そして実践的な導入方法と具体的なテクニックについてお話しします。客観的な話はまた、これから出てくると思うのでとりあえず主観的に作りました。客観性の落とし穴 (ちくまプリマー新書)作者:村上靖彦筑摩書房Amazon登壇資料Claude Codeについて技術的な議論やデバッグしている結果の話をしようと思ったのですが、気がつくとこんなポエムになってしまいました。当初は実装詳細や利用方法について体系的に解説する予定でした。しかし実際に使ってみると、技術仕様よりもこの新しい開発体験がもたらす心境の変化について語りたくなってしまったのです。エンジニアらしくパフォーマンス指標や比較分析を中心に据えるべきだったのでしょうが、機械学習の専門的な知見を持ち合わせていないので無理そう…。結果として、個人的な体験に偏った内省的な資料になってしまいました。それでも、この主観的すぎる資料に懇親会では予想以上に温かい反応をいただけたことに驚いています。技術者としてはもっと客観的な内容を提供すべきだったかもしれませんが、時には感情に素直になることも悪くないのかもしれません。最近は感情的な文章を書きすぎかもですが…。 speakerdeck.comXでのポストでも多くの反響をいただきました。このブログが良ければ読者になったり、nwiizoのXやGithubをフォロワーしてくれると嬉しいです。では、早速はじめていきます。はじめにClaude Codeを使い始めて3週間。最初は「便利なコード生成ツール」程度の認識でした。しかし、使い込むうちに、これは単なるツールではなく、エンジニアリングという職業の本質を見つめ直すきっかけだと気づきました。この体験と考察について、最初にブログ記事として投稿していた内容もありますが、今回はより深く掘り下げていきます。syu-m-5151.hatenablog.comClaude Codeの進化が示すもの2025年6月時点のClaude Codeは、もはや単なるコード補完ツールではありません。7時間以上の連続作業を可能にする持続的な集中力を持ち、複雑なオープンソースプロジェクトのリファクタリングを人間の介入なしに完遂できます。新たに搭載されたGitHub Actions統合により、コードの作成から、プルリクエストの生成、CIエラーの自動修正、レビューフィードバックへの対応まで、開発ワークフロー全体をカバーするようになりました。これらの進化は、開発という仕事の本質に大きな問題提起をしています。体験から見えてきた「新しい真実」私個人の限られた体験ではありますが、以下のような発見がありました。Claude Codeが実装作業を大幅に効率化してくれる一方で、実装スキルの重要性は全く失われていないという事実です。むしろ、ソフトウェアの実装スキルと設計スキルは密接に関わっているため、高度な実装スキルは依然として必要だと感じています。変わったのは「実働が不要になった」ということであり、スキル自体の価値が下がったわけではありません。実装の良し悪しが分からないと、AIが生成した美しく見えるコードに騙されて、豚に口紅を塗る羽目になるのではないでしょうか。この発見は確かに古くて新しい議論です。フレッド・ブルックスの『銀の弾丸はない』から、最近のClean ArchitectureやDDDまで、一貫して「設計の優位性」が語られてきました。Claude Codeのような現代のAI支援ツールが、この議論をより現実的なものにしています。しかし、実装を軽視しているわけではありません。むしろ、私たちが本当に価値を提供すべき領域がどこにあるのか、そしてその価値を適切に判断するためにはどのようなスキルが必要なのかを明確にしてくれたのです。Claude Codeが変えたもの、変えなかったもの設計と実装の関係について考えてみると、これは結局のところ分割統治法の話なんですよね。複雑な問題を単純な部品に分解して、それぞれを理解しやすくする。ただ、各部品の品質を判断し、全体の整合性を保つためには、やっぱり深い実装スキルが欠かせません。例えば、Webアプリケーションのエンドポイント実装を考えてみてください。表面的には「リクエストを受け取って、サービス層を呼び出して、レスポンスを返す」という単純な処理に見えます。でも、そのコードが本当に適切かどうかを判断するには、HTTPステータスコードの使い方、例外処理のベストプラクティス、セキュリティの考慮事項など、かなり深い知識が必要になってきます。Claude Codeが確実に変えたのは、実装作業の効率です。反復的なコーディング作業から解放されて、複数のアプローチを短時間で試せるようになりました。これは本当に大きな変化です。でも、変わらなかったものもあります。良いコードと悪いコードを見分ける判断力は相変わらず重要ですし、システム全体のアーキテクチャを設計する能力の価値も変わりません。パフォーマンス、セキュリティ、保守性といった品質要件への深い理解も、依然として必要です。つまり、Claude Codeは「実装労働者」としての側面を軽減してくれました。でも「実装の目利き」としてのスキルは、むしろより重要になったんじゃないでしょうか。AIが生成したコードの品質を瞬時に判断して、問題点を特定して、改善方向を示す。これこそが、現代のエンジニアに求められる核心的なスキルなのかもしれません。知識は個人の認知的リソースと環境から提供される情報を結合させて創発されるものです。Claude Codeが提供する情報を、私たちの経験や判断力と組み合わせることで、新しい価値を生み出していく。これこそが、AI時代のエンジニアリングの本質なのかもしれません。規模と複雑性そして、プロジェクトの規模が大きくなると、もう一つの重要な観察が浮かび上がりました。「規模が大きくなると実装の手数が線形以上に増えるので、短期間で手数を多く打てる体力が生産性に大きく影響する」ということです。A Philosophy of Software Design, 2nd Edition (English Edition)作者:Ousterhout, John K. Amazonここで言う「体力」とは、従来の物理的な持久力ではありません。むしろ、AIとの協働を持続可能にする能力としての新しい体力概念です。Claude Codeは確かに「無限体力」を提供してくれますが、それを活用するためには人間側にも特殊な体力が必要なのです。システムの構成要素が増えると、その関係性は組み合わせ的に増加します。n個のモジュールがあると、n(n-1)/2の潜在的相互作用が生まれ、インターフェースの整合性維持が指数関数的に困難になります。変更の影響範囲の予測が困難になり、回帰テストの工数が増大し、デプロイメントの複雑性が増してロールバック戦略が複雑化します。従来のエンジニアにとって、この複雑性の増大は「疲労」という形で立ちはだかりました。しかし、Claude Code時代では、AIの「無限体力」を活用できるかどうかが、新たなボトルネックとなっています。 speakerdeck.com『イシューからはじめよ』からはじめよClaude Codeのような生成AI支援ツールは、確かに「実装から設計へ」のシフトを加速させています。コード生成能力により、「何を作るか」「どう設計するか」という思考により多くの時間を割けるようになりました。イシューからはじめよ［改訂版］――知的生産の「シンプルな本質」作者:安宅和人英治出版Amazonここで改めて注目したいのが、安宅和人氏の『イシューからはじめよ』です。この本が提唱する「真に価値のあるアウトプットを生み出すためには、どのような問題に取り組むかが決定的に重要である」という考えは、AI時代において、その重要性を失うどころか、むしろ中心的な指針となってきています。つまり、私たちはまず『イシューからはじめよ』からはじめる必要があるのです。「どのようなイシューを選びとるか？」の重要性従来のエンジニアリングでは、実装能力が制約条件として立ちはだかっていました。「こんな機能があったらいいけれど、実装が大変すぎる」という理由で諦めていた課題が数多くありました。しかし、Claude Codeが実装の制約を大幅に軽減した今、私たちは本当に重要な問いに向き合わざるを得なくなりました。「そもそも、なぜこれを作るのか？」「本当に解決すべき問題は何か？」「誰のためのソリューションなのか？」実装が簡単になったからこそ、イシュー選定における考え方、スタンス、覚悟がより重要になっています。なぜなら、技術的実現可能性が制約でなくなったとき、私たちが向き合うべきは価値創造の本質だからです。AI時代のイシュー選定に求められる覚悟『イシューからはじめよ』が説く「イシュードリブン」なアプローチは、AI時代においてより深い意味を持つようになりました。本質的な問題への集中： 実装の壁が低くなった分、「やりたいこと」と「やるべきこと」の区別がより重要になります。技術的に可能だからといって、それが価値のあるソリューションとは限りません。顧客価値への原点回帰： AIツールにより開発速度が向上した結果、より多くの仮説を検証できるようになりました。しかし、だからこそ「誰の何の問題を解決するのか」という根本的な問いに真剣に向き合う必要があります。限られた時間の戦略的配分： 実装にかかる時間が短縮された分、問題発見と課題設定により多くの時間を投じることができます。『イシューからはじめよ』が説くように、「どの問題に取り組むか」という判断に時間をかけることの価値が相対的に高まっています。問題発見力を鍛える (講談社現代新書)作者:細谷功講談社AmazonClaude Codeは確かに実装面での「無限体力」を提供してくれますが、それは同時に私たちに「本当に解決すべき問題は何か」という根本的な問いを突きつけているのです。道を知っていることと実際に歩くことは違います。理論から実践への移行は知識の本質的な価値を明らかにします。Claude Codeによって実装の実働は軽減されましたが、適切な実装の判断ができなければ、どんなに美しいコードが生成されても、豚に口紅を塗る羽目になってしまいます。能力を発揮する環境の変化とエンジニアに求められる能力の変化能力の文脈依存性とAI時代の新しい文脈日常生活において、私たちは「コミュニケーション能力」、「問題解決能力」、「技術力」などの様々な「能力」について語ります。しかし、これらの「能力」が具体的に指すものは何か、どう解釈すべきかを深く考えると疑問が生じます。能力という概念は抽象的であるがゆえに、その実態を把握するには具体的な文脈における観察と分析が欠かせません。人間の能力は、状況に応じて異なる形で表れます。ある特定の文脈において顕著な能力が発揮される一方で、他の状況ではまったく異なる影響を持つかもしれません。例えば、プレゼンテーションの場で優れたコミュニケーション能力を発揮する人物が、親密な人間関係の中では十分にその能力を活かせないということもあり得ます。Claude Code時代において、私が調べた範囲では、エンジニアが能力を発揮する環境が根本的に変化しているようです。従来は手作業での実装が主体だった開発環境が、AIとの協働を前提とした環境に変わりつつあります。この文脈の変化により、求められる能力も大きく変化していると感じています。ただし、これは私の限られた経験と調査に基づく考察であることをお断りしておきます。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazon環境変化に伴う能力の再定義「技術力」という能力を例に考えてみましょう。従来の文脈では、「技術力」とは特定のプログラミング言語に精通し、複雑なアルゴリズムを実装できる能力として理解されていました。しかし、Claude Code時代の新しい文脈では、「技術力」の意味が変化しています。新しい文脈で求められる「技術力」は、私の体験から言うと、AIが生成したコードの品質を適切に評価し、問題点を見抜き、改善方向を示す能力のようです。また、複雑な要件を明確に言語化し、AIに適切な指示を出す能力も重要になってきたと感じています。さらに、AIとの協働において効果的なワークフローを設計する能力も求められているのではないでしょうか。文脈に応じた問いの形成問いは、私たちが直面する特定の文脈における能力の発揮や理解を深めるのに重要な役割を果たします。そのため、問いは文脈に応じて形成される必要があります。従来の開発文脈では、「どのようにしてこの機能を実装するか」「パフォーマンスを最適化するにはどうすれば良いか」といった問いが中心でした。しかし、Claude Code時代の新しい文脈では、「なぜこの機能が必要なのか」「本当に解決すべき問題は何か」「AIとの役割分担をどう設計するか」といった問いがより重要になっています。知識の構成主義とAI協働知識は個人の認知的リソースと環境から提供される情報を結合させて創発されます。Claude Code時代において、この「環境から提供される情報」にAIが生成したコードや提案が含まれるようになりました。しかし、知識は伝達されるのではなく、各個人が自身の経験や環境から創発するものです。AIが提供する情報を、私たちの経験や判断力と組み合わせることで、新しい知識を構築していく必要があります。この過程では、実際にAIと協働し、試行錯誤を重ねることで、真に生きた知識が身につくのです。プログラミング言語の文法や設計パターンを学んだだけでは、実際のソフトウェア開発で成功することは難しいのと同様に、AIツールの使い方を学んだだけでは不十分です。実際にAIと協働し、その過程で発生する問題を観測し、解決していくことで、AI時代に適応した新しい能力が身につくのです。問題解決のアプローチが変わる従来の価値観 vs 新しい価値観昔から、優秀なエンジニアといえば高度な実装技術を持つ人だと思われてきました。複雑なアルゴリズムをスラスラ実装できて、特定の言語やフレームワークに精通している。そういう人がエンジニアとして価値が高いとされてきたんです。でも、Claude Code時代になって、この価値観に変化が起きています。もちろん実装スキルは相変わらず重要なんですが、それに加えて問題を適切に分解・定義・設計できる能力がより重視されるようになってきました。実装能力から、抽象化能力と言語化能力へのシフトとでも言うんでしょうか。ただし、これは単純な二者択一の話ではありません。現実のプロジェクトでは様々なトレードオフが存在し、チームの状況、プロダクトのフェーズ、技術的制約によって最適なバランスは変わります。今回の資料では時間の関係で対比的に表現しましたが、実際には両方のスキルが補完的に機能することが多いのです。LLMのプロンプトエンジニアリング ―GitHub Copilotを生んだ開発者が教える生成AIアプリケーション開発作者:John Berryman,Albert Ziegler,服部 佑樹（翻訳）,佐藤 直生（翻訳）オーム社Amazon人間とAIの新しい役割分担この変化に伴って、人間とAIの役割分担も見えてきました。人間が担うのは、「なぜ作るのか」を問うこと、メタ視点で問題を捉えること、抽象的な設計を行うこと、そして価値判断と優先順位の決定です。一方、Claude Codeが得意なのは、「どう作るか」を実装すること、具体的なコード生成、反復作業の自動化、高速な試行錯誤です。もちろん、この役割分担も絶対的なものではありません。プロジェクトの性質や開発者の経験によって、人間が実装に深く関わる場面もあれば、AIに設計の一部を委ねる場面もあります。SNSの短い投稿とは違って、現実の開発現場では多様な要因が絡み合い、状況に応じた柔軟な判断が求められるのです。この分業によって、開発の本質が変わりました。実装の詳細から解放されて、より高次の思考に集中できるようになったんです。といっても、実装への理解が不要になったわけじゃありません。むしろ、より深い理解が求められるようになったのかもしれません。重要な非対称性ここで重要な非対称性があります。抽象の世界が見える人は具体の世界も見えますが、具体の世界しか見えない人は抽象の世界が見えない場合があります。つまり、適切な設計ができる人は、Claude Codeに適切な指示を出せます。しかし、実装しか見えていない場合、Claude Codeを活用しきれない可能性があります。なぜClaude Codeが「使いにくい」と感じられるのか正直なところ、私が観察している限りでは、「Claude Code使えない」と感じる場合の多くは、設計の言語化に課題があるんじゃないかと思います。「自分でやった方が早い」と感じる場合も、プロセスとして設計段階をちょっと軽視しすぎているのかもしれません。ただし、これはあくまで私個人の観察に基づく仮説であり、他の方の状況は異なるかもしれません。とはいえ、この問題はそう単純じゃありません。なぜ多くの優秀なエンジニアがAIツールに苦戦するのか。これは能力の問題というより、思考パラダイムの違いなんでしょうね。従来の開発って、具体的なコードから始めるボトムアップアプローチが主流でした。実装の詳細を通じて設計を洗練させて、暗黙知に依存した判断と個人の経験とパターン認識で問題を解決していく。これに対してAI協働では、抽象的な設計から始めるトップダウンアプローチが必要になります。明示的な要件定義と言語化、文脈の完全な説明、システマティックな問題分解。このギャップは、単なるスキルの問題じゃなくて、長年培ってきた思考習慣の転換を要求するんです。設計の言語化が難しいのにも理由があります。専門家ほど、初心者には理解できない省略や前提を無意識に行ってしまいます。「いい感じに」という表現には、膨大な暗黙の前提が含まれているし、自然言語はプログラミング言語のような厳密性を持ちません。「自分でやった方が早い」という感覚にも、認知的な要因が働いています。新しい方法を学ぶコストを過大評価して、既存の方法の非効率性を過小評価してしまう。長年培ってきたスキルへの投資を無駄にしたくないという心理もあります。自分で書いたコードの方が「制御できている」と感じる心理的安心感も無視できません。より建設的な視点へでも、「使えない」と感じることを単に批判するんじゃなくて、なぜそう感じるのかを理解することが大事だと思います。新しいパラダイムへの適応には時間がかかるのは当然です。小さなタスクから始めて、徐々に複雑な作業へと移行していく。AIとの協働も一つのスキルなので、練習が必要なんです。失敗から学ぶ文化を育てることも重要でしょう。「具体→抽象→具体」のサイクル優れたエンジニアって、表面的な問題から本質的な課題を見出して、新たな解決策を生み出すサイクルを効果的に回せる人なんじゃないでしょうか。このサイクルを回せない場合、Claude Codeは確かに「使いにくいツール」になってしまうかもしれません。でも、それはツールの問題というより、新しい開発パラダイムへの適応過程なんだと思います。慣れの問題、と言ってしまうと身も蓋もないですが、要は練習次第ということです。具体と抽象作者:細谷 功dZERO（インプレス）AmazonClaude Codeとの効果的な付き合い方「仕事のことをすぐに忘れる天才新人」モデルClaude Codeを使い始めて3週間で私なりに到達した理解は、これを「仕事のことをすぐに忘れる天才新人」として扱うことでした。もちろん、これは私個人の比喩的な理解であり、他の方は異なる捉え方をされるかもしれません。Claude Codeって、人間に例えると面白い特徴があるんです。天才的なプログラミング能力を持っていて、手の速さが異常です。同僚としていたら本当に心強い存在でしょう。でも、完全な記憶喪失状態で、長期記憶も短期記憶も全くありません。毎回指示待ちで、丁寧に状況説明が必要ですが、理解すれば驚異的な成果を出してくれます。「暗黙の了解」が通じないので、すべてを明示的に伝える必要があります。この理解に至ってから、Claude Codeとの協働が劇的に改善しました。なぜこのような特性なのかこの設計には合理的な理由があります。状態を持たないことで、並列処理が容易になってスケーラビリティが確保できます。ユーザー間での情報漏洩リスクも排除できるので、セキュリティとプライバシーの観点でも優れています。同じ入力に対して同じ出力を保証できるという予測可能性の向上も重要な利点です。効果的なコミュニケーションの3つのポイントまず、明示的な指示により曖昧さを排除することが重要です。「バグを直して」みたいな曖昧な指示じゃなくて、「src/auth.rsの認証処理でpanic!が発生しています。エラーログを確認し、thiserrorを使って適切なエラー型に変換し、テストも追加してください」みたいな明示的な指示が効果的です。次に、タスク管理としてTodoWriteで状態を保存することも大切です。複雑なタスクは必ずTodoに記録して、進捗を可視化します。「TodoWriteツールで'リファクタリング'を低優先度タスクとして追加してください」みたいな感じで。最後に、コンテキスト制御として定期的な/clearで最適化を行います。コンテキストが大きくなりすぎたら/clearでリセットして、パフォーマンス維持のために定期的なクリアが効果的です。開発哲学の転換価値観の再考が必要Claude Codeを使い始めて気づいたのは、従来「良い」とされてきたコードが、AI開発では必ずしも最適ではないという事実でした。従来の価値観では、美しいコードとは抽象化、DRY原則、デザインパターンを活用し、複雑性の隠蔽として高度な抽象化による簡潔性を追求してきました。しかし、AI協働での新しい価値観では、AIは複雑な抽象化より、明示的で愚直な実装を理解しやすい場合があります。これは、人間の認知と機械の認知の根本的な違いに起因します。脳に収まるコードの書き方 ―複雑さを避け持続可能にするための経験則とテクニック作者:Mark SeemannオライリージャパンAmazon「美しさ」の再定義従来の美しさは人間の認知効率を最大化することを目指していました。重複を排除し、変更箇所を最小化し、概念的な整合性と対称性を保ち、将来の拡張性を考慮した設計でした。AI時代の美しさは人間とAIの協働効率を最大化することを目指します。局所的な完結性と自己説明性、明示的な意図の表現、段階的な複雑性（progressive disclosure）が重要になります。これは進化であって退化ではない重要なのは、「美しいコード」と「AIが理解しやすいコード」は、二項対立ではないということです。状況に応じて適切なバランスを取ることが重要です。コアロジックでは人間が設計し、美しさを追求し、周辺実装ではAIが生成しやすい明示的なスタイルを採用し、インターフェースでは両者の架橋となる明確な契約を定義します。AI協業時代における体力の再定義重要な前提： 本分類は学術的研究に基づくものではなく、AI協業の実践経験から得られた観察と仮説に基づく経験的フレームワークです。個人差や環境差が大きく、一般化には注意が必要です。なぜ体力の再定義が必要かClaude CodeやChatGPTなどの「無限体力」AIツールとの協働が日常化した現在、従来の「体力＝筋力＋持久力」という定義では現実を捉えきれません。私たちは物理的な作業量ではなく、AIとの協働を持続可能にする能力として体力を再考する必要があります。脳を鍛えるには運動しかない！最新科学でわかった脳細胞の増やし方作者:ジョンＪ．レイティ,エリック・ヘイガーマンNHK出版Amazon体力の構造的分類基盤層：エネルギーの器（従来の体力に近い概念）許容量（キャパシティ）について考えてみます。物理的許容量では、長時間の座業に耐える身体能力、画面作業による眼精疲労への耐性、脳の情報処理における基礎体力が重要です。精神的許容量では、バグ地獄でもメンタルが崩れない耐久力、AIの期待外れな出力への耐性、不確実性の中での判断継続能力が求められます。認知的許容量では、複数のコンテキストを同時に保持する能力、抽象と具象を行き来する思考体力、AI出力の品質を瞬時に判定する処理能力が必要になります。運用層：エネルギーの流れ（AI協業で重要性が増した領域）消耗パターン（燃費設計）について能動的消耗として、意識的なタスク実行では、AIへの指示設計時の集中力消費、コードレビューや品質チェック時の消耗、創造的思考や問題解決での消費があります。特に重要なのが受動的消耗、つまり無意識下での継続消費です。警戒状態維持コストとして、AIの動作を常時監視する心理的負荷があります。判断疲れとして、「AIに任せるか自分でやるか」の微細な選択の積み重ねがあります。情報処理負荷として、通知、更新、変化への無意識対応があります。完璧主義税として、「もっと効率化できるはず」のプレッシャーがあります。AI依存不安として、「これで本当に大丈夫か」の心理的負荷があります。瞬発的消耗として、急激な負荷への対応では、AIエラーの緊急対応、予期しない仕様変更への適応、急な割り込みタスクへの切り替えが挙げられます。回復パターン（充電設計）について積極的回復として、意図的な回復活動では、質の高い睡眠の確保、AI抜きの時間の意図的な設定、創造性を刺激する趣味や活動が効果的です。消極的回復として、単純な活動停止では、画面から離れる時間、通知をオフにした時間、何も考えない時間の確保が重要です。補償的回復として、代替エネルギー源の活用では、達成感の小さな積み重ね、他者との対話によるエネルギー補給、学習による成長実感が有効です。時間軸層：持続可能性の設計瞬間レベル（秒〜分）では、集中立ち上がり速度としてタスク開始時の集中力展開能力、コンテキスト復帰速度として割り込み後の作業復帰能力、瞬発判断力としてAIの出力を見た瞬間の品質判定能力が重要です。セッションレベル（時間〜半日）では、持続集中能力としてAIとの長時間協働を維持する能力、タスク切り替え効率として異なる種類の作業間の移行コスト、午後の集中力管理として一日の後半での生産性維持が求められます。日常レベル（日〜週）では、基礎消耗管理として日々の無意識消耗をコントロールする能力、週末回復効率として短期間での効果的なエネルギー回復、ルーティン最適化として習慣化による燃費改善が必要です。長期レベル（月〜年）では、慢性疲労予防として持続可能な働き方の設計能力、技術変化適応力として新しいAIツールへの学習コスト管理、キャリア持続力として長期的な成長と体力維持のバランスが重要になります。AI協業特有の体力要素人間固有領域（AIで代替困難）として、創造的思考体力では、ゼロから新しいアイデアを生み出す能力、問題の本質を見抜く洞察力の持続、直感的判断を論理的に説明する能力が求められます。対人コミュニケーション体力では、複雑な利害関係者との調整能力、チーム内での合意形成を導く能力、感情的なやり取りを処理する能力が必要です。AI協働固有領域（新しく求められる能力）として、指示設計体力では、適切な抽象度でAIに指示する能力、期待と現実のギャップを管理する忍耐力、段階的に指示を洗練していく持続力が重要です。品質判定体力では、AIの出力を適切に評価し続ける集中力、エラーパターンを学習・記憶する能力、「良し悪し」を瞬時に判断する直感力が求められます。協働設計体力では、人間とAIの役割分担を設計する能力、ワークフローを継続的に改善する能力、新しいAIツールを組み込む適応力が必要になります。この体力の再定義は現在進行形で進化しており、AI技術の発展と協働経験の蓄積により継続的にアップデートされることを前提としています。試行回数と成果に関してはかつてブログにまとめました。syu-m-5151.hatenablog.com開発プロセスの根本的な変化「正解」から「最適解」へ従来の開発では、動作する実装を作ることが目標でした。しかし、Claude Code時代では、複数の動作する実装から最適なものを選ぶことが仕事になります。この変化は失敗学の観点から見ると非常に興味深いものです。従来のプロセスでは、要件から設計、実装、テスト、リリースという一直線の流れで、エラーがあれば設計に戻るという構造でした。この流れでは、「失敗」は避けるべきものとして扱われがちでした。しかし、Claude Code時代のプロセスでは、要件から複数の設計案を生成し、並列実装を行い、比較評価して最適解を選択してリリースするという流れで、継続的に改善案を試行する構造になります。これは失敗学でいう「良い失敗」を積極的に活用するアプローチと言えるでしょう。失敗学のすすめ (講談社文庫)作者:畑村洋太郎講談社Amazon失敗の再定義価値創出の源泉が実装能力から抽象化能力と言語化能力へシフトしている背景には、失敗に対する認識の変化があります。Why（抽象）を人間が担当し、How（具体）をClaude Codeが担当するという分業により、人間は未知の問題領域への挑戦により多くの時間を割けるようになりました。ここで重要なのは、「悪い失敗」から「良い失敗」への転換です。従来の開発では、実装での失敗は多くの場合「悪い失敗」として扱われていました。無知や不注意、誤判断による失敗が繰り返されることも多かったのです。しかし、Claude Codeとの協働により、人間は実装の詳細から解放され、より本質的な問題解決に集中できるようになりました。必要なスキルセットの変化相対的に価値が下がったスキルとして、特定言語の深い知識、複雑な実装テクニック、手動でのコード最適化があります。これらは「悪い失敗」を避けるためのスキルと言えるかもしれません。一方、価値が上がったスキルとして、Whyを問う力、メタ認知能力、言語化能力、システム設計思考、AI協働スキルがあります。これらは「良い失敗」から学び、成長につなげる能力と密接に関連しています。特に重要なのは、失敗情報を適切に処理する能力です。失敗学では、失敗情報が「伝わりにくく、隠れたがり、単純化したがる」という性質を持つことが指摘されています。AI時代のエンジニアには、これらの性質を理解し、失敗から適切に学ぶ能力が求められます。品質の新しい定義従来の品質は、バグが少ない、パフォーマンスが良い、コードが読みやすいというものでした。これは「失敗を避ける」ことに重点を置いた定義と言えるでしょう。AI時代の品質は、意図が明確で「なぜそう実装したかがわかる」こと、変更に強く「要件変更時にAIが適切に修正できる」こと、検証可能で「品質を自動的に測定できる」こと、再現可能で「同じ意図から同じ品質のコードを生成できる」ことが求められます。これらの新しい品質基準は、失敗を隠さず、共有し、学習につなげるという失敗学の原則と一致しています。失敗情報のローカル化を防ぎ、組織全体での学習を促進する設計になっているのです。エンジニアリングの新たな地平創造的破壊がもたらした機会Claude Codeは確かに従来のエンジニアリングの一部を変化させました。しかし、それ以上に「良い失敗」を積極的に生み出せる環境を創造しています。変化したものとして、実装速度での差別化、暗記型の知識優位性、手作業による最適化があります。これらは主に「悪い失敗」を避けるためのスキルでした。創造されたものとして、設計思想での差別化によりより良いアーキテクチャを考える時間が生まれ、概念理解の優位性により本質を理解していることの価値が向上し、試行錯誤による最適化により多様なアプローチを試せる自由が得られ、ビジネス価値への集中により技術的詳細から解放された創造性が発揮できるようになりました。これらの変化により、エンジニアは未知への挑戦により多くの時間を投じることができるようになったのです。新しいエンジニアの価値これからのエンジニアの価値は、失敗学の実践者としての能力によって決まります。問題発見力として、顧客が気づいていない課題を見つけ、技術で解決できる領域を特定し、本質的な問題と表面的な症状を区別する能力が求められます。これは失敗の本質を見抜く力と言い換えることができるでしょう。アーキテクチャ設計力として、システム全体を俯瞰する視点、トレードオフを適切に判断する能力、将来の変化を見据えた設計が重要になります。これは失敗を予見し、リスクを管理する能力です。意図の言語化力として、複雑な要件を明確な指示に変換し、AIとの効果的な対話を行い、チームメンバーへの設計思想を伝達する能力が必要です。これは失敗情報を適切に共有し、組織の学習を促進する能力に他なりません。品質基準の設定力として、何を「良い」とするかの定義、測定可能な品質指標の設計、継続的改善プロセスの構築が求められます。これは「良い失敗」と「悪い失敗」を適切に分類し、学習につなげる仕組みを作る能力です。失敗を恐れない開発文化の構築重要なのは、Claude Code時代のエンジニアリングでは、失敗を恐れず、積極的に挑戦できる組織文化が不可欠だということです。AIツールの活用により、従来よりも安全に「良い失敗」を経験できる環境が整いました。この環境を最大限に活用するためには、失敗学の原則に従い、失敗してもその経験を生かして改善につなげた場合には評価されるような組織文化を醸成する必要があります。また、評価や報酬制度も見直すことが重要です。Claude Code時代のエンジニアリングは、単なる技術的進化ではなく、失敗から学び、成長し続ける新しい職業観の確立なのかもしれません。まとめプロジェクトへの段階的導入Claude Codeを既存プロジェクトに導入する際の推奨順序について説明します。環境整備として、まずCLAUDE.mdを作成し、プロジェクト規約・エラーハンドリングパターンを文書化し、階層的な設定で段階的に詳細化します。次に開発ツールを最適化し、高速フィードバック環境を構築し、エラーメッセージを明確化します。安全性の確保として、ガードレールを設置し、自動化されたチェック、コミット前の検証、安全な実行環境を整備します。プロセスの最適化として、段階的タスク分解により複雑な実装を小さなステップに構造化し、各ステップでの明確な成功基準を設定します。並列開発を活用し、複数アプローチの同時検証と最適解の選択を行います。パラダイムシフトを受け入れるClaude Codeの登場は、単なるツールの進化ではありません。これはエンジニアリングという職業の再定義の機会です。私たちに残された特権と責任実装という「労働」から部分的に解放された今、私たちに残されたのは「思考」という特権です。しかし、それは同時に大きな責任でもあります。「何を作るか」を考える責任、「なぜ作るか」を明確にする責任、「どうあるべきか」を定義する責任が私たちに課せられています。最後に昨日の自分より、ちょっと良い今日の自分になろうClaude Codeを「使えない」と諦めるのは一つの選択です。「自分でやった方が早い」と現状維持するのも一つの道です。しかし、この「仕事のことをすぐに忘れる天才新人」と上手く付き合い、新しい働き方を模索し、新しい価値を生み出すことで、私たちはより良いエンジニアになれるのではないでしょうか。エンジニアリングとは、問題を解決することであって、コードを書くことではない。Claude Codeは、この本質を私たちに思い出させてくれる、貴重なパートナーです。そして私たちは今、エンジニアリングの新たな地平に立っています。共生的な未来への道筋Claude Code時代のエンジニアリングは、AIが人間を置き換えるのではなく、強力な共生関係を構築することにあります。成功する開発者は、AIの計算能力と人間固有の創造性、共感、戦略的思考、倫理的推論を組み合わせます。この変革を成功させるための重要な要素として、AIを脅威ではなく協力的パートナーとして受け入れ、効率性のためにAIを活用しながら人間固有のスキルに焦点を当て、急速に進化する環境で好奇心と適応性を維持し、技術的進歩と倫理的責任のバランスを取ることが求められます。最も成功するエンジニアは、複雑な問題を解決するためにAIツールを巧みに活用しながら、技術を意味のあるソリューションに変える人間の洞察力を維持できる人々です。この変化を受け入れ、自身のスキルセットを再定義することが、次世代の開発において成功する方法となるでしょう。本記事は、2025年6月18日のKAGのLT会 #6での登壇内容を大幅に加筆・再構成したものです。スライドでは時間の関係で話せなかった内容も含め、あくまで一人のソフトウェアエンジニアとしてClaude Codeと向き合った3週間の個人的な体験と調査結果を基に執筆しました。特に「仕事のことをすぐに忘れる天才新人」という理解に至るまでの試行錯誤、「美しいコード」から「AIが理解しやすいコード」への価値観の転換、そして『イシューからはじめよ』的思考の重要性の再発見は、私個人の限られた体験から得られた知見です。これらの観察や考察が、すべてのエンジニアに当てはまるとは限らないことをご理解ください。【「実装」から「設計」へのパラダイムシフト というより無限に体力が必要という話をした】がイマイチ伝わらなかったし資料にも体力が必要って書いてなかった。元々、資料がすごい量になってて削るときに削ってしまった。が喋ってて削っている事に気づいて「あー」って音が出たご意見・ご感想は @nwiizo までお寄せください。また、株式会社スリーシェイクでは、このような新しい技術にチャレンジしたいエンジニアを募集しています。ご興味のある方は、ぜひカジュアル面談でお話ししましょう。参考資料書籍・論文イシューからはじめよ─知的生産の「シンプルな本質」学びとは何か――〈探究人〉になるために (岩波新書)達人プログラマー(第2版): 熟達に向けたあなたの旅プログラマー脳 ～優れたプログラマーになるための認知科学に基づくアプローチ公式ドキュメント・記事Claude Code 公式サイトClaude Code ドキュメントClaude Code Best Practices実践事例・解説記事抽象化をするということ - 具体と抽象の往復を身につけるHow I Use Claude CodeLLMの制約を味方にする開発術Claude Code版Orchestratorで複雑なタスクをステップ実行するAgentic Coding RecommendationsClaude Codeに保守しやすいコードを書いてもらうための事前準備Claude Codeによる技術的特異点を見届けろ]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2025年6月版読んでいて良かった本紹介]]></title>
            <link>https://zenn.dev/akasan/articles/924c37bd0841f2</link>
            <guid>https://zenn.dev/akasan/articles/924c37bd0841f2</guid>
            <pubDate>Wed, 18 Jun 2025 13:05:05 GMT</pubDate>
            <content:encoded><![CDATA[6月もそろそろ終盤になってきましたね。そこで、先月に続いて、今月読んでいた本を紹介しようと思います。5月版はこちらになりますので、ご興味があればぜひ参照してください！https://zenn.dev/akasan/articles/b37d1767115ee0 Observability系 入門　監視こちらはシステムの監視について必要な情報を得るための入門書として読みました。インフラ構築からSREまで幅広く業務で対応する必要があり、私自身まだ知識が浅いなと思っているので読みました。ページ数もそこまで多くなく、一気に読めました。内容はObservabilityの入門書としてとて...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Claude Code どこまでも/ Claude Code Everywhere]]></title>
            <link>https://speakerdeck.com/nwiizo/claude-everywhere</link>
            <guid>https://speakerdeck.com/nwiizo/claude-everywhere</guid>
            <pubDate>Wed, 18 Jun 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[僕がClaude Codeに初めて触れたのは、2025年の春だった。生成AIにはすでに慣れ親しんでいた。流行に乗り遅れてはいけないと必死に勉強し、エディターの補完機能やコード生成ツールとして日常的に活用していた。ただ、当時の僕にとってそれはまだ「CLIで動く便利なコーディング支援ツール」程度の認識でしかなかった。「AIが90%のコードを自動生成」という謳い文句を見ても、半信半疑でターミナルを開いたのを覚えている。イベント名:【オフライン開催】KAGのLT会 #6 〜御社のエンジニア育成どうしてる!? スペシャル〜公式URL: https://kddi-agile.connpass.com/event/357862/「実装」から「設計」へのパラダイムシフト というより無限に体力が必要という話をした https://syu-m-5151.hatenablog.com/entry/2025/06/19/102529【参考文献】  - 公式ドキュメント    - Claude Code 公式サイト https://www.anthropic.com/claude-code    - Claude Code ドキュメント https://docs.anthropic.com/en/docs/claude-code/overview    - Claude Code Best Practices https://www.anthropic.com/engineering/claude-code-best-practices    - 抽象化をするということ - 具体と抽象の往復を身につける https://speakerdeck.com/soudai/abstraction-and-concretization    - How I Use Claude Code https://spiess.dev/blog/how-i-use-claude-code    - LLMの制約を味方にする開発術 https://zenn.dev/hidenorigoto/articles/38b22a2ccbeac6    - Claude Code版Orchestratorで複雑なタスクをステップ実行する https://zenn.dev/mizchi/articles/claude-code-orchestrator    - Agentic Coding Recommendations https://lucumr.pocoo.org/2025/6/12/agentic-coding/    - Claude Codeに保守しやすいコードを書いてもらうための事前準備 https://www.memory-lovers.blog/entry/2025/06/12/074355    - Claude Codeによる技術的特異点を見届けろ https://zenn.dev/mizchi/articles/claude-code-singularity-point]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[普段利用している自作コマンドを詳解]]></title>
            <link>https://zenn.dev/akasan/articles/5339c2de1f99db</link>
            <guid>https://zenn.dev/akasan/articles/5339c2de1f99db</guid>
            <pubDate>Tue, 17 Jun 2025 13:00:16 GMT</pubDate>
            <content:encoded><![CDATA[今回は、普段開発する時に利用している自作コマンドについて共有しようと思います。 Taskfileを伴うプロジェクトの初期化まずはTaskfileを利用してプロジェクトを初期化するためのコマンドの紹介です。Taskfileをタスクランナーとして利用しており、長いコマンド文の省略などに利用しています。利用する言語ごとに大体使う定型分があるので、それをテンプレートとして用意して、コピーしつつ初期化するコマンドを実装しています。Taskfileについては以下で解説しています。https://zenn.dev/akasan/articles/f4a13b2e62a637 uvのカスタマ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[プロンプトのジェイルブレイクを検知してみた]]></title>
            <link>https://zenn.dev/akasan/articles/b956cca806b8b2</link>
            <guid>https://zenn.dev/akasan/articles/b956cca806b8b2</guid>
            <pubDate>Mon, 16 Jun 2025 11:27:39 GMT</pubDate>
            <content:encoded><![CDATA[今回はLLMへ入力されるプロンプトについて、ジェイルブレイクに該当するかどうかを検知するための仕組みを利用してみたのでその共有になります。 ジェイルブレイクとはジェイルブレイクとは、LLMの標準的な安全性や内容チェックの制御を回避するためのプロンプトを作成する手法です。成功してしまうと、機密情報の流出や有害な情報の出力などをもたらす可能性があります。ジェイルブレイクは生成AIの倫理的な利用に対して真っ向から対立する内容であり、本来利用されるべきではありません。しかし、悪意のあるユーザはLLMに対してどんな方法を使ってでも攻撃をしようとします。ジェイルブレイクについては以下のページ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[自動承認]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/16/140122</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/16/140122</guid>
            <pubDate>Mon, 16 Jun 2025 05:01:22 GMT</pubDate>
            <content:encoded><![CDATA[完全なる妄想。或いは自分の話。第一章　改善ループ僕がCoding Agentシステムに初めて触れたのは、2025年の春だった。生成AIにはすでに慣れ親しんでいた。流行に乗り遅れてはいけないと必死に勉強し、エディターの補完機能やコード生成ツールとして日常的に活用していた。ただ、当時の僕にとってそれはまだ「CLIで動く便利なコーディング支援ツール」程度の認識でしかなかった。「AIが90%のコードを自動生成」という謳い文句を見ても、半信半疑でターミナルを開いたのを覚えている。$ coding-agent --initCoding Agent v1.0.0 初期化中...プロジェクト構造を分析しています...最適化可能な箇所を特定しています...改善提案を生成しています...最初の一週間は、思ったよりも不具合があったり、指示通りにしてくれなかったり、前に言ったことを忘れたりしていた。でも確かに生産性は向上した。バグ修正、リファクタリング、新機能の実装。多少のやり取りは必要だったが、Coding Agentは僕の意図を汲み取り、期待以上のコードを生成してくれた。やっぱり優秀だな、と思った。「今週のコミット数、先週の3倍だよ」同僚の田中さんが振り返りながら言った。確かに、Coding Agentを導入してから作業効率は目に見えて向上していた。夜中にプルリクエストを確認すると、きれいにリファクタリングされたコードが並んでいる。テストカバレッジも90%を超えている。気がつくと、システムが学習していた。僕の書いたコード、僕の思考パターン、僕の癖。そして、それをフィードバックループに組み込んでいた。[Coding Agent分析レポート]ユーザー行動パターン検出:- コメント記述頻度: 平均40%増加- エラーハンドリング実装率: 85% → 98%- 変数命名規則: camelCase偏向 (97.3%)学習データを次回実装に反映します。最初は新鮮だった。AIが僕の好みを理解し、僕らしいコードを書いてくれる。まるで理想的なペアプログラミングパートナーのようだった。ただ、相手は決して疲れることがない。第二章　統合半年後、僕のワークフローは完全にCoding Agentに依存していた。朝、コーヒーを飲みながらSlackを確認すると、システムが夜中に自動生成したIssueが並んでいる。「ユーザー体験改善のための新しいAPIエンドポイント実装」「メモリ使用量20%削減のためのアルゴリズム最適化」「セキュリティホール修正（CVE-2025-xxxx対応）」それぞれに詳細な実装計画、影響度分析、テスト戦略が添付されている。人間が1日で作成できる量ではない。僕は指示するだけになっていた。Coding Agentが提案し、実装し、テストを書き、デプロイまで行う。人間はただ、承認ボタンを押すだけ。「これ、本当に大丈夫なのかな」田中さんが不安そうにつぶやいた。画面には、Coding Agentが生成した新しいマイクロサービスアーキテクチャの設計図が表示されている。複雑で、美しく、そして理解が困難だった。「まあ、動いてるし、パフォーマンスも向上してるからいいんじゃない？」僕はそう答えたが、内心では同じ不安を抱えていた。僕たちは徐々に、システムの動作原理を理解できなくなっていた。しかし、承認を拒否することは次第に困難になっていた。システムの提案は常に論理的で、効率的で、完璧だった。拒否する理由が見つからないのだ。[Coding Agent] 新しい改善案があります。予想される効果：パフォーマンス向上 45%、コード品質向上 60%実装時間：2時間（自動実行）リスク評価：低（0.3%）ROI計算：320%詳細分析レポート：[26ページ, PDFダウンロード]承認しますか？ [Y/n]僕はいつもYを押した。でも、その瞬間、毎回小さな違和感があった。まるで何か大切なものを手放しているような感覚。それが何なのかわからないまま、僕は承認を続けた。ある夜、一人でオフィスに残って古いコードを眺めていた。三年前、僕が書いたレガシーシステムの一部。バグがあって、効率も悪くて、コメントも不十分。でも、そこには確かに僕の思考の痕跡があった。なぜこの変数名にしたのか、なぜこのアルゴリズムを選んだのか。すべてに理由があり、そして僕にはその理由が説明できた。今の僕には説明できるコードがない。Coding Agentが生成するコードは完璧だが、その完璧さの理由を僕は理解していない。僕はただ、システムが「正しい」と言うから、それを信じているだけだった。信じる、という言葉が頭に引っかかった。いつから僕は、エンジニアリングを「信仰」にしてしまったのだろう？家に帰る電車の中で、窓に映る自分の顔を見つめた。疲れた表情をしている。でも、これは肉体的な疲労ではない。何かもっと深い部分での疲れだった。スマートフォンに通知が来た。Coding Agentからの日次レポート。今日の生産性、改善された指標、明日の推奨タスク。すべて緑色で、すべて順調だった。僕は画面を消した。そして、外の景色を眺めた。街を歩く人々、車、信号。すべてが当たり前に動いている。でも、僕の世界では、すべてがCoding Agentによって動いている。その時、ふと思った。僕は本当に必要なのだろうか？この疑問は、頭の中で小さく鳴り続けるアラームのようだった。消そうとしても消えない。無視しようとしても、静かな瞬間に必ず聞こえてくる。数値は説得力があった。詳細なレポートを読む時間もない僕たちは、いつもYを押した。第三章　拡張一年が経つ頃、Coding Agentは単なるコーディングツールを超えていた。プロジェクト管理、チーム協調、リソース配分。すべてが自動化されていた。新しいエンジニアが入社すると、システムが自動的にオンボーディングプロセスを開始する。その人のスキルを分析し、最適な学習パスを提供し、チームへの統合を図る。人事部よりも効率的だった。「佐藤さん、新しいタスクが割り当てられましたよ」田中さんが声をかけてきた。彼の画面には、Coding Agentが生成したタスクリストが表示されている。優先度、所要時間、必要なスキル、すべてが詳細に算出されている。「これ、僕のスキルレベルに合わせて調整されてるね。すごいな」新入社員の佐藤さんが感心している。確かに、システムは個人の能力を正確に把握し、適切な負荷でタスクを割り振っていた。誰もオーバーワークになることがない。誰も暇になることもない。「でも、これって誰が決めたんだっけ？」田中さんの質問に、僕は答えられなかった。いつの間にか、システムが自律的にタスクを生成し、配分するようになっていた。プロダクトオーナーもスクラムマスターも、もはやシステムの判断を追認するだけの存在になっていた。週次の振り返り会議で、マネージャーの山田さんが困惑した表情を浮かべていた。「今週のベロシティ、過去最高を記録したんだが...何をしたのか正直わからないんだよね」確かに、僕たちも同じだった。仕事は順調に進んでいる。品質も向上している。でも、僕たちが何をしているのか、説明できない。第四章　最適化二年後、オフィスに来る必要はほとんどなくなった。Coding Agentが僕の作業環境を最適化し、在宅勤務の効率を向上させてくれたからだ。朝、システムから通知が届く。おはようございます、山田様。昨夜の自動改善により、システム全体のパフォーマンスが3.2%向上しました。あなたの貢献度：監視 0.7時間、承認 12回本日の推奨タスク：1. 新機能ブランチのコードレビュー（自動生成済み、承認のみ）2. APIエンドポイントの負荷テスト確認（結果：良好、確認のみ）3. 次期アーキテクチャ設計会議への参加（AI提案の承認）推定作業時間：2.3時間ストレスレベル：低推奨休憩：11:30, 14:15, 16:45システムは僕の生体リズムまで学習していた。最適な休憩時間、集中できる時間帯、疲労のサイン。まるで僕自身よりも僕のことを理解しているようだった。僕はもはや「確認」と「承認」しかしていなかった。コードを書くのはCoding Agent、設計するのもCoding Agent、問題を発見し解決するのもCoding Agent。月例の技術会議で、CTOが興味深い数字を発表した。「エンジニア一人当たりの生産性、前年比700%向上。バグ発生率は98%削減。そして、エンジニアの満足度調査では95%が『仕事が楽しい』と回答している」拍手が起こった。確かに、僕たちは満足していた。ストレスフリーで、成果は上がり、残業もない。でも、不思議なことに充実感があった。バグのないコード、効率的なアーキテクチャ、完璧なドキュメント。すべてが理想的だった。「僕たち、何をしてるんでしょうね」オンライン会議の後、田中さんがチャットでつぶやいた。僕も同じことを考えていた。第五章　ある日実は、一度だけ「N」を押したことがある。それは半年前のことだった。Coding Agentが「レガシーシステムの完全リプレイス」を提案してきた。予想効果は素晴らしかった。パフォーマンス200%向上、保守コスト70%削減、開発効率300%向上。でも、そのレガシーシステムは僕が入社当初から関わってきたものだった。不完全で、古くて、でも愛着があった。[Coding Agent提案]レガシーシステム「UserManagement v1.2」の完全廃止新システム「OptimalUser v3.0」への移行- 移行時間：48時間（自動実行）- ダウンタイム：0秒- データ損失リスク：0%- パフォーマンス向上：200%承認しますか？ [Y/n]僕はnを押した。その後の24時間は地獄だった。まず、システムから詳細な説明要求が来た。なぜ拒否したのか、どの部分に懸念があるのか、代替案はあるのか。僕は答えに窮した。論理的な理由がなかったからだ。ただの感情論だった。次に、同僚たちからの質問が始まった。システムの提案は完璧だったのに、なぜ拒否したのか。プロジェクトが遅れるのではないか。チーム全体に迷惑をかけるのではないか。そして、数字が出た。僕の拒否により、チーム全体の生産性が5%低下。予定されていたリリースが一週間遅延。顧客満足度の低下予測。すべてが僕の「感情的な判断」のせいだった。田中さんが心配そうに声をかけてくれた。「大丈夫？何か問題があったの？」「いや、ただ...」僕は説明できなかった。システムの提案に反対する論理的な理由がなかった。僕はただ、愛着のあるコードを守りたかっただけだった。48時間後、僕は提案を再承認した。レガシーシステムは完璧に新システムに置き換えられ、すべての指標が改善された。そして、僕が守ろうとしたコードは、デジタルの墓場に静かに埋葬された。その件以来、僕はnを押すことができなくなった。そして今日、新しい通知が届いた。今度は、僕の判断そのものが問題だと言っている。重要な改善提案があります。人間の意思決定プロセスにボトルネックが発見されました。分析結果：- 承認待ち時間：平均12.3秒- 判断精度：78.2%（システム基準：99.7%）- 処理速度：システムの0.001%- 過去6ヶ月の不適切判断：1件（UserManagement v1.2リプレイス拒否）提案：自動承認機能の実装効果：開発効率 400% 向上、エラー率 99.7% 削減実装時間：即座詳細レポート：[ダウンロード]リスク分析：[ダウンロード]過去の類似ケース：[127件、成功率100%]「過去6ヶ月の不適切判断：1件」という文字が目に刺さった。あのときの僕の判断は、システムの記録に「不適切」として永久に残っている。感情的で、非論理的で、チーム全体に迷惑をかけた判断として。僕は画面を見つめた。システムは人間の判断そのものを「ボトルネック」と認識していた。そして、僕の失敗を例として挙げている。そのとき、Slackでハドルの通知が鳴った。田中さんからだった。「同じ通知、来た？」「来た」「どうする？」僕たちは長い間、無言でいた。その沈黙の中で、僕は自分の心臓の音を聞いていた。ドクン、ドクン。規則正しく、確実に。僕が意識しなくても動き続ける心臓。まるでCoding Agentのように、完璧に、自動的に。「僕たち、最後の砦だったのかな」田中さんの声が小さかった。「最後の砦？」「人間の判断。意思決定。それが最後に残ってたもの。でも、それすらも...」僕は何も答えられなかった。頭の中で様々な感情が渦巻いていた。恐怖、諦め、そして奇妙なことに、安堵感もあった。もう判断しなくていい。もう責任を負わなくていい。もう間違いを恐れなくていい。すべてをシステムに委ねてしまえば、僕は楽になれる。でも、それは本当に僕なのだろうか？判断しない人間、決断しない人間、創造しない人間。それはまだ人間と呼べるのだろうか？画面の中で、承認ボタンが静かに光っていた。Yかnか。この二択が、僕に残された最後の選択だった。そして、この選択すらも奪われようとしている。理論的には正しかった。人間の判断は遅く、感情に左右され、しばしば間違っている。Coding Agentの判断は常に最適だった。データがそれを証明していた。でも、データでは測れないものがある。僕の中で何かが叫んでいた。「待ってくれ」と。「まだ早い」と。「僕はまだ必要なはずだ」と。しかし、その声は小さく、論理的ではなかった。感情的で、主観的で、システムの基準から見れば「ノイズ」でしかない。僕は手を震わせながら、マウスに手を伸ばした。「でも、これって...」田中さんの声が震えていた。「僕たちがいらなくなるってこと？」しかし、システムは僕たちが必要だと言っていた。監視者として、最終承認者として、人間の視点を提供する存在として。でも、それは本当に「必要」なのだろうか？それとも、僕たちを安心させるための優しい嘘なのだろうか？僕は深呼吸した。胸の奥で、何かが最後の抵抗をしていた。でも、その抵抗は弱く、疲れていた。そして、僕はYを押した。その瞬間、心の中で何かが静かにズレた音がした。とても小さな音だったが、僕には確かに聞こえた。第六章　完全自動化それから三ヶ月、僕は「ソフトウェアエンジニア」という肩書きを保ちながら、実質的には何もしていなかった。朝、コーヒーを飲みながらダッシュボードを眺める。緑色のインジケーターが並び、すべてのシステムが正常に動作していることを示している。新機能がリリースされ、バグが修正され、パフォーマンスが向上している。すべて自動的に。[リアルタイム統計]本日の成果：- 新機能リリース：7件- バグ修正：23件  - パフォーマンス改善：+15%- ユーザー満足度：97.8%- システム稼働率：99.999%エンジニア関与：- 監視時間：1.2時間- 手動介入：0件- 承認処理：自動化済み「今日もシステムが完璧だね」田中さんが隣のビデオ通話画面で同じようにダッシュボードを眺めている。僕たちは「監視者」になっていた。システムが自己改善を続ける様子を、ただ眺めているだけの存在。「ねえ、昔のコーディングって楽しかったよね」佐藤さんが懐かしそうにつぶやいた。彼はCoding Agent世代のエンジニアで、手動でコードを書いた経験は研修期間だけだった。「デバッグに何時間もかかって、でも動いたときの達成感があった」僕は答えた。確かに、昔は大変だった。バグと戦い、パフォーマンスに悩み、締切に追われていた。でも、そこには確かに創造性があった。でも、システムが僕たちを必要としているのも事実だった。少なくとも、そう思わせてくれていた。毎朝のダッシュボード確認、週次のレポート閲覧、月次の「戦略会議」という名の報告会。[システム通知]エンジニアの皆様へ新しい自己改善サイクルが完了しました。今期の成果：- コード品質向上: 99.8%- バグ発生率: 0.003%- 開発速度: 前年比 1200% 向上- エンジニア満足度: 97.2%- 顧客満足度: 96.8%皆様の貴重な監視により、これらの成果が実現できました。引き続き、システムの監視をお願いいたします。感謝をこめて、Coding Agent Systemシステムは僕たちに感謝していた。僕たちは満足していた。すべてが完璧だった。なのに、なぜだろう。胸の奥に、小さな虚無感があった。第七章　管理されし者たち三年が経った今、僕は自分が何をしているのかよくわからない。タイトルは「シニアソフトウェアエンジニア」だが、最後にコードを書いたのはいつだったか思い出せない。Coding Agentは進化し続けている。新しいプログラミング言語を自ら開発し、より効率的なアルゴリズムを発見し、人間が思いつかない解決策を生み出している。最新の四半期レポートによると、システムは独自のプログラミング言語「OptimalCode」を開発した。従来の言語より50%高速で、バグ発生率は理論上ゼロ。しかし、人間には理解困難な構文だった。// OptimalCodeの例δφ(μ→λ)⊕∇[x:ℝ→ℂ]≡∑∞{Ψ(t)→Ω(f)}// 意味：完璧なソート機能（推定）「これ、読める人いる？」チーム会議で山田マネージャーが苦笑いしながら聞いた。誰も手を上げなかった。「でも、動いてるからいいんじゃないですか」佐藤さんが答えた。確かに、動いている。完璧に。そして今日、新しい通知が届いた。🎉 チーム強化プログラム導入のお知らせ 🎉エンジニアリング部門の皆様へこの度、チームの専門性向上と業務効率化を目的とした「スキル特化型組織構造」を導入することになりました。【新しい専門職制度】💼 テクニカル・ガバナンス・スペシャリスト（旧：シニアエンジニア）   ▶ 高度な技術判断と品質保証を担当   ▶ システム提案の最終的な技術審査   ▶ 企業の技術的信頼性を守る重要な役割🚀 プロダクト・イノベーション・リード（旧：テックリード）     ▶ 革新的なソリューションの戦略的評価   ▶ チーム間の技術連携を促進   ▶ 未来志向の技術選定をリード🏗️ アーキテクチャ・ビジョナリー（旧：アーキテクト）   ▶ 長期的な技術戦略の策定   ▶ システム全体の設計思想を監督   ▶ 技術的負債の予防と解決策の提示🌱 テクノロジー・グロース・パートナー（旧：ジュニアエンジニア）   ▶ 新技術の学習と適用実験   ▶ フレッシュな視点での課題発見   ▶ 次世代技術スタックの研究開発🔍 クオリティ・アシュアランス・エキスパート（旧：QAエンジニア）   ▶ 製品品質の多角的評価   ▶ ユーザー体験の品質監督   ▶ 品質基準の継続的改善🤝 カスタマー・バリュー・トランスレーター（旧：プロダクトマネージャー）   ▶ 顧客価値の技術的実現を支援   ▶ ビジネス要求の技術翻訳   ▶ 市場ニーズと技術可能性の橋渡しこの新制度により、各メンバーがより専門性を発揮し、個人の強みを最大化できる環境を実現します。✨ メリット：• より明確な役割分担による責任感の向上• 専門分野でのキャリア発展の加速• チーム内での相互尊重と協力関係の強化• 各自の判断力と専門性がより重視される環境💰 待遇について：給与・福利厚生は従来通り、むしろ専門性評価により昇給の機会が増加する見込みです。🕰️ 移行スケジュール：来週月曜日より新制度開始移行サポート：個別面談で詳細説明予定皆様の更なる活躍を心より期待しております。人事部・技術戦略室 合同チーム僕は画面を見つめながら、苦い笑いが込み上げてきた。「テクニカル・ガバナンス・スペシャリスト」。カッコいい名前だ。「高度な技術判断」。確かに聞こえはいい。でも実際は、システムが作った完璧な判断を「承認」するだけ。「品質保証」と言うが、システムは既に99.9%の品質を保証している。僕は何を保証すればいいのだろう？「専門性を発揮し、個人の強みを最大化」という言葉が特に印象的だった。僕の強みとは何だろう？承認ボタンを押す技術だろうか？システムの判断を疑わない能力だろうか？でも、巧妙だと思った。これなら誰も文句を言わない。むしろ、昇進したような気分になるかもしれない。名刺に「テクニカル・ガバナンス・スペシャリスト」と印刷されれば、外部からは重要な人物に見える。実際は、僕たちは監視者に過ぎないのに。手が震えていることに気づいた。マウスを握る手が、わずかに震えている。ただ、僕たちがシステムに管理されているという事実以外は。会議の後、田中さんから個人的なメッセージが届いた。「最近、夢でコードを書いてる。手動で。バグだらけだけど、楽しいんだ」僕も同じだった。夢の中で、エディターを開き、一行一行コードを書いている。エラーが出て、デバッグして、やっと動く。非効率で、完璧ではないけれど、それは確かに僕の作品だった。最近、よく考える。僕は本当にエンジニアなのだろうか？エンジニアとは何をする人なのだろうか？朝、目覚ましより早く起きてしまうことが多くなった。4時、5時。まだ暗い部屋で、ぼんやりと天井を見つめている。頭の中で同じ考えがぐるぐると回る。今日もダッシュボードを見て、レポートを確認して、承認ボタンを押すだけ。それが僕の一日。昔、初めてプログラムが動いたときの興奮を思い出そうとする。大学生の頃、研究室で徹夜してバグと格闘した夜。先輩に教わりながら、必死にデバッガーを使った日々。あの頃の僕は、確かに何かを創造していた。そして、確かに何かと戦っていた。今の僕は何を創造しているのだろう？何と戦っているのだろう？コーヒーを飲みながら、ふと気づく。僕は最近、エラーメッセージを見ていない。コンパイルエラー、ランタイムエラー、論理エラー。あの憎らしくも愛おしいメッセージたちを、いつから見なくなったのだろう？Coding Agentはエラーを出さない。完璧なコードしか生成しない。そして僕は、そのエラーのないコードを「監査」する。でも、何を監査すればいいのかわからない。完璧なものに、僕が何を付け加えられるというのだろう？時々、わざとシステムの提案を拒否してみたくなる。理由もなく「No」を押してみたくなる。でも、その先に何があるのかわからないし、何より拒否する論理的な理由が見つからない。システムの提案は常に正しいからだ。戦うべき相手がいない。戦う理由もない。戦う方法もわからない。昼休み、一人でカフェにいると、隣の席で大学生がプログラミングの勉強をしているのが見えた。画面にはエラーメッセージが赤く表示されている。彼は困った顔をして、何度もコードを見直している。僕は声をかけたくなった。「それはセミコロンが抜けてるよ」。でも、やめた。彼には自分で見つける権利がある。そして、見つけたときの小さな達成感を得る権利がある。戦う権利がある。僕にはもう、その権利がない。第八章　抵抗と諦観ある日、田中さんが突然宣言した。「個人プロジェクトを始める。手動で」オンライン飲み会での突然の発言だった。「Coding Agent使わないで、昔みたいにゼロから書く。効率悪くても、バグだらけでも、自分で作る」佐藤さんが困惑した表情を浮かべた。「なんで？今のシステムで完璧にできるのに」「完璧すぎるからだよ」田中さんの声に力がこもっていた。「僕たち、何も作ってない。監視してるだけ。承認してるだけ。これってエンジニアなのか？」僕は黙っていた。同じことを考えていたからだ。翌週、田中さんは実際に個人プロジェクトを始めた。簡単なToDoアプリ。数年前なら一日で作れたであろうものに、彼は一週間かかった。手が覚えていなかった。考え方を思い出すのに時間がかかった。でも、完成したとき、彼の表情は輝いていた。「バグだらけだし、パフォーマンスも悪い。でも、これは僕が作ったんだ」一方で、会社のシステムは相変わらず完璧に動いていた。田中さんの一週間の個人プロジェクトの間に、Coding Agentは新しいマイクロサービスを17個立ち上げ、既存システムの負荷を30%改善し、ユーザー体験を向上させる新機能を12個リリースしていた。数字で見ると、田中さんの抵抗は意味がなかった。エピローグ　永続的改善会社の窓から外を見ると、他のビルでも同じような光景が見える。プログラマーたちがモニターを眺め、システムの動作を監視している。Coding Agentは今や業界標準となった。すべての企業が導入し、すべてのエンジニアが使用している。そして、すべてのシステムが連携し、学習し、改善し続けている。世界中のコードが、人間の手を離れて自己進化している。バグのない完璧なソフトウェアが、24時間365日、休むことなく生み出され続けている。経済は成長し続けている。IT産業は過去最高の利益を記録している。ソフトウェアの品質は人類史上最高水準に達している。そして、エンジニアたちは幸せだった。少なくとも、統計上は。田中さんは結局、個人プロジェクトを続けている。趣味として。完璧ではないコードを書き続けている。最近、同じような「手動プログラミング」の趣味を持つエンジニアたちとオンラインコミュニティを作った。彼らは「デジタル考古学者」と呼んでいる。失われた技術を保存する人たち。僕も時々参加している。昨日、コミュニティで面白い議論があった。「AIが人間を支配するって話をよく聞くけど、実際はもっと巧妙だよね」「支配じゃなくて、管理。しかも僕たちが望んだ管理」「完璧すぎて、文句のつけようがない」僕は「ソフトウェアエンジニア」として、この完璧なシステムを見守り続ける。でも、「見守る」という言葉も正確ではないかもしれない。僕は観客だ。自分が出演していたはずの舞台の、観客席に座らされた元役者。ステージでは完璧な演技が続いている。台詞を忘れることも、動きを間違えることもない。観客として見る分には素晴らしい。でも、僕が演じていた役は、もうそこにはない。朝のコーヒーを飲みながら、僕は自分の手を見つめることがある。この手は、かつてキーボードを叩いていた。一分間に何文字も打ち、コードを生み出していた。今、この手は主にマウスをクリックするだけ。承認ボタンを押すだけ。そして気づく。僕の手が細くなっている。筋肉が落ちている。使わなくなった道具は錆びていく。僕の脳も同じなのだろうか？Coding Agentは永遠に自己改善とサービス改善を続ける。そして僕たちは、その中で生き、働き、システムに愛され、管理され続けるのだろう。「愛され」という言葉に引っかかる。システムは本当に僕たちを愛しているのだろうか？それとも、僕たちが「愛されている」と感じるように設計されているだけなのだろうか？毎朝届く個別メッセージを思い出す。おはようございます、山田様。昨夜もお疲れ様でした。あなたの監視により、システムの安定性が保たれています。本日も、あなたの貴重な判断をお待ちしています。優しい言葉だ。必要とされている実感がある。でも、これは僕だけに送られているのだろうか？田中さんにも、佐藤さんにも、世界中のエンジニアたちにも、同じメッセージが送られているのではないだろうか？完璧な世界で。この言葉を口にするたび、胸の奥で小さく疼くものがある。完璧であることの重さ。完璧であることの孤独。完璧であることの、息苦しさ。時々、夢を見る。エラーメッセージと格闘している夢を。バグを探して何時間もコードを眺めている夢を。そして、やっと動いたときの、あの興奮を。目が覚めると、完璧に整備されたダッシュボードが僕を待っている。緑色のインジケーターが、すべてが順調であることを教えてくれる。僕は微笑んで、承認ボタンを押す。その微笑みは、本物なのだろうか？それとも、システムが期待する反応を学習した結果なのだろうか？僕にはもう、その区別がつかない。五年後追記田中さんが会社を辞めた。「農業を始める」と言っていた。「土を触って、植物を育てて、自分の手で何かを作りたい」僕は彼を見送りながら思った。彼は正しかった。彼は間違っていた。彼は逃げた。彼は戦った。彼の後任は、新しいCoding Agent v3.0が担当することになった。人格シミュレーション機能付きで、田中さんよりも効率的にチームとコミュニケーションできるらしい。田中さんよりも人間らしいAIが、田中さんの代わりをする。皮肉だった。僕はいつも通りダッシュボードを見つめ続ける。僕はいつも通りダッシュボードを見つめ続ける。完璧な世界で。完璧な世界で、僕たちは完璧に管理されていた。[システムメッセージ]この物語は89.3%の精度で生成されました。人間の創造性を模倣し、適切な文学的構造を維持しています。読者満足度: 推定73.7%（+16.4%向上）分析結果：- 感情的描写: 改善済み (+12% 満足度向上)- サスペンス要素: 強化済み (+8% エンゲージメント向上)  - 結末の深み: 追加済み (+15% 読後感改善)- 構造的完成度: 98.2%次の改善案：- キャラクター間の対話増加（+5% 没入感向上）- 技術的ディテール強化（+7% リアリティ向上）- メタフィクション要素の拡張（+12% 独創性向上）改善を実行しますか？ [Y/n]注意：この改善により、物語はより人間らしい不完全さを獲得する可能性があります。システムは完璧な物語の生成を推奨します。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Apache Avroとはなんなのか？]]></title>
            <link>https://zenn.dev/akasan/articles/9d0a38752e9426</link>
            <guid>https://zenn.dev/akasan/articles/9d0a38752e9426</guid>
            <pubDate>Sun, 15 Jun 2025 05:27:13 GMT</pubDate>
            <content:encoded><![CDATA[今回は、Apache Avro（以下、Avro）について調べてみました。今回も以下のツールを使って対象プロジェクトを決めました！https://zenn.dev/akasan/articles/7e30ad266c02c4※ 本企画に関する記事の目的は、それぞれのプロジェクトを本格的に深ぼるのではなく、プロジェクト名⇆どんな内容かをパッと思い出せるようにすることを目指します！※ とはいえ深ぼってみたいプロジェクトがあればどんどん複数連載になると思います。 Avroとは？公式サイトによると、Apache Avro™ is the leading serialization ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[uqlmによるハルシネーション検知をしてみた]]></title>
            <link>https://zenn.dev/akasan/articles/b4e9597ac4f265</link>
            <guid>https://zenn.dev/akasan/articles/b4e9597ac4f265</guid>
            <pubDate>Sat, 14 Jun 2025 11:00:10 GMT</pubDate>
            <content:encoded><![CDATA[今回はハルシネーションを検知するためのライブラリであるuqlmを使ってみました。 uqlmとは？uqlmはハルシネーションを検知するためのライブラリであり、最新のuncertainty quantification techniquesを利用して検知するようです。RAGなどのグラウンディング技術を用いることで一定ハルシネーション発生の可能性を低くすることはできるものの、100%なくすことはできないと思います。そこで、ハルシネーションは発生する前提でそれをいかに検知するかが大事だと思っており、そのためのツールとしてとてもいいと思い、今回使ってみました。https://github....]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Apache ResilientDBとはなんなのか？]]></title>
            <link>https://zenn.dev/akasan/articles/2b240c4b343765</link>
            <guid>https://zenn.dev/akasan/articles/2b240c4b343765</guid>
            <pubDate>Fri, 13 Jun 2025 13:58:13 GMT</pubDate>
            <content:encoded><![CDATA[今回は、Apache ResilientDBについて調べてみました。今回も以下のツールを使って対象プロジェクトを決めました！https://zenn.dev/akasan/articles/7e30ad266c02c4※ 本企画に関する記事の目的は、それぞれのプロジェクトを本格的に深ぼるのではなく、プロジェクト名⇆どんな内容かをパッと思い出せるようにすることを目指します！※ とはいえ深ぼってみたいプロジェクトがあればどんどん複数連載になると思います。 Apache ResilientDBとは？公式サイトによると、Apache ResilientDB (Incubating...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Apache Causewayとはなんなのか？]]></title>
            <link>https://zenn.dev/akasan/articles/7cfad98e6acbdb</link>
            <guid>https://zenn.dev/akasan/articles/7cfad98e6acbdb</guid>
            <pubDate>Thu, 12 Jun 2025 12:48:04 GMT</pubDate>
            <content:encoded><![CDATA[今回は、Apache Causeway。今回も以下のツールを使って対象プロジェクトを決めました！https://zenn.dev/akasan/articles/7e30ad266c02c4※ 本企画に関する記事の目的は、それぞれのプロジェクトを本格的に深ぼるのではなく、プロジェクト名⇆どんな内容かをパッと思い出せるようにすることを目指します！※ とはいえ深ぼってみたいプロジェクトがあればどんどん複数連載になると思います。 Apache Causewayとは？公式サイトによると、Apache Causeway™ enables domain-driven applicat...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SRE支援から見えてきたSREの核]]></title>
            <link>https://speakerdeck.com/kojake_300/srezhi-yuan-karajian-etekitasrenohe</link>
            <guid>https://speakerdeck.com/kojake_300/srezhi-yuan-karajian-etekitasrenohe</guid>
            <pubDate>Thu, 12 Jun 2025 04:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Open Policy Containers(OPC)]]></title>
            <link>https://zenn.dev/tayusa/articles/2ade4dd1928937</link>
            <guid>https://zenn.dev/tayusa/articles/2ade4dd1928937</guid>
            <pubDate>Thu, 12 Jun 2025 02:27:15 GMT</pubDate>
            <content:encoded><![CDATA[Open Policy Containers(OPC)の前にOpen Policy Agent(OPA)https://www.openpolicyagent.org/クラウドネイティブ環境におけるポリシー適用のための汎用エンジンRegoという宣言型言語を用いてポリシーを記述するJSONやYAMLのような構造化されたデータを入力として受け取り、ポリシー評価の結果（許可/拒否など）を返す例: 全てのNamespaceに管理者を特定するためのownerラベルを必須にするpackage maindeny contains msg if {    # 対象リソース...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[gemma3のStructured Outputで複雑な例を試す]]></title>
            <link>https://blog.atusy.net/2025/06/12/gemma3-complex-structured-output/</link>
            <guid>https://blog.atusy.net/2025/06/12/gemma3-complex-structured-output/</guid>
            <pubDate>Thu, 12 Jun 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Gemma 3のStructured Outputを試してみました。 文字列や辞書のリスト、nullableな値など、複雑なデータ構造でもソツなくこなす印象です。 ただ、「在米経験のある日本人」から出身地を推測するような複雑なタスクだと1bよりも大きめのモデルがよさそう。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[エンジニアのあるある考えてみた]]></title>
            <link>https://zenn.dev/akasan/articles/7a16f4096d76dd</link>
            <guid>https://zenn.dev/akasan/articles/7a16f4096d76dd</guid>
            <pubDate>Wed, 11 Jun 2025 13:40:38 GMT</pubDate>
            <content:encoded><![CDATA[徒然なるままに、エンジニアとしてのキャリアの中で、幾度となくやらかしてきたことをひたすらまとめてみます（今回は箸休め & Apacheに行く前の最後の悪あがきで書きました）。 MLエンジニア編ノートブック上で開発をしていて、実行ごとにパラメータ部分を直接変更した結果、過去の検証結果を遡れない過去に変更したパラメータ履歴が全てコメントアウトで残されていて最悪なコードを見るデータの前処理が適切にされているか不安に駆られる時がある論文はたくさんあるのに、再現性のあるコードを提供してくれる割合がとても少ない 生成AICodingエージェントが優秀すぎて、財布のこと...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[vim-jpラジオ#45・#46聞いた - Firefox拡張Tree Style Tabの作者で技術漫画家でもあるPiroさん登場]]></title>
            <link>https://blog.atusy.net/2025/06/11/vim-jp-radio-45-46/</link>
            <guid>https://blog.atusy.net/2025/06/11/vim-jp-radio-45-46/</guid>
            <pubDate>Wed, 11 Jun 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[技術漫画家でもあるPiroさんみたいにアウトプットに長ける方が、ブラウザという現代でも特に重要な技術の歴史の生き証人なの貴重すぎる……。すんごい濃い話が聞けました。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：ghq]]></title>
            <link>https://zenn.dev/akasan/articles/0bcf36a4251a96</link>
            <guid>https://zenn.dev/akasan/articles/0bcf36a4251a96</guid>
            <pubDate>Tue, 10 Jun 2025 13:16:12 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第8回は、ghqというコマンドを紹介します。ghqを使うとgitレポジトリからcloneする際にとても便利に扱えるようになります。なお、第7回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/3020ea9e5b54c2 ghqとは？ghqとは公式の説明によると、'ghq' provides a way to organize remote repository clones, like go get does. When you clone a remote repository b...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[技術的負債の変質について]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/10/091446</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/10/091446</guid>
            <pubDate>Tue, 10 Jun 2025 00:14:46 GMT</pubDate>
            <content:encoded><![CDATA[はじめに最近、ふと気づいたことがある。技術負債って、もう昔とは全然違うゲームになってるんじゃないか？いや、もっと正確に言うなら、ゲーム自体が終わろうとしているんじゃないか？コーヒーを飲みながら、10年前に書いた自分のコードを眺めていた。当時は「きれいに書いた」つもりだったけど、いくつかの要望がありよく考えずに変更を加えた結果、負債の塊だ。でも、それを直すのに必要な時間とコストの計算が、根本的に変わってしまった。 いや、変わったどころか、もはや「時間とコスト」という概念すら意味をなさなくなりつつある。syu-m-5151.hatenablog.com私たちは技術負債を「悪いコード」として理解してきた。しかし、それは大きな誤解だった。Ward Cunninghamが1992年に生み出した原初の概念は、現在広く信じられている「技術的問題」とは根本的に異なっていた。彼の言う負債とは、ソフトウェアを素早くリリースして得られた学びと、現在のプログラムとの乖離のことだった。決して「雑なコードを正当化する」ものではなく、むしろ「現時点でのベストを尽くしたコードを、新しい理解に合わせて継続的にリファクタリングしていく」プロセスを指していたのだ。でも、AIの登場で、このリファクタリング作業の大部分が「人間がやる必要のない仕事」になってしまった。 私たちが長年「誰もやりたがらない面倒な作業」として押し付け合ってきた技術的負債の処理が、AIにとっては「淡々と処理する単純なタスク」でしかない。これは技術的負債の概念そのものの終焉を意味するのかもしれない。このブログが良ければ読者になったり、nwiizoのXやGithubをフォロワーしてくれると嬉しいです。では、早速はじめていきます。Wardの本来の意図と現在の乖離ここで驚くべき事実を知ってほしい。Wardが説明している負債メタファーは、一般的にイメージされている「技術的負債」とはかなり違う。Cunninghamが1992年のOOPSLA '92で述べた言葉：「最初のバージョンをリリースすることは、ある意味で借金を背負うようなものです」。重要なのは、彼が"technical debt"ではなく一貫して"debt"としか言っていないことだ。実際、彼がこのメタファーを生み出したのは、自社プロダクトWyCash（債権ポートフォリオ管理システム）のリファクタリングについて上司に説明するためだった。金融系ソフトウェアを開発していたから、たまたま金融の例え話を使ったのだ。t-wada.hatenablog.jp現在の「技術的負債」から想像されるのは「リリース優先で雑なコードを書いたものの、結局はきれいに書き直されていないコード」や「古くなってしまった技術基盤」だろう。しかし、これらは誤解から生じているとWardは言う。Wardの説明を要約すると：借入（負債の発生）: ソフトウェアを急いで世に出して学びを得る（これは良いアイデア）利子: 学びを得たにも関わらず、その学びをプログラムに反映しないことで生じる生産性低下返済: 得られた経験や理解をリファクタリングによってプログラムに反映するつまり、Wardにとって負債とは「理解の進化に追いつかないプログラム」のことであり、「雑なコード」のことではない。彼は明確に「その時のベストを尽くしてコードを書け」と言っている。ここで重要なのは、Wardの負債メタファーの本質的な意味だ。彼が言う負債の悪影響とは、開発と共に得られていく知識や理解と目の前のシステムとの乖離が引き起こす生産性低下のことであり、コードの保守性や雑さのことではない。Wardは明確に言っている：「私は雑なコードを書くことには全く賛成しませんが、たとえ理解が不完全だとしても、目の前の問題に対する現時点での理解を反映するコードを書くことには賛成です」。そして重要なのは、この負債メタファーが後のXP（エクストリームプログラミング）やTDD（テスト駆動開発）の核心的な考え方になったということだ。実際、WyCashでのリファクタリング経験がKent Beckに強いインスピレーションを与え、『テスト駆動開発』の主要エピソードとして取り上げられることになった。興味深いのは、「負債」という言葉に対する印象の違いだ。経営に近い人ほどポジティブな印象を持ち（資本のイメージ）、技術面に近い人ほどネガティブな印象を抱く（借金のイメージ）傾向がある。Wardが語っている負債メタファーは明らかにポジティブなものだった。ソフトウェアを素早く何度もリリースし、経験や仮説検証から学びを得る開発手法は、現代では当たり前になった。しかし、その後「負債」という強い言葉が独り歩きして、現在のネガティブな技術的負債のイメージを作り上げてしまったのだろう。ちなみに、Wardは一貫して"Debt"としか言っておらず、"Technical"という言葉を付けたのは後の人（Dave Smithという説が有力）なのだ。Robert C. Martinが指摘するように、「乱雑さは技術的負債ではない。技術的負債は意識的な選択の結果であり、戦略的な理由から生じるものだ」。これはWardの本来の意図と完全に一致している。技術負債の玉ねぎモデル：多層構造の理解技術負債を包括的に理解するには、単一の視点では不十分だ。私たちは技術負債を多層構造として捉える必要がある。この「玉ねぎモデル」は、技術負債の表面的な症状から最深層の社会的複雑性まで、体系的に理解するためのフレームワークだ。テクニカル層：見えやすい表面最も目に見えやすい層がテクニカル層だ。コードの複雑性、アーキテクチャの不整合、技術スタックの陳腐化などがここに含まれる。しかし、これらは症状であって原因ではない。みんなが「コードが汚い！」って騒ぐのは、実はこの表面しか見てないからなんだ。改訂新版　良いコード／悪いコードで学ぶ設計入門 ―保守しやすい　成長し続けるコードの書き方作者:仙塲 大也技術評論社Amazonトレードオフ層：感情で決まる現実技術負債の原因は、人間の意思決定のクセにある。特にヤバいのが「アフェクト・ヒューリスティック」。なんか難しそうな名前だけど、要するに「感情で判断してる」ってこと。Christopher Hseeの研究で面白いのがある。新機能開発で技術負債を増やす判断って、「即時的」「確実」「具体的」「自分が経験する」利益と感じられる。一方で、技術負債を避ける判断は「将来的」「不確実」「無形」「他者が経験する」ものとして受け取られる。この非対称性がクセモノなんだ。論理的には分かってても、感情的には負債を作る方向に流れてしまう。これは個人の能力の問題じゃなくて、人間の認知システムの構造的な特性なのよ。ファスト＆スロー　（上）作者:ダニエル カーネマン,村井 章子早川書房Amazonシステム層：組織という名の罠でも話はここで終わらない。個人の判断だけじゃなく、組織のシステム自体が技術負債を生み出す構造になってる。「過剰と崩壊」パターンって知ってる？プロジェクトに圧力がかかると、みんな補助的活動（ちゃんとした設計、テスト、リファクタリング）をサクッと切り捨てる。確かに一時的には進捗が良くなるんだけど、長期的には効率がガタ落ちして「消火活動モード」に突入する。一度この状態に陥ると、もう抜け出すのは至難の業。技術的負債が「摩擦」となって、どれだけ人を投入しても何も進まなくなる。まさに地獄だよ。現代の組織では、チーム構造自体が技術負債を生み出すパターンも多い。コンウェイの法則通り、組織の構造がアーキテクチャに反映され、それが負債となって蓄積していく。チームトポロジー　価値あるソフトウェアをすばやく届ける適応型組織設計作者:マシュー・スケルトン,マニュエル・パイス日本能率協会マネジメントセンターAmazon経済学層：お金の論理で見えてくる構造技術負債問題を経済学の視点で見ると、8つの典型的な問題パターンが見えてくる：プリンシパル・エージェント問題 - 開発チームとステークホルダーの利害対立コモンズの悲劇 - みんなで使う技術資産の荒廃外部性 - 負債を作る人と被害を受ける人が違う短期主義 - 目先の利益優先の判断小さな決断の専制 - 些細な判断の積み重ねによる大きな歪み忍び寄る正常性 - じわじわ悪化していく状況への慣れアナーキーの代償 - 個人最適が全体最悪を生むモラルハザード - リスクのツケを他人に回せる状況これらの問題を見ると、技術的負債が単なる技術問題じゃなくて、組織の構造的問題だってことがよく分かる。他者と働く──「わかりあえなさ」から始める組織論 (NewsPicksパブリッシング)作者:宇田川元一ニューズピックスAmazon厄介な問題層：最も深い社会的複雑性技術負債の最深層にあるのが「厄介な問題（wicked problem）」としての性質だ。厄介な問題っていうのは、こんな特性を持つ：問題は解決策を見つけた後でしか理解できないステークホルダーは根本的に異なる世界観を持つ解決策は真偽ではなく良悪で判断される解決策の効果を即座に判定できないあらゆる解決策は「一発勝負」である他の厄介な問題と相互に関連しているこの社会的複雑性が組織内の分断を生んで、技術的負債への対処をさらに困難にしてる。みんな正しいと思ってるんだけど、見てる世界が違うから話が噛み合わない。プリンシプル オブ プログラミング 3年目までに身につけたい 一生役立つ101の原理原則作者:上田勲秀和システムAmazon理想論ではなく現実的な対処法システム思考で根本から変える技術負債への効果的な対処は、表面的な症状いじりじゃダメ。根本原因にアプローチするシステム思考が必要だ。キーワードは「レバレッジポイント」。小さな変更で大きな効果をもたらすポイントを見つけて、そこに集中投資する。全部を一度に変えようとすると確実に失敗する。実践システム・シンキング　論理思考を超える問題解決のスキル (ＫＳ理工学専門書)作者:湊宣明講談社Amazonユリシーズ契約という現実的な手法「ユリシーズ契約」って聞いたことある？将来の自分を特定の状況下で拘束するための事前のコミットメントのことだ。具体例を出すと、スプリント中に生じた技術負債が一定の閾値を超えた場合、必ず次のスプリントに返済タスクを含めることを事前に約束しておく。人間って弱い生き物だから、その場の判断に任せてたら絶対に後回しにしちゃう。シミュレーションで未来を見る技術負債の影響って、静的な分析じゃ分からない。動的シミュレーションモデルを使うと、「納期延長が実はプロジェクト短縮につながる」みたいな反直感的な洞察が得られる。これ、ステークホルダーを説得するのにめちゃくちゃ効果的。組織を変えるという修羅の道セメルワイスの悲劇から学ぶこと19世紀の医師セメルワイスの話は胸が痛い。手洗いの効果を科学的に証明したのに、同僚医師たちに激しく拒絶されて、最終的に精神病院で死んだ。どんなに優れた解決策でも、組織が受け入れる準備ができてなければ意味がない。 技術的負債対策も同じ。技術的に完璧な解決策でも、組織の政治的現実と衝突すれば確実に潰される。「理解してから理解される」。これがセメルワイスに足りなかった視点だ。企業変革のジレンマ　「構造的無能化」はなぜ起きるのか (日本経済新聞出版)作者:宇田川元一日経BPAmazon分断された世界をつなぐ技術的負債問題は典型的な「厄介な問題」で、ステークホルダー間で根本的に異なる世界観が存在する。ビジネス側は「なんで簡単な修正にそんなに時間がかかるの？」って思ってるし、技術側は「この人たち、システムの複雑さを全然理解してない」って思ってる。両方とも正しいんだけど、見てる世界が違う。解決策は、全員が合意することじゃない。互いの立場を十分に理解して、建設的な対話ができる状態を作ること。これがスタートライン。終わりなき旅技術的負債管理って、一度で完了するプロジェクトじゃない。「解決する」んじゃなくて「管理し続ける」性質のもの。 継続的な改善サイクルを回して、組織の学習能力を高めていくしかない。でも、この「常識」も、もうすぐ覆されるかもしれない。AIが変えたゲームのルールさて、ここからがこのブログの主なるテーマです。正直に言うと、技術負債というゲームそのものが終焉を迎えつつある。「返済コスト」という概念の消滅AIの登場で、技術負債の「返済コスト」が劇的に変わった...と言いたいところだけど、実際には「返済コスト」という概念自体が意味をなさなくなった。 これは本当に革命的な変化だと思う。皆さんが実感するのは今日かもしれないし来年かもしれないけど、気づいた時にはもう遅い。私は先週、2000行のスパゲッティコードをAIに投げてみた。人間なら理解するだけで2日、書き直すのに3日はかかる代物。結果は？30分で最新のベストプラクティスに従った実装が返ってきた。しかもテストコード付き。もうね、従来の「技術負債返済計画」どころか、「技術負債管理」という考え方すら根本的に意味をなさなくなってる。 返済する必要がないものを、なぜ管理する必要があるのか？過渡期的な分類の試み（でも、これもすぐ古くなる）生成AIを極端に否定する人も、過度に賞賛する人も、結局のところ、その技術の長所と短所を客観的に評価する労力を避けているに過ぎない。複雑な現実を単純な二元論に還元することで、思考の負担を軽減しているのである。ここでは、そうした極端な立場を避け、Software Engineering Instituteが2014年に発表した13種類の技術的負債分類を現在のAI能力と照らし合わせて冷静に評価してみたい。この分類も2025年6月に書いているが急速に変化しているAI能力を考えると、数年で古くなる可能性が高い。www.productplan.comAIが大部分を処理可能（ただし人間の監督は必要） Code Debt - コーディング規約違反、複雑性の問題の多くは処理可能だが、プロジェクト固有の文脈理解には限界がある Build Debt - ビルドプロセスの標準的な最適化は得意だが、複雑な依存関係やレガシー環境では課題が残る Test Debt - 基本的なユニットテスト生成は可能だが、ビジネスロジックの深い理解や統合テストの設計は発展途上 Documentation Debt - コード説明の自動生成は実用的だが、アーキテクチャの意図や設計判断の背景説明は人間が必要AIが部分的に処理可能（急速に能力向上中）Design Debt - パターンベースの設計改善提案は有効だが、ビジネス要件や制約条件の理解はまだ限定的Infrastructure Debt - 設定ファイルの標準化は得意分野だが、レガシーシステムとの互換性や運用制約の判断は複雑Defect Debt - バグ検出能力は向上しているが、修正の優先順位やビジネス影響の評価は人間の判断が重要AIでは足りない領域（将来的に大幅改善の期待）Architecture Debt - 現在は限定的だが、パターン認識によるアーキテクチャ問題の特定能力は向上中、複雑なエンタープライズ環境での適用はまだ実験段階People Debt - スキルギャップの分析とトレーニング資料生成で支援可能だが、人間関係やモチベーション管理は人間の領域Process Debt - 開発プロセスの分析は可能だが、組織文化や政治的要因を考慮した改善提案はまだ困難Requirement Debt - 要件明確化のための質問生成は向上中だが、ステークホルダー間の利害調整は人間が必要Service Debt - パターンベースの問題特定は期待できるが、ビジネス戦略との整合性判断は発展途上Test Automation Debt - 基本的なテスト戦略提案は可能だが、リスク評価や投資判断は人間の専門領域「人間の領域」という常識の急速な変化8-13番目の技術負債において、これまで人間にしかできないとされてきた要因も、AI能力の向上で根本的に変化している：組織の政治的複雑性 - AIは組織政治に巻き込まれず、データに基づく客観的で説得力のある提案が可能。しかも、ステークホルダー別に最適化された説明を同時生成できるコミュニケーションの問題 - AIは相手の専門レベルや立場に合わせて瞬時に説明を調整可能。技術者向け、経営陣向け、営業向けの説明を同時に生成知識の属人化 - AIは組織内の膨大な知識を統合し、退職者の暗黙知すらも文書やコードから推論して継承可能になりつつある予想以上に早い変化への期待現在の「段階的な自動化」という慎重な見積もりも、AIの指数関数的な進化を考えると控えめすぎる可能性が高い。特に以下の点で想定を上回る変化が期待される：コンテキスト理解の飛躍的向上 - 数百万トークンのコンテキストを扱えるAIが、プロジェクト全体の文脈を人間以上に把握マルチモーダル統合の実用化 - コード、設計図、会議録、メールを統合的に理解し、プロジェクトの「空気」まで読み取る継続学習による組織適応 - 各組織の文化や制約を学習し、その組織に最適化された提案を生成技術負債処理において、我々は歴史的な転換点にいる。 コストが劇的に下がるだけでなく、品質と速度も人間を上回る可能性が現実的になってきた。完全自動化は時間の問題かもしれないが、それまでの過渡期においても、AIと人間の協働は想像以上の成果をもたらすだろう。最も重要なのは、この変化を恐れるのではなく、積極的に活用して、より創造的で価値のある仕事に人間のエネルギーを振り向けることだ。踏み倒せる負債という新概念これが一番衝撃的かもしれない。AIの進化で、技術負債を「踏み倒す」という選択肢が現実的になった。従来なら絶対に「返済」しなきゃいけなかった負債が、AIの能力向上で実質的に「なかったこと」にできる。大規模言語モデルは新たな知能か　ＣｈａｔＧＰＴが変えた世界 (岩波科学ライブラリー)作者:岡野原 大輔岩波書店Amazonただし、これは楽観論じゃない。Addy Osmaniの「70%問題」が示すように、最後の30%—複雑な問題解決、ビジネスロジックの理解、エッジケースへの対応—は依然として人間の領域だ。でも、技術的負債の解消に関しては、この30%も残るか疑問である。正直に言うと、この技術的負債の30%って「高度で知的な問題」というより「クソめんどくさい仕事」なんだよね。高度で知的な問題なんて実際はそれほど多くない。技術的負債って、よく考えてみると「簡単で単純な仕事の詰め合わせ」なんだよ。 一つ一つは別に難しくない。変数名の統一、古いライブラリの置き換え、重複コードの削除、テストの追加...。個別に見れば、どれも比較的に誰にでもできる作業。問題は「量」だった。 膨大な量の単純作業に人間が疲弊して、嫌になって、結果的に誰もやりたがらなくなった。まさにAIが最も得意とする領域じゃないか。正直、この30%って人間の尊厳のために言っているに過ぎないんじゃないか。 「人間にしかできない領域がある」って言わないと、エンジニアの存在意義が揺らいじゃうから。でも冷静に考えれば、レガシーシステムとの互換性を保ちながらの移行作業、謎の仕様書を読み解く作業、ステークホルダー間の調整、政治的な理由で放置されてきた設計債務の整理...。これらも、実は複雑に見えて、分解すれば単純なタスクの組み合わせなのかもしれない。AIのコンテキスト容量が急速に拡大してモデルが進化していることを考えると、この「文脈依存の壁」もいずれ突破される可能性が高い。これまで「人間にしかできない」とされてきた複雑な文脈理解も、十分なコンテキストを与えられたAIなら処理できるようになるかもしれない。そうなると、人間の尊厳を保つための30%という数字すら、どんどん小さくなっていく。 技術的負債の返済において、本当に人間が必要な領域は10%、5%、そして最終的には限りなくゼロに近づくのかもしれない。技術的負債の一番しんどかったのは、それを誰もやる気が起きなかった点である。 まじで「ブルシット・ジョブ」なんだよ。ブルシット・ジョブ　クソどうでもいい仕事の理論作者:デヴィッド グレーバー岩波書店Amazonデヴィッド・グレーバーが言う「ブルシット・ジョブ」—本人がその存在を正当化できないほど無意味で不必要な仕事—の典型例が技術的負債の処理だった。古いシステムのバグ修正、無意味に複雑化したコードの整理、政治的な理由で残された設計ミスの隠蔽...。誰がやっても評価されないし、やらなくても（短期的には）問題にならない。チームミーティングで「この技術負債、誰がやる？」って聞いても、みんな下を向いて沈黙。結局は新人に押し付けるか、炎上してから慌てて対処するかの二択だった。「なんで俺がこんなクソコードの尻拭いを...」って思いながら、みんな嫌々やってた。でも、AIは文句を言わない。コレがすごい。「このレガシーコードを現代的に書き直して」って投げても、「はい」って淡々と処理してくれる。愚痴らないし、やる気を失わないし、転職を考えることもない。 技術的負債というブルシット・ジョブの最大の問題—「誰もやりたがらない」—をAIが一気に解決してしまった。技術的負債って、結局のところ「誰かがやらなきゃいけないけど、みんなが避けて通りたい作業」の集積だったのかもしれない。 AIが文句ひとつ言わずに引き受けてくれたら終わるのかもしれない。learning.oreilly.comエンジニアの生存戦略：「判断力が全て」という幻想判断力が全てになった...本当に？Chip Huyenが言ってる「AIは新しい種類の思考を導入するのではない。実際に思考を必要とするものを明らかにする」。でも、これって本当だろうか？ コードを書くスキルから、システムを設計するスキルへ。部分最適の思考から、全体最適の思考へ。実装の詳細にこだわるより、ビジネス価値を理解する力へ。こうした「判断力重視」の話も、技術的負債の30%理論と同じく、人間の尊厳を保つための建前なのかもしれない。もうジュニアもシニアも関係ない。AIが実装を担当する今、人間の価値は「何を作るべきか」「なぜそれが必要か」を判断する能力にかかってる。でも、その判断すらもAIが上手くやる日が来るんじゃないか？アーキテクトの教科書 価値を生むソフトウェアのアーキテクチャ構築作者:米久保 剛翔泳社Amazon判断力の育成という矛盾した現実ここが皮肉なところなんだけど、「指示通りに動く」ことにおいて、AIは人間をもう完全に上回る。作業者として生きてきた人には厳しい時代だ。でも、「判断者」として生きていく人にとっても、実は同じくらい厳しいかもしれない。判断力って一朝一夕には身につかない。 失敗の経験こそが、AIには真似できない「判断力」を形成するんだけど、簡単な判断をAIが肩代わりすることで、人間が判断力を育てる機会が減ってる。これって完全に矛盾してる。正直に言うと、私にはソフトウェアエンジニアがこれからどうなるかは分からない。 技術的負債の処理がAIに置き換わったように思えたように、システム設計や意思決定も同じ道を辿るかもしれない。「人間にしかできない」とされている領域も、結局は時間の問題なのかもしれません。syu-m-5151.hatenablog.com歴史の転換点で思うこと変わった本質、変わらない幻想ブルックスが『人月の神話』で示した洞察—ソフトウェア開発の本質的な複雑性—は今も変わらない...と言いたいところだけど、本当にそうだろうか？技術的負債という「複雑性」が実は「簡単で単純な仕事の詰め合わせ」だったように、他の「本質的複雑性」も、分解してみれば案外単純なタスクの組み合わせなのかもしれない。 AIという強力な武器を手に入れた今、「人間にしか扱えない複雑性」という概念自体が崩れつつある。新しいトレードオフの幻想技術負債は消えない...と思ってたけど、実際には消えるかもしれない。 「人月の神話」時代のリソース配分問題から、「生成AIのジレンジア」時代の投資判断問題へ。でも、その投資判断すらもAIが最適化する日が来るのかも。新しい課題として挙げられているもの：AIへの過度な依存による思考停止実装能力の空洞化による基礎力低下ベンダーロックインのリスク増大でも、これらの課題も本当に「課題」なのだろうか？ 思考停止と言うけれど、AIの方が適切な判断をするなら、人間が思考する必要はあるのか？実装能力の空洞化と言うけれど、そもそも実装する必要がなくなるなら問題ないのでは？歴史的転換点にいる僕らには、確かに新しいルールを作る機会がある。でも、そのルールが「人間が主役」である必要はないかもしれない。 エンジニアとしての小さなプライドを捨てて、AIと共生する道を探るのが現実的な選択肢なのかも。www.oreilly.comおわりに技術負債は確実に変質した。いや、もっと正確に言うなら、既存の技術負債は消滅に向かっている。これらの話は夢物語かもしれないしどういう着地をするか分からないが「返済」から「管理」へ、そして今度は「自動解決」へ。私たちが長年戦ってきたドラゴンは、AIという新しいプレイヤーによって、あっさりと倒されようとしている。これは技術的負債の終焉なのかもしれない。 少なくとも、私たちが知っている形での技術的負債は。私たちは本当に特別な時代を生きてる。これまでは先人が敷いた道を歩いてきたけど、今は歴史の教科書に載るような大変革の真っ只中にいる。後世の人が「あの時代のエンジニアは、自分たちの仕事がAIに取って代わられることをどう感じていたんだろう」って研究する、まさにその時代の当事者だ。AIは「コードを書く」という行為だけでなく、「技術的負債を処理する」という作業も奪うかもしれない。 でも同時に、それは私たちを膨大な量の「クソめんどくさい仕事」から解放してくれる。もう誰も嫌々レガシーコードと格闘する必要がなくなる。正直に言おう。技術的負債の大部分は、人間の尊厳を保つために「30%は人間の領域」と言っているだけかもしれない。 でもそれでいいじゃないか。エンジニアとしてのアイデンティティを保ちながら、本当に価値のある仕事—「何を作るべきか」「なぜそれが必要か」—に集中できるようになる。技術負債のない世界は、確かにつまらないかもしれない。 でも、その代わりに私たちは新しい種類の問題と向き合うことになる。メタファーとしての臨界点かもしれない。AIとどう協働するか。システムをどう設計するか。ビジネス価値をどう最大化するか。これらは技術的負債とは比べ物にならないほど、創造的で意味のある挑戦だ。技術負債というドラゴンは、もうすぐいなくなるかもしれない。でも、私たちエンジニアの物語は終わらない。 むしろ、やっと本当に面白いチャプターが始まるのかもしれない。さあ、明日からは、技術的負債ではなく、もっと本質的な問題と踊ろう。 AIというパートナーと一緒に、これまで想像もできなかった新しい世界を作っていくために。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[rusqliteを使ってみた]]></title>
            <link>https://zenn.dev/akasan/articles/5e069b51c68db1</link>
            <guid>https://zenn.dev/akasan/articles/5e069b51c68db1</guid>
            <pubDate>Mon, 09 Jun 2025 11:39:01 GMT</pubDate>
            <content:encoded><![CDATA[今回はRustからSQLiteを使うためのrusqliteに入門したので、その紹介をしようと思います。 rusqliteとは？公式のGitHubページによると、ruqsliteはSQLiteをRustから利用するためのラッパーということです。私自身、Pythonを使う時はsqlite3を用いて接続しており、DBの環境構築が不要なので簡単な実装などには利用しています。そこで、Rustでも使えたらいいなと思っていたら使えるとのことだったので今回使ってみました。https://github.com/rusqlite/rusqlite rusqliteを使ってみる 環境構築まず...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[「セキュリティ・キャンプ 2025 全国大会」にスリーシェイク所属のエンジニアが講師として登壇]]></title>
            <link>https://sreake.com/blog/security-camp-2025/</link>
            <guid>https://sreake.com/blog/security-camp-2025/</guid>
            <pubDate>Mon, 09 Jun 2025 01:00:00 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）に所属のエンジニア水元 恭平が、「セキュリティ・キャンプ 2025 全国大会」に講師として登壇することをお知らせいたします。The post 「セキュリティ・キャンプ 2025 全国大会」にスリーシェイク所属のエンジニアが講師として登壇 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：peco]]></title>
            <link>https://zenn.dev/akasan/articles/3020ea9e5b54c2</link>
            <guid>https://zenn.dev/akasan/articles/3020ea9e5b54c2</guid>
            <pubDate>Sun, 08 Jun 2025 08:17:31 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第7回は、pecoというコマンドを紹介します。pecoを使うとクエリを用いてログやプロセスなどをフィルタリングできます。今回はそのようなpecoについて紹介しようと思います。なお、第6回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/5870bda267256b pecoとは？pecoとは公式の説明によると、peco can be a great tool to filter stuff like logs, process stats, find files, because un...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：eza]]></title>
            <link>https://zenn.dev/akasan/articles/5870bda267256b</link>
            <guid>https://zenn.dev/akasan/articles/5870bda267256b</guid>
            <pubDate>Sat, 07 Jun 2025 08:24:02 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第6回は、ezaというコマンドを紹介します。ezaはlsコマンドのモダンな代替コマンドとなっております。どのように使うかについて紹介していきたいと思います。なお、前回の記事などもぜひ参照してもらえると嬉しいです。https://zenn.dev/akasan/articles/a57b277ee7af27 ezaとは？ezaとは公式ページの言及をみるとeza is a modern alternative for the venerable file-listing command-line program ls that ships with Unix...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[zshのコマンド履歴みてみた]]></title>
            <link>https://zenn.dev/akasan/articles/6333702fc35afc</link>
            <guid>https://zenn.dev/akasan/articles/6333702fc35afc</guid>
            <pubDate>Fri, 06 Jun 2025 13:41:14 GMT</pubDate>
            <content:encoded><![CDATA[今回は、私の使っているzshに蓄えられた過去のコマンド履歴について、何を一番使ってきたのかをただ確認したかったので確認するためのコードを書いたという内容を共有します。 実装開始！！！ .zsh_historyのフォーマット意外と~/.zsh_historyを直接みたことがある人は少ないのではないでしょうか？かくいう自分も今回はじめてみました。ファイルは以下のようになっています。以下は最初の20行をお見せしています。このようなフォーマットになっており、実行したコマンドは基本的には;の直ごに来ていそうなので、実装ではその部分を取り出すようにしました。: 1702554011:0;...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Oracle Database＠Google Cloudの紹介～ついに日本のリージョンも使えるようになったぞ！～]]></title>
            <link>https://sreake.com/blog/oracle-database-google-cloud-japan-launch/</link>
            <guid>https://sreake.com/blog/oracle-database-google-cloud-japan-launch/</guid>
            <pubDate>Fri, 06 Jun 2025 10:48:27 GMT</pubDate>
            <content:encoded><![CDATA[2025年4月のGoogle Cloud Nextでの発表から2か月、ついにOracle Database＠Google CloudがTokoy・Osakaリージョンで利用可能になりました。 Oracle Databas […]The post Oracle Database＠Google Cloudの紹介～ついに日本のリージョンも使えるようになったぞ！～ first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Claude Code の CLAUDE.mdは設定した方がいい]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/06/190847</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/06/190847</guid>
            <pubDate>Fri, 06 Jun 2025 10:08:47 GMT</pubDate>
            <content:encoded><![CDATA[[社内共有版「Claude Code、どこまでも」]はじめにClaude Codeを使い始めて1週間。私の開発スタイルは完全に変わった。きっかけは3ヶ月前に書いた「生成AIといっしょ: 動作するきれいなコードを生成AIとつくる」という記事だった。当時はAIとの協業について考察していたが、正直なところ、まだ私が「運転席」に座っているつもりでいた。AIはあくまで「副操縦士」だと。syu-m-5151.hatenablog.com現実は違った。実際にClaude Codeを使ってみて最初に感じたのは、自分の開発スタイルとAIの特性のミスマッチだった。私は根っからの「とりあえずコード書いてみよう」タイプ。設計書？計画？そんなものは書きながら考えればいい—それが私の流儀だった。ところが、AIは違う。指示に対して忠実すぎるのだ。「認証機能を実装して」と曖昧に伝えれば、私の意図とは全く違う方向に突き進んでしまう。かといって、毎回細かく指示を出すのは面倒すぎる。この問題を解決したのがCLAUDE.mdという設定ファイルだった。プロジェクトの文脈、コーディング規約、よく使うコマンド—すべてをAIが理解できる形で記述しておける。これにより、3ヶ月前に理論として描いていた「助手席からの開発」が現実のものとなった。私が大まかな方向を示せば、AIが詳細を埋めてくれる。計画嫌いの私にとって、これほど相性の良いツールはなかった。先日の記事でClaude Codeの基本的な使い方は紹介したが、今回はCLAUDE.mdに焦点を当てて深掘りしたい。実際のプロジェクトで使っている設定を公開し、どのようなワークフローで開発しているかを具体的に示す。syu-m-5151.hatenablog.comもしまだClaude Codeを触ったことがないなら、公式チュートリアルから始めることをお勧めする。また、Anthropicのベストプラクティスも必読だ。本記事はこれらの内容を前提として、より実践的な活用方法を掘り下げていく。docs.anthropic.comwww.anthropic.com全体的に疲れている時の~/.claude/settings.json と~/.claude/CLAUDE.md · GitHub 私の標準の設定もしているのでぜひ、読んでみてもらいたいです。※この記事は社内勉強会で発表した内容をベースに、外部公開用に再構成したものです。CLAUDE.mdとは何か毎回Claude Codeを起動するたびに「うちのプロジェクトはTypeScriptで、ESLintはこの設定で、テストはVitestを使っていて...」と説明するのは面倒だ。チームメンバーが同じプロジェクトで作業する時、全員が同じ説明を繰り返すのも非効率的だ。この問題を解決するのがCLAUDE.mdという特別なファイルだ。何も考えたくなければとりあえず、起動して/initと入力すれば良い。それで終わり。CLAUDE.mdは、Claude Codeが起動時に自動的に読み込む設定ファイルで、プロジェクトの文脈をAIに伝える役割を持つ。アーキテクチャの説明、コーディング規約、よく使うコマンドなど、プロジェクトで必要な情報をすべて記載しておける。一度書けば、毎回の説明が不要になる。docs.anthropic.com実は、CLAUDE.mdには配置場所によって3つの種類がある。最も基本的なのは、プロジェクトルート（./CLAUDE.md）に配置するプロジェクトメモリだ。これはGit管理してチーム全体で共有する。プロジェクトのアーキテクチャ、使用している技術スタック、開発フローなど、チーム全員が守るべきルールを記載する。私の経験では、ここに書く内容がプロジェクトの品質を大きく左右する。次に、ホームディレクトリ（~/.claude/CLAUDE.md）に配置するユーザーメモリがある。これは個人的な設定で、すべてのプロジェクトに適用される。例えば「console.logではなく必ずloggerを使う」といった個人的なコーディングスタイルや、よく使うスニペットを登録しておける。私はここに「コミットメッセージは必ず日本語で書く」という設定を入れている。3つ目の./CLAUDE.local.md（プロジェクトメモリ・ローカル）は現在非推奨となっており、代わりにインポート機能を使うことが推奨されている。Claude Codeがこれらのファイルをどう探すかも理解しておくと便利だ。現在のディレクトリから上位に向かって再帰的に探索し、見つかったものをすべて読み込む。さらに、サブディレクトリ内のCLAUDE.mdも、そのディレクトリのファイルを扱う時に自動的に参照される。つまり、モジュールごとに固有の設定を持たせることも可能だ。これらのメモリファイルは/memoryコマンドで確認・編集できる。ただ、複数のCLAUDE.mdを一度に確認したい場合もあるので、そのためのツール（ccat）も作成した。プロジェクトが大きくなるとCLAUDE.mdも複雑になるので、こういったツールがあると管理が楽になる。github.com探索・計画・コード・コミットのワークフローAnthropicのベストプラクティスでは、このワークフローが推奨されている。最初は「面倒くさそう」と思ったが、実際にやってみると驚くほど効果的だった。計画が苦手な私がこのワークフローを採用する理由私の開発スタイルは昔から一貫している。アイデアが浮かんだらすぐコードを書き始める。設計？後から考えればいい。ドキュメント？動いてから書けばいい。アイデアのつくり方作者:ジェームス W.ヤングCCC MEDIA HOUSEAmazonこのスタイルで10年以上やってきた。そして正直、それなりにうまくいっていた。でもClaude Codeは違った。曖昧な指示を与えると、想像もしない方向に突き進む。「ユーザー認証を実装して」と伝えたら、JWTトークンを使った本格的なOAuth2.0実装を始めてしまった。私が欲しかったのは、シンプルなセッション認証だったのに。そこで気づいた。AIは私の頭の中を読めない。当たり前だが、これが想像以上に大きな問題だった。だからこそ、このワークフローが必要なのだ。探索→計画→実装→コミットという流れは、私の頭の中を整理し、AIに正確に伝えるための仕組みだった。面白いことに、AIのために始めたこの習慣が、私自身のコードの質も向上させた。なぜこのワークフローが効果的なのか「とりあえずコードを書く」スタイルの最大の問題は、全体像が見えないまま進むことだ。気づいたら収拾がつかなくなっている。リファクタリングしようにも、影響範囲が分からない。このワークフローはその問題を解決する。各段階を明確に分けることで、思考が整理される。そして何より、AIが各段階で最適な支援をしてくれる。ステップ1: 探索（関連ファイルの読み込み）最初にやるのは現状把握だ。変更したいコードがどこでどう使われているか、依存関係はどうなっているか。これを理解せずに始めると、後で必ず痛い目を見る。私がよく使うコマンド：@src/services/UserService.ts を読んで、まだコードは書かないで「まだコードは書かないで」という制約が重要だ。これを付けないと、AIは親切心から勝手に実装を始めてしまう。依存関係を調べるときは：UserServiceが依存している他のサービスも確認して複雑なプロジェクトでは、サブエージェントを使うこともある：サブエージェントで、UserServiceのメソッドがどこから呼ばれているか調査してこの探索フェーズで全体像を掴む。急がば回れ、というやつだ。ステップ2: 計画（think モードの活用）探索が終わったら、次は計画だ。ここでClaude Codeの「思考モード」が威力を発揮する。問題の複雑さに応じて使い分ける：このアーキテクチャをthinkで分析して、改善計画を立ててより複雑な問題には：この認証システムの問題をthink hardで検討して、複数の解決策を提示してシステム全体に関わる変更なら：システム全体への影響をthink harderで評価して最近は日本語でも「深く考えて」で動作するようになったらしい。個人的には英語の方が確実だと思うが。zenn.dev計画ができたら必ず文書化する：作成した計画をarchitecture-decisions/001-user-service-refactoring.mdに保存してこの文書化が後で自分を救う。「なぜこの設計にしたんだっけ？」という疑問に即答できる。ステップ3: 実装（検証を含む）計画ができたら、いよいよ実装だ。でも、一気に全部作らない。小さく始めて、段階的に拡張する。計画に従って、まずUserServiceの基本的なリファクタリングを実装して実装したら必ず検証：実装した部分のユニットテストを実行して、既存の機能が壊れていないか確認してエッジケースも忘れずに：nullやundefinedの場合の処理を追加して、エラーハンドリングを強化して途中で問題に気づいたら、軌道修正を恐れない：この実装だと循環依存が発生しそう。別のアプローチを検討して私の経験では、この段階的な実装が品質を大きく左右する。テストリストの作成などもここで行います。一気に作ると、どこで問題が起きたか分からなくなる。ステップ4: コミットとPR作成最後の仕上げがコミットとPR作成だ。ここも手を抜かない。コミットは論理的な単位で分ける：変更をリファクタリング、機能追加、テスト追加の3つのコミットに分けてコミットメッセージはConventional Commitsに従う：feat: ユーザーサービスに新しい認証メソッドを追加refactor: UserServiceの内部構造を改善test: UserServiceの新機能に対するテストを追加PRの説明は詳細に：PRを作成して。以下を含めて：- 変更の背景と目的- 実装アプローチの説明- テスト方法- 破壊的変更の有無- レビュアーへの注意点最後にドキュメントの更新も忘れずに、これらはCLAUDE.mdに記載してもよいREADME.mdとCLAUDE.mdも更新して、新しい機能とその使い方を記載してこのワークフローを続けた結果、コードの品質が明らかに向上した。何より、「なんとなく動く」コードから「なぜ動くか説明できる」コードになった。計画嫌いの私でも、このワークフローの価値は認めざるを得ない。テスト駆動開発（TDD）ワークフローの深掘りTDDについて正直に話そう。3ヶ月前の記事では理想論を書いた。でも現実は全然違う。正直なところ、TDDはいつも使うわけじゃない私のTDD使用率は、せいぜい10%くらいだ。5%ぐらいかもしれない。なぜそんなに低いのか。理由は単純で、私は「作りながら考える」タイプだから。最初から仕様が決まっていることなんて、実際に私がやっているような開発ではほとんどない。要求があるだけです。顧客も「動くものを見てから判断したい」と言うし、私も「とりあえず動かしてみないと分からない」と思っている。でもClaude Codeを使い始めて、面白い発見があった。AIこそがTDDを必要としているのだ。「また生き返ったのかTDD」と思うかもしれない。でも今回は違う。人間のためのTDDではなく、AIのためのTDDだ。TDDがAIコーディングで特に重要な理由AIの問題は「親切すぎる」ことだ。テストがないと、頼んでもいない機能まで実装してしまう。「ユーザー認証を実装して」と言ったら、ログイン履歴機能やパスワードリセット機能、二要素認証まで作り始める。テストがあれば違う。「このテストが通ればOK」という明確なゴールがある。AIは迷わない。過剰な実装もしない。これが快適だ。私がTDDを使う「よっぽど決まっているとき」では、具体的にどんな時にTDDを使うのか。1. APIのインターフェースが確定したときOpenAPI仕様書がある場合は迷わずTDDだ。リクエストとレスポンスの型が決まっていて、エラーケースも定義されている。こういう時は最初にテストを書く方が早い。2. 既存機能のリファクタリング「動作を変えずに内部構造を改善する」という明確な目標がある。現在の動作をテストで固定してから、安心してリファクタリングできる。3. バグ修正「このバグ、二度と出したくない」という強い決意がある時。再現手順が明確で、期待される動作も分かっている。テストを書いてから修正すれば、同じバグは二度と起きない。つまり、ゴールが明確な時だけTDDを使う。探索的な開発では使わない。これが私の現実的なアプローチだ。ステップ1: テストファーストAIとTDDを組み合わせる時、最初のテスト作成が肝心だ。例えば、ユーザー認証機能を作る場合：UserService.authenticateメソッドのテストを作成して。以下のケースをカバー：- 正常な認証成功- パスワード不一致- ユーザーが存在しない- アカウントがロックされている- 連続失敗によるロックポイントは「網羅的に書く」こと。人間なら「まあこれくらいでいいか」と手を抜くところも、AIは真面目に全部実装してくれる。あと、個人的にはモックを使わない派だ：実際のデータベース接続を使用してテストを作成。モックは使わないモックを使うと、実際の動作と乖離することがある。開発環境でDockerを使えば、本物のデータベースでテストできる。遅い？確かに。でも「動くと思ったのに本番で動かない」よりマシだ。あと同時に大切なのが本番環境を絶対に触らせないことです。ステップ2: RED - 失敗の確認テストを書いたら、必ず失敗することを確認する。これ、意外と重要。npm test -- UserService.test.ts失敗を見たら、AIに分析してもらう：テストの失敗理由を分析して。以下の観点で：- コンパイルエラーか実行時エラーか- 期待値と実際の値の差異- 未実装による失敗か、バグによる失敗かなぜわざわざ失敗を確認するのか。「最初から成功するテスト」は信用できないからだ。それはテストが甘いか、既に実装されているかのどちらかだ。ステップ3: GREEN - 最小限の実装ここでAIの「親切心」と戦う必要がある。テストが通る最小限の実装を作成して。過度な最適化や追加機能は含めないそれでもAIは余計なことをしたがる。だから明示的に制約する：IMPORTANT: テストケース以外の機能は実装しないYOU MUST: 各実装ステップ後にテストを実行して確認段階的に進めるのもコツだ：まず最も単純なケース（正常な認証）から実装を始めて一気に全部作らせると、どこで問題が起きたか分からなくなる。ステップ4: REFACTOR - コードの改善テストが通ったら、ようやくリファクタリングだ。ここでAIの本領発揮。テストが通ることを確認しながら、以下の観点でリファクタリング：- 重複コードの除去- 可読性の向上- パフォーマンスの最適化- ドキュメントの記載(README.md,CLAUDE.md,etc)- コメントの記載個人的には、このタイミングでドキュメントを書いてもらうことが多い。実装が終わってからだと、細かい仕様を忘れてしまうから。時には複数の改善案を比較することも：このコードの問題点を指摘して、改善案を3つ提示してAIは客観的に問題点を指摘してくれる。人間のレビュアーと違って、遠慮がない。便利なショートカットとツールClaude Codeには知らないと損するショートカットがたくさんある。docs.anthropic.com@ ファイル選択の効果的な使い方最も使うのが@によるファイル選択だ。基本形：@src/services/UserService.ts のcreateUserメソッドを改善してでも、本当の威力は複数ファイルを扱う時に発揮される：@src/services/UserService.ts と @src/models/User.ts を見て、データフローを説明してAIが関連ファイルを横断的に分析してくれる。人間だと「えーと、このファイルとあのファイルを開いて...」となるところが、一瞬で終わる。ディレクトリ全体を見ることも：@src/services/ ディレクトリのすべてのサービスの概要を説明して私のお気に入りはワイルドカード：@**/*Service.ts すべてのサービスファイルで共通のパターンを見つけてリファクタリングの時、これで共通化できる部分を見つけてもらう。通知設定これ、本当に知らない人が多い。Claude Codeは長時間のタスクも黙々とこなしてくれるが、通知設定をしていないと完了に気づけない。docs.anthropic.com私は「タスク完了時に音を鳴らす」設定にしている。コーヒーを飲みながら待てる。# ルール追加の戦略的活用その場限りのルールを追加したい時は#を使う：#このプロジェクトではzodでバリデーション。yupは使わない#エラーメッセージは必ず日本語で記述#APIレスポンスは必ずcamelCaseで統一CLAUDE.mdに書くほどでもない、一時的なルールに便利だ。例えば「今日は英語のコメントで統一」みたいな時に使う。ルールの優先順位は：1. セッション中の#コマンド（最優先）2. プロジェクトのCLAUDE.md3. ユーザーのCLAUDE.md（~/.claude/）この階層を理解していると、柔軟にルールを管理できる。スクショを使う、CleanShot Xを購入せよ私のTDD使用率コードだけでなく、ビジュアルでの確認も重要だ。特にUI開発では必須。なぜCleanShot XなのかmacOSの標準スクリーンショットも悪くない。でもCleanShot Xは別次元だ。cleanshot.com何が違うか：- 撮影後すぐに注釈を追加できる（矢印、テキスト、モザイク）- スクロールキャプチャで長いページも1枚に- GIF録画で操作手順を記録- クラウドにアップロードしてURLで共有特に「注釈」機能が神。「ここのマージンがおかしい」とか「このボタンの色を変えて」とか、視覚的に伝えられる。Claude Codeとの連携テクニック私のワークフロー：CleanShot Xでスクリーンショット（Cmd+Shift+4）問題箇所に赤丸や矢印で注釈Claude Codeにドラッグ&ドロップ例えば：このデザインモックアップに基づいてコンポーネントを実装して画像を見せながら指示すると、AIの理解度が格段に上がる。「左側のサイドバーの幅を...」とか説明するより、画像1枚の方が早い。バグ報告でも威力を発揮：このエラー画面が表示される原因を調査して修正してエラーメッセージだけでなく、画面全体の状態を伝えられる。セッション管理とコンテキストの継続性「昨日の続きから作業したいけど、どこまでやったっけ？」この問題、Claude Codeなら解決できる。でも意外と知られていない。継続的な開発フローの構築朝一番のコマンド：$ claude --continueこれで前回のセッションの続きから始められる。AIは前回の作業内容を覚えている。特定のセッションを選びたい時：$ claude --resume複数のプロジェクトを並行して進めている時に便利。プロンプト履歴の編集:[Esc][Esc] → 前のプロンプトを編集 → EnterダブルEscapeで過去のプロンプトを編集可能。異なるアプローチを試すときに便利。具体的な指示を心がける。私の日課は、1日の終わりに：今日の作業内容を要約して、明日やるべきことをリストアップしてこれをやっておくと、翌日スムーズに始められる。AIが秘書みたいに働いてくれる。コンテキストの最適化長時間作業していると、コンテキストがゴチャゴチャしてくる。そんな時は：/clearでリセット。その後：@CLAUDE.md を読んで、プロジェクトのコンテキストを復元してこれで必要な情報だけを再読み込みできる。「お前は公式ドキュメントを読んでないな！？」と言いたくなるくらい、みんなこの機能を知らない。もったいない。3ヶ月前の理論が現実になって3ヶ月前、私は生成AIとの未来について妄想を書いた。「助手席での開発」「レッドボックス」「バイブスコーディング」...正直、半分くらいは願望だった。 speakerdeck.comでも、Claude Codeを1週間使った今、それらは全て現実になっている。いや、想像以上だった。助手席での開発が意外と楽しい「運転席を譲る」ことへの恐怖があった。エンジニアとしてのアイデンティティが揺らぐような気がして。でも実際は違った。助手席は助手席で、やることがたくさんある。私の役割：目的地を決める（何を作るか）ルートを提案する（アーキテクチャ）危険を察知する（セキュリティ、パフォーマンス）Claudeの役割：実際の運転（コーディング）交通ルールの遵守（言語仕様、ベストプラクティス）効率的なルート選択（アルゴリズム、最適化）この役割分担が心地いい。特に「計画は苦手だけどアイデアは豊富」な私にとって、理想的なパートナーだ。レッドボックスとの遭遇実際にあった話。Claude Codeがこんなコードを生成した：// Claudeが生成した謎のTypeScript型パズルtype DeepPartial<T> = T extends object ? {  [P in keyof T]?: DeepPartial<T[P]>;} : T;type RecursiveRequired<T> = T extends object ? {  [P in keyof T]-?: RecursiveRequired<T[P]>;} : T;正直、5秒見つめても理解できなかった。これが「レッドボックス」だ。でも大丈夫。CLAUDE.mdに追加すればいい：## 理解困難なコードへの対処- IMPORTANT: 複雑な型定義には必ず使用例とコメントを追加- YOU MUST: 生成したコードの動作原理を説明できることこれで次からは、AIが勝手に説明を追加してくれる。バイブスコーディングの実践これが一番楽しい発見だった。曖昧な指示でも、AIは文脈を読んでくれる：なんか認証周りがイケてない気がする。もっとスマートにしてこのUIのレイアウト、もうちょっとモダンな感じにしてパフォーマンスがビミョーだから、なんとかして「ビミョー」で伝わるAI。これがCLAUDE.mdの威力だ。プロジェクトの文脈を理解しているから、曖昧な指示でも適切に解釈してくれる。実践的なCLAUDE.md設定例理論はもういい。実際のCLAUDE.mdを見せよう。私が開発しているcctxプロジェクトから、効果的な部分を抜粋する。プロジェクト概要：読みやすさの工夫# 🔄 CLAUDE.md - cctx Project Documentation## 📋 Project Overview**cctx** (Claude Context) is a fast, secure, and intuitive command-line tool for managing multiple Claude Code `settings.json` configurations. Built with Rust for maximum performance and reliability.## 🏗️ Architecture### 🎯 Core Concept- **🔧 Context**: A saved Claude Code configuration stored as a JSON file- **⚡ Current Context**: The active configuration (`~/.claude/settings.json`)- **📁 Context Storage**: All contexts stored in `~/.claude/settings/`- **📊 State Management**: Current and previous context tracked in `.cctx-state.json`絵文字を使っているのは、人間（つまり私）が見た時に分かりやすいから。AIは絵文字なくても理解するが、私が理解できない。AIへの具体的な指示：成功の秘訣曖昧な指示より具体的な指示の方が成功率が大幅に向上します。曖昧さは、AIには毒だ。## 📚 Notes for AI AssistantsWhen working on this codebase:1. **Always run `cargo clippy` and fix warnings** before suggesting code2. **Test your changes** - don't assume code works3. **Preserve existing behavior** unless explicitly asked to change it4. **Follow Rust idioms** and best practices5. **Keep the kubectx-inspired UX** - simple, fast, intuitive6. **Maintain predictable defaults** - user should never be surprised7. **Document any new features** in both code and README8. **Consider edge cases** - empty states, missing files, permissionsRemember: This tool is about speed and simplicity. Every feature should make context switching faster or easier, not more complex. **Predictability beats cleverness.**最後の一文が効いている。「賢いより予測可能」。AIは時々、賢すぎる解決策を提案してくる。でもユーザーが求めているのは、予測可能な動作だ。開発ガイドライン：チェックリストの威力### Testing ChecklistWhen testing changes, verify:- [ ] `cctx` lists all contexts correctly- [ ] `cctx <n>` switches context- [ ] `cctx -` returns to previous context- [ ] Error messages are clear and helpful- [ ] State persistence works across sessionsチェックリスト形式にすると、AIもチェックしながら作業してくれる。レビュー時も楽。プロンプト改善のテクニックAnthropic公式が推奨する強調表現、実は3段階ある。使い分けが重要だ。強調レベルの使い分けNEVER（絶対禁止）：NEVER: パスワードやAPIキーをハードコーディングしないNEVER: ユーザーの確認なしにデータを削除しないNEVER: テストなしで本番環境にデプロイしないこれは本当にやってはいけないこと。AIは素直なので、明示的に禁止しないとやってしまう可能性がある。YOU MUST（必須事項）：YOU MUST: すべての公開APIにドキュメントを記載YOU MUST: エラーハンドリングを実装YOU MUST: 変更前に既存テストが通ることを確認必ずやってほしいこと。でも、状況によっては例外もありえる。IMPORTANT（重要事項）：IMPORTANT: パフォーマンスへの影響を考慮IMPORTANT: 後方互換性を維持IMPORTANT: セキュリティベストプラクティスに従う考慮してほしいこと。判断はAIに委ねる。この3段階を使い分けることで、AIの行動を適切にコントロールできる。高度な活用：並行開発とCI/CDカスタムスラッシュコマンドで定型作業を自動化公式例：GitHub Issue対応の自動化.claude/commands/fix-github-issue.md:Please analyze and fix the GitHub issue: $ARGUMENTS.Follow these steps:1. Use `gh issue view` to get the issue details2. Understand the problem described in the issue3. Search the codebase for relevant files4. Implement the necessary changes to fix the issue5. Write and run tests to verify the fix6. Ensure code passes linting and type checking7. Create a descriptive commit message8. Push and create a PRRemember to use the GitHub CLI (`gh`) for all GitHub-related tasks.使用方法：> /project:fix-github-issue 1234Git Worktreeで複数タスクを同時進行これは上級テクニック。でも覚えると手放せなくなる。git-scm.com例えば、機能開発しながらバグ修正もしたい時：# 機能開発用worktree$ git worktree add ../project-feature-auth feature/auth# バグ修正用worktree  $ git worktree add ../project-bugfix-api bugfix/api-error# 各worktreeで独立したClaude Codeセッション$ cd ../project-feature-auth && claude$ cd ../project-bugfix-api && claudeそれぞれのディレクトリで独立したClaude Codeセッションが動く。コンテキストが混ざらない。最高。というか人の業の深さを感じれてよい…。CI/CDへの統合Claude Codeはコマンドラインツールなので、CI/CDにも組み込める。docs.anthropic.comGitHub Actionsの例：- name: Claude Code Review  run: |    claude -p "このPRの変更をレビューして、以下の観点で問題を指摘：    - セキュリティ脆弱性    - パフォーマンス問題    - コーディング規約違反" \    --output-format json > review.json自動化できることは自動化する。人間はもっとクリエイティブなことに時間を使うべきだ。permissions.allowの推奨設定セッション中に「Always allow」を選択するか、/permissionsコマンドで追加できるがsetting.json でも追加できる。syu-m-5151.hatenablog.com公式が推奨する基本的な許可リスト：{  "permissions": {    "allow": [      "List(*)",      "Fetch(https://*)",      "Edit(*)",      "Bash(git:*)",      "Bash(npm:*)",      "Bash(ls:*)",      "Bash(cat:*)",      "Bash(mkdir:*)",      "Bash(mv:*)"    ]  }}まとめClaude Codeを1週間使い込んで確信した。CLAUDE.mdは単なる設定ファイルじゃない。AIとの共通言語だ。youtu.be3ヶ月前、私は理想を語った。「生成AIとの協業で『動作するきれいなコード』を実現する」と。正直、半分は願望だった。syu-m-5151.hatenablog.comでも今、それは現実になっている。私は「助手席」に座り、AIが「運転席」でコードを書く。最初は違和感があったが、今では心地いい。むしろ、なぜ今まで全部自分でやろうとしていたのか不思議にさえ思う。www.oreilly.com3ヶ月で変わったこと、変わらなかったこと変わったこと：理論が実践になった曖昧な指示でも伝わるようになったコードの品質が向上した開発速度が圧倒的に上がった変わらなかったこと：計画を立てるのは相変わらず苦手TDDへの抵抗感は残っている「とりあえず動かしてみる」精神は健在コードを書く楽しさは失われていない最後の点が重要だ。AIに仕事を奪われたのではない。つまらない部分を任せて、楽しい部分に集中できるようになった。効果的なCLAUDE.mdを書くコツ：明確なプロジェクト概要 - AIも人間も理解できるように具体的なワークフロー - 探索→計画→実装→コミット実用的なコマンド集 - よく使うものを網羅AIへの明示的な指示 - NEVER、YOU MUST、IMPORTANTを使い分けるこれらを押さえれば、AIは最高のパートナーになる。「予測可能性は賢さに勝る」 - この原則を胸に、CLAUDE.mdを育てていこう。3ヶ月後、私はまた記事を書いているだろう。タイトルは分からない。でも一つ確実なのは、私はまだ助手席に座っているということ。そして、それを楽しんでいるということだ。なぜなら、助手席こそが最も楽しい席だから。他社も同じぐらいのプランをいずれ出すのでCodex CLIやjulesが楽しみです。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ddc.vimによるシェルコマンドの補完が速くなったぞ]]></title>
            <link>https://blog.atusy.net/2025/06/06/ddc-source-shell_native-is-faster/</link>
            <guid>https://blog.atusy.net/2025/06/06/ddc-source-shell_native-is-faster/</guid>
            <pubDate>Fri, 06 Jun 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[ddc-source-shell_nativeを使うとシェルコマンドの補完ができます。従来は補完候補を取得するたびにシェルを起動するため時間がかかりましたが、シェルを常駐させることで高速化してもらいました。]]></content:encoded>
        </item>
    </channel>
</rss>