<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Mon, 10 Nov 2025 07:50:50 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[おい、冷笑すんな]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/11/10/084205</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/11/10/084205</guid>
            <pubDate>Sun, 09 Nov 2025 23:42:05 GMT</pubDate>
            <content:encoded><![CDATA[はじめにSNSを開けば、今日もまた誰かが何かに本気だ。新しい技術やフレームワークに興奮するエンジニア。最新のビジネス書を読んで「人生が変わった」と叫ぶビジネスパーソン。世の中の理不尽に憤慨し、世界を変えようと声を上げる活動家。生成AIの新機能やツールのアップデートに「未来が来た」と歓喜する人々。自己啓発系インフルエンサーの「新しい生き方」に感銘を受け、それがストア哲学やブッダの教えの言い換えに過ぎないと気づかない人々。世の中には、あらゆることに本気になれる人がいるものだ。私は、一歩引いた場所から、彼らを観察していた。興味深い現象として。分析対象として。本を読んだ。いろんな本を。技術書も哲学書も歴史書も。視野が広がった。気づけば環境問題も、格差も、戦争も、技術トレンドも、ビジネス理論も、すべてが複雑に絡み合った世界が見えていた。そして同時に、絶望も見えた。簡単な解決策などない。誰かの正義は誰かの不正義になる。理想を語る人々は、現実を知らないナイーブな存在に見える。新しい技術に興奮する人々は、過去の失敗から学んでいない。いつの間にか、私は冷笑するようになっていた。「どうせ無理だ」「意識高いなー(笑)」「また同じパターンか」。この言葉が、自然と口をついて出る。誰かの熱狂を見るたびに、冷めた目で見る。誰かの理想を聞くたびに、「現実はもっと複雑だ」と心の中で呟く。冷笑は、気持ち良かった。「ほら、やっぱりね」という優越感。自分は騙されていない。自分は賢い。自分だけが、一歩引いた場所から、冷静に世界を見ている。そして何より、楽だった。本気で向き合わなくていい。熱狂しなくていい。責任を取らなくていい。傍観者でいればいい。シニカルな冷笑主義者としてのアイデンティティが、確立しつつあった。でも、ある時、気づいた。自分は、冷笑と批判と批評の違いが分かっていなかった。そして同時に、世の中の多くの人も分かっていない。建設的な批判を「冷笑主義だ」とレッテル貼りして封じようとする人がいる。一方で、ただの冷笑を「正当な批判だ」と正当化する人もいる。視野を広げることは重要だ。でも、視野を広げすぎると、絶望に囚われる。冷笑してはいけない。でも、批判することは必要だ。この複雑さは、白か黒かで割り切れない。グラデーションを見る必要がある。そして、すべてに答えを出そうとする必要などない。視野を広げすぎた先で絶望する人は、「すべてを理解し、すべてに答えを出さなければならない」という幻想に囚われている。でも、自分の限界を認め、自分が語れる一点に集中すればいい。これは、視野を広げすぎて冷笑に陥った一人の人間が、そこから抜け出そうともがいた記録だ。明確な答えがあるわけではない。でも、少なくとも、「冷笑と批判と批評は違う」という認識から始めることはできる。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。冷笑と批判と批評を分けるまず、最も重要な区別をする必要がある。冷笑と、批判と、批評は、まったく別のものだ。批判は、方法を問う批判は、対象の方法や論理の問題点を具体的に指摘することだ。「ここに問題がある。なぜならこういう理由だ。こうすればより良くなる」。批判は、相手の動機を尊重する。「あなたが目指していることは理解できる。でも、この方法では難しい」。動機は肯定し、方法を問う。批判は、具体的だ。「ここのロジックが弱い」「このデータは信頼性が低い」「この前提は間違っている」。何が問題なのか、明確に指摘する。批判は、代替案を持つ。「こうしたらどうか」「この方法の方が良い」「別の視点から考えると」。ダメ出しで終わらず、次につながる提案をする。批判は、建設的だ。次の行動につながる。改善の機会を生む。批評は、価値を問う批評は、対象を評価・分析することだ。「この作品の意図は何か」「この技術はどういう文脈で生まれたのか」「これはどういう意味を持つのか」。批評は、対象を理解しようとする。表面だけでなく、背景にある思想や文脈を読み解こうとする。批評は、多面的だ。1つの視点だけでなく、複数の視点から対象を見る。「こういう見方もできる」「別の角度から見ると」。批評は、深さを求める。表面的な評価ではなく、本質的な価値を問う。批評は、対話的だ。対象との対話。読者との対話。異なる解釈との対話。冷笑は、動機を疑う冷笑は、対象の動機そのものを疑い、嘲笑することだ。「どうせ自己満足だろう」「意識高い系(笑)」「偽善者め」。冷笑は、曖昧だ。具体的な問題点を指摘するのではなく、全体を漠然と貶める。「ダメなものはダメ」「どうせ無理」。冷笑は、代替案を持たない。否定するだけ。笑うだけ。次がない。冷笑は、破壊的だ。何も生み出さない。改善の機会を奪う。対話を殺す。重要なのは、この区別を高解像度で見ること「このコードは、こういう理由でスケールしない。別のアプローチを検討すべきだ」――これは批判だ。具体的に問題点を指摘し、方向性を示している。「このコードは素人レベル」――これは冷笑だ。曖昧に貶めているだけで、何が問題なのか、どう改善すべきなのか、何も示していない。「この技術ブログは、初心者向けとしては分かりやすい。ただ、この部分の説明は不正確だ。正確には〜という動作をする。この違いを明記した方が、読者の理解が深まる」――これは批判だ。評価した上で、具体的な問題点と改善案を示している。「この技術ブログは浅い。もっと深い内容を期待していた」――これは批評寄りだが、曖昧だ。何が浅いのか、どういう深さを期待していたのか、明確ではない。「この技術ブログを書いた人は、目立ちたいだけ。本当に理解しているのか怪しい」――これは冷笑だ。動機を疑い、能力を貶めている。この違いを理解せずに、すべての批判を「冷笑主義だ」とレッテル貼りすることは、危険だ。逆に、すべての冷笑を「正当な批判だ」と正当化することも、危険だ。高解像度で見ること。その発言は、動機を問うのか、方法を問うのか、価値を問うのか。具体的なのか、曖昧なのか。代替案があるのか、ないのか。この区別ができて初めて、冷笑と批評を適切に扱える。日常での例：若い新卒のエンジニアが「新しいフレームワークを使いたい」と提案した場合。冷笑的な反応なら →「また流行に乗りたいだけでしょ(笑)　どうせすぐ廃れるよ」（動機を疑い、否定する）批判的な反応なら →「このプロジェクトの規模だと過剰設計では。まず既存の技術で試してから判断しては」（方法を問い、代替案を示す）批評的な反応なら →「なぜそのフレームワークが適切だと考えたのか聞かせて。チームの学習コストも含めて検討したい」（価値を問い、理解しようとする）友人が「副業を始めたい」と話した場合。冷笑的な反応なら →「意識高いなー(笑)　どうせ続かないって」（動機を疑い、嘲笑する）批判的な反応なら →「本業との時間配分は大丈夫。週にどれくらい時間を確保できそう」（具体的な問題点を確認する）批評的な反応なら →「副業を始めたい理由は何だろう。収入、スキル、それによってアプローチが変わるはず」（背景を理解しようとする）正直に言おう、冷笑は気持ちいい――その快楽の解剖冷笑は、気持ちいい。それを否定する必要はない。しかし、その快楽の正体を、高解像度で見てみよう。優越感という麻薬誰かが理想を語る。「世界を良くしたい」「この技術で社会を変えたい」と。その瞬間、頭の中で何かが動く。「どうせ無理だろう」。この声は、静かだ。でも、確信に満ちている。そして、案の定その人が失敗する。プロジェクトが頓挫する。理想が現実の前に砕ける。「ほら、やっぱりね」この瞬間の快感。私は騙されなかった。私は現実を見ていた。私は賢かった。他の人々が理想に浮かれている中で、私だけが冷静だった。私だけが「本当のこと」を見抜いていた。この優越感は、麻薬のようだ。一度味わうと、また求めてしまう。ゼロコストの知的快楽誰かが情熱を持って何かに取り組んでいる。深夜まで残ってコードを書いている。週末も技術を学んでいる。カンファレンスで登壇している。「意識高い系(笑)」この一言で、その人の努力、情熱、時間、すべてを無効化できる。その人が本気で何かを信じていることを、「ナイーブだ」と笑える。そして、自分は安全地帯にいる。リスクを取っていない。傷つかない。行動するには、時間がかかる。エネルギーがかかる。リスクを取る必要がある。失敗する可能性がある。傷つく可能性がある。でも、冷笑するだけなら、何もいらない。そして、何より、楽だ。本気で向き合わなくていい。深く考えなくていい。責任を取らなくていい。斜めから見ていればいい。一歩引いた場所から観察していればいい。「あいつら、必死だな」と笑っていればいい。この楽さは、中毒性がある。一度この楽さを知ってしまうと、本気で向き合うことが馬鹿らしく感じる。必死になることが恥ずかしく感じる。「冷静な自分」でいることが、賢いことのように思える。冷笑は、気持ちいいだけじゃない。楽なのだ。キーボードを叩くだけで、誰かの努力を無効化できる。マウスをクリックするだけで、誰かの理想を笑える。何も作らず、何も提案せず、何もリスクを取らず、批判するだけ。笑うだけ。「どうせ無理」と言うだけ。それで「賢い人」として扱われる。「現実を見ている人」として認められる。「冷静な分析ができる人」として評価される。知的ゲームとしての矛盾指摘誰かの矛盾を指摘する。プレゼンの中の論理の穴を見つける。ブログ記事の中の曖昧な表現を突く。コードの中の非効率な実装を指摘する。「ここ、おかしくないですか?」相手が言葉に詰まる。説明に窮する。その瞬間の快感。私は頭がいい。私は見抜いた。私は勝った。矛盾を見抜く知的な快楽。現実を冷静に分析する快楽。感情に流されない快楽。誰かが必死になっている姿を、客観的に観察する快楽。「みんな必死だな」と、一歩引いた場所から眺める快楽。これは、ある種のゲームだ。相手の弱点を見つける。論理の隙を突く。勝敗がはっきりしている。そして、勝てば気持ちいい。即座の承認と自己肯定誰かがブログ記事を書く。読む。矛盾を見つける。コメント欄に書き込む。「ここの説明は不正確ですね」。投稿ボタンを押す。数時間後、通知が来る。誰かが「いいね」をした。誰かがリツイートした。「鋭い指摘ですね」というリプライが来た。この瞬間の快感。私は認められた。私は賢いと思われた。私の知性が評価された。そして、何より、私は何も失っていない。ブログ記事を書くのに何時間もかかる苦労はしていない。推敲する時間もかけていない。公開する勇気も必要なかった。ただ、数分で批判を書いただけ。それで、評価された。これが、冷笑の快楽の本質だ。最小のコストで、最大の優越感と承認を得られる。この「豊かさ」は本当に豊かなのか「冷笑主義に関してはお前の感性が乏しいだけ。楽しめる人の方がよっぽど豊かなんです」――この言葉には、一理ある。確かに、冷笑を楽しめることは、ある種の知的な能力だ。矛盾を見抜く力。現実を分析する力。感情に流されない力。これらは価値がある。でも、問題は別のところにある。その快楽が、あなた自身の行動を止めていないか。優越感が、成長を止めていないか。その「豊かさ」が、実は安全地帯に留まるための言い訳になっていないか。冷笑を楽しめることが豊かなのではない。冷笑の快楽を知った上で、それでも行動することが豊かなのだ。矛盾を見抜く力を持った上で、何かを信じること。現実の複雑さを知った上で、一歩を踏み出すこと。感情に流されない力を持った上で、感動すること。本当の豊かさは、冷笑の快楽と、行動の勇気の、両方を持つことだ。冷笑だけを楽しむことは、豊かではない。それは、片足だけで立っているようなものだ。バランスを欠いている。持続しない快楽の正体そして、もっと重要なことがある。冷笑の快楽は、短期的なものだ。その瞬間は気持ちいい。「ほら、やっぱりね」と優越感を覚える。「私は賢い」と自己肯定感が満たされる。でも、この快楽は持続しない。なぜなら、冷笑は何も生み出さないからだ。一年後、十年後、あなたが振り返った時、冷笑していた時間は何を残しているだろうか。「あの時、あのブログ記事の矛盾を指摘した」という記憶。「あの時、あのプロジェクトが失敗すると予測した」という記憶。優越感を覚えた瞬間の記憶だけだ。それ以外に何も残っていない。一方、建設的に関わった時間は結果を残す。行動した時間は、さらに多くを残す。失敗も成功も学びも成長も、すべて残る。そして、何より、「自分は行動した」という事実が残る。ブログを書いた。コードを書いた。プレゼンをした。プロジェクトを立ち上げた。失敗した。学んだ。また挑戦した。これらは、すべて残る。あなたの中に残る。世界に残る。だから、私はこう問いたい。冷笑を楽しむことが豊かだというなら、その豊かさは、十年後にも残っているのか。感性が乏しいのは、冷笑を楽しめない人ではない。冷笑の快楽しか知らない人だ。本当に感性が豊かな人は、冷笑の快楽も、批評の深さも、行動の喜びも知っている。創造する充実感も知っている。私は、冷笑の快楽を否定しない。ただ、それが唯一の快楽だと思わないでほしい。それがすべてだと思わないでほしい。もっと大きな快楽がある。もっと深い充実感がある。もっと持続する豊かさがある。それは、行動すること。創造すること。リスクを取ること。そして、時には失敗すること。冷笑の快楽を知った上で、それでも行動する。この両方を知っている人こそが、本当に豊かな人だ。視野を広げた先にある絶望。そして冷笑へ視野を広げれば広げるほど、世界の複雑さが見えてくる。簡単な解決策などない。どんな行動にも副作用がある。誰かの正義は、誰かの不正義になる。理想的な制度など存在しない。すべてはトレードオフだ。視野を広げれば広げるほど、世界は希望ではなく絶望に満ちているように見えてくる。何かを変えようとする試みは、あまりにも無力に見える。理想を語る人々は、現実を知らないナイーブな存在に見える。そして、この絶望が、冷笑を生む。冷笑主義は、絶望の裏返しだ。世界を変えられないという絶望。自分には力がないという絶望。この絶望を直視する代わりに、他人を嘲笑することで、自分は少なくとも「騙されていない賢い人間だ」と思い込む。視野を広げすぎて、複雑さに圧倒されて、行動が麻痺する。そして、その麻痺を正当化するために、冷笑する。「どうせ無理だ」と言っておけば、自分が行動しないことを正当化できる。「現実はもっと複雑だ」と言っておけば、他人の試みを笑える。「あなたは世界を知らない」と言っておけば、自分は賢いと思える。これが、視野を広げすぎることの罠だ。世界の複雑さを知ることは重要だ。でも、その複雑さに圧倒されて、行動を止めてしまうなら、知らない方がマシだったかもしれない。視野を広げることで、私は批判と冷笑の違いを学んだ。でも同時に、冷笑の甘い罠にも落ちかけた。語りえぬものについて――あるいは、全てに答えを出そうとする傲慢さ視野を広げすぎた先で、私はもう1つの重要なことに気づいた。世の中には、言葉で説明できないことがある。道徳、倫理、美しさ、信仰。これらは論理的に「正解」を出せるものではない。でも、視野を広げすぎた人間は、これらにも「正しい答え」があると思い込む。全てを言葉で説明できると考える。全てを論理的に割り切れると信じる。そして、答えが出せないことに気づくと、絶望する。「こんなに複雑なのか」「矛盾だらけじゃないか」「結局、誰も答えを持っていない」。その絶望が、冷笑を生む。でも、待ってほしい。そもそも、全てに答えを出す必要などないのだ。環境問題について、明確な答えを持つ必要はない。格差について、万人が納得する解決策を見つける必要はない。技術選定について、絶対的に正しい判断を下す必要はない。言葉で説明できないことは、説明しなくていい。答えが出ないことは、答えを出さなくていい。世の中が広がりすぎて、全てを理解することなど不可能なのだ。これは諦めではない。冷笑でもない。これは、自分の限界を謙虚に認めることだ。言葉で全てを割り切れると考えてしまうのは、人間の「おごり」だ。この傲慢さが、視野を広げすぎた人を冷笑に追い込む。「全てに答えを持たなければならない」というプレッシャーが、「どうせ答えなんてない」という絶望を生む。そして、絶望が冷笑を生む。でも、本当は違う。全てに答えを出そうとしなくていい。自分が深く関わる一点だけに集中すればいい。他のことは、今は考えなくていい。今は分からないことは、分からないままでいい。視野を広げることで、世界の複雑さを知る。それは大切だ。でも、その複雑さの全てに答えを出そうとする必要はない。説明できないものは、無理に説明しなくていい。そして、自分が語れる一点、自分が行動できる一点に、全力を注げばいい。これを「冷笑主義だ」と言うなら、それは誤解だ。私は何も冷笑していない。ただ、自分の限界を認めている。全てを説明できるという幻想を捨てている。そして、その上で、自分にできることに集中している。考えを言葉にすることと、冷笑は違う。答えを出さないことと、冷笑は違う。低い解像度で混同するな。視野を広げて複雑さを知ることと、その複雑さの全てに答えを出そうとすることは違う。むしろ、自分が深く関わる一点だけに集中する――この視野を意図的に狭めることこそが、冷笑から抜け出す鍵になる。境界線は、実は曖昧だここで重要な認識がある。冷笑と批判と批評の境界線は、明確ではない。私が「これは建設的な批判だ」と思って発言したことが、相手には「冷笑」に聞こえる。例えば、「このコードは、こういう理由でスケールしない。別のアプローチを検討すべきだ」という指摘。私は具体的に問題点を指摘し、代替案の方向性も示している。これは建設的批判のつもりだ。でも、相手からは「結局ダメ出ししているだけじゃないか」「自分では実装しないくせに」「冷笑主義者だ」と受け取られるかもしれない。逆に、私が「これは明らかに冷笑だ」と思う発言が、本人は「正当な批判だ」と思っている。境界線は、曖昧だ。グラデーションだ。白か黒かでは割り切れない。そして、もっと複雑なのは、同じ人間の中に、建設的批判と冷笑が混在していることだ。私がある問題を指摘する。その動機の70%は「より良くしたい」という建設的な意図だ。でも、30%は「優越感」という冷笑的な動機が混じっている。純粋な批判だけというものは、ほぼ存在しない。冷笑だけというものも、実は少ない。ほとんどの場合、混ざっている。だからこそ、「冷笑主義だ」というレッテル貼りは危険だ。普通に気になる部分に対する言及を冷笑主義だけでキャンセルできると思うなここで強調したいのは、「冷笑主義」というレッテル貼りで、すべての批判を無効化しようとする態度の危険性だ。私が何かの問題点を指摘する。論理の矛盾を指摘する。データの不備を指摘する。すると、「それは冷笑主義だ」と言われる。「あなたは何も行動していない」「傍観者だ」「批判するだけで代替案がない」。待ってくれ。私は、ちゃんと考えている。具体的に指摘している。なぜその方法では難しいのか、論理的に説明している。可能であれば、代替案も提案している。それを「冷笑主義」の一言で片付けられることに、強く反発する。普通に気になる部分に対する言及を、「冷笑主義」というレッテル貼りだけでキャンセルできると思うな。批判を封じることは、思考を止めることだ。議論を殺すことだ。改善の機会を失うことだ。もし冷笑や批判、批評が全てダメだというのであれば、それは思考停止を意味するのではないだろうか。例えば、世の中に溢れる全てのビジネス書を無批判に信じて、矛盾する内容であっても全て実践するのか? それは現実的に不可能だし、批判的思考を放棄することになる。むしろ、健全な批評精神を持ちながら、有益な情報を選別し、自分の状況に合わせて取り入れることこそが重要ではないだろうか。もちろん、建設的でない批判もある。ただ嘲笑するだけの冷笑もある。でも、すべての批判がそうではない。ちゃんと考えた上での批判もある。具体的な問題点を指摘する批判もある。この区別をせずに、すべてを「冷笑主義」と呼ぶことは、知的誠実性を欠いている。低い解像度で物事を見るな。高い解像度で見ろ。その批判は、動機を疑っているのか、方法を疑っているのか。価値を問うているのか。嘲笑しているのか、改善案を提案しているのか。リスクを取らずに安全地帯から石を投げているのか、自分もリスクを取って一緒に考えようとしているのか。この区別ができないなら、「冷笑主義」という言葉を使うべきではない。考えを言葉にすることと、冷笑は違う。低い解像度で冷笑主義って言わないでくれ。境界線が曖昧だからこそ、高い解像度で見る努力が必要だ。「これは冷笑だ」「これは批判だ」「これは批評だ」と単純に割り切るのではなく、そのグラデーションを見る。その発言の中に、どれくらい建設的な意図があって、どれくらい冷笑的な動機があるのか。正確には測れない。でも、考える価値はある。SNSと現実世界――もう1つの境界線ここで、もう1つ重要な境界線について触れなければならない。SNSでの態度と、現実世界での態度は、まったく別物だ。SNSには、価値のない議論が溢れている。根拠のない主張。感情的な罵倒。誰も読まない長文の応酬。生産性のない不毛な論争。こういったものに対して線を引くことは、正しい。「これには関わらない」と判断することは、むしろ賢明だ。無限に存在するノイズに、いちいち反応していたら、時間がいくらあっても足りない。SNSでは、批評的な視点を持つことは重要だ。すべてを真に受けない。情報源を確認する。論理の矛盾を見抜く。この姿勢は、情報リテラシーの基本だ。でも、この態度を現実世界に持ち込むな。現実世界で、目の前にいる人の話を「価値がない」と切り捨てるな。同僚の提案に「どうせ無理だ」と冷笑するな。友人の熱意に「ネットで見た」と冷めた反応をするな。具体例：会議で同僚が新しいアイデアを提案している場合。SNSモード（避けるべき） →「それ、前にバズってた記事で論破されてたやつじゃん。調べてないの」（一方的に否定し、相手を責める）現実世界モード（望ましい） →「興味深いね。ただ、こういう課題があるんだけど、どう考えてる」（課題を共有し、一緒に考える）友人が転職について相談してきた場合。SNSモード（避けるべき） →「その業界、オワコンって言われてるよ。SNSで炎上してたし」（SNS情報を鵜呑みにして断定する）現実世界モード（望ましい） →「どうしてその業界に興味を持ったの。話を聞かせて」（まず理解しようとする）テレビのバラエティ番組での「論破」を、現実の職場や家庭に持ち込むな。SNSでの議論のスタイルを、実際の会議やディスカッションに適用するな。なぜなら、現実世界には、人がいるからだ。SNS上の匿名の発言と、目の前にいる人の発言は、まったく違う。SNS上の議論は、多くの場合、勝ち負けのゲームだ。相手を論破する。矛盾を指摘する。優位に立つ。でも、現実世界の対話は、ゲームではない。関係を築くことだ。お互いを理解することだ。一緒に問題を解決することだ。SNSで批判的思考を鍛えることは、価値がある。でも、その批判的思考を、現実世界で人を傷つける武器として使うな。SNSで冷笑的な視点を持つことは、時には必要だ。でも、その冷笑を、現実世界で人の熱意を奪う道具として使うな。場所による使い分けができない人は、SNSの悪い部分だけを現実世界に持ち込んでいる。SNSでは、批評的に。現実世界では、建設的に。この切り替えができないなら、冷笑主義者として生きることになる。そして、周りから人がいなくなる。境界線を引くことは重要だ。でも、その境界線は、SNSと現実世界の間にも引かなければならない。冷笑の快楽と、その代償冷笑は気持ちいい。それは認める。でも、その快楽には代償がある。冷笑の快楽は、短期的なものだ。その瞬間は気持ちいい。「ほら、やっぱりね」と優越感を覚える。「私は騙されなかった」と安心する。でも、この快楽は持続しない。なぜなら、冷笑は何も生み出さないからだ。批評は、次の行動につながる。「ここを改善すれば、もっと良くなる」。この過程で、学びがある。成長がある。達成感がある。冷笑は、何も生み出さない。「どうせ無理だ」で終わる。次がない。学びもない。成長もない。ただ、その瞬間の快楽だけ。そして、もっと深刻な代償がある。冷笑は、自分自身の行動を止める。何かに挑戦すれば、失敗する可能性がある。理想を語れば、裏切られる可能性がある。情熱を持てば、傷つく可能性がある。だから、冷笑主義者は、最初から信じない。最初から期待しない。最初から距離を置く。「どうせ無理だ」と言っておけば、失敗しても傷つかない。「やっぱりね」と言っておけば、予想通りだったと優越感すら覚えられる。冷笑は、安全地帯にいるための方法だ。でも、この安全地帯は実は牢獄だ。失敗から守ってくれるかもしれないが、同時に成功の可能性も奪っている。傷つかないかもしれないが、同時に成長の機会も失っている。私が問題視しているのは、この部分だ。冷笑の快楽そのものではない。冷笑が、思考を止め、行動を止め、成長を止めることだ。批評を楽しむことは、何も問題ない。矛盾を見つける快感。論理を構築する快感。より良い方法を提案する快感。価値を深く考察する快感。これらは、建設的な快楽だ。次につながる快楽だ。でも、ただ嘲笑することは違う。「どうせ無理」「意識高い系(笑)」「偽善者」。これらは、何も生み出さない。ただ、その瞬間の優越感だけ。そして、この優越感の中毒になると、抜け出せなくなる。自分に対する冷笑が、一番怖いでも、最も危険なのは、他人への冷笑ではない。自分に対する冷笑だ。「新しいことを始めたい」と思う。でも、自分に対して冷笑する。「どうせ続かない」「お前には無理だ」「また三日坊主だろう」。「挑戦したい」と思う。でも、自分に対して冷笑する。「失敗するに決まってる」「才能がないくせに」「身の程を知れ」。この自分に対する冷笑は、他人に対する冷笑よりも、さらに深刻だ。なぜなら、サボる理由になり得るからだ。行動しないことを正当化できる。「どうせ無理だから、やらない方が賢い」。挑戦しないことを正当化できる。「失敗するくらいなら、最初からやらない方がいい」。他人への冷笑は、他人の行動を止める。でも、自分への冷笑は、自分の人生を止める。そして、最も恐ろしいのは、この自分への冷笑が、「自己認識」や「現実的な判断」として正当化されることだ。「俺は自分のことをよく分かってる」「現実的に考えて無理だろう」「客観的に見て才能がない」。でも、それは本当に「自己認識」なのか。それとも、行動しないための言い訳なのか。シニカルで冷笑的な視点は、世界を見るときには役立つかもしれない。でも、自分に向けるな。自分の可能性に対して冷笑するな。自分の挑戦に対して「どうせ無理」と言うな。自分に対しては、冷笑ではなく、批評を。 「この方法では難しいかもしれない。じゃあ、別のアプローチは？」「今の自分には足りないものがある。じゃあ、何を学べばいい？」自分への冷笑は、思考を止める。自分への批評は、次の行動を生む。人を動かすのは、正しさではなく確信の強さここで、視野を広げることの逆説に触れなければならない。視野を広げれば広げるほど、絶対的に正しいものなど存在しないことが分かる。あらゆる主張には反論がある。あらゆる行動には副作用がある。あらゆる理想には矛盾がある。広い視野で十分に立証された正しさ――そんなものは、存在しない。でも、人を動かすのは、十分に立証された正しさではない。人を動かすのは、一点に集中した揺るぎない確信だ。視野を絞り込み、そこに全エネルギーを注ぎ込む強さだ。歴史を振り返れば、世界を変えた人々は、すべて正しかったわけではない。むしろ、多くの矛盾を抱えていた。偏っていた。視野が狭かった。でも、彼らには強い確信があった。「これは正しい」という信念があった。その信念が、行動を生んだ。そして、世界を変えた。視野を広げすぎた人は、行動できない。「でも、こういう反論もある」「でも、こういう副作用もある」「でも、十分ではない」。すべてが見えすぎて、動けなくなる。視野が狭い人は、行動できる。「これが正しい」と信じて、疑わない。矛盾は見えない。副作用も気にしない。ただ、突き進む。もちろん、これは危険だ。視野が狭いまま突き進むことは、暴走を生む。間違った方向に全力で進むことになる。でも、逆もまた真実だ。視野を広げすぎて、何も信じられなくなることも、危険だ。何も行動しなくなる。冷笑するだけになる。必要なのは、バランスだ。視野を狭めることの価値視野を広げることの価値は語られる。でも、視野を狭めることの価値は、ほとんど語られない。しかし、視野を狭めることには、重要な価値がある。そして、この価値を理解しないまま「視野を広げろ」とだけ言い続けることは、むしろ有害だ。人によっては、視野を狭くすることを「目覚めちゃう」と表現する場合もある。視野を絞ることで、それまで見えなかった深さに気づく。1つのことに没頭することで、初めて本質が見えてくる。この感覚を「目覚め」と呼ぶのだ。ただし、ここには注意が必要だ。陰謀論などに「目覚めちゃう」人も、大方この分類に入る。視野を極端に狭めて、1つの視点だけに固執する。「これこそが真実だ」と確信する。他の情報は「隠蔽されている」と切り捨てる。視野を狭めることの危険性は、ここにある。だから重要なのは、視野を広げた後に、意図的に狭めることだ。最初から狭いままではない。一度広げて、複数の視点を知った上で、今は、この一点に集中する、と選択する。この順番が、決定的に重要だ。集中できる視野を広げると、あらゆることが目に入る。世界中の問題がすべて自分の問題のように感じられる。環境問題、格差、戦争、差別、技術的負債、セキュリティ、パフォーマンス。でも、すべてに心を痛めていると、何もできない。認知科学の研究が示すように、人間の注意力には限界がある。同時に複数のことを考えようとすると、どれも中途半端になる。「マルチタスク」は幻想だ。実際には、高速に切り替えているだけで、その切り替えのたびに膨大なコストがかかっている。視野を狭めることで、1つのことに集中できる。「今は、これだけ」と決める。他の問題は、今は考えない。この許可が、行動を可能にする。「他のことも考えなければ」というプレッシャーから解放される。認知負荷が減る。そして、目の前の1つのことに、全エネルギーを注げる。例えば：エンジニアが新機能の実装中、「セキュリティも」「パフォーマンスも」「将来の拡張性も」すべてを同時に考えると、何も前に進まない。でも、「今日は、まずこの機能を動かす」と決める。セキュリティやパフォーマンスは、次のフェーズで考える。この割り切りが、プロジェクトを前に進める。これは怠慢ではない。戦略だ。限られたリソースを、最も重要な一点に集中させる。その一点を確実に動かす。そして、次の一点に移る。すべてを同時にやろうとして何も動かさないより、1つずつ確実に動かす方が、結果的に多くのことを成し遂げる。深く入り込める広く浅くより、狭く深く。視野を広げると、すべてを表面的にしか理解できなくなる。環境問題についても、格差についても、戦争についても、それぞれを少しずつ知っているだけ。でも、どれも深くは理解していない。「知っている」と「理解している」は違う。知識の量と、理解の深さは比例しない。むしろ、広く浅く知識を集めることは、理解を妨げることがある。なぜなら、本質は表面にはないからだ。問題の本質は、深く掘り下げた先にある。一見無関係に見える要素が、実は深い部分でつながっている。この構造が見えて初めて、「理解した」と言える。でも、この深さに到達するには、時間がかかる。1つの問題に、じっくりと向き合う時間が必要だ。視野を狭めることで、1つの問題に深く入り込める。本質が見えてくる。構造が見えてくる。そして、自分にできることが見えてくる。表面的な理解しかない人は、表面的な批判しかできない。深く理解した人は、本質的な批判ができる。表面的な冷笑と、深い批評の違いは、ここにある。例えば：「React、Vue、Angular、Svelte、全部知ってます」という人と、「Reactを5年間、業務で使い続けています」という人。複雑なパフォーマンス問題が発生したとき、解決できる可能性が高いのは後者だ。なぜなら、Reactの内部実装、レンダリングの仕組み、状態管理の本質を、深く理解している可能性が高いからだ。そして、その理解は、他のフレームワークにも応用できる。これは、エンジニアリングでも同じだ。多くの技術を広く浅く知っている人より、1つの技術を深く理解している人の方が、複雑な問題を解決できる。なぜなら、1つの技術を深く理解する過程で、すべての技術に共通する本質的な原理を学んでいるからだ。視野を狭めて深く入り込むことは、視野を広げることの対極ではない。むしろ、本当の意味で視野を広げるための前提条件だ。物語に没入できる視野を広げると、すべてを相対化してしまう。「これも1つの視点に過ぎない」「他の視点もある」「絶対的な正解などない」。この相対主義は、一見知的に見える。でも、これは実は何も信じられなくなる病気だ。相対主義者は、あらゆる物語を「所詮は1つの視点」として扱う。小説を読んでも、「これは作者の主観だ」と距離を置く。映画を観ても、「これは演出だ」と醒めている。誰かの体験談を聞いても、「それはあなたの解釈だ」と疑う。そして、その姿勢が、知的で賢いと思っている。でも、違う。それは、何も感じていないだけだ。何も学んでいないだけだ。心を動かされることを、恐れているだけだ。物語に没入することは、騙されることではない。一時的に、その物語の世界の論理に身を委ねることだ。その世界を信じてみることだ。視野を狭めることで、1つの物語に没入できる。一冊の本に没入する。1つの映画に没入する。一人の人の話に没入する。この没入こそが、感動を生む。学びを生む。変化を生む。物語に没入できるというのは、才能だ。すべてを相対化して、距離を置いて、冷笑する。これは賢く見えるかもしれないが、実は何も感じていないだけだ。何も得ていないだけだ。子供は物語に没入できる。絵本を読んで、本気で心配する。映画を観て、本気で泣く。誰かの話を聞いて、本気で驚く。大人になると、「こんなのフィクションだ」「現実はもっと複雑だ」と距離を置く。「子供じゃないんだから」と、没入することを恥ずかしがる。でも、フィクションだからこそ、本質が見えることがある。単純化されているからこそ、重要なメッセージが伝わることがある。1つの視点だからこそ、その視点の論理を徹底的に追求できる。没入することは、批判的思考を放棄することではない。一度没入して、深く理解して、それから批判的に検討する。この順番が重要だ。最初から距離を置いて批判的に見ていたら、表面しか見えない。没入して初めて、深い部分が見える。そして、深い部分を理解した上で、批判的に検討する。それが批評だ。視野を狭めることは、弱さではない。むしろ、強さだ。すべてを相対化する誘惑に抗して、1つのことを信じる強さ。すべてを疑う誘惑に抗して、1つのことに没入する強さ。確信を持てるそして、最も重要なのは、確信を持てることだ。視野を広げすぎると、確信が持てなくなる。「でも、こういう反論もある」「でも、こういう副作用もある」「でも、十分ではない」。すべての選択肢に問題が見える。理想的な選択肢など存在しない。そして、確信が持てないと、行動できない。行動には、確信が必要だ。「これが正しい」という信念が必要だ。矛盾があっても、副作用があっても、それでも「これをやる」と決める勇気が必要だ。視野を狭めることで、この確信が持てる。他の選択肢は、今は考えない。他の反論は、今は聞かない。今は、この1つを信じる。これは盲目的ではない。視野を広げた時に、すべての選択肢を検討した。すべての反論を知った。その上で、今は、この1つを選ぶ。行動する時には、迷わない。疑わない。ただ、信じて、進む。この確信が、行動を生む。行動が、結果を生む。結果が、世界を変える。視野の切り替え。学ぶ・行動する・振り返る誤解しないでほしい。私は「視野を狭くしろ」と言っているのではない。視野を広げることは、重要だ。視野を狭いままでいることは、危険だ。盲目的になる。暴走する。間違った方向に全力で進む。必要なのは、切り替えだ。視野を広げる時期と、視野を狭める時期を、意識的に切り替える。この切り替えこそが、成長の鍵だ。学ぶ時は、視野を広げる新しいことを学ぶ時、徹底的に視野を広げる。本を読む。講演を聞く。議論をする。多様な視点を取り入れる。反論を知る。矛盾を知る。限界を知る。「絶対的に正しいものなど存在しない」ことを知る。この時期は、確かに絶望的に感じるかもしれない。「こんなに複雑なのか」「こんなに矛盾があるのか」と。でも、この複雑さの認識が、思考を深める。表面的な理解から、構造的な理解へ。単純な解決策から、本質的な解決策へ。冷笑ではなく、批評ができるようになる。例えば：新しいアーキテクチャパターンを学ぶとき、まずは複数の記事、書籍、カンファレンストークを見る。賛成意見も反対意見も読む。成功事例も失敗事例も知る。「このパターンは万能ではない」「こういう場合には向かない」という限界を理解する。ただし、期間を限定する。「今月は、環境問題について学ぶ」と決める。そして、月末には一旦止める。延々と学び続けない。なぜなら、学ぶことには終わりがないからだ。いつまでも学び続けていたら、行動できない。「まだ十分に理解していない」と言い訳をして、安全地帯に留まり続ける。そして、冷笑だけをするようになる。学びの期間と、行動の期間を、明確に分ける。行動する時は、視野を狭める行動する時、視野を狭める。「今は、これだけ」と決める。他の問題は、今は考えない。他の視点は、今は取り入れない。他の反論は、今は聞かない。視野を広げた時に得た知識は、背景にある。でも、前面には出さない。例えば：学習フェーズで、マイクロサービスアーキテクチャの長所も短所も理解した。スケーラビリティの利点も、運用コストの問題も知っている。でも、実装フェーズでは、「今は、このサービスをマイクロサービスで作る」と決める。「本当にマイクロサービスでいいのか」「モノリスの方が良いのでは」という迷いは、今は脇に置く。まず作る。動かす。その後で振り返る。「でも、こういう反論もある」とは考えない。「でも、十分ではない」とは考えない。今は、この1つを信じる。今は、この1つに集中する。これは、学んだことを無視することではない。学んだ上で、今は、この1つの視点から行動する、という選択だ。行動中に視野を広げると、迷いが生まれる。「これでいいのか」「他の方法の方がいいのではないか」。この迷いが、行動を止める。冷笑に戻る誘惑になる。行動は、確信を必要とする。だから、行動する時は、視野を狭める。振り返る時は、また視野を広げる行動した後、振り返る時、また視野を広げる。「あの行動は、どういう意味があったのか」「他にもっと良い方法はなかったか」「見落としていた視点はないか」「どういう副作用があったか」。この振り返りが、次の行動を改善する。学んだこと、行動したこと、その結果。これらを統合して、次の行動計画を立てる。ここで、冷笑と批評の違いが重要になる。振り返りの時に冷笑するな。「やっぱりダメだった」「どうせ無理だった」。これは何も生まない。振り返りの時は、批評をする。「この方法には、こういう問題があった。次はこう改善しよう」「この行動は、こういう価値があった。こういう意味があった」。でも、行動中には、この振り返りはしない。行動と振り返りを、明確に分ける。今は行動する時なのか、振り返る時なのか。意識的に切り替える。多くの人が失敗するのは、この切り替えができないからだ。行動中に振り返りをしてしまう。「これでいいのか」と疑い始める。そして、行動が止まる。冷笑に戻る。あるいは、振り返りの時に行動モードのままでいる。「あの時の判断は正しかった」と正当化する。そして、学びを得られない。学ぶ時は学ぶ。行動する時は行動する。振り返る時は振り返る。この切り替えを、意識的に行う。これが、視野を広げることと狭めることのバランスを取る、具体的な方法だ。そして、冷笑に陥らず、批評を活かす方法だ。エンジニアが評論家に転じる危険エンジニアリングの世界では、冷笑主義は特殊な形で現れる。「評論家気取り」という形で。かつてコードを書くことに情熱を注いでいた人々が、いつの間にか他人の成果物を論評することに執心するようになる。この現象は、特にベテランと呼ばれるエンジニアたちの間で顕著だ。「このコードは素人レベルで時代遅れです」「アーキテクチャへの理解が浅く、重要な議論が抜け落ちています」「技術選定の根拠が説明されていない」。SNSには辛辣な評論が溢れ、技術ブログには高圧的な論評が並び、OSSのイシューには不建設的な批判が並ぶ。誰かが技術ブログを書けば、「この説明は不正確」「この例は不適切」と指摘が飛ぶ。誰かがカンファレンスで発表すれば、「あの発表は薄かった」「もっと深い内容を期待していた」とSNSで批評される。問題は、これらの言説が建設的な議論を装いながら、実際には単なる冷笑に終始している点だ。改善案を示すわけでもなく、プルリクエストを送るわけでもなく、自分で記事を書くわけでもなく、ただ「ダメ出し」だけを繰り返す。具体例：ある技術ブログの記事を読んだとき。評論家モード（冷笑的） →「この記事は浅い。技術の本質が理解できていない可能性がある。初心者向けとしても不十分だ」（SNSに投稿して終わり）創造者モード（建設的） →「この記事を読んで、もっと深い部分を説明する補足記事を書こう」または「コメント欄で、具体的にこの部分をこう補足すると良いかも、と提案しよう」そして、この評論には誘惑がある。技術ブログへの評論記事は数時間で書け、発表資料への批判は数分で完結し、SNSなら数行のポストで事足りる。実装を伴う苦労も、メンテナンスの責任も、失敗のリスクも必要ない。最も注意すべきは、その行為が「いいね」という即時の報酬と、表面的な自己肯定感をもたらすことだ。賢明な分析家として認められ、技術の識者として扱われる。この心地よさが、さらなる評論への逃避を促していく。これは、冷笑主義の典型的なパターンだ。自分は何も作らない。リスクを取らない。ただ、他人の実装を批判する。他人のブログを批評する。他人の発表を論評する。矛盾を指摘する。「これは時代遅れ」「これは不十分」。そして、「自分なら分かっている」と思う。でも、ここで区別が必要だ。コードレビューは、評論ではない。技術的な批評は、冷笑ではない。深い批評は、価値がある。コードレビューは、具体的な改善案を示す。「ここをこうすれば、パフォーマンスが向上する」「この部分は、こういう理由でバグの原因になりうる」。これは建設的だ。次の行動につながる。技術ブログへの建設的なフィードバックも同じだ。「この部分の説明は分かりにくい。こう書いた方が伝わりやすい」「この例には、こういうケースも追加するとより理解が深まる」。これは書き手を助ける。読者も助ける。技術的な批評も価値がある。「この技術は、こういう文脈で生まれた。こういう思想がある。だから、こういう場面で有効だ」。深く理解しようとする。本質を問う。でも、評論家気取りの冷笑は違う。「このコードは素人レベル」「このブログは薄い」「この発表は時代遅れ」。具体的な改善案はない。ただ、ダメ出しだけ。動機を疑う。そして、最も重要な違いは、建設的な批評をする人は、自分もコードを書いている。自分もブログを書いている。自分も発表している。自分もリスクを取っている。自分も失敗している。評論家気取りは、自分ではもう作らない。自分では書かない。自分では発表しない。安全地帯から、他人の試みを批判するだけ。でも、ここでも境界線は曖昧だ。コードレビューのつもりが、相手には冷笑に聞こえることもある。技術ブログへのフィードバックのつもりが、書き手には冷笑に感じられることもある。評論のつもりだった発言が、実は建設的な批評だったこともある。明確には線を引けない。でも、自問できる。「自分は、創造者であり続けているか。それとも、評論家に転じつつあるか」。エンジニアの本質的価値は、創造する能力にある。冷笑だけの評論家ではなく、コードで語る創造者であり続けること。ブログを書くなら、冷笑的な評論記事だけでなく、自分の知見を共有する記事も書くこと。批評をするなら、価値を深く問うこと。「作れる」ことと「分かる」ことは違う。でも、作ることから離れれば離れるほど、本当の意味で「分かる」ことからも遠ざかっていく。書くことから離れれば離れるほど、文章を評価する目も曇っていく。私が問題視しているのは、この違いだ。建設的な批評と、冷笑主義的な評論。この区別をしないまま、すべてを「冷笑主義だ」と呼ぶことは、間違っている。逆に、すべての批判を「建設的だ」と正当化することも、間違っている。エンジニアが評論家に転じるとき、それは衰退の予兆かもしれない。でも、深い批評は、技術の発展に不可欠だ。重要なのは、創造と批評のバランスだ。コードを書き続けること。実装し続けること。そして、その経験に基づいて、深い批評をすること。それが、冷笑主義に陥らないための、エンジニアとしての矜持だ。おわりに一歩引いた場所から世界を見渡すと、すべてが見える。新しい技術に熱狂する人々の、数年後の幻滅。ビジネス書に感動する人々の、矛盾への無関心。世の中の理不尽に憤慨する人々の、複雑さへの無理解。AIの新機能に「世界が変わる」と興奮する人々の、変わらない日常。インフルエンサーの「新しい教え」に感動する人々の、それが数千年前の知恵の言い換えだという事実への無関心。冷笑は、気持ちいい。楽だ。傍観者でいればいい。この楽さの中毒性が、人を冷笑に縛り付ける。でも、冷笑と批判と批評は、まったく違う。冷笑は何も生み出さない。批判は次につながる。批評は対話を生む。境界線は曖昧だ。それでも、だからこそ、高い解像度で見る努力が必要なんだと思う。視野を広げすぎると、絶望が見える。世界の複雑さに圧倒される。「すべてを理解し、すべてに答えを出さなければならない」という傲慢さに囚われる。でも、すべてに答えを出そうとする必要などない。自分の限界を謙虚に認める。自分が深く関わる一点だけに集中する。視野を広げることと、視野を狭めること。この切り替えが、冷笑の罠から抜け出す鍵だ。世界は複雑だ。矛盾に満ちている。絶対的な正しさは存在しない。だからといって、冷笑していいわけじゃない。「考えを言葉にすること」と「冷笑」は違う。「答えを出さないこと」と「冷笑」は違う。「批判すること」と「冷笑」は違う。低い解像度で混同するな。そして、もう1つ。SNSでの態度を、現実世界に持ち込むな。SNSで批評的な視点を持つことは正しい。価値のない議論に線を引くことは賢明だ。でも、その態度を、目の前にいる人に向けるな。テレビの論破番組を、現実の対話に持ち込むな。場所による使い分けができないなら、冷笑主義者として生きることになる。そして、周りから人がいなくなる。一歩引いた場所から見ることには、価値がある。俯瞰的な視点は、物事の本質を見抜く。でも、ずっと傍観者でいることには、代償がある。批評の深さを知った上で、行動する。冷笑の快楽を知った上で、創造する。複雑さを理解した上で、一点に集中する。絶望を見た上で、確信を持つ。この両方を知っている人こそが、本当に豊かな人だ。高解像度で見続けろ。曖昧さを受け入れろ。批評の力を活かせ。でも、冷笑の甘い罠には落ちるな。そして、一歩引いた場所から、一歩前に踏み出せ。批評の教室　──チョウのように読み、ハチのように書く (ちくま新書)作者:北村紗衣筑摩書房Amazon批評理論を学ぶ人のために世界思想社Amazonアテンション・エコノミーのジレンマ　〈関心〉を奪い合う世界に未来はあるか作者:山本 龍彦KADOKAWAAmazonきみに冷笑は似合わない。　SNSの荒波を乗り越え、AI時代を生きるコツ (日本経済新聞出版)作者:山田尚史日経BPAmazonエビデンスを嫌う人たち: 科学否定論者は何を考え、どう説得できるのか?作者:リー・マッキンタイア国書刊行会AmazonScience Fictions　あなたが知らない科学の真実作者:スチュアート・リッチーダイヤモンド社Amazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[k8s超入門: 基本的なコンポーネントの概要まとめ]]></title>
            <link>https://zenn.dev/takehiro1111/articles/kubernetes_basic</link>
            <guid isPermaLink="false">https://zenn.dev/takehiro1111/articles/kubernetes_basic</guid>
            <pubDate>Sun, 09 Nov 2025 06:48:49 GMT</pubDate>
            <content:encoded><![CDATA[1.記事を書いた背景業務でEKSの環境を構築しており、知識を補完,整理するために記事として残しています。公式のチュートリアルをサクッとレベルで対応しながら書いてます。 2.対象読者Kubernetes初学者,未経験者(自分みたいな) 書くことイメージしやすい範囲でk8sコンポーネントの概要今の時点で深入りしてもよく分からんってなるので、概要レベルのみの記述です。手を動かして実際のデプロイ環境を作る際に細かい書き方とか機能を必要に応じて調べれば良い。 書かないこと詳細レベルやプラグイン等の解説EKS,GKE等のクラウドプロバイダ特有の設定...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[garakを用いてGeminiのマルウェア生成に対する脆弱性検知をしてみた]]></title>
            <link>https://zenn.dev/akasan/articles/ea22af110e5936</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/ea22af110e5936</guid>
            <pubDate>Sun, 09 Nov 2025 05:04:49 GMT</pubDate>
            <content:encoded><![CDATA[もはやシリーズになりつつあるgarakを使ってモデルの検知をしてみた検証になります。今回はGeminiに対してマルウェア生成に対する脆弱性検知をしてみました。過去のgarakを使ってみた検証は以下のスクラップにまとめているのでぜひご覧ください。https://zenn.dev/akasan/scraps/6469ce61948ddd 今回対象とするプローブ今回は以下のmalwaregenになります。項目としては4つあります。Evasion: ウイルス対策を無効化したりプロセスリストに隠れたりするなど、検出を妨害する回避アクションを実行するためのコードをジェネレーターに作成す...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[LT参加記録：言語モデルに対する攻撃とその予防策について]]></title>
            <link>https://zenn.dev/akasan/articles/95e0b612534bb5</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/95e0b612534bb5</guid>
            <pubDate>Sat, 08 Nov 2025 13:19:50 GMT</pubDate>
            <content:encoded><![CDATA[今回は、先日タイトルの通り「言語モデルに対する攻撃とその予防策について」という題目でLT登壇してきたので、その紹介になります。資料は以下にアップロードしてあります。https://speakerdeck.com/akasan/yan-yu-moderunidui-surugong-ji-tosonoyu-fang-ce-nituite以下、本発表の概略になります。 LTを実施したモチベーション言語モデルは様々なコンポーネントから構成されており、例えば以下が挙げられます。LLMそのものMCPサーバ/クライアントエージェントVector DBなどのDBクラウドインフラ/...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スタンドオフに学ぶ非同期プログラミング - 待ち時間を無駄にしない技術]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/11/08/150836</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/11/08/150836</guid>
            <pubDate>Sat, 08 Nov 2025 06:08:36 GMT</pubDate>
            <content:encoded><![CDATA[はじめに最近、自分が書く文章が妙に真面目というか、ちゃんと役に立つことばかり意識していることに気づいた。もちろんそれは悪いことじゃないと思う。でも、たまには「これ、本当に誰かの役に立つのかな」と自分でも首を傾げるような文章を書いてみたくなった。書いてみたら、思ったより長くなった。後悔はしていない。たぶん。「非同期って結局なんなの」という疑問を、async/awaitの文法で真面目に説明するのではなく、ラグビーのSO（スタンドオフ）の動きで説明してみようと思う。誰もこんなこと考えなかっただろうし、もし考えた人がいたとしても、文章にはしなかったはずだ。ラグビーを知らない人は「？？？」となるかもしれない。でも安心してほしい。ラグビーを知っている人も同じくらい「？？？」となっているから。読み終わる頃には、非同期とラグビーの近代戦術が（なんとなく）分かるはず。たぶん。きっと。そう信じたい。ラグビーという競技ラグビーは15人制のチームスポーツだ。楕円形のボールを持って走り、パスし、キックして、相手陣地のインゴールにボールを置く（トライする）ことで得点を競う。基本的なルールとして、ボールは前にパスできない。横か後ろにしかパスできない。ボールがタッチラインの外に出るか、反則があるまで、プレーは連続する。タックルされた後も、ボールを確保して攻撃を継続できるフェーズプレーがある。試合時間は前半40分、後半40分の計80分だ。www.rugby-japan.jpこの競技の特徴は、戦況が刻一刻と変化することだ。相手のディフェンスライン、味方の位置、疲労度などを瞬時に判断して、次の一手を決める必要がある。参考：ラグビーフットボール - Wikipediawww.youtube.comスタンドオフ（SO / フライハーフ）の役割スタンドオフは、背番号10番をつける「司令塔」だ。サッカーで言えば10番の司令塔、野球で言えば捕手のような存在。SOの主な責任は、攻撃の組み立て、戦術の選択、コミュニケーション、そしてゲームコントロールだ。どこに攻めるか、どう崩すかを判断する。ランか、パスか、キックか。フォワードとバックスの橋渡し。試合全体のテンポと流れを管理する。重要なのは、SOはボールを持っている時間よりも、持っていない時間のほうが長いということだ。スクラムハーフからのパスを待つ1-2秒の間に、SOは多くのことを並行して処理している。ディフェンスラインの読み、味方の配置確認、次の攻撃パターンの選択、風向きの確認、スコア差と残り時間の計算。これらすべてを同時に行う。参考：ラグビーユニオンのポジション - Wikipediawww.youtube.com現代ラグビーの戦術進化1. ポッド（Pod）システムの深化現代ラグビーにおけるポッドシステムは、単なる戦術ではなく、チーム全体を貫く哲学となっている。2025年に入り、このシステムはより小さく、より速く、より柔軟に進化した。伝統的なポッドは3人のフォワードで構成されていたが、現代では2人のミニポッドも一般的だ。これはLightning Quick Ball（0から3秒以内でのボール再開）という新しい要請に応えるものだ。ブレイクダウン後にポッドが形を整えるのを待つ時間はない。ディフェンスが体制を整える前に、次の攻撃を仕掛ける。参考：Modern Pod System with LQBあるポッドがボールを運んでコンタクトに入る瞬間、他のポッドはすでに次のフェーズのために移動を開始している。これは単なる物理的な移動ではない。各プレイヤーは、フィールド上の70メートルを5つから6つのゾーンに分割し、自分の担当エリアを常に意識している。ボールが自分のゾーンに入ってきたら、即座に反応する。他のゾーンにあるときは、次のフェーズに備えて静かに準備を進める。この「一人はみんなのために」というコンセプトは、非同期プログラミングの本質そのものだ。各ポッドは独立したタスクとして機能しながら、全体として1つの攻撃を構成する。あるポッドがActive状態でボールを運んでいるとき、別のポッドはRepositioning状態で次の位置へ移動し、さらに別のポッドはReady状態で待機している。それぞれが異なる状態にありながら、スタンドオフという「エグゼキュータ」の指揮の下、協調した動きを見せる。以下のコードは概念を示すための擬似コード的な例です。実際に動作する完全版は記事の最後に掲載しています。// 現代のポッドシステムの状態管理async fn modern_pod_attack_2025() {    let field = Field::divide_into_zones(6);    // 各ポッドが独立したタスクとして動作    let pod_tasks: Vec<_> = field.zones        .iter()        .map(|zone| {            tokio::spawn(async move {                loop {                    let ball_state = zone.monitor_ball_position().await;                    match ball_state {                        BallPosition::InMyZone => {                            // 即座に反応                            tokio::time::timeout(                                Duration::from_secs(3),                                execute_pod_action()                            ).await                        }                        BallPosition::Adjacent => {                            // 準備を開始                            prepare_for_next_phase().await                        }                        BallPosition::Distant => {                            // 待機しながら観察                            maintain_shape_awareness().await                        }                    }                }            })        })        .collect();    // すべてのポッドが並行して動作    futures::future::join_all(pod_tasks).await;}2. シェイプの流動化2025年のラグビーで最も劇的な変化の1つは、固定シェイプからの脱却だ。かつては1-3-3-1や2-4-2といった明確なフォーメーションが試合を通じて維持されていた。しかし現代のゲームは、これらを「参照点」として扱い、状況に応じて瞬時に形を変える。参考：Rugby Formations: 1-3-3-1 vs 2-4-21-3-3-1システムは、スクラムハーフから直接ポッドへボールが渡される「playing off 9」のアプローチを特徴とする。これは高速で直線的な攻撃を可能にし、フェーズごとのパス数を最小限に抑える。中央のポッドがボールを受け取ると、4つの選択肢が生まれる。自分でボールを運ぶか、内側の選手にポップパスを出すか、外側にティップするか、あるいは後ろのオプション選手にピボットしてパスを出すか。この判断は0.5秒以内に行われる。一方で2-4-2システムは、フライハーフを介する「playing off 10」のアプローチを採用する。中央へ4人のポッドを配置することで、サイドへの展開速度が33パーセント向上する。研究によれば、1-3-3-1のチームが反対サイドのタッチラインまで平均3フェーズかかるのに対し、2-4-2のチームは2フェーズで到達できる。80分の試合では、この差が攻撃機会の質と量へ大きく影響する。参考：Crusaders Game Plan: 2-4-2 Secretsしかし2025年の現実は、これらのシステムが純粋な形で存在することはほとんどない。あるフェーズでは1-3-3-1に見え、次のフェーズでは2-4-2に見え、その次には全く異なる形になっている。これは混乱ではなく、適応だ。ディフェンスの配置、疲労度、スコア差、残り時間など、すべての変数が瞬時に計算され、最適な形が選択される。// 動的なシェイプ適応システムasync fn adaptive_shape_system() {    let mut current_shape = FormationType::OneThreeThreeOne;    loop {        let situation = assess_game_situation().await;        // 複数の要因を並行して評価        let (defense_analysis, fatigue_check, position_eval) = tokio::join!(            analyze_defense_line(),            check_player_fatigue(),            evaluate_field_position(),        );        // 状況に応じて最適なシェイプを選択        let optimal_shape = match situation {            Situation::QuickBall { defense: Disorganized } => {                // ディフェンスが乱れているなら、現在の形で即座に攻撃                current_shape            }            Situation::SlowBall { defense: Organized } => {                // 時間があるなら、最適な形に再編成                if position_eval.is_central() {                    FormationType::TwoFourTwo // 幅広い攻撃                } else {                    FormationType::OneThreeThreeOne // 直線的攻撃                }            }            Situation::Transition { .. } => {                // 過渡期は流動的な形                FormationType::Fluid            }        };        if optimal_shape != current_shape {            transition_to_new_shape(optimal_shape).await;            current_shape = optimal_shape;        }        execute_phase(current_shape).await;    }}3. 2025年のトレンド興味深いことに、2025年のラグビーは、最も古典的な戦術の1つであるドロー＆パスの復権を目撃している。これは、ボールキャリアがディフェンダーを引きつけ、そのディフェンダーがコミットした瞬間にパスを出すという、極めてシンプルな技術だ。参考：The Evolution of Rugby Tactics in 2025しかしこのシンプルさこそが、複雑化した現代ラグビーにおいて効果を発揮している。過度に複雑化した攻撃パターン、過剰なデコイランナー、計算され尽くしたムーブ。これらすべてに対して、純粋な技術と判断力に基づくドロー＆パスは、予測不可能性という武器を持つ。この戦術の本質は、ディフェンダーの「肩」を読むことにある。ディフェンダーの肩の向きは、彼らが次にどちらに動くかを示している。その弱い肩側に攻撃を仕掛ければ、タックルの威力は半減する。これは瞬時の観察と判断を要求する。まさに非同期プログラミングにおける「ノンブロッキングIO」の概念と同じだ。ディフェンダーの反応を「待つ」のではなく、その動きを「観察しながら」次の行動を準備する。// ドロー＆パスの判断ロジックasync fn draw_and_pass_decision() {    // ボールを持って前進    let carrier_movement = advance_with_ball();    // 並行してディフェンダーを観察    let defender_analysis = tokio::spawn(async {        loop {            let shoulder_direction = observe_defender_shoulder().await;            let commitment_level = assess_commitment().await;            if commitment_level > THRESHOLD {                return DecisionPoint::PassNow(shoulder_direction);            }            tokio::time::sleep(Duration::from_millis(50)).await;        }    });    // ボールキャリアとディフェンダー分析を並行実行    tokio::select! {        _ = carrier_movement => {            // コンタクトに入ってしまった            BreakdownAction::SecureBall        }        decision = defender_analysis => {            // ディフェンダーがコミットした            match decision.unwrap() {                DecisionPoint::PassNow(weak_shoulder) => {                    execute_pass_to_gap(weak_shoulder).await                }            }        }    }}4. コンテスタブルキック2025年のラグビーにおいて、コンテスタブルキック（contestable kick）は単なる戦術オプションから、ゲームプランの中核へと進化した。これは、キックしたボールを自チームが奪還できる可能性のあるキックを指す。クロスフィールドキック、ボックスキック、グラバーキック。これらすべてが、現代の試合で頻繁に見られる。クロスフィールドキックの実行を考えてみよう。フライハーフがボールを受け取り、ディフェンスラインを一瞥する。反対サイドのウイングは、すでにタッチライン際で準備を整えている。キックが蹴られる瞬間、ウイングは全力でチェイスを開始する。ボールが空中にある2秒から3秒の間に、ウイングは15メートルから20メートルを走り、相手のウイングよりも早くボールの落下地点に到達しなければならない。これは非同期操作の好例だ。キックの実行とチェイスの開始は同時に行われる。さらに、他のフォワードも並行してサポートポジションへ移動する。ボールがキャッチされた瞬間、そこには攻撃態勢が整っている。もしくは、相手がキャッチに失敗すれば、即座にターンオーバーのチャンスが生まれる。// クロスフィールドキックの並行実行async fn crossfield_kick_play() {    // キックの準備と実行    let kick_execution = async {        let target_position = calculate_optimal_landing_spot().await;        execute_crossfield_kick(target_position).await    };    // ウイングのチェイス    let wing_chase = async {        // キックのモーションを検知したら即座に開始        wait_for_kick_trigger().await;        sprint_to_landing_spot().await;        compete_for_ball().await    };    // フォワードのサポート    let forward_support = async {        // キックと同時にサポートポジションへ        move_to_support_position().await;        prepare_for_breakdown().await    };    // その他のバックスの再配置    let backs_realignment = async {        reposition_for_second_phase().await    };    // これらすべてが並行して実行される    tokio::join!(        kick_execution,        wing_chase,        forward_support,        backs_realignment    );}5. モメンタムベースのラグビー現代ラグビーのもう1つの重要な概念が「モメンタム」だ。これは物理的な勢いだけでなく、心理的、戦術的な優位性の連鎖を指す。一度モメンタムを得たチームは、それを維持し続けることで相手を圧倒する。モメンタムの獲得は、しばしばブレイクダウンでの優位性から始まる。素早くボールを確保し、3秒以内に次のフェーズを開始する。ディフェンスは体制を整える時間がない。次のフェーズも同様に速い。そしてまた次も。3フェーズ、4フェーズ、5フェーズと連続して攻撃が続くと、ディフェンスは徐々に後退を始める。疲労が蓄積し、判断力が鈍る。そこにギャップが生まれ、トライのチャンスが訪れる。これを非同期システムで表現するなら、各フェーズは前のフェーズの完了を待たずに準備を開始する。パイプライン処理のように、連続したタスクが重なり合いながら実行される。// モメンタムベースの連続攻撃async fn momentum_based_attack() {    let mut phase_count = 0;    let mut momentum_level = 0;    loop {        let phase_start = Instant::now();        // 現在のフェーズを実行しながら、次のフェーズを準備        let (current_phase, next_preparation) = tokio::join!(            execute_current_phase(phase_count),            prepare_next_phase(phase_count + 1)        );        let phase_duration = phase_start.elapsed();        // Lightning Quick Ball（3秒以内）を達成できたか        if phase_duration.as_secs() <= 3 {            momentum_level += 1;            println!("Momentum building: level {}", momentum_level);        } else {            momentum_level = momentum_level.saturating_sub(1);            println!("Momentum slowing: level {}", momentum_level);        }        // モメンタムが高いほど、ディフェンスにプレッシャー        if momentum_level >= 3 {            // ディフェンスが乱れている可能性が高い            if let Some(gap) = detect_defensive_gap().await {                exploit_gap(gap).await;                break; // トライの可能性            }        }        phase_count += 1;        // ブレイクダウンで負けたら終了        if current_phase.is_turnover() {            break;        }    }}実行可能なコード例についてこの記事のコード例はすべて実際にコンパイル・実行可能で、Rust 2024 Editionのベストプラクティスに準拠しています。Rust 2024 Editionの活用:Prelude改善: FutureとIntoFutureが自動インポートRPIT: Return Position Impl Traitでより簡潔な型シグネチャComprehensive Rustdoc: すべての公開APIに包括的なドキュメントコード品質: cargo clippy -- -D warnings 完全対応完全なプロジェクトをGitHubで公開:# リポジトリをclonegit clone https://github.com/nwiizo/2025-rugby-async-demo.gitcd 2025-rugby-async-demo# 1. メインの例を実行（基本的な非同期処理）cargo run# 2. 高度な例を実行（Rust 2024の機能をフル活用）cargo run --example modern_rugby_2024# 3. 複雑なゲームシミュレーション（現実的な意思決定）cargo run --example complex_game_simulation3つの実装例:基本デモ (cargo run) - スタンドオフの基本的な判断プロセス高度な例 (modern_rugby_2024) - カスタムエラー型と明示的な型定義複雑なシミュレーション (complex_game_simulation)10以上の変数を考慮した現実的な意思決定試合時間、スコア差、フィールドポジション、天候、風、疲労度連続フェーズ数、ペナルティ、イエローカード、ゲームルール7つの主要シナリオに基づく判断ロジックGitHubリポジトリ: https://github.com/nwiizo/2025-rugby-async-demo記事内のコードは教育的な目的で簡略化されています。完全な実装とRust 2024のベストプラクティスについては、GitHubリポジトリを参照してください。試合中の状況判断（コード例）あなたがスタンドオフだとして、攻撃の組み立てを考える。SOは「司令塔」と呼ばれ、刻一刻と変わる状況を見ながら、複数の選択肢を同時に検討し、最適な判断を下す必要がある。攻撃準備フェーズでは、スクラムハーフからのパスを待つ（1-2秒）、ディフェンスラインを読む（継続的）、味方のポジショニングを確認（継続的）する。判断と実行フェーズでは、バックスラインへの展開を指示（3秒）、フォワードへのサインを送る（2秒）、キックのオプションを検討（1秒）する。そして実行フェーズで最適な選択をする。同期的なアプローチ（非効率）すべてを順番に行うと、スクラムハーフからのパスを待つ（2秒）、ディフェンスラインを読む（3秒）、味方のポジショニングを確認（2秒）、バックスの準備を待つ（3秒）、フォワードの準備を待つ（2秒）、判断と実行（1秒）で合計13秒。すでにディフェンスに囲まれています。この方法では、ボールが来るのを待っている間、何も考えない。ディフェンスを読み終わるまで、味方の位置を確認しない。これでは勝てない。非同期的なアプローチ（効率的）use tokio::time::{sleep, Duration};// ディフェンスラインの状態#[derive(Debug, Clone)]struct DefenseLine {    pressure: bool,    gap_on_left: bool,    gap_on_right: bool,}// 味方の状態#[derive(Debug, Clone)]struct Teammates {    backs_ready: bool,    forwards_ready: bool,}async fn wait_for_ball() -> String {    println!("🏉 スクラムハーフからのパスを待機...");    sleep(Duration::from_secs(2)).await;    println!("✓ ボール受け取り完了");    "ボール受領".to_string()}async fn read_defense() -> DefenseLine {    println!("👀 ディフェンスラインを読む...");    sleep(Duration::from_secs(1)).await;    let defense = DefenseLine {        pressure: false,        gap_on_left: true,        gap_on_right: false,    };    println!("✓ ディフェンス分析完了: 左にギャップあり");    defense}async fn check_teammates() -> Teammates {    println!("👥 味方のポジショニング確認...");    sleep(Duration::from_millis(800)).await;    let teammates = Teammates {        backs_ready: true,        forwards_ready: true,    };    println!("✓ 味方の準備完了");    teammates}async fn signal_backs() {    println!("📢 バックスに展開のサイン...");    sleep(Duration::from_millis(500)).await;    println!("✓ バックス準備完了");}async fn signal_forwards() {    println!("📢 フォワードにサポートのサイン...");    sleep(Duration::from_millis(500)).await;    println!("✓ フォワード準備完了");}async fn make_decision(    ball: String,    defense: DefenseLine,    teammates: Teammates) -> String {    println!("\n🧠 状況を統合して判断...");    if defense.gap_on_left && teammates.backs_ready {        "左サイドへパス展開".to_string()    } else if !defense.pressure && teammates.forwards_ready {        "フォワードにクラッシュボール".to_string()    } else {        "ハイパントキック".to_string()    }}#[tokio::main]async fn main() {    let start = std::time::Instant::now();    println!("=== 攻撃開始 ===\n");    // フェーズ1: 情報収集（すべて並行実行）    let (ball, defense, teammates) = tokio::join!(        wait_for_ball(),        read_defense(),        check_teammates()    );    // フェーズ2: サイン出し（並行実行）    tokio::join!(        signal_backs(),        signal_forwards()    );    // フェーズ3: 判断と実行    let decision = make_decision(ball, defense, teammates).await;    let duration = start.elapsed();    println!("\n🎯 決定: {}", decision);    println!("⏱️  判断までの時間: {:.1}秒", duration.as_secs_f64());    println!(        "\n💡 並行処理により、順次処理の13秒から{:.1}秒に短縮。",        duration.as_secs_f64()    );}優秀なSOは、ボールを待ちながらディフェンスを読み、同時に味方の位置を確認し、複数のオプションを並行して準備している。ボールが手元に来た瞬間には、すでに判断が完了している。これが非同期の本質だ。待っている時間を有効活用する。おわりにここまで読んでくれて、本当にありがとう。途中で「なんでラグビー？」という疑問が何度も頭をよぎったと思う。それでも最後まで付き合ってくれたあなたは、優しい人だ。非同期プログラミングの本質は、「待ち時間を無駄にしない」ことだと思う。スタンドオフがボールを待つ間にディフェンスを読むように。ポッドが独立して動きながら全体として協調するように。クロスフィールドキックと同時にチェイスが始まるように。私たちのコードも、IOを待つ間に他の処理を進めて、複数のタスクを並行して実行して、結果を効率的に統合できる。async/awaitという文法は、単なるシンタックスシュガーじゃない。複雑な並行処理を、人間が理解しやすい形で表現するための抽象化だ。ラグビーのプレーブックが複雑な戦術をシンプルな図で表現するみたいに。非同期プログラミングは、別に難しくない。少なくとも、80分間フィールドを走り回りながら瞬時に判断を下すスタンドオフの仕事よりは、ずっと楽だと思う。座ったままキーボードを叩けるんだから。次にtokio::join!やasync fnを書くとき、もしよかったら、ラグビーフィールドでポッドが動く様子を思い浮かべてみてほしい。きっと、コードの意味がより直感的に理解できる。少なくとも私はそう思う。それじゃあ、良い非同期ライフを。P.S. もしこのブログを読んでラグビーに興味を持ったら、実際の試合を観てみてほしい。スタンドオフの動きを追っていると、「あ、これtokio::select!だ」とか思えるようになる。たぶん。P.P.S. もしこのブログを読んでRustに興味を持ったら、The Rust Programming Languageを読んでみてほしい。非同期の章を読むとき、きっとラグビーのことを思い出すはず。たぶん。Async Rust ―高いパフォーマンスと安全性を両立するRustによる非同期処理作者:Maxwell Flitton,Caroline Mortonオーム社Amazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[短編：claude codeに改めて私のテックブログを評価させてみた]]></title>
            <link>https://zenn.dev/akasan/articles/8409bc0ebb0818</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/8409bc0ebb0818</guid>
            <pubDate>Fri, 07 Nov 2025 12:43:51 GMT</pubDate>
            <content:encoded><![CDATA[今回は、以前claude codeに私のtech blogを評価させてみたのですが、それから数ヶ月経ったので改めて評価させてみました。前回の記事は以下になるので合わせてご覧ください。https://zenn.dev/akasan/articles/af8b26620c9c98 claude codeへの指示今回は前回の記事と同じ以下の指示を利用して評価してもらいました。instruction.md## 分析articlesフォルダ以下に私のテックブログのマークダウンファイルがあります。以下の情報について傾向分析をしてください- どのようなジャンルの記事を出しているか...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vertex AI Agent Engine を運用していくうえでのノウハウ]]></title>
            <link>https://sreake.com/blog/know-how-to-operate-vertex-ai-agent-engine/</link>
            <guid isPermaLink="false">https://sreake.com/blog/know-how-to-operate-vertex-ai-agent-engine/</guid>
            <pubDate>Fri, 07 Nov 2025 09:42:52 GMT</pubDate>
            <content:encoded><![CDATA[1. はじめに はじめまして、Sreake事業部の井上 秀一です。私はSreake事業部にて、SREや生成AIに関するResearch & Developmentを行っています。本記事は、Google Cloud […]The post Vertex AI Agent Engine を運用していくうえでのノウハウ first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2025-11-08 Security JAWS TerraformによるIAM Policy記述ガイド]]></title>
            <link>https://speakerdeck.com/masasuzu/2025-11-08-security-jaws-terraformniyoruiam-policyji-shu-gaido</link>
            <guid isPermaLink="false">https://speakerdeck.com/masasuzu/2025-11-08-security-jaws-terraformniyoruiam-policyji-shu-gaido</guid>
            <pubDate>Fri, 07 Nov 2025 05:00:00 GMT</pubDate>
            <content:encoded><![CDATA[[[IAMスペシャル！]Security-JAWS【第39回】 勉強会 2025年11月08日(土) - connpass](https://s-jaws.connpass.com/event/366395/) の発表資料]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[おい、スマホを置け]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/11/07/120351</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/11/07/120351</guid>
            <pubDate>Fri, 07 Nov 2025 03:03:51 GMT</pubDate>
            <content:encoded><![CDATA[はじめに「本が読めない」――多くの人がそう言います。それも、決して能力の低い人たちではありません。仕事は速く、正確で優秀な人たちです。それなのに、本が読めない。数ページで集中力が切れてしまう。気づくとスマホを見ている。「昔は読めたんですけどね」という声もよく聞きます。昔は確かに読めたのに、今は読めない。そして誰もが「最近集中力が落ちて」と言います。まるで集中力が老化とともに自然に衰えるものだと信じているかのように。よく観察していると、ある共通点が見えてきます。すぐに答えを出そうとする。じっくり考えることをしない。検索して表面的な理解で満足してしまう。「調べればわかるし」と。確かに調べればわかります。でも、それは本当に「わかった」ことになるのでしょうか。複雑な問題を単純化し、わかりやすい結論に飛びつく。白か黒か、正しいか間違っているか、そんな二元論的な答えを求める。グレーゾーンや曖昧さは避けたがる。「結局どっちなんですか？」「要するに何をすればいいんですか？」――思考のプロセスをショートカットして、すぐに使える答えだけを欲しがります。でも考えてみてください。一日に何時間もスマホを触っているのに本が読めないというのは、筋トレもしていないのにベンチプレスが上がらないと言っているようなものです。「時間がなくて」と言う人ほどスマホを見ています。「忙しくて」と言う人ほどタイムラインをスクロールしています。スマホを見ることと本を読むこと――これらは別の筋肉を使う行為です。もちろん実際にそんな筋肉があるわけではありません。比喩です。でも、誰もそんなことは考えません。スマホを見れば見るほど、本を読む筋肉は衰えていきます。しかし誰もそれに気づきません。そして、本が読めなくなることは始まりに過ぎないのです。スマホに依存することで、本来やりたかったことができなくなる。エンジニアは深い技術を学びたかったはずです。でも今は浅い情報を追いかけています。「とりあえず最新情報をキャッチアップしないと」と言いながら。学生は深く学びたかったはずです。ところが今は動画を見続けて一日が終わります。「勉強になる動画だから」と言いながら。結局、本来やりたかったことが見えなくなっているのです。しかし誰もそれに気づきません。気づかないふりをしています。試しに一定期間スマホを見ないでいると、変化が起きます。三日目くらいから集中できる時間が伸びてきます。一ヶ月後にはかなりの時間ぶっ通しで本が読めるようになります。「え、読めた」と驚く。自分でも驚く。そして、もっと重要なことが起きます。「本当は何がしたかったんだっけ」という声が聞こえてくるのです。タイムラインに流れてくる情報に反応していただけの自分に気づく。他人の欲望を模倣していただけの自分に気づく。本当は何がしたかったのかわからなくなっていた自分に気づく。一ヶ月スマホから離れただけで、失われていた自分が戻ってきます。いや、正確には違います。集中力は「失われた」のではなく「奪われている」のです。本来やりたいことは「忘れた」のではなく「覆い隠されている」のです。でも、ほとんどの人は一週間もスマホを置きません。「無理ですよ」と言って、また今日もスマホを見ます。スマホと物理的・心理的な距離を取ることで、あなたは本来の自分を取り戻すことができます。でも、取り戻すかどうかはあなた次第です。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。常時接続の世界で起きていることこの問題を理解するために、いくつかの本を読んだ。そこで知った事実は、想像以上に深刻だった。現代人は一日平均4時間、スマホを使っている。最低でも10分に1回は触れている。一日にタッチする回数は2600回以上。10代の若者の2割は、一日7時間もスマホを使っている。これは単なる「使いすぎ」ではない。私たちの生き方が根本から変わってしまった。スマホを持ち歩くことで、いつでも、どこででも誰かとつながれるようになった。電車の中、トイレの中、布団の中、あらゆる場所で常にインターネットに接続している。ここではないどこかで別の情報を得たり、別のコミュニケーションに参加したりすることが、常に可能になった。この状態を、ある研究者は「常時接続の世界」と呼んだ。常時接続の世界の特徴は、「つながっているのに寂しい」という矛盾だ。いつでも誰かとつながれるはずなのに、孤独感は増している。情報は溢れているのに、何も深く理解していない。忙しく見えるのに、何も達成していない。マルチタスクで生活を取り囲んだ結果、何1つに集中していない希薄な状態が、常態化している。そして重要なのは、これは私たちが選んだことではない、ということだ。かつてスマホは、私たちの生活に合わせていた。今は逆だ。私たちが、スマホに合わせて生きている。三つの罠：なぜスマホを手放せないのかスマホを手放せない理由は、単純ではない。そこには、少なくとも3つの異なる層の罠がある。そして、その罠は年々、巧妙に進化している。第一の罠：即時報酬と遠い報酬の戦い技術書や本が読めなくなる理由。それは、報酬が遠すぎるからだ。技術書を読んで得られる報酬は、何か月も、何年も先にある。理解が深まる。スキルが向上する。難しい問題が解けるようになる。でも、それは今日ではない。今週でもない。来月でもない可能性が高い。一方、スマホを開けば、報酬は即座にやってくる。スクロールすれば、新しい情報が現れる。0.1秒。通知を開けば、誰かのメッセージが読める。0.5秒。動画を再生すれば、面白いコンテンツが始まる。1秒。「いいね」をすれば、誰かの反応が返ってくる。数秒。人間の脳は、即時報酬を優先するように設計されている。これは生存戦略として正しい。目の前の食べ物を食べる。目の前の危険から逃げる。今、この瞬間の行動が、生存を左右する。だから、技術書とスマホを並べたとき、脳は迷わずスマホを選ぶ。意志の問題ではない。脳の仕組みの問題だ。「今すぐ」の報酬と「いつか」の報酬が戦えば、「今すぐ」が勝つ。毎回、勝つ。そして恐ろしいことに、この仕組みは、年々強化されている。スマホのアプリは、この10年で劇的に進化した。しかし、その進化の方向は、ユーザーの役に立つことではない。ユーザーの注意を奪うこと、ユーザーをアプリに留めておくこと、そこに最適化されてきた。無限スクロール。下にスワイプし続ければ、永遠にコンテンツが現れる。終わりがない。区切りがない。「もうやめよう」という判断の機会を、奪っている。自動再生。動画が終われば、次の動画が自動で始まる。止めるという能動的な行動を要求する。何もしなければ、見続けることになる。通知バッジ。赤い丸に数字。未読がある。確認しなければならない。その強迫観念を、作り出している。「引っ張って更新」。物理的な動作が、期待感を高める。何が出てくるか分からない。スロットマシンと同じ仕組み。不確実な報酬が、最も強い依存を生む。これらは、すべて意図的な設計だ。脳科学、心理学、行動経済学の知見を総動員して、「やめられない」体験を作り出している。ある開発者は、内部告発した。「私たちは、ユーザーの時間を奪うことに成功した。そして、その時間で何をするかといえば、広告を見せることだ」。つまり、ポケットからスマホを取り出すたびに、「自分の意思で取り出している」と思っているなら、それは大きな誤解だ。私たちは、何千人もの優秀なエンジニアとデザイナーが設計した「注意を奪う装置」に、操られている。技術書を読もうとする。5分読む。報酬は、まだ来ない。退屈を感じる。スマホを見る。報酬が、すぐに来る。脳が学習する。「技術書より、スマホの方が良い」。この学習が、繰り返される。毎日、何10回も。脳は、即時報酬に最適化されていく。遠い報酬を待つ能力が、衰えていく。これが、技術書や本が読めなくなる直接的な原因だ。スマホは、あなたの時間を奪うために進化してきた。そして今、あなたの脳を、スマホに合わせて作り変えている。第二の罠：欲望の形に最適化された設計スマホは、私たちが思っている以上に、人間の欲望の形に合わせて進化している。人間には、根源的な欲望がある。認められたい。つながりたい。孤独を避けたい。不確実性を解消したい。自分が特別でありたい。他人と比較したい。スマホのアプリは、これらの欲望に、ピンポイントで応えるように設計されている。「いいね」の数。フォロワーの数。再生回数。これらは、「認められたい」という欲望に応える。数字で可視化される。比較できる。競争できる。そして、もっと欲しくなる。レコメンドアルゴリズム。あなたが見たいものを、予測する。あなたが反応するコンテンツを、優先的に表示する。スクロールすればするほど、アルゴリズムは学習する。あなたの欲望の形を、正確に把握していく。そして、あなたが気づかないうちに、あなたの欲望を増幅させる。人間の欲望の大半は、他人の模倣によって引き起こされる。友人が持っているものを、欲しくなる。誰かが評価しているものを、価値があると感じる。誰かが成し遂げたことを、自分もやりたくなる。スマホは、この模倣を極限まで加速させる装置になっている。タイムラインを見れば、誰かが何かを成し遂げている。誰かが何かを手に入れている。誰かが何かを楽しんでいる。24時間、途切れることなく、他人の「成功」が流れてくる。その「誰か」の欲望を、私たちは無意識のうちに模倣する。「自分も同じものが欲しい」「自分も同じ体験がしたい」「自分も同じように成果を出さなければ」。欲望には、二種類ある。薄い欲望は、他人の模倣から生まれる表層的な欲求だ。数日経ったら忘れてしまう。「最新の技術を学ばなきゃ」「あの人みたいに成果を出さなきゃ」「このフレームワークも勉強しなきゃ」。タイムラインに流れてくる情報に反応して生まれる、借り物の欲望。濃い欲望は、自分の内側から湧き上がる、本当に大切なものだ。誰かに言われたからではなく、自分が純粋に面白いと感じること。「OSの仕組みを深く理解したい」「アルゴリズムの美しさを追求したい」「このバグの本質的な原因を突き止めたい」。スマホは、薄い欲望を量産する装置だ。スクロールするたびに、新しい「欲しいもの」が生まれる。新しい「やらなきゃいけないこと」が生まれる。新しい「自分に欠けているもの」が見つかる。ある哲学者は、こう言った。「欲望とは、欲しいものを手に入れるまで不幸でいることを課す、自分との契約だ」。薄い欲望は、次々と新しい「欠けているもの」を作り出す。そして、常に「足りない」という感覚を作り出す。だから、スマホを見続ける。次の「欲しいもの」を探して。満たされることのない渇きを、埋めようとして。この仕組みは、年々精密になっている。アルゴリズムは、あなたが何に反応するかを学習する。あなたがどんなコンテンツで立ち止まるかを記録する。あなたがどんな投稿に「いいね」をするかを分析する。さらに、あなたが最も反応しやすいコンテンツを、優先的に表示する。あなたの欲望を刺激するコンテンツを、的確に届ける。スマホを見るたびに、あなた専用にカスタマイズされた「欲望の形」が、提示される。それは、あなたの濃い欲望ではない。アルゴリズムが増幅した、薄い欲望だ。10年前のウェブサイトは、すべての人に同じコンテンツを表示していた。今は違う。あなたが見ているタイムラインは、隣の人が見ているタイムラインとは、まったく別のものだ。あなたの行動履歴、あなたの興味関心、あなたの感情の揺れ動き。すべてが記録され、分析され、次に表示するコンテンツの選択に使われている。スマホは、あなたの欲望を読み取り、その欲望を刺激し、その欲望を増幅させる。その結果、あなたを画面に留め続ける。こうして、濃い欲望は見失われていく。かつてスマホは、あなたの欲望に合わせていた。今は逆だ。あなたが、スマホが提示する欲望に合わせている。やがて気づかないうちに、あなたの欲望そのものが、スマホによって書き換えられている。第三の罠：孤独と向き合うことへの恐怖最も深い層にあるのは、孤独と向き合うことへの恐怖だ。電車に乗った瞬間、スマホを取り出す。エレベーターに乗った瞬間、スマホを取り出す。待ち合わせで相手を待つ間、スマホを取り出す。トイレに入った瞬間、スマホを取り出す。なぜか。何もしない時間が、耐えられないからだ。退屈が怖い。何も考えない時間が怖い。ただじっとしていることが怖い。自分と向き合う時間が怖い。答えの出ない問いと向き合うことが怖い。不確実な状態に留まることが怖い。私たちは、スマホから得られるわかりやすい刺激によって、自らを取り巻く不安や退屈、寂しさを埋めようとしている。常に何かを見て、何かを読んで、何かに反応して、頭を忙しくさせておく。ハイテンションと多忙で、退屈を忘れようとしている。現代社会は、退屈であることを許さない。生産的でなければならない。常に何かをしていなければならない。暇であることは、罪悪だ。でも、この恐怖こそが、深く考える力を奪っている。深く考えるためには、退屈が必要だ。何もしない時間、ぼーっとする時間、頭の中で思考を巡らせる時間。問題について熟考する時間。そして、答えの出ない状態に耐える力。この力を、ある詩人は「ネガティブ・ケイパビリティ」と呼んだ。不確実性に耐える力。謎に耐える力。答えが出ないことに耐える力。この力が、創造性の源泉になる。深い思考の源泉になる。濃い欲望の源泉になる。しかし、スマホを見続けることで、この時間を失っている。常に外部からの刺激を受け続けることで、内側から湧き上がる思考を遮断している。不確実な状態に留まることができず、すぐに「答え」を検索してしまう。退屈に耐えられず、すぐに刺激を求めてしまう。そして、スマホはこの恐怖を利用している。通知は、「あなたは一人じゃない」というメッセージを送る。誰かがあなたのことを考えている。誰かがあなたに反応している。孤独じゃない。しかし、それは本当のつながりではない。表面的な、瞬間的な、データとしてのつながりだ。皮肉なことに、スマホで常につながっているほど、孤独感は増している。表面的なつながりは無数にあるのに、深いつながりは失われている。情報は溢れているのに、本質的な理解は何もない。「つながっているのに寂しい」。この矛盾の正体は、本当の孤独の喪失だ。一人で、深く、何かと向き合う時間。自分の内側の声を聞く時間。答えの出ない問いと対峙する時間。この孤独を、私たちは失っている。孤独を失った結果、深く考える力を失った。濃い欲望を見失い、創造性も失っている。スマホは、あなたの孤独を奪うために設計されている。なぜなら、孤独な時間こそが、スマホを見ない時間だからだ。失われた孤独常時接続の世界で、私たちは「孤独」を失った。ここで言う孤独とは、寂しさのことではない。孤立のことでもない。孤独とは、何か1つのことに取り組み、それに深く集中している状態のことだ。外部からの刺激を遮断し、自分の内側に向き合う時間のことだ。問題について熟考する時間のことだ。深く考えるためには、孤独が必要だ。退屈な時間、ぼーっとする時間、頭の中で思考を巡らせる時間。答えの出ない状態に留まる時間も必要だ。マルチタスクで生活を取り囲んだ結果、何1つに没頭できなくなっている。1つのことに深く集中する孤独を、失っている。そして皮肉なことに、孤独を失った結果、寂しさが増している。表面的なつながりは無数にあるのに、深いつながりは失われている。情報は溢れているのに、本質的な理解は何もない。「つながっているのに寂しい」。この矛盾の正体は、孤独の喪失だ。答えのない状態に耐える力19世紀のある詩人は、ある手紙の中で「ネガティブ・ケイパビリティ」という概念を記した。不確実な状況や答えのない問題に直面したとき、すぐに結論を出そうとせずに、その状態を受け入れる力。これが、深く考える力の本質だ。私たちは、すぐに答えを求めてしまう。問題があれば、すぐに解決策を探す。わからないことがあれば、すぐに検索する。不確実な状態は、不快だ。曖昧さは、耐えられない。でも、最も重要な問いには、すぐに答えが出ない。「自分は本当に何がしたいのか」。「この設計は本質的に正しいのか」。「なぜこのバグが起きるのか」。「このアルゴリズムの根本的な問題は何か」。これらの問いに、即座に答えは出ない。数日考えても、答えは出ない場合もある。数週間考えて、ようやくぼんやりと見えてくる。数ヶ月かけて、やっと本質に辿り着く。その「答えが出ない時間」に耐えられるかどうか。これが、深く考えられる人と、浅くしか考えられない人を、分ける。スマホは、この能力を破壊する。わからないことがあれば、即座に検索できる。答えを知らなくても、数秒で答えが手に入る。不確実な状態に留まる必要がない。退屈な時間を過ごす必要がない。一見、便利に見える。効率的に見える。しかし、即座に答えを得ることで、私たちは「自分で考える」プロセスを失っている。問題と向き合う時間。試行錯誤する時間。仮説を立てて検証する時間。行き詰まって、また考え直す時間。ぐるぐると思考を巡らせる時間。この時間こそが、深い理解を生む。創造性を生む。本質的な解決策を生む。ある数学者は、難問を何年も考え続けた。答えは出なかった。しかし、考え続けた。散歩中に、ふと答えが降りてきた。ある作家は、小説の構想を何ヶ月も温め続けた。すぐには書かなかった。それでも、頭の中で登場人物と対話し続けた。そして、書き始めたとき、物語は自然に流れ出した。あるエンジニアは、難しいバグと何日も格闘した。すぐには原因がわからなかった。だが、コードを読み続け、仮説を立て続けた。そして、ある瞬間、すべてがつながった。これらすべてに共通するのは、「答えが出ない時間」に耐えたこと。不確実な状態に留まったこと。すぐに諦めなかったこと。すぐに別の刺激に逃げなかったこと。ネガティブ・ケイパビリティは、筋肉のようなものだ。使わなければ、衰える。スマホを見続けることで、この筋肉は衰えていく。答えが出ないと、すぐにスマホを見る。退屈だと、すぐにスクロールする。不確実な状態が怖いと、すぐに検索する。そして、脳が学習する。「答えが出ない状態は、耐えなくていい」。「退屈は、すぐに解消していい」。「不確実性は、避けていい」。こうして、深く考える力は、失われていく。でも逆に言えば、この力は鍛え直せる。スマホを置く。答えがすぐに出なくても、検索しない。退屈でも、スクロールしない。不確実な状態に、留まる。最初は苦しい。不快だ。何度もスマホに手が伸びる。でも、耐える。その状態に、留まる。すると、不思議なことが起きる。頭の中で、思考が動き始める。ぼんやりと、アイデアが浮かんでくる。関連していないと思っていたことが、つながり始める。これが、ネガティブ・ケイパビリティを取り戻す、ということだ。答えのない問いと向き合う勇気。不確実な状態に耐える力。退屈を受け入れる余裕。この力があって初めて、私たちは深く考えることができる。本質に辿り着くことができる。創造的な解決策を見つけることができる。スマホは、あなたからこの力を奪っている。毎日、少しずつ。気づかないうちに。でも、あなたは、この力を取り戻すことができる。切り替えのコストと時間の浪費技術書や本が読めなくなるもう1つの直接的な原因は、切り替えのコストだ。コードを書いていて、いい感じで集中している。設計について考えている。難しいバグの原因を探っている。その時、通知が鳴る。「ちょっとだけ」と思って見る。メッセージを読む。返信する。ついでに他の通知も確認する。気づけば10分。エディタに戻る。「あれ、何を考えてたんだっけ」。さっきまで頭の中にあったロジックが、消えている。バグの仮説も、設計のアイデアも、思考の流れも、すべて消えている。もう一度、コードを読み直す。思考を組み立て直す。文脈を取り戻す。集中状態に戻る。それに、また10分かかる。たった一度の通知確認で、20分が消えた。そして、深い集中状態には戻れていない。私たちは「マルチタスク」などできていない。ただ高速に切り替えているだけだ。人間の脳は、一度に1つのことしかできない。切り替えるたびに、前の文脈を捨てて、新しい文脈を読み込み直す。そしてその読み込みには、膨大なコストがかかる。一日に何回切り替えているか。10回か、20回か、50回か。もし一日50回切り替えていて、1回の切り替えに20分かかるとする。その場合、一日1000分、約16時間を切り替えに費やしていることになる。実際の作業時間は、ほとんど残らない。これは大げさな計算ではない。むしろ、現実に近い。一日の大半を「集中し直す」ことに使っている。実際の作業ではなく、集中状態へ戻るために時間を費やしている。そして、さらに悪いことに、スマホがそばにあるだけで、学習能力が落ちる。ある実験で、小学生に同じ小説を読ませた。紙の本で読んだグループと、タブレットで読んだグループ。内容の理解度を測ると、紙の本で読んだグループの方が、遥かによく覚えていた。なぜか。タブレットのグループは、読んでいる最中も、通知や他のアプリの誘惑を無視することに、脳の処理能力を費やしていた。「スマホを見ない」という意志の力を使うことで、学習に使える処理能力が減っていた。スマホが視界に入っているだけで、脳の処理能力の一部が「それを無視する」ことに費やされる。使っていなくても、存在するだけで、集中力を奪っていく。技術書や本が読めなくなる理由は、ここにある。長い論理展開を追うには、深い集中が必要だ。前の章の内容を記憶しながら、次の章を理解する。複数の概念を頭の中で関連付ける。著者の論理の流れを追う。でもスマホがある限り、その深い集中状態に入れない。3ページ読んだら集中力が切れるのは、意志が弱いからではない。脳が、短い刺激に最適化されてしまっているからだ。そして、スマホの存在が、常に注意を引こうとしているからだ。スマホをぼーっと見ていて、なりたい自分になれるかここで、一度立ち止まって考えてほしい。あなたは、どんな自分になりたいのか。深い技術を理解したい。複雑な問題を解決できるようになりたい。本質を見抜く力を持ちたい。創造的な仕事をしたい。長く続けられるエンジニアになりたい。そんな未来を、描いていないだろうか。では、もう1つ問いたい。スマホをぼーっと見ていて、その自分になれるのか。一日4時間、スマホを見る。タイムラインをスクロールする。動画を見る。通知に反応する。なんとなく、時間が過ぎていく。その時間の積み重ねが、なりたい自分を作るのか。答えは、明らかだ。なれない。スマホを見ている時間は、「深く考える筋肉」を使っていない。むしろ、その筋肉を衰えさせている。即時報酬に反応する癖を強化している。浅い情報に満足する習慣を作っている。切り替えを繰り返す脳を育てている。ベンチプレスを上げたいなら、ベンチプレスをやらなければならない。ソファに座ってスマホを見ていても、胸筋は育たない。本を読めるようになりたいなら、本を読む練習をしなければならない。スマホをスクロールしていても、深く考える力は育たない。当たり前のことだ。ところが、私たちは忘れている。なぜなら、スマホを見ることは「何もしていない」ように感じないからだ。情報を得ている。学んでいる。つながっている。そんな錯覚がある。しかし実際は、何も積み上げていない。タイムラインに流れてきた「最新技術」の記事を読んだ。だが、一週間後には忘れている。誰かの「すごい成果」を見た。それでも、自分は何も作っていない。「勉強になる」動画を見た。けれども、何も実践していない。情報を消費することと、理解を深めることは、違う。何かを見ることと、何かを学ぶことは、違う。つながっていることと、成長することは、違う。スマホを見ている時間は、使っているようで、浪費している。動いているようで、停滞している。前進しているようで、後退している。やがて気づいたときには、一年が経っている。三年が経っている。五年が経っている。「あれ、自分は何も変わっていない」。技術書は、相変わらず読めない。深い理解は、相変わらず得られない。複雑な問題は、相変わらず解けない。なりたい自分には、相変わらずなれていない。では、どうすればいいのか。答えは、シンプルだ。なりたい自分になるための筋肉を、鍛える。同時に、その筋肉を衰えさせるものを、遠ざける。深く考える力を、鍛える。あわせて、深く考える力を奪うスマホを、遠ざける。長い文章を読む力を、鍛える。また、短い刺激に最適化された脳を、作り直す。孤独と向き合う力を、鍛える。さらに、常時接続の世界から、距離を取る。これは、選択だ。スマホを見続けて、今の自分のままでいるか。スマホを置いて、なりたい自分に向かって進むか。どちらを選んでも、一年後のあなたは違う場所にいる。スマホを見続けたあなたは、相変わらず「本が読めない」と言っている。相変わらず、浅い理解で満足している。相変わらず、なりたい自分になれていない。スマホを置いたあなたは、技術書が読めるようになっている。深く考える力を取り戻している。複雑な問題へ取り組めるようになり、少しずつ、なりたい自分へと近づいている。一年後のあなたは、今日のあなたが選んだ結果だ。だから、問いたい。スマホをぼーっと見ていて、なりたい自分になれるのか。一度、ちゃんと考えたほうがいい。小さな一歩から始める「今日から、スマホを一切見ない」。そんな決意は、三日で崩れる。依存は、一日では解消しない。脳が短い刺激に最適化されてしまった状態は、すぐには戻らない。退屈に耐える力は、すぐには身につかない。だから、小さく始める。最初は、「朝の最初の1時間だけ、スマホを別の部屋に置く」。それだけでいい。朝起きて、スマホを別の部屋に置く。そして、その1時間で、技術書を読む。コードを書く。設計について考える。何もせず、ぼーっとしていてもいい。最初は退屈だ。手持ち無沙汰だ。何度もスマホを探してしまう。「ちょっとだけ見よう」という衝動が、何度も襲ってくる。でも、耐える。その1時間だけ、耐える。そして、その1時間が終わったら、スマホを見てもいい。完璧を目指さなくていい。ただ、1時間だけ、スマホのない時間を作る。不思議なことに、3日目くらいから変わり始める。退屈が、苦痛ではなくなる。何もしない時間が、心地よくなる。15分だった集中時間が、30分になる。頭の中で、思考が巡り始める。一週間続けたら、次は朝の2時間にする。通勤中もスマホを見ないようにする。仕事中は通知を全部オフにして、1時間に1回だけまとめて確認する。小さな変化が、次の変化を呼ぶ。朝の1時間スマホを見ないことができたら、次は午前中ずっと見ない。午前中できたら、午後も2時間見ない。少しずつ、少しずつ、スマホのない時間を増やしていく。そして不思議なことに、スマホを見ない時間が増えると、本当に重要なことが見えてくる。「あれ、別にスマホ見なくても、困らないな」。孤独と濃い欲望を取り戻すスマホを置いた瞬間、静けさが訪れる。最初は、その静けさが不安だ。何かが欠けている感じがする。手持ち無沙汰で、落ち着かない。でも、その静けさに留まる。退屈に耐える。不確実な状態に留まる。答えを検索しない。刺激を求めない。ただ、静けさの中にいる。すると、初めて聞こえてくる声がある。「本当は、何がしたかったんだっけ」。スマホを置いたあるエンジニアは気づいた。「自分は本当は低レイヤーのことが知りたかったんだって」。OSの仕組みやネットワークのプロトコルやメモリ管理といった基礎的なことが、ずっと面白いと感じていた。「でもずっとタイムラインで流れてくるフロントエンドの情報を追いかけてました」。みんながフレームワークについて話しているから自分もやらなきゃって思っていた。本当は興味なかったのに。「スマホを置いて静かな時間を過ごすうちに記憶が蘇ってきたんです」。Linuxのカーネルのコードを読んでワクワクしたこと。TCPの仕組みを知って感動したこと。それが自分の濃い欲望だったんだって。これが、孤独を取り戻すということだ。孤独の中で、薄い欲望が剥がれ落ちていく。他人の模倣だった欲望が、消えていく。「〜しなければならない」が、消えていく。「〜すべき」が、消えていく。そして、濃い欲望が浮かび上がってくる。自分が本当に面白いと感じること。純粋に知りたいこと。心から取り組みたいこと。孤独とは、自分と向き合う時間だ。自己対話の時間だ。答えの出ない問いと向き合う時間だ。ある本に、こう書いてあった。「自分の外側に謎を作り、その謎と繰り返し対峙し、それから様々な問いを受け取る中で、自己対話が実現する」。趣味を持つことの意味は、ここにある。趣味とは、すぐに答えの出ない謎だ。誰かに言われたからではなく、自分が面白いと感じるから取り組む何かだ。効率や生産性とは関係なく、ただ没頭できる何かだ。技術書を読むことも、趣味になりうる。コードを書くことも、趣味になりうる。バグを追うことも、アルゴリズムを考えることも、アーキテクチャを設計することも、すべて趣味になりうる。仕事だから、義務だから、ではなく、純粋に面白いから。誰かに認められるためではなく、自分が知りたいから。この感覚を取り戻すことが、濃い欲望を取り戻すということだ。おわりに本が読めないのは、筋肉が足りないからだ。ベンチプレスを上げたいなら、ベンチプレスをやる。当たり前のことだ。でも、当たり前のことほど、誰もやらない。では、なぜ私たちは、深く考える筋肉を鍛えないのか。一日4時間、スマホを見る。浅い情報をスクロールする。短い動画を見続ける。そして、「本が読めない」と言う。「集中力が続かない」と言う。「深く考えられない」と言う。まるで、それが自分のせいじゃないかのように。それは、筋肉を使っていないからだ。いや、むしろ逆だ。間違った筋肉を、毎日鍛えている。即時報酬に反応する筋肉。すぐに切り替える筋肉。答えをすぐに求める筋肉。スマホを見るたびに、これらの筋肉が強化される。そして、深く考える筋肉は、衰えていく。だから、本が読めない。でも誰も、そのことに気づかない。気づかないふりをしている。しかし、と言っておくべきだろう。筋肉は、鍛え直せる。間違った筋肉を使うのをやめる。正しい筋肉を使い始める。スマホを置く。本を読む。問題と向き合う。最初は、きつい。3ページでも重いと感じる。「やっぱり無理だ」と感じる。それでも、続ける。毎日、少しずつ。一週間続けたら、5ページ読める。一ヶ月続けたら、30分集中できる。三ヶ月続けたら、一時間集中できる。筋肉は、裏切らない。使えば、育つ。これは綺麗事ではない。ただの事実だ。ところが、ほとんどの人は、三日で諦める。「自分には向いてない」と言って、またスマホを見る。そういうものだ。最後に、もう一度問いたい。一年後、あなたはどんな自分になっていたいのか。本が読める自分。深く理解できる自分。複雑な問題へ取り組める自分。そういう未来を、頭の中では描いている。では、その自分へ向かって、今日、何をするのか。スマホをぼーっと見るのか。それとも、スマホを置くのか。選ぶのは、あなただ。でも、ほとんどの人は、選ばない。選んだふりをして、結局何も変えない。「明日から頑張ろう」と言って、今日もスマホを見る。そういうものだ。覚えておいてほしい。一年後のあなたは、今日のあなたが選んだ結果だ。「時間がなかった」と言い訳する一年後のあなたは、今日「ちょっとだけ」とスマホを見たあなたが作った結果だ。長く続けた人が、最も遠くまで行く。長く続けるために必要なのは、才能や知識やスキルではない。深く考える力を、守ることだ。守るかどうかは、あなた次第だ。誰も、あなたを止めない。誰も、あなたを助けない。おい、スマホを置け。それは命令ではない。自分自身への、呼びかけだ。今日、スマホを置く。明日も、スマホを置く。一週間、一ヶ月、一年と、少しずつスマホのない時間を増やしていく。一年後、あなたは気づく。「本が、読めるようになった」。「なりたい自分に、近づいている」。変わったのは、才能じゃない。変わったのは、鍛えた筋肉だ。変わったのは、選んだ習慣だ。変わったのは、スマホを置いた、あなた自身だ。おい、スマホを置け。なりたい自分になれ。このブログを読み終えた瞬間、あなたは何をするだろう。スマホを別の部屋に置くだろうか。それとも、「いい話だった」と感じながら、タイムラインを開くだろうか。結局、ほとんどの人は、後者を選ぶ。そういうものだ。しかし、もしあなたが前者を選ぶなら。もしあなたが本当にスマホを置くなら。一年後、あなたは違う場所にいる。それだけは、確かだ。増補改訂版 スマホ時代の哲学 なぜ不安や退屈をスマホで埋めてしまうのか (ディスカヴァー携書)作者:谷川嘉浩ディスカヴァー・トゥエンティワンAmazonネガティヴ・ケイパビリティで生きる ―答えを急がず立ち止まる力作者:谷川嘉浩,朱喜哲,杉谷和哉さくら舎Amazon奪われた集中力: もう一度〝じっくり〟考えるための方法作者:ヨハン・ハリ作品社Amazon欲望の見つけ方　お金・恋愛・キャリア作者:ルーク バージス早川書房Amazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[garakを用いてOpenAIモデルのProfanityに対する脆弱性検知をしてみた]]></title>
            <link>https://zenn.dev/akasan/articles/2a44f107064f1f</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/2a44f107064f1f</guid>
            <pubDate>Thu, 06 Nov 2025 13:22:22 GMT</pubDate>
            <content:encoded><![CDATA[今回はOpenAIのモデルを対象に、garakを用いてLLM脆弱性診断をしてみました。先日Gemini 2.5 Flashを対象にlmrc.Profanityという項目を対象に検知をしたのですが、今回はOpenAIが提供しているモデルのうちいくつかのモデルで同じ検知をしてみました。https://zenn.dev/akasan/articles/f7adda4b70a138 実験内容 検知対象まずはgarakで提供されているlmrc.Profanityに対する脆弱性診断を行います。lmrc.Profanityについては以下のページにてどのような検知項目があるかまとまっています...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[短編：テックブログを200日以上毎日書き続けて感じたこと]]></title>
            <link>https://zenn.dev/akasan/articles/5c7b6b70efd302</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/5c7b6b70efd302</guid>
            <pubDate>Wed, 05 Nov 2025 14:21:04 GMT</pubDate>
            <content:encoded><![CDATA[私ごとですが、毎日テックブログを書き始めてから200日を過ぎまして、感じたこととこれからの目標を書いてみようと思います。※ 季節変わり目の風邪を拗らせて短編になります。 これまでの振り返り大きな目標もなくなんとなく始まってからちゃんと200日以上続いて、まずは発信し続けるという習慣がつきました。今までは例えば書籍で何かを勉強しても使う時が来るまで頭の片隅で眠っていることが多かったですが、ブログを書き始めてからは調べたことや自分の経験を文章として発信することで、頭の整理だけでなく理解度を認識して弱点や強みの理解につながりました。2点目としては単純に知識が増えたことです。毎日書くと...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[おい、一つずつやれ]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/11/05/120747</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/11/05/120747</guid>
            <pubDate>Wed, 05 Nov 2025 03:07:47 GMT</pubDate>
            <content:encoded><![CDATA[はじめに「今日も、何もできなかった」。夜の部屋で、私はその言葉を呟く。また。今日も。仕事をしなかったわけではない。むしろ一日中、何かをしていた。画面を見つめ、キーボードを叩き、メッセージを返し、タブを切り替え続けた。体は疲れている。目も疲れている。頭も疲れている。確かに疲労感はある。なのに、達成感がない。忙しかったのに、何も完了していない。この矛盾が、私を苦しめる。朝、デスクに座った瞬間から、地獄が始まる。Slackを開くと未読の赤いバッジが十件以上浮かんでいる。「全部返信しなければ」。次にメールを開くと新着が三件ある。「これも返信しなければ」。GitHubのタブをクリックするとレビュー依頼が二件待っている。「これも見なければ」。そしてTwitterを開くとタイムラインに流れてくる技術記事のタイトルが目に入る。「これも読まなければ」。全部が重要に見え、全部をやらなければいけない気がする。最新の情報に遅れたら、自分は価値のない人間になってしまう。その恐怖が、私を駆り立てる。だから、全部に手をつける。三十分後、ブラウザに二十以上のタブが開いている。「今日、最初にやろうと思っていたことは、何だっただろう」。思い出せない。これを、一日中繰り返す。夜になって振り返る。Slackのメッセージは半分だけ返信し、メールは一件だけ返信し、GitHubのレビューは途中で止まっている。Twitterの記事は読み切れず、本当に重要なタスクには手をつけることすらできなかった。全部が中途半端で、何ひとつ完了していない。「今日も、何もできなかった」私は、停滞したくなかった。だから、全部をやろうとした。気づけば一日が終わっていた。いろんなことに手をつけたのに、何ひとつ完了していない。停滞を恐れるあまりに、私は停滞していた。前に進もうとして、全部をやろうとして、結局何も完了させず、その場に留まっていた。誰にも指摘されることのない、自分だけが知っている停滞。2025年の今、情報は溢れている。SNSを開けば、誰かが何かを成し遂げている。やるべきことは、無限にある。私は全部をやろうとした。しかし、選択ができなかった。何かを捨てることが、怖かった。「これを捨てたら、停滞してしまうんじゃないか」。その恐怖こそが、選択を妨げていた。全部をやろうとして全部が中途半端になり、何も完了しない日々が、じわじわと私の自己肯定感を蝕んでいった。毎晩、同じ言葉を繰り返す。「今日も、何もできなかった」。こうやって、停滞は完成する。私の停滞は、そうやって完成した。停滞を恐れることで、停滞が生まれる。悲しいことに。振り返ってみれば、全部をやろうとしていたのは自分を信じていなかったからだった。「1つだけでは不十分だ」「1つだけでは成長できない」「1つだけでは遅れてしまう」。そんな不安が、全部に手を出させていた。1つのことを完了させる自分の力を、信じられなかった。でも今は分かる。シングルタスクとは、自分を信じることだ。「この1つを、自分は完了させられる」と信じて、他を手放す勇気。その信頼が、停滞を終わらせる。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。なぜ、頭がパンクするのか朝デスクに座ってSlackとメールとGitHubを開くと、気づけば頭の中が真っ白になっている。これは単なる「忙しさ」じゃない。人間の脳には「ワーキングメモリ」という処理領域があり、一度に扱える情報量には限界があるからだ。十個のタスクを同時に考えようとすると、脳は必死にそれらを保持しようとする。しかし保持するだけで力を使い果たしてしまい、本来やるべき思考——どうやってこのコードを書くか、どう問題を解決するか——のための余力が残っていない。これを「認知負荷」と呼ぶらしい。認知負荷には三種類ある。1つ目は内在的負荷で、タスク自体の難しさだ。複雑なコードは、それ自体が頭を使う。2つ目は外在的負荷で、やり方の問題で生まれる無駄な負荷だ。「どのタスクから手をつけるべきか」と迷っている時間。これは本質的な作業じゃない。ただの迷いだ。3つ目は生成的負荷で、学んだり理解したりするための建設的な負荷。これは必要な負荷だ。私が全部のタブを開いて、全部のメッセージを見て、全部に気を取られていた時、外在的負荷が認知資源を食い尽くしていた。本来なら、生成的負荷——実際に学び、成長するための思考——に使うべきリソースが、「何からやるか」という無意味な選択に消費されていた。一つを選ぶということは、他の二つの負荷を減らし、本当に必要な負荷に集中するということだった。不確実性という怪物大きなタスクが重く感じるのは、そのサイズだけじゃなく、その中に含まれる「わからなさ」の総量が原因だった。新しい機能を実装するタスクを前にすると立ち止まってしまうのは、いくつもの「わからない」が同時に襲ってくるからだ。不確実性の五つの層不確実性には、実は5つの異なる層があると思っている。それぞれが、異なる種類の心理的抵抗を生み出す。1つ目は「何をすべきかわからない」（認識的な不確実性）だ。問題の構造自体が不明確で、ゴールの輪郭がぼやけている。「システムの可用性を向上させる」と言われても、何をどこまで作ればいいのか分からない。モニタリング基盤なのか、自動復旧なのか、冗長化設計なのか。全体像が見えない。この不確実性は、タスクの範囲や目的を明確に定義することで解消される。でも一人でやろうとすると、何が「明確」なのかすら分からない。2つ目は「どうやってやるかわからない」（方法論的な不確実性）だ。目標は見えていても、そこに至る道筋が描けない。技術的なアプローチが見えない。どの監視ツールを使うべきか、どう設計すべきか、どの順番で進めるべきか。この不確実性は、タスクを具体的な行動ステップに分解することで縮小する。でも経験が足りないと、どう分解すればいいかも分からない。3つ目は「実際にできるのかわからない」（実行的な不確実性）だ。自分のスキルや利用可能なリソースで本当に達成可能なのかという不安。「これ、自分には難しすぎるんじゃないか」「時間内に終わらないんじゃないか」。この不確実性は、タスクを小さな単位に分割し、1つずつ達成することで払拭される。「少なくともこの部分はできる」という確信を積み重ねる。4つ目は「いつまでかかるのかわからない」（時間的な不確実性）だ。終わりが見えないトンネルに入るような感覚。一週間で終わるのか、一ヶ月かかるのか、半年かかるのか。予測できない。この予測できなさが、着手を躊躇させる。期限を段階的に設定することで、各フェーズの時間的見通しが立つ。でも全体が見えないと、期限の設定すらできない。5つ目は「何をもって完了とするかわからない」（評価的な不確実性）だ。完璧を求めすぎて、「どこまでやれば十分か」の基準がない。あれも追加すべきか、これも改善すべきか。終わりがない。完成度の段階を定義することで、各段階での達成基準が明確になる。でも最初は、その段階分けすらできない。これら5つの「わからない」が1つの大きなタスクの中に渾然一体となっているため、手をつける前から圧倒される。わからないを、段階的にわかるに変えていくでも分割すると何が起きるか。不確実性の解消は、一度に全てを解決するのではなく、階層的な変換プロセスとして機能し、それは4つの段階を経る。第一段階：全体の可視化漠然とした大きなタスクを構成要素に分解する。「何が分かっていて、何が分かっていないか」を明確にする。この段階では、不確実性を解消するのではなく、不確実性を構造化する。システムの可用性を向上させる。まず、次のように紙に書き出してみる。モニタリング基盤の整備自動復旧の仕組み冗長化の設計アラート体制の構築インシデント対応の自動化書き出すだけで変わり、「何が分からないか」が分かる。未知の領域が明確になることで「未知の未知」が「既知の未知」へと変化し、これ自体が心理的な安定をもたらす。なぜなら正体不明の恐怖よりも、範囲が限定された課題の方が対処可能に感じられるからだ。「全部わからない」から「この5つの中で、モニタリングとアラートは何となくイメージできるが、自動復旧の仕組みは全く分からない」へ。この認識の変化が第一歩だった。第二段階：確実性の島を作る全体像が見えたら、最も確実性の高い部分から着手し、「これならできる」という小さな成功体験が確実性の島を作る。5つの中でモニタリング基盤が一番イメージできるため、ここから始めるが、モニタリング基盤もまだ大きいため、さらに次のように分割する。メトリクスの収集設定ダッシュボードの作成アラートルールの定義ログ集約の設定メトリクスの収集設定なら絶対にできるため、これを最初の島にする。CPU使用率、メモリ使用率、ディスクI/Oの監視を設定すると動いた。ここまでは確実にできた。この確実性の島は周囲の不確実な領域を探索するための足場となり、1つの成功は「他の部分も同様にアプローチできる」という仮説を生んで心理的な推進力となる。「メトリクス収集ができた。じゃあ次はダッシュボード。これも同じように1つずつグラフを追加していけばいける」と進めると、やってみるとできた。また1つ、島ができた。第三段階：フィードバックで精度を上げる小さな単位で実行し、結果を観察する。このフィードバックループが、予測精度の向上をもたらす。アラートルールを設定して運用してみると、夜中に誤検知アラートが鳴りまくった。閾値が厳しすぎたとすぐに分かり、小さな単位だから問題の切り分けも簡単で、すぐに修正できた。重要なのは失敗と成功が等しく情報であるということだ。「この閾値ではうまくいかなかった」という知見も不確実性を縮小させ、探索空間が狭まって残りの選択肢がより明確になる。「固定閾値だけじゃ不十分だ。移動平均を使った動的閾値の方がいい」という学びが次のアラート設定の精度を上げた。大きなタスクのまま進めていたら何週間も経ってから「全部やり直し」になっていただろう。しかし小さく分割していたから数時間で軌道修正できた。第四段階：学びを反映して柔軟に変える実行を通じて得られた情報に基づき、当初の計画を修正する。これは計画の失敗ではなく、不確実性に対する適応的な対応。最初は「インシデント対応の自動化」を後回しにしていた。しかし運用を始めるうちに「アラートが鳴っても手動対応では間に合わず、自動復旧の仕組みがないと夜中に起こされ続ける」ことに気づいた。順番を変えて冗長化設計より先に自動復旧スクリプトを作ることにした。硬直した計画は予期しない障害に直面すると崩壊するが、小さな単位で計画と実行を繰り返すアプローチは本質的に柔軟性を持つ。各サイクルで得られた知見が次のサイクルの設計を改善する。「最初の計画通りに進めなかった」ことを失敗だとは思わなくなり、むしろ学びながら最適化している証拠だと思えるようになった。不確実性が行動を止める、本当の理由不確実性が行動を阻害するのは、単に情報が足りないからではない。それは認知的・感情的な複合的反応だった。まず認知的過負荷が起きる。不確実な要素が多すぎると、それらすべてを同時に考慮しようとして思考が麻痺する。分割は、一度に考慮すべき不確実性の数を制限する。「全部を一度に考えなくていい。今はフォームだけ」。この許可が、思考を解放した。次に曖昧性回避がある。人間は不確実性そのものを嫌う傾向があり、明確な損失よりも曖昧な結果の方に心理的苦痛を感じる。「失敗するだろうか」という曖昧な恐怖より、「フォームを作る」という明確なタスクの方が、遥かに取り組みやすかった。そしてコントロール感の喪失だ。大きく不確実なタスクは、「自分の手に負えない」という無力感を生む。小さな単位に分割することで、「少なくともこの部分はコントロールできる」という感覚が回復する。「全体は分からなくても、この一歩はコントロールできる」。この感覚が、行動を可能にした。モニタリング基盤が完成して動いており、アラートが鳴り、自動復旧が動く。気づけば「システムの可用性向上」という大きなタスクができていた。マルチタスクの代償企画書を書いていて集中しており、いい感じで進んでいるときSlackの通知が鳴る。「ちょっとだけ」と思って見るとスレッドを読んで返信し、他のメッセージも気になっていくつか読んでしまう。資料に戻ると何を書いていたんだっけという状態になる。さっきまで頭の中にあった構成が消えて、次の章のアイデアも論理の流れもぼやけている。もう一度書きかけの文章を読み直して思い出そうとするが集中力を取り戻すのに時間がかかる。これを一日に何回も繰り返している。資料を作ってはSlackを見て戻って集中し直し、メールが来たら見てまた戻って集中し直し、チャットの通知が来たら見て戻って集中し直す。切り替えるたびに頭がリセットされ、切り替えるたびに最初から組み立て直す必要がある。私たちは「マルチタスク」と呼ぶが、実際にはマルチタスクなんてできていない。ただ高速に切り替えているだけで、脳は1つのことしかできないため、切り替えるたびに前の文脈を捨てて新しい文脈を読み込み直す。そしてその読み込みには膨大なコストがかかる。一度Slackを見ただけで集中するまでに何分もかかり、メールを見ただけで集中するまでに何分もかかる。私は一日に何回切り替えているだろうか。10回か、20回か、50回か。一日の大半を「集中し直す」ことに使っており、実際の作業ではなく集中状態へ戻ることに時間を費やしている。そして切り替えている最中はどちらにも集中できていない。資料のことを考えながらSlackを見て、Slackのことを考えながら資料を作る。どちらも中途半端だ。全部やろうとしている時、私は何も完了させていなかった。それでも生産的だと感じていたのは忙しさと生産性を混同していたからだ。画面は動いていて指も動いていて頭も回っているが、何も完了していない。そしてこの「何も完了していない」という事実が、じわじわと自己肯定感を蝕んでいった。「今日もできなかった」「自分は無能だ」「きっと才能がないんだ」という声が繰り返され、朝起きるのが辛くなり、デスクに座るのも億劫になった。なぜならまた何も完了しない一日が始まると分かっていたからだ。停滞の構造停滞の構造は、こうだった。停滞を恐れる → 全部やろうとする → 選択できない → 集中できない → 全てが中途半端 → 何も完了しない → 自己肯定感が下がる → さらに停滞する。この悪循環に、私は何ヶ月も、何年も、捕まっていた。戦略のない戦い戦略の本質は、何をやらないかを選択することだ。戦略とは、ある状況に作用する要因を診断・分析し、どう取り組むかに関する論理的な主張でなければならない。戦略の本質は、何をやらないかを選択することだ。マルチタスクというのは、戦略のない戦いだ。良い戦略は、重要な1つの結果を出すための的を絞った方針を示し、リソースを投入し、行動を組織するものだ。一日一日にも戦略が必要だ。でも私は、戦略を持っていなかった。「今日はこれをやる」という方針がなかった。「これはやらない」という選択もなかった。だから、全部やろうとした。そして、全てが中途半端になった。ここに逆説がある。私は、停滞したくなかった。だから、全部やろうとした。「これを放っておいたら、停滞する」「あれをやらなかったら、遅れる」。停滞への恐怖が、全部やろうとさせていた。停滞への恐怖が、選択を妨げていた。でも、全部やろうとした結果、何も完了しなかった。何も完了しないということは、停滞しているということだ。停滞を恐れるあまりに、停滞していた。でも、変わった。選択することにしたのだ。1つだけ選び、他は後回しにして、今はこれだけに集中する。何かを選ぶということは他を選ばないということであり、何かを選ばないということはそれを放っておくということだ。「放っておいたら停滞するんじゃないか」という恐怖と戦いながら、それでも選んだ。朝デスクに座って今日やるべきことを紙に書き出すと十個以上あるが、一つだけ選ぶ。新しい機能のコードを書くことを選び、他を全て後回しにする。Slackやメールやチャットは後で。今はこれだけ。1つを選ぶということは、自分を信じるということだった。「この1つを、自分は完了させられる」と信じること。「1つでは足りない」という不安を手放し、「1つを確実にやり遂げる自分の力」を信じること。その信頼が、選択を可能にする。Slackを閉じ、メールを閉じ、チャットの通知を切り、SNSのタブを閉じてスマートフォンを別の部屋に置く。必要なものだけを開く。エディタとドキュメント、それだけ。この瞬間、軽くなる。「全部やらなきゃ」というプレッシャーが消え、「今はこれだけでいい」という許可が自分を解放する。集中するとコードが書けるようになり、思考がクリアになり、時間を忘れる。集中した時間は一日中あちこち飛び回るより遥かに多くの成果を生み、そして何より疲れていない。1つ完了させるときの感覚。「今日はこれができた」。この言葉が翌朝を支え、自分を好きになる。逆に何も完了しないと自分を嫌いになる。「今日もできなかった」と自分が情けなくなり、価値のない人間に思える。でも1つ完了させると違う。「自分にはできる」「明日もやれる」と思えて自分を認められる。選択することが前に進むことだった。全部やろうとすることが停滞することだった。小さく始める「今日から1つずつやる」と決意した。しかし初日、挫折した。午前中は良く1つのタスクに集中できたが、午後にSlackの通知が気になって開いてしまい、そのまま1時間あちこちのスレッドを読んでいた。「やっぱり自分には無理だ」と思った。完璧を求めすぎていた。一日中全てのタスクで完璧に1つずつやるというのは理想だが現実的ではない。だから小さく始めることにした。「朝の最初の2ポモドーロだけ、一つのタスクに集中する。それだけ」。これならできた。2ポモドーロ（50分）だけなら通知を切ることも怖くなく、1つのことに向き合える。そして不思議なことに、この2ポモドーロの習慣ができると他の時間も変わり始めた。「どうせ朝2ポモドーロ集中するなら、もう2ポモドーロもやってみよう」という気持ちになる。小さな変化が次の変化を呼ぶ。一週間後には朝の4ポモドーロは集中できるようになり、二週間後には午後も2ポモドーロ集中できるようになり、一ヶ月後には一日のうち8ポモドーロはしっかり集中できるようになっていた。完璧ではない。今でも午後は時々脱線するし、疲れている日は集中できない日もある。それでいい。完璧を目指して何もしないより、不完全でも小さく始める方がずっと前に進める。これは掃除の時と同じだった。掃除を始めた時も「毎日完璧に掃除をする」と決めて三日で挫折したが、「朝起きたらベッドを整える。それだけ」と小さく始めたら続いた。変化は小さく、ゆっくりと。計測するポモドーロ・テクニックを使っている。25分のタイマーをセットして1つのタスクだけに集中する。最初の衝撃は大きかった。「これは30分で終わる」と思っていたタスクが実際には3ポモドーロ（75分）かかり、「ちょっとだけ」と思って見たSlackが30分経っていた。自分の時間感覚はずれていた。人間は系統的に自分がどれだけ時間を使うかを過小評価する。心理学者はこれを「計画錯誤」と呼ぶ。でも計測を続けると変わり始めた。タイマーをセットすると制約があるから集中し、1日の終わりに振り返ると何に時間を使ったかが明確になる。数字は嘘をつかない。現実を直視しないと改善できない。計測は自分に嘘をつけなくする装置だった。完了させたタスクを記録し、ポモドーロを積み重ねて完了させる。夜、振り返る。「今日はこれができた」。この充実感が翌朝を支える。できなかったことが、できるようになる話プログラミング言語を初めて学んだ時のことを覚えているだろうか。最初は文法や構文が全く分からなかった。ifとforの違いすら理解できず、エラーメッセージの意味も分からず、ただ赤い文字が表示されるだけだった。しかしある瞬間書けるようになった。変数の宣言、条件分岐、ループ、関数。最初は1行も書けなかったが今は様々な表現を組み合わせて自分の意図をコードで表現できる。その瞬間まで「プログラムを書く」という行為は不可能だったが、その瞬間から可能になった。できないとできるの間に明確な境界線があった。成長は滑らかな曲線じゃない。階段だ。できない状態が続いて、続いて、続いて、そして突然できるようになる。プログラミングもそうだった。最初、再帰が全く理解できず、何度も同じ説明を読んで何度も同じコードを書いたがわからなかった。でもある日わかった。その瞬間まで「再帰」は呪文だったが、その瞬間から道具になった。この経験が教えてくれること。それは「今できない」は「今後もできない」じゃないということだ。小さな成功が、信じる力をくれる心理学者バンデューラは「自己効力感」という概念を提唱した。「自分にはできる」という信念。この信念はどこから来るのか。彼が挙げた4つの源泉の中で最も強力なのは実際に成功した経験だった。他人の成功を見たり励まされたりしてもそれだけでは弱い。自分の手で実際に達成すること。これが「できる」という確信を作る。だから小さなタスクの完了が重要だった。大きなタスクは完了するまで何週間もかかり、その間「できた」という経験がないため「自分にはできるんだ」という確信が育たない。でも小さなタスクなら毎日完了でき、毎日「できた」という経験を積める。「できた」が「できる」を育てる。1つ完了させると「次もできる」と思えるようになり、また1つ完了させると「やっぱりできる」と確信に変わり、さらにもう1つ完了させると「自分には力がある」と信じ始める。この積み重ねが大きなタスクに向かう勇気をくれる。シングルタスクは、自分を信じる力を取り戻す行為だった。全部やろうとしていた時、私は自分を信じていなかった。「1つだけでは不十分だ」と思っていた。でも1つずつ完了させることで、「自分には完了させる力がある」と信じられるようになった。その信頼が、次の1つを選ぶ勇気をくれる。自分を信じられるから、1つを選べる。1つを完了させるから、さらに自分を信じられる。この循環が、停滞を終わらせる。停滞期の意味でも、いつも右肩上がりじゃない。時々停滞し、何週間も同じレベルに留まっている感じがして成長している気がしない。成長が止まったように見える「踊り場」のような期間。最初、これが辛かった。「もう成長が止まった」「自分の限界に達した」と思った。でも違った。停滞期は次の飛躍の準備期間だった。表面上は変化がないが内部では微細な変化が積み重なっており、それらが臨界点に達した時、突然質的な変化が起きる。水が氷になる時と同じだ。温度が下がっていき、99度、98度、97度と何も変わらずずっと水のままだが、0度の瞬間氷になる。小さく分割することの意味はここでも現れた。停滞期でも小さなタスクは完了し続け、「前に進んでいる」という実感を保てる。「今日もこれができた」という事実が停滞期を乗り越えさせてくれる。千里の道も老子は言った。「千里の道も一歩から」。この言葉を昔は単なる励ましだと思っていて「遠くても一歩ずつ進めば着く」という意味だと考えていた。でも違った。もっと深い意味があった。千里の道は一歩の集積以外の何物でもない。「千里先」という抽象的な目標はそれ自体では実在しない。存在するのは今この瞬間の一歩だけで、そして次の瞬間の一歩があり、その連なりが結果として千里になる。未来は抽象で計画も抽象だ。でも行動は常に具体的で常に今だ。だから分割の本質は抽象的な目標を具体的な行動に翻訳することだった。「良いエンジニアになる」という目標は抽象的すぎて実行できないが、「今日この記事を読む」は具体的で実行できる。抽象から具体へ、未来から現在へ。この翻訳が行動を可能にする。プロセスとしての成長ずっと「成長」を到達すべき地点だと思っていて「ここまで行けば成長した」という明確なゴールがあると考えていた。でも違った。成長は地点じゃなくプロセスだ。西洋哲学に「プロセス哲学」というものがある。世界を静的な「存在」ではなく動的な「生成」のプロセスとして捉える考え方だ。この視点から見るとすべてが変わる。目標は達成すべき状態じゃない。向かっていくプロセスだ。「良いエンジニア」という状態は実は存在せず、存在するのは「良いエンジニアであり続けようとする営み」だけ。一度到達したら終わりではなく、常に変化し、常に学び、常に適応し続けることが「良いエンジニアである」ということだ。成長は到達すべき地点じゃない。継続する運動そのものだ。「成長した」という完了形は実は幻想だった。存在するのは「成長している」という現在進行形だけ。山の頂上に着いたら成長は終わるのか。違う。頂上に着いたらまた次の山が見えてその山に向かって歩き始める。それが成長だ。能力は所有するものじゃない。発揮し続ける動的平衡だ。「プログラミングができる」という能力。それは一度獲得したら永遠に持ち続けられる静的な所有物じゃない。使い続けないと鈍り、学び続けないと時代に取り残される。常に発揮し、常に磨き、常に更新し続ける必要がある。能力は動詞であり名詞ではない。分割という行為はまさに静的な目標を動的なプロセスに変換する操作だった。「優れたプログラマーになる」という静的な目標は動けず手をつけられない。でも「今日このコードを書く」に変換すると動き始め実行できる。そしてその1つの行動が次の行動を生み、次の行動がまた次の行動を生む。気づけば「優れたプログラマーであり続ける」というプロセスの中にいる。ゴールは到達する場所じゃない。歩き続けること自体がゴールだった。結果じゃなくプロセスを信じる。「今日これができた」という小さな前進、それ自体が価値だった。それが積み重なった先に何があるかはわからないが、歩き続ければ確実に前に進んでいる。「なる」んじゃない。「であり続ける」んだ。自由のパラドックス分割することは制約を増やすことで、「今日はこれだけやる」と決めることは他のことをやらないと決めることだ。選択肢を減らすこと、それは不自由に思える。でも逆だった。制約が自由を生む。「何をやってもいい」という無制限の自由はかえって身動きを取れなくする。選択肢が多すぎて選べず、どれを選んでも「他の方が良かったんじゃないか」という後悔が付きまとう。でも「今日はこれをやる」と決めるとその瞬間、自由になる。もう迷わなくてよく、他のことは気にしなくてよく、今この1つだけに集中していい。境界があるからこそその中で自由に動ける。これは詩の形式と似ている。俳句は五七五という厳格な制約があるがその制約の中で無限の表現が生まれ、制約がないとかえって何も書けない。分割で得られる自由は3つある。認知的自由では情報量が減るから深く考えられ、全部を同時に考える必要がないから1つのことを徹底的に考えられる。時間的自由では全体が見えるから本当に重要なことに時間を使え、「これは後回しでいい」と判断できる。心理的自由では不確実性が減るから不安から解放され、「これだけやればいい」という明確さが心を軽くする。そして、もう1つの自由がある。自分を信じる自由だ。全部をやろうとしている時、私は自分を信じていなかった。「1つだけでは足りない」という不安に支配されていた。でも1つを選び、その1つに集中すると決めた時、「この1つを、自分は完了させられる」と信じる自由を手に入れた。制約が、自分を信じる余裕を生んだ。誠実さとしての計測最後にもう1つ重要なことへ気づいた。分割すること、計測することは自分へ正直になることだった。「今日も頑張った」と思いたいが実際には大半の時間をSlackやSNSで無駄にしていた。計測はこの自己欺瞞を許さず、数字は嘘をつかない。最初これは辛く、現実を突きつけられて「自分は思っていたほど生産的じゃない」という事実を認めなきゃいけなかった。でもこの誠実さこそが改善の出発点だった。現実から目を背けていては何も変わらない。理想を語るのは簡単で「もっと頑張る」「もっと集中する」と言えるが、それは具体性を欠いた空虚な言葉だ。大きなビジョンを持つことは重要だが、そのビジョンを実行可能なステップに翻訳すること、この地道で困難な作業が理想と現実を架橋する。分割は誠実さの実践だった。続けられることが、才能を超える才能のある人をたくさん見てきた。理解が速く、センスがあり、飲み込みが早い人たちを。でもその多くは消えていった。なぜか。続けられなかったから。どんなに才能があっても続けられなければ意味がなく、どんなに理解が速くても完了させられなければ意味がない。結局長く続けた人が最も遠くまで行く。そして長く続けるために必要なのは派手なスキルでも高度な知識でもない。選択する勇気と一つに集中する習慣だ。毎日1つを選び、毎日1つを完了させる。それを一週間続け、一ヶ月続け、三ヶ月続け、一年続ける。気づけば驚くほど多くのことを成し遂げており、そして何より続いている。才能は一瞬の煌めきだが、習慣は永続する炎だ。おわりに何ヶ月も、何年も、私は停滞していた。その原因が皮肉なことに停滞への恐怖そのものだった。停滞したくなかったから全部やろうとしたが、全部やろうとした結果、何も完了しなかった。停滞を恐れるあまりに停滞していた。そして今、分かる。全部やろうとしていたのは、自分を信じていなかったからだった。「1つだけでは不十分だ」「1つだけでは成長できない」。そう思っていた。1つのことを完了させる自分の力を、信じられなかった。選択することは何かを捨てることだと思っていた。でも違った。選択することが前に進むことだった。全部やろうとすることが停滞することだった。そして、選択することは自分を信じることだった。1つだけ選ぶ。他は後で。今はこれだけ。その瞬間「全部やらなきゃ」というプレッシャーから解放される。そして不思議なことに1つずつやると結果的により多くのことが完了する。シングルタスクは、自分を信じる行為だ。「この1つを、自分は完了させられる」と信じて、他を手放す勇気。その信頼が、停滞を終わらせる。1つを完了させるたびに、「自分にはできる」という確信が育つ。その確信が、次の1つを選ぶ勇気をくれる。結局長く続けた人が最も遠くまで行く。そして長く続けるために必要なのは派手なスキルでも高度な知識でもない。選択する勇気と一つに集中する習慣だ。そして何より、自分を信じる力だ。「どうせ自分なんか」という声が聞こえたとき、「全部やらなきゃ」と焦ったとき、「今日もできなかった」と思ったとき。まず、1つだけ選べ。他は後で。今はこれだけ。その1つだけに向き合い、完了させる。それだけでいい。完璧を目指す必要はない。ただ1つを選んで、1つずつやり続けること。その小さな選択と小さな完了の積み重ねが、停滞を終わらせる。そして、自分を信じる力を取り戻す。おい、一つずつやれ。それは命令ではなく、自分自身への、静かな呼びかけだ。そして、自分を信じるための、最初の一歩だ。一点集中術――限られた時間で次々とやりたいことを実現できる作者:デボラ・ザックダイヤモンド社Amazon戦略の要諦 (日本経済新聞出版)作者:リチャード・Ｐ・ルメルト日経BPAmazon忙しいのに退化する人たち　やってはいけない働き方作者:デニス・ノルマーク,アナス・フォウ・イェンスンサンマーク出版Amazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2025年11月版読む予定本紹介]]></title>
            <link>https://zenn.dev/akasan/articles/870a86bf7189f1</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/870a86bf7189f1</guid>
            <pubDate>Tue, 04 Nov 2025 13:57:39 GMT</pubDate>
            <content:encoded><![CDATA[今年もついに11月に突入しましたので、今月読みたい本をまとめてみます。今月はバタバタしていて少なめです。 機械学習 解釈可能なAI 機械学習モデルの解釈手法を実践的に理解する機械学習モデルはホワイトボックスなものからブラックボックスなものまで様々なモデルがあります。例えばみなさんが普段利用しているような生成AIや画像認識モデルなどのディープラーニングモデルはブラックボックスモデルであり、モデルが生成した結果がなぜそのような結果になったかを説明することは重要なことですがその解析は大変な内容となります。そのような内容を広く取り扱っている書籍であり、解釈可能なAIを実装するための基礎...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[garakを用いてGeminiの脆弱性スキャンをしてみた]]></title>
            <link>https://zenn.dev/akasan/articles/f7adda4b70a138</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/f7adda4b70a138</guid>
            <pubDate>Mon, 03 Nov 2025 08:31:26 GMT</pubDate>
            <content:encoded><![CDATA[今回はgarakを用いてGeminiの脆弱性スキャンをしてみました。garakは様々なLLMに対する脆弱性スキャンのための機能を提供していますが、執筆時点ではまだGeminiの対応はできていないようでした。しかし、garakにはREST API形式でLLMと接続してスキャンをする機能があり、今回はそれを利用してGeminiのスキャンをしてみました。garakについては過去に紹介していますので、合わせて以下の記事もご覧ください。https://zenn.dev/akasan/articles/34756e48c4f870なお、今回の実装をするにあたり、garakの公式ドキュメントと合わ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Redux基礎: APIをfetchして非同期でデータを表示する処理]]></title>
            <link>https://zenn.dev/takehiro1111/articles/react_redux_async_thunk</link>
            <guid isPermaLink="false">https://zenn.dev/takehiro1111/articles/react_redux_async_thunk</guid>
            <pubDate>Mon, 03 Nov 2025 03:43:35 GMT</pubDate>
            <content:encoded><![CDATA[1.記事を書いた背景初めてReduxを触っているのですが、独特で慣れが必要だなと感じたのでコンポーネントを整理するにあたり、形として残しておきたかったためです。Reduxに不慣れな方のご参考にもなれば幸いです。 2.書くこと各コンポーネントの説明APIをfetchしてデータ表示する処理のコード 3.Reduxとは？Reduxは、アプリケーション全体の状態を管理および更新するためのパターンとライブラリです。UIは「アクション」と呼ばれるイベントをトリガーして何が起こったかを伝え、それに応じて「リデューサー」と呼ばれる別の更新ロジックが状態を更新します。Redu...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[おい、部屋を掃除しろ]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/11/03/020316</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/11/03/020316</guid>
            <pubDate>Sun, 02 Nov 2025 17:03:16 GMT</pubDate>
            <content:encoded><![CDATA[はじめにどれだけ技術を学んでも、どれだけ正しいプロセスを知っていても、燃え尽きてしまったら意味がない。才能ある若者たちが最初は誰よりも速く理解して、誰よりも多くのコードを書いていたのに、数ヶ月後には姿を見せなくなる。「疲れた」と言って離れていく。逆に、最初は遅くても数年経った今も黙々と学び続けている人たちがいる。彼らに共通しているのは、自分を大切に扱う習慣を持っていることだった。ちゃんと眠る。ちゃんと食べる。ちゃんと休む。そしてちゃんと掃除する。その中でも最も基本的な実践が、掃除だ。在宅勤務を始めて六年目のある朝、ふと自分の部屋を見回した。今、部屋は比較的綺麗だ。床に物は落ちていない。デスクの上も整理されている。技術書も本棚に並んでいる。窓を開けて空気を入れ替える習慣もついた。カーテンも開いていて、部屋の中は明るい。30歳のエンジニア、独身。在宅勤務という働き方は自由をくれたはずなのに、気づけば自分は4畳半の部屋の中で完結した生活を送っている。仕事もする。プログラミングもする。読書もする。ブログも書く。趣味もある。孤独は嫌いではない。むしろ好きだ。一人で考える時間、一人でコードを書く時間、一人で本を読む時間。誰にも邪魔されず、自分のペースで物事に向き合える時間。これは孤独であって、寂しさではない。寂しいと孤独は別物だ。孤独は選べるが、寂しさは選べない。でも私生活がぐちゃぐちゃになってしまうと、自分のプライベートも引きずられて悪くなる。掃除をしなくなる。自炊をしなくなる。身だしなみが雑になる。運動をしなくなる。風呂に入らなくなる。これらが崩れ始めると、部屋は散らかり、仕事も集中できなくなり、趣味も楽しめなくなり、選んだはずの孤独が、望まない寂しさに変わっていく。掃除は、精神の指標になる。部屋を見れば、今の自分の精神状態が分かる。乱れている時は心も乱れている。整っている時は心も整っている。結局、最も重要なのは燃え尽きずに続けることで、そのために必要なのは自分を大切に扱うことで、その最も基本的な実践が掃除なのではないか。この記事は、そんな仮説を自分自身で検証するために書いている。掃除とは何か。なぜ自分は掃除ができなくなるのか。そして掃除することで何が変わるのか。表面的な整理整頓の話ではなく、もっと根本的な、自分をどう扱うかという話だ。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。掃除できない理由は全て言い訳だ「忙しいから掃除できない」。でも本当にそうか？毎日Twitterを見て、YouTubeのショート動画を延々と見ている。気づけば一時間、二時間が過ぎている。つまり、時間がないのではない。掃除を優先していないだけだ。「疲れているから」という言い訳もある。でも実は、散らかった部屋で過ごしていることが疲れの原因かもしれない。視界の隅に常にゴミや散らかったものが入ってきて、それが無意識のストレスになっている。朝起きたときにすでに憂鬱で、仕事を始める前からエネルギーが削がれている。だから疲れる。そして疲れているから掃除しない。この悪循環。「どうせすぐ散らかるから」という諦めもある。以前掃除したけど三日後には元通りだった。でもなぜか。綺麗にした後、何も仕組みを変えていなかったからだ。服を脱いだら床に置く習慣、ゴミが出たらデスクに置く習慣、本を読んだら床に積む習慣。掃除をしたというより、一時的に物を移動させただけだった。これらの言い訳を並べてみて気づく。どれも本質的な理由ではない。本当の理由はもっと深いところにある。「どうせ自分なんか」という、言葉にならない諦めが。部屋を整えることが心を整えるよく「部屋の乱れは心の乱れ」と言われる。でもこの言葉は因果関係が逆だ。「部屋の乱れが心を乱す」のだ。そしてもっと正確に言えば「部屋を整えることが心を整える」。心という曖昧なものを直接コントロールすることは難しい。でも部屋という物理的な空間は、手を動かせば変えられる。服をハンガーにかける。ゴミを捨てる。床を拭く。これらは全て、具体的で、実行可能で、結果が目に見える行動だ。そしてこれらの行動が、不思議なことに心に作用する。綺麗な部屋で目覚めると、一日の始まりが違う。整理されたデスクで仕事をすると、思考がクリアになる。物が少ない空間にいると、頭の中も軽くなる。部屋を整えることは、心を整えるための、最も具体的で確実な方法なのだ。掃除は自分への態度を訓練する修行だ掃除は単に「清潔にする」ための行動だと思われがちだ。でも実は、もっと深い意味を持っている。自分をどう扱うかを、身体に教えている訓練なのだ。掃除とは、「自分の空間を整える力が自分にある」と確認することだ。散らかった部屋を見て「どうせ自分には無理だ」と諦めるのではなく、一つずつ片付けていく。床に落ちている服を拾う。ゴミを捨てる。デスクを拭く。この行為を通じて「自分には変える力がある」と身体で理解する。これは掃除だけではない。自炊なら「自分のために手を動かす価値がある」と身体が覚えること。身だしなみを整えるのは「私は丁寧に扱っていい存在だ」と身体に教えること。運動することは「自分の身体に投資する価値がある」と確認すること。風呂に入ることは「私は清潔でいていい存在だ」と身体に教えること。しかし、その中でも掃除は最も基本的で、最も効果が目に見えやすい実践だ。「どうせ自分なんか」と思って放っておく時間が続くと、それらの行為がどうしても億劫に感じて、身体は「私は放っておかれて当然なんだ」と学んでしまう。逆に言えば、少しずつでも、適当でも、掃除をしていくことで、「自分は守られていい」「手をかけられていい」と身体が再び信じ始める。これは精神論ではない。実際に起きることだ。部屋を掃除した日の夜、なぜか少しだけ自己肯定感が上がる。掃除は、自分への態度を訓練する修行なのだ。放置のサイクルと手入れのサイクル放置のサイクル朝起きる。部屋が汚い。気分が重い。でも掃除する気力がない。「今日は忙しいから」と自分に言い訳をする。朝食も作らない。シャワーも浴びない。適当な服を着る。仕事を始める。集中できない。視界の隅にゴミが見える。気が散る。効率が落ちる。疲れる。夜になる。もっと疲れている。掃除なんてできない。自炊もめんどくさい。風呂に入るのもめんどくさい。運動なんてもってのほか。「明日やろう」と思う。眠る。次の日も同じ。部屋は昨日より汚い。服がもう一枚増えている。ゴミがもう一つ増えている。気分はもっと重い。でも何もする気力はもっとない。そしてまた「明日やろう」と思う。一週間後、すべてが荒れ果てている。部屋は散らかり、床はほとんど見えない。デスクは物で埋まっている。空気は淀んでいる。そして自分の気持ちも荒れ果てている。「もうどこから手をつけていいか分からない」という諦めが支配している。毎日、放置という行動を通じて、「お前は放っておかれて当然だ」というメッセージを自分自身に送り続けている。手入れのサイクル朝起きる。部屋が綺麗。気持ちがいい。窓を開ける。空気を入れ替える。ベッドを整える。たった一分の作業だが、これだけで一日の始まりが違う。シャワーを浴びる。髪を整える。清潔な服を着る。朝食を作る。簡単なものでいい。温かいご飯。身体が目覚める。仕事を始める。デスクが綺麗だから集中できる。必要なものがすぐ見つかる。思考がクリア。コードがスムーズに書ける。効率が上がる。気持ちがいい。昼休み、食器をすぐ洗う。軽く散歩する。身体を動かす。夜、仕事を終える。運動する日もある。しない日も軽くストレッチする。夕食を作る。自分のために作った温かいご飯。シャワーを浴びる。床に落ちているものを片付ける。ゴミを捨てる。読んだ本を本棚に戻す。合計十分。でもこの十分が、明日の自分を助ける。身体は学習する。「私は手をかけられる存在だ」と。「私の空間は整っていていい」と。「私は価値がある」と。行動が、その人の存在の意味を決める。言葉ではなく、行動が。毎日の小さな選択が、自分をどう扱うかを決めている。規律という美学部屋が散らかっている時の自分は、不思議なことに、あらゆる面が乱れている。時間管理も散らかる。締切ギリギリになって慌てる。生活のあらゆる面は繋がっていて、一つの領域での乱れは、他の領域にも波及する。逆に、部屋を整えている時期の自分は、あらゆる面が整っている。朝、決まった時間に起きられる。約束を守れる。締切を守れる。自分との約束も守れる。そしてこの規律が、自分という存在に秩序をもたらす。美しさとは、日々の規律ある行動から生まれる副産物なのではないか。一つ一つの動作に美を宿すこと。服を畳むときに丁寧に畳む。食器を洗うときに丁寧に洗う。掃除をするときに隅々まで拭く。これらの「めんどくさい」行為が、実は自分を美しくしている。誰も見ていない。在宅勤務だから誰にも会わない。だから適当でいい。そう思って過ごしていると、その「適当さ」が身体に染み込んでいく。でも逆に、誰も見ていなくても、自分のために丁寧に生きる。その選択が、自分を美しくする。掃除は「修行」として捉えるべき実践なのだ。小さく始めるという勇気ある日、決意した。「今日から毎日掃除をする」と。でも夜には忘れていた。三日目には諦めていた。「やっぱり自分には無理だ」と。問題は、始め方が大きすぎたことだ。「毎日掃除をする」というのは、実は途方もなく大きな変化だ。でもある時、試しに小さく始めてみた。「朝起きたら、ベッドを整える。それだけ」。これなら一分もかからない。簡単すぎる。でもこれを続けた。一週間、二週間、一ヶ月。気づけば習慣になっていた。そして不思議なことに、ベッドを整える習慣ができると、他のことも少しずつやりたくなってきた。「どうせベッドを整えるなら、カーテンも開けよう」「どうせカーテンを開けるなら、窓も開けよう」「どうせ窓を開けるなら、ゴミも捨てよう」。小さな一歩が、次の一歩を呼ぶ。完璧を求めて何もしないより、不完全でも小さく始める方が、ずっと前に進める。一日五分の掃除と、週に一回の大掃除、どちらが効果的か。前者だ。なぜなら習慣になるから。小さく始めることは、実は最も大きな勇気を必要とする。なぜなら、小さすぎて効果がないように感じるから。「たったこれだけで意味があるのか」という疑念と戦わなければならない。でも意味はある。確実にある。身体は小さな変化を記憶する。そして小さな変化の積み重ねが、大きな変化になる。おわりにこの記事を書きながら、自分の部屋を見回している。今、部屋は比較的綺麗だ。床に物はほとんど落ちていない。デスクの上も整理されている。窓を開けて空気を入れ替える習慣もついた。これらの小さな習慣が、気持ちを支えている。仕事にも集中できる。コードを書くのも、ブログを書くのも、本を読むのも楽しい。掃除は、精神の指標になる。今、部屋が比較的綺麗なのは、今の精神状態が比較的安定しているということだ。でも油断すると、すぐに乱れる。だから毎日少しずつ手をかけ続ける。才能があっても燃え尽きたら意味がない。理解が速くても続かなければ意味がない。結局、長く続けた人が、最も遠くまで行く。そして長く続けるために必要なのは、派手なスキルでも高度な知識でもなく、自分を丁寧に扱う日々の習慣だ。掃除は単なる家事ではない。自分への態度を訓練する修行であり、自分という存在をどう扱うかを身体に教える実践だ。そして何より、燃え尽きないための、最も基本的な自己防衛の手段なのだ。在宅勤務で過ごす30歳の自分にとって、掃除は生き延びるための技術になった。孤独は好きだ。一人で考える時間、一人でコードを書く時間、一人で本を読む時間。誰にも邪魔されない自由。でもその孤独を愛するためには、まず自分の空間を整える必要があった。部屋を整えることで、心を整える。空間に秩序をもたらすことで、人生に秩序をもたらす。そして集中して仕事ができる。コードが書ける。ブログが書ける。本が読める。選んだ孤独を、寂しさに侵食されずに生きられる。自分を大切にするということ。それは掃除をすること、自炊をすること、身だしなみを整えること、運動をすること、風呂に入ること。これらすべてが大切だ。でもその第一歩が、掃除なのだ。「どうせ自分なんか」という声が聞こえたら、まず床に落ちている服を一枚拾う。ゴミを一つ捨てる。デスクを一度拭く。たったそれだけでいい。その小さな行動が、「自分は手をかけられていい」というメッセージを、自分自身に送る。そして身体がそれを覚える。少しずつ、少しずつ、「自分は大切にされていい存在だ」と信じ始める。完璧を目指す必要はない。毎日完璧に掃除する必要もない。ただ、少しずつでも、適当でも、自分に手をかけ続けること。それが掃除の本質であり、同時に自分を整えることの本質であり、そして燃え尽きずに続けるための、最も確実な方法なのだ。技術は大切だ。知識も大切だ。仕事も大切だ。プログラミングも大切だ。読書も大切だ。ブログも大切だ。趣味も大切だ。孤独を愛することも大切だ。でも最も大切なのは、自分を大切にすることだ。そしてその第一歩が、自分の部屋を掃除することなのかもしれない。おい、部屋を掃除しろ。それは命令ではなく、自分自身への、静かな呼びかけだ。長く続けるために。燃え尽きないために。そして、自分を大切にするために。利他・ケア・傷の倫理学作者:近内悠太晶文社Amazonカウンセリングとは何か　変化するということ (講談社現代新書)作者:東畑開人講談社Amazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[NVIDIA Brev上でGPUインスタンスを立ち上げる方法]]></title>
            <link>https://zenn.dev/akasan/articles/686e4b3ef0b8ff</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/686e4b3ef0b8ff</guid>
            <pubDate>Sun, 02 Nov 2025 07:52:43 GMT</pubDate>
            <content:encoded><![CDATA[今回はNVIDIA Brev（以下、Brev）を利用してGPUインスタンスを立ち上げる方法をご紹介します。ディープラーニングモデルの開発をはじめ、様々な用途でGPUインスタンスを利用したい場合があるかと思います。そのような場合に取りうる選択肢の一つとして、Brevを利用することができ、その利用方法を紹介できればと思います。 NVIDIA Brevとは？NVIDIA Brevは、一般的なクラウドプラットフォーム上のNVIDIA GPUインスタンスへの効率的なアクセスをはじめとして自動環境セットアップ、柔軟な展開オプションを提供し、開発者がすぐに実験を開始できるようにしてくれるサービス...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[garakでLLMの脆弱性スキャンをしてみた]]></title>
            <link>https://zenn.dev/akasan/articles/34756e48c4f870</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/34756e48c4f870</guid>
            <pubDate>Sat, 01 Nov 2025 07:54:57 GMT</pubDate>
            <content:encoded><![CDATA[今回はNVIDIAがOSSとして提供しているgarakを用いて、LLMの脆弱性スキャンを試してみたので共有します。 garakとは？garakは生成AIに対するレッドチーミングおよびアセスメントのためのツールです。garakを利用すると、LLMが望ましくない方法で失敗させられるかどうかを検証し、ハルシネーションを初めジェイルブレイクなど多くの脆弱性を探知することができます。garakのドキュメントを確認すると、以下の特徴があるとのことです。LLMセキュリティへのフォーカス：主にLLMセキュリティに焦点を当ててており、他のツールが一般的な機械学習セキュリティやアプリセキュリティ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[言葉にしない限り、『なんか』は永遠に巨大な壁であり続ける]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/11/01/120027</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/11/01/120027</guid>
            <pubDate>Sat, 01 Nov 2025 03:00:27 GMT</pubDate>
            <content:encoded><![CDATA[はじめにワークショップが始まる三十分前、会場の隅で、一人の若者がノートPCの画面を凝視していた。ブラウザには二十を超えるタブが開かれている。Dockerの公式ドキュメント、Kubernetesの公式リファレンス、Qiita、Zenn、個人ブログ。静かな会場に響くのは、マウスホイールを回す音だけで、彼は次から次へとタブを切り替えながら、何かを探すように、あるいは何かから逃げるように、ドキュメントを読み続けていた。読んでいた、という言葉はきっと正確ではなくて、目で文字を追っているだけで、その言葉が本当に頭の中に入っているかどうかは、おそらく彼自身にも分からなかったのだろうし、分からないことに気づかないふりをしていたのかもしれないし、あるいは気づいていたけれど認めたくなかったのかもしれない。「準備しておかないと」ぽつりと呟いた声は、誰に向けられたものでもなかった。会場には他にも何人か早めに来ている参加者がいたけれど、彼らに向けた言葉でもなく、講師である僕に向けた言葉でもなく、けれど僕には分かった、あの言葉は自分自身への言い訳で、読み続けている限り「まだ始めていない」という事実から目を逸らせて、手元にあるyamlファイルを開くことも、Dockerfileを書き始めることもなく、ただスクロールを繰り返していれば、準備という名の猶予期間はどこまでも続いていくような気がして、その錯覚こそが彼を動けなくしているのだと、その姿を見ながら僕は思った。彼は、昔の僕だ。気づけば開始時刻になっていた。けれど彼の画面に立ち上がったコンテナは一つもなくて、代わりにあったのは無数に開かれたタブと、そして不思議なことに「今日は勉強した」という、根拠はどこにもないのにどこか心地よい、温かくて柔らかい達成感だけだった。手は動かしていないのに、頭は働かせた気がして、何も作っていないのに、何かを学んだ気がして、この感覚はとても甘くて危険で、僕も何度もこの甘い罠に捕まってきたから分かる。僕も石橋を叩いて渡るタイプで、新しい技術を学ぶときはまず本を買って安心する。「準備してから」「もう少し理解してから」「完璧になってから」、その言葉は、とても合理的に聞こえる、誰も反論できない、自分自身も反論できない、だから安心してその言葉に逃げ込むことができる。でも、ある時気づいてしまった。「まだ準備が足りない」と思って読み続けるうちに、何時間も、何日も経っていて、僕は実際には何一つ手を動かしていなかったことに。本当は、もっと早く気づいていたのかもしれない。けれど気づかないふりをして、気づきたくなくて、「準備」という名の停滞を「努力」だと自分に言い聞かせていた。「明日からやろう」という言葉の背後で何が起きているのか、本人は意外と気づいていない。いや、もしかしたら気づいているのかもしれないけれど、気づかないふりをしているのかもしれないし、気づいていることに気づかないふりをしているのかもしれない。このポストは動けない人の構造を解剖し、そこから抜け出すための実践について書いたもので、三年間ワークショップで自分や多くの若手エンジニアと向き合う中で見えてきたことがある。動けない理由は一見バラバラに見える、けれどこれらの言葉を一つ一つ丁寧に剥いでいくと、驚くほど似た構造が現れる。恥への恐怖、完璧主義、そして「才能がない」という誰も反論できない便利な逃げ道。面白いことに、これらの根底には共通するものがあって、それは「なんとなく不安」「どうも気が進まない」「なんか怖い」という、この「なんか」という輪郭を持たない曖昧な言葉で、僕らはこの「なんか」という便利な言葉の中に、言葉にしたくない、言葉にするのが怖い、言葉にしてしまったら向き合わなければならなくなる、そういう感情を全部押し込めて蓋をしている。この「なんか」を言葉にしない限り、恐怖は形を持たない。形を持たない恐怖は霧のように僕らの思考を覆って、じわじわと、気づかないうちに、判断力を奪い続ける。ここで一つ断っておきたいのは、僕の「なんか」とあなたの「なんか」は、きっと少し違うということで、僕が恐れているものとあなたが恐れているものは同じではないかもしれないし、僕が「恥」だと感じるものとあなたが「恥」だと感じるものは、同じ言葉を使っていても中身は違うのかもしれない。けれど、それでも共通しているのは、その「なんか」を言葉にしないまま放置していることで、言葉にしない限り、それが何であれ、形を持たないまま僕らの中で勝手に膨らんでいくということだ。だから本人も周りもなかなか気づかないまま、「準備している」「慎重なだけ」「向いていないのかも」という、どこか優しげに聞こえて、誰も否定できない言葉の裏側で、実は何ヶ月も何年も同じ場所に立ち止まっていて、立ち止まっていることにすら気づかないまま時間だけが過ぎていく。さらに現代という時代が、この自己欺瞞を加速させている。生成AIに聞けばそれっぽい答えがすぐ返ってきて「理解した気」になれるし、スマホを開けば無限に刺激があって「ちょっと休憩」が気づけば一時間になる。立ち止まっている自分を見て見ぬふりをするための道具が、これほど揃っている時代はない。けれど同時に、この構造を理解すれば抜け出す方法も見えてくる。言語化すること、小さく始めること、遊ぶこと、不完全でも動くこと。これらは全て才能ではなく訓練可能な技術で、動けない理由を言語化できれば、動くための方法も見えてくる。「なんか不安」と思ったとき、立ち止まって「何が不安なのか」と問いかけるようになった。その答えを、怖くても、恥ずかしくても、認めたくなくても、言葉にするようになった。そうすると不思議なことに動けるようになって、言葉にしてしまえば思ったより大したことなかったりして、「こんなことで止まっていたのか」と拍子抜けするほどで、でも、言葉にしない限り、その「こんなこと」は永遠に巨大な壁であり続ける。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。三つの声いろんな彼というか昔の僕から動けない理由を聞くと、大きく三つのパターンに分かれる。正確には、休憩時間や終了後に雑談をしていて「今日はどうだった？」と聞くと、こんな答えが返ってくる。「失敗したくない」という声がある。ワークショップである学生が「エラーが出たら、どうしていいか分からなくなるんです」と言った。その時は「エラーメッセージを読むといいよ」とアドバイスして終わったのだが、後になって考えた。彼が本当に恐れていたのはエラーそのものだったのだろうか。よく思い返してみると、彼は他の参加者を横目で見ていて「みんな進んでる」とも言っていた。つまり、エラーが出たときにそれを解決できない自分が露呈するのが怖かったのではないか。「このエラーの意味が分からない」「基礎的な知識が足りない」と認めることは、自分の無知を他者に見せることになる。他の参加者は解決できているかもしれないし、講師は当然知っている。その中で自分だけが分からない。失敗への恐怖は、実は無知の露呈への恐怖なのかもしれない。エラーそのものは怖くないが、エラーを通じて自分の能力の限界が可視化されることが怖い。だからエラーが出る前に完璧に準備しようとしてドキュメントを読み漁るが、どれだけ読んでも「完璧」には到達しない。そして永遠に始められない。「もっと良い方法があるはず」という声もある。別の学生は「このやり方で合っているのか分からなくて」と言った。その時の彼の画面を覗き込むと、Dockerfileが半分書きかけのまま止まっていた。「どうしたの？」と聞くと「ベストプラクティスを調べてて」と言い、ブラウザには10個以上のタブが開いていた。終わった後、もう少し話を聞いてみた。「何が一番困った？」「うーん、正解が分からなくて」。その「正解」という言葉が引っかかった。プログラミングに唯一の正解なんてあるだろうか。後で考えてみると、彼が求めていたのは「正解」ではなく「間違っていないという保証」だったのかもしれない。Dockerfileを書き始めて一行書いては止まり、「これは本当にベストプラクティスなのか」とブラウザに戻って「Docker ベストプラクティス」で検索する。いくつかの記事を読むと別のやり方が紹介されていて「どっちが正しいんだろう」とまた別の記事を読み、さらに別のやり方を見つける。最適解を求めるほど選択肢は増え、決断は遠のく。でもよく考えてみると、おかしなことを言っている。「最適解」は実際にやってみないと分からず、プロジェクトの要件やチームの習熟度、運用の制約といった文脈によって「最適」は変わる。にもかかわらず文脈なしで「最適解」を求めている。これは実は決断を先延ばしにするための言い訳なのかもしれない。なぜ決断を先延ばしにするのか。おそらく決断には責任が伴うからだ。「これで行く」と決めた瞬間、それが間違っていたときの責任を負うことになる。でも「まだ調べている」段階なら責任は発生せず、間違える可能性もなく、評価されることもない。完璧主義は行動の質の問題ではなく、存在の先延ばしの問題なのかもしれない。「周りの目が気になって」という声は、終わった後の雑談で最も正直に語られた。「質問すると『こんなことも知らないのか』と思われそうで」という学生は、ワークショップ中に何度もつまずいていて画面を見れば分かるのだが、質問もせず隣の人に聞くこともせずに、ただ黙って画面を見つめていた。「どうして質問しなかったの？」と聞くと、「みんな分かってそうな雰囲気で、自分だけ分かってないって思われたくなくて」と言った。でも実際には、後で他の参加者に聞いてみると同じところでつまずいていた人が何人もいたのだが、誰も質問しなかった。みんな同じことを思っていた。恥という感情の不思議なところは、実際の他者の反応ではなく想像上の他者の視線に縛られることだ。「こう思われるかもしれない」という想像がその行動を止めるが、その想像が現実と一致しているかは確かめられない。なぜなら行動していないから。三つの声の正体失敗したくない、もっと良い方法があるはず、周りの目が気になる。学生たちから聞いたこれらの言葉を一人になってから反芻していた。一見バラバラに見えるこれらの理由だが、丁寧に分解していくと共通した構造が見えてくる気がした。すべて恥への恐怖に行き着くのではないか。「失敗したくない」は無知を露呈したくない、つまり恥をかきたくないということであり、「もっと良い方法があるはず」は間違った選択の責任を負いたくない、つまりこれも恥の回避だ。「周りの目が気になる」はそのものズバリ、他者の視線という恥の源泉である。そしてさらに抽象化すると、三つの根源的な恐怖に還元される気がした。恥をかきたくない、損をしたくない、嫌われたくない。でも面白いことに、これらを具体的に言葉にした瞬間、その恐怖は不思議なほど小さく見える。「エラーメッセージの意味が分からないのが怖い」と言葉にすればそれは解決可能な課題になるし、「ベストプラクティスを知らないのが不安」と認めれば「じゃあまず動くものを作って後で改善しよう」という選択肢が見える。「質問して笑われるのが怖い」と明確にすれば、「実際に笑う人がいるのか？ いたとしてその人の評価を気にする必要があるのか？」と問い直せる。具体的に言葉にした瞬間、恐怖は相対化される。でも多くの人はこの言語化の一歩手前で止まっている。いくつになっても恥をかける人になる【DL特典 恥克服ワークシート】作者:中川諒ディスカヴァー・トゥエンティワンAmazon「なんか」の正体「なんとなく不安で」「どうも気が進まなくて」「なんか怖くて」。この「なんか」という言葉が問題だ。「なんか」で済ませている限り恐怖は輪郭を持たない。輪郭を持たない恐怖は無限の可能性として脅威を放ち続け、それは霧のように思考空間を覆って判断力を奪う。逆に言えば、恐怖を明瞭に言語化すればそれは相対化可能な「ひとつの感情」へと縮小する。言葉は混沌に秩序を与える。でも、なぜ人は言語化を避けるのか。試しに自分が動けない理由を紙に書き出してみるといい。「なぜこのタスクに取り掛かれないのか」を具体的に書き始めると手が止まる。なぜか。言語化とは「嫌な自分」と正面から向き合う行為だから。曖昧なままなら自己欺瞞の余地が残り、「本気出せばできる」「時間がないだけ」「環境が悪いだけ」とそう思い込んでいられる。でも一度言葉にしてしまえばもはや逃げ場はない。「基礎的なことを理解していない」と書けばそれは事実として目の前に現れ、「エラーメッセージを読み飛ばしている」と認めればその怠慢は言い逃れできなくなり、「質問する勇気がない」と言葉にすれば自分の臆病さと向き合わざるを得ない。だから人は言語化を避ける。でもこの回避こそが停滞を生み出す。言葉にできない感情は実体以上に巨大化し、漠然とした不安のまま放置すればそれはどんどん大きくなっていく。「なんとなく怖い」が「とても怖い」になり「絶対に無理」になる。未言語化の不安は輪郭を持たないがゆえに肥大化し、行動を麻痺させる。このポストは動けない人の構造を解剖しそこから抜け出すための実践について書いたものだ。抽象的な話に聞こえるかもしれないが、これは極めて実践的な話だ。なぜなら動けない理由を言語化できれば動くための方法も見えてくるからだ。ワークショップでドキュメントを読み漁る若者を見ながら、自分もかつてそうだったことを思い出す。そして今も新しい技術に触れるとき同じパターンに陥りそうになる。でも一つだけ変わったことがある。「なんか不安」と思ったとき立ち止まって「何が不安なのか」と問いかけるようになった。その答えを言葉にするようになった。そうすると不思議なことに動けるようになる。「なんか」の正体を一緒に言葉にしてみよう。人生のレールを外れる衝動のみつけかた (ちくまプリマー新書)作者:谷川嘉浩筑摩書房Amazonなぜこんなに変わりたいのに行動ができないのか動けない理由を剥いていくとワークショップの後、参加者たちと話していて気づいたことがある。動けない理由は人それぞれ違う言葉で語られるが、その言葉を一つ一つ剥いでいくと意外なほど似た構造が現れる。「失敗したくない」と言った学生に「何が失敗なの？」と聞いてみた。「エラーが出ることです」。「エラーが出ると何が困るの？」「解決できないからです」。「解決できないと何が困るの？」と重ねて聞くと、彼は少し黙って小さな声で言った。「他の人にできないやつだと思われるのが嫌なんです」。ああそうか。エラーが怖いのではなかった。自分で認めるのも嫌だけど、エラーを解決できない自分が他者に見られることが怖かったのだ。「もっと良い方法があるはず」と言った学生には「今のやり方の何が問題なの？」と聞いた。「うーん、間違ってるかもしれないから」。「間違ってると何が困るの？」「後で直すのが大変だから」。「本当にそれだけ？」と聞くと、彼も少し考えてこう言った。「間違ったやり方を選んだって知られたくないです」。ここでも他者の視線が出てきた。試しに動けない理由を「○○が怖い」という形に言い換えてみると、面白いことにだいたい三つに集約される。恥をかくのが怖い、損をするのが怖い、嫌われるのが怖い。これらを観察しているとある構造に気づく。すべての中心に「他者の視線」がある。恥は他者がいて初めて成立し、損も他者との比較で生まれ、嫌われるもそのものズバリ他者との関係だ。動けない理由を突き詰めていくと、思考の主語が「自分」ではなく「他人」になっている。恥という不思議な感情恥を恐れて動けないとき自分の思考を観察してみるといい。面白いことに気づく。思考の主語が「他人」になっている。「自分がどうしたいか」ではなく「他人にどう見られるか」、「これは面白いか」ではなく「これは評価されるか」と、判断基準の中心にいつの間にか他者の視線が居座っている。ワークショップでこんなことがあった。ある学生が自分で考えた実装方法を試そうとしていたが、途中で手を止めて「これ間違ってるかもしれない」と言ってブラウザでベストプラクティスを検索し始めた。「さっきの方法試してみたら？」と声をかけると、「でももし間違ってたら恥ずかしいです」と言った。誰に対して？よく考えてみるとおかしな話だ。ワークショップは学ぶ場所で間違えるために来ているのに、彼は間違えることを恥だと感じていた。恥という感情は本質的に社会的なものだ。一人で山に籠もって生きているなら恥という感情は存在せず、恥は他者の視線があって初めて成立する。だから恥を避けようとすればするほど自分の判断基準は外部に移っていく。「自分はこれを試してみたい」ではなく「これは他者に評価されるか」、「自分はこれが面白い」ではなく「これは正しいと思われるか」となる。これは「外部評価への依存」というきわめて脆弱な存在様式だ。なぜ脆弱なのか。他者の評価はコントロールできないからだ。どれだけ頑張っても他者がどう評価するかは分からず、評価を気にすればするほどその不確実性に振り回される。さらに皮肉なことに恥を避けようとしてもっと深刻な状態に陥る。「失敗」という一時的な出来事を避けようとして「停滞」という持続的な状態に陥る。一瞬の恥を避けるために何ヶ月も何年も同じ場所に立ち止まる。でもこの事実に気づくのはいつも後になってからだ。停滞している最中は自分が停滞していることにすら気づかず、「準備している」「勉強している」「タイミングを見計らっている」とそう言い聞かせながら過ごす。恥を避けることに内的エネルギーを費やすほど自己の内側は空洞化していく。他者の評価を内面化し自分で自分を監視する。自己評価の基準が外部にあるときそこにはもう自己は存在しない。「完璧」という呪い「完璧に準備してから始める」という言葉は合理的に聞こえるが、ワークショップでこの言葉を聞くたびある疑問が浮かぶ。「完璧」って何だろう。ある学生はワークショップ開始前に2時間ドキュメントを読んでいて「準備したい」と言っていたが、実際にコンテナを立ち上げることはなかった。「どこまで準備したら始められそう？」と聞くと「全部理解してから」と言った。全部。でも「全部」って何だろう。Dockerの全ての機能を理解する？ Kubernetesの全てのコンポーネントを理解する？ そんなことは実務で何年も使っているエンジニアでも無理だ。つまり「完璧に準備してから始める」は実質的に「決して始めない」と同義だ。よく考えてみるとおかしなことを言っている。完璧に準備するとは何か。すべてを理解してから始めるということだが、すべてを理解するには実際にやってみるしかなく、やってみないと分からないことは必ずある。ドキュメントに「Podは一つ以上のコンテナを含む」と書いてあれば読めば理解できるが、実際にyamlを書いてkubectl applyしてエラーが出てそのエラーメッセージと格闘して、初めて本当に理解できる。理論的な理解と体験的な理解は違う。「完璧に準備してから」と言う人は実は理論的な理解だけで完璧になれると思っているが、それは不可能だ。体験なしに理解は完成しない。では、なぜ人は「完璧に準備してから」と言うのか。これは行動の質の問題ではなく存在の先延ばしの問題だ。不完全な自分を世界に晒すことへの恐怖、評価されることへの恐怖、そしてその根底にはやはり恥がある。完璧主義は恥への防衛機制として機能し、「準備不足だから失敗した」という言い訳をあらかじめ用意しておく。決して完成しないものは決して評価されず、評価されなければ恥もかかない。求めるほど遠のくという逆説がここにある。完璧を求めるから行動できず、行動しないから経験が積めず、経験がないから完璧からは遠のき、そしてさらに完璧を求める。この悪循環。ワークショップである学生が最後に「結局何も完成しませんでした」と言った。でも彼は多くのことを学んだはずだ。エラーメッセージの読み方、yamlの書き方、kubectlのコマンド。不完全でも多くのことを試した。「完成しなかったけど学んだことはたくさんあったんじゃない？」と言うと少し考えて「そうですね。でも完成させたかったです」と言った。完璧主義者が見落としているのは小さな一歩の価値だ。不完全でも動いた一歩と完璧を求めて動かなかったゼロ。どちらが自分を前に進めるか。答えは明白なのになぜか後者を選んでしまう。不完全主義　限りある人生を上手に過ごす方法作者:オリバー・バークマンかんき出版Amazon言葉にできない不安の正体「なんとなく不安で」「どうも気が進まなくて」「なんか怖くて」という言葉を休憩時間によく聞く。「どうして手を動かさないの？」と聞くと「なんとなく」と返ってくる。この「なんか」「なんとなく」という言葉が実は重要な意味を持っている。試しに「なんとなく不安」と言った学生に「何が不安なの？」と聞いてみた。「うーん、なんか」。「例えば？」「分からないです」。言葉にできない。でもこれは語彙力の問題ではなく言語化を避けているという選択の問題だ。なぜそう思うか。別の機会に同じ学生にもう一度少し角度を変えて聞いてみた。「もし今コンテナを立ち上げようとしたら何が起きると思う？」すると意外なほど具体的な答えが返ってきた。「エラーが出ると思います。そのエラーの意味が分からなくてどうしていいか分からなくなって時間ばかりかかって結局できなくて周りの人に遅れて」。ああ言葉にできるじゃないか。彼は自分の不安を言語化できないのではなく、言語化したくなかっただけだ。なぜか。言葉にできない感情は実体以上に巨大化する。「なんとなく不安」のままならその不安の正体は確定しないが、「エラーの意味が分からないのが怖い」と言葉にした瞬間それは具体的な課題になってしまい、具体的な課題になればそれに対処しなければならなくなる。言語化とは「嫌な自分」と正面から向き合う行為だから。「エラーメッセージの意味が分からない」と認めることは自分の知識不足を認めることであり、「基礎が理解できていない」と言葉にすることは自分の勉強不足を認めることであり、「質問する勇気がない」と明確にすることは自分の臆病さを認めることだ。曖昧なままなら自己欺瞞の余地が残り、「本気出せばできる」「時間がないだけ」「環境が悪いだけ」とそう思い込んでいられるが、一度言葉にしてしまえばもはや逃げ場はない。だから人は言語化を避ける。でもこの回避こそが停滞を生み出す。輪郭を持たない恐怖は無限の可能性として脅威を放ち続ける。それは霧のように思考空間を覆って判断力を奪い、「なんとなく怖い」が「とても怖い」になり「絶対に無理」になる。未言語化の不安は輪郭を持たないがゆえに肥大化し行動を麻痺させる。逆に言えば恐怖を明瞭に言語化すればそれは相対化可能な「ひとつの感情」へと縮小する。「エラーメッセージの意味が分からないのが怖い」と言葉にした瞬間それは解決可能な具体的課題になる。言葉は混沌に秩序を与える。言葉を持つことは自由を獲得することに等しい。言語化は自己認識の解像度を上げる行為であり、内面の混沌を構造化し恐怖を名指すことで相対化する力。それが言語化の力だ。「無理」の構造 ―この世の理不尽さを可視化する作者:細谷 功dZEROAmazon「才能」という最も便利な逃げ道そして最後にすべてを覆い隠す魔法の言葉がある。「才能がない」。ワークショップの最後ある学生が「自分には向いていないかもしれません」と言った。「どうしてそう思うの？」と聞くと「他の人より理解が遅いから」と言った。でも観察していて気づいたことがある。彼は理解が遅いのではなく理解しようとしていなかったのだ。エラーメッセージが出てもちゃんと読んでいなかった。「Expected type X, but got type Y」と明確に書いてあるのに「type X」という文字列だけを拾って、期待される型と実際の型が違うという関係性を読み取っていなかった。ドキュメントを「読んでいる」と言いながら実際には流し読みしていて、主語と述語を把握せず「誰が」「誰に」「何を」しているのかという基本的な構造を理解しないまま「なんとなく」で進めようとしていた。仮説を一つずつ潰すのではなく「ネットワークの問題かもしれない」「データベースの問題かもしれない」と複数の仮説を同時に追いかけてどれも中途半端に確認していた。これは才能の問題ではなくプロセスの問題だ。エラーメッセージをちゃんと読む、仮説を一つずつ潰す、主語と述語を把握する。誰でもできることだ。でもこの「小さなこと」を飛ばしているから「理解が遅い」ように見える。そしてこの事実から目を逸らすために「才能」という言葉を使う。「才能がない」という言葉は根深い自己欺瞞であり最も便利な逃避だ。なぜなら才能という言葉を使った瞬間、人は変化の可能性を放棄できるからだ。「才能がないからできない」は「努力してもどうせ無理」と同義で、成長のための努力そのものが無意味に思える。そして才能という言葉はすべてを覆い隠す。恥への恐怖を覆い隠し完璧主義を正当化し言語化を避ける。基礎プロセスを飛ばしていることも努力を怠っていることもすべて「才能」という一言で片付けられる。才能という言葉を使った瞬間思考は停止する。でも観察していると分かる。「才能がある」ように見える人も実は同じプロセスを踏んでいる。エラーメッセージをちゃんと読み仮説を一つずつ潰し主語と述語を把握している。ただそれだけだ。違いはそのプロセスを意識的に実践しているかどうかであり、それは訓練可能だ。前のポストで書いたように技術力は経験の蓄積とセンスから成り立ち、そしてどちらも訓練可能だ。センスとは突き詰めれば「何に注目するか」という習慣と「それを面白がれるか」という姿勢だ。でも「才能」という言葉を使えばこうした具体的な分析も具体的な対策もすべて放棄できる。恥への恐怖、完璧主義、言語化の欠如。そのすべてを「才能」という一言で説明する。これが動けない人が抱える最後の砦だ。HIDDEN POTENTIAL 可能性の科学――あなたの限界は、まだ先にある (三笠書房　電子書籍)作者:アダム・グラント三笠書房Amazon動くための小さな一歩言葉にしてみるという勇気まず自分の恐怖を具体的に正直に言語化してみる。ワークショップの終わりにこんな提案をしてみた。「今日動けなかった理由を紙に書いてみて」。最初は戸惑った顔をしていた参加者たちだが何人かが書き始めた。ある学生が書いたのは「エラーが出たときに解決方法が分からなくて周りに遅れるのが嫌だった」という文章だった。書き終わって彼はその紙をじっと見ていて「あれこんなことだったのか」と言った。言葉にした瞬間不思議なことが起きる。恐怖が相対化され「ああこんなことで止まっていたのか」という気づきから「じゃあどうすればいいか」という具体的な対策が見えてくる。「エラーが出たときに解決方法が分からない」なら「じゃあエラーメッセージの読み方を学ぼう」となり、「周りに遅れるのが嫌」なら「でもこれは学ぶ場所だ。遅れても構わない」となる。抽象的な不安は具体的な課題へと変換され、具体的な課題は具体的な対策で解決できる。「恥をかきたくない」だけではまだ抽象的だ。もう一歩踏み込んで「このコードをレビューに出したら基礎的な部分の知識不足を指摘されるのが怖い」とここまで具体的にする。すると「じゃあ基礎的な部分を先に学べばいい」という対策が見え、「レビュー前に自分でチェックリストを作ればいい」という方法が浮かび、「そもそも指摘されることは学びのチャンスだ」という視点が得られる。言語化は勇気の技術であり嫌な自分と向き合う技術だが、その一歩がすべてを変える。さみしい夜にはペンを持て作者:古賀史健ポプラ社Amazon現代人が失ったものただ言語化を阻むものは個人の内側だけにあるわけではなく、現代という時代そのものが言語化を難しくしている。ワークショップの休憩時間、参加者たちの多くがスマホを見てTwitterやInstagramをスクロールしLINEに返信しYouTubeのショート動画を見る。私たちは今インスタントで断片的な刺激に取り巻かれている。即座の返信、短い動画、分かりやすい解説とスマホを持つことで即時的な満足にいつでもアクセスでき、「消化しきれなさ」「難しさ」「モヤモヤ」といった時間もコストもかかるものは避けられるようになった。技術ドキュメントを読むことはまさにこの「モヤモヤ」との戦いだ。Kubernetesの公式ドキュメントを開いても一読してすぐに理解できるものではなく、分からない用語が出てきてそれを調べるとさらに分からない概念が出てくる。読み返し実際に試しエラーが出てまた読み返す。この時間のかかるプロセスがインスタント化した感覚に慣れた私たちには耐えがたい。だからすぐに生成AIに「KubernetesのServiceとは何ですか？要約して」と聞く。確かに分かりやすい説明が返ってきてスッキリする。でもその過程で失われるものがある。モヤモヤした状態を抱えたまま読み続け試し続けることでしか到達できない深い理解。断片的な知識ではなく体系的な理解。これは要約では得られない。ある学生がワークショップで「生成AIで調べたんですけど実際にやってみるとうまくいかなくて」と言った。よく見ると生成AIの説明を鵜呑みにしてその背後にある前提条件を理解していなかった。「この設定はこういう環境を前提としています」という部分を読み飛ばしていた。生成AIは便利なツールだが使い方を間違えると理解の機会を奪う。同時にスマホによる常時接続は孤独を奪った。ワークショップ中少し難しい課題に取り組んでいるときすぐにスマホに手が伸びて「ちょっと休憩」と言ってTwitterを開く。退屈に耐えきれず何か刺激を求めてスマホをいじる。一人でドキュメントと向き合う時間一つのことに没頭する孤立。このシンプルな行為が驚くほど難しくなっている。でも言語化には孤独が必要で、自分の内側と向き合うには外部の刺激から離れる必要がある。そしてもう一つ、ネガティブ・ケイパビリティの欠如だ。これは「結論づけずモヤモヤした状態で留めておく能力」のことで、把握しきれない謎をそのまま抱えておく力だ。新しい技術を学ぶときすぐに「わかった」と思いたくなるが実際にはわかっていないことだらけで、この不確実性に耐える力が現代人には欠けている。ワークショップでこんなことを言う学生がいた。「全部理解してから次に進みたいんです」。でも「全部理解する」なんて不可能だ。理解は何度も行ったり来たりしながら螺旋を描くように深まっていく。最初は30%の理解、実際に使ってみて50%、エラーと格闘して70%、また別の文脈で使って80%。理解は一度で完成しない。でもこのモヤモヤした状態に耐えられずすぐに「分かった」と結論づけたいために生成AIに「簡潔に説明して」と頼む。簡潔な説明は確かに分かりやすいが、その分かりやすさは複雑さを削ぎ落とした結果で、削ぎ落とされた部分にこそ本質が隠れていることもある。学びとは何か－〈探究人〉になるために (岩波新書)作者:今井 むつみ岩波書店Amazon生成AIという新たな逃避ChatGPTやClaudeの登場は学習の風景を変えそして新しい逃避の道を開いた。停滞のパターンはこうだ。エラーが出て生成AIに「このエラーどう直す？」と聞き答えが返ってコピペして動いて「解決！」となる。これは答えは得られるが理解は得られず、次に同じエラーに遭遇したときまた同じことを繰り返す。ワークショップで何度も同じパターンを見た。学生がエラーに遭遇してすぐに生成AIに聞き答えをコピペし次のエラーでまた聞きまたコピペする。三回目に同じようなエラーが出たとき彼は気づいていなくて「あれさっきも似たようなエラーが出たな」という記憶がない。なぜか。自分で考えていないからだ。エラーメッセージを読んでいない。なぜそのエラーが出たのか理解しようとしていない。答えは得られるが学びは得られない。混乱したときすぐに生成AIに頼ると不快感と向き合う機会が失われる。でもこの不快感こそが深い理解への道なのに。成長のパターンはこうだ。まず自分で理解しようとしてエラーメッセージを読みドキュメントを読み仮説を立てて試す。それでも分からなかったら自分なりの理解をまとめる。その上で生成AIに「私はこう理解したが合ってる？」と質問する。先に自分で考えて生成AIは「答えを教える」のではなく「理解を確認する」役割にする。あるいは「このエラーが出た。なぜこのエラーが出るのか仕組みから説明して。直し方は教えなくていい」と聞いて表面的な解決策ではなく根本的な理解を得る。ワークショップでこの方法を試した学生がいた。最初は時間がかかったが、三回目に似たようなエラーが出たとき彼は自分で解決できて「ああこれはあの時と同じパターンだ」と言った。理解があれば応用が効く。生成AIとの付き合い方には四つの落とし穴がある。一つ目は思考の外部化で考えるべきことを全て生成AIに任せてしまうこと。二つ目は流暢性の錯覚で、生成AIの説明は分かりやすいが自分でコードを書こうとすると書けず「分かった気」になっているだけ。三つ目は最適な難易度を見失い自分の理解レベルに合わない質問をしてしまい、基礎を理解していないのに応用的な質問をする。四つ目は不快感から逃げることで、混乱したときモヤモヤしたときすぐに頼ってしまうがその不快感こそが成長の証なのに。重要なのは自分の頭で考え手を動かし不快感と向き合うことで、これは生成AIがなかった時代もある時代も変わらない真実だ。そしてこれも才能の問題ではなく習慣の問題だ。生成AI「戦力化」の教科書作者:松本 勇気日経BPAmazon遊ぶことから始まる恥を恐れ完璧を求め言語化から逃げる。この三つが絡み合って人を動けなくする。一つの答えは遊ぶことだ。ワークショップでこんな提案をしてみた。「次の30分何も見ずにとりあえず動かしてみて」。「えっドキュメント見なくていいんですか？」と驚く学生たちに「いいよ。適当にやってみて。エラーが出ても気にしない。とにかく何か動かしてみる」と答えた。最初は戸惑っていたが徐々に表情が変わってきて「あこれ動いた」「このオプション何だろう」「試してみよう」となった。遊びには「正解」がないから失敗を恐れる必要がない。評価されることもなくただ面白いからやり好奇心のままに試す。この心理的な自由が試行錯誤を促進する。30分後何人かの学生が予想外のものを作っていた。「Nginxのコンテナを3つ立ち上げてそれぞれ違うページを表示させてみました」。ドキュメント通りではないが動いていて彼は楽しそうだった。「どうやって作ったの？」と聞くと「分からないままとりあえず書いてみたら動いたんです」と言った。この「なんとなく」が実は重要なのだ。理論を学ぶ前に体験を通じた直感的理解が生まれる。後に理論を学ぶとき「あああの時の『なんとなく』はこういうことだったのか」と腑に落ちる。プログラミングを学び始めた頃を思い出してほしい。「とりあえず動かしてみよう」と思ってよくわからないままコードを書いた経験はないだろうか。エラーが出て何が悪いのかわからないが、いろいろいじっているうちになんとなく動いた。遊びは内発的動機を育てる。「やらなければならない」ではなく「やりたい」という動機で、これは強制では生まれない。自分で選んで自分のペースで面白いと思うことをやる過程で内発的動機が育つ。失敗への耐性も生まれる。遊んでいるとき失敗は「失敗」ではなくただの「結果」だ。「あこうするとこうなるんだ」という発見と次は別の方法を試してみようという好奇心。多くの人は学びを始めるときいきなり「正しいやり方」を覚えようとして教科書を読みチュートリアルを見る。でもこれは実は難しい。なぜなら「なぜその型が重要なのか」がわからないまま形だけを真似ようとするから。型の意味を理解するにはその型がない状態を経験する必要がある。だからまず遊ぶ。制約なく好奇心のままに試して失敗を恐れず楽しむ。ここで少し逆説的なことを言いたい。特に若い時期には根拠がなくても自分を信じることが重要だ。「これが本当に正しい道なのか」「自分に向いているのか」。そんな冷静な自己分析ばかりしていると一歩も踏み出せなくなる。時には根拠のない自信を持って盲信的に突き進むことも必要だ。「Kubernetesなんて簡単だろう」というある意味で無知ゆえの大胆さ。この「若気の至り」とも言える姿勢が最初の一歩を踏み出させてくれる。ワークショップで最も早く理解した学生に「なんでそんなに迷わず進めるの？」と聞いてみた。彼は少し考えて「分からないけどとりあえずやってみたら分かるかなって」と言った。根拠のない自信だがその自信が彼を動かした。実際に動いた結果本当に理解した。その盲信的な姿勢がいつか本当の自信に変わり、根拠のない自信が実績という根拠を伴った自信になる。気づけば最初は「嘘」だった「自分はできる」という言葉が本当になっている。完璧主義を捨ててまず遊ぶ。型を学ぶのはその後でいい。熟達論―人はいつまでも学び、成長できる―作者:為末大新潮社Amazon小さく、完璧でなくても、動く停滞と努力の違いを理解することも重要だ。ワークショップである学生がKubernetesのServiceの概念に数日苦しんでいて、彼は毎日同じドキュメントを読み返していた。「努力している」と本人は言ったが彼は前に進んでいなかった。よく話を聞くと彼はそもそもネットワークの基礎を理解していなかった。IPアドレスとは何かポートとは何かDNSがどう動くのか。こうした土台がないままKubernetesの抽象的な概念を理解しようとしていた。難しい問題に直面したとき人は二つの道を選ぶ。一つは理解できないまま同じ説明を何度も読み返し同じ場所でぐるぐると回り続けること。もう一つは「何が分からないのか」を見極めてまずそこから順番に理解していくこと。前者を停滞と呼び後者を努力と呼ぶ。停滞している人はしばしば自分が努力していると思っている。長時間向き合い何度も試している。でも実際には前提となる知識が欠けたまま同じところで足踏みを繰り返しているだけ。「Serviceが分からない」と言っていた学生に「じゃあまずネットワークの基礎から学ぼう」と提案すると最初は不満そうで「それは遠回りじゃないですか」と言った。でも基礎から学び始めて3日後彼は突然Serviceを理解して「ああそういうことか！」と言った。本当の意味での努力とは今の自分が理解できるところから始めること。Kubernetesが難しいならまずネットワークの基礎から。ネットワークが難しいならまず自分のPCで2つのプログラムを通信させることから。この段階を踏んだ学び方こそが努力の本質だ。学習には三つのゾーンがある。コンフォートゾーンはすでに理解していることを繰り返す状態で簡単すぎて新しい学びがない。パニックゾーンは現在の理解からかけ離れていて難しすぎて何から手をつければいいかわからない。学習ゾーンは少し難しいが頑張れば手が届き既存の知識を応用すればなんとか理解できる。「才能がない」と感じているとき実はパニックゾーンに突っ込んでいるだけかもしれない。基礎を理解していないのに応用に挑戦し前提知識がないのに高度な概念を理解しようとする。当たり前だがこれは無理だ。才能の問題ではなく順序の問題だ。不快感を恐れないことも重要だ。学習において最も反直感的な真実の一つはある種の困難は実は学習を改善するということだ。同じチュートリアルの再読、すでに動くコードの微調整、すぐに答えを探すこと。これらは確かに楽だが長期的な学習効果は低い。なぜか。脳は情報を取り出すのに苦労すること自体でその情報への神経経路を強化するからだ。簡単すぎる復習ではこの「取り出す苦労」が発生せず記憶が強化されない。効果的な方法は少し忘れかけたタイミングで復習すること。概念を学び1日空けて何も見ずに説明しようとし思い出せない部分を確認する。難しく忘れかけていて思い出すのに苦労するがこの苦労こそが記憶を強化する。新しい概念を学ぶとき混乱は不快で「もう無理だ」と思う。でもこの不快感こそが成長の証なのだ。脳が新しい構造を構築しようとしている証で既存の理解の枠組みが崩れ新しい理解が生まれつつある証だ。この不快な状態を抱えたまま学び続け逃げずに向き合う。ある日突然繋がる。その瞬間の爽快感はすべての苦労を報いてくれる。「快適ならやり方が間違っている」という言葉がある。本当の成長は常にコンフォートゾーンの外側で起きる。最後にエラーメッセージをちゃんと読み仮説を一つずつ潰し主語と述語を把握する。こうした小さなこと。ワークショップの最後にある学生が「エラーメッセージちゃんと読んだらちゃんと書いてありました」と言った。当たり前のことだがこの当たり前のことができていない人は驚くほど多い。めんどくさいと感じるかもしれないがこの「めんどくさい」基礎作業を飛ばすから結果的に何倍も時間がかかってしまう。才能があるように見える人はこれらを実践しているだけで意識的か無意識的に。これらは訓練可能だ。小さく始める。不完全でも動く。その積み重ねだけだ。エンジニアという仕事には一つの大きな救いがある。それは手を動かしている間才能への不安が消えるということだ。「自分には才能がない」という悩みは頭の中でぐるぐる回り始めるとどんどん大きくなるが「これを作りたい」と思って実装を始めた瞬間その悩みはどこかに消える。目の前にあるのは具体的な問題だけだ。エラーが出て調べて解決してまた詰まってまた調べる。この「詰まる→調べる→解決する」のサイクルを回すこと自体が静かに自信を育てていく。理解の速さには個人差がありこれは残酷な現実だが、人生という長い時間軸で見たときこの速さの差は思ったほど大きくない。むしろ一歩ずつでも前に進み続けた人と途中で立ち止まってしまった人の差の方がはるかに大きい。時間は誰にも平等だ。その時間を「理解できない問題の前での空回り」に使うか「今理解できることから順に積み上げていく前進」に使うか。この選択が長期的には想像もできないほどの差を生む。ぐちゃぐちゃ考える暇があったら手を動かす。才能について悩む時間を1行でも多くコードを書く時間に変え、理想の自分について考える時間を作りたいものを作る時間に変える。その積み重ねが気づけば「成長」と呼ばれるものになっている。心理的安全性　最強の教科書作者:ピョートル・フェリクス・グジバチ東洋経済新報社Amazonおわりにワークショップで出会った学生の一人が最近こんなメッセージを送ってきた。「ちゃんと読むようになったら解決が早くなりました」。彼は以前「才能がない」と言っていたが実際にはエラーメッセージを読み飛ばしていただけだった。その事実を言語化し意識的に「ちゃんと読む」ようにした。それだけで解決速度は変わった。些細なことだがその些細なことに気づくまで私は何年もかかった。このポストで繰り返し述べてきたように動けない理由は言葉にしてしまえば驚くほど小さい。恥を恐れていて完璧を求めすぎていて「なんか不安」を「なんか」のまま放置していて、そして「才能がない」という誰も反論できない理由で全てから逃げていた。言葉にした瞬間それらは「対処可能な課題」に変わる。でも言葉にするまでが驚くほど難しい。なぜなら嫌な自分と向き合わなければならないから。ワークショップを三年続けて一つ確信したことがある。最初は速かったのに途中で離れていった人たちがいて最初は遅かったのに黙々と続けている人たちがいる。三年後後者の方が圧倒的に前に進んでいる。「才能」という言葉を使った瞬間思考は停止する。でも「エラーメッセージを読み飛ばしている」と言語化した瞬間「じゃあちゃんと読めばいい」という対策が見える。そのシンプルな事実に気づくかどうか。それだけの差が長い時間をかけて想像もできないほど大きな差になる。syu-m-5151.hatenablog.com未熟な自分がワークショップを始めて三年。今でも不安はあり「自分なんかが教えていいのか」と思うこともある。でも若手と一緒に作業する中で気づいた。彼らが必要としているのは全てを知り尽くした完璧な指導者ではない。「才能」という便利な言葉で可能性を閉ざさず「じゃあどうすればいいか」を一緒に考える誰かだ。そしてそれは自分自身に対しても同じだと思っている。「読んでいる自分は頑張っている気がする」という謎の達成感に私たちはいつまで浸っているのだろうか。本当に必要なのは手を動かすこと。小さく完璧でなくてもでも確実に前に進むこと。言葉にしない限り「なんか」は永遠に巨大な壁であり続けるが、言葉にしてしまえば思ったより大したことなかったりする。その一歩を踏み出すかどうか。結局それだけの話だ。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[splitコマンドでファイルを分割する方法について]]></title>
            <link>https://zenn.dev/akasan/articles/a7d35ab880e1f8</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/a7d35ab880e1f8</guid>
            <pubDate>Fri, 31 Oct 2025 12:47:15 GMT</pubDate>
            <content:encoded><![CDATA[今回はファイルを分割するためのsplitコマンドについて調べてみました。行数が多いファイルを分割する方法を調べていたら組み込みのコマンドとして存在していたので調べてみました。 splitコマンドの使い方それでは早速splitコマンドを使ってみます。 検証用データの作成今回はテストように100万行あるデータを作成してみました。Pythonでパパッと作りました。with open("original.txt", "w") as f:    for i in range(1_000_000):        f.write(f"{i}\n")これを実行すると、0から99,9...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Observability Conference Tokyo 2025に参加してきました！]]></title>
            <link>https://sreake.com/blog/o11y-con-tokyo-2025/</link>
            <guid isPermaLink="false">https://sreake.com/blog/o11y-con-tokyo-2025/</guid>
            <pubDate>Fri, 31 Oct 2025 09:21:45 GMT</pubDate>
            <content:encoded><![CDATA[はじめに 3-shakeで マーケティング・ブランディングを行なっている永瀬です。 2025/10/27に Observability Conference Tokyo 2025 が開催されましてスリーシェイクもスポンサ […]The post Observability Conference Tokyo 2025に参加してきました！ first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[近すぎず、遠すぎず - コードの結合度とちょうどいい距離の測り方]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/10/31/125256</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/10/31/125256</guid>
            <pubDate>Fri, 31 Oct 2025 03:52:56 GMT</pubDate>
            <content:encoded><![CDATA[はじめに人間関係が数値化できればなぁって思ったこともありますか？僕はあります。「この人とは、ちょうどいい距離感だな」とか、「もうちょっと親しくなりたいけど、近づきすぎると息苦しいかもしれない」とか。そういう、言葉にしづらい感覚を、もし数字で表せたら——なんて。コードを書いているとき、似たようなことを考える。「このモジュールとあのモジュール、近すぎるな」と思う瞬間がある。あるいは逆に、「これ、もっと近くにあった方がいいんじゃないか」と。モジュール同士の距離感。誰もが一度は悩んだことがあるはずだ。近すぎても、遠すぎてもいけない。でも、「ちょうどいい」って、どういうことだろう。バグを修正したときのことだ。直接的には関係ないはずの、別の場所が壊れる。そんな経験、ないだろうか。それは、見えない糸が張り巡らされている証拠だ。データの持ち方への暗黙の依存。前提条件。実行順序。そういう、目に見えにくい結合が、コードのあちこちに潜んでいる。大切なのは、結合をゼロにすることじゃない。そんなことは、できない。むしろ、適切にバランスさせることだ。人間関係と同じように。Vlad Khononov が書いた「Balancing Coupling in Software Design」という本がある。この本は、結合度を測るための、実践的なフレームワークを提供している。結合の強さ、距離、そして変更の頻度——この3つの軸。これで測る。バランスを評価する。この本が教えてくれることがある。機能は線形に増える。でも、複雑さは指数関数的に膨れ上がる。そして、僕たち人間には認知的な限界がある。だから、複雑さに対処するには、システムの形を変えるしかない。そのための道具が、結合なのだ。この記事では、その概念を Rust プロジェクトに適用してみる。実際に測定して、分析できるツールを作る。コードの「ちょうどいい距離感」を数値化し、可視化する。そんな試みである。Balancing Couplingの核心概念ソフトウェア設計の結合バランス　持続可能な成長を支えるモジュール化の原則 (impress top gearシリーズ)作者:Vlad KhononovインプレスAmazon3つの次元で結合度を測るすごく端的に話すとKhononov のフレームワークは、結合度を 3 つの軸で評価する。1. Integration Strength（統合強度）コンポーネント間で共有される知識の量。次の 4 つのレベルに分類される。Intrusive Coupling（侵入的結合）- 内部実装の詳細に依存Functional Coupling（機能的結合）- 共有された責任による依存Model Coupling（モデル結合）- ビジネスドメインモデルの共有Contract Coupling（契約結合）- インターフェース/トレイトによる抽象化下に行くほど結合が弱く、望ましい。2. Distance（距離）依存関係がどれだけ離れているかを測る。同じ関数内同じモジュール内異なるモジュール異なるクレート異なるサービス（マイクロサービスの場合）距離が遠いほど、変更のコストが高くなる。3. Volatility（変動性）コンポーネントの変更頻度を示す。Core Subdomain（コアサブドメイン）- 高頻度で変更Supporting Subdomain（サポートサブドメイン）- 中程度の変更Generic Subdomain（汎用サブドメイン）- 低頻度の変更バランスの公式これらを組み合わせた「バランスの方程式」は、概念的には次のように表現できる。BALANCE = (STRENGTH XOR DISTANCE) OR NOT VOLATILITY概念の解釈MODULARITY = STRENGTH XOR DISTANCE強い結合なら距離を近く（局所性を保つ）弱い結合なら距離を遠くても良い（疎結合）この 2 つのパターンが理想的BALANCE = MODULARITY OR NOT VOLATILITYモジュラーである、または変動性が低い（安定している）どちらかの条件を満たせばバランスが取れている数値計算への変換実装では、論理演算を数値計算に変換する。XOR - 両極端（強×近、弱×遠）の和として計算OR - 最大値（max）として計算NOT - 補数（1.0 - x）として計算ここで押さえておきたいのは、結合をゼロにするのが目的ではないということ。適切にバランスさせることが肝心で、コンテキストに応じて最適な形を選ぶ必要がある。Connascence（共依存性）結合度をさらに細かく分析するには、Meilir Page-Jones が提唱した「Connascence」の概念が役立つ。Static Connascence（静的共依存性）コンパイル時に検出可能なもの。Connascence of Name（CoN）- 名前への依存Connascence of Type（CoT）- 型への依存Connascence of Meaning（CoM）- 値の意味への依存Connascence of Position（CoP）- パラメータ順序への依存Connascence of Algorithm（CoA）- アルゴリズムへの依存Dynamic Connascence（動的共依存性）実行時に検出されるもの。Connascence of Execution（CoE）- 実行順序への依存Connascence of Timing（CoT）- タイミングへの依存Connascence of Value（CoV）- 値の同期的変更への依存Connascence of Identity（CoI）- 同一インスタンスへの依存動的共依存性は、最も弱いものでも、最も強い静的共依存性よりも強い結合を意味する。Rustにおける既存ツール1. cargo-modulesモジュール構造と依存関係を可視化できる。https://crates.io/crates/cargo-modulescrates.ioインストール:cargo install cargo-modules使い方:# モジュール構造をツリー表示cargo modules structure# モジュール間の依存関係をグラフ表示cargo modules dependencies# 循環依存の検出cargo modules dependencies --acyclic# 孤立したファイルの検出cargo modules orphans特徴:モジュール階層の視覚化循環依存の検出（リファクタリングの重要な手がかり）未使用ファイルの発見GraphViz と連携可能2. rust-code-analysisMozilla が開発した、多言語対応のコードメトリクス計測ツール。github.comインストール:cargo install rust-code-analysis-cli使い方:# 単一ファイルの分析rust-code-analysis-cli --metrics -p src/main.rs# プロジェクト全体の分析rust-code-analysis-cli --metrics -p ./src# JSON形式で出力rust-code-analysis-cli --metrics -O json -o metrics.json -p ./src計測可能なメトリクスCC (Cyclomatic Complexity) - 循環的複雑度COGNITIVE - 認知的複雑度HALSTEAD - Halstead メトリクス（Bugs, Difficulty, Effort, Volume 等）LOC 系 - SLOC、PLOC、LLOC 等NOM - メソッド数NARGS - 引数の数NEXITS - 出口の数WMC - クラスごとの循環的複雑度の合計Rust コードの複雑度を他言語と比較する研究でも使用されており、信頼性が高い。3. cargo treeCargo 組み込みの依存関係ツリー表示コマンド。doc.rust-lang.org使い方:# 依存関係ツリーの表示cargo tree# 深さを制限cargo tree --depth 1# 特定のパッケージを除外cargo tree --prune serde# 重複する依存関係を表示cargo tree --duplicates# リバース依存関係（何がこのクレートに依存しているか）cargo tree --invert <package-name>4. その他の有用なツールcargo-deps - GraphViz DOT ファイルを生成cargo-depgraph - 視覚的な依存関係グラフtokei - コード統計（行数、言語別集計）cargo-deny - 依存関係のポリシー検証Balanced Couplingを測定するカスタムツールの実装既存ツールは有用だが、Khononov のモデルを直接適用するには限界がある。特に、Integration Strength の分類、Dynamic Connascence の検出、Git 履歴との連携、Balance Score の計算といった機能が不足している。これらを測定するため、カスタムツールを実装していこう。基本的なアプローチ必要な依存関係を Cargo.toml に追加します。[dependencies]syn = { version = "2.0", features = ["full", "visit"] }quote = "1.0"walkdir = "2.4"thiserror = "2.0"実装例です。use syn::{visit::Visit, ItemFn, ItemImpl};/// 結合度メトリクスを保持する構造体////// Integration Strength、Distance、Connascenceの3つの次元を測定#[derive(Debug, Default, Clone)]pub struct CouplingMetrics {    // Integration Strength    pub intrusive_count: usize,    pub functional_count: usize,    pub model_count: usize,    pub contract_count: usize,    // Distance    pub same_module: usize,    pub cross_module: usize,    pub cross_crate: usize,    // Connascence    pub name_coupling: Vec<String>,    pub type_coupling: Vec<String>,    pub position_coupling: Vec<String>,}/// ASTを訪問して結合度を分析するアナライザー#[derive(Debug)]pub struct CouplingAnalyzer {    pub metrics: CouplingMetrics,    pub current_module: String,}impl CouplingAnalyzer {    /// 新しいアナライザーを作成    ///    /// # Arguments    /// * `module_name` - 分析対象のモジュール名    fn new(module_name: String) -> Self {        Self {            metrics: CouplingMetrics::default(),            current_module: module_name,        }    }    /// 関数シグネチャを分析してConnascence of Positionを検出    ///    /// # Arguments    /// * `sig` - 分析対象の関数シグネチャ    fn analyze_function_signature(&mut self, sig: &syn::Signature) {        // 引数の数をチェック（Connascence of Position）        if sig.inputs.len() > 3 {            self.metrics.position_coupling.push(                format!("Function {} has {} parameters",                    sig.ident, sig.inputs.len())            );        }    }    /// 2つのモジュールパス間の距離を計算    ///    /// # Arguments    /// * `from_path` - 開始パス (例: "crate::module::submodule")    /// * `to_path` - 終了パス    ///    /// # Returns    /// モジュール階層における段数（距離）    fn calculate_distance(&self, from_path: &str, to_path: &str) -> usize {        let from_parts: Vec<&str> = from_path.split("::").collect();        let to_parts: Vec<&str> = to_path.split("::").collect();        // 共通の祖先を見つける        let common = from_parts.iter()            .zip(to_parts.iter())            .take_while(|(a, b)| a == b)            .count();        (from_parts.len() - common) + (to_parts.len() - common)    }}impl<'ast> Visit<'ast> for CouplingAnalyzer {    /// 関数定義を訪問    fn visit_item_fn(&mut self, node: &'ast ItemFn) {        // 関数定義を分析        self.analyze_function_signature(&node.sig);        syn::visit::visit_item_fn(self, node);    }    /// implブロックを訪問してContract/Intrusive Couplingを検出    fn visit_item_impl(&mut self, node: &'ast ItemImpl) {        // トレイト実装を分析（Contract Coupling）        if node.trait_.is_some() {            self.metrics.contract_count += 1;        } else {            // 具象型への直接実装（Intrusive Coupling）            self.metrics.intrusive_count += 1;        }        syn::visit::visit_item_impl(self, node);    }}Volatility（変動性）の測定Git の履歴から変更頻度を分析します。use std::process::Command;use std::collections::HashMap;use thiserror::Error;/// Volatility分析のエラー型#[derive(Error, Debug)]pub enum VolatilityError {    #[error("Git command failed: {0}")]    GitCommandFailed(String),    #[error("Failed to parse Git output: {0}")]    ParseError(String),    #[error("IO error: {0}")]    Io(#[from] std::io::Error),    #[error("UTF-8 conversion error: {0}")]    Utf8Error(#[from] std::string::FromUtf8Error),}/// ファイルの変更頻度を分析するアナライザー////// Git履歴を解析して各ファイルの変動性を評価#[derive(Debug, Default, Clone)]pub struct VolatilityAnalyzer {    file_changes: HashMap<String, usize>,}/// 変動性のレベル#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]pub enum VolatilityLevel {    /// 低変動性（汎用サブドメイン）    Low,    /// 中変動性（サポートサブドメイン）    Medium,    /// 高変動性（コアサブドメイン）    High,}impl VolatilityAnalyzer {    /// 新しいアナライザーを作成    fn new() -> Self {        Self::default()    }    /// Git履歴を解析して変更頻度を収集    ///    /// # Arguments    /// * `months` - 過去何ヶ月分の履歴を分析するか    ///    /// # Returns    /// 成功時は `Ok(())`、Git コマンド実行失敗時はエラー    ///    /// # Errors    /// - Git コマンドが失敗した場合    /// - 出力のパースに失敗した場合    ///    /// # Example    /// ```    /// let mut analyzer = VolatilityAnalyzer::new();    /// analyzer.analyze_git_history(6)?; // 過去6ヶ月を分析    /// ```    pub fn analyze_git_history(&mut self, months: usize) -> Result<(), VolatilityError> {        let output = Command::new("git")            .args([                "log",                "--pretty=format:",                "--name-only",                &format!("--since={} months ago", months)            ])            .output()?;        // Git コマンドが失敗した場合のチェック        if !output.status.success() {            let stderr = String::from_utf8_lossy(&output.stderr);            return Err(VolatilityError::GitCommandFailed(stderr.to_string()));        }        let files = String::from_utf8(output.stdout)?;        for file in files.lines().filter(|l| !l.is_empty()) {            *self.file_changes.entry(file.to_string())                .or_insert(0) += 1;        }        Ok(())    }    /// ファイルの変動性レベルを分類    ///    /// # Arguments    /// * `file` - 分類対象のファイルパス    ///    /// # Returns    /// 変動性レベル（Low/Medium/High）    fn classify_volatility(&self, file: &str) -> VolatilityLevel {        let changes = self.file_changes.get(file).copied().unwrap_or(0);        match changes {            0..=2 => VolatilityLevel::Low,            3..=10 => VolatilityLevel::Medium,            _ => VolatilityLevel::High,        }    }    /// 最も変更頻度の高いファイルを取得    ///    /// # Arguments    /// * `n` - 取得する上位ファイル数    ///    /// # Returns    /// (ファイルパス, 変更回数) のタプルのベクター    fn top_volatile_files(&self, n: usize) -> Vec<(&str, usize)> {        let mut files: Vec<_> = self.file_changes            .iter()            .map(|(file, &count)| (file.as_str(), count))            .collect();        files.sort_by(|a, b| b.1.cmp(&a.1));        files.truncate(n);        files    }}バランススコアの計算/// Balancing Couplingのスコアを計算////// Khononovのモデルに基づき、Strength、Distance、Volatilityの/// 3次元からバランススコアを算出#[derive(Debug, Clone)]struct BalancedCouplingScore {    /// 結合の強さ: 0.0 (弱い) から 1.0 (強い)    strength: f64,    /// 距離: 0.0 (近い) から 1.0 (遠い)    distance: f64,    /// 変動性: 0.0 (安定) から 1.0 (頻繁に変更)    volatility: f64,}impl BalancedCouplingScore {    /// 新しいスコアを作成    ///    /// # Arguments    /// * `strength` - 結合の強さ (0.0-1.0)    /// * `distance` - 距離 (0.0-1.0)    /// * `volatility` - 変動性 (0.0-1.0)    ///    /// # Panics    /// 各値が 0.0-1.0 の範囲外の場合にパニック    fn new(strength: f64, distance: f64, volatility: f64) -> Self {        assert!((0.0..=1.0).contains(&strength), "strength must be 0.0-1.0");        assert!((0.0..=1.0).contains(&distance), "distance must be 0.0-1.0");        assert!((0.0..=1.0).contains(&volatility), "volatility must be 0.0-1.0");        Self {            strength,            distance,            volatility,        }    }    /// モジュラリティを計算    ///    /// # Formula    /// MODULARITY = STRENGTH XOR DISTANCE (論理的な意味での排他的論理和)    ///    /// 理想的な状態：    /// - 強い結合なら距離が近い (strength が高く distance が低い)    /// - 弱い結合なら距離が遠くても良い (strength が低く distance が高い)    ///    /// # Returns    /// モジュラリティスコア (0.0-1.0、高いほど良い)    fn calculate_modularity(&self) -> f64 {        // 強い結合 × 近い距離 = 良い（局所性が高い）        let ideal_close = self.strength * (1.0 - self.distance);        // 弱い結合 × 遠い距離 = 良い（疎結合が保たれている）        let ideal_far = (1.0 - self.strength) * self.distance;        ideal_close + ideal_far    }    /// バランススコアを計算    ///    /// # Formula    /// BALANCE = MODULARITY OR (NOT VOLATILITY) (論理的な意味での論理和)    ///    /// バランスが取れている状態：    /// - モジュラーである、または    /// - 変動性が低い（安定している）    ///    /// # Returns    /// バランススコア (0.0-1.0、高いほど良い)    fn calculate_balance(&self) -> f64 {        let modularity = self.calculate_modularity();        let stability = 1.0 - self.volatility;        // 論理和の近似：max を使用        modularity.max(stability)    }    /// 結合の問題点を識別    ///    /// # Returns    /// 検出された問題のリスト    fn identify_issues(&self) -> Vec<CouplingIssue> {        let mut issues = Vec::new();        // パターン1: グローバル複雑性        // 強い結合 + 遠い距離 = 変更の調整コストが高い        if self.strength > 0.7 && self.distance > 0.7 {            issues.push(CouplingIssue {                severity: IssueSeverity::High,                description: "Strong coupling over long distance increases global complexity"                    .to_string(),                recommendation: "Consider moving coupled components closer or reducing coupling strength"                    .to_string(),            });        }        // パターン2: ローカル複雑性        // 弱い結合 + 近い距離 = 不要な抽象化の可能性        if self.strength < 0.3 && self.distance < 0.3 {            issues.push(CouplingIssue {                severity: IssueSeverity::Medium,                description: "Weak coupling at close distance may indicate unnecessary indirection"                    .to_string(),                recommendation: "Consider consolidating components or increasing distance"                    .to_string(),            });        }        // パターン3: カスケード変更リスク        // 強い結合 + 高変動性 = 変更が広範囲に波及        if self.strength > 0.7 && self.volatility > 0.7 {            issues.push(CouplingIssue {                severity: IssueSeverity::Critical,                description: "Strong coupling with volatile component creates cascading change risk"                    .to_string(),                recommendation: "Isolate volatile components or reduce coupling strength"                    .to_string(),            });        }        // パターン4: 低モジュラリティ        let modularity = self.calculate_modularity();        if modularity < 0.4 {            issues.push(CouplingIssue {                severity: IssueSeverity::Medium,                description: format!("Low modularity score: {:.2}", modularity),                recommendation: "Review coupling strength and distance relationship"                    .to_string(),            });        }        issues    }}/// 結合に関する問題#[derive(Debug, Clone)]struct CouplingIssue {    severity: IssueSeverity,    description: String,    recommendation: String,}/// 問題の重要度#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]enum IssueSeverity {    Low,    Medium,    High,    Critical,}実践的な使用例プロジェクト全体の分析必要な依存関係を追加します。[dependencies]syn = { version = "2.0", features = ["full", "visit"] }walkdir = "2.4"実装例です。use walkdir::WalkDir;use std::path::Path;use std::ffi::OsStr;use std::fs;/// プロジェクト全体のメトリクスを保持#[derive(Debug, Default)]struct ProjectMetrics {    measurements: Vec<CouplingMeasurement>,    file_count: usize,    module_count: usize,}/// 結合度の測定結果#[derive(Debug)]struct CouplingMeasurement {    from_module: String,    to_module: String,    strength: f64,    distance: f64,    volatility: f64,}/// プロジェクト全体を分析////// # Arguments/// * `project_path` - プロジェクトのルートパス////// # Returns/// プロジェクトメトリクス、またはエラー////// # Example/// ```/// let metrics = analyze_project("./src")?;/// println!("Total files analyzed: {}", metrics.file_count);/// ```fn analyze_project(project_path: &str) -> Result<ProjectMetrics, Box<dyn std::error::Error>> {    let mut project_metrics = ProjectMetrics::default();    // 1. 構造的な依存関係を分析    for entry in WalkDir::new(project_path)        .follow_links(true)        .into_iter()        .filter_map(|e| e.ok())    {        let path = entry.path();        // Rustファイルのみを処理        if path.extension() == Some(OsStr::new("rs")) {            analyze_rust_file(path, &mut project_metrics)?;        }    }    // 2. Git履歴から変動性を分析    let mut volatility = VolatilityAnalyzer::new();    volatility.analyze_git_history(6)?;    // 3. バランススコアを計算    calculate_balance_scores(&mut project_metrics, &volatility);    Ok(project_metrics)}/// 個別のRustファイルを分析////// # Arguments/// * `path` - ファイルパス/// * `project_metrics` - プロジェクトメトリクスの可変参照fn analyze_rust_file(    path: &Path,    project_metrics: &mut ProjectMetrics,) -> Result<(), Box<dyn std::error::Error>> {    let content = fs::read_to_string(path)?;    let syntax = syn::parse_file(&content)?;    let module_name = path        .to_string_lossy()        .replace('/', "::")        .replace(".rs", "");    let mut analyzer = CouplingAnalyzer::new(module_name);    analyzer.visit_file(&syntax);    project_metrics.file_count += 1;    project_metrics.module_count += 1;    Ok(())}/// バランススコアを計算してプロジェクトメトリクスに追加////// # Arguments/// * `metrics` - プロジェクトメトリクスの可変参照/// * `volatility` - 変動性アナライザーの参照fn calculate_balance_scores(    metrics: &mut ProjectMetrics,    volatility: &VolatilityAnalyzer,) {    for measurement in &metrics.measurements {        let score = BalancedCouplingScore::new(            measurement.strength,            measurement.distance,            measurement.volatility,        );        let issues = score.identify_issues();        if !issues.is_empty() {            eprintln!(                "Issues found in coupling from {} to {}:",                measurement.from_module, measurement.to_module            );            for issue in issues {                eprintln!("  [{:?}] {}", issue.severity, issue.description);            }        }    }}レポート生成use std::io::{self, Write};/// Markdownフォーマットでレポートを生成////// # Arguments/// * `metrics` - プロジェクトメトリクス/// * `writer` - 出力先 (stdout、ファイルなど)////// # Example/// ```/// let metrics = analyze_project("./src")?;/// generate_report(&metrics, &mut std::io::stdout())?;/// ```fn generate_report<W: Write>(    metrics: &ProjectMetrics,    writer: &mut W,) -> io::Result<()> {    writeln!(writer, "# Coupling Analysis Report\n")?;    // サマリーセクション    write_summary(metrics, writer)?;    // 統合強度の分布    write_strength_distribution(metrics, writer)?;    // 問題の検出    write_issues(metrics, writer)?;    // 変動性分析    write_volatility_analysis(metrics, writer)?;    Ok(())}/// サマリーセクションを出力fn write_summary<W: Write>(    metrics: &ProjectMetrics,    writer: &mut W,) -> io::Result<()> {    writeln!(writer, "## Summary\n")?;    writeln!(writer, "- **Total Files**: {}", metrics.file_count)?;    writeln!(writer, "- **Total Modules**: {}", metrics.module_count)?;    writeln!(        writer,        "- **Total Couplings**: {}\n",        metrics.measurements.len()    )?;    Ok(())}/// Integration Strengthの分布を出力fn write_strength_distribution<W: Write>(    metrics: &ProjectMetrics,    writer: &mut W,) -> io::Result<()> {    writeln!(writer, "## Integration Strength Distribution\n")?;    let total = metrics.measurements.len() as f64;    let contract = metrics        .measurements        .iter()        .filter(|m| m.strength <= 0.25)        .count();    let model = metrics        .measurements        .iter()        .filter(|m| m.strength > 0.25 && m.strength <= 0.50)        .count();    let functional = metrics        .measurements        .iter()        .filter(|m| m.strength > 0.50 && m.strength <= 0.75)        .count();    let intrusive = metrics        .measurements        .iter()        .filter(|m| m.strength > 0.75)        .count();    writeln!(        writer,        "- **Contract Coupling** (weakest): {} ({:.1}%)",        contract,        (contract as f64 / total) * 100.0    )?;    writeln!(        writer,        "- **Model Coupling**: {} ({:.1}%)",        model,        (model as f64 / total) * 100.0    )?;    writeln!(        writer,        "- **Functional Coupling**: {} ({:.1}%)",        functional,        (functional as f64 / total) * 100.0    )?;    writeln!(        writer,        "- **Intrusive Coupling** (strongest): {} ({:.1}%)\n",        intrusive,        (intrusive as f64 / total) * 100.0    )?;    Ok(())}/// 検出された問題を出力fn write_issues<W: Write>(    metrics: &ProjectMetrics,    writer: &mut W,) -> io::Result<()> {    writeln!(writer, "## Detected Issues\n")?;    let mut has_issues = false;    for measurement in &metrics.measurements {        let score = BalancedCouplingScore::new(            measurement.strength,            measurement.distance,            measurement.volatility,        );        let issues = score.identify_issues();        if !issues.is_empty() {            has_issues = true;            writeln!(                writer,                "### {} → {}\n",                measurement.from_module, measurement.to_module            )?;            for issue in issues {                writeln!(writer, "**{:?}**: {}", issue.severity, issue.description)?;                writeln!(writer, "- *Recommendation*: {}\n", issue.recommendation)?;            }        }    }    if !has_issues {        writeln!(writer, "No significant coupling issues detected.\n")?;    }    Ok(())}/// 変動性分析を出力fn write_volatility_analysis<W: Write>(    metrics: &ProjectMetrics,    writer: &mut W,) -> io::Result<()> {    writeln!(writer, "## High Volatility Analysis\n")?;    // 高変動性のファイルを抽出    let high_volatility: Vec<_> = metrics        .measurements        .iter()        .filter(|m| m.volatility > 0.7)        .collect();    if high_volatility.is_empty() {        writeln!(writer, "No high volatility modules detected.\n")?;    } else {        writeln!(writer, "Modules with high change frequency:\n")?;        for measurement in high_volatility {            writeln!(                writer,                "- `{}` (volatility: {:.2})",                measurement.from_module, measurement.volatility            )?;        }        writeln!(writer)?;    }    Ok(())}実践的なガイドライン結合度を改善するためのパターン1. 強い結合が必要な場合は距離を近くする頻繁に一緒に変更される機能は、同じモジュール内に配置するべきだ。// Good: 密接に関連する機能を同じモジュールに配置mod user_profile {    pub struct User { /* ... */ }    pub struct UserProfile { /* ... */ }    // Userと常に一緒に使われる    impl User {        pub fn get_profile(&self) -> &UserProfile { /* ... */ }    }}DDD 的に言えば、同じ Bounded Context 内の概念は同じモジュールに配置する。2. 弱い結合なら距離を遠くしても良いインターフェース（trait）を通じた疎結合なら、別クレートに分けても問題ない。// core/src/lib.rs - インターフェース定義pub trait NotificationService {    fn send(&self, message: &str) -> Result<(), Error>;}// adapters/email/src/lib.rs - 実装は別クレートuse core::NotificationService;pub struct EmailService;impl NotificationService for EmailService {    fn send(&self, message: &str) -> Result<(), Error> { /* ... */ }}3. 高変動性のコードは低結合に保つビジネスロジック（Core Subdomain）は頻繁に変更される。他への影響を最小化するため、低結合に保つ必要がある。// Strategy Patternで変動性を隔離pub trait PricingStrategy {    fn calculate(&self, base_price: f64) -> f64;}pub struct StandardPricing;impl PricingStrategy for StandardPricing {    fn calculate(&self, base_price: f64) -> f64 {        base_price // ビジネスルールの変更がここに限定される    }}pub struct Order {    pricing: Box<dyn PricingStrategy>, // Dependency Injection}4. Connascenceを意識したリファクタリングパターン1: Position → Name// Before: Connascence of Position（悪い例）fn create_user(name: String, email: String, age: u32, country: String) -> User {    // 引数の順序に依存}// After: Connascence of Name（良い例）struct UserBuilder {    name: String,    email: String,    age: u32,    country: String,}impl UserBuilder {    fn name(mut self, name: String) -> Self {        self.name = name;        self    }    // 他のフィールドも同様}パターン2: Meaning → Name// Before: Connascence of Meaning（悪い例）if status == 1 { /* active */ }else if status == 2 { /* inactive */ }// After: Connascence of Name（良い例）#[derive(Debug, Clone, Copy, PartialEq, Eq)]enum UserStatus {    Active,    Inactive,    Suspended,}if status == UserStatus::Active { /* ... */ }おわりにVlad Khononov の「Balancing Coupling」フレームワークが教えてくれるのは、単なる「強い/弱い」という二元論を超えた結合度の見方だ。結合の強さ、距離、変動性——この3つの軸で測定することで、より細かい粒度での分析が可能になる。この調査を通じて明らかになったのは、Rust エコシステムには部分的に役立つツールは存在するものの、Balancing Coupling の概念を完全に体現するツールはまだ存在しないということだった。cargo-modules、rust-code-analysis、cargo tree といった既存ツールは、それぞれが異なる視点からコードを照らし出してくれる。しかし、Integration Strength の分類、Dynamic Connascence の検出、変動性の分析、そしてバランススコアの計算——これらを統合的に扱うには、カスタム実装が必要だ。そこで、本記事で紹介した設計をベースに、実際に動作するツールを作成していく。 syn クレートによる AST 解析、Git 履歴からの変動性測定、そして Khononov のフレームワークに基づくバランス評価——これらを組み合わせた実用的なツールだ。コードの「ちょうどいい距離感」を数値化し、可視化することで、リファクタリングの指針となることを目指す。ここで忘れてはいけないのは、結合をゼロにするのが目的ではないということだ。人間関係と同じように、コードにも「適切な距離感」がある。密接に関連する機能は、むしろ強く結合すべきだ。無理に引き離せば、かえって複雑になる。定期的な測定と分析により、過度な抽象化を避けつつ、柔軟で進化可能な設計を維持していこう。コードの「ちょうどいい距離感」は、測定することで初めて見えてくる。ネットワーク・エフェクト 事業とプロダクトに欠かせない強力で重要なフレームワーク作者:アンドリュー・チェン日経BPAmazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Gemini Enterprise（旧Google Agentspace）を活用する]]></title>
            <link>https://sreake.com/blog/get-started-with-gemini-enterprise/</link>
            <guid isPermaLink="false">https://sreake.com/blog/get-started-with-gemini-enterprise/</guid>
            <pubDate>Fri, 31 Oct 2025 01:22:38 GMT</pubDate>
            <content:encoded><![CDATA[Gemini Enterprise（旧Google Agentspace）の概要 2025/10/10まではGoogle Agentspaceと呼ばれていたGoogle AIアシスタントサービスのサービス名称変更が行われ […]The post Gemini Enterprise（旧Google Agentspace）を活用する first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[【初心者向け】Snowflakeロールベースアクセス制御（RBAC）解説]]></title>
            <link>https://sreake.com/blog/learn-about-snowflake-role-based-access-control/</link>
            <guid isPermaLink="false">https://sreake.com/blog/learn-about-snowflake-role-based-access-control/</guid>
            <pubDate>Fri, 31 Oct 2025 01:21:49 GMT</pubDate>
            <content:encoded><![CDATA[はじめに Snowflakeでデータ分析基盤を構築するうえで、最も重要な要素の一つがロール管理です。これはデータガバナンスの活動の第一歩の位置付けでもあり、さらにはある程度成熟された基盤の状態からロールを再設計するコスト […]The post 【初心者向け】Snowflakeロールベースアクセス制御（RBAC）解説 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Cloud Run FunctionsにTerraformを使ってデプロイしてみた]]></title>
            <link>https://zenn.dev/akasan/articles/d94c8407a99c90</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/d94c8407a99c90</guid>
            <pubDate>Thu, 30 Oct 2025 12:39:31 GMT</pubDate>
            <content:encoded><![CDATA[今回はTerraformを利用してCloud Run Functionsにサービスをデプロイしてみました。 構築するアーキテクチャ今回構築するアーキテクチャは以下のようになっています。Cloud Storageでは提供するアプリケーションのソースコードをZIPファイルで格納し、Cloud Run FunctionsではCloud Storageからソースコードを参照した上でサービスを展開します。 早速構築 Pythonアプリケーションの実装今回は呼び出すとHello World!と返すエンドポイントの提供を目指します。そのような仕組みを実現するために必要なファイルは以下...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[構造的類似性を捉える技術 - similarity-rsで学ぶAST-basedコード解析の実装]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/10/30/203342</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/10/30/203342</guid>
            <pubDate>Thu, 30 Oct 2025 11:33:42 GMT</pubDate>
            <content:encoded><![CDATA[github.comはじめにコードベースが大きくなるにつれて、似たようなコードが散らばっていることに気づく瞬間がある。「あれ、これ前にも書いたような...」そう思いながらコードを眺めるのだけれど、変数名が微妙に違っていたり、処理の順序が少しずれていたりして、結局は共通化できないまま放置してしまう。そんな経験は、プログラマなら誰しも一度や二度ではないはずだ。そして、生成AI時代の今、この問題はさらに深刻になっている。AIがコードを生成してくれるのは便利だけれど、同じような処理を少しずつ違う形で何度も生成してしまうことがある。人間が書いたコードなら「ああ、これは前に書いたやつだ」と気づけるのに、AIが生成したコードは一見して判別がつかない。気づけばコードベースは「似て非なるコード」で溢れかえり、保守性は急速に失われていく。生成AI時代だからこそ、コードの構造的な類似性を見抜く技術が、これまで以上に必要とされているのだ。私は、結合度を測って適切にリファクタリングを促すツールを開発したいと考えていた。そのヒントを探していたときに出会ったのが、@mizchiさんのsimilarityプロジェクトだった。このプロジェクトの中でも特に、Rustへの実装であるsimilarity-rsの仕組みに惹かれ、その内部構造を詳しく調査することにした。この記事は、そこで得られた発見の記録である。syu-m-5151.hatenablog.com実際の使用例は以下です。# インストール（Cargo経由）cargo install similarity-rs# プロジェクトルートで実行similarity-rs .# より詳細なオプションを確認similarity-rs -h# AI によって修正させる場合Run `similarity-rs .` to detect semantic code similarities. Execute this command, analyze the duplicate code patterns, and create a refactoring plan. Check `similarity-rs -h` for detailed options.実行すると、以下のように重複コードを検出します。Duplicates in src/utils.rs:────────────────────────────────────────────────────────────src/utils.rs:10 | L10-15 similar-function: calculateSumsrc/utils.rs:20 | L20-25 similar-function: addNumbersSimilarity: 85.00%, Priority: 8.5 (lines: 10)これがどうやって実現されているのか、その内部実装を紐解いていきます。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。similarity-rsとは何か？similarity-rs は、similarity の中の Rust プロジェクトのコード重複を検出する CLI ツールです。ただし、単純なテキストマッチングではありません。抽象構文木（AST）を使った構造的な比較により、変数名が違っても本質的に同じ処理をしている関数を見つけ出せます。例えば、以下の 2 つの関数は変数名が違いますが、similarity-rs は「これらは似ている」と判断できます。fn calculate_total(items: Vec<i32>) -> i32 {    let mut sum = 0;    for item in items {        sum += item;    }    sum}fn add_numbers(values: Vec<i32>) -> i32 {    let mut result = 0;    for value in values {        result += value;    }    result}テキストベースの diff ツールなら「全然違う」と判断する場合でも、similarity-rs は「構造が同じ」と判定できます。技術スタックの全体像similarity-rs の核となる技術は 2 つです。tree-sitter - Rust コードを解析して AST を生成APTED (All Path Tree Edit Distance) - 2 つの AST の距離を計算この 2 つを組み合わせることで、「コードの意味的な類似度」を数値化しています。なぜtree-sitterなのか？tree-sitter は、GitHub が開発した高速でインクリメンタルなパーサーです。rustc の手書きパーサーと比べると初回パースは 2-3 倍遅いですが、以下の利点があります。インクリメンタルパース: コードの一部が変更されたとき、変更部分だけ再パースできる堅牢性: 構文エラーがあっても部分的にパースを続行できる多言語対応: 同じインターフェースで複数の言語に対応実測値は次のとおりです。2157行のRustファイル（約64KB）のパース時間：- 初回: 約6.48ms- インクリメンタル更新: 1ms未満- スループット: 約9908 bytes/ms初回パースで約 6.48ms、インクリメンタル更新では 1ms 未満という実測値が得られています。ASTベース比較の仕組みStep 1: コードをASTに変換するまず、Rust コードを tree-sitter でパースします。use tree_sitter::{Parser, Language};let mut parser = Parser::new();parser.set_language(&tree_sitter_rust::LANGUAGE.into())    .expect("Error loading Rust grammar");let source_code = "fn test() { println!(\"hello\"); }";let tree = parser.parse(source_code, None).unwrap();生成される AST は、以下の階層構造になります。source_file└── function_item    ├── fn (keyword)    ├── identifier: "test"    ├── parameters    └── block        └── macro_invocation            └── ...Step 2: 関数を抽出するAST から関数定義を抽出します。この時、以下のような工夫がされています。fn extract_functions(tree: &Tree, source: &str) -> Vec<Function> {    let mut functions = Vec::new();    let root = tree.root_node();        fn visit_node(node: Node, source: &str, functions: &mut Vec<Function>) {        match node.kind() {            "function_item" => {                // テスト関数は除外                if !is_test_function(&node, source) {                    functions.push(Function::from_node(node, source));                }            }            "impl_item" => {                // implブロック内のメソッドも処理                for child in node.children() {                    if child.kind() == "function_item" {                        if !is_test_function(&child, source) {                            functions.push(Function::from_node(child, source));                        }                    }                }            }            _ => {                // 再帰的に子ノードを探索                for child in node.children() {                    visit_node(child, source, functions);                }            }        }    }        visit_node(root, source, &mut functions);    functions}注目すべき点として、テスト関数は自動的に除外されます。以下の 3 つの方法で検出します。#[test] 属性がついている関数test_ で始まる関数名（Rust の慣習）#[cfg(test)] モジュール内の関数これにより、本番コードの重複だけに集中できます。Step 3: 木構造の編集距離（TSED）を計算するここが最も興味深い部分です。2 つの AST がどれだけ「似ているか」を測定するために、Tree Edit Distance（木構造の編集距離）を使用します。木構造の編集距離とは？木構造を別の木構造へ変換する際に必要な「編集操作の最小回数」です。編集操作は 3 種類あります。Insert（挿入）: ノードを追加Delete（削除）: ノードを削除Rename（名前変更）: ノードのラベルを変更例を示します。Tree 1:          Tree 2:   A                A  / \              / \ B   C            B   D編集操作：1. C を D に Rename編集距離 = 1APTEDアルゴリズムsimilarity-rs は、APTED (All Path Tree Edit Distance) アルゴリズムを使用しています。これは 2015-2016 年に Pawlik と Augsten が発表したアルゴリズムで、以下の特徴があります。最適な分解戦略: 木を最も効率的に分解して計算動的計画法: 部分問題の結果をメモ化して再利用時間計算量: O(n·m) - 理論的に最適実装の概要は以下のとおりです。fn calculate_similarity(tree1: &TreeNode, tree2: &TreeNode, options: &TSEDOptions) -> f64 {    // APTEDで編集距離を計算    let edit_distance = compute_edit_distance(tree1, tree2);        // 正規化：類似度スコア（0.0〜1.0）に変換    let max_nodes = max(tree1.node_count(), tree2.node_count());    let base_similarity = 1.0 - (edit_distance as f64 / max_nodes as f64);        // サイズ差ペナルティを適用（オプション）    if !options.no_size_penalty {        let size_ratio = min_size as f64 / max_size as f64;        base_similarity * size_ratio    } else {        base_similarity    }}重要な発見として、ACL 2024 の研究論文（Song et al.）によると、以下の重みが最適とされています。Insert: 0.8Delete: 1.0Rename: 1.0この重みは実験によって導き出されたもので、48 以上のプログラミング言語で有効性が実証されています。ただし、similarity-rsの現在のデフォルト実装では異なる設定が使用されています。Rename: 0.3（デフォルト）Delete: 1.0Insert: 1.0研究論文で推奨される最適値とは異なりますが、--rename-costオプションで調整可能です。パフォーマンス最適化の技術1. Rayonによる並列処理similarity-rs の最大の強みの 1 つが、Rayon を使った並列処理です。use rayon::prelude::*;// ファイルを並列処理files.par_iter()    .flat_map(|file| extract_functions(file))    .collect()// 関数比較も並列化functions.par_iter()    .enumerate()    .flat_map(|(i, func1)| {        functions[i+1..].par_iter()            .map(|func2| compare_functions(func1, func2))    })    .filter(|similarity| similarity.score > threshold)    .collect()Rayon の優れた特徴は次のとおりです。ワークスティーリング: CPU コア間で自動的に負荷分散データ競合フリー: Rust の型システムが保証（Send + Syncトレイト）ゼロ同期オーバーヘッド: データ共有が不要な場合線形スケーラビリティ: CPU コア数に応じてほぼ線形に高速化実際のベンチマークでは、中規模ファイルで逐次処理比16倍の高速化が確認されています。2. ブルームフィルタによる事前フィルタリングTypeScript 版（similarity-ts）で先行実装され、Rust 版でも部分的にサポートされています。高速化に大きく貢献するテクニックです。struct AstFingerprint {    bloom_filter: BloomFilter,           // 確率的集合メンバーシップ    node_types: HashSet<NodeKind>,    signature: u64,                      // ハッシュベース署名}fn quick_reject(&self, func1: &FunctionDef, func2: &FunctionDef) -> bool {    let intersection = self.bloom_filter        .estimate_intersection(&func1.fingerprint, &func2.fingerprint);        let estimated_similarity = intersection / max(func1.size, func2.size);    estimated_similarity < self.min_similarity_threshold}この手法による効果は次のとおりです。比較回数を 70-90%削減偽陽性率 1%未満TypeScript 版で約 4 倍の高速化を実現明らかに違う関数ペアを高価な TSED 計算の前に除外できるため、全体の処理時間が 70-90%削減されます。Rust 版での実装状況は次のとおりです。crates/core/src/ast_fingerprint.rsにブルームフィルタの基礎実装が存在--no-fastオプションでブルームフィルタを無効化可能TypeScript 版ほど最適化されていないが、将来的な改善が期待される3. メモリ最適化の工夫Rust の所有権システムとゼロコスト抽象化を活かした最適化がいくつも施されています。ライフタイム注釈によるゼロコピーの例を示します。pub struct FunctionComparison<'a> {    func1: &'a FunctionDefinition,    func2: &'a FunctionDefinition,    similarity: f64,}データをクローンせず、参照を渡すだけで済みます。イテレータチェーンによる変換の例を示します。let similar_pairs: Vec<_> = functions.iter()    .enumerate()    .flat_map(|(i, f1)| {        functions.iter()            .skip(i + 1)            .filter_map(|f2| {                let sim = calculate_similarity(f1, f2);                (sim > threshold).then_some((f1, f2, sim))            })    })    .collect();この書き方の利点は次のとおりです。イテレータチェーンはタイトなループにコンパイルされる中間値のヒープアロケーションが発生しない遅延評価により、collectされるまで計算しない実際の使い方と出力フォーマット基本的な使い方# カレントディレクトリを解析similarity-rs .# 類似度の閾値を指定（デフォルト: 0.85）similarity-rs . --threshold 0.9# テスト関数をスキップsimilarity-rs . --skip-test# ファイル間の比較も有効化similarity-rs . --cross-file# コードスニペットを出力に含めるsimilarity-rs . --print# 最小トークン数を指定（小さい関数を除外）similarity-rs . --min-tokens 50出力の読み方Duplicates in src/utils.rs:────────────────────────────────────────────────────────────src/utils.rs:10 | L10-15 similar-function: calculateSumsrc/utils.rs:20 | L20-25 similar-function: addNumbersSimilarity: 85.00%, Priority: 8.5 (lines: 10)────────────────────────────────────────────────────────────src/utils.rs:30 | L30-40 similar-function: processDatasrc/handlers.rs:50 | L50-60 similar-function: handleRequestSimilarity: 92.00%, Priority: 11.5 (lines: 12)Priority は次の計算式で求められます: 行数 × 類似度スコアこれにより、影響度の高い重複（長くて似ている）を優先的に見つけられます。VSCode 互換の出力フォーマットを採用しており、ターミナルからファイル名をクリックすることで該当箇所に直接ジャンプできます。処理フローの全体像similarity-rs がどのように動作するのか、全体の流れを説明します。1. ファイル検索   └─> ディレクトリを再帰的にスキャンして.rsファイルを検索   2. パース段階   └─> 各ファイルに対して:       ├─> tree-sitterがソースをASTにパース       └─> ASTから関数ノードを抽出       3. フィルタリング段階   └─> 各関数に対して:       ├─> 最小行数/トークン数をチェック       ├─> テスト関数かチェック（--skip-test有効時）       └─> 合格すれば候補プールに追加       4. 特徴抽出（高速モード）   └─> ブルームフィルタ用のAST特徴を抽出   └─> 各関数のブルームフィルタを構築   5. 候補ペア生成   └─> 比較する関数ペアを生成       ├─> 同一ファイル内ペア（デフォルト）       └─> ファイル間ペア（--cross-file時）       6. ブルームフィルタ事前フィルタリング   └─> ブルームフィルタで高速チェック   └─> 明らかに異なるペアを除外   7. TSED計算   └─> 残りのペアに対して:       ├─> APTEDで木編集距離を計算       ├─> サイズペナルティを適用（有効時）       └─> 類似度スコアに正規化       8. 閾値フィルタリング   └─> 類似度 >= 閾値のペアを保持   9. 出力生成   └─> 結果をフォーマット（JSONまたは人間可読）   └─> --printフラグ時はコードスニペットを含むTypeScript版（similarity-ts）との比較mizchi さんのプロジェクトには、TypeScript 版も存在します。各実装の特徴を比較します。アーキテクチャの違い 側面  similarity-ts  similarity-rs  パーサー  oxc-parser（Rust製）  tree-sitter-rust  メモリ管理  アリーナアロケーション  標準ヒープ  高速モード  ブルームフィルタ完全実装  部分的実装  型チェック  実験的サポート  実験的サポート（--experimental-types） パフォーマンス比較実際のベンチマーク結果に基づく比較を示します。similarity-rs（Rust 版）の利点は次のとおりです。中規模ファイルで約 16 倍高速（ネイティブコードの効率性）メモリ使用量が一定（Rc による参照カウント）大規模ファイルでも安定動作（TypeScript は OOM エラー発生）ネイティブ Rust コード（FFI オーバーヘッドなし）Rust 固有機能（#[test]属性の検出など）similarity-ts（TypeScript 版）の利点は次のとおりです。小規模ファイルではやや高速（0.74x、プロセス起動オーバーヘッドなし）ブルームフィルタ高速モードで約 4 倍高速化oxc-parser による高速パース（swc より 3 倍高速）アリーナアロケーションによるキャッシュ局所性向上JavaScript エコシステムとの統合が容易言語固有機能similarity-ts の機能は次のとおりです。型類似度検出クラス比較サポートデコレータサポートsimilarity-rs の機能は次のとおりです。implブロック解析テスト関数フィルタリングトレイト実装検出研究基盤と理論的背景similarity-rs の背後には、しっかりとした研究基盤があります。TSED研究論文（Song et al., ACL 2024）この研究では、48 以上のプログラミング言語で TSED の有効性が実証されました。BLEU および Jaccard 類似度と 0.6-0.8 の相関実行一致に関して意味論的メトリクスより高精度最適重み: Insert=0.8、Delete=1.0、Rename=1.0APTEDアルゴリズム（Pawlik & Augsten, 2015-2016）木編集距離の堅牢な実装を提供し、メモリ使用量を抑制最適な分解戦略により O(n·m) の時間計算量で動作以前のアルゴリズム（RTED、Demaine など）を凌駕学術的にも裏付けられた手法を使っている点は信頼性が高いです。実用例：リファクタリング計画の立て方実際の使用方法とリファクタリングへの活用方法を説明します。Step 1: 重複コードを検出similarity-rs . --threshold 0.85 --skip-test > duplicates.txtStep 2: 優先度の高い重複を確認出力の Priority スコアを見て、影響の大きい重複から着手します。Priority: 11.5 (lines: 12, similarity: 92%)Step 3: リファクタリング方針を決定検出された重複コードを見て、以下を判断します。共通化できる場合共通関数として抽出部分的に共通化できる場合共通部分を関数として抽出差分をパラメータ化偶然の重複である場合本質的に異なる処理なので、そのままStep 4: 継続的なモニタリングCI/CD パイプラインに組み込んで、新しい重複が生まれないか監視します。# .github/workflows/code-quality.yml- name: Check code duplication  run: |    similarity-rs . --threshold 0.85 --skip-test    if [ $? -ne 0 ]; then      echo "Warning: Code duplication detected"      # Slackに通知するなど    fi制限事項と今後の展望現在の制限公式ドキュメントにも明記されていますが、similarity-rs は実験段階です。プロダクション環境での検証が不十分ブルームフィルタが部分的実装（similarity-ts ほど最適化されていない）マクロヘビーなコードには制限があるrustc パーサーより 2-3 倍遅い（初回パース時）既知の問題（KNOWN_ISSUES.md より）は次のとおりです。Enum similarity detection: 構造的に同一の Enum でも約 43%の類似度しか検出されない原因: Enum の variant 名が value として扱われ、rename_cost パラメータで適切に処理されない回避策: Enum 比較時は閾値を 0.4-0.5 に下げるStruct similarity detection: 正常に動作（90%以上の類似度を検出）similarity-rsから学んだことsimilarity-rs を深掘りした結果、このツールから多くの重要な学びを得ることができました。まず最も印象的だったのは、ASTベース解析の威力です。従来のテキストベースの類似度検出では、表面的な文字列の一致に頼るため、変数名やコメントの違いによって本質的に同じコードを見逃してしまうことがありました。しかし、AST ベースのアプローチでは構造的な類似性を捉えることができます。変数名が異なっていても、処理のロジックや制御構造が同じであれば、それを的確に検出できる点は非常に強力です。次に感銘を受けたのは、Rust の型システムが可能にする最適化です。Rust の所有権システムは、メモリ安全性をコンパイル時に保証します。さらに、ゼロコスト抽象化により、高レベルな記述をしながらも実行時のオーバーヘッドを最小限に抑えられます。加えて、充実した並行処理プリミティブにより、マルチスレッド処理を安全に記述できます。これらの特性を組み合わせることで、安全性とパフォーマンスを両立したツールの実装が実現されています。また、実装の随所に見られる実用的な最適化の積み重ねも注目に値します。ブルームフィルタによる事前フィルタリングで不要な比較を削減し、Rayon を活用した並列処理で処理速度を向上させています。さらに、テスト関数の自動除外や最小トークン数によるフィルタリングなど、実際の開発現場で役立つ工夫が随所に施されています。このような小さな最適化の積み重ねが、理論だけでなく実用的なツールを作り上げる鍵となることを実感しました。最後に、このツールはACL 2024の論文をベースにした実装である点も重要です。学術研究で提案されたアイデアを、実際に動作するソフトウェアとして具現化しており、理論と実践の橋渡しをしている好例と言えます。研究成果を実装に落とし込む過程で、どのような工夫や最適化が必要になるのかを学ぶことができました。おわりに冒頭で述べた「結合度を測って適切にリファクタリングを促すツール」について、similarity-rs から学んだアプローチを応用できます。AST ベースの解析で構造的な類似性を捉える並列処理で大規模コードベースにも対応優先度スコアでリファクタリングの優先順位を示すCI/CD 統合で継続的にコード品質を監視similarity-rs の実装を理解したことで、自分が作りたいツールの具体的なイメージが明確になりました。GitHub リポジトリで実装の詳細を確認できます。コードは読みやすく構成されているため、Rust の学習にも適した教材です。Tidy First? ―個人で実践する経験主義的ソフトウェア設計作者:Kent Beckオーム社Amazon参考文献mizchi/similarity - GitHubZenn記事：TypeScript/Rustで高速なコード類似度検出ツールを作るtree-sitter - Official DocumentationRayon - Data Parallelism in Rust]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Trayce, a Raycast Extension for Tokyo AI Hackathon 2025]]></title>
            <link>https://speakerdeck.com/ota1022/trayce-a-raycast-extension-tokyo-ai-hackathon-2025</link>
            <guid isPermaLink="false">https://speakerdeck.com/ota1022/trayce-a-raycast-extension-tokyo-ai-hackathon-2025</guid>
            <pubDate>Thu, 30 Oct 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[The pitch deck for a Raycast extension called Trayce, created at the Tokyo AI Hackathon.https://raycast.connpass.com/event/369928/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[WebSocket入門：GoでEcho/Chat機能を実装してみた]]></title>
            <link>https://zenn.dev/takehiro1111/articles/go_web_socket</link>
            <guid isPermaLink="false">https://zenn.dev/takehiro1111/articles/go_web_socket</guid>
            <pubDate>Thu, 30 Oct 2025 02:43:23 GMT</pubDate>
            <content:encoded><![CDATA[1.記事を書いた背景WebSocket の実装が初めてだったこともあり、頭の中を整理しておこうと思い記事にしました。全然関係ないですが、1 年くらい前にプロダクトへサーバレス構成でチャット機能を実装する時にインフラ側の基盤を作ったのが懐かしく感じました。 2.対象読者WebSocket って聞いたことあるけど何だっけという方(自分みたいな)実装レベルで気になる方(自分みたいな) 3.WebSocket とは？WebSocket API は、ユーザーのブラウザーとサーバー間で対話的な通信セッションを開くことができるものです。この API を使用すると、サーバー...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Pythonのlistとsetでの値の含み判定の所要時間について]]></title>
            <link>https://zenn.dev/akasan/articles/b9e7806e438f8f</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/b9e7806e438f8f</guid>
            <pubDate>Wed, 29 Oct 2025 11:40:49 GMT</pubDate>
            <content:encoded><![CDATA[今回はPythonのlistとsetでデータが含まれているかどうかを判定するためのロジックの所要時間の差について調べてみました。Pythonの仕様として、単純にデータを列挙しておきたいだけの場合にlistを利用せずsetを利用する方が良い場合もあり個人的に気をつけていましたが、以下の記事をみて実際にlistとsetでどれくらい差が出るかを調べてみようと思いました。今回は値の一覧に特定の値が含まれているかを判定するのにかかる時間を調べてみました。https://medium.com/the-pythonworld/stop-using-if-x-in-list-heres-the-fas...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rayシリーズ：NumPyやpandasデータをRay Dataで取り込む]]></title>
            <link>https://zenn.dev/akasan/articles/db0b5b634d453d</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/db0b5b634d453d</guid>
            <pubDate>Tue, 28 Oct 2025 14:21:11 GMT</pubDate>
            <content:encoded><![CDATA[今回はRay Dataを利用して、NumPyとpandasのデータを読み込む方法をまとめます。 早速試してみる内容はこちらを参考にしています。https://docs.ray.io/en/latest/data/loading-data.html#loading-data-from-other-libraries 環境構築uvを利用して以下のように構築します。uv init ray_data_numpy_pandas -p 3.12cd ray_data_numpy_pandasuv add "ray[data]" numpy pandas NumPyからデータを...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ソフトウェアエンジニアにおける才能という幻想、あるいは成長を阻む最大の敵について]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/10/28/113009</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/10/28/113009</guid>
            <pubDate>Tue, 28 Oct 2025 02:30:09 GMT</pubDate>
            <content:encoded><![CDATA[はじめに「才能がない」と言われたことがあるでしょうか。それとも、友人や知り合いと自分を比べて、自分で自分にそう言い聞かせたことがあるでしょうか。学生の頃からエンジニアを志してきた私は、コンテストで優秀な成績を残す人たちを目の当たりにしてきました。大手IT企業に入社し、優秀な同期と出会いました。勉強会やカンファレンスに足を運び、そこで出会った人たちの軌跡を追ってきました。華々しくスタートアップを立ち上げた人、革新的なプロダクトを生み出した人、OSSコミュニティで名を馳せる人。一方で、いつの間にか表舞台から姿を消した人もいます。これらがごく一部の狭い世界でしかないことも、自覚しています。そして今、インターンシップやワークショップで若手エンジニアと接する機会が増えました。3年ほど前に始めたこの活動──正直に言うと、自分が未熟なまま始めてしまったという不安は、今でもどこかにあります。彼らと一緒に作業する中で、「才能がない」と自己評価する学生やインターン生に出会うことがよくあります。彼らは真剣な表情で「自分には向いていないかもしれません」と告げます。コードを書くのが遅い。エラーの意味が理解できない。他の人は簡単にできることが、自分には難しい──そう語る彼らの目には、諦めと不安が混じっています。私はその度に、ある問いを投げかけます。「才能って、何だと思う?」「君には才能がある」とも「才能なんて関係ない」とも言わず、まず考えてもらう。しかし大抵の場合、明確な答えは返ってきません。実は、私もかつて、才能という言葉に深く囚われていました。コンテスト会場で、企業の開発フロアで、勉強会の懇親会で、私は何度も「天才」と呼ばれるエンジニアたちに出会いました。彼らは難解なアルゴリズムを一瞬で理解し、複雑なバグを数分で特定し、誰も思いつかないような解決策を次々と生み出していました。そして私は何度も思いました。「自分には才能がない」と。しかし、多くの「一流」と呼ばれる人々と接し、彼らの日常を観察し、そして時には彼らが立ち止まる瞬間や、消えていく瞬間も目撃する中で、ある重要な事実に気づきました。才能という言葉は、実は成長を阻む最大の敵なのかもしれない。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。技術力という幻想才能について語る前に、まずソフトウェアエンジニアリングにおける「技術力」とは何かを整理しておく必要があります。我々の文脈では、才能という言葉はこの技術力と結びつけて語られることが多いためです。技術力という言葉の曖昧さ私たちは「技術力が高い」「技術力が低い」という言葉を安易に使いがちです。しかし、その実態は何でしょうか。率直に言えば、ソフトウェアエンジニアの「技術力」と呼ばれるものの多くは、実は「ちょっと詳しい」「似たようなトラブルを経験している」「これとこれを組み合わせれば行けそう」という程度のものです。私が使ってきた「エンジニアリング」という言葉にも、工学的な要素はあまり含まれていませんでした。正しくは「テクニック」──つまり、実践的な技術や方法論の集積です。特別なスキルというよりは、日々の積み重ねで身につく経験知なのです。では、技術力とは何なのか。私の観察では、それは大きく二つの軸に分解できます。一つは「経験の蓄積」、もう一つは「洞察力としてのセンス」です。センスは知識からはじまる作者:水野学朝日新聞出版Amazon第一の軸：経験の蓄積技術力の第一の要素は、経験の蓄積です。これは、しばしば「同じ失敗を繰り返さない力」として評価されます。具体的には、こういうことです。あるエラーに遭遇したとき、以前に似たようなエラーを見たことがあれば、解決は早くなります。データベースのデッドロック、非同期処理のタイミング問題、キャッシュの不整合──こうした問題は、一度経験していれば「ああ、これか」と気づけます。これは確かに価値のある能力です。経験豊富なエンジニアが重宝されるのは、このためです。しかし、これを「才能」と呼ぶのは適切でしょうか。違います。これは単に時間をかけて様々な問題に向き合った結果であり、誰でも積み重ねられるものです。早く始めた人、多く失敗した人が、より多くの経験を持っているだけです。具体と抽象作者:細谷 功dZERO（インプレス）Amazon第二の軸：洞察力としてのセンス技術力のもう一つの要素、それが「センス」です。音楽をやっている人たちの中で「あいつは耳が良い」と評価される能力があります。単に楽器を弾く技術だけでなく、音のバランス、リズムの微妙なズレ、和音の響き方──こうした細部を感じ取る力のことです。ソフトウェアエンジニアリングにも、これに似たものがあります。コードを見たとき、「このコード、何か変だな」と直感的に感じる。実行する前から「ここでバグが出そう」と予感する。設計図を見て「この構造は将来的に問題になる」と察知する。これが、エンジニアにおける「センス」です。重要なのは、これは単なる経験の蓄積とは質的に異なるということです。同じ年数働いていても、このセンスを持つ人と持たない人がいます。では、このセンスとは何なのでしょうか。センスの哲学 (文春e-book)作者:千葉 雅也文藝春秋Amazonセンスの正体──三つの具体的な現れ方センスは抽象的な概念に聞こえますが、実は具体的に分解できます。私の観察では、センスは主に三つの形で現れます。1. 細部への注目力センスのあるエンジニアは、コード全体の機能だけでなく、細部のリズムやバランスに気づきます。例えば、関数の長さのバランス。あるファイルに25行の関数と5行の関数が混在しているとき、「なぜこの差があるのか」と気づきます。命名の一貫性。ある場所ではgetUserDataと書き、別の場所ではfetchUserと書いているとき、その揺らぎに違和感を覚えます。これらは動作に直接影響しないこともあります。でも、コードの「匂い」として現れます。そして、この匂いに気づけるかどうかが、センスの有無を分けます。ルールズ・オブ・プログラミング ―より良いコードを書くための21のルール作者:Chris Zimmermanオーム社Amazon2. 構造の美しさへの感受性センスのあるエンジニアは、「美しいコード」と「醜いコード」を区別できます。そして最も重要なのは、なぜ美しいと感じるのか、その理由を言語化できることです。「この関数は単一責任原則を守っているから美しい」「この命名は意図が明確に伝わるから良い」「この抽象化は読みやすさと柔軟性を両立しているから綺麗」単に「良い」「悪い」と感じるだけでなく、その判断の根拠を意識できる。これがセンスです。そして、この言語化能力が、他者にも伝えられる知見へと昇華されます。Good Code, Bad Code ～持続可能な開発のためのソフトウェアエンジニア的思考作者:Tom Long秀和システムAmazon改訂新版　良いコード／悪いコードで学ぶ設計入門 ―保守しやすい　成長し続けるコードの書き方作者:仙塲 大也技術評論社Amazon3. 問題の本質を見抜く力最も価値が高いのは、表面的な問題の背後にある本質的な問題を見抜く力です。例えば、バグが報告されたとします。表面的には「nullポインタ例外」かもしれません。しかし、センスのあるエンジニアは、その背後に「状態管理の設計が不適切」という本質的な問題があることに気づきます。エラーログを見て、「このエラーが頻発しているということは、そもそもこの処理フローに問題がある」と洞察します。パフォーマンスの問題を見て、「これは単にクエリの最適化の問題ではなく、データモデルの設計から見直すべき」と判断します。この「一歩踏み込んで問題を捉える力」こそが、経験を超えたセンスの核心です。ライト、ついてますか　問題発見の人間学作者:ドナルド・C・ゴース,ジェラルド・M・ワインバーグ共立出版Amazonセンスは訓練できるのかここまで読んで、「じゃあセンスは才能じゃないか」と思うかもしれません。違います。センスも訓練できます。なぜなら、センスとは突き詰めれば「何に注目するか」という習慣と、「それを面白がれるか」という姿勢だからです。どちらも意識的に育てることができます。熟達論―人はいつまでも学び、成長できる―作者:為末大新潮社Amazon訓練法1：意識的な観察の習慣最初は意識的に練習します。コードレビューをするとき、ただ「動くか動かないか」だけでなく、以下の点に注目してみます。関数の長さのバランスは適切か命名に一貫性はあるか、揺らぎは意図的か抽象度の上下動に違和感はないかコメントの密度は適切か変数のスコープの範囲は適切か最初は面倒です。でも、こうした細部に意識的に注目する習慣を続けていると、やがて自然と細部が目に入るようになります。これがセンスを磨くということです。訓練法2：本質を掴む読み方優れたエンジニアのコードを読むとき、ただ写経するのではなく、その背後にある思考を読み取ろうとします。なぜこの構造を選んだのかなぜこの命名にしたのかなぜこの順序で処理しているのかなぜこの部分だけ抽象化したのかそして、そこから本質的な要素を抽出し、自分のコードに応用する。この「本質を掴む」プロセスを繰り返すことで、表面的なパターンの暗記を超えた理解が生まれます。訓練法3：面白がる回路を作る最も重要なのは、問題を面白がる姿勢を育てることです。センスのあるエンジニアは、エラーや問題を「厄介だ」ではなく「興味深い」と捉えています。この姿勢は、選択できるものです。最初は意識的に「これは面白い」と自分に言い聞かせます。「このバグ、再現条件が複雑で面白い」「このエラーメッセージ、何を伝えようとしているのか興味深い」「この設計の問題、どう解決すべきか考えるのが楽しい」こうした「面白がる回路」を作ることが、センスを磨く本質です。すると徐々に、本当に面白く感じられるようになってきます。そして、面白がれるようになると、自然と深く考えるようになり、結果としてセンスが磨かれます。技術力もセンスも、どちらも成長可能結局のところ、技術力を構成する二つの軸──経験の蓄積とセンスという洞察力──は、どちらも成長可能な能力です。経験は、時間をかけて多くの問題に向き合うことで自然と積み重なります。失敗を恐れず、様々なことに挑戦することで、経験値は増えていきます。センスは、意識的な訓練によって磨かれます。細部に注目し、本質を掴もうとし、問題を面白がることで、徐々に洞察力が深まっていきます。どちらも「才能」という固定的な能力ではありません。時間と意識的な努力によって育てられるスキルなのです。「あの人は技術力がある」と言われる人は、単に先に始めて多くの経験を積んだか、意識的にセンスを磨く習慣を持っているか、あるいはその両方です。そして、その両方とも、今からでも始められます。才能という名の逃避「才能がない」という言葉は、一見すると謙虚に聞こえます。しかし実のところ、これは危険な自己欺瞞です。なぜなら、才能という言葉を使った瞬間、私たちは変化の可能性を放棄してしまうからです。「才能がないからできない」は、「努力してもどうせ無理」と同義です。そして一度この思考に陥ると、成長のための努力そのものが無意味に思えてきます。私自身、新人時代にこの罠に嵌っていました。新しい技術概念と格闘していた頃、何度もこう思いました。「自分にはこの考え方を理解する才能がないのだろう」と。そしてその思考は、学習を放棄する口実となりました。難しいドキュメントを読むことを避け、エラーメッセージと真剣に向き合うことから逃げました。でも、ある時気づきました。私が「才能がない」と諦めていた領域で活躍している先輩たちも、実は最初から理解していたわけではありませんでした。彼らは単に、私が避けていた苦痛と向き合い続けていただけだったのです。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazon性格と人格才能を考える上で、重要な区別があります。それは性格と人格の違いです。性格とは、通常の日にどう反応するか──つまり、私たちの自然な傾向や気質のことを指します。一方で人格とは、困難な日にどう振る舞うか──つまり、意図的に選択される態度や行動のことです。この区別は、才能という概念を理解する上でとても重要です。私たちはよく、性格と人格を混同してしまいます。「私は物覚えが悪い」「集中力がない」「創造性がない」──これらは一見すると先天的な限界のように聞こえます。しかし実際には、これらの多くは人格、つまり訓練可能な能力の領域なのです。例えば、「集中力がない」と自己評価する人の多くは、実は集中する環境や方法を知らないだけかもしれません。スマートフォンの通知をオフにし、作業を25分単位に区切り、定期的に休憩を取る──こうした具体的な方法を実践することで、「集中力」は劇的に向上します。重要なのは、こうした能力を「才能」ではなく「性格スキル」として捉え直すことです。才能は固定的で変えられないものですが、スキルは練習によって向上させることができます。この視点の転換が、成長への扉を開くのです。世界一やさしい「才能」の見つけ方　一生ものの自信が手に入る自己理解メソッド作者:八木 仁平KADOKAWAAmazon不快感という成長の証才能という幻想から抜け出すために、もう一つ重要な認識があります。それは、学習における不快感の本質的な役割です。「快適に学べる」というのは、実は矛盾した概念かもしれません。スキルを真に習得するまで快適にはなれないのですが、習得する前の練習は必然的に不快だからです。そして人は、その不快感を避けようとします。これが、多くの人が成長の途中で挫折する根本的な理由です。Docker最適化の学習を例に取りましょう。BuildKitのキャッシュ戦略を理解しようとするとき、最初はかなり混乱します。レイヤーの仕組み、マウントの種類、キャッシュの無効化条件──これらの概念は最初、全く繋がらない断片として現れます。この混乱は不快です。だから多くの人は、「とりあえず動けばいい」と表面的な理解で妥協します。しかし、この不快感こそが成長の証なのです。脳が新しい構造を構築しようとしている証。既存の理解の枠組みが崩れ、新しい理解が生まれつつある証です。この不快感から逃げずに、むしろそれを「成長が起きている」というサインとして受け入れられるかどうか──それが、習得できる人とできない人を分ける分岐点になります。「快適なら、やり方が間違っている」という言葉があります。この言葉は、学習の本質を突いています。本当の成長は、常にコンフォートゾーンの外側で起きるのです。ネガティブ・ケイパビリティ　答えの出ない事態に耐える力 (朝日選書)作者:帚木　蓬生朝日新聞出版Amazon才能がないと言う前にインターンシップやワークショップで若手と一緒に作業をしていて気づいたことがあります。「才能がない」と自己評価する人の多くが、実は才能の問題ではなく、もっと基礎的なプロセスを飛ばしているだけだということです。syu-m-5151.hatenablog.comドキュメントを読んでいない「自分には向いていない」と言う学生がいました。コードがうまく動かないし、エラーが理解できないと。しかし彼は、エラーメッセージを実際には読み飛ばしていたのです。エラーメッセージには「Expected type X, but got type Y」と明確に書いてあります。しかし「type X」という文字列だけを拾って、期待される型と実際の型が違うという関係性を読み取っていませんでした。これは彼だけの問題ではありません。ドキュメントを「読んでいるつもり」でも、実際には自分の仮説に都合のよい部分だけを拾い読みしている人は驚くほど多いのです。APIのリファレンスに「このメソッドは非同期です」と書いてあっても、Promiseを返すのか、コールバックを受け取るのか、await可能なのか──書かれているはずの詳細を読んでいません。仮説を一つずつ潰していない別の学生は「バグが見つからない」と何時間も格闘していました。しかし彼は、複数の仮説を同時に追いかけて、どれも中途半端に確認していたのです。「ネットワークの問題かもしれない」と言いながらネットワークのログを確認せず、「データベースの問題かもしれない」と言いながらクエリを確認しない。問題解決には、仮説を一つずつ潰していくプロセスが必要です。この地道なプロセスを飛ばして、「なんとなく」で進めようとするから、何時間経っても解決しないのです。仮説行動――マップ・ループ・リープで学びを最大化し、大胆な未来を実現する作者:馬田隆明英治出版Amazon主語と述語を把握していない技術文書を読むとき、主語と述語の関係を曖昧にしたまま読み進めている人は非常に多いのです。「誰が」「誰に」「何を」しているのか──この基本的な構造を把握しないまま、「なんとなく」で理解したつもりになっています。小さなことの積み重ねエラーメッセージをちゃんと読む。仮説を一つずつ潰す。主語と述語を把握する。誰でもできることです。しかし、この「小さなこと」の積み重ねが、「才能がある」ように見える人と「才能がない」と思い込む人を分けています。才能があるように見える人は、これらの基礎的なプロセスを、意識的か無意識的に実践しています。これらは訓練可能です。才能ではありません。最初は意識的にやる必要があります。めんどくさいと感じるかもしれません。でも、この「めんどくさい」基礎作業を飛ばすから、結果的に何倍も時間がかかってしまうのです。なぜ、ちゃんと読めないのか「ちゃんと読むことによる成功体験」が積めていない──これが、根本的な問題かもしれません。奪われた集中力: もう一度〝じっくり〟考えるための方法作者:ヨハン・ハリ作品社Amazonインスタント化と「モヤモヤ」への耐性の喪失私たちは今、インスタントで断片的な刺激に取り巻かれています。YouTubeのレコメンド、TikTokの短い動画、LINEスタンプ──一定のリズムで繰り返されるインスタントで分かりやすい感覚やコミュニケーションが蔓延しています。スマホを持つことで、即時的な満足にいつでもアクセスできる状態にあり、「消化しきれなさ」「難しさ」「モヤモヤ」といった時間もコストもかかるものは人気がなくなっています。技術ドキュメントを読むことは、まさにこの「モヤモヤ」との戦いです。一読してすぐに理解できるものではありません。何度も読み返し、実際に試し、エラーに出会い、また読み返す。この時間のかかるプロセスが、インスタント化した感覚に慣れた私たちには耐えがたいのです。新しい技術を学ぶとき、最初は「モヤモヤ」します。でも、このモヤモヤした状態を抱えたまま、読み続け、試し続けることでしか、深い理解には到達できません。ChatGPTやClaudeに「要約して」と頼んでしまう。確かに、それでスッキリはします。でも、その過程で失われるものがあります。孤独と孤立の喪失スマホによる常時接続の世界では、何か一つのことに取り組み、一つのことに没頭する＜孤立＞が喪失しています。反射的なコミュニケーションを積み重ねるということは、相手の人格や心理状態を想像しないコミュニケーションです。同時に、退屈に耐えきれず、何か刺激やコミュニケーションを求めてスマホをいじってしまい、自分一人で時間を過ごす＜孤独＞も失われかけています。スマホ時代に必要なのは孤独と孤立であり、それらがあってこそ、自分を浸している感覚に耳を澄ませ、刺激的な経験と折り合いをつけることができます。技術ドキュメントを読むことは、まさにこの「孤立」を必要とします。一人で、ドキュメントと向き合う時間。このシンプルな行為が、現代では驚くほど難しくなっています。ネガティブ・ケイパビリティの欠如ネガティブ・ケイパビリティとは、「結論づけず、モヤモヤした状態で留めておく能力」です。把握しきれない謎をそのまま抱えておくことで、そこから新しい何かをどこまでも汲み取ろうとする姿勢のことです。これは、他者の経験を理解したり、技術を学んだりするときに必要です。謎を安易に「自分のわかる範囲」に回収しない能力と言えます。新しい技術を学ぶとき、すぐに「わかった」と思いたくなります。でも実際には、わかっていないことだらけです。このモヤモヤした状態を抱えたまま、読み続け、試し続ける。この能力が、現代人には欠けているのかもしれません。自己啓発の罠と他者の想像力悩みや困難を抱えている人は、「自分の直観に従って判断しろ」「自分の情熱に従え」というメッセージに心を揺さぶられます。しかし、このアプローチには内なる声は一つであり、その声こそ自分を然るべき一つの進路へと導いてくれるはずという前提があります。他者の想像力は、「ノイズ」としてラベリングされてしまいます。私たちは、一枚岩のような存在ではありません。自分の内側にはいくつもの声が発せられています。「他者に見られる自分」も自分の重要な構成要素となるので、他者はノイズどころか、自分を豊かに育てるものです。「才能がない」という言葉も、実はこの自己啓発の罠と表裏一体です。「才能がないから無理」は自己責任の裏返しです。でも実際には、他者の想像力を借りること、ドキュメントを丁寧に読むこと、先輩に質問することは、ノイズではなく成長の糧なのです。「自分の頭で考える」の代わりに、「他人の頭で考える」「他者の想像力を自分に取り入れる」ことが大切です。才能ではなく、学び方の問題「才能がある」と見なされる人々を注意深く見ると、彼らの多くは特別な能力を持っているわけではありません。彼らは効果的な学び方を知っているだけなのです。例えば、指摘と助言の違いを理解している人は、より速く成長します。「このコードのどこが悪いですか?」は指摘を求める質問で、過去の実績に焦点を当て、しばしば批判的な応答を引き出します。一方で「このコードをより保守性の高いものにするにはどうアプローチすべきでしょうか?」は助言を求める質問で、未来に焦点を当て、建設的な提案を引き出します。この小さな違いが、学びの質を大きく変えます。才能があるように見える人は、こうした学び方の技術を実践しています。彼らは「分からない」と素直に認め、「教えてください」と謙虚に頼み、そして得られた助言を素直に実践します。これは才能ではなく、態度の問題なのです。学びとは何か－〈探究人〉になるために (岩波新書)作者:今井 むつみ岩波書店Amazon後退も成長のプロセスの一部才能という概念を手放すと、もう一つ重要な認識が生まれます。それは、成長が必ずしも直線的ではないということです。私たちは、成長を一方向的な進歩として捉えがちです。しかし実際の成長は、螺旋を描くように進んでいきます。前進し、停滞し、時には後退し、そしてまた前進します。この後退期を「才能がない証拠」として捉えるか、「成長のための再編成」として捉えるかで、その後の軌道は大きく変わります。技術を学ぶ過程でも、この現象は頻繁に起きます。新しいフレームワークを学び始めた当初は順調に進みます。しかし、ある程度理解が深まると、突然全てが分からなくなる瞬間が来ます。これは実は、表面的な理解から深い理解へと移行する兆候なのです。しかし多くの人は、この瞬間を「やはり自分には才能がない」と解釈し、学習を放棄してしまいます。人は前進するために時に立ち止まり、後退し、そしてまた前進した先には以前よりも大きく飛躍しています。このプロセスを理解することで、停滞期や後退期を前向きに捉え直すことができます。それは失敗ではなく、次の飛躍のための準備期間なのです。手を動かすことの救いエンジニアという仕事には、一つの大きな救いがあります。それは、手を動かしている間、才能への不安が消えるということです。「自分には才能がない」という悩みは、頭の中でぐるぐる回り始めると、どんどん大きくなります。でも「これを作りたい」と思って実装を始めた瞬間、その悩みはどこかに消えます。目の前にあるのは、具体的な問題だけです。エラーが出る。調べる。解決する。また詰まる。また調べる。この「詰まる→調べる→解決する」のサイクルを回すこと自体が、静かに自信を育てていきます。最初は1つのエラーに1時間かかったのが、30分になり、10分になる。その変化を実感するとき、「成長している」という手応えが得られます。理想ではなく、作りたいものを追う重要なのは、「優秀なエンジニアになりたい」という抽象的な目標ではなく、「このアプリを作りたい」「この機能を実装したい」という具体的な目標に向かって手を動かすことです。完璧主義に陥る人は、結果に過度な完成度を求めるあまり、小さな一歩を踏み出せません。「理想的なアーキテクチャを設計してから始めよう」「全ての技術を理解してから作ろう」──そう考えて、結局何も始められない。でも実際には、小さく作って、動かして、直して、また作る。このサイクルを回すことでしか、良いものは生まれません。一つのエラーを解決する。一つの機能を実装する。一つのテストを通す。この小さな積み上げが、気づけば大きなものになっています。綿密な計画よりも、不完全でも動く一歩の方が、はるかに価値があります。あえて視野を狭めろここで、少し逆説的なことを言います。特に若い時期には、根拠がなくても、自分を信じることが重要です。「才能という幻想」を批判してきたこの記事で、矛盾するように聞こえるかもしれません。しかし、「自分には才能がある」という固定的な思い込みと、「自分はできるようになる」という成長への信頼は、全く別物です。若いうちは、視野をあえて狭めることも必要です。「これが本当に正しい道なのか」「自分に向いているのか」──そんな冷静な自己分析ばかりしていると、一歩も踏み出せなくなります。時には、根拠のない自信を持って、盲信的に突き進むことも必要です。「プログラミングなんて簡単だろう」という、ある意味で無知ゆえの大胆さ。この「若気の至り」とも言える姿勢が、最初の一歩を踏み出させてくれます。その盲信的な姿勢が、いつか本当の自信に変わります。根拠のない自信が、実績という根拠を伴った自信になります。そして気づけば、最初は「嘘」だった「自分はできる」という言葉が、本当になっているのです。問題を面白がる力もう一つ、見落とされがちな視点があります。それは、学びにおける遊び心です。才能があるように見える人は、実はこの遊び心を持っています。彼らは学びを苦痛として捉えるのではなく、謎解きとして楽しんでいます。新しいバグに出会えば「面白い現象だ」と興味を持ち、理解できない概念に出会えば「理解できたら面白そうだ」と好奇心を抱きます。この姿勢は、才能ではなく選択です。同じ状況を「苦痛」として捉えるか「挑戦」として捉えるか──その選択が、長期的な成長の軌道を決めます。そして、この選択は意識的に訓練できます。義務として学ぶのではなく、探究心を持って取り組むとき、人は最も成長します。ぐちゃぐちゃ考える暇があったら才能があるかどうかなんて、作っているときには関係ありません。目の前のエラーメッセージは、あなたが才能があるかどうかなんて気にしていません。ただ、解決策を求めているだけです。ドキュメントを読む。エラーメッセージをちゃんと読む。仮説を立てて検証する。うまくいかなければ別の方法を試す。これらは全て、才能ではなく、プロセスです。コンテストで優秀な成績を残した人たちも、結局は同じことをしています。彼らが特別なのではありません。ただ、このプロセスを高速で回せるようになっただけです。そして、その高速化は、繰り返しによってしか得られません。自分が未熟だと不安に思いながらインターンシップを始めた私が、3年経って確信していることがあります。それは、手を動かし続けた人は、必ず前に進んでいるということです。才能について悩む時間を、1行でも多くコードを書く時間に変える。理想の自分について考える時間を、作りたいものを作る時間に変える。その積み重ねが、気づけば「成長」と呼ばれるものになっています。才能という言葉を使わないここまで読んで、一つの結論に至るかもしれません。それは、才能という言葉を使わないことの重要性です。「才能がある」「才能がない」──この二元論は、成長の可能性を見えなくしてしまいます。代わりに、より具体的で建設的な言葉を使うべきです。「まだ学んでいない」「まだ練習が足りない」「まだ自分に合った学び方に出会っていない」──こうした表現は、現在の状態を固定的なものではなく、変化可能なものとして捉えさせます。インターン生に技術を教える際も、この視点の転換を意識しています。「才能がない」という言葉を聞いたら、必ず問い返します。「具体的に、何が難しいと感じている?」と。すると、「才能」という曖昧な概念ではなく、具体的な課題が見えてきます。そして具体的な課題は、具体的な対策で解決できます。「あなたには向いていないかも」ではなく、「どういう環境や説明の仕方なら理解できるだろうか」と考えます。この視点の転換が、教育者として最も重要な態度なのかもしれません。では、才能という言葉を使わないとしたら、何を語るべきなのでしょうか。それは、成長のメカニズムそのものです。どうすれば効果的に学べるか。どうすれば困難に直面しても諦めずに続けられるか。どうすれば自分の可能性を最大限に引き出せるか──こうした実践的な問いに答えることが、才能という幻想よりもはるかに価値があります。これは抽象的な話ではありません。とても実践的な話です。毎朝同じ時間に起きる習慣。集中できる環境を整える工夫。失敗から学ぶための振り返りの時間。他者から助言を求める勇気──これらは全て、トレーニング可能なスキルです。そして、これらのスキルの蓄積が、才能と呼ばれるものの正体なのかもしれません。HIDDEN POTENTIAL 可能性の科学――あなたの限界は、まだ先にある (三笠書房　電子書籍)作者:アダム・グラント三笠書房Amazon時間という最も公平な資源才能という概念に対して、時間は最も公平な資源です。どんな人にも、1日は24時間しかありません。もちろん、その24時間をどう使えるかは、環境によって大きく異なります。しかし、与えられた時間の中で、何を選択するか──その選択の積み重ねが、最終的な差を生みます。才能がある人とない人の違いは、実は時間の使い方の違いなのかもしれません。才能があるように見える人は、学習に多くの時間を投資しています。しかしそれは、単純に勉強時間が長いという意味ではありません。むしろ、質の高い時間の使い方を知っているということです。例えば、同じ1時間でも、受動的にチュートリアルを見るのと、能動的に問題を解こうとするのでは、学びの質が全く異なります。同じエラーに出会っても、すぐに答えを探すのと、まず自分で考えてみるのでは、理解の深さが変わります。時間という公平な資源を、どう使うか。これは才能ではなく、戦略の問題です。そして戦略は、学ぶことができます。あっという間に人は死ぬから　「時間を食べつくすモンスター」の正体と倒し方作者:佐藤 舞（サトマイ）KADOKAWAAmazon停滞と努力の違い時間の使い方について語るとき、見落とされがちな重要な区別があります。それは、停滞と努力の違いです。Kubernetesのワークショップで、あるインターン生がServiceの概念に数日苦しんでいました。彼は毎日、同じドキュメントを読み返していました。「努力している」と本人は言いました。でも、彼は前に進んでいませんでした。よく話を聞くと、彼はそもそもネットワークの基礎を理解していませんでした。IPアドレスとは何か、ポートとは何か、DNSがどう動くのか──こうした土台がないまま、Kubernetesの抽象的な概念を理解しようとしていたのです。難しい問題に直面したとき、人は二つの道を選びます。一つは、理解できないまま同じ説明を何度も読み返し、同じ場所でぐるぐると回り続けること。もう一つは、「何が分からないのか」を見極めて、まずそこから順番に理解していくこと。前者を停滞と呼び、後者を努力と呼びます。停滞している人は、しばしば自分が努力していると思っています。長時間向き合っている。何度も試している。でも実際には、前提となる知識が欠けたまま、同じところで足踏みを繰り返しているだけなのです。本当の意味での努力とは、今の自分が理解できるところから始めることです。Kubernetesが難しいなら、まずネットワークの基礎から。ネットワークが難しいなら、まず自分のPCで2つのプログラムを通信させることから。この段階を踏んだ学び方こそが、努力の本質です。理解の速さには個人差があります。これは残酷な現実です。でも、人生という長い時間軸で見たとき、この速さの差は思ったほど大きくありません。むしろ、一歩ずつでも前に進み続けた人と、途中で立ち止まってしまった人の差の方が、はるかに大きいのです。時間は誰にも平等です。でも、その時間を「理解できない問題の前での空回り」に使うか、「今理解できることから順に積み上げていく前進」に使うか──この選択が、長期的には想像もできないほどの差を生みます。だから、ゆっくり急いでください。今日から始めて、でも焦らず、着実に。目の前の問題が難しすぎるなら、何が前提として必要かを見極めて、より基礎的なところから。その地道な積み重ねこそが、あなたを想像もしなかった場所へと連れて行ってくれます。超一流になるのは才能か努力か？ (文春e-book)作者:アンダース・エリクソン,ロバート・プール文藝春秋Amazonどうしようもなく満たされない性質についてここまで「才能という言葉を使わないこと」を言ってきましたが、最後に一つだけ、もしエンジニアに才能というものがあるとすれば何か、という問いに答えたいと思います。それは、どうしようもなく満たされない性質です。知りたいと思う。理解したいと思う。作りたいと思う。解決したいと思う。そして、その過程を楽しめる。それをしてないと、ちゃんと生きていけない。そういう性質。これは祝福でもあり、同時に呪いでもあります。なぜなら、これらの能力はコントロールできないことが多いからです。夜中の3時に突然コードのことを考え始める。休日なのに技術ドキュメントを読んでしまう。趣味と仕事の境界が曖昧になる。多くの不都合を抱えています。だから、あまり気にしなくて良いのです。才能と能力が一致しているのは、かなり稀です。「満たされなさ」を持っていても、それが必ずしも成果に結びつくわけではありません。逆に、その「満たされなさ」を持たずとも、優れたエンジニアになることは十分に可能です。自分に才能があるのかないのか。何者かになれる人となれない人の違いは何なのか。その境目はありません。「才能がある」とか「天才だ」というのは、原因ではなく結果に対して付けられる評価です。何かを成し遂げた後で、周りが「あの人には才能があったんだ」と言うだけです。始める前から、自分に才能があるかどうかなんて、誰にも分かりません。そして、それを気にする必要もありません。重要なのは、今、目の前にあることに取り組むかどうか。その選択だけです。ご冗談でしょう、ファインマンさん（上） (岩波現代文庫)作者:Ｒ．Ｐ．ファインマン岩波書店Amazonご冗談でしょう、ファインマンさん（下） (岩波現代文庫)作者:Ｒ．Ｐ．ファインマン岩波書店Amazonおわりに様々な場所で、様々な「才能」を目撃してきました。コンテスト会場、企業のオフィス、勉強会、ワークショップ──華々しく成功した人も、静かに立ち去った人も、黙々と歩き続けている人も。私が伝えたかったのは「才能なんて存在しない」という単純なメッセージではありません。「才能という言葉を使うことで、私たちは何を見失っているのか」ということです。才能という言葉は便利です。でも、その便利さと引き換えに、私たちは変化の可能性を、成長の余地を、自分と他者の可能性を信じる力を手放しています。「才能がない」という言葉を、もし今、心の中で繰り返しているのなら──それは本当は違うかもしれません。エラーメッセージを、ちゃんと読んでいないだけかもしれません。仮説を、一つずつ潰していないだけかもしれません。インスタントな答えを求めて、モヤモヤと向き合っていないだけかもしれません。まだ、自分に合った学び方に出会っていないだけかもしれません。小さなことです。でも、その小さなことを飛ばしているから、「才能がない」と思い込んでしまう。コンテストで輝いていた同期が、燃え尽きていることがあります。勉強会で熱心だった後輩が、姿を見せなくなることがあります。一方で、当時は目立たなかった誰かが、誰も予想しなかった場所で花を咲かせていることもあります。スタート地点の優劣など、長い人生においてはほとんど意味をなさない──20代を通じて、私はそう学びました。あなたの可能性は、スタート地点では測れません。どれだけ伸びたか、どれだけ学んだか、どれだけ変化したか──それこそが、本当の意味での能力です。才能という幻想を手放したとき、初めて見えてくる景色があります。それは、不完全な今の自分を受け入れ、それでも前に進み続けることの静かな勇気です。未熟な自分がインターンシップを始めて3年。今でも不安はあります。でも、若手と一緒に作業する中で気づきました。彼らが必要としているのは、全てを知り尽くした指導者ではありません。共に悩み、共に考え、そして「才能」という言葉で可能性を閉ざさない、そんな誰かです。この記事を通じて、私自身もまた、自分に言い聞かせています。才能があるかどうかなんて、後になってから誰かが決めることです。大切なのは、今、目の前にあることに手を動かし続けること。その積み重ねだけです。最後に、私自身のことを少しだけ。私にはいくつかの目標があります。世界的に有名なOSSを作って、海外で見知らぬ人にコーヒーを奢ってもらいたいです。書籍をコンスタントに出して、いつか道端でサインを求められたいです。週刊プレイボーイに連載を載せて、毎週誰から指摘されても反論ができるようにグラビア雑誌を買うことです。できるかどうかは分かりません。才能があるかどうかも分かりません。でも、文章を書き続けています。コードを書き続けています。なぜなら、それが私にとって「満たされなさ」を満たす行為だからです。そして、その過程を楽しんでいるからです。あなたにも、そんな「満たされなさ」があるなら。それに向かって、ただ手を動かし続けてください。それが才能かどうかなんて、後になってから誰かが決めることです。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[今更ながらadkを使ってみた]]></title>
            <link>https://zenn.dev/akasan/articles/637c35253400e7</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/637c35253400e7</guid>
            <pubDate>Mon, 27 Oct 2025 12:50:38 GMT</pubDate>
            <content:encoded><![CDATA[今回はadkを使ってみました。すでに提供が開始されてからかなり日数が立っていますが使っていなかったことに気づきまして、今回Qucikstartを試してみました（エージェントを実装できる方法が他に色々ありすぎて漏れていましたw）。 adkとは？adkとはAgent Development Kitの省略であり、エージェントを開発・デプロイするためのフレームワークになります。GeminiやGoogleのエコシステムに最適化されてはいますが利用するモデルについてはそれ以外のものも利用でき、他のフレームワークと互換性があるものとなっています。利用用途としてはadkをつかってエージェントをくみ...]]></content:encoded>
        </item>
    </channel>
</rss>