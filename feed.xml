<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Fri, 22 Aug 2025 22:41:20 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[claude commandのスラッシュコマンドでコーディングの癖を検知させてみた]]></title>
            <link>https://zenn.dev/akasan/articles/846cd9a610d5a4</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/846cd9a610d5a4</guid>
            <pubDate>Fri, 22 Aug 2025 14:38:31 GMT</pubDate>
            <content:encoded><![CDATA[今回はclaude codeのスラッシュコマンドを実装して、指定したファイルからコーディングの癖を見抜く仕組みを入れてみました。※ 出張中につき超短編です スラッシュコマンドの実装以下のようなスラッシュコマンドを作りました。ファイルは~/.claude/commands/kuse.mdです。内容は極めてシンプルで、指定されたファイルをよんでただただ癖を見抜かせるだけです。- 指定されたファイルから、私のコーディングの癖を見出してください- 癖の中でベストプラクティスに沿っていないコーディングがあれば指摘してください 使ってみた例えば以下のようなmain.pyを作ってみま...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ RustでLinuxのシグナル処理とプロセス間通信をしてみた]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/08/22/155856</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/08/22/155856</guid>
            <pubDate>Fri, 22 Aug 2025 06:58:56 GMT</pubDate>
            <content:encoded><![CDATA[はじめに前回の記事「RustでLinuxプロセス管理をしてみた」の続編として、今回はシグナル処理とプロセス間通信（IPC）について解説します。これらの技術は、システムプログラミングの根幹をなす重要な概念です。doc.rust-lang.orgサンプルコードはこちらに配置しておきます。github.com2025年の最新動向2025年現在、Rustエコシステムは大きな転換期を迎えています。Linux 6.13が2025年1月にリリースされ、Rustサポートが「転換点」に到達しました。また、非同期ランタイムの世界では、async-stdが2025年3月に廃止されることが決まり、Tokioが事実上の標準となっています。さらに、Rust 1.85ではasync closuresが安定化され、より表現力豊かな非同期処理が可能になりました。1. 基礎知識書籍はこちらがめちゃくちゃに詳しいのでオススメです。ふつうのLinuxプログラミング 第2版　Linuxの仕組みから学べるgccプログラミングの王道作者:青木 峰郎SBクリエイティブAmazonプロセスとはプロセスは「実行中のプログラムのインスタンス」です。皆さんが日常的に使うWebブラウザのタブやターミナルのセッションは、すべてプロセスとして動作しています。各プロセスは独立したメモリ空間を持ち、他のプロセスから直接アクセスすることはできません。これがシステムの安定性と安全性を保証していますが、同時にプロセス間でデータをやり取りする特別な仕組みが必要になる理由でもあります。シグナルとはシグナルは、プロセス間の非同期通知メカニズムです。電話の着信音のように、プロセスに「何か重要なことが起きた」と割り込みで知らせる仕組みだと考えると分かりやすいでしょう。主要なシグナルと実際の用途： シグナル  番号  用途  実例  SIGTERM  15  正常終了要求  systemctl stopで送信される  SIGKILL  9  強制終了  kill -9、OOMキラー  SIGINT  2  割り込み  Ctrl+Cを押したとき  SIGHUP  1  設定再読み込み  nginxやsshdの設定リロード  SIGUSR1/2  10/12  カスタム用途  アプリ固有の動作トリガー シグナルには重要な特徴がいくつかあります。まず非同期性という性質があり、いつ届くか予測できません。また割り込みとして動作するため、実行中の処理を中断して処理されます。そしてシンプルな仕組みで、シグナル番号以外の追加情報を送ることはできません。rust-cli.github.ioプロセス間通信（IPC）とはIPCは、独立したプロセス同士がデータをやり取りするための仕組みです。それぞれの方式には特徴があり、用途に応じて使い分けます： 方式  特徴  実際の使用例  パイプ  単方向、親子プロセス間  ls | grepなどのシェルパイプ  名前付きパイプ  双方向、無関係なプロセス間も可  ログ収集デーモンへのデータ送信  Unix Domain Socket  双方向、高速、信頼性高  Docker、systemd、PostgreSQL  共有メモリ  最速、同期が複雑  データベースのバッファプール  メッセージキュー  非同期、順序保証  ジョブキューシステム 2. シンプルなシグナル処理Ctrl+Cを検知して安全に終了最もシンプルな例から始めてみましょう。Ctrl+Cを押したときに、きちんと後処理をしてから終了するプログラムです。use std::sync::atomic::{AtomicBool, Ordering};use std::sync::Arc;use std::thread;use std::time::Duration;fn main() {    println!("プログラム開始（Ctrl+Cで終了）");        // 実行中フラグ（スレッド間で安全に共有）    let running = Arc::new(AtomicBool::new(true));    let r = running.clone();        // Ctrl+Cハンドラーを設定    ctrlc::set_handler(move || {        println!("\n終了シグナルを受信しました");        r.store(false, Ordering::SeqCst);    }).expect("シグナルハンドラーの設定に失敗");        // メインループ    let mut counter = 0;    while running.load(Ordering::SeqCst) {        counter += 1;        println!("処理中... カウント: {}", counter);        thread::sleep(Duration::from_secs(1));    }        println!("プログラムを安全に終了しました");}このコードにはいくつかの重要なポイントがあります。まずAtomicBoolを使ってスレッド間で安全にフラグを共有しています。シグナルハンドラーはいつ呼ばれるか分からないため、アトミック操作が必要になります。そしてループを抜けてから終了処理を行うことで、データの整合性を保っています。docs.rsgithub.com複数のシグナルを処理実際のサーバーアプリケーションでは、複数のシグナルを適切に処理する必要があります。use signal_hook::{consts::signal::*, iterator::Signals};use std::{error::Error, thread, time::Duration};fn main() -> Result<(), Box<dyn Error>> {    let mut signals = Signals::new(&[SIGTERM, SIGINT, SIGHUP])?;        thread::spawn(move || {        for sig in signals.forever() {            match sig {                SIGTERM | SIGINT => {                    println!("終了シグナルを受信");                    std::process::exit(0);                }                SIGHUP => {                    println!("設定再読み込み");                }                _ => unreachable!(),            }        }    });        // メイン処理    loop {        println!("作業中...");        thread::sleep(Duration::from_secs(2));    }}docs.rsgithub.com3. プロセス間通信の基礎シンプルなパイプ通信親プロセスから子プロセスへメッセージを送る基本的な例です。use std::io::{Write, Read};use std::process::{Command, Stdio};fn main() -> std::io::Result<()> {    // catコマンドは標準入力をそのまま標準出力に出力    let mut child = Command::new("cat")        .stdin(Stdio::piped())        .stdout(Stdio::piped())        .spawn()?;        // 子プロセスに書き込み    if let Some(mut stdin) = child.stdin.take() {        stdin.write_all(b"Hello from Rust!\n")?;    }        // 結果を読み取り    let output = child.wait_with_output()?;    println!("受信: {}", String::from_utf8_lossy(&output.stdout));        Ok(())}パイプには特徴的な性質があります。まず単方向通信であり、データは一方向にのみ流れます。またバッファリング機能があり、OSが自動的にバッファを管理してくれます。そしてブロッキング動作をするため、読み込み側は書き込みを待つことになります。docs.rsUnix Domain Socketより本格的な双方向通信の例です。多くのシステムソフトウェアが採用している方式です。Unix Domain Socketには多くの利点があります。双方向通信が可能で、クライアント・サーバー間で自由にやり取りできます。また、ネットワークスタックを通らないため高速に動作します。そしてファイルシステム上のパスとして存在するため、アクセス制御が簡単に行えます。4. デバッグツールの活用詳解 システム・パフォーマンス 第2版作者:Brendan Greggオーム社Amazonシステムプログラミングにおいて、問題を解決するには、まず問題を観察できなければならないという原則があります。特にシグナル処理やIPCのような非同期的な動作は、従来のprint文デバッグでは限界があります。そこで重要になるのが可観測性（Observability）という概念です。効果的なデバッグには階層的なアプローチが必要です。まずアプリケーション層で何が起きているかを把握し、次にシステムコール層まで掘り下げ、必要に応じてカーネル層まで観察します。各層に適したツールを使い分けることで、最小のオーバーヘッドで最大の洞察を得ることができます。また、動的トレーシングと静的トレーシングを使い分けることも重要です。straceのような動的トレーシングツールは実行中のプロセスをリアルタイムで観察でき、rr-debuggerのような記録再生型ツールは時間を巻き戻して問題の根本原因を特定できます。これらを組み合わせることで、再現困難なバグも確実に捕捉できるようになります。strace - システムコールトレースシグナル処理やIPCのデバッグには、システムコールレベルでの動作確認が不可欠です。# シグナル関連のシステムコールのみ表示strace -e trace=signal,sigaction,kill,pause cargo run# 実際の出力例rt_sigaction(SIGINT, {sa_handler=0x5555555, ...}, NULL, 8) = 0--- SIGINT {si_signo=SIGINT, si_code=SI_KERNEL} ---rt_sigreturn({mask=[]}) = 0straceを使うと様々な情報が見えてきます。シグナルハンドラーの登録状況（sigaction）、シグナルの送受信タイミング、ブロックされたシグナル、そしてシステムコールの引数と戻り値などを確認できます。strace.iorr-debugger（最強のデバッグツール）rrは、GDBを拡張して作られたデバッガで、プログラムの実行を記録し、逆方向にステップ実行できます。# プログラムの実行を記録rr record ./target/debug/my_program# rust-gdbを使って再生rr replay -d rust-gdb# リバース実行のコマンド(rr) reverse-continue  # 逆方向にcontinue(rr) reverse-next      # 逆方向にnextrrが強力な理由はいくつかあります。まず100%再現性があり、非決定的な動作も完全に再現できます。また逆実行機能により、エラーの原因を遡って調査できます。そして低オーバーヘッドで動作するため、実用的な速度で記録が可能です。特にシステムプログラミングでは、「たまにしか起きないエラー」や「データ競合」のデバッグで威力を発揮します。rr-project.orgtokio-console - 非同期ランタイムデバッグ非同期Rustアプリケーションのデバッグには、tokio-consoleが非常に有用です。タスクの状態、実行時間、リソース使用状況をリアルタイムで監視できます。# tokio-consoleをインストールcargo install --locked tokio-console# アプリケーション起動（別ターミナル）RUSTFLAGS="--cfg tokio_unstable" cargo run# tokio-consoleで監視tokio-consolegithub.com5. グレイスフルシャットダウン実際のサービスで必要な、適切な終了処理の実装例を見てみましょう。グレイスフルシャットダウンが重要な理由は複数あります。まずデータの整合性を保つため、処理中のタスクを完了してから終了する必要があります。またリソースの解放として、ファイルやソケットを適切にクローズしなければなりません。そして状態の保存により、次回起動時に必要な情報を保存することも重要です。実装する際のポイントとしては、まず新規タスクの受付を停止し、新しい仕事を受け付けないようにします。次に既存タスクの完了を待機し、実行中の処理を最後まで実行させます。その後リソースのクリーンアップを行い、ファイルやネットワーク接続を閉じます。最後に統計情報の出力を行い、ログに実行結果を記録します。6. Tokioを使った非同期グレイスフルシャットダウンモダンなRustアプリケーションでは、Tokioを使った非同期処理が主流です。use tokio::signal;use tokio_util::sync::CancellationToken;#[tokio::main]async fn main() {    let token = CancellationToken::new();        // Ctrl+Cハンドラー    let shutdown_token = token.clone();    tokio::spawn(async move {        signal::ctrl_c().await.unwrap();        println!("シャットダウン開始");        shutdown_token.cancel();    });        // メインループ    loop {        tokio::select! {            _ = token.cancelled() => {                println!("終了処理中...");                break;            }            _ = do_work() => {                // 通常の処理            }        }    }}async fn do_work() {    // 非同期処理}CancellationTokenには多くの利点があります。階層的なキャンセルが可能で、親トークンをキャンセルすると子もキャンセルされます。また協調的な仕組みにより、各タスクが自分のタイミングで終了できます。そして非同期対応により、async/awaitと自然に統合されています。tokio.rsdocs.rsgithub.comdocs.rstokio.rs7. nixクレートでシステムコールを扱うRustでは、nixクレートを使って安全にUnixシステムコールを扱うことができます。libcクレートの生のAPIをラップし、Rust的な安全なインターフェースを提供しています。use nix::sys::signal::{self, Signal};use nix::unistd::{fork, ForkResult};match fork() {    Ok(ForkResult::Parent { child }) => {        println!("親プロセス、子PID: {}", child);    }    Ok(ForkResult::Child) => {        println!("子プロセス");    }    Err(_) => eprintln!("fork失敗"),}nixクレートを使うことで、エラーハンドリングが適切に行われ、メモリ安全性が保証されます。生のシステムコールを直接扱う必要がなくなり、より安全なコードが書けるようになります。docs.rsgithub.com8. 2025年の新機能：Async ClosuresRust 1.85.0で安定化されたasync closuresを使うと、より柔軟な非同期処理が書けます。async fn retry_with_backoff<F, Fut>(    mut f: F,     max_retries: u32,) -> Result<String>where    F: FnMut() -> Fut,    Fut: Future<Output = Result<String>>,{    for attempt in 1..=max_retries {        match f().await {            Ok(result) => return Ok(result),            Err(e) if attempt < max_retries => {                let backoff = Duration::from_secs(2_u64.pow(attempt - 1));                sleep(backoff).await;            }            Err(e) => return Err(e),        }    }    unreachable!()}async closuresを使うメリットは多岐にわたります。まず簡潔な記述が可能になり、非同期処理を関数引数として渡せるようになります。また型安全であるため、コンパイル時に型チェックが行われます。そして柔軟な制御フローにより、リトライやタイムアウトの実装が簡単になります。実装パターンの選び方シグナル処理の選択基準シグナル処理の実装方法を選ぶ際は、用途に応じて適切なツールを選択することが重要です。単純な終了処理であればctrlcクレートで十分です。複数のシグナルを扱う必要がある場合はsignal-hookを使用します。そして非同期処理と組み合わせる場合は、Tokioのsignalモジュールが最適です。IPC方式の選択基準IPC方式も同様に、用途に応じて選択します。親子プロセス間の単純な通信であればパイプが適しています。高速な双方向通信が必要な場合はUnix Domain Socketを選びます。大量データの共有には共有メモリが最適で、非同期メッセージングにはメッセージキューが向いています。まとめこの記事では、Rustでのシグナル処理とプロセス間通信について、基礎から実践まで段階的に解説しました。重要なポイント今回学んだ重要なポイントを振り返ってみましょう。まず、シグナルは非同期であり、いつ届くか分からないためアトミック操作が必要です。IPCは用途に応じて選ぶ必要があり、速度、双方向性、複雑さのトレードオフを考慮します。グレイスフルシャットダウンはデータの整合性を保つために必須です。straceやrr-debuggerなどのデバッグツールを活用することで、問題を効率的に解決できます。そして、async closuresやCancellationTokenなどの最新機能を活用することで、保守性を向上させることができます。各IPC方式の使い分け実際の開発では、各IPC方式を適切に使い分けることが重要です。パイプはシェルスクリプトとの連携や親子プロセス間の単純な通信に適しています。名前付きパイプはログ収集や順序保証が必要な場合に使います。Unix Domain Socketは高速な双方向通信やサービス間連携に最適です。共有メモリは大量データの高速処理やリアルタイム性が必要な場合に選択します。次のステップこの基礎を踏まえて、さらに高度な実装に挑戦することができます。分散システムへの拡張としてgRPCやメッセージキューの実装、コンテナ環境でのIPC最適化、リアルタイムシステムでの応用、そしてマイクロサービスアーキテクチャでの実装などが考えられます。完全なソースコードはGitHubリポジトリで公開しています。前回の記事「RustでLinuxプロセス管理をしてみた」と合わせて読むことで、Rustでのシステムプログラミングの基礎がしっかりと身につきます。Linuxカーネルプログラミング 第2版作者:Kaiwan N. Billimoria,武内 覚（翻訳）,大岩 尚宏（翻訳）オライリージャパンAmazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Aimシリーズ：入門してみた]]></title>
            <link>https://zenn.dev/akasan/articles/6221f74bea622d</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/6221f74bea622d</guid>
            <pubDate>Thu, 21 Aug 2025 12:28:55 GMT</pubDate>
            <content:encoded><![CDATA[今回から、Aimという実験管理ツールに入門してみます。※ 出張中につき、短編になります。 Aimとは？Aimとはオープンソースの実験管理ツールになります。Aimを利用すると実験を実行し、その結果発生する様々なメタデータを一元的に取り扱い、グラフィカルに解析することができます。Aimを利用することで以下のようなことが実現できます。MLパイプラインのロギングを可能にするUIを通してメタデータを比較分析できるML学習を効率的に実行可能実験管理のオーガナイズができるhttps://github.com/aimhubio/aim/ 早速使ってみる今回はGitHub上で提...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[RustでLinuxプロセス管理をしてみた]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/08/21/161234</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/08/21/161234</guid>
            <pubDate>Thu, 21 Aug 2025 07:12:34 GMT</pubDate>
            <content:encoded><![CDATA[はじめにこれまでPythonとGoでプロセス管理システムを実装してきましたが、今回Rustでも実装してみました。各言語にはそれぞれ得意不得意があり、プロジェクトの要件によって最適な選択は変わります。変なとこがあれば教えてください。この記事では、Rustでプロセス管理システムを実装した経験を共有します。標準ライブラリのstd::processだけでは不十分な要件があったため、より高度な制御が可能な実装を行いました。doc.rust-lang.orgサンプルコードはこちらに配置しておきます。github.comPython、Go、Rustでの実装経験から見えた違い3つの言語でプロセス管理を実装してきた経験から、それぞれの特徴をまとめます。Pythonでの実装subprocessモジュールは高レベルで使いやすいasyncioとの組み合わせで非同期処理も可能GILの影響で真の並行性には制限があるメモリ使用量が多く、長時間稼働で増加傾向Goでの実装os/execパッケージはシンプルで直感的goroutineによる並行処理が強力エラーハンドリングが冗長になりがちGCのオーバーヘッドが気になるケースがあるRustでの実装所有権システムによるリソース管理の確実性ゼロコスト抽象化による高パフォーマンス型システムによる実行前のバグ検出学習曲線は確かに急だが、長期的なメンテナンス性は高いRustの所有権システムとゼロコスト抽象化により、今回の要件を満たす堅牢なシステムを構築できました。特に、コンパイル時にリソースリークを防げる点、SendとSyncトレイトによる安全な並行処理、システムコールのオーバーヘッドが最小限である点が優れていました。1. まずはstd::processから始めよう最初の一歩：シンプルなコマンド実行Rustでプロセスを扱う最も簡単な方法は、標準ライブラリのstd::process::Commandを使うことです。use std::process::Command;fn main() {    // 最もシンプルな例    let output = Command::new("echo")        .arg("Hello, Rust!")        .output()        .expect("Failed to execute command");        println!("stdout: {}", String::from_utf8_lossy(&output.stdout));}パイプを使った入出力制御もう少し複雑な例として、子プロセスとパイプで通信してみましょう。use std::io::Write;use std::process::{Command, Stdio};fn main() -> std::io::Result<()> {    let mut child = Command::new("cat")        .stdin(Stdio::piped())        .stdout(Stdio::piped())        .spawn()?;        // 標準入力に書き込み    if let Some(mut stdin) = child.stdin.take() {        stdin.write_all(b"Hello from parent process!\n")?;    }        // 出力を取得    let output = child.wait_with_output()?;    println!("Child said: {}", String::from_utf8_lossy(&output.stdout));        Ok(())}std::processの限界しかし、実際のプロジェクトを進めていくと、std::processだけでは対応できない要件が出てきました。// ❌ std::processではできないこと// 1. 特定のシグナル（SIGTERM、SIGUSR1など）を送信できない// child.kill() はSIGKILLのみ// 2. プロセスグループの管理ができない// 複数の子プロセスをグループとして扱えない// 3. fork()が使えない// Unix系OSの基本的なプロセス生成方法が使えない// 4. 細かいリソース制限（CPU時間、メモリ量など）の設定ができない2. nixクレートの導入：なぜ必要なのかnixクレートとはnixクレートは、Unix系システムコールのRustラッパーです。std::processでは提供されていない低レベルな制御が可能になります。docs.rs[dependencies]nix = { version = "0.27", features = ["process", "signal"] }最初のnixプログラム：fork()の基本まずは最も基本的なfork()から始めましょう。fork()は現在のプロセスを複製し、親プロセスと子プロセスの2つに分岐します。use nix::unistd::{fork, ForkResult};fn main() -> Result<(), Box<dyn std::error::Error>> {    println!("親プロセス開始: PID={}", std::process::id());        // fork()は unsafe - プロセスの複製は危険を伴うため    match unsafe { fork() }? {        ForkResult::Parent { child } => {            // 親プロセスのコード            println!("親: 子プロセス {} を作成しました", child);        }        ForkResult::Child => {            // 子プロセスのコード            println!("子: 私は新しいプロセスです！PID={}", std::process::id());            std::process::exit(0); // 子プロセスは明示的に終了        }    }        Ok(())}なぜunsafeなのか？fork()がunsafeな理由を理解することは重要です。メモリの複製: fork時点のメモリ状態が複製されるマルチスレッドとの相性問題: スレッドがある状態でforkすると予期しない動作リソースの重複: ファイルディスクリプタなどが複製される3. 段階的に学ぶnixクレートの機能ステップ1: シグナル送信std::processではできなかったシグナル送信を実装してみます。use nix::sys::signal::{kill, Signal};use nix::unistd::Pid;use std::process::Command;use std::thread;use std::time::Duration;fn main() -> Result<(), Box<dyn std::error::Error>> {    // 子プロセスを起動    let mut child = Command::new("sleep")        .arg("30")        .spawn()?;        let pid = Pid::from_raw(child.id() as i32);    println!("子プロセス起動: PID={}", pid);        // 2秒待ってからSIGTERMを送信    thread::sleep(Duration::from_secs(2));    println!("SIGTERMを送信...");    kill(pid, Signal::SIGTERM)?;        // プロセスの終了を確認    let status = child.wait()?;    println!("子プロセス終了: {:?}", status);        Ok(())}ステップ2: プロセスの終了を待つ（ゾンビプロセスの防止）プロセスが終了しても、親がwait()しないとゾンビプロセスになります。nixを使った適切な処理方法を見てみましょう。use nix::sys::wait::waitpid;use nix::unistd::{fork, ForkResult};fn main() -> Result<(), Box<dyn std::error::Error>> {    match unsafe { fork() }? {        ForkResult::Parent { child } => {            println!("親: 子プロセス {} の終了を待機", child);                        // waitpid()で子プロセスの終了を待つ            // これによりゾンビプロセスを防ぐ            let status = waitpid(child, None)?;            println!("親: 子プロセスが終了 - {:?}", status);        }        ForkResult::Child => {            println!("子: 2秒間作業します...");            std::thread::sleep(std::time::Duration::from_secs(2));            println!("子: 作業完了！");            std::process::exit(0);        }    }        Ok(())}ステップ3: プロセスグループの管理複数のプロセスをグループとして管理し、まとめてシグナルを送信できます。use nix::sys::signal::{killpg, Signal};use nix::unistd::{fork, setpgid, ForkResult, Pid};fn main() -> Result<(), Box<dyn std::error::Error>> {    match unsafe { fork() }? {        ForkResult::Parent { child } => {            // 子プロセスを新しいプロセスグループのリーダーにする            setpgid(child, child)?;            println!("親: プロセスグループ {} を作成", child);                        // さらに子プロセスを同じグループに追加（省略）                        // グループ全体にシグナルを送信            std::thread::sleep(std::time::Duration::from_secs(2));            println!("親: グループ全体にSIGTERMを送信");            killpg(child, Signal::SIGTERM)?;        }        ForkResult::Child => {            // 新しいプロセスグループを作成            let my_pid = nix::unistd::getpid();            setpgid(my_pid, my_pid)?;                        // グループ内で作業            loop {                std::thread::sleep(std::time::Duration::from_secs(1));                println!("子: 作業中...");            }        }    }        Ok(())}4. 実用的な実装：ProcessGuardパターンRAIIを活用した安全なプロセス管理実際のプロジェクトでは、プロセスのライフサイクルを確実に管理する必要があります。こういうのは世の中に知見がたくさんあるのでちゃんと調べて行きましょう。今回はRustのRAII（Resource Acquisition Is Initialization）パターンを活用しましょう。use nix::sys::signal::{kill, Signal};use nix::unistd::Pid;use std::process::{Child, Command};/// プロセスの自動クリーンアップを保証する構造体pub struct ProcessGuard {    child: Option<Child>,    name: String,}impl ProcessGuard {    pub fn new(command: &str) -> std::io::Result<Self> {        let child = Command::new(command).spawn()?;        Ok(Self {            child: Some(child),            name: command.to_string(),        })    }        pub fn wait(&mut self) -> std::io::Result<std::process::ExitStatus> {        if let Some(mut child) = self.child.take() {            child.wait()        } else {            Err(std::io::Error::new(                std::io::ErrorKind::Other,                "Process already terminated"            ))        }    }}impl Drop for ProcessGuard {    fn drop(&mut self) {        if let Some(mut child) = self.child.take() {            // まだ実行中かチェック            if child.try_wait().ok().flatten().is_none() {                eprintln!("Terminating process: {}", self.name);                                // まずSIGTERMで優雅に終了を試みる                let pid = Pid::from_raw(child.id() as i32);                let _ = kill(pid, Signal::SIGTERM);                                // 少し待つ                std::thread::sleep(std::time::Duration::from_millis(500));                                // まだ生きていればSIGKILL                if child.try_wait().ok().flatten().is_none() {                    let _ = child.kill();                }                                // 必ずwait()してゾンビプロセスを防ぐ                let _ = child.wait();            }        }    }}// 使用例fn main() -> std::io::Result<()> {    {        let mut guard = ProcessGuard::new("sleep")?;        println!("プロセスを起動しました");                // スコープを抜けると自動的にクリーンアップ    } // ここでDropが呼ばれる        println!("プロセスは自動的に終了されました");    Ok(())}5. セキュリティ：入力検証とサニタイゼーションコマンドインジェクション対策ユーザー入力を含むコマンド実行は非常に危険です。悪意がなくても失敗する可能性があるものはいつか失敗します。ちなみに普通に入力は適切な検証が必要です。use thiserror::Error;#[derive(Error, Debug)]pub enum ProcessError {    #[error("Invalid input: {0}")]    InvalidInput(String),        #[error("Security violation: {0}")]    SecurityViolation(String),        #[error("IO error: {0}")]    Io(#[from] std::io::Error),}/// 安全な入力検証pub fn validate_input(input: &str) -> Result<&str, ProcessError> {    // 危険な文字をチェック    const DANGEROUS_CHARS: &[char] = &[        ';', '&', '|', '$', '`', '>', '<',         '(', ')', '{', '}', '\n', '\r', '\0'    ];        for &ch in DANGEROUS_CHARS {        if input.contains(ch) {            return Err(ProcessError::SecurityViolation(                format!("Dangerous character '{}' detected", ch)            ));        }    }        // パストラバーサル対策    if input.contains("..") || input.starts_with('~') {        return Err(ProcessError::SecurityViolation(            "Path traversal detected".into()        ));    }        // コマンド置換パターンをチェック    let dangerous_patterns = ["$(", "${", "&&", "||"];    for pattern in dangerous_patterns {        if input.contains(pattern) {            return Err(ProcessError::SecurityViolation(                format!("Dangerous pattern '{}' detected", pattern)            ));        }    }        Ok(input)}// 使用例fn safe_execute(user_input: &str) -> Result<(), ProcessError> {    let safe_input = validate_input(user_input)?;        let output = std::process::Command::new("echo")        .arg(safe_input)        .output()?;        println!("Safe output: {}", String::from_utf8_lossy(&output.stdout));    Ok(())}リソース制限の設定www.linkedin.comプロセスが使用できるリソースを制限することで、システム全体への影響を防げます。#[cfg(target_os = "linux")]use nix::sys::resource::{setrlimit, Resource};#[cfg(target_os = "linux")]fn set_resource_limits() -> nix::Result<()> {    // CPU時間を10秒に制限    setrlimit(Resource::RLIMIT_CPU, 10, 10)?;        // メモリを100MBに制限    let memory_limit = 100 * 1024 * 1024; // 100MB in bytes    setrlimit(Resource::RLIMIT_AS, memory_limit, memory_limit)?;        // プロセス数を50に制限    setrlimit(Resource::RLIMIT_NPROC, 50, 50)?;        Ok(())}6. 高度な実装例：プロセスプール複数のワーカープロセスを管理実際のシステムでは、複数のワーカープロセスを効率的に管理する必要があります。use std::sync::{Arc, Mutex};use std::collections::HashMap;use nix::unistd::Pid;pub struct ProcessPool {    workers: Arc<Mutex<HashMap<Pid, ProcessGuard>>>,    max_workers: usize,}impl ProcessPool {    pub fn new(max_workers: usize) -> Self {        Self {            workers: Arc::new(Mutex::new(HashMap::new())),            max_workers,        }    }        pub fn spawn_worker(&self, command: &str) -> Result<Pid, ProcessError> {        let mut workers = self.workers.lock().unwrap();                if workers.len() >= self.max_workers {            return Err(ProcessError::InvalidInput(                "Maximum workers reached".into()            ));        }                let child = std::process::Command::new(command)            .spawn()            .map_err(|e| ProcessError::Io(e))?;                let pid = Pid::from_raw(child.id() as i32);        let guard = ProcessGuard {            child: Some(child),            name: command.to_string(),        };                workers.insert(pid, guard);        Ok(pid)    }        pub fn terminate_worker(&self, pid: Pid) -> Result<(), ProcessError> {        let mut workers = self.workers.lock().unwrap();                if let Some(mut guard) = workers.remove(&pid) {            guard.wait()?;            Ok(())        } else {            Err(ProcessError::InvalidInput(                "Worker not found".into()            ))        }    }        pub fn active_workers(&self) -> usize {        self.workers.lock().unwrap().len()    }}// 使用例fn main() -> Result<(), Box<dyn std::error::Error>> {    let pool = ProcessPool::new(5);        // ワーカーを起動    for i in 0..3 {        let pid = pool.spawn_worker("sleep")?;        println!("Started worker {}: PID={}", i, pid);    }        println!("Active workers: {}", pool.active_workers());        // プールがスコープを抜けると全ワーカーが自動終了    Ok(())}7. 非同期処理との統合（Tokio）Tokioを使った非同期プロセス管理docs.rs大規模なシステムでは、非同期処理と組み合わせることが重要です。use tokio::process::Command;use tokio::time::{timeout, Duration};#[tokio::main]async fn main() -> Result<(), Box<dyn std::error::Error>> {    // 非同期でコマンド実行    let output = Command::new("echo")        .arg("Hello, async!")        .output()        .await?;        println!("Output: {}", String::from_utf8_lossy(&output.stdout));        // タイムアウト付き実行    let result = timeout(        Duration::from_secs(2),        Command::new("sleep").arg("10").output()    ).await;        match result {        Ok(Ok(_)) => println!("Command completed"),        Ok(Err(e)) => println!("Command failed: {}", e),        Err(_) => println!("Command timed out"),    }        Ok(())}8. デバッグとテスト単体テストの実装プロセス管理のコードは、適切にテストすることが重要です。#[cfg(test)]mod tests {    use super::*;    use std::time::Instant;        #[test]    fn test_input_validation() {        // 安全な入力        assert!(validate_input("hello.txt").is_ok());                // 危険な入力        assert!(validate_input("; rm -rf /").is_err());        assert!(validate_input("$(whoami)").is_err());        assert!(validate_input("../../../etc/passwd").is_err());    }        #[test]    fn test_process_timeout() {        let start = Instant::now();                let mut guard = ProcessGuard::new("sleep").unwrap();                // 1秒でタイムアウト        std::thread::sleep(std::time::Duration::from_secs(1));        drop(guard); // 強制的にDropを呼ぶ                // 2秒以内に終了していることを確認        assert!(start.elapsed() < std::time::Duration::from_secs(2));    }        #[test]    fn test_process_pool() {        let pool = ProcessPool::new(2);                // 最大数まで起動できることを確認        assert!(pool.spawn_worker("true").is_ok());        assert!(pool.spawn_worker("true").is_ok());                // 最大数を超えるとエラー        assert!(pool.spawn_worker("true").is_err());    }}統合テスト実際のプロセスを起動して動作を確認します。// tests/integration_test.rsuse std::process::Command;use std::time::Duration;#[test]fn test_zombie_prevention() {    // 子プロセスを起動    let mut child = Command::new("sh")        .arg("-c")        .arg("sleep 0.1")        .spawn()        .expect("Failed to spawn");        // プロセスの終了を待つ    let status = child.wait().expect("Failed to wait");    assert!(status.success());        // psコマンドでゾンビプロセスがないことを確認    let output = Command::new("ps")        .arg("aux")        .output()        .expect("Failed to run ps");        let ps_output = String::from_utf8_lossy(&output.stdout);    assert!(!ps_output.contains("<defunct>"));}まとめRustでプロセス管理システムを実装する際のポイントをまとめます。std::processから始める簡単な用途には標準ライブラリで十分パイプや環境変数の設定も可能多くの場合、これだけで要件を満たせるnixクレートが必要な場面シグナルの細かい制御が必要プロセスグループの管理fork()やexec()の直接的な使用リソース制限の設定実装のベストプラクティスRAIIパターンの活用: ProcessGuardでリソースの自動解放入力検証の徹底: コマンドインジェクション対策エラーハンドリング: thiserrorで構造化されたエラーテストの充実: 単体テストと統合テストの両方Rustの優位性メモリ安全性: 所有権システムによる確実なリソース管理ゼロコスト抽象化: 高レベルAPIでも性能劣化なし型システム: コンパイル時のバグ検出並行性: Send/Syncトレイトによる安全な並行処理長期運用するシステムでは、これらの特性が大きなメリットとなります。特に、ゾンビプロセスの防止やリソースリークの回避が、コンパイル時に保証される点は、運用の安定性に大きく貢献します。The Linux Programming Interface: A Linux and UNIX System Programming Handbook作者:Kerrisk, MichaelNo Starch PressAmazonLinuxプログラミングインタフェース作者:Michael KerriskオライリージャパンAmazon今後は、分散システムでのプロセス管理や、より高度なモニタリング機能の実装を予定しています。Rustのエコシステムは急速に発展しており、プロセス管理の分野でも新しい可能性が広がっています。github.com]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[DockerからECSへ 〜 AWSの海に出る前に知っておきたいこと 〜]]></title>
            <link>https://speakerdeck.com/ota1022/dockerkaraecshe-awsnohai-nichu-ruqian-nizhi-tuteokitaikoto</link>
            <guid isPermaLink="false">https://speakerdeck.com/ota1022/dockerkaraecshe-awsnohai-nichu-ruqian-nizhi-tuteokitaikoto</guid>
            <pubDate>Thu, 21 Aug 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[JAWS-UGコンテナ支部 入門編 #8 初心者大歓迎LT大会のLT登壇資料です。https://jawsug-container.connpass.com/event/361918/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Dataprepを使ってデータ編集レシピを作ってみた]]></title>
            <link>https://zenn.dev/akasan/articles/ebd4be0540c5f2</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/ebd4be0540c5f2</guid>
            <pubDate>Wed, 20 Aug 2025 11:51:38 GMT</pubDate>
            <content:encoded><![CDATA[今回はDataprepを利用してTitanicデータセットを加工してみようと思います。 Dataprepとは？Dataprepとは、Alteryxと共同で構築されたGoogleのセルフサービスデータ準備ツールです。BigQueryなどのデータソースからデータを取得してレシピを通して加工し、再度BigQueryやCloud Storageなどに格納するといったデータの処理を実行することができます。Dataprepを利用することでデータのクリーニングや変換などを一つのプラットフォームで可視化しながら実行できるため、データエンジニアリングに大きく貢献します。なお、今回の検証ではトライア...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[BigQueryMLを用いてtitanic生存者予測タスクをやってみた]]></title>
            <link>https://zenn.dev/akasan/articles/4ac96d153149c7</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/4ac96d153149c7</guid>
            <pubDate>Tue, 19 Aug 2025 11:28:44 GMT</pubDate>
            <content:encoded><![CDATA[今回はタイトルにあるように、BigQueryMLを用いてtitanicの生存者予測タスクに取り組めるモデルを開発してみました。なお、今回BigQueryMLを利用するにあたり、クエリの生成にはGPT-5を存分に利用しました。 実際にやってみる！ BigQueryにデータセットをアップロードするまずはtitanicのデータセットをBigQueryにアップロードします。以下の手順でデータを準備します。titanicデータセットをダウンロードするBigQueryにてtitanicデータセットを作成するtitanicデータセットに対してtrainとtestというテーブルを登録...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vertex AIのModel Garden調査　〜基盤モデル〜]]></title>
            <link>https://zenn.dev/akasan/articles/adca86f2802773</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/adca86f2802773</guid>
            <pubDate>Mon, 18 Aug 2025 10:42:05 GMT</pubDate>
            <content:encoded><![CDATA[今回はVertex AIのModel Gardenで提供されているText Generation用の基盤モデルについて何が提供されているかまとめてみます。全ては網羅せず、ざっくり眺めてみます。※ Model Gardenで説明に利用されているサムネイルのテキストから要約しています。モデルの詳細などは省略します。 Gemini系 Gemini 2.5 Proコーディングおよび複雑なプロンプトに特に強く対応 Gemini 2.5 Flashリーズニングとレスポンススピードの両方がバランスよく使える Imagen系列 Imagen Ultra 4 for im...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Gemma3 270M がでたらしいのでスペックを見てみる]]></title>
            <link>https://zenn.dev/satohjohn/articles/0866bbd4b2cefa</link>
            <guid isPermaLink="false">https://zenn.dev/satohjohn/articles/0866bbd4b2cefa</guid>
            <pubDate>Sun, 17 Aug 2025 15:17:18 GMT</pubDate>
            <content:encoded><![CDATA[概要説明を見ている限り LLM にしてはめちゃくちゃ軽いなという印象があります（桁が違う）がそれがどういうことなのかを見てみます。 3行まとめローカル(M3 MacBook Pro のメモリ 16GB)で動かす分に関しては全く問題なく動かせる。普通のアプリケーション動かすのと大差なく周りに影響もないシンプルなユースケースに限られる。（後に検証Cloud Run GPU NVIDIA L4 1台で十分スピード感出せる (簡単な文章 200ms程度で返却できるイメージ) docker で動かすモデルが https://hub.docker.com/r/ai/gemm...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Eventarcを用いてCloud Storageへのファイルアップロードイベントを検知してみた]]></title>
            <link>https://zenn.dev/akasan/articles/ca5a602c2482f5</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/ca5a602c2482f5</guid>
            <pubDate>Sun, 17 Aug 2025 12:30:42 GMT</pubDate>
            <content:encoded><![CDATA[今回はEventarcを利用して、Cloud Storageにファイルがアップロードされたことを検知してCloud Runのエンドポイントを呼び出してみました。以前Pub/Subを使ってBigQueryと連携することはしてみましたが、今回はEventarcを使ってみました。https://zenn.dev/akasan/articles/e17a1867408c53 早速試してみる今回は以下の公式ドキュメントを参考に進めました。https://cloud.google.com/run/docs/tutorials/eventarc?hl=ja#before-you-begin...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google Cloud RunのDocker Compose対応]]></title>
            <link>https://speakerdeck.com/aminevg/google-cloud-runnodocker-composedui-ying</link>
            <guid isPermaLink="false">https://speakerdeck.com/aminevg/google-cloud-runnodocker-composedui-ying</guid>
            <pubDate>Sun, 17 Aug 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Google Cloud RunがDocker Composeに対応しました！。これで、既存のDockerfileを活用してCloud Runにデプロイできるようになりました。複数のコンテナをまとめて単一サービスとしてデプロイのも便利です。一方で、モノレポへの不向きだったり、複数のサービスをデプロイできなかったり、デメリットもあります。今後はTerraform対応やCompose機能の拡充を期待しています。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2025年8月版読んでいて良かった本紹介]]></title>
            <link>https://zenn.dev/akasan/articles/e8c40a51231ade</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/e8c40a51231ade</guid>
            <pubDate>Sat, 16 Aug 2025 13:06:36 GMT</pubDate>
            <content:encoded><![CDATA[8月も気づけば中盤になってきましたね。先月に続いて、今月読んでいた本を紹介しようと思います。7月版はこちらになりますので、ご興味があればぜひ参照してください！https://zenn.dev/akasan/articles/05fc81a6ab77e5 データ分析 Python実践データ分析100本ノック最近改めてデータ分析をやり直そうと思ってこちらの書籍をやってます。データ分析入門書としては結構有名な気がします！Pythonでpandasとかを用いてデータ分析を始めたい人はぜひ参考にしてください。https://www.amazon.co.jp/Python実践データ分析...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[OptunaとPyTorch Lightningを組み合わせてモデルの最適化をしてみた]]></title>
            <link>https://zenn.dev/akasan/articles/a75361d039906f</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/a75361d039906f</guid>
            <pubDate>Fri, 15 Aug 2025 11:10:23 GMT</pubDate>
            <content:encoded><![CDATA[今回はOptunaとPyTorch Lightningを組み合わせてモデルの最適化をしてみようと思います。なお、Optunaは昨日紹介した記事を、Pytorch Lightningについてはこちらの記事をベースに進めようと思います。https://zenn.dev/akasan/articles/ca4ab7c5f5da15https://zenn.dev/akasan/articles/2b625606090524 それでは早速やってみる！ 環境構築uvを使って環境構築していきます。uv init optuna_pytorch_lightning -p 3.12cd ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Optunaに入門してみた]]></title>
            <link>https://zenn.dev/akasan/articles/ca4ab7c5f5da15</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/ca4ab7c5f5da15</guid>
            <pubDate>Thu, 14 Aug 2025 13:23:43 GMT</pubDate>
            <content:encoded><![CDATA[今回はOptunaを利用してパラメータ最適化に入門してみたので共有します。 Optunaとは？OptunaとはPreferred Networksによって開発されているパラメータ最適化ライブラリになります。例えばディープラーニングで様々なハイパーパラメータの組み合わせを効率的に探索して最適モデルを検討するような使い方ができます。主な特徴としては以下があるようです。Eager search spaces: Pythonの条件文やループ、構文を使用した自動的なハイパーパラメータ探索State-of-the-art algorithm: 大規模な空間を効率的に探索し、見込みのない...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[缶つぶし機とソフトウェア移行技術 - Refactoring to Rust の読書感想文]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/08/14/143527</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/08/14/143527</guid>
            <pubDate>Thu, 14 Aug 2025 05:35:27 GMT</pubDate>
            <content:encoded><![CDATA[はじめに——あるいは、「知っている」と「理解している」の間Rustのことは、知っていた。学習もしていた。実務でも使っていた。でも、それは知っているつもりだった。知ってるつもり　無知の科学 (ハヤカワ文庫NF)作者:スティーブン スローマン,フィリップ ファーンバック早川書房Amazon日々Rustで開発し、BoxとRcとArcを使い分け、tokio::spawnでタスクを生成し、?演算子を当たり前のように書いている。FFI？PyO3使えばいいでしょ。WebAssembly？wasm-bindgenがあるじゃない。技術的には、確かに「使える」レベルにはあった。でも、心のどこかで感じていた違和感があった。オートバイのエンジンを分解できる人と、エンジンが動く原理を理解している人は違う。コードが動くことと、なぜそう書くべきかを理解することも違う。私は前者だった。メカニックではあったが、エンジニアではなかった。なぜRustはこんなに厳格なのか。なぜ所有権という概念が必要なのか。なぜunsafeをあんなに忌避するのか。これらの「なぜ」に対して、私は技術的な回答はできた。でも、それは表面的な理解に過ぎなかった。部品の名前と用法は知っているが、設計思想は理解していなかった。『Refactoring to Rust』を手に取った理由は、この雰囲気で掴んでいた知識を、哲学として理解したかったから。O'Reilly Learningでパラパラと眺めた時、これは単なる技術書ではないと直感した。Refactoring to Rust (English Edition)作者:Mara, Lily,Holmes, JoelManningAmazon例えば、「段階的改善」という言葉。実践はしていた。小さく始めて大きく育てる。でも、それがMartin Fowlerの『リファクタリング』から連なる系譜の中にあり、「big bang-style rewrites」への明確なアンチテーゼとして位置づけられていることは知らなかった。リファクタリング(第2版): 既存のコードを安全に改善する (OBJECT TECHNOLOGY SERIES)作者:Martin Fowler 著オーム社Amazon例えば、FFIの境界。PyO3を使えば簡単に境界を越えられる。でも、その境界が「信頼の切れ目」であり、unsafeが「コンパイラが保証できない領域」の明示的な宣言であることの深い意味は、理解していなかった。この読書記録は、一人のRustを実装している人間が、散在していた知識の点を線で結び、線を面にし、そして立体的な理解へと昇華させていく過程の記録である。Kent Beckが「恐怖を退屈に変える」と表現したこと。John Ousterhoutが「深いモジュール」と呼んだもの。これらの古典的な知恵が、Rustという現代の言語でどう具現化されているか。それを理解することで、私の「なんとなく」が「なるほど」に変わっていく。そして、Firecracker VMMやPolarsといった産業グレードのプロジェクトを通じて、教科書的な理想と現実の実装の間にある溝も見えてきた。美術館のアートワーク管理という優雅な例から、(*(*request.request_body).bufs).bufという呪文のような現実へ。この振れ幅こそが、実践の本質だった。さあ、「雰囲気」から「哲学」へ、「使える」から「理解する」への旅を振り返ります。また、気になればぜひ、読んでみてほしいです。あなたにとっても学びが多いハズです。learning.oreilly.comwww.manning.comこのブログが良ければ読者になったり、nwiizoのXやGithubをフォロワーしてくれると嬉しいです。では、早速はじめていきます。第1章 Why refactor to Rust第1章「Why refactor to Rust」を読んで最初に感じたのは、著者がRustという言語の技術的優位性よりも段階的改善という哲学に重点を置いているということだった。表面的にはパフォーマンスやメモリ安全性という技術的要素を説明しているが、その根底にはソフトウェアシステムの漸進的進化という時代を超えた課題が埋め込まれている。リファクタリングという外科手術本章で著者が「big bang-style rewrites」と呼ぶ完全書き換えへの批判は、Martin Fowlerの「リファクタリング」で語られる原則と深く共鳴する。動いているシステムを止めずに改善する——この一見当たり前のような要求が、どれほど難しく、そして重要なのか。Release It! 本番用ソフトウェア製品の設計とデプロイのために作者:Michael T. Nygardオーム社AmazonFigure 1.1 How refactoring and rewriting affect the size of deployments より引用著者は、リファクタリングとリライトの違いを「手術の規模」になぞらえて説明する。完全書き換えが臓器移植だとすれば、リファクタリングは腹腔鏡手術のようなものだ。小さな切開から始めて、最小限の侵襲で問題を解決する。この比喩は単なる文学的装飾じゃない。リスク管理の本質を突いている。Kent Beckの「Tidy First?」では、コードの整理（tidying）と振る舞いの変更（behavior change）を明確に分離することの重要性が説かれている。Rustへの段階的移行は、まさにこの原則の実践例だと思った。既存のPythonやRubyのコードはそのまま動かしながら、パフォーマンスクリティカルな部分だけをRustで「整理」する。振る舞いは変えずに、実装だけを置き換える。Tidy First? ―個人で実践する経験主義的ソフトウェア設計作者:Kent Beckオーム社Amazonでも、現実はそう単純じゃない。CSVパーサーの寓話本章で示されたCSVパーサーの例——PythonとRustで実装した同じ機能が20倍の性能差を示すという話——は魅力的だけど、同時に危険でもある。Cherry-picked exampleだと著者自身が認めているように、これは最良のケースだ。Science Fictions　あなたが知らない科学の真実作者:スチュアート・リッチーダイヤモンド社Amazonスチュアート・リッチーの「サイエンス・フィクションズ」を読んだ後だと、このような都合の良いベンチマーク結果には警戒心を抱かざるを得ない。科学の世界でさえ、再現性の危機や出版バイアスに悩まされている。技術書のベンチマークも同じ罠に陥りやすい。20倍の性能改善という数字は人を惹きつけるが、それは全体像を表しているだろうか？実際のプロダクションコードでは、PandasやNumPyのような高度に最適化されたC拡張を使っているだろう。純粋なPythonのループと比較するのはフェアじゃない。でも、ここで重要なのは絶対的な性能差じゃなくて、メモリアロケーションの制御という概念だと気づいた。def sum_csv_column(data, column):  sum = 0  for line in data.split("\n"):    if len(line) == 0:      continue    value_str = line.split(",")[column]    sum += int(value_str)  return sumRustの.split()がイテレータを返し、メモリを再利用するという説明は、John Ousterhoutの「A Philosophy of Software Design」で語られる「深いモジュール」の概念を思い出させる。シンプルなインターフェースの裏に、複雑だが強力な実装が隠されている。Rustのゼロコスト抽象化は、まさにこの理想を体現している。fn sum_csv_column(data: &str, column: usize) -> i64 {    let mut sum = 0;    for line in data.lines() {    if line.len() == 0 {      continue;    }    let value_str = line      .split(",")      .nth(column)      .unwrap();  #3    sum += value_str.parse::<i64>().unwrap();   }  sum}A Philosophy of Software Design, 2nd Edition (English Edition)作者:Ousterhout, John K. Amazon所有権という約束C/C++プログラマーに向けた「メモリ安全性」のセクションを読んで、Rustの所有権システムが単なる技術的な仕組みじゃなくて、プログラマーとコンパイラの間の契約だということを改めて認識した。従来のC/C++では、メモリの所有権は「プログラマーの頭の中」にしか存在しなかった。コメントやドキュメント、命名規則で暗黙的に管理されていた。Rustはこの暗黙知を明示的な型システムに昇華させた。これは単なる安全性の向上じゃない。チーム開発における認知負荷の軽減でもある。でも、Rustの学習曲線は急峻だ。借用チェッカーとの格闘は、多くの開発者にとって最初の——そして時に最後の——障壁となる。著者はこの点について楽観的すぎるかもしれない。型システムの再発見JavaのHashMapの冗長な初期化コードと、Rustの型推論を対比させる部分は巧妙だった。でも、これは半分しか真実を語っていない。確かにRustの型推論は優秀だ。でも、ライフタイムパラメータが絡むと話は変わる。HashMap<&'a str, Vec<&'b str>>みたいな型シグネチャは、Java以上に威圧的だ。TypeScriptやKotlinのような現代的な言語と比較すると、Rustの型システムはパワフルだが複雑という評価が妥当だろう。それでも、「テスト駆動開発」のKent Beckが言うように、「恐怖を退屈に変える」ことが重要だ。Rustの型システムは、実行時の恐怖をコンパイル時の退屈な作業に変換する。segfaultの恐怖が、借用チェッカーとの退屈な格闘に変わる。これは良いトレードオフだと思う。FFIという橋第1章の後半で紹介される統合手法——C FFI、言語固有のバインディング、WebAssembly——は、異なる世界をつなぐ橋のようだ。PyO3やwasm-bindgenのような高レベルなバインディングツールの存在は心強い。最近知ったmluaというRust-Luaバインディングも興味深い。Neovimのプラグイン開発でRustを使いたい場合、cargo.nvimを開発したときに使ったのだがmluaを活用してLuaとRustをシームレスに統合している。エディタの拡張機能までRustで書ける時代が来たのだ。これは単なる技術的な遊びじゃなくて、パフォーマンスクリティカルなテキスト処理や、複雑な静的解析をエディタ内で実行する実用的なユースケースがある。でも、FFIの境界では、Rustの安全性保証が部分的に失われることを忘れてはいけない。unsafeブロックは必要悪だが、それでも悪だ。直接呼び出しアーキテクチャFigure 1.3が示す「Rustコードが通常のモジュールのように見える」というアプローチは、認知的な連続性を保つ上で重要だ。開発者から見れば、PythonのモジュールをインポートするのとRustで書かれたモジュールをインポートするのに違いはない。この透明性が、段階的移行を成功させる鍵だ。Figure 1.3 When calling Rust directly from your existing application, your Rust code looks like a normal module.でも、この簡潔さの裏には、メモリの所有権、エラーハンドリング、型変換といった複雑な変換層が隠されている。PyO3が#[pyfunction]マクロで隠蔽する複雑さは、まさに抽象化の芸術だ。開発者は細部を気にせず、ビジネスロジックに集中できる。サービス分離アーキテクチャ一方、Figure 1.4が示すネットワーク経由のアプローチは、マイクロサービスアーキテクチャの文脈で理解すべきだろう。Figure 1.4 When Rust code is in an external service, there is additional overhead due to the network hop. より引用ネットワークホップのオーバーヘッドは確かに存在する。でも、このアプローチには別の利点がある。独立したデプロイメント、言語に依存しないインターフェース、水平スケーリングの容易さ。これはSam Newmanの「マイクロサービスアーキテクチャ」で語られる、強い境界による弱い結合の実現だ。どちらを選ぶかは、トレードオフの問題だ。レイテンシが重要なら前者、運用の独立性が重要なら後者。でも、最初は前者から始めて、状況に応じて後者に移行するという段階的な進化も可能だ。これこそが、本書が提案する実用主義的アプローチの真骨頂だろう。興味深いのは、WebAssemblyという第三の選択肢だ。WASMは単なるブラウザ技術じゃなくて、言語中立的なランタイムとして進化している。WasmerやWasmtimeのようなスタンドアロンランタイムを使えば、Rustで書いたコードをどこでも動かせる。これは「Write Once, Run Anywhere」の新しい形かもしれない。いつ使わないべきか「When not to refactor to Rust」のセクションは、本章で最も価値のある部分かもしれない。技術書が「使わない理由」を真剣に議論することは珍しい。特に「あなたが会社で唯一のRust推進者なら」という警告は重要だ。Bus factor 1のシステムを作ることは、技術的負債の別の形だ。Goが成功した理由の一つは、学習曲線が緩やかで、チーム全体が習得しやすかったことだ。Rustはこの点で不利だ。組織的な準備なしにRustを導入することは、「Tidy First?」でKent Beckが警告する「整理のための整理」に陥る危険がある。技術的に優れた解決策が、必ずしもビジネス的に正しい選択とは限らない。Rustという選択の合理性著者は「empowering」「welcoming」「reliable」「efficient」というRustの特徴を挙げている。でも、これらは他の言語でも主張されている。本当の差別化要因は何か？私は、Rustの価値はゼロコスト抽象化とメモリ安全性の両立にあると思う。C++は前者を、Goは後者を提供する。両方を同時に提供するのはRustだけだ（Zigも近いが、まだ成熟していない）。Discordが最近発表したように、彼らはGoからRustに移行することで、レイテンシのスパイクを劇的に削減した。これはGCの存在が根本原因だった。リアルタイム性が求められるシステムでは、予測可能なパフォーマンスが重要だ。Rustはこれを保証する。実用主義者のためのRust第1章を読んで、この本が提案しているのは実用主義的なRust導入戦略だとわかった。完璧主義者のための完全書き換えじゃなくて、現実主義者のための段階的改善。Martin Fowlerが「リファクタリング」で述べたように、「プログラムを動かし続けながら、設計を改善する」ことが重要だ。Rustへの移行も同じ原則に従うべきだ。測定し、最も痛みを感じる部分を特定し、外科手術的に改善する。でも、忘れてはいけない。技術は手段であって目的じゃない。Rustが解決するのは技術的な問題だけだ。組織的な問題、プロセスの問題、人の問題は残る。それでも、適切に使われたRustは、システムの進化を可能にする強力なツールだ。恐怖を退屈に変え、不確実性を型システムに閉じ込め、並行性を安全にする。これらは小さな改善じゃない。ソフトウェアの品質に対する根本的な再考だ。次の章では、具体的な測定と分析の手法が語られるだろう。楽しみだ。なぜなら、「測定できないものは改善できない」からだ。でも、測定だけでは不十分だ。行動が必要だ。そして、その行動の一つが、Rustへの段階的な移行かもしれない。ただし、銀の弾丸はない。Fred Brooksが50年前に警告したように。Rustも例外じゃない。でも、適切に使えば、強力な道具になる。問題は、いつ、どこで、どのように使うかだ。この本は、その問いに答えようとしている。理想的な答えじゃないかもしれない。でも、始まりとしては十分だ。第2章 An overview of Rust第2章「An overview of Rust」を読んで最初に感じたのは、著者が所有権や借用という技術的メカニズムよりもメモリ管理の責任の所在に重点を置いているということだった。表面的にはRustの基本的な言語機能を説明しているが、その根底にはプログラマーとコンパイラの契約関係の再定義という時代を超えた課題が埋め込まれている。美術館のメタファーが語るもの著者が選んだ美術館のアートワーク管理システムという例は、単なる教育的な配慮じゃない。これは所有と共有のパラドックスを表現する巧妙な選択だ。美術作品は一つしか存在しないが、多くの人に鑑賞されなければならない。この物理世界の制約が、そのままRustのメモリモデルに投影されている。fn admire_art(art: Artwork) {  println!("Wow, {} really makes you think.", art.name);}このコードが最初のコンパイルエラーを生むとき、初学者は戸惑うだろう。なぜ同じ作品を二度鑑賞できないのか？ でも、これこそがRustの本質だ。所有権の移動（move）は、責任の移譲を意味する。美術館から作品が消えてしまうのだ。John Ousterhoutの「A Philosophy of Software Design」では、複雑性を制御する方法として「深いモジュール」の概念が提唱されている。シンプルなインターフェースの裏に複雑な実装を隠すという考え方だ。でも、Rustの所有権システムは逆のアプローチを取る。複雑性を型システムに露出させることで、実行時の複雑性を排除する。この選択は、トレードオフだ。学習コストと引き換えに、実行時の安全性を得る。でも、本当にこれは「複雑性の露出」なのだろうか？ むしろ、本質的な複雑性の顕在化かもしれない。メモリ管理は元々複雑だ。C/C++はそれを隠していただけで、Rustは正直に見せている。ライフタイムグラフという可視化本章で導入されるライフタイムグラフは、革新的な教育ツールだと思った。Figure 2.5 The lifetime graph for listing 2.9 より引用このグラフが示すのは、単なる変数の生存期間じゃない。責任の流れだ。誰が、いつ、何に対して責任を持つのか。これはDomain-Driven Designにおける集約（Aggregate）の境界定義に似ている。データの一貫性を保証するために、明確な境界と責任者が必要だ。Eric Evansは集約のルートを通じてのみ内部オブジェクトにアクセスすることを推奨している。Rustの所有権も同じだ。所有者を通じてのみ、値にアクセスできる。借用は一時的なアクセス権で、集約の境界を越えた参照に似ている。でも、現実のプロジェクトでこのような可視化ツールはあるだろうか？ rust-analyzerやIntelliJ Rustプラグインは、借用チェッカーのエラーを表示してくれるが、ライフタイムの全体像を俯瞰することは難しい。aquascopeやrustowlというツールが登場しているので今後も注目していきたい。「K言語」という思考実験の深層著者が導入する架空の「K言語」——Pythonに手動メモリ管理を追加した言語——は秀逸な思考実験だ。def welcome(name):  print('Welcome ' + name)  free(name)  # 誰がこの責任を持つべきか？この例は、C/C++プログラマーが日常的に直面するジレンマを見事に表現している。関数の暗黙的な副作用。welcome関数が引数を解放するという「隠れた契約」は、ドキュメントにしか存在しない。これは、リスコフの置換原則の違反でもある。関数のシグネチャが同じでも、メモリ管理の挙動が異なれば、安全に置換できない。C++のスマートポインタ（unique_ptr、shared_ptr）は、この問題を部分的に解決するが、Rustほど厳密じゃない。void process(std::unique_ptr<Data> data) {    // dataの所有権を取得}void observe(const Data& data) {    // dataを借用するだけ}C++でもある程度は表現できるが、コンパイラの強制力が弱い。Rustはすべての参照にライフタイムがあることを明示的に管理する。文字列型の二重性が示すものStringと&strの区別は、多くの初学者を悩ませる。でも、これは所有と借用の具現化だ。let mut x = String::with_capacity(10_000_000);  // 事前割り当てfor _ in 0..10_000_000 {    x.push('.');}著者が示す1000万個のドットを追加する例は、パフォーマンスの観点から興味深い。Pythonでは同じ操作に約10億回のアロケーションが発生する可能性があるが、Rustでは1回で済む。でも、より深い洞察は制御の粒度にある。JavaやC#のStringBuilderも似たような最適化を提供するが、Rustは言語レベルでこれを統合している。Stringは単なるデータ構造じゃない。所有権の具現化だ。実際、ripgrepのようなツールがなぜ高速なのか、この章を読むと理解できる。不要なアロケーションを避け、必要な時だけメモリを確保する。grepの何倍も高速な理由は、単にRustで書かれているからじゃない。メモリ管理を細かく制御できるからだ。エラーを値として扱う哲学の深層FizzBuzzを使ったエラーハンドリングの説明は、一見すると過剰に思える。でも、これはエラーの第一級市民化という重要な概念を示している。enum Result<T, E> {    Ok(T),    Err(E),}この定義は、HaskellのEither型に似ている。実際、Resultはモナドの一種だ。map、and_then（Haskellのbindに相当）などのメソッドを持つ。fn validate_username(username: &str) -> Result<(), UsernameError> {  validate_lowercase(username)    .map_err(|_| UsernameError::NotLowercase)?;  validate_unique(username)    .map_err(|_| UsernameError::NotUnique)?;  Ok(())}このmap_errの連鎖は、Railway Oriented Programmingを思い出させる。成功の軌道と失敗の軌道を並行して走らせ、エラーが発生したら失敗の軌道に切り替える。でも、現実のコードベースではunwrap()の乱用を見かける。GitHubで「unwrap()」を検索すると、多くのRustプロジェクトでヒットする。特にテストコードでは顕著だ。anyhowやthiserrorのようなエラーハンドリングライブラリの人気は、標準のResult型だけでは不十分なことを示している。?演算子の美学と限界let result = fizzbuzz(i)?;この小さな?記号は、エラー処理の明示的な委譲を表現する。でも、これには限界もある。Goでは、エラー処理は冗長だが明確だ。以下のようなコードになる。result, err := fizzbuzz(i)if err != nil {    return err}Rustの?は簡潔だが、エラーの変換が暗黙的になりやすい。特に、Fromトレイトを使った自動変換は、デバッグを困難にすることがある。Firecracker VMMから学ぶAWSのFirecracker VMMの実際のコードを見ると、本章で学んだ概念が産業グレードのシステムでどう実装されているかが明確になる。/// Contains the state and associated methods required for the Firecracker VMM.#[derive(Debug)]pub struct Vmm {    events_observer: Option<std::io::Stdin>,    pub instance_info: InstanceInfo,    shutdown_exit_code: Option<FcExitCode>,        // Guest VM core resources.    kvm: Kvm,    pub vm: Arc<Vm>,  // 共有所有権の明示    vcpus_handles: Vec<VcpuHandle>,    vcpus_exit_evt: EventFd,    device_manager: DeviceManager,}このコード構造から、所有権の階層的な設計が見て取れる。Vmmが全体を所有し、Arc<Vm>で仮想マシンを複数のVCPUスレッドと共有している。これは美術館で言えば、一つの作品（VM）を複数の学芸員（VCPU）が同時に管理するようなものだ。エラーハンドリングの徹底Firecrackerのエラー型定義は圧巻だ。次のような構造になっている。#[derive(Debug, thiserror::Error, displaydoc::Display)]pub enum VmmError {    /// Device manager error: {0}    DeviceManager(#[from] device_manager::DeviceManagerCreateError),    /// Cannot send event to vCPU. {0}    VcpuEvent(vstate::vcpu::VcpuError),    /// Failed to pause the vCPUs.    VcpuPause,    // ... 他にも20以上のエラーバリアント}thiserrorとdisplaydocを使った構造化されたエラー処理。これは本章で学んだResult型の産業的な実装だ。各エラーは具体的な状況に応じた文脈を持ち、#[from]属性で自動変換も定義されている。メッセージパッシングによるVCPU制御pub fn pause_vm(&mut self) -> Result<(), VmmError> {    // Send the events.    self.vcpus_handles        .iter()        .try_for_each(|handle| handle.send_event(VcpuEvent::Pause))        .map_err(|_| VmmError::VcpuMessage)?;    // Check the responses with timeout.    if self.vcpus_handles        .iter()        .map(|handle| handle.response_receiver().recv_timeout(RECV_TIMEOUT_SEC))        .any(|response| !matches!(response, Ok(VcpuResponse::Paused)))    {        return Err(VmmError::VcpuMessage);    }        self.instance_info.state = VmState::Paused;    Ok(())}このコードは防御的プログラミングの極致だ。30秒のタイムアウト（RECV_TIMEOUT_SEC）を設定し、すべてのVCPUからの応答を確認している。一つでも異常があれば即座にエラーを返す。Dropトレイトによる資源管理impl Drop for Vmm {    fn drop(&mut self) {        // グレースフルシャットダウンの保証        self.stop(self.shutdown_exit_code.unwrap_or(FcExitCode::Ok));                if let Some(observer) = self.events_observer.as_mut() {            // ターミナルをカノニカルモードに戻す            let res = observer.lock().set_canon_mode().inspect_err(|&err| {                warn!("Cannot set canonical mode for the terminal. {:?}", err);            });        }                // メトリクスの書き出し        if let Err(err) = METRICS.write() {            error!("Failed to write metrics while stopping: {}", err);        }                // VCPUスレッドの終了確認        if !self.vcpus_handles.is_empty() {            error!("Failed to tear down Vmm: the vcpu threads have not finished execution.");        }    }}このDropの実装は、RAIIパターンの教科書的な例だ。リソースの解放だけでなく、システムの一貫性も保証している。特に、VCPUスレッドが残っていないことを確認する最後のチェックは重要だ。unsafeの最小化コードの冒頭にある警告が印象的だ。次のようなものだ。#![warn(clippy::undocumented_unsafe_blocks)]これは、すべてのunsafeブロックにドキュメントを要求する。実際、500行を超えるこのファイルにunsafeは一度も登場しない。KVMとの相互作用は抽象化層で隠蔽され、安全性の境界が明確に定義されている。Firecrackerでは、panic!は最小限に抑えられている。ゲストVMの異常でホストが落ちるわけにはいかない。すべてのエラーは回復可能として扱われる。美術館から工場へ、そして戦場へ美術館のメタファーは教育的だが、現実のシステムは工場であり、時に戦場だ。tokioのような非同期ランタイムでは、所有権の管理はさらに複雑になる。次のようなパターンが必要になる。use std::sync::Arc;use tokio::sync::Mutex;let data = Arc::new(Mutex::new(vec![1, 2, 3]));let data_clone = Arc::clone(&data);tokio::spawn(async move {    let mut lock = data_clone.lock().await;    lock.push(4);});Arc<Mutex<T>>パターンは、共有所有権を表現する。これは美術館で言えば、複数の美術館が一つの作品を共同所有するようなものだ。誰も単独で破壊できないが、誰もが鑑賞できる。でも、このパターンには罠もある。デッドロックの可能性だ。Rustはデータ競合は防げるが、デッドロックは防げない。部分的な正しさの例だ。パニックという最終手段の哲学panic!("Got a negative number for fizzbuzz: {}", x);panic!の導入は、Rustの実用主義を示している。でも、これはErlangの「Let it crash」哲学とは根本的に異なる。Erlangでは、プロセスの失敗は想定内だ。次のようなコードが一般的だ。spawn_link(fun() ->    % クラッシュしても親プロセスが処理    risky_operation()end).Rustでは、パニックは想定外だ。Actix Webのようなフレームワークは、アクターモデルを使ってErlang的な耐障害性を実現しようとしているが、言語レベルのサポートはない。実際、Cloudflareのようなエッジコンピューティング環境では、パニックは許されない。一つのリクエストの失敗で、ワーカー全体が落ちるわけにはいかない。だから、徹底的なResultの使用が求められる。doc.rust-jp.rsqiita.comムーブセマンティクスの深い意味fn admire_art(art: Artwork) {    // artの所有権を取得}let art1 = Artwork { name: "La Liberté guidant le peuple".to_string() };admire_art(art1);// art1はもう使えないこの「使えなくなる」という制約は、最初は不便に感じる。でも、これはリソース管理のRAII（Resource Acquisition Is Initialization）パターンの究極形だ。C++でも似たような概念がある。以下のようなコードだ。std::unique_ptr<Artwork> art1 = std::make_unique<Artwork>();admire_art(std::move(art1));// art1は空になるでも、C++のstd::moveはヒントに過ぎない。コンパイラは強制しない。Rustのムーブは保証だ。契約の明文化から信頼の構築へ第2章を読み終えて、そして実際のFirecracker VMMのコードを見て、Rustが提案しているのは単なる暗黙を明示に変えることじゃないとわかった。それは信頼できるソフトウェアの構築方法だ。教育的な美術館から産業的な仮想化基盤へ本章の美術館の例とFirecrackerのコードを比較すると、興味深い世界が見える。教育的な例：fn admire_art(art: &Artwork) {    println!("Wow, {} really makes you think.", art.name);}産業的な実装：pub fn save_state(&mut self, vm_info: &VmInfo) -> Result<MicrovmState, MicrovmStateError> {    let vcpu_states = self.save_vcpu_states()?;    let kvm_state = self.kvm.save_state();    let vm_state = self.vm.save_state().map_err(SaveVmState)?;    let device_states = self.device_manager.save();        Ok(MicrovmState {        vm_info: vm_info.clone(),        kvm_state,        vm_state,        vcpu_states,        device_states,    })}美術館の作品を「鑑賞する」シンプルな関数から、仮想マシン全体の状態を「保存する」複雑な関数へ。でも、根底にある原則は同じだ。所有権の明確化、エラーの明示的な処理、借用による処理速度が速いアクセス。段階的な信頼の構築Firecrackerのシャットダウンシーケンスは、分散システムにおける合意形成プロトコルを思わせる：// Firecrackerのコメントより// 1. vcpu.exit(exit_code)// 2. vcpu.exit_evt.write(1)// 3. <--- EventFd::exit_evt ---// 4. vmm.stop()// 5. --- VcpuEvent::Finish --->// 6. StateMachine::finish()// 7. VcpuHandle::join()// 8. vmm.shutdown_exit_code becomes Some(exit_code)これは単なる終了処理じゃない。分散合意だ。各VCPUが独立したアクターとして動作し、メッセージパッシングで状態を同期する。ErlangやAkkaを彷彿とさせるが、Rustの型システムがより強い保証を提供している。パニックしない哲学Firecrackerのコードで最も印象的なのは、panic!の不在だ。本章ではpanic!を「最終手段」として紹介していたが、Firecrackerはそれすら使わない。/// Timeout used in recv_timeout, when waiting for a vcpu responsepub const RECV_TIMEOUT_SEC: Duration = Duration::from_secs(30);30秒という長いタイムアウト。これは楽観的ロックの逆だ。悲観的だが確実なアプローチ。VCPUがデッドロックしていることを検出するための保険だ。メトリクスという観測可能性// Write the metrics before exiting.if let Err(err) = METRICS.write() {    error!("Failed to write metrics while stopping: {}", err);}エラーが起きても、メトリクスの書き出しを試みる。これは観測可能性（Observability）への配慮だ。システムが失敗しても、なぜ失敗したかを知る手がかりを残す。「Refactoring to Rust」の意味この章とFirecrackerのコードを照らし合わせると、「Refactoring to Rust」の意味が見えてくる。それは単に：PythonをRustに書き換えることじゃないパフォーマンスを改善することじゃないメモリ安全性を得ることじゃないそれは：システムの契約を明文化することエラーを第一級市民として扱うこと所有権を通じて責任を明確化すること型システムで不変条件を保証することFirecrackerは、これらの原則を1ミリ秒のレイテンシと5MBのメモリフットプリントで実現している。これは理論の実践的な証明だ。第3章 Introduction to C FFI and unsafe Rust第3章「Introduction to C FFI and unsafe Rust」を読んで最初に感じたのは、著者がFFIという技術的な仕組みよりも異なる世界の架け橋を築く哲学に重点を置いているということだった。表面的にはunsafeブロックやポインタ操作を説明しているが、その根底には信頼境界の管理という時代を超えた課題が埋め込まれている。unsafeという名の正直さ「unsafe」という言葉は誤解を招きやすい。著者も指摘するように、これは「危険」ではなく「未検証」を意味する。より正確には「コンパイラが保証できない領域」だ。unsafe {    *solution = 1024;}このたった2行のコードが、Rustの哲学の核心を表している。通常のRustコードでは、コンパイラがメモリ安全性を保証する。でも、C言語の世界から渡されたポインタについて、コンパイラは何も知らない。信頼の連鎖が切れる場所、それがunsafeブロックだ。John Ousterhoutの「A Philosophy of Software Design」では、モジュール間の境界を明確にすることの重要性が説かれている。unsafeブロックは、まさにその境界を可視化する。「ここから先は、私（プログラマー）が責任を持つ」という宣言だ。Figure 3.1 A program’s stack memory during reference and dereference operations より引用この図が示すように、ポインタは単なるメモリアドレス——インデックスのようなものだ。でも、そのシンプルさゆえに危険でもある。doc.rust-lang.orgRPN計算機という教材の巧妙さ著者が選んだ逆ポーランド記法（RPN）計算機という例は、教育的配慮以上の意味を持つ。RPNはスタックマシンの純粋な表現だ。Infix: (3 + 4) * 12RPN  : 3 4 + 12 *     = 84Figure 3.2 RPN stack used to calculate 3 4 + 12 * より引用この例が巧妙なのは、複雑性が段階的に導入される点だ。最初は単純な二項演算、次に複数の演算の連鎖。Kent Beckの「Tidy First?」で語られる「小さな整理から始める」原則の実践例だ。でも、現実のプロジェクトはRPN計算機のようにシンプルじゃない。cbindgenのようなツールが人気なのは、手動でFFIバインディングを書くことの複雑さを物語っている。github.comメモリ共有という芸術本章で最も印象的だったのは、CとRustが同じメモリを共有している様子だ。fn evaluate(problem: &str) -> Result<i32, Error> {  println!("problem: {:p}", problem.as_ptr());  // ...}実行結果：problem: 0x7ffc117917b0  # Cのスタックアドレスterm   : 0x7ffc117917b0  # 同じアドレス！文字列が再アロケーションされることなく、Cのスタックメモリを直接参照している。これはゼロコピーの美しい実例だ。でも、この効率性には代償がある。CStr::from_ptrはunsafeだ。なぜなら、Cから渡されたポインタが：- 有効なメモリを指しているか- NULL終端されているか- UTF-8として有効かこれらをコンパイラは検証できない。プログラマーが保証しなければならない。libcという薄い抽象use libc::{c_char, c_int};libcクレートは、CとRustの型システムの違いを吸収する。C言語のintのサイズはプラットフォーム依存だが、c_intはそれを抽象化する。これは適応層パターンの実例だ。異なるインターフェースを持つシステムを接続するための薄い変換層。でも、薄すぎると危険で、厚すぎると非効率。具体的な状況に応じたバランスが重要だ。実際、PyO3のようなプロジェクトは、より高レベルな抽象を提供する：#[pyfunction]fn sum_as_string(a: usize, b: usize) -> PyResult<String> {    Ok((a + b).to_string())}PyO3では、unsafeを一切書かずにPythonとやり取りできる。でも、その裏では本章で学んだような低レベルのFFIが動いている。github.com動的ライブラリという柔軟性[lib]crate-type = ["cdylib"]この設定により、RustコードがC互換の動的ライブラリになる。$ cargo build$ gcc calculator.c -o bin -lcalculate動的リンクの利点は明確だ：- Rustコードの再コンパイル後、Cプログラムの再コンパイルが不要- メモリ効率（複数のプロセスで共有可能）- 独立したデプロイメントでも、動的ライブラリにはDLL地獄の問題もある。バージョン管理、依存関係の解決、ABI互換性——これらすべてが複雑になる。Displayトレイトという共通言語impl Display for Error {  fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {    match self {      Error::InvalidNumber => write!(f, "Not a valid number or operator"),      Error::PopFromEmptyStack => write!(f, "Tried to operate on empty stack"),    }  }}Displayトレイトの実装は、エラーメッセージの中央集権化だ。これはDomain-Driven Designのユビキタス言語の概念に通じる。エラーの意味を一箇所で定義し、どこでも同じメッセージを使う。Martin Fowlerの「リファクタリング」では、「重複の排除」が基本原則の一つだ。Displayトレイトは、エラーメッセージの重複を防ぐエレガントな方法だ。段階的移行の現実本章のRPN計算機の例は、段階的移行の理想形を示している。境界の明確化：solve関数だけを移行インターフェースの保持：同じシグネチャを維持責任の分離：FFI層（solve）とビジネスロジック（evaluate）を分離でも、現実はもっと複雑だ。実際のプロジェクトでの課題Firecracker VMMのようなプロジェクトでは、数千のFFI呼び出しがある。各呼び出しで：- エラー処理の変換- 所有権の移譲- ライフタイムの管理これらを正しく行う必要がある。一つでも間違えれば、セグメンテーションフォルトだ。github.comripgrepの作者Andrew Gallantは、「RustのFFIは強力だが、慎重に使うべき」と述べている。彼のプロジェクトでは、FFI境界を最小限に抑え、可能な限りRust側で処理を完結させている。github.comburntsushi.netunsafeの連鎖という罠let c_str = unsafe { CStr::from_ptr(line) };let r_str = match c_str.to_str() {    Ok(s) => s,    Err(e) => {        eprintln!("UTF-8 Error: {}", e);        return 1;    }};このコードは一見安全に見える。unsafeブロックは最小限で、エラー処理も適切だ。でも、unsafeの影響は局所的じゃない。もしlineポインタが無効なら、プログラム全体が未定義動作になる。これは「A Philosophy of Software Design」で警告される複雑性の漏れだ。局所的な決定が、システム全体に影響を与える。WebAssemblyという新しい選択肢本章では触れられていないが、WebAssembly（WASM）は興味深い代替案だ。#[wasm_bindgen]pub fn calculate(input: &str) -> Result<i32, JsValue> {    // ...}WASMなら：- メモリ安全性が保証される（サンドボックス環境）- 言語中立的（どの言語からも呼べる）- ポータブル（どこでも動く）でも、パフォーマンスオーバーヘッドがある。wasm-bindgenは素晴らしいツールだが、ネイティブFFIほど高速じゃない。Zigという対抗馬Zig言語は、C互換性を言語の中心に据えている。export fn add(a: i32, b: i32) i32 {    return a + b;}exportキーワードだけで、C互換の関数が作れる。#[no_mangle]やextern "C"は不要だ。これは設計の単純性の違いだ。RustはC互換性を後付けで追加したが、ZigははじめからC互換性を前提に設計された。どちらが良いかは、プロジェクトの要求次第だ。ziglang.org境界を管理する技術第3章を読み終えて、FFIが単なる技術的な仕組みじゃないことがわかった。それは異なる世界観を持つシステムを接続する哲学だ。Rustのunsafeは、「ここから先は信頼できない世界」という明示的な宣言。この正直さが、システム全体の信頼性を高める。Firecracker VMMが500行のコードでunsafeを一度も使わないのは、FFI境界を慎重に設計した結果だ。「Tidy First?」の精神で言えば、FFIは「整理」と「振る舞いの変更」の境界だ。C側のインターフェースは変えずに（振る舞いを保持）、内部実装をRustに置き換える（整理）。でも、忘れてはいけない。FFIは必要悪だ。理想的には、システム全体を一つの言語で書きたい。でも、現実には既存のコードベースがあり、段階的な移行が必要だ。次の章では、おそらくより高レベルなFFI抽象——PyO3やwasm-bindgenなど——が語られるだろう。unsafeの海から、より安全な抽象の島へ。でも、その島も結局はunsafeの海に浮かんでいることを忘れてはいけない。github.comRPN計算機は動いた。でも、これは始まりに過ぎない。実際のシステムでは、スレッド安全性、例外処理、リソース管理など、さらに多くの課題が待っている。それでも、この章が示したのは希望だ。異なる言語が協調できるという証明。完璧じゃないかもしれない。でも、実用的だ。そして時に、実用性こそが最も重要な美徳なのかもしれない。第4章 Advanced FFI第4章「Advanced FFI」を読んで最初に感じたのは、著者が単純なFFIの技術的詳細よりも複雑な既存システムとの共生戦略に重点を置いているということだった。表面的にはNGINXモジュール開発とbindgenの使い方を説明しているが、その根底にはレガシーシステムとの漸進的統合という時代を超えた課題が埋め込まれている。現実世界の複雑性という試金石第3章のRPN計算機は教育的だった。美しく、理解しやすく、制御可能だった。でも、この章のNGINX統合は戦場だ。NGINXは400万以上のウェブサイトで使われている本物のプロダクションシステム。144個のフィールドを持つngx_http_request_t構造体は、現実世界の複雑性を物語っている。struct ngx_http_request_t {  request_body: *mut ngx_http_request_body_t,  ... // 他に143個のフィールド}この巨大な構造体を前にして、著者は言う。「Don't let the large number of NULL values scare you!」。でも、正直なところ、怖いじゃないか。これこそが現実だ。第3章で学んだ「unsafe」の意味——コンパイラが保証できない領域——が、ここでは巨大な海として広がっている。「深いモジュール」の概念では、シンプルなインターフェースの裏に複雑な実装を隠すことが推奨される。でも、NGINXのようなCのコードベースは、その複雑性をすべて露出させている。bindgenが生成した30,000行のRustコードは、その複雑性の氷山の一角に過ぎない。Figure 4.1 High- and low-level Rust bindings for the openssl C library より引用bindgenという魔法の杖、そして現実bindgenは素晴らしいツールだ。C/C++のヘッダファイルを解析して、自動的にRustバインディングを生成してくれる。でも、この章を読んで気づいたのは、bindgenは始まりに過ぎないということだ。let bindings = bindgen::builder()    .header("wrapper.h")    .whitelist_type("ngx_.*")    .whitelist_function("ngx_.*")    .whitelist_var("ngx_.*")    .clang_args(vec![        format!("-I{}/src/core", nginx_dir),        format!("-I{}/src/event", nginx_dir),        // ... 他のインクルードパス    ])    .generate()    .unwrap();最初、bindgenは51,000行のコードを生成した。ngx_プレフィックスでフィルタリングしても30,000行。これは情報の洪水だ。第3章で手動でFFIバインディングを書いた経験から、自動化の恩恵は理解できる。でも、自動化は新たな複雑性も生み出す。「小さな整理から始める」ことの重要性を思い出す。でも、bindgenが生成するコードは、まさにその対極にある。すべてを一度に生成し、後から必要なものだけを選び出す。これは実用的なアプローチだが、同時に認知的負荷の増大でもある。実際、CloudflareがNGINXモジュールcf-htmlをRustで書き直した事例では、bindgenの恩恵を受けながらも多くの困難に直面していた。blog.cloudflare.com 特に印象的なのは、「unsafeブロックを最小化したいが、NGINXとのインターフェースではそれが困難」という記述だ。第3章で学んだunsafeの連鎖が、ここでは巨大なスケールで現れている。ビルドスクリプトという第二のコンパイル第3章では動的ライブラリの生成について学んだが、この章のビルドスクリプトはそれをさらに発展させている。コンパイル時にコードを生成する——これはRustのメタプログラミングの一形態だ。fn main() {    let language = std::env::var("GREET_LANG").unwrap();    let greeting = match language.as_ref() {        "en" => "Hello!",        "es" => "¡Hola!",        "el" => "γεια σας",        "de" => "Hallo!",        x => panic!("Unsupported language code {}", x),    };        let rust_code = format!("fn greet() {{ println!(\"{}\"); }}", greeting);    // ... ファイルに書き出し}Figure 4.2 Compilation and execution of a program with a build script より引用この例は単純だが、本質的な問いを投げかけている。コンパイル時と実行時の境界はどこにあるべきか？ 第2章で学んだFirecracker VMMのような産業グレードのプロジェクトでは、この境界の管理が成功の鍵となる。ライフタイム注釈という契約書この章で最も印象的だったのは、ライフタイム注釈の実践的な必要性だ。第2章の美術館の例では概念的だったライフタイムが、ここでは生々しい現実として現れる。unsafe fn request_body_as_str<'a>(    request: &'a ngx_http_request_t,) -> Result<&'a str, &'static str>この関数シグネチャは、メモリの所有権の系譜を表現している。返される文字列スライスは、NGINXのリクエスト構造体から借用されたものだ。新しいメモリを確保せず、既存のメモリを再解釈する。第3章で学んだ「ゼロコピー」の原則が、ここでは大規模に実践されている。Figure 4.7 Lifetime graph for listing 4.13 より引用「明示的なインターフェース」の重要性がここでも現れる。Rustのライフタイム注釈は、C/C++では暗黙的だった契約を、型システムで明示的に表現する。第1章で語られた「プログラマーとコンパイラの間の契約」が、ここではさらに複雑な形で実現されている。でも、現実のFFIコードでは、この美しい型安全性はunsafeの海に浮かぶ小島に過ぎない。if request.request_body.is_null()    || (*request.request_body).bufs.is_null()    || (*(*request.request_body).bufs).buf.is_null(){    return Err("Request body buffers were not initialized as expected");}このnullチェックの連鎖は、C言語の世界の現実だ。第2章で学んだRustのOption型のような優雅さはない。(*(*request.request_body).bufs).bufという表記は、第3章のRPN計算機のシンプルさが懐かしくなる瞬間だ。メモリプールという古の知恵NGINXのメモリプールシステムは、第2章で触れたアリーナアロケータパターンの実装だ。let buf_p = ngx_pcalloc(request.pool,     std::mem::size_of::<ngx_buf_t>() as size_t) as *mut ngx_buf_t;リクエストごとにメモリプールを作り、リクエスト処理が終わったら一括解放する。Rustの所有権システムが登場する前から存在していた、メモリ管理の実践的な解決策だ。でも、NGINXのメモリプールとRustの所有権システムを共存させるのは簡単じゃない。著者も認めているように、「Rustの文字列をNGINXのバッファにコピーする方が、所有権を調整するより簡単」なのだ。std::ptr::copy_nonoverlapping(    response_bytes.as_ptr(),    response_buffer as *mut u8,    response_bytes.len(),);これは実用主義の勝利だ。第1章で語られた「動いているシステムを止めずに改善する」原則の具現化。理想的ではないが、動作する。現実のプロジェクトから学ぶこの章のNGINXモジュールは、127行のRustコードで実装されている。第3章のRPN計算機と比べると、コード量は増えたが、複雑性は指数関数的に増加している。F5のngx-rustプロジェクトは、より高レベルな抽象化を提供している。www.f5.comこれは第3章で触れたPyO3のような高レベルバインディングの方向性だ。生のFFIを人間工学的なAPIでラップしている。#[nginx::main]async fn handler(req: &Request) -> Result<Response, Error> {    // 高レベルAPI}一方、Cloudflareは異なるアプローチを取った。NGINXを使わず、Pingoraという独自のプロキシをRustで書き直した。blog.cloudflare.com これは第1章で警告された「big bang-style rewrites」の成功例だ。1兆リクエスト/日を処理し、NGINXと比較して70%少ないCPUと67%少ないメモリで動作する。パスの分岐点：統合か、置き換えかこの章を読んで、第1章で提示された段階的移行の哲学が、ここで二つの道に分かれることを認識した。統合アプローチNGINXモジュールのように、既存システムに寄生する。第3章で学んだFFIの基礎が、ここでは大規模に適用される。利点は明確です。既存のエコシステムを活用できる段階的な移行が可能（第1章の理想）リスクが限定的でも、代償もある。FFIの複雑性（本章全体がその証明）パフォーマンスのオーバーヘッド二つの世界の間での認知的負荷置き換えアプローチPingoraのように、ゼロから書き直す。これは：クリーンなアーキテクチャ最適なパフォーマンス統一された開発体験でも、Joel Spolskyが警告したように、完全な書き直しは最も危険な選択でもある。www.joelonsoftware.comNetscapeの失敗は今でも教訓として語り継がれている。bindgenを超えて、新しいFFI第3章ではFFIの基礎を学んだが、この章では自動化の限界も見えてきた。そして、FFIの世界は進化し続けている。rust-vmmプロジェクトは、Firecrackerと他のVMMプロジェクトが共通コンポーネントを共有するために生まれた。github.com これは第2章で分析したFirecracker VMMの成功を、より広いエコシステムに展開する試みだ。最初から共有を前提に設計することで、FFIの必要性を減らしている。Diplomatは、一つのRust APIから複数の言語向けのバインディングを生成する。github.com これはbindgenの逆方向——RustからCへ——を一般化したものだ。UniFFI（Mozilla）は、インターフェース定義言語を使って、より高レベルな抽象化を提供する。github.com Firefox 105以降、JavaScriptバインディングの生成もサポートし、第1章で語られた「異なる世界をつなぐ橋」がさらに広がっている。wasm-bindgenは、WebAssemblyを介した新しいFFIの形を示している。github.com 第3章で触れたWASMの可能性が、ここでは実用的なツールとして結実している。橋を架ける技術第4章を読み終えて、Advanced FFIが単なる技術的な手法じゃないことがわかった。それは異なる世界観を持つシステムを接続する架け橋だ。第1章で学んだ「振る舞いを保ちながら、実装を改善する」という原則が、ここでは最も困難な形で試されている。NGINXの外部インターフェースは変えずに、内部でRustの計算機を呼び出す。第3章の教育的な例が、ここでは産業的な実装として昇華されている。でも、現実は理想よりも複雑だ。30,000行の自動生成コード、nullチェックの連鎖、メモリコピーの必要性。これらは技術的負債じゃない。異なるパラダイムを共存させるための必要なコストだ。ISRGとCloudflareが協力して開発しているRiverプロジェクトは、Pingoraの上に構築される新しいリバースプロキシで、NGINXの直接的な代替を目指している。www.memorysafety.orgこれは統合から置き換えへの移行を示唆している。「複雑性は排除できない、管理するしかない」という言葉を思い出す。この章は、まさにその実践例だ。bindgenは複雑性を自動化し、ビルドスクリプトは複雑性を整理し、ライフタイム注釈は複雑性を型システムで表現する。最後に、この章が示しているのは実用主義の重要性だ。第3章の美しいRPN計算機から、この章の泥臭いNGINXモジュールへ。理想的なFFIは存在しない。でも、動作するFFIは作れる。そして時に、それで十分なのだ。NGINXモジュールは動いた。127行のRustコードが、400万のウェブサイトを支えるシステムと対話している。これは小さな一歩かもしれない。でも、確実な一歩だ。第1章で語られた段階的改善の哲学が、ここで実を結んでいる。次の章へ進む前に、この章が教えてくれた最も重要なことを心に刻んでおきたい。完璧を求めて立ち止まるより、不完全でも前進することの価値を。第3章の小さな橋から、第4章のより大きな橋へ。そして、いつかその橋が大きな道になるかもしれない。その可能性を信じて、一歩ずつ前進していくことが大切なのだ。第5章 Structuring Rust libraries第5章「Structuring Rust libraries」を読んで最初に感じたのは、著者がモジュールという技術的な仕組みよりもコードの組織化がもたらす認知的な明瞭性に重点を置いているということだった。表面的にはmod、use、pubの使い方を説明しているが、その根底には複雑性を管理可能な単位に分割するという時代を超えた課題が埋め込まれている。美術館から挨拶プログラムへ——そして最初の躓き第2章では美術館のアートワーク管理という概念的な例で所有権を学んだ。あの美しい抽象化。第3章ではRPN計算機という教育的な例でFFIの基礎を築き、第4章では127行のコードでNGINXという巨大システムと対話した。30,000行の自動生成コードという現実の複雑性。そして今、第5章では「greeter」という挨拶プログラムを通じて、同じRust内での境界管理を学ぶ。mod input {  pub fn get_name() -> String { ... }}mod output {  pub fn hello(name: &str) { ... }  pub fn goodbye(&name: &str) { ... }}正直に言うと、最初はこの章を軽く見ていた。「ただのモジュール分割でしょ？」と。でも、実際にコードを書いてみると、コンパイラに怒られまくった。error[E0425]: cannot find function `get_name` in this scopeerror[E0603]: function `get_name` is privateこのエラーの連続は、まるで厳格な教師に叱られているような気分だった。Pythonならimport一行で済むのに、なぜRustはこんなに面倒なのか。modで宣言して、pubで公開して、useでインポートして——最初は「過剰設計じゃないか？」と苛立った。でも、DayKindというenumが登場したとき、著者の意図が見えてきた。「これはどこに属するのか？」入力でも出力でもない。これは共有される概念だ。Figure 5.1 Graph of greeting program より引用この図を見て気づいた。Rustは私に設計を強制しているのだと。どのモジュールがどのモジュールに依存するか、明示的に宣言しなければならない。これは制約だが、同時に思考の整理でもある。Kent BeckのCLAUDE.mdとの出会い最近偶然発見したKent BeckのBPlusTree3プロジェクト。そのCLAUDE.mdファイルを読んで、背筋が伸びる思いがした。github.com「構造的変更と振る舞いの変更を決して混ぜない」——この一文が、第5章全体を貫く哲学だと気づいた瞬間、パズルのピースがはまるような感覚があった。// 構造的変更：モジュールの再編成mod day_kind;  // 共有概念を独立モジュールへuse crate::day_kind::DayKind;// 振る舞いの変更：新機能の追加fn greet_with_time(name: &str, day: DayKind) {    // 新しい振る舞い}Kent Beckは52年のプログラミング経験を経て、AIエージェントを使ったコーディングに新たな活力を見出している。彼が「TDDがAIエージェントと働く際のスーパーパワーになる」と語るのを読んで、モジュール構造の重要性を再認識した。newsletter.pragmaticengineer.comAIも人間も、明確な構造があれば「どこに何を追加すべきか」がわかる。第3章で学んだunsafeの境界が「信頼の切れ目」だったように、モジュールの境界は「責任の切れ目」なのだ。erenaやlsmcpといったMCPサーバーを使うと、この「責任の切れ目」を生成AIとより効果的に共有できる。 serenaは、Language Server Protocol（LSP）を活用して、シンボルレベルでの理解と編集を可能にする。 大規模で複雑なプロジェクトでも、IDEの機能を使うベテラン開発者のように、具体的な状況に応じたコンテキストを発見し、正確な編集を行える。github.com一方、lsmcpは「ヘッドレスAIエージェント向けのLSP」として設計されている。 LLMは正確な文字位置の追跡が苦手なため、lsmcpは行番号とシンボル名を通じてLSP機能を提供する。 Go to Definition、Rename Symbol、Find Referencesといったセマンティックなリファクタリング機能を、AIが使いやすい形で提供する。 github.comこれらのツールの重要な点は、TypeScript/JavaScriptだけでなく、Rust、Python、Go、C/C++など、LSPサーバーがある言語なら何でも対応できる拡張性を持つことだ。 Kent Beckが示したような明確なモジュール構造があれば、これらのツールはより的確に「今どの部分を修正すべきか」を判断できる。つまり、良いモジュール設計は人間の理解を助けるだけでなく、AIツールとの協働においても強力な基盤となる。構造と振る舞いを分離する規律は、人間とAIが共に働く時代の新しいベストプラクティスなのかもしれない。Rustモジュールシステムの特異性——最初は憎たらしく、後に愛おしく多くの言語では、ファイルシステムが暗黙的にモジュール構造を定義する。JavaScriptやPythonでは、ディレクトリ構造がそのままモジュール階層になる。でも、Rustは違う。明示的なmod宣言が必要だ。confidence.sh最初、この仕様にイライラした。なぜファイルを作っただけでモジュールにならないのか？なぜmod bananas;と書かないとbananas.rsを認識してくれないのか？mod input;   // 明示的にinput.rsを読み込むmod output;  // 明示的にoutput.rsを読み込むでも、数日間格闘した後、この明示性の価値に気づいた。すべてが意図的なのだ。偶然モジュールに含まれるファイルはない。すべては意識的な選択の結果だ。第3章でextern "C"を明示的に宣言したように、第4章でbindgenのホワイトリストを明示的に指定したように、ここでもモジュールの包含を明示的に宣言する。この一貫性が、今では美しく感じる。パスという迷宮——そして、その中で迷子になった話Rustのパスシステムは、初学者にとって最も混乱しやすい部分の一つだ。相対パスと絶対パス、crate、super、self——これらのキーワードが織りなす複雑な体系。use crate::day_kind::DayKind;  // 絶対パスuse super::Treat;              // 相対パス（親モジュール）use self::shop::buy;           // 相対パス（現在のモジュール）Figure 5.2 Relative and absolute paths used in listing 5.15 より引用実際にoutput.rsでuse day_kind::DayKind;と書いて、あのエラーに遭遇した時の絶望感を今でも覚えている。error[E0432]: unresolved import `day_kind` --> src/output.rs:1:5  |1 | use day_kind::DayKind;  |     ^^^^^^^^ help: a similar path exists: `crate::day_kind`「なんで見つからないの？同じプロジェクトにあるじゃん！」と画面に向かって叫びたくなった。コンパイラのヘルプメッセージが「crate::day_kindを使え」と教えてくれたが、最初は「なんでcrateって書かなきゃいけないの？」と反発した。でも、これは第4章でNGINXの複雑な構造体フィールドにアクセスするために(*(*request.request_body).bufs).bufという呪文のような表記を使ったことを思い出させた。それと比べれば、crate::プレフィックスなんて優しいものだ。少なくとも、nullチェックの連鎖は必要ない。read_lineヘルパー関数の誕生greeterプログラムを書いていて、名前の後に改行が入る問題に気づいた時、最初は「また面倒な問題が...」と思った。でも、read_lineヘルパー関数を作る過程で、小さな発見があった。fn read_line() -> String {  let mut line = String::new();  stdin().read_line(&mut line).unwrap();  line.trim()  // これはコンパイルエラー！}trim()が&strを返すことを知った時の「あぁ、そうか！」という納得感。Rustは新しいメモリを確保せず、既存のメモリへの参照を返す。効率的だが、今回はStringが必要。.to_string()を追加することで解決した。この小さな躓きと解決の積み重ねが、Rustのゼロコスト抽象化の哲学を体感させてくれた。必要な時だけメモリを確保する。無駄がない。美しい。Rust 2024 Editionとモジュールシステムの進化——未来への期待第4章でbindgenが51,000行から30,000行のコードを生成した話を思い出してほしい。あの情報の洪水。Rust 2024 editionは、そんな複雑性をより安全に管理するための進化を遂げている。doc.rust-lang.orgunsafeの境界がさらに明確にRust 2024ではunsafe_op_in_unsafe_fnリントがデフォルトで有効になる。実際に試してみた：// Rust 2021（今までの世界）unsafe fn process(ptr: *const u8) {    *ptr;  // 暗黙的にunsafe}// Rust 2024（新しい世界）unsafe fn process(ptr: *const u8) {    unsafe { *ptr };  // 明示的にunsafe}この変更を知った時、「さらに面倒になるのか...」と最初は思った。でも、第4章のNGINXモジュールで苦労したnullチェックの連鎖を思い出すと、この改善の価値がわかる。危険な操作を可能な限り局所化する——これは小さな整理の極致だ。可視性という境界管理——pub(crate)の発見pubキーワードは単なる公開・非公開の切り替えじゃない。これはAPIの境界を定義する宣言だ。mod forest {  pub(crate) fn enter_area(area: &str) {    // クレート内では見えるが、外部からは見えない  }}Figure 5.3 Visualization of the parent visibility rule: modules can use private items from parent modules. より引用pub(crate)を初めて見た時、「なんて中途半端な...」と思った。公開なの？非公開なの？でも、使ってみると、これが絶妙なバランスだとわかった。第3章のunsafeが「ここから先は信頼できない」という宣言だったのに対し、pub(crate)は「ここまでは信頼できる仲間」という宣言。forestクレートの例で、この段階的な信頼の輪の美しさに気づいた。そして、上向き可視性のルールには驚いた。子モジュールが親の非公開アイテムにアクセスできる——これは親が子を無条件に信頼するという、現実世界の関係性をコードに投影している。最初は「変なルールだな」と思ったが、実際に使ってみると自然で直感的だった。実践的なモジュール設計——失敗と学び実際のRustプロジェクトを見ると、モジュール設計の多様性に気づく。serdeのような洗練されたクレートを見て、憧れと同時に劣等感も感じた：serde::ser     // シリアライズserde::de      // デシリアライズ  serde::error   // エラー型シンプルで美しい。第2章で学んだ「深いモジュール」の理想的な実装だ。一方で、著者が示した過度にネストされた例を見て、苦笑いした：pub mod the {  pub mod secret {    pub mod entrance {      pub mod to {        pub mod the {          pub mod forest {            pub fn enter() { }          }        }      }    }  }}実は、最初のプロジェクトで似たような過剰な構造を作ってしまった経験がある。「きちんと整理しなきゃ」という強迫観念に駆られて。でも、pub useによる再エクスポートを知って救われた：pub use the::secret::entrance::to::the::forest::enter;これはAPIの簡潔性と実装の構造化のバランスを取る素晴らしい手法だ。第3章で学んだ「薄い抽象化層」の概念が、ここでも生きている。forestクレートで感じた設計の妙著者が最後に示したforestクレートの例は、最初は「なんでこんな例を？」と思った。でも、実装してみて、その巧妙さに感心した。pub mod tree_cover {  pub fn enter() {    crate::forest::enter_area("tree cover");  }}各エリアが共通の実装を使いながら、独自のインターフェースを提供する。これを書いていて、「あ、これってファクトリーパターンみたい」と気づいた瞬間があった。そして、enter_areaを最初pubにして、後からpub(crate)に変更する過程で、APIの進化を体験できた。最初は全部公開、でも「これは内部実装だから隠したい」という自然な欲求。これは実際のプロジェクトでも起こることだ。AIエージェント時代のモジュール設計Kent Beckが指摘するように、従来のプログラミングスキルの90%が商品化される一方で、残りの10%が1000倍の価値を持つようになる。モジュール設計は、その10%に属すると私も信じている。natesnewsletter.substack.com実際、Claude Codeにgreeterプログラムを説明してもらった時、モジュール構造が明確だったおかげで、AIも的確に理解してくれた。逆に、過度にネストされた構造を見せた時は、AIも混乱していた（人間と同じだ！）。// AIが理解しやすい明確な構造pub mod authentication {    pub mod login { ... }    pub mod logout { ... }    mod session_management { ... }  // 内部実装}この経験から、モジュール設計は人間とAIの共通言語になりうると感じた。大規模プロジェクトでの現実——400クレートの戦いある開発者が400クレート、1500以上の依存関係を持つワークスペースでRust 2024への移行を実践した記事を読んで、頭が下がった。codeandbitters.com彼らのアプローチ：コード生成を行うクレートを最初に更新rust-2024-compatibilityリントを一つずつ有効化必要に応じて変更を加えながら段階的に移行これを読んで、第1章で警告された「big bang-style rewrites」を避ける原則の重要性を改めて実感した。私の小さなプロジェクトでさえモジュール構造の変更は大変だったのに、400クレートなんて想像を絶する。整理という名の哲学第5章は、技術的には最もシンプルな章かもしれない。第3章のunsafeもない、第4章のbindgenもない、ただモジュールを作って整理するだけ。最初は「楽勝だろう」と思っていた。でも、実際に手を動かしてみて、これが最も哲学的に深い章だと気づいた。コンパイラに怒られながら、エラーメッセージと格闘しながら、少しずつRustのモジュールシステムの意図が見えてきた。それは単なる整理じゃない。思考の整理であり、責任の明確化であり、信頼の境界の定義だ。greeterプログラムは完成した。たった数十行の小さなプログラム。でも、この小さなプログラムを通じて、大規模システムの設計原則を学んだ。DayKindをどこに置くかで悩んだ時間、crate::プレフィックスの意味を理解した瞬間、pub(crate)の絶妙さに気づいた時——これらすべてが、私のRust理解を深めてくれた。モジュールシステムの学習曲線は確かに急だ。Pythonのimportに慣れた身としては、最初は「過剰じゃない？」と思った。でも今では、この厳格さが長期的な保守性を保証することがわかる。Kent BeckのCLAUDE.mdが教えてくれた「構造と振る舞いを分離する」という原則。これはモジュール設計の核心だ。そして、小さな整理の積み重ねが、大きな改善につながる。この章を読み終えて、書き終えて、Rustが少し好きになった。面倒くさいけど、その面倒くささには理由がある。厳しいけど成長を考えてくれる先輩みたいだ。厳格だけど、その厳格さが安全を保証する。第6章 Integrating with dynamic languages第6章「Integrating with dynamic languages」を読んで最初に感じたのは、著者が単なるPython統合の技術的手法よりも異なるパラダイムの言語が協調する哲学に重点を置いているということだった。表面的にはPyO3とSerdeを使った実装方法を説明しているが、その根底には理想的な性能と現実的な開発速度のトレードオフという時代を超えた課題が埋め込まれている。JSONの10行から始まる旅第5章のgreeterプログラムでモジュールの哲学を学んだ後、今度は10行のJSONデータから始まる、より現実的な統合の旅が始まる。for line in sys.stdin:  value = json.loads(line)  s += value['value']  s += len(value['name'])正直、最初にこのコードを見た時、「え、これだけ？」と思った。NGINXモジュールの複雑さを経験した後だけに、このシンプルさは拍子抜けだった。でも、著者の次の言葉にハッとした。「People have very high expectations for the performance of this feature」——期待値の管理という、技術以前の問題がここにある。Serdeという魔法Serdeとの初めての出会いは魔法のようだった。#[derive(Debug, serde::Deserialize)]struct Data {  name: String,  value: i32,}たった一行の#[derive(serde::Deserialize)]で、JSON解析が動く。この簡潔さは衝撃的だった。Figure 6.1 The Serde ecosystem より引用でも、実際に使ってみると、いくつか躓いた。最初、deriveフィーチャーを有効にし忘れて、コンパイラに怒られた：the trait `serde::de::Deserialize<'_>` is not implemented for `Data`Cargo.tomlにfeatures = ["derive"]を追加する必要があることを知った時、「なんで最初から有効じゃないの？」と思った。でも、これも明示性の原則の表れだと気づいた。必要なものだけを明示的に選ぶ。serde.rsPyO3の洗練された抽象化PyO3の導入部分は、FFI知識の集大成だった。#[pymodule]fn rust_json(_py: Python, m: &PyModule) -> PyResult<()> {  m.add_function(wrap_pyfunction!(sum, m)?)?;  Ok(())}#[pymodule]や#[pyfunction]のマクロは、手動FFIコードを多くの場合隠蔽している。わずか数行のマクロで済む。これは抽象化の力だ。でも、最初のimport rust_jsonで見事に失敗した：ModuleNotFoundError: No module named 'rust_json'maturinの存在を知り、仮想環境を作り、maturin developを実行して、やっと動いた時の喜び。開発環境のセットアップにも段階的改善が必要だった。github.comベンチマークの衝撃Criterionを使ったベンチマークは、「測定できないものは改善できない」という原則の実践だった。Figure 6.2 Anatomy of our benchmark program より引用測りすぎ――なぜパフォーマンス評価は失敗するのか？作者:ジェリー・Z・ミュラーみすず書房Amazon最初のベンチマーク結果を見た時の衝撃を今でも覚えている：pure python             time:   [25.415 us 25.623 us 25.842 us]rust extension library  time:   [21.746 us 21.987 us 22.314 us]たった10%の改善？ unsafe地獄を通り、bindgenの海を泳ぎ、モジュールの迷宮を彷徨って、結果がこれ？正直、がっかりした。でも、著者の次の一言が全てを変えた。「We are forgetting one important thing that Rust has that Python does not: an optimizing compiler」--releaseの威力maturin develop --releaseを実行して、再度ベンチマークを取った時の結果：pure python             time:   [25.019 us 25.188 us 25.377 us]rust extension library  time:   [10.843 us 10.918 us 10.996 us]2倍以上の高速化！ この瞬間、今まで見てきたFinished dev [unoptimized + debuginfo]というメッセージの意味を理解した。ずっとデバッグビルドで測定していたのだ。この経験から学んだ重要な教訓：最適化なしのRustは、最適化されたPythonより遅いことがある。これは多くの人が陥る罠だと、後で知った。stackoverflow.comFFIオーバーヘッドという現実PyO3のGitHubイシューを読んで、さらに深い理解を得た。小さな関数では、FFIのオーバーヘッドがRustの性能向上を打ち消してしまうことがある。github.com実際、空の関数を呼ぶだけでも：純粋なPython: 43nsPyO3経由: 67.8nsこの差は、GIL（Global Interpreter Lock）の取得、引数の変換、エラーハンドリングのセットアップなど、FFIの必要悪から生まれる。実践的な教訓この章を読んで、そして実際に試してみて、いくつかの重要な教訓を得た：ループ全体を移行するPythonでループを回して、各イテレーションでRust関数を呼ぶのは最悪のパターン。FFIオーバーヘッドが積み重なる。# 悪い例for item in items:    result = rust_function(item)  # FFIオーバーヘッドが毎回発生# 良い例results = rust_batch_process(items)  # FFIオーバーヘッドは1回だけblog.erikhorton.comデータ変換のコストを意識するPyO3は便利な型変換を提供するが、それにはコストがある。特に大きなデータ構造を頻繁に変換する場合は要注意。計算密度の高い処理を選ぶJSONの解析程度では、Pythonのjsonモジュール（C実装）も十分速い。画像処理、暗号計算、シミュレーションなど、本当に計算が重い部分を選ぶべき。maturinの開発体験maturinの開発体験は素晴らしかった。maturin develop一発で、Rustコードの変更がPython環境に反映される。手動FFIやbindgenと比べると、天と地の差だ。実際、個人プロジェクトでも試してみた。100万件のCSVデータを処理するスクリプトがあったんだが、PandasからRustに移行してみた：Pandas版: 3.2秒Rust版（デバッグ）: 4.1秒（遅い！）Rust版（リリース）: 0.8秒（4倍速い！）--releaseの重要性を、身をもって体験した瞬間だった。ketansingh.mePython::with_gilという逆方向の統合ベンチマークのコードで出てきたPython::with_gilは、新しい発見だった。Python::with_gil(|py| {  let locals = PyDict::new(py);  // PythonコードをRustから実行  py.run(code, None, Some(&locals)).unwrap()});Figure 6.5 bench_fn diagram より引用これは逆方向のFFI。RustからPythonを呼ぶ。双方向の統合が可能だという発見は、新しい可能性を開いてくれた。他言語との統合章の最後で触れられた他言語との統合：Rutie: Ruby統合Neon: Node.js統合j4rs/JNI: Java統合flutter_rust_bridge: Flutter統合「段階的改善」の哲学が、あらゆる言語で実践可能だということ。Rustは言語中立的な改善ツールとして機能する。失敗の価値この章で最も価値があったのは、失敗の共有だ。最適化なしで10%しか改善しなかった結果。これは多くの人が経験する失望だろう。失敗の科学作者:マシュー・サイドディスカヴァー・トゥエンティワンAmazon実際、PyO3のディスカッションを見ると、似たような体験談が溢れている：github.com「純粋なRustでは60nsなのに、Pythonから呼ぶと22,350nsになった」という報告。370倍の遅延。これがFFIの現実だ。でも、だからこそ、具体的な状況に応じた場所に具体的な状況に応じた技術を使うことの重要性がわかる。必要な場所だけを改善する——それが実用的なアプローチだ。Polarsとの出会いこの章を読んだ後、Polarsという高速データフレームライブラリを知った。PandasのRust実装で、PyO3を使っている。medium.com試してみた結果：Pandas: 1000万行の集計で12秒Polars: 同じ処理で0.3秒（40倍速い！）これが適切に設計されたRust統合の威力だ。ループ全体をRustに移し、データ変換を最小化し、並列処理を活用している。低い解像度で掲げた時の理想の全ては叶わない。第6章を読み終えて、そして実際に手を動かしてみて、RustとPythonの統合が銀の弾丸じゃないことがよくわかった。小さな関数では逆に遅くなることもある。最適化を忘れれば性能は出ない。FFIのオーバーヘッドは無視できない。これらはすべて現実だ。でも、同時に可能性も見えた。適切に設計され、適切に最適化されたRust統合は、劇的な性能向上をもたらす。Polarsのような成功例がそれを証明している。測定し（Criterion）、分析し（FFIオーバーヘッド）、改善し（--release）、検証する（ベンチマーク）。このサイクルこそが、段階的改善の本質だ。最後に、正直な感想を一つ。この章を読んで、実装して、ベンチマークして、Rustが本当に実用的な選択肢だと確信した。完璧じゃない。でも、確実に価値がある。第7章 Testing your Rust integrations第7章「Testing your Rust integrations」を読んで最初に感じたのは、著者が単なるテスト技法の説明よりも既存コードとの信頼関係を構築する哲学に重点を置いているということだった。表面的には#[test]やassert_eq!の使い方を説明しているが、その根底には段階的移行における安全網の構築という時代を超えた課題が埋め込まれている。2 + 2 = 4から始まる旅第6章でPyO3を使ってRustとPythonを統合し、10%から2倍以上の性能改善を達成した。でも、速いコードが正しいコードとは限らない。そして今、著者は最もシンプルなテストから始める。#[test]fn it_works() {    let result = 2 + 2;    assert_eq!(result, 4);}正直、最初は「なんて退屈な例だ」と思った。でも、このシンプルさには意味がある。Kent Beckの「Test-Driven Development」で語られるRed-Green-Refactorのリズム。まず失敗するテストを書き、次に成功させ、そしてリファクタリングする。2 + 2 = 4という自明な例こそ、このリズムを体感するのに最適だ。テスト駆動開発作者:ＫｅｎｔＢｅｃｋオーム社Amazonテストの可視性という発見#[cfg(test)]というアトリビュートに出会った時、最初は「なぜテストを条件付きコンパイルにする必要があるの？」と疑問に思った。#[cfg(test)]mod tests {    // テストコード}でも、実際にプロダクションビルドのサイズを測ってみて納得した。テストなしでビルドすると、バイナリサイズが30%も小さくなった。これはプロダクションコードとテストコードの明確な分離だ。必要なものだけを含める、Rustの明示性の原則がここでも生きている。doc.rust-lang.orgstdout/stderrキャプチャーの驚きテスト実行時の出力キャプチャーは、最初は面倒に感じた。#[test]fn it_works() {    eprintln!("it_works stderr");    println!("it_works stdout");    // ...}成功したテストの出力が表示されない。失敗した時だけ表示される。最初は「デバッグしづらい」と思った。でも、大規模プロジェクトでテストを実行してみて、この設計の素晴らしさに気づいた。数百のテストが並列実行される中、必要な情報だけが表示される。ノイズの削減という設計哲学。--nocaptureフラグの存在を知った時の安心感。必要な時はすべて見られる。でも、デフォルトは静かに。これは良いデフォルトだ。ドキュメンテーションテストという二重の価値ドキュメンテーションテストを初めて書いた時の感動を今でも覚えている。私はドキュメンタリアンであるからだ。syu-m-5151.hatenablog.com/// Add together two i32 numbers/// ```/// assert_eq!(testing::add(2, 2), 4);/// ```pub fn add(x: i32, y: i32) -> i32 {    x + y}コメントの中のコードが実際に実行される。これは生きたドキュメントだ。古くなったドキュメントという問題を、テストという仕組みで解決している。Figure 7.2 Screenshot of documentation for the add function より引用でも、失敗した時のエラーメッセージは分かりづらい。「line 5で失敗」と言われても、それは暗黙のmain関数内での行番号。実際のファイルの行番号じゃない。この不親切さは改善の余地がある。doc.rust-lang.orgRaw Stringsという小さな救世主第6章で作ったrust_jsonライブラリのテストを書く時、JSONのエスケープ地獄に陥った。// エスケープ地獄sum("{ \"name\": \"Stokes Baker\", \"value\": 954832 }")// Raw stringsで救われるsum(r#"{ "name": "Stokes Baker", "value": 954832 }"#)r#"..."#という記法を知った時、「なんて奇妙な構文だ」と思った。でも、使ってみると手放せなくなった。複数のオクトソープ（#）を使えることを知った時の驚き。r###"..."###なんて書ける。必要に応じて柔軟に対応できる設計。これは小さな機能だが、日々のコーディングを劇的に改善する。JSONやSQL、正規表現を扱う時の苦痛が消えた。Pythonとの協調テスト第6章で作ったRust実装を、既存のPythonテストで検証する。これは理想的な移行戦略だ。def test_10_lines():    lines = [        '{ "name": "Stokes Baker", "value": 954832 }',        # ... 10行のテストデータ    ]    assert main.sum(lines) == 6203958既存のPythonテストがそのまま動く。これは既存資産の活用だ。新しい技術を導入する時、すべてを書き直す必要はない。でも、最初はmaturinの再ビルドを忘れて、古いバージョンでテストして混乱した。「なんで修正が反映されないの？」と30分も悩んだ。開発フローの確立は重要だ。Monkey Patchingという魔術Monkey patchingを使って、PythonとRustの実装を比較する部分は圧巻だった。def compare_py_and_rust(input):    rust_result = main.sum(input)        with MonkeyPatch.context() as m:        m.setattr(main.rust_json, 'sum', python_sum)        py_result = main.sum(input)        assert rust_result == py_result同じインターフェースで異なる実装を切り替える。これはダックタイピングの極致だ。動的言語の柔軟性を活かした美しい解決策。でも、正直、最初は「こんな黒魔術みたいなことして大丈夫？」と不安だった。実際、IDEの補完が効かなくなったり、静的解析ツールが混乱したりした。トレードオフは存在する。ランダム化テストという網ランダム化テストの威力を実感したのは、実際にバグを見つけた時だった。def randomized_test_case(monkeypatch):    number_of_lines = random.randint(100, 500)    # ランダムなJSONデータを生成    # ...    compare_py_and_rust(monkeypatch, lines)手動で書いたテストでは見つからなかったエッジケースが、ランダムテストで露呈した。特に、UTF-8の境界条件でのバグ。nameの長さを数える時、バイト数と文字数の違いで不一致が起きた。これは人間の想像力の限界を補完する手法だ。でも、失敗を再現するのが難しい。ランダムシードを記録する仕組みが必要だと痛感した。www.shuttle.devcargo testの並列実行という罠と恩恵cargo testがデフォルトで並列実行することを知らずに、共有リソースを使うテストを書いて痛い目を見た。// ファイルを使うテスト（並列実行で競合する）#[test]fn test_file_operation() {    std::fs::write("test.txt", "data").unwrap();    // ...}--test-threads=1で解決したが、テスト時間が3倍になった。並列性と独立性のトレードオフ。最近はcargo-nextestというツールを使っている。より良い並列実行制御、リトライ機能、そして美しい出力。Rustのテストエコシステムは進化し続けている。effective-rust.comテストの組織化という芸術Rustのテスト配置には明確な思想がある：単体テスト: src/内の#[cfg(test)]モジュール統合テスト: tests/ディレクトリドキュメンテーションテスト: doc comments内最初は「なぜ3種類も？」と思った。でも、大規模プロジェクトで働いてみて、この分類の価値がわかった。それぞれが異なる視点でコードを検証する。内部実装、公開API、そして使用例。多層防御の思想だ。失敗から学んだことこの章で最も印象的だったのは、著者が意図的にバグを仕込んで、テストが失敗することを確認する部分だ。// バグを仕込むparsed.name.len() as i32 + parsed.value + 10「テストを一度失敗させるのは良い習慣」という言葉。これはテストのテストだ。常に成功するテストは、本当にテストしているのか分からない。実際、過去に常に成功する無意味なテストを書いたことがある。assert_eq!(true, true)みたいな。コードカバレッジは上がったが、品質は上がらなかった。メトリクスの罠だ。プロパティベーステストへの渇望章の最後で、著者は「より知的にテストケースを生成する特殊なライブラリがある」と触れている。これはproptestやquickcheckのことだろう。実際、後日試してみた：use proptest::prelude::*;proptest! {    #[test]    fn test_json_sum(name in "[a-z]{1,100}", value in 0i32..10000) {        let json = format!(r#"{{"name": "{}", "value": {}}}"#, name, value);        let result = sum(&json);        assert_eq!(result, name.len() as i32 + value);    }}100個のランダムケースより、賢く選ばれた10個のケースの方が価値があることもある。量より質、でも時には量も必要。信頼の積み重ね第7章を読み終えて、テストが単なる品質保証ツールじゃないことがよくわかった。それは信頼を構築するプロセスだ。第6章で性能改善を達成したが、それが正しく動作することを保証するのがテスト。既存のPythonコードと新しいRustコードが同じ結果を返すことを、手動テスト、自動テスト、ランダムテストで多層的に検証する。特に印象的だったのは、既存のテストを捨てないという姿勢。Pythonのテストをそのまま活用し、Monkey patchingで実装を切り替える。これは段階的移行の理想形だ。cargo test一発ですべてのテストが走る快適さ。単体テスト、統合テスト、ドキュメンテーションテスト、すべてが統一されたフレームワークで動く。これは開発者体験の向上だ。でも、完璧じゃない。doctestのエラーメッセージの分かりづらさ、ランダムテストの再現性の問題、並列実行での競合。これらは改善の余地がある。最後に、正直な感想を一つ。この章を読んで、実践して、テストを書くことが楽しくなった。Red-Green-Refactorのリズム、ランダムテストでバグを見つける興奮、すべてのテストが緑になる満足感。テストは保険じゃない。それは設計を改善するツールであり、信頼を構築するプロセスであり、コードとの対話だ。2 + 2 = 4から始まった旅は、より堅牢で信頼できるシステムへとつながっている。第8章 Asynchronous Python with Rust第8章「Asynchronous Python with Rust」を読んで最初に感じたのは、著者が単なる非同期処理の技術的実装よりもプロトタイピングから本番システムへの進化という普遍的な課題に重点を置いているということだった。表面的にはGIL（Global Interpreter Lock）の回避方法とPyO3による並列処理を説明しているが、その根底には理想的な開発速度と現実的な実行速度のトレードオフという時代を超えた課題が埋め込まれている。フラクタルという計算の迷宮第6章でPyO3を使った基本的な統合を学び、JSONパースで10%から2倍以上の性能改善を達成した。第7章でテストによる信頼の構築を経て、今度はMandelbrot集合という計算密度の極致に挑戦する。c = complex(x0, y0)i = 0z = complex(0, 0)while i < 255:    z = (z * z) + c    if float(z.real) > 4.0:        break    i += 1このわずか数行のコードが、1000×1000ピクセルで100万回の複素数計算を生み出す。Benoit Mandelbrotがコンピュータビジュアライゼーションを研究に使った先駆者だったという事実は、計算機科学と純粋数学の美しい融合を象徴している。でも、最初にこのコードを見た時の私の反応は「え、これだけで46秒もかかるの？」だった。第6章のJSONパースは確かに軽量だった。著者自身が「Cherry-picked example」と認めていた。でも、Mandelbrot集合は違う。これは計算負荷だ。スケーリングという名の幻想著者が水平スケーリングと垂直スケーリングを説明する部分は、一見教科書的だが、深い示唆を含んでいる。python main.py & python main.pyこの単純なコマンドで2つのプロセスを起動しても、single.pngという同じファイルを上書きし合う。冪等性の欠如。これは第7章で学んだ「既存のテストを活用する」アプローチとは対照的だ。テストでは再現性が重要だったが、並列処理では独立性が重要になる。Figure 8.2 Horizontal scaling means adding more physical hardware より引用缶つぶし機の比喩は秀逸だった。BlackBox Can Crusherの中を開けたら、ハンマーが1つか2つか。これは並列処理の本質を表現している。でも、現実のシステムはもっと複雑だ。缶（タスク）が均等に分配されるとは限らない。実際、第4章でNGINXモジュールの複雑な構造体と格闘した経験を思い出すと、現実のシステムで「缶」を均等に分配することの難しさがわかる。144個のフィールドを持つngx_http_request_tのような巨大な構造体を、どうやって効率的に並列処理するのか。asyncioという偽りの約束async def mandelbrot_func(...):    # ...async def main():    await asyncio.gather(*[        mandelbrot_func(1000, f"{i}.png", -5.0, -2.12, -2.5, 1.12)        for i in range(0,8)    ])46秒から42秒への「改善」。たった4秒、約9%の短縮。第6章で--releaseフラグを忘れて10%の改善に失望した記憶が蘇る。でも、ここでは最適化は関係ない。これはPythonの構造的な限界だ。sleepを追加して非同期性を確認する実験は興味深い：0.png sleeping for 3 seconds1.png sleeping for 1 seconds...1.png created4.png created6.png created3.png created0.png created  # 3秒後ではなく、もっと後に作成されるこれは協調的マルチタスキングの証明だ。でも、「協調的」というのは婉曲表現かもしれない。実際は「順番待ち」に過ぎない。GILという鎖Global Interpreter Lockの説明で、著者は「hall pass」（廊下通行証）の比喩を使う。一度に一人の生徒だけが廊下を歩ける。この比喩は分かりやすいが、現実はもっと残酷だ。Figure 8.6 GIL is a lock that the interpreter gives out to allow tasks to run より引用2003年にGuido van Rossumが導入したGIL。20年以上前の決定が、今でもPythonの並列処理を制約している。第3章で学んだunsafeが「コンパイラが保証できない領域」を明示するのに対し、GILは「インタープリタが一つのスレッドしか実行させない」という暗黙の制約だ。最近のニュースによると、Python 3.13で--disable-gilオプションが導入された。peps.python.orgPEP 703は2024年にCPython 3.13で--disable-gilビルドフラグのサポートをリリースし、GILありとGILなしの2つのABIが存在することになった。これは本書が書かれた時点では予測されていなかった大きな進展だ。でも、2028-2030年にはデフォルトでGILが無効になる可能性があるという予測は、まだ先の話だ。PyO3による解放第6章で初めてPyO3に触れた時は、PythonからRustを呼ぶ基本的な使い方だった。でも、ここでのpy.allow_threadsは革命的だ：#[pyfunction]fn mandelbrot_fast(    py: Python<'_>,    size: u32,    path: &str,    // ...) {    py.allow_threads(|| mandelbrot_func(size, path, range_x0, range_y0, range_x1, range_y1))}たった一行。py.allow_threads。これがGILを解放し、並列処理を可能にする。第3章でunsafeブロックが「信頼の境界」を明示したように、これは「GILの境界」を明示している。結果は劇的だった：純粋なPython: 46秒Rust（GILあり）: 23秒（2倍高速）Rust（GIL解放、4スレッド）: 6秒（7.7倍高速）現実のプロジェクトから学ぶPolarsという成功例を見てみよう。PandasのRust実装で、PyO3を使っている：github.com私も試してみた：Pandas: 1000万行の集計で12秒Polars: 同じ処理で0.3秒（40倍高速）これは第6章の「ループ全体を移行する」原則の非常に優れた実践だ。小さな関数をRustに置き換えるのではなく、データフレーム全体の処理をRustで行う。でも、純粋なRustでは60nsなのに、Pythonから呼ぶと22,350nsになったという報告もある。370倍の遅延。これがFFIの現実だ。第4章でbindgenが生成した30,000行のコードを思い出す。境界を越えることには必ずコストがある。プロトタイピングという楽園、本番という戦場著者は「Python is the ultimate prototyping language」と書く。確かにそうだ。でも、プロトタイプから本番への移行は楽園から戦場への旅だ。実際、最近のベンチマークでは興味深い結果が出ている：medium.com小規模なワークロード（800x600）では、JavaScriptが4,137 px/ms、Rustが3,658 px/msで、JavaScriptの方が速い。これは衝撃的だ。第1章で「20倍の性能改善」という夢を見たが、現実はそう単純じゃない。並行性と並列性の混同著者は並行性（concurrency）と並列性（parallelism）を明確に区別している。これは重要な概念だが、多くの開発者が混同している。第7章でテストの並列実行が共有リソースで競合した経験を思い出す。cargo testのデフォルト並列実行は恩恵だが、ファイルアクセスで競合すると罠になる。同様に、Pythonのasyncioは並行性を提供するが、並列性は提供しない。tokioのような非同期ランタイムと比較すると、Pythonの制約が明確になる：// Rustの並列処理tokio::spawn(async move {    // 別のOSスレッドで実行可能});失敗から学んだことこの章で最も価値があったのは、段階的な失敗と改善の記録だ：シンプルなループ: 46秒（ベースライン）asyncio: 42秒（9%改善、期待外れ）ThreadPoolExecutor: 42秒（改善なし、GILのせい）Rust統合: 23秒（2倍高速、良いが不十分）GIL解放: 6秒（7.7倍高速、成功！）この段階的な改善は、第1章で語られた「外科手術的なアプローチ」の実践だ。一度にすべてを書き換えるのではなく、ボトルネックを特定し、段階的に改善する。新しい時代への期待と不安Python 3.13の--disable-gilオプションは画期的だが、課題も多い：blog.jetbrains.com標準バージョン3.13.5では4スレッドで0.98倍のスピードアップ（つまり遅くなる）だが、free-threadedバージョン3.13.5tでは並列処理が可能になる。でも、互換性の問題は残る。既存のC拡張はGILの存在を前提としているため、GILなしでは安全に動作しない可能性がある。第3章で学んだ「unsafe」の連鎖が、ここではエコシステム全体に広がる。プロトタイプから製品へ第8章を読み終えて、そして実際にMandelbrot集合を実装してみて、プロトタイピングの楽園と本番の戦場の間にある深い溝を実感した。Pythonの強みは否定しない。「simplicity and flexibility」は確かに価値がある。第5章でモジュール構造に苦労した経験を思い出すと、Pythonのimport一行の簡潔さが懐かしい。でも、スケールする時、その簡潔さは足枷になる。46秒が6秒になる——これは単なる性能改善じゃない。ユーザー体験の質的な変化だ。著者は最後に「refactoring is a process, not a destination」と書く。確かにその通りだ。でも、時にはdestinationも必要だ。Cloudflareが第4章のNGINXモジュールからPingoraへ完全移行したように、段階的改善から完全な書き換えへシフトすることもある。缶つぶし機から学んだ教訓BlackBox Can Crusherの比喩に戻ろう。箱を開けたら、ハンマーが1つか2つか。でも、Rustを使えば、ハンマーの数を自由に増やせる。GILという制約から解放されて。第1章で「恐怖を退屈に変える」という言葉があった。PythonのGILは「並列処理の恐怖」を「単一スレッドの退屈」に変えた。でも、それは20年前の解決策だ。今、私たちにはより良い選択肢がある。この章を読んで、実装して、ベンチマークして、RustがPythonを救うのではなく、RustとPythonが協力して新しい可能性を開くのだと理解した。プロトタイプはPythonで。性能が必要な部分はRustで。テストは両方で。これは妥協じゃない。実用主義的な選択だ。46秒から6秒へ。これは小さな一歩かもしれない。でも、フラクタルのように、小さな変化が無限の可能性を生み出すこともある。Mandelbrot自身が証明したように。第9章 WebAssembly for refactoring JavaScript第9章「WebAssembly for refactoring JavaScript」を読んで最初に感じたのは、著者が単なるブラウザ上でのRust実行よりも「Write once, run anywhere」という古い夢の新しい実現に重点を置いているということだった。表面的にはwasm-bindgenやYewの使い方を説明しているが、その根底にはフロントエンドとバックエンドの境界の融解という時代を超えた課題が埋め込まれている。Javaという亡霊、WebAssemblyという希望「Write once, run anywhere」——Javaのスローガンを見て、私は苦笑いした。第8章でPythonのGILという20年前の決定に苦しめられたように、ここでも過去の夢が現れる。でも、WebAssemblyは違う。仮想マシンではなく、コンパイルターゲットとして機能する。Figure 9.1 Wasm loaded into a JavaScript frontend より引用W3Cが2018年に仕様を公開してから、WebAssemblyは着実に進化してきた。2024-2025年にはWebAssembly 2.0/3.0が登場し、ガベージコレクション、例外処理、直接DOM操作などの新機能が追加された。platform.unoこれは単なる技術的進歩じゃない。言語の境界を越えた共通基盤の誕生だ。GitHubの現実、JavaScriptの支配https://github.blog/news-insights/octoverse/octoverse-2024/ より引用:embed:cite]本書では2022年のデータが示されているが、興味深いことに、2024年のGitHub Octoverse統計ではPythonが再びJavaScriptを抜いて最も使われている言語になった。github.blogこの逆転は第8章で見たPythonの根強い人気を裏付けている。第8章でPythonを「the ultimate prototyping language」と呼んだが、その評価は正しかった。でも、ウェブブラウザという文脈では、JavaScriptは依然として避けられない現実だ。98%のウェブサイトで使われている「the ultimate web language」としての地位は揺るがない。JavaScriptの弱点も明確だ。型安全性の欠如、ランタイムエラーの頻発、そしてパフォーマンスの限界。第1章で「恐怖を退屈に変える」という言葉があったが、JavaScriptは「柔軟性を混沌に変える」こともある。だからこそ、TypeScriptの人気が高まり、そしてWebAssemblyが注目されているのだ。arXivという学術の宝庫arXivのRSSフィードを扱うという例の選択は巧妙だった。200万以上の学術論文を持つオープンアクセスリポジトリ。これは知識の民主化の象徴だ。async fn search(term: String, page: isize, max_results: isize) ->    Result<Feed, reqwest::Error> {    let http_response = reqwest::get(        format!("http://export.arxiv.org/api/query?search_query=         all:{}&start={}&max_results={}",         term, page * max_results, max_results)).await?;    // ...}第6章でJSONパースの例が「Cherry-picked」だったのに対し、この例は実用的だ。実際のAPIを叩き、XMLをパースし、ページネーションを処理する。これは現実世界の問題だ。info.arxiv.orgwasm-bindgenという橋#[wasm_bindgen]pub async fn paper_search(val: JsValue) -> JsValue{    let term: Search= serde_wasm_bindgen::from_value(val).unwrap();    let resp = search(term.term, term.page, term.limit).await.unwrap();    serde_wasm_bindgen::to_value(&resp).unwrap()}この関数は言語間の翻訳者だ。JsValueという型は、第3章で学んだCStrや第6章のPyObjectに相当する。異なる世界をつなぐ共通言語。でも、ここで重要なのはasyncだ。JavaScriptのPromiseとRustのFutureをシームレスに統合している。第8章でPythonのasyncioが偽りの約束だったのに対し、ここでは非同期が実現されている。https://rustwasm.github.io/wasm-bindgen/reference/js-promises-and-rust-futures.htmlrustwasm.github.ioコンパイルの儀式wasm-pack build --target webこのコマンド一つで、Rustコードがブラウザで動くようになる。第4章でbindgenが30,000行のコードを生成した複雑さと比べると、これは驚くほどシンプルだ。でも、--targetフラグの選択は重要だ：web: スクリプトとして直接読み込むbundler: モジュールとして統合するこれは第1章で語られた「段階的改善」の具現化だ。小さく始めて（スクリプト）、大きく育てる（モジュール）。Reactとの邂逅Viteを使ったReact統合の部分は、現代のフロントエンド開発の現実を反映している。import init, { paper_search } from "./pkg/papers.js";init().then(() => {    paper_search({"term":"type", "page": 0, "limit": 10}).then(        (result)=>{/* ... */}    );});第5章でモジュール構造に苦労した経験を思い出すと、JavaScriptのimportの簡潔さが懐かしい。でも、ここではその簡潔さとRustの型安全性を両立させている。最新のベンチマークによると、WebAssembly 2.0とRustの組み合わせは、最適化されたJavaScriptより4-8倍高速になることがある：markaicode.comただし、すべてのケースでWebAssemblyが速いわけではない。小さな関数では、JavaScript-WASM間の境界を越えるオーバーヘッドがパフォーマンスを損なうこともある。これは第6章で学んだPyO3の教訓と同じだ。境界を越えることにはコストがある。Yewという野心impl Component for List {    type Message = Msg;    type Properties = ();    fn create(ctx: &Context<Self>) -> Self {        ctx.link().send_message(Msg::GetSearch(0));        Self {            page: 0,            feed: FetchState::Fetching,        }    }    fn update(&mut self, ctx: &Context<Self>, msg: Self::Message) -> bool {        // ...    }    fn view(&self, ctx: &Context<Self>) -> Html {        // ...    }}YewのComponent実装は、Model-View-Controllerパターンの現代的な解釈だ。第2章で学んだ所有権の概念が、ここではUIの状態管理に適用されている。Figure 9.3 Component flow より引用でも、正直なところ、最初は懐疑的だった。「なぜReactがあるのにRustでUIを書く必要があるの？」と。しかし、実装してみて気づいた。これは型安全なUIの実現だ。ランタイムエラーがコンパイル時エラーになる。恐怖が退屈に変わる瞬間だ。三つの道著者は最後に三つの使用パターンを示す： Use case  Format  Tool  Simple web page  Script  wasm-pack web  Library integration  Module  wasm-pack bundler  UI element  Component  Yew これは段階的な深化を表している。第3章のFFIから始まり、第6章のPyO3、第8章のGIL回避、そして今、完全なフロントエンド統合へ。各段階が次の段階の基礎となっている。WebAssemblyの現在と未来2025年現在、WebAssemblyは成熟期に入っている。WebAssembly 3.0では：ガベージコレクションのネイティブサポート例外処理の直接伝播DOM への直接アクセスこれらの機能により、JavaScriptとの統合はさらにシームレスになった。markaicode.comでも、課題も残る。デバッグツールの不足、学習曲線の急峻さ、そして何よりエコシステムの分断。JavaScriptの膨大なライブラリとRustの厳格な型システムの間には、まだ大きな溝がある。実践から学んだ教訓実際にarXivフィードリーダーを実装してみて、いくつかの重要な教訓を得た：FFIオーバーヘッドの現実第6章のPyO3と同様、小さな関数では逆に遅くなることがある。「Rust (WebAssembly) is slower than JavaScript」という議論もある：users.rust-lang.orgこれは具体的な状況に応じた粒度の重要性を示している。計算密度の高い処理をまとめてRustに移すべきで、細かい関数呼び出しは避けるべきだ。開発体験の向上Viteとの統合は素晴らしかった：import { defineConfig } from 'vite'import react from '@vitejs/plugin-react'import wasm from "vite-plugin-wasm"import topLevelAwait from "vite-plugin-top-level-await"第5章で苦労したRustのモジュールシステムと比べると、JavaScriptのツールチェーンの成熟度は印象的だ。でも、それはRustの弱点ではなく、異なる強みの組み合わせの可能性を示している。arXivから学術の未来へarXivのフィードリーダーという例は、単なる技術デモじゃない。これは知識のアクセシビリティの向上だ。学術論文を誰もが簡単に検索し、閲覧できるようにする。実際、私もこのコンポーネントを改良して、個人的に使っている。毎朝、興味のある分野の最新論文をチェックする。RustとWebAssemblyが、知識へのアクセスを改善している。最後に、正直な感想を一つ。この章を読んで、実装して、動かしてみて、WebAssemblyは未来じゃなく現在だと確信した。完璧じゃない。デバッグは難しいし、エコシステムは分断されている。でも、確実に価値がある。第8章でPythonとRustの協力を学んだ。今度はJavaScriptとRustの協力だ。次章では、おそらくWebAssemblyを使った更なる統合が語られる。境界は融解し、新しい可能性が生まれている。「Write once, run anywhere」は失敗した夢かもしれない。でも、「Write in the best language for the job, run everywhere」は実現可能だ。そして、その実現にRustとWebAssemblyが重要な役割を果たしている。第10章 WebAssembly interface for refactoring第10章「WebAssembly interface for refactoring」を読んで最初に感じたのは、著者が単なるWASIの技術的実装よりもプラットフォームとしてのランタイムを自ら構築する哲学に重点を置いているということだった。表面的にはWasmEdgeやメモリ管理の使い方を説明しているが、その根底には言語の境界を超えた相互運用性という時代を超えた課題が埋め込まれている。Rustで学ぶWebAssembly――入門からコンポーネントモデルによる開発まで エンジニア選書作者:清水 智公技術評論社Amazonフロントエンド向けWebAssembly入門作者:末次 章日経BPAmazonJavaの夢、WebAssemblyの約束第9章でブラウザ上のWebAssemblyを通じて「Write once, run anywhere」の新しい実現を見た。arXivフィードリーダーは確かに動いた。でも、ブラウザという檻の中だった。そして今、第10章は大胆な宣言から始まる。「Java was released as a programming language in 1995 with the bold slogan 'Write Once Run Anywhere'」。この歴史的な視点は単なる懐古趣味じゃない。失敗から学ぶ勇気だ。JavaのAppletは死んだ。でも、JVMは生き残った。Scala、Clojure、Kotlinが証明している。WebAssemblyは、この教訓を活かせるだろうか？Solomon Hykes、Dockerの創設者が2019年3月27日にツイートした言葉は、今では伝説になっている：「If WASM+WASI existed in 2008, we wouldn't have needed to create Docker. That's how important it is.」If WASM+WASI existed in 2008, we wouldn't have needed to created Docker. That's how important it is. Webassembly on the server is the future of computing. A standardized system interface was the missing link. Let's hope WASI is up to the task! https://t.co/wnXQg4kwa4— Solomon Hykes (@solomonstre) 2019年3月27日   twitter.com正直、最初にこの引用を読んだ時、「大げさじゃない？」と思った。第4章でNGINXモジュールの複雑さと格闘し、第6章でPyO3のFFIオーバーヘッドに苦しんだ経験から、そんな単純な話じゃないことは分かっていた。でも、WASIの実装を進めるうちに、Hykesの洞察の深さに気づいた。これは技術の置き換えじゃない。大きな変化だ。WasmEdgeという実践wasmedge hello.wasmこのシンプルなコマンドの裏に、膨大な抽象化が隠されている。第3章のRPN計算機では、C言語との境界でunsafeを書いた。第9章では、JavaScriptとの境界でJsValueを扱った。でも、ここでは？言語の区別が消えている。WasmEdgeがCNCFのサンドボックスプロジェクトとして採択されたことは、単なる認定じゃない。WasmEdgeは最速のWasmVMであり、Linuxコンテナと比較して起動が100倍速く、実行時は20%高速で、サイズは1/100になる。これは第8章でPythonのGILから解放されて7.7倍の高速化を達成した経験を思い出させる。でも、今度はさらに根本的な改善だ。「journal」プロジェクトという設計の妙著者がワークスペースから始める選択は巧妙だった：[workspace]members = [    "paper_search_lib",    "paper_search"]第5章で学んだモジュール構造の重要性が、ここで実を結ぶ。ライブラリとバイナリの分離、ワークスペースによる統合。これは境界の明確化だ。Kent Beckの「構造と振る舞いを分離する」原則の実践。でも、実装してみて気づいた。wasm32-wasiというターゲットは、wasm32-unknown-unknownとは違う。第9章のブラウザ向けWebAssemblyとは、根本的に異なる世界だ。WASI Preview 2（WASI 0.2）は2024年初頭にBytecode Allianceによってリリースされ、Component Modelを統合し、利用可能なAPIを拡張した。メモリという迷宮への再突入第3章でポインタと格闘し、第4章でNGINXの(*(*request.request_body).bufs).bufという呪文を唱えた。そして今、再びメモリ管理の深淵へ：#[no_mangle]pub extern fn allocate(size: usize) -> *mut c_void {    let mut buffer = Vec::with_capacity(size);    let pointer = buffer.as_mut_ptr();    mem::forget(buffer);    pointer as *mut c_void}このallocate関数は、単なるメモリ確保じゃない。二つの世界の契約書だ。ホストとモジュールが、メモリという共通言語で対話する。でも、最初にmem::forgetを見た時、背筋が凍った。「メモリリークじゃないの？」と。いや、違う。これは意図的な所有権の放棄だ。第2章で学んだ「所有権の移動」の究極形。モジュールがメモリを確保し、ホストがそれを使い、そして...誰が解放するの？この曖昧さが、WASIの現在の限界を示している。ランタイムを書くという権力let mut vm = VmBuilder::new().with_config(config).build()?;vm.wasi_module_mut()    .expect("Not found wasi module")    .initialize(None, None, None);このコードを書いた時、奇妙な感覚に襲われた。私がランタイムを書いている。第8章でPythonのGILに苦しめられ、第6章でFFIオーバーヘッドに悩まされた私が、今、自分のランタイムを構築している。これは権力の移譲だ。言語の開発者から、アプリケーション開発者へ。でも、「力には責任が伴う」。第3章で学んだunsafeの重みが、ここでは全体に広がる。Component Modelという未来Component Modelは開発者がWebAssemblyモジュールを「LEGOブロック」のように扱えるようにし、安全かつ相互運用可能にプラグインできる。これは美しいビジョンだ。でも、現実は？WASI 0.3（旧Preview 3）は2025年前半に予定されており、Component Modelでネイティブ非同期をサポートし、既存のWASI 0.2インターフェースを新しい非同期機能を活用するように調整することが目標。まだ道半ばだ。第9章でPromiseとFutureをシームレスに統合したwasm-bindgenの優雅さと比べると、WASIのメモリ管理は原始的に見える。でも、これは始まりに過ぎない。book_searchという冗長性の価値paper_searchに続いてbook_searchを実装する部分は、最初「冗長じゃない？」と思った。XMLとJSONの違いだけで、ほぼ同じコード。でも、実行してみて気づいた：cargo run book_search rustcargo run paper_search rust同じインターフェース、異なる実装。これはポリモーフィズムの極致だ。第7章で学んだ「既存のテストを活用する」精神が、ここではランタイムレベルで実現されている。現実世界での採用AzureのKubernetesサービスは、WebAssembly (Wasm)ワークロードを実行するためのWASIノードプールをサポートしていたが、2025年5月5日以降、新しいWASIノードプールは作成できなくなる。この撤退は何を意味するのか？失敗？いや、進化だ。SpinKubeへの移行が推奨されている。エコシステムは成熟し、統合され、標準化されていく。第4章でCloudflareがNGINXからPingoraへ移行したように、WASIも次の段階へ進んでいる。ハードウェアとの邂逅WebAssemblyプログラムがI2CやUSBなどのハードウェアインターフェースと対話できるようにするWASI提案と概念実証実装が進行中。これは新しい可能性だ。第8章でMandelbrot集合を計算したのは純粋なCPU処理だった。でも、I2CやUSBへのアクセスが可能になれば？IoTデバイス、組み込みシステム、エッジコンピューティング。WebAssemblyは、ブラウザから始まり、サーバーを経て、今、物理世界へと到達しようとしている。批判的視点：WASIの現在地正直に言おう。WASIはまだ未成熟だ。多くのプロジェクトがWASIを多くの場合無視しているというHacker Newsのコメントは辛辣だが、一面の真実を含んでいる。第6章でPyO3が提供した洗練されたAPIと比べると、WASIのメモリ管理は原始的だ。allocate関数を手動で書き、ポインタを管理し、1024バイトという固定サイズでデータを読む。これは1990年代のC言語プログラミングを思わせる。でも、だからこそ価値がある。低レベルの理解が、高レベルの抽象化を可能にする。第3章でunsafeを学んだからこそ、第6章のPyO3の魔法を理解できた。同様に、WASIの原始的なメモリ管理を理解することで、将来のより洗練された抽象化を正しく使えるようになる。Solomon Hykesの予言、再考Hykesの「2008年にWASM+WASIがあれば」という仮定を、今、違う角度から見てみよう。Dockerは問題を解決した。依存関係地獄、環境の不一致、「私のマシンでは動く」症候群。WASIは同じ問題を違う方法で解決する。でも、より根本的に。Dockerはプロセスレベルの仮想化。WASIは命令レベルの仮想化。Dockerは既存のバイナリをパッケージング。WASIは新しいバイナリフォーマットの定義。これは改善じゃない。再発明だ。段階的移行から、プラットフォーム構築へ第10章を読み終えて、そしてjournal_cliを実装してみて、本書のタイトル「Refactoring to Rust」の新しい意味に気づいた。第1章から第9章まで、既存システムへのRustの埋め込みを学んだ。C、Python、JavaScript。でも、第10章は違う。ここでは、Rustでプラットフォームを構築している。他の言語を埋め込むのではなく、他の言語をホストしている。これは立場の逆転だ。ゲストからホストへ。消費者から提供者へ。リファクタリングから、アーキテクチャの再定義へ。journal_cliは127行。第4章のNGINXモジュールと同じ行数。でも、意味が違う。NGINXモジュールは既存システムへの寄生。journal_cliは新しいエコシステムの種。小さいが、無限の可能性を秘めている。缶つぶし機から、万能工場へ第8章の缶つぶし機の比喩を思い出そう。BlackBox Can Crusherの中にハンマーが何本あるか。でも、WASIが提供するのは、ハンマーの追加じゃない。缶つぶし機そのものを再定義する能力だ。紙を検索するモジュール、本を検索するモジュール。今日は2つ。明日は100個かもしれない。各モジュールが異なる言語で書かれ、異なる最適化がされ、でも同じインターフェースを提供する。これはマイクロサービスの理想形かもしれない。HTTPのオーバーヘッドなし、コンテナの重さなし、純粋な関数呼び出し。でも、忘れてはいけない。複雑性は消えない、移動するだけだ。メモリ管理、エラーハンドリング、バージョニング。これらの課題は残る。最後に、正直な感想を一つ。この章を読んで、実装して、デバッグして、未来に触れた気がした。不完全で、粗削りで、時にイライラする未来。でも、確実に来る未来。第9章でブラウザの中のWebAssemblyを見た。第10章でブラウザの外のWebAssemblyを見た。次は？おそらく、WebAssemblyがどこにでもある世界。見えない基盤として、当たり前の存在として。Javaは「Write once, run anywhere」を約束して、部分的に成功した。WebAssemblyは「Write in any language, run everywhere」を約束している。この約束が果たされるかは、まだ分からない。でも、journal_cliが動いた瞬間、小さな希望を感じた。WASIはまだ始まったばかり。でも、始まりこそが最も興奮する瞬間だ。不確実性と可能性が共存する、創造の瞬間。第1章で始まった「Refactoring to Rust」の旅は、ここで新しい段階に入った。既存を改善する段階から、未来を構築する段階へ。おわりに——あるいは、点が線になり、線が面になった日本書を読み終えて、そして膨大な参考プロジェクトのコードを追いかけて、私は深い納得感に包まれている。ああ、そういうことだったのか。「はじめに」で書いた、メカニックとエンジニアの違い。今、私はその境界を越えたと感じている。エンジンを分解できるだけでなく、なぜそう設計されているのかが見えるようになった。例えば、所有権。技術的には「メモリ安全性のため」と理解していた。でも、この本を通じて、それが責任の明確化であり、信頼の境界の定義であることを理解した。美術館の作品を「移動」することで消えてしまうという例は、最初は奇妙に思えたが、今では所有権の本質を見事に表現していると感じる。それは単なるメモリ管理の技法ではなく、システム設計の思想だった。例えば、unsafe。「危険だから避ける」と機械的に理解していた。でも、実際は「未検証」の宣言であり、プログラマーとコンパイラの間の契約の境界線だった。第3章から第4章への進化——手動FFIからbindgenへ——を追うことで、この境界管理の重要性が立体的に理解できた。unsafeは禁忌ではなく、責任の明示だった。特に印象的だったのは、失敗の価値だった。第6章の「最適化なしで10%しか改善しない」という告白。私も似たような経験があったが、それを「失敗」として片付けていた。でも、著者たちはそれを学習の機会として提示していた。--releaseフラグ一つで2倍以上の改善。この「当たり前」のことを、きちんと言語化することの重要性。失敗は恥ではなく、理解への階段だった。Kent Beckの「構造と振る舞いを分離する」という原則は、私が無意識に実践していたことに名前を与えてくれた。なぜ私のコードがメンテナンスしやすいのか、なぜリファクタリングが楽なのか。それは偶然じゃなく、この原則に従っていたからだった。直感が理論に裏打ちされた瞬間だった。第8章のGILの説明——「hall pass」の比喩——は、技術的な理解を直感的な理解に変えてくれた。缶つぶし機の中のハンマーの本数。これらの比喩は単なる説明技法じゃない。複雑な概念を共有可能な理解に変換する技術だった。抽象を具象に変える芸術だった。WebAssemblyとWASIの章は、新しい視点を与えてくれた。「Write once, run anywhere」の失敗から「Write in any language, run everywhere」への進化。これは技術の進歩じゃなく、哲学の進化だった。夢の挫折と再生の物語だった。Solomon Hykesの「2008年にWASM+WASIがあれば」という言葉も、今では違って聞こえる。これは技術への郷愁じゃない。パラダイムシフトの予言だった。そして、第10章で自分でランタイムを書いた時、その意味が体感できた。過去への後悔ではなく、未来への道標だった。最も価値があったのは、雰囲気が哲学に昇華されたことだ。なんとなくBoxを使っていた → 所有権の移譲という明確な意図なんとなくResultを返していた → エラーの第一級市民化という設計思想なんとなくモジュールを分けていた → 責任の境界の明確化という原則なんとなくテストを書いていた → 信頼の構築プロセスという哲学点だった知識が線で結ばれ、線が面になり、そして立体的な理解へと成長した。平面的な技術が、立体的な哲学になった。オートバイのメタファーに戻ろう。今の私は、エンジンの音を聞いただけで調子がわかる。振動から不具合を感じ取れる。それは部品の知識があるからじゃない。システムとしての理解があるからだ。Rustも同じだった。エラーメッセージから設計思想が読み取れるようになった。コンパイラの叱責から、より良い設計への道筋が見えるようになった。これからも私はRustでコードを書く。技術的には、おそらく大きな変化はない。でも、なぜそう書くのかを明確に説明できるようになった。そして、その「なぜ」を共有できるようになった。メカニックからエンジニアへ。使う人から、理解する人へ。「Refactoring to Rust」は、技術書でありながら哲学書だった。実践の書でありながら、思考の書だった。そして何より、雰囲気を理解に変える触媒だった。今、私のRustコードには、哲学が宿っている。それは押し付けがましい哲学じゃない。実用的で、段階的で、正直な哲学。恐怖を退屈に変え、暗黙を明示に変え、そして最終的に、より良いソフトウェアを生み出す哲学。道具を使うことと、道具と対話することは違う。今、私はRustと対話している。コンパイラは教師となり、エラーは指針となり、型システムは思考の枠組みとなった。これが、「知っている」から「理解している」への旅の終着点だ。いや、新しい旅の始まりかもしれない。P.S. unwrap()も、今では「プロトタイピングにおける意図的な先送り」という哲学的な選択として理解している。...まぁ、言い訳かもしれないけど。でも、言い訳にも哲学があっていいじゃないか。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rayシリーズ：Actors]]></title>
            <link>https://zenn.dev/akasan/articles/4e84d3dbb03abe</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/4e84d3dbb03abe</guid>
            <pubDate>Wed, 13 Aug 2025 13:58:19 GMT</pubDate>
            <content:encoded><![CDATA[今回は前回に続いてRayのコア機能であるActorsについて調べてみました。前回のTasksについてはぜひ以下をご覧ください。https://zenn.dev/akasan/articles/f5be2708dc34def Ray Actorsとは？Ray Actorsは、Ray APIを関数からクラスへと拡張する仕組みになります。前回紹介したRay Tasksは関数に対するデコレータとして実装していましたが、それのクラス版と解釈できます。Actorは基本的にステートフルなワーカー（またはサービス）で、新しいActorをインスタンス化すると、新しいワーカーを作成しそのワーカーにA...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Kubernetes Admission Controlについての技術調査]]></title>
            <link>https://sreake.com/blog/dive-deep-into-kubernetes-admission-control/</link>
            <guid isPermaLink="false">https://sreake.com/blog/dive-deep-into-kubernetes-admission-control/</guid>
            <pubDate>Tue, 12 Aug 2025 13:32:41 GMT</pubDate>
            <content:encoded><![CDATA[はじめに 工学院大学工学部電気電子工学科4年の清水悠利と申します。 大学では、C言語とOpenCVを用いた画像解析アルゴリズムの研究に従事しており、それとは別に趣味でWebアプリの開発も行っています。今回Sreake事業 […]The post Kubernetes Admission Controlについての技術調査 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[エンジニアのための「中身のある話」の作り方]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/08/12/210021</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/08/12/210021</guid>
            <pubDate>Tue, 12 Aug 2025 12:00:21 GMT</pubDate>
            <content:encoded><![CDATA[はじめにエンジニアの勉強会で、こんな経験はないだろうか。「〇〇って知ってる？」「最近△△が流行ってて」「□□の記事読んだ？」「✗✗さんって知り合い？」次から次へと断片的な情報を繰り出してくる人。どの話題も表面的で、深く掘り下げようとすると会話が続かない。そして、ふと気づく瞬間がある――自分も同じような話し方をしているのではないか、と。コードは書ける。タスクはこなせる。でも技術的な議論になると、借り物の言葉しか出てこない。 この恐怖を、多くのエンジニアが密かに抱えている(と思っている)。表層的な知識だけで話す「Fake野郎」――そう呼ばれることほど、エンジニアとしての信頼と自信を失う言葉はない。何者（新潮文庫）作者:朝井 リョウ新潮社Amazon現代のエンジニアは、かつてないほど豊富な学習リソースに囲まれている。朝から晩まで技術記事を読み漁り、新しいフレームワークを追いかけ、トレンドをキャッチアップする。それなのに、いざ技術的な議論になると、借り物の言葉しか出てこない。問題の本質は、情報量の不足ではない。むしろその逆だと思う。大量の情報を消費することで満足し、深く考える時間を失っている。その結果、「聞いたことはある」レベルの断片的な知識ばかりが蓄積され、体系的な理解や独自の洞察が育たない。今日はそんな問題について考えていきたいと思う。このブログが良ければ読者になったり、nwiizoのXやGithubをフォロワーしてくれると嬉しいです。では、早速はじめていきます。コミュニケーション技法の限界雑談を円滑にする方法、相手に好印象を与える話し方――こうしたスキルは確かに社会人として必要だ。共通の話題を見つけ、相手の意見に共感を示し、適度に自己開示をする。これらのテクニックで、職場の人間関係は確実に改善されるだろう。しかし技術的な文脈において「あの人の意見は聞く価値がある」と思われるためには、全く別の次元の能力が要求される。それは、技術に対する深い洞察と、実体験に基づく独自の視点だ。表面的なコミュニケーションスキルでこの本質的な課題を解決しようとするのは、バグの根本原因を無視してUIだけを修正するようなものだ。 一時的には改善したように見えても、本質的な問題は何も解決していない。人は聞き方が９割作者:永松 茂久すばる舎Amazon人は話し方が９割２作者:永松 茂久すばる舎Amazon凡人エンジニアの生存戦略厳しい現実を直視しよう。私たちの大半は、いわゆる「本物」ではない。必死で情報を集めて継ぎ接ぎしている「凡人エンジニア」だ。借り物の言葉で話し、Qiitaのコードで動かし、理解が浅いまま次のタスクに移る。まずは全力で実装して、全力で失敗することから始めよう。「ドキュメント読めばわかる」と言いながら、結局コピペで終わらせている。そんな中途半端な理解では、いつまでも表層的なままだ。公式ドキュメントの10倍のコードを書いて、サンプルコードの10倍のエッジケースを試して、それでも理解できなかったら、そこがスタートラインだ。センスは知識からはじまる作者:水野学朝日新聞出版Amazonセンスの哲学 (文春e-book)作者:千葉 雅也文藝春秋Amazon天才には直感がある。我々にはそれがない。だから地道に検証するしかない。優れたエンジニアが一目で見抜く問題を、我々はベンチマークを取り、プロファイラを回し、ボトルネックを一つずつ潰していく。それが我々の戦い方だ。禅とオートバイ修理技術 上 (ハヤカワ文庫NF)作者:ロバート Ｍ パーシグ早川書房Amazon禅とオートバイ修理技術 下 (ハヤカワ文庫NF)作者:ロバート Ｍ パーシグ早川書房Amazonそして朗報がある。本当に深い理解を持つエンジニアは、実はそんなにいない。一流と評価されているエンジニアのうち、本当に深い理解を持つのはごく一部。残りの大半は、我々と同じ、必死で技術ブログを読み漁って知識を継ぎ接ぎしている連中だ。深い理解がないのに評価されているエンジニアとの違いは、表層的な知識の組み立て方の上手さだ。断片的な知識を体系化し、一つ一つコードで検証して本物らしくなっていく。借り物でも、偽物でも、精度を上げていけば立派な「技術力のあるエンジニア」として認められる。批判された時こそ、謙虚に、誠実に、真摯でなくてはならない。批判してくる外野にではなく、理解したい技術そのものに対して。深い理解を持たない我々は、あくまで謙虚に、一つずつ理解を深めていくしかない。達人プログラマー ―熟達に向けたあなたの旅― 第2版作者:David Thomas,Andrew Huntオーム社Amazon情報収集の罠現代のエンジニアを取り巻く環境を見てみよう。GitHub、Hacker News、Reddit、Zenn、Qiita、技術ブログ、Twitter――無限とも思える情報の海が広がっている。朝起きてから寝るまで、常に新しい情報が流れ込んでくる。そして今や、ChatGPTやClaudeに「説明して」と投げるだけで、瞬時に整理された回答が返ってくる。 GitHub Copilotがコードを補完し、エラーメッセージをそのまま生成AIに貼り付ければ解決策が提示される。便利になった分、自分で考える機会は激減した。しかしここに大きな落とし穴がある。情報を消費し続けることと、知識を深めることは全く別の行為なのだ。むしろ過度な情報摂取は、深い思考を妨げる最大の要因となる。Qiitaから解決策をコピーペーストし、Zennの記事を斜め読みし、YouTubeのチュートリアルを倍速で流し見る。生成AIに「どうやって実装する？」と聞いて、返ってきたコードをそのまま使う。 こうした習慣は、一見効率的に見えるが、実は表面的な理解しか生まない。生成AIの回答は確かに正確で包括的だ。しかし、なぜその実装なのか、どんなトレードオフがあるのか、エッジケースはどうなるのか――こうした深い理解は、自分でデバッグし、失敗し、試行錯誤する中でしか得られない。必要なのは、情報の洪水から一歩離れ、静かに思考する時間だ。新しく学んだ概念について、なぜそう設計されているのか、どんな問題を解決しているのか、他のアプローチと比べてどんな利点があるのか――こうした問いと向き合う時間なくして、深い理解は得られない。奪われた集中力: もう一度〝じっくり〟考えるための方法作者:ヨハン・ハリ作品社Amazonアテンション・エコノミーと「驚き屋」の罠「〇〇驚き屋」という揶揄する言葉を聞いたことがあるだろうか。 新しい技術が出るたびに「革命的だ！」と騒ぎ立て、トレンドが変わるたびに「これからはこれだ！」と主張を変える。彼らの発言には深みがなく、表面的な驚きと感動だけで構成されている。これは個人の問題じゃなくて、アテンション・エコノミーが生み出す構造的な問題なんだよね。 クリック数、いいね数、PV数――これらの指標が支配する世界では、深い考察より刺激的なタイトルが、地道な検証より扇動的な主張が評価される。「〇〇は死んだ」「なぜ〇〇を今すぐやめるべきか」「〇〇を使わない奴は時代遅れ」 ――こうした極端なタイトルの記事が溢れる理由は明白だ。注目を集めることが最優先事項となり、技術の本質的な理解は二の次になる。技術ブログを書く側も読む側も、このアテンション・エコノミーの罠にはまっている。書く側は「バズる」ことを意識し、読む側は刺激的な情報を求めちゃう。 この悪循環が、技術コミュニティ全体の議論を浅くしている。価値のある技術的洞察は、地味で、時間がかかり、すぐには「バズらない」。でもさ、長期的に見れば、これらの深い考察こそが技術の進歩を支えているんだ。 派手な新機能の紹介記事より、バグの根本原因を探る地道な分析の方が、エンジニアとしての成長には遥かに有益だ。「驚き屋」にならないためには、情報の新しさではなく深さを追求する姿勢が必要だ。 トレンドを追いかけるのではなく、技術の本質を理解する。表面的な機能紹介に満足せず、なぜその設計になったのかを探求する。この姿勢こそが、技術力を育てる。アテンション・エコノミーのジレンマ　〈関心〉を奪い合う世界に未来はあるか作者:山本 龍彦KADOKAWAAmazon技術書と技術ブログプログラミング言語の入門書、フレームワークの解説書、設計パターンの教科書――積読が増えていく一方で、正直、身についた知識はどれだけあるだろうか。技術書を読むのは確かに良い。体系的な知識が得られ、著者の深い洞察に触れることができる。しかし、月に何冊も読破しようとすると、結局どれも消化不良に終わってしまう。一冊の技術書から価値を引き出すには、読んだ内容を実際に試し、既存の知識と関連付け、自分のプロジェクトに応用してみる必要がある。そして技術ブログとなると、この問題はさらに顕著になる。技術ブログは技術書以上に断片的で、文脈が省略され、前提知識がバラバラだ。朝のコーヒーを飲みながら5つの記事を流し読み、昼休みにさらに3つ、帰りの電車でまた10個――こうして大量の技術ブログを消費しても、頭に残るのは曖昧な印象だけ。「〇〇の新機能について読んだ気がする」「マイクロサービスの何かについて見た」「セキュリティの重要性について誰かが書いていた」――読んだはずなのに、具体的に何を学んだか説明できない。これが技術ブログの読み過ぎがもたらす典型的な症状だ。私の経験から言うと、技術ブログを立て続けに読むと、まるで異なるプログラミング言語を同時に学んでるような混乱が生じるんだ。ある記事ではTypeScriptのベストプラクティス、次の記事ではGoの並行処理、その次はKubernetesの設定――概念が混ざり合い、理解が浅くなり、結局どれも中途半端に終わってしまう。技術ブログの危険性は、その手軽さにある。 1記事5分で読めるという錯覚が、大量消費を促す。しかし実際には、その5分の記事を理解するには、コードを書いて検証し、関連概念を調べ、自分の言葉で説明できるようになるまで、少なくとも1時間は必要だ。質の高い学習とは、情報の量ではなく、理解の深さで測られる。 週に50本の技術ブログを流し読みするより、1本の記事を徹底的に理解し、実際にコードを書いて検証する方がはるかに価値がある。技術書なら月に1冊を深く読み込む方が、10冊を斜め読みするより遥かに身になる。知ってるつもり　無知の科学 (ハヤカワ文庫NF)作者:スティーブン スローマン,フィリップ ファーンバック早川書房Amazonインプットのコンテキストスイッチという罠コンテキストスイッチのコストは、アウトプットだけの問題じゃない。インプット（学習）においても、同じように深刻な影響を及ぼす。朝はReactのHooks、昼休みにRustの所有権、夕方にはKubernetesのネットワーキング、寝る前にデータベースのインデックス戦略――一見効率的に見えるが、これは脳に対して過酷なコンテキストスイッチを強いている。プログラミング言語を切り替えるとき、私たちの脳は文法、イディオム、エコシステム、思考パターンを丸ごと切り替える必要がある。JavaScriptの非同期処理を理解しようとしていた脳が、突然Goのgoroutineに切り替わる。この切り替えには、想像以上の認知的コストがかかる。オブジェクト指向から関数型プログラミングへ、ミュータブルからイミュータブルへ――異なるメンタルモデルが脳内で衝突し、どちらの理解も中途半端になってしまう。10分でDockerの記事、5分でGraphQL、15分で機械学習入門。このような学習は、パズルのピースをランダムに拾い集めているようなものだ。結果として「聞いたことはある」レベルの知識ばかりが蓄積される。理解を深めるには「没入」が必要だ。しかし頻繁なコンテキストスイッチは、この没入状態を妨げる。水面を滑るように情報を摂取しても、深海に潜ることはできない。効果的な学習のためには、「テーマを絞った集中的なインプット」が重要だ。 今週はReactに集中する、今月はデータベース設計を深める――こうした戦略的な学習計画が、技術力向上につながる。マルチタスクが生産性を下げるように、マルチトピック学習は理解を浅くする。 一つのテーマに集中し、関連する複数の情報源から多角的に学ぶ。この「深さ優先」のアプローチこそが、技術的洞察を生み出す土壌となる。あっという間に人は死ぬから　「時間を食べつくすモンスター」の正体と倒し方作者:佐藤 舞（サトマイ）KADOKAWAAmazon実践こそが深い理解への唯一の道理論を語るだけの評論家と、実際にシステムを構築するエンジニアの最大の違いは何か。それは、仮説を実証できる環境を持っているということだ。公式ドキュメントには「簡単に実装できます」と書かれていた機能が、実際にはエッジケースの山だった。ベンチマークでは高速だったライブラリが、実環境では思わぬボトルネックになった。こうした「理想と現実のギャップ」は、実装してみて初めて分かる。手を動かすことで見えてくる世界がある。「〇〇の新機能」という記事を10本読むより、実際にその機能を使ってみる。チュートリアルのコピペではなく、ゼロから書く。公式サンプルを動かすだけでなく、壊してみる。境界値を試し、負荷をかけ、エラーケースを検証する。平凡なエンジニアと卓越したエンジニアを分けるのは、「違和感」に対する感度だ。 このAPIの設計、何か不自然じゃないか？なぜこのフレームワークは、こんな実装を選んだのだろう？――天才なら一瞬で見抜く違和感を、凡人の我々は見逃してしまう。Fake野郎は表面的な動作だけ見て「動いたからOK」で終わらせる。だから深い理解に到達できない。 でも、小さな疑問を素通りせず、愚直にコードで検証する習慣を続ければ、いつか独自の技術的洞察にたどり着けるかもしれない。コードリーディングも、深い学習につながる。 ライブラリの内部実装を読めば、ドキュメントに書かれていない設計思想が見えてくる。GitHubでスター数の多いプロジェクトを開き、/srcディレクトリを覗く。最初は圧倒されるかもしれない。しかし、エントリーポイントから少しずつ読み進めれば、必ず「ああ、そういうことか」という気づきが訪れる。技術選定を誤った経験、見積もりを大きく外した経験、本番環境で障害を起こした経験――これらの苦い記憶こそが、最も価値ある学習材料となる。 成功事例からは「うまくいく方法」しか学べないが、失敗からは「なぜうまくいかないのか」という本質的な理解が得られる。個人的に思うのだが、思考を深めるための最良の方法の一つが、技術ブログの執筆だ。 コードの動作を説明し、設計の意図を言語化し、遭遇した問題と解決策を記録する。この過程で、曖昧だった理解が明確になり、見落としていた課題が浮かび上がる。完璧である必要はない。思考の過程を記録することに価値がある。「動いた」で満足せず、「なぜ動くのか」「どこまで動くのか」「動かなくなる境界はどこか」を探求する。サンプルコードをそのまま動かして終わりにするのではなく、必ず何か一つは変更を加えてみる。この小さな実験が、表面的な理解を本質的な理解へと変える。手を動かすことは、時間がかかる。 記事を読むだけなら5分で済むことが、実装すれば1時間かかるかもしれない。しかし、その1時間の投資が、将来の技術的議論で「実はこれ、実装してみたんですが...」と言える強みになる。この実体験に基づく発言こそが、「深みのある話」の源泉となるのだ。アイデアが生まれるプロセス深い技術的洞察はどのようにして生まれるのか。ジェームス・W・ヤングの名著『アイデアのつくり方』が、その答えを示してくれる。ヤングによれば、アイデアっていうのは既存の要素の新しい組み合わせで、その才能は事物の関連性を見つけ出す力に依存してるらしい。3年目までに身につけたい技術ブログの書き方でも紹介したがかなり自分の中でしっくり来ているのだと思う。アイデアのつくり方作者:ジェームス W.ヤングCCC MEDIA HOUSEAmazonこの考え方は、技術的な深みを持つエンジニアになるプロセスと驚くほど一致する。ヤングが提唱する5段階のプロセスを見てみよう。第1段階：資料を収集する特定の技術に関する専門知識と、幅広い一般知識の両方を集める。ドキュメントを読み、コードを書き、エラーメッセージと格闘する――これらすべてが資料収集だ。第2段階：資料を噛み砕く集めた情報を様々な角度から検討し、関係性を探る。「なぜこのAPIはこう設計されているのか」「他の言語ではどう実装されているか」と問いかけながら、情報を咀嚼する。第3段階：問題を放棄する一度意識的な思考から離れ、無意識に働かせる。デバッグに行き詰まったときに散歩に出る、複雑な設計問題を一晩寝かせる――これは逃避ではなく、創造的プロセスの一部だ。第4段階：アイデアが訪れるシャワー中、通勤中、ランチタイム――何気ない瞬間に「あっ、そうか！」という閃きが訪れる。バグの原因が突然分かる、エレガントな設計が浮かぶ、技術の本質が見える瞬間だ。第5段階：アイデアを現実に連れ出す閃いたアイデアを忍耐強く形にする。コードに落とし込み、動作を検証し、チームに説明する。この段階で初めて、漠然とした洞察が具体的な価値となる。多くのエンジニアが「深い話ができない」と悩む理由は、このプロセスのどこかが欠けているからだ。 情報収集ばかりで咀嚼が足りない、あるいは考えてばかりで実装しない。バランスこそが鍵となる。深い洞察が生まれない理由「技術的に深い話ができない」と悩んでいるなら、ヤングの5段階プロセスのどこが欠けているか診断してみよう。資料収集が不足している場合技術書を読む量が少ない、新しい技術に触れる機会が限られている――こんな状態では、組み合わせる要素自体が不足する。ただし、前述の通り大量の技術ブログを流し読みするのは逆効果だ。 質の高い情報源から、じっくりと知識を吸収することが重要となる。最も見落とされがちなのが、ソースコードという一次資料の重要性だ。 ドキュメントは理想を語り、ブログは表面を撫でるが、コードは真実を語る。なぜその設計になったのか、どんな制約があったのか、どんなトレードオフがあったのか――これらの答えはコードの中にある。優れたエンジニアは、コードを読む際に独自の視点を持っている。状態の遷移に着目する者、データの流れを追う者、エラーハンドリングから本質を見抜く者――アプローチは様々だが、共通するのは表層的な動作ではなく、設計の意図を読み取ろうとする姿勢だ。さらに重要なのは、技術以外の分野からの資料収集だ。 心理学、経済学、デザイン、哲学、歴史――こうした他分野の知識が、技術的な洞察に独特の深みを与える。ユーザー心理を理解せずに優れたUIは作れないし、経済原理を知らずにビジネス価値のあるシステムは設計できない。技術と他分野の知識が交差する地点に、イノベーティブなアイデアが生まれる。情報の咀嚼が不足している場合学んだことをそのまま記憶するだけで、自分の言葉で説明できない。コードは書けるが「なぜそう書くのか」を説明できない。これは最も多くのエンジニアが陥る罠だ。咀嚼とは、単に理解することではない。異なる文脈で再構成し、別の角度から検証し、既存の知識と結びつける創造的なプロセスだ。 学んだデザインパターンを、自分のプロジェクトの文脈で解釈し直す。新しいフレームワークの概念を、過去に使った技術と比較する。エラーメッセージの意味を、システム全体の動作と関連付けて理解する。図解する、誰かに説明する、ブログに書く――これらはすべて咀嚼のための手段だ。しかし最も効果的なのは、「もしこれが違う設計だったら」という仮定の問いを立てることだ。 なぜこのAPIはRESTfulなのか、GraphQLだったらどうなるか。なぜこのデータベースはRDBMSなのか、NoSQLだったらどうなるか。この思考実験が、表面的な理解を本質的な理解へと変える。思考を寝かせる時間がない場合常にタスクに追われ、締切に追われ、新しい情報を詰め込み続ける。これでは無意識が働く余地がない。創造的な洞察は、意識的な思考の合間に生まれる。問題を抱えたまま散歩に出る、シャワーを浴びる、コーヒーを淹れる――これらは逃避ではなく、無意識に問題を委ねる積極的な戦略だ。 優れたエンジニアは、デバッグに行き詰まったら席を立つ。設計に悩んだら一晩寝かせる。これは諦めではなく、脳の別の部分を活用する技術だ。重要なのは、問題を明確に定義してから離れることだ。 曖昧なまま放置しても、無意識は働かない。「なぜこのテストが失敗するのか」「どうすればこのパフォーマンスを改善できるか」――具体的な問いを立ててから離れることで、無意識が背景で処理を続ける。そして予期しない瞬間に、答えが浮かび上がる。閃きを見逃している場合「あれ？」という違和感、「もしかして」という仮説――これらの小さな気づきを「大したことない」と無視してしまう。閃きは派手なものばかりではない。むしろ日常の中の小さな違和感こそが、深い洞察への入り口となる。 なぜこのライブラリは、こんな回りくどい実装をしているのか。なぜこのエラーメッセージは、こんなに分かりにくいのか。なぜみんな、この非効率な方法を使い続けているのか。これらの違和感を捕まえるには、常に記録する習慣が必要だ。 スマートフォンのメモアプリ、Slackの自分専用チャンネル、紙のメモ帳――媒体は何でもいい。重要なのは、その瞬間を逃さないことだ。後から見返すと「なんでこんなことをメモしたんだろう」と思うこともある。しかし、その中の一つが、数週間後に重要な発見につながることがある。形にできない場合頭の中では分かっているのに、コードに落とせない、文章にできない、説明できない。これは「完璧主義の罠」かもしれない。しかしより深刻なのは、「形にする」ことの本質を誤解していることだ。 形にするとは、完成品を作ることではない。思考を外部化し、検証可能にし、他者と共有可能にすることだ。プロトタイプでいい、疑似コードでいい、箇条書きでいい。重要なのは、頭の中から外に出すことだ。最小限の形から始める勇気が必要だ。 100行の美しいコードではなく、10行の動くコード。推敲を重ねた技術記事ではなく、500文字のメモ。洗練されたプレゼンではなく、ホワイトボードの走り書き。これらの「不完全な形」こそが、思考を前進させる。形にする過程で新たな問題が見つかり、新たな洞察が生まれる。完璧を待っていては、永遠に何も生み出せない。それでも深い理解に到達できない時はここまで読んでも、できない人が大半だと思う。頭では理解できても、結局技術ブログを流し読みして、何も実装せずに終わっていく。偽物は偽物のまま、凡人は凡人のまま終わってしまうのか。違う。凡人には凡人の戦い方がある。深い理解に一足飛びに到達できないなら、浅い理解を100回積み重ねればいい。 天才が1回で見抜くバグを、我々は10回のprint文で追い詰める。「なんとなく分かった」を50個集めれば、いつの間にか体系的な理解の入り口に立っている。そして何より大切なのは、この積み重ねを「誠実に」続けることだ。分からないことを分からないと認める。コピペしたコードに「理解した」と言わない。ChatGPTが生成したコードを自分が書いたように見せない。この小さな正直さが、長期的には最も強い武器になる。「分からないけど動いた」と正直に言えるエンジニアは、意外と信頼される。 なぜなら、その人の「分かった」という言葉には重みがあるからだ。誠実にコードと向き合い続けると、不思議なことが起きる。3年前に書いた「分からないまま動かしたコード」の意味が、ある日突然分かる瞬間が来る。 これは、誠実に向き合い続けた者だけに与えられる報酬だ。凡人の強みは、凡人の気持ちが分かることだ。 天才の書く完璧なドキュメントより、凡人の書く「ここでハマった」メモの方が、多くの人を救うこともある。一人でこっそり胸を張ってもいい。地道で誠実な成長を、私は美しいと思う。ファスト教養　10分で答えが欲しい人たち (集英社新書)作者:レジー集英社Amazonおわりに記事自体が筆者の批判する「大量の情報」になってしまっている点は皮肉をぶつけないで下さい。痛いです。問題は知識の量だけではない。 大量の情報を右から左へ流すだけでは、いつまでも「借り物の言葉」しか話せない。深みのある技術者になるために必要なのは、情報の消費を減らし、思考の時間を増やすことだ。 週に50本の技術ブログを流し読みする代わりに、1つのテーマに集中して深く潜る。天才ではない我々には、地道な努力しかない。偽物は偽物なりに、凡人は凡人なりに、全力で実装して、全力で失敗して、そこから学ぶ。借り物の知識でも、継ぎ接ぎの理解でも、精度を上げていく。今日から始められることは、シンプルだ。 週に1時間、ネットから離れて静かに考える時間を作る。今週取り組んだ技術的課題について振り返り、500文字でもいいから言語化する。何より恐れるのは「Fake野郎」と呼ばれることだ。借り物の言葉で話し、実装経験もないのに知ったかぶりをし、深い理解もないのに分かったふりをする。でも、それでいい。大切なのは、自分がFake野郎かもしれないという自覚を持ち、それでも前に進む勇気を持つことだ。週に1時間、静かに考える。500文字でもいいから言語化する。実装して、失敗して、そこから学ぶ。この小さな積み重ねが、いつか「あの人の話には深みがある」と言われる日につながる。Fake野郎から始まってもいい。大切なのは、そこで終わらないことだ。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rayシリーズ：Tasks]]></title>
            <link>https://zenn.dev/akasan/articles/f5be2708dc34df</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/f5be2708dc34df</guid>
            <pubDate>Tue, 12 Aug 2025 05:24:48 GMT</pubDate>
            <content:encoded><![CDATA[今回からRay解説シリーズを始めてみようと思います。分散コンピューティングライブラリとして絶対的な地位を気づいているであろうRayを使えるようになるために解説してみます。 Ray Tasksとは？Ray TasksはRay Coreの一つとして置かれている機能の一つになります。任意の関数を別のPythonワーカー上で非同期的に実行することを可能にするための機能になります。Ray Tasksで扱われる関数はRayリモート関数と呼ばれ、その非同期呼び出しはRayタスクと呼ばれます、https://docs.ray.io/en/latest/ray-core/tasks.html#ra...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[yttに入門してみた]]></title>
            <link>https://zenn.dev/akasan/articles/b773d7c2be0327</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/b773d7c2be0327</guid>
            <pubDate>Mon, 11 Aug 2025 05:41:30 GMT</pubDate>
            <content:encoded><![CDATA[今回は、yttをを用いてYAMLファイルを生成する方法について学習してみました。 yttとは？公式サイトによると、Template and patch as needed to easily make your configuration reusable and extensible. Works with your own and third-party YAML configuration.ということで、YAMLファイルについてテンプレートとパッチを適用することで、設定を簡単に再利用・拡張できるツールということです。YAMLファイルは基本的には静的に指定した値を利用す...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Datadog LLM Observabilityへの入門]]></title>
            <link>https://zenn.dev/akasan/articles/c6e1a1a001f863</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/c6e1a1a001f863</guid>
            <pubDate>Sun, 10 Aug 2025 06:07:02 GMT</pubDate>
            <content:encoded><![CDATA[今回は、DatadogのLLM Observabilityの機能を利用して、LLMアプリケーションの結果をDatadogにて取り扱ってみます。 Datadog LLM Observabilityとは？DatadogはObservabilityのSaaSとして絶対的な地位をとっているツールかと思います。LLMの発展に伴い、DatadogでもLLMのObservabilityを対応できるようになっており、その機能が今回紹介する機能になります。この機能を利用することでLLMアプリケーションの問題点の特定やパフォーマンス測定などを行うことができ、より堅牢なLLMアプリケーションの実装を実現...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Neovim ≧ 0.11ユーザーのためのnvim-treesitter最新版利用ガイド（mainブランチ切り替え）]]></title>
            <link>https://blog.atusy.net/2025/08/10/nvim-treesitter-main-branch/</link>
            <guid isPermaLink="false">https://blog.atusy.net/2025/08/10/nvim-treesitter-main-branch/</guid>
            <pubDate>Sun, 10 Aug 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Neovim 0.11以降のnvim-treesitterプラグインのmainブランチへの移行方法を紹介します。masterブランチは2025年5月で更新が止まっているので、切り替えの時期だと思います。ただし、変更範囲が大きく、単純に切り替えるとNeovim起動時にエラーが出るので注意が必要です。本体の設定方法に加え、自動ハイライトの有効化方法や依存プラグインの更新方法など、切り替えに必要な情報をまとめました。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[開発に使っているアプリケーションリストアップしてみた]]></title>
            <link>https://zenn.dev/akasan/articles/469eda61a31bfc</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/469eda61a31bfc</guid>
            <pubDate>Sat, 09 Aug 2025 13:25:02 GMT</pubDate>
            <content:encoded><![CDATA[今回は普段の開発作業などで利用しているアプリケーションについて一覧にしてみました。 メモ系 NotionNotionは個人環境でドキュメント管理やメモとかで多用しています。ブログネタ考えたりナレッジ蓄積に大いに役立っています。https://www.notion.com/ja IDE系 CursorCursorはもう説明はいらないでしょう。みなさんお馴染みのAIコードエディタです。小規模な開発はvimを使っているのですが、大規模なものになるとCursorを使っています。https://cursor.com/ja 描画系 draw.ioアーキテクチャ図とか...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Pytorch Lightningに入門してみた]]></title>
            <link>https://zenn.dev/akasan/articles/2b625606090524</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/2b625606090524</guid>
            <pubDate>Fri, 08 Aug 2025 14:23:27 GMT</pubDate>
            <content:encoded><![CDATA[今回はpytorchのエコシステムの一つであるLightningに入門してみました。 Lightningとは？PyTorch Lightningとは、PyTorchのエコシステムの一つであり、モデルの開発から本番運用まで広く対応したフレームワークです。最小限の労力で最大限の柔軟性を与えることができ、パフォーマンスを落とすことなくモデル開発を行うことができます。PyTorchのモデル学習では必ずしもLightningのようなフレームワークは必要なく、PyTorchのみでも十分モデル学習はできます。一方、実験管理などをしようとお思うと独自に実装する必要があったりで結構面倒な作業が多いの...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Agent Development Kitで作るマルチエージェントアプリケーション（AIAgent勉強会）]]></title>
            <link>https://speakerdeck.com/yunosukey/agent-development-kitdezuo-rumarutiezientoapurikesiyon-aiagentmian-qiang-hui</link>
            <guid isPermaLink="false">https://speakerdeck.com/yunosukey/agent-development-kitdezuo-rumarutiezientoapurikesiyon-aiagentmian-qiang-hui</guid>
            <pubDate>Fri, 08 Aug 2025 04:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Vimでヤンクした内容の上書き回避にはマイナス（-）をブラックホールレジスタにマッピングするといいよ]]></title>
            <link>https://blog.atusy.net/2025/08/08/map-minus-to-blackhole-register/</link>
            <guid isPermaLink="false">https://blog.atusy.net/2025/08/08/map-minus-to-blackhole-register/</guid>
            <pubDate>Fri, 08 Aug 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[nnoremap - "_しておくと、ヤンクした内容を残しながら編集できて便利ですよ。"_ciwは入力しにくいですけど-ciwなら入力しやすいですよね。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Cloud RunにデプロイしたmlflowからArtifactsをダウンロードすることを禁止するには？]]></title>
            <link>https://zenn.dev/akasan/articles/5f823793737bf6</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/5f823793737bf6</guid>
            <pubDate>Thu, 07 Aug 2025 11:03:16 GMT</pubDate>
            <content:encoded><![CDATA[今回はCloud RunにデプロイしたmlflowサーバかのUIからアーティファクトのダウンロードを阻止することができるか調べてみました。mlflowに関するアドバイスをしようということでmlflowについてちょうど調べていました。mlflow uiではモデルに関連づけられたアーティファクトのダウンロード機能があるのですが、mlflow uiとしてはそのダウンロードを拒否する仕組みが備わっていないです。セキュリティリスクになることからこれを防ぐ方法はないか調べてみた結果、うまくIAM設定をすると対応できるということがわかったので、その方法をブログにしてみます。※ 今回のコードはclau...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google Cloudサービスの生成AI関連サービス]]></title>
            <link>https://speakerdeck.com/shukob/google-cloudsabisunosheng-cheng-aiguan-lian-sabisu</link>
            <guid isPermaLink="false">https://speakerdeck.com/shukob/google-cloudsabisunosheng-cheng-aiguan-lian-sabisu</guid>
            <pubDate>Thu, 07 Aug 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[2025年8月7日(木)、日本生成AIユーザ会 で「Google Cloudサービスの生成AI関連サービス」について発表しました。https://genai-users.connpass.com/event/361798/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Apache Linkisとはなんなのか？]]></title>
            <link>https://zenn.dev/akasan/articles/0cad512332b58c</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/0cad512332b58c</guid>
            <pubDate>Wed, 06 Aug 2025 14:12:33 GMT</pubDate>
            <content:encoded><![CDATA[今回はApache Linkisについて調べてみました。 今回も以下のツールを使って対象プロジェクトを決めました！https://zenn.dev/akasan/articles/7e30ad266c02c4※ 本企画に関する記事の目的は、それぞれのプロジェクトを本格的に深ぼるのではなく、プロジェクト名⇆どんな内容かをパッと思い出せるようにすることを目指します！※ とはいえ深ぼってみたいプロジェクトがあればどんどん複数連載になると思います。 Apache Linkisとは？公式サイトによると、Linkis builds a computation middleware l...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[短編：Lensを使ってKubernetes環境をモニタリングしてみた]]></title>
            <link>https://zenn.dev/akasan/articles/9cc74002290a99</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/9cc74002290a99</guid>
            <pubDate>Tue, 05 Aug 2025 14:15:24 GMT</pubDate>
            <content:encoded><![CDATA[今回はKubernetesのモニタリングなどに利用できるIDEであるLensを使ってみたので、その共有をしようと思います。※ 本日健康診断を受けた結果体力が著しくなくなっちゃったため、ほんとにちょっと使ってみた感想になってしまいました。そのため、次回もっと本格的にLensを使ってみて記事出しますので今日のところはこれで勘弁してくださいw Lensとは？Lensとは公式の説明によるとLens is a Kubernetes platform that provides tools for seamless interaction with Kubernetes clusters...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Agent Development Kitで作るマルチエージェントアプリケーション（GCNT2025）]]></title>
            <link>https://speakerdeck.com/yunosukey/agent-development-kitdezuo-rumarutiezientoapurikesiyon-gcnt2025</link>
            <guid isPermaLink="false">https://speakerdeck.com/yunosukey/agent-development-kitdezuo-rumarutiezientoapurikesiyon-gcnt2025</guid>
            <pubDate>Tue, 05 Aug 2025 04:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[PyCaretを利用して簡単にモデル比較を行おう]]></title>
            <link>https://zenn.dev/akasan/articles/9844ec4f012639</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/9844ec4f012639</guid>
            <pubDate>Mon, 04 Aug 2025 10:51:03 GMT</pubDate>
            <content:encoded><![CDATA[今回はローコードでモデルを開発できるPyCaretを利用して、titanicデータセットの分類をさせてみようと思います。 PyCaretとは？PyCaretとは、オープンソースのローコードで機械学習モデルを開発できるPythonライブラリです。通常機械学習モデルを開発する時はscikit-learnやXGBoost、LightGBMなど様々なライブラリを駆使し、ベースモデルや比較対象モデルを開発して行きます。しかし、モデルの開発を行う場合は多くの実装を必要とすることが多々あり、最低限の設定でモデルを作って性能比較をしたいと言った場合に負担が大きかったと思います。そこでPyCaret...]]></content:encoded>
        </item>
    </channel>
</rss>