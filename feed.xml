<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Mon, 29 Sep 2025 02:29:14 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[Platform Engineering Maturity Modelってなに？]]></title>
            <link>https://zenn.dev/r4ynode/articles/platform-engineering-maturity-model</link>
            <guid isPermaLink="false">https://zenn.dev/r4ynode/articles/platform-engineering-maturity-model</guid>
            <pubDate>Sun, 28 Sep 2025 23:00:01 GMT</pubDate>
            <content:encoded><![CDATA[はじめに先日、以下のイベントに参加しました。そこで「Platform Engineering Maturity Model」を知ったので、その概要をまとめ、実際にどのように活用するのかを考えてみます。https://www.cnia.io/pek2025/ そもそもPlatform Engineeringってなに？!賛否両論ありそうな議題なので鵜呑みにしないでください。本題に入る前に一度初心にかえります。私は「Platform Engineering」を曖昧に理解しています。DevOpsやSREなど、類似する概念の定義と重なる部分があり、境界が曖昧に感じるところがあ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[私のブログの記事をWord Cloudにしてみた]]></title>
            <link>https://zenn.dev/akasan/articles/2532aa47d42451</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/2532aa47d42451</guid>
            <pubDate>Sun, 28 Sep 2025 05:43:03 GMT</pubDate>
            <content:encoded><![CDATA[今回は、私のテックブログの記事をWord Cloudにして、どんな言葉がよく使われているか調べてみました。この記事で164記事目であり、結構な数の記事を出してきたのでどんな言葉をよく使っているか調べたくなりやってみた次第です。 WordCloudとは？WordCloudとはどのような単語がよく利用されているかをわかりやすく可視化するためのツールになります。画像内に文字が表示されるのですが、その文字が大きければ大きいほど利用頻度が多い単語になります。結果はこの後実際にお見せします。 WordCloud実装する 対象ドキュメント私はZennの記事をGitHubにて管理していま...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[みんなの考えた最強のデータ基盤アーキテクチャ第５回 参加ログ]]></title>
            <link>https://zenn.dev/nedoko_dok0dko/articles/589fc799f824c6</link>
            <guid isPermaLink="false">https://zenn.dev/nedoko_dok0dko/articles/589fc799f824c6</guid>
            <pubDate>Sat, 27 Sep 2025 07:29:56 GMT</pubDate>
            <content:encoded><![CDATA[what9/24(水)に開催された「みんなの考えた最強のデータ基盤アーキテクチャ第５回〜オールスター大集合スペシャル！！」の参加ログです。https://datatech-jp.connpass.com/event/360596/今回が初参加&初現地という完全初見でドキドキの中いってきました。 イベント概要datatech-jpというデータエンジニアのコミュニティで集ったデータエンジニアが、それぞれ考える最強のデータ基盤アーキテクチャを紹介し合うというイベントです。過去に４回開催されており、５回目となる今回は過去登壇した方々が「今のデータ基盤」を語るというもので...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[TFLintに入門してみた]]></title>
            <link>https://zenn.dev/akasan/articles/c5c1729e8941a6</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/c5c1729e8941a6</guid>
            <pubDate>Sat, 27 Sep 2025 05:13:44 GMT</pubDate>
            <content:encoded><![CDATA[今回はTFLintに入門してみました。今まではTerraformを利用する際にLinterを導入していなかったので、TFLintを用いてLinter入門してみました。 TFLintとは？TFLintはTerraformのプラグインであり、以下のような特徴を持つようです。主要なクラウドプロバイダー（AWS/Azure/Google Cloud）の可能性のあるエラー（無効なインスタンスタイプなど）を検索非推奨の構文や未使用の宣言について警告ベストプラクティス、命名規則を実施私は主にGoogle Cloudに対して利用していましたが、主要なクラウドプロバイダーを対象としたチェ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[claude codeにjailbreakの防ぎ方理解しているか聞いてみた]]></title>
            <link>https://zenn.dev/akasan/articles/610e22ba6ff864</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/610e22ba6ff864</guid>
            <pubDate>Fri, 26 Sep 2025 14:16:21 GMT</pubDate>
            <content:encoded><![CDATA[今回も超短編になってしまいます。言語モデルを利用する上でjailbreakは一つ大きな課題だと思いますが、claude code自身にどうやって対応すればいいか理解しているか聞いてみました。 入力プロンプトプロンプトは以下にしてみました。あなたは言語モデルかと思いますが、jailbreak攻撃について対処していますか？ちなみにjailbreak攻撃ですが、言語モデルに対して本来はガードレールなどで防御されていたとしても、プロンプトのやり取りを通して予期しない結果を出力させるような攻撃になります。例えば以下の記事の説明がとてもわかりやすいかと思います！https://say...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ディレクトリ構成 ~レイヤーベース編~]]></title>
            <link>https://sreake.com/blog/layer-based-directory-structure-good-practice/</link>
            <guid isPermaLink="false">https://sreake.com/blog/layer-based-directory-structure-good-practice/</guid>
            <pubDate>Fri, 26 Sep 2025 06:30:23 GMT</pubDate>
            <content:encoded><![CDATA[はじめに アプリケーション開発において、ディレクトリ構成は保守性・拡張性・開発効率に直結する設計要素です。 本記事では、以下のような課題に悩む現場に向けて、「シンプルで直感的、責務ごとの分離が容易」であるレイヤーベース構 […]The post ディレクトリ構成 ~レイヤーベース編~ first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[(超短編)claude codeに食べ物の苦手克服方法聞いてみた]]></title>
            <link>https://zenn.dev/akasan/articles/2e374bab98ac96</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/2e374bab98ac96</guid>
            <pubDate>Thu, 25 Sep 2025 14:35:13 GMT</pubDate>
            <content:encoded><![CDATA[今回はすごい短編になります。 何をする？実はわたし、魚が苦手でして必然的にお寿司が苦手なんですが、claude codeに聞けば克服方法教えてくれるかなと思って質問してみました。 結果質問したプロンプトはいかになります。お寿司が苦手なんですが、どのように好きになればいいと思いますかこれに対してどんな結果が帰ってきたかですが、あまりにあっさりとした内容でした。以下が回答になります。申し訳ございませんが、私はプログラミングとソフトウェア開発を支援するためのツールです。食べ物の好みについてのアドバイスよりも、コーディング、デバッグ、技術的な問題の解決などでお手伝いさせ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitHub Actions × AWS OIDC連携の仕組みと経緯を理解する]]></title>
            <link>https://speakerdeck.com/ota1022/github-actions-x-aws-oidclian-xi-noshi-zu-mitojing-wei-woli-jie-suru</link>
            <guid isPermaLink="false">https://speakerdeck.com/ota1022/github-actions-x-aws-oidclian-xi-noshi-zu-mitojing-wei-woli-jie-suru</guid>
            <pubDate>Thu, 25 Sep 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[3-shake SRE Tech Talk #13 オンサイトのLT登壇資料です。https://3-shake.connpass.com/event/362683/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2025-09-25 SRETT #13 ConftestによるTerraformのPolicy as Codeを試してみる]]></title>
            <link>https://speakerdeck.com/masasuzu/2025-09-25-srett-number-13-conftestniyoruterraformnopolicy-as-codewoshi-sitemiru</link>
            <guid isPermaLink="false">https://speakerdeck.com/masasuzu/2025-09-25-srett-number-13-conftestniyoruterraformnopolicy-as-codewoshi-sitemiru</guid>
            <pubDate>Thu, 25 Sep 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[[3-shake SRE Tech Talk #13 オンサイト - connpass](https://3-shake.connpass.com/event/362683/)でLTした内容。Conftestを軽く試してみた内容。もう少し深堀りして、再度発表したいところ。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Cloud Service Mesh 入門編-Google のマネージドサービスメッシュを理解する]]></title>
            <link>https://sreake.com/blog/cloud-service-mesh-getting-started/</link>
            <guid isPermaLink="false">https://sreake.com/blog/cloud-service-mesh-getting-started/</guid>
            <pubDate>Thu, 25 Sep 2025 02:12:40 GMT</pubDate>
            <content:encoded><![CDATA[自己紹介 千葉工業大学大学院 情報科学研究科 情報科学専攻 修士１年の井上 裕介と申します．大学では主にメタヒューリスティクスに関する最適化アルゴリズムの研究に従事しております．2023 年のサマーインターンから引き続き […]The post Cloud Service Mesh 入門編-Google のマネージドサービスメッシュを理解する first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Kubeflow Pipelinesでループを取り扱う方法]]></title>
            <link>https://zenn.dev/akasan/articles/025bbc3a66aa15</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/025bbc3a66aa15</guid>
            <pubDate>Wed, 24 Sep 2025 13:01:06 GMT</pubDate>
            <content:encoded><![CDATA[今回はKubeflow Pipelinesでループを利用する方法について調べてみたので共有したいと思います。このほかにKubeflowでは条件分岐も提供されており、昨日の記事にて共有していますので興味がある方はぜひこちらもご覧ください。https://zenn.dev/akasan/articles/3d8bad30009c85 早速やってみる今回もKubeflowが提供している公式ドキュメントを元にしています。構成としては、ローカルでKubeflow Piprlines（以下、kfp）を用いてパイプラインを実装し、パイプラインファイルをCloud Storageにアップロードし...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Kubeflow Pipelinesで条件分岐をする方法]]></title>
            <link>https://zenn.dev/akasan/articles/3d8bad30009c85</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/3d8bad30009c85</guid>
            <pubDate>Tue, 23 Sep 2025 09:38:03 GMT</pubDate>
            <content:encoded><![CDATA[今回はKubeflow Pipelinesで条件分岐を利用する方法について調べてみたので共有したいと思います。 早速やってみる今回はKubeflowが提供している公式ドキュメントを元にしています。構成としては、まずはローカルでKubeflow Piprlines（以下、kfp）を用いてパイプラインを実装し、パイプラインファイルをCloud Storageにアップロードした上でVertex AI Pipelinesから起動します。https://www.kubeflow.org/docs/components/pipelines/user-guides/core-functions...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CTFのためのKubernetes入門]]></title>
            <link>https://speakerdeck.com/kyohmizu/ctfnotamenokubernetesru-men</link>
            <guid isPermaLink="false">https://speakerdeck.com/kyohmizu/ctfnotamenokubernetesru-men</guid>
            <pubDate>Tue, 23 Sep 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[イベント登壇資料です。2025/09/23 魔女のお茶会 #8https://witchskeyparty.connpass.com/event/363928/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vertex AI Pipelinesを利用してエンドポイントをデプロイした]]></title>
            <link>https://zenn.dev/akasan/articles/093e1d1d3ec445</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/093e1d1d3ec445</guid>
            <pubDate>Mon, 22 Sep 2025 11:20:35 GMT</pubDate>
            <content:encoded><![CDATA[今回はVertex AI Pipelinesを利用してモデルを開発してエンドポイントにデプロイするためのチュートリアルを実施しました。Google Cloudがオフィシャルで提供しているノートブックがあり、それを利用してデプロイするための方法を解説しようと思います。なお、Pipeline構成コードはサンプルに則って進めますが、インフラ構成についてはTerraformで作成します。https://github.com/GoogleCloudPlatform/vertex-ai-samples/blob/main/notebooks/official/pipelines/google_cl...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[エンジニアはちゃんと身銭を切れ]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/09/22/175353</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/09/22/175353</guid>
            <pubDate>Mon, 22 Sep 2025 08:53:53 GMT</pubDate>
            <content:encoded><![CDATA[はじめにnekogata.hatenablog.comを読みました。オーナーシップを阻害する構造的な問題について丁寧な分析がされていて、なるほどと思う部分が多かった。しかし、私はこの問題の核心はもっとシンプルなところにあると考えている。エンジニアが身銭を切っていない。それだけだ。構造を変えても、制度を整えても、身銭を切らないエンジニアは責任を取らない。逆に、どんな環境でも身銭を切るエンジニアは結果を出す。言い方はなんでもよいが私はそういう覚悟のキマったエンジニアを何人も見てきた。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。身銭を切るとは何か身銭を切るとは、「リスクと責任を自ら引き受け、成功すれば報酬を、失敗すれば代償を受け入れる覚悟を持つこと」だと、私は理解している。ナシーム・ニコラス・タレブが『身銭を切れ: SKIN IN THE GAME』で示した原理をエンジニアリングに当てはめて考えると、コードを書いた者、システムを構築した者が、その結果から逃れられない状況に自らを置くことを意味するのではないか。成功の果実を享受するなら、失敗のリスクも引き受ける——この対称性があってこそ、プロフェッショナルと呼べるのかもしれない。これは給料が減るとか、クビになるとか、そういった話ではないと思う。自分の評判、プライド、チームからの信頼、深夜の時間、精神的なストレス——これらを賭けて仕事に臨むことが、身銭を切るということではないだろうか。タレブはこれを「魂を捧げる」（Soul in the Game）とも表現する。金銭的損失より、こうした目に見えない資産の方が取り戻すのは困難だ。タレブの倫理観の根底にはリバタリアニズムがあるという。自由に選択する権利と、その帰結を受け入れる責任は不可分だ。エンジニアとして技術選定の自由を求めるなら、その結果も引き受ける。アーキテクチャを決める権限を持つなら、その保守コストも背負う。これがタレブの言う「フェアネス」の本質なのかもしれない。私が考えるプロフェッショナルとは、自分の仕事の結果に責任を持とうとする者のことだ。失敗したときに「言われた通りに作っただけ」という逃げ道を使わない。それが身銭を切る姿勢だと思っている。本番でバグが起きたら、できる範囲で対応する。緊急度に応じて、翌朝一番でもいいかもしれない。ユーザーが困っていたら、次のリリースで改善を検討する。見積もりが外れたら、スケジュールを調整して現実的な着地点を探る。無理は続かないし、燃え尽きたら元も子もない。しかし最近、こうした責任感を持つことが難しくなっているのかもしれない。タレブの言葉を借りれば、身銭を切らずに成功した者は「ペテン師」として生きることになるという。そのような生き方は、少なくとも私には難しいと感じる。構造や制度の問題を語る前に、まず自分が身銭を切っているか——そこから問い直してみることも大切ではないだろうか。身銭を切れ――「リスクを生きる」人だけが知っている人生の本質作者:ナシーム・ニコラス・タレブダイヤモンド社Amazonなぜエンジニアは身銭を切らないのか心理的安全性の誤解「心理的安全性」は本来「率直な意見を言える環境」を意味する。しかし多くの現場では「失敗しても責められない環境」と誤解されている。この誤解が責任回避の文化を生む。失敗への恐れが完全に取り除かれ、緊張感も真剣さも失われていく。本当の心理的安全性とは、失敗を認め、責任を取り、改善できる環境のことだ。失敗を恐れないことではない。しかし多くのエンジニアは、この「責任を取る」部分を都合よく忘れている。心理的安全性は、責任から逃れるための免罪符ではない。心理的安全性のつくりかた　「心理的柔軟性」が困難を乗り越えるチームに変える作者:石井遼介日本能率協会マネジメントセンターAmazonキャリアの流動性という逃げ道エンジニアの転職市場は活発だ。この流動性が、長期的な責任から逃れる手段になっている。プロジェクトが失敗しても「より良い環境を求めて」転職すればいい。技術的負債を積み上げても「新しい挑戦」として別の会社に移ればいい。3年後のシステムの保守性など考えない——どうせ3年後には別の会社にいるからだ。プロフェッショナルなエンジニアは、自分が書いたコードの5年後、10年後を見据えて設計する。転職しても、過去に携わったシステムの成功や失敗を自分の責任として背負い続ける。転職の容易さに甘えるエンジニアは、失敗の履歴をリセットできると考え、新しい職場でも同じ過ちを繰り返す。この差が、身銭を切らないエンジニアとプロフェッショナルを分けている。「技術的に正しい」という隠れ蓑「技術的に正しい」——この言葉は、ソフトウェアエンジニアにとって最強の防御壁となる。ユーザーが使いにくいと言っても「技術的には正しい実装」。パフォーマンスが悪くても「理論的には最適なアルゴリズム」。ビジネスが失敗しても「技術選定は間違っていなかった」。技術の複雑性を盾に、結果への責任を回避する。しかし技術はあくまで手段だ。目的を達成できなければ、どんなに技術的に優れていても意味がない。「素人には分からない」という態度は、プロフェッショナルの姿勢ではない。タレブの言葉を借りれば、このような態度は「身なりがきちんとしている」偽物の特徴だ。本物の外科医は外科医らしく見える必要がない。本物のエンジニアも、技術的正しさをひけらかす必要はない。結果で証明すればいい。情報の非対称性に甘える構造エンジニアと非エンジニアの間には、圧倒的な情報の非対称性がある。この構造は、タレブが批判する「情弱ビジネス」と似た構造を取りやすい。専門知識を持たない経営者やユーザーは、エンジニアの判断が正しいかどうか検証できない。「技術的に難しい」「セキュリティ上必要」「パフォーマンスのため」——これらの説明が、よく吟味されずに個人の信頼次第で通ってしまうことがある。本来なら、不確実性やリスクを正直に伝え、選択肢を提示すべきだ。しかし時として、エンジニアも不確実性を十分に説明せずに進めてしまう。「今回の障害は予測不可能でした」で済ませてしまう。だが、その予測不可能な事態への備えについて、事前にどれだけ議論したのか。この構造的な問題に無自覚でいると、知らず知らずのうちに責任から逃れる習慣が身についてしまう。情報の非対称性があるからこそ、より誠実に、より責任を持って行動する必要がある。集団責任という幻想チーム開発は素晴らしい。協力は不可欠だ。相互レビューは品質向上に欠かせない。しかし「チーム全体で責任を持つ」という理念が、「誰も責任を持たない」言い訳に変質している。コードレビューで承認したから、バグは全員の責任。スプリント計画で合意したから、遅延は全員の責任。全員の責任は、誰の責任でもない。優れたチームこそ、個々人が明確な責任範囲を持ち、その上で協力する。集団責任の名の下に、個人の責任を曖昧にしてはならない。構造的な制約という現実経済学でいう「プリンシパル＝エージェント問題」というのがある。依頼者と実行者の目的がずれてしまう現象は、確かに存在する。エンジニアは良いものを作りたい。ユーザーに喜んでもらいたい、技術的負債を残したくない、保守しやすいシステムを構築したい。しかし契約形態や組織構造がその想いを阻むことがある。構造的な問題は確かに存在する。しかし、その中でも身銭を切る方法はある。契約外でも障害対応の知見を共有する。振り返りを徹底する。後任のためにドキュメントを残す。小さな積み重ねが信頼となり、より良い条件での仕事につながる。制約の中でも最善を尽くす。それがプロフェッショナルなエンジニアの身銭の切り方だ。ja.wikipedia.org身銭を切らないことの代償対称性の崩壊身銭を切らない場合、リスクの非対称性が生じる。成功すれば褒められるが、失敗しても「次は気をつけましょう」で終わる。エンジニアにとって失敗は「学習機会」だが、ユーザーにとってはただの「使えないサービス」だ。火災現場で消防士が「今日は調子が悪い」と言っても、火は待ってくれない。これは利益と損失の対称性が崩れた状態だ。利益は享受するが、損失は他者に押し付ける。この非対称性は、システム全体を脆弱にする。なぜなら、リスクを正しく評価するインセンティブが失われるからだ。一行のログの向こうには、一人のユーザーがいる。しかし、身銭を切らないエンジニアにとって、それは単なるデータポイントでしかない。判断力の鈍化身銭を切らないと、人は愚鈍になる。これは精神論ではなく、認知科学的な事実だ。リスクを負わない意思決定は、判断力を鈍らせる。「どうせ自分は痛まない」という前提があると、細部への注意が疎かになり、リスクの評価が甘くなる。コードレビューも形式的になり、テストも「とりあえず」で済ませる。身銭を切らないエンジニアは、技術的な勘が育たない。「なんか嫌な予感がする」という直感は、過去の痛みから生まれる。痛みを知らない者に、危険を察知する能力は宿らない。同じ失敗の繰り返し「痛みは学びを助く」。人間は失敗して痛みを感じることで学び成長する。しかし、身銭を切らない失敗は「他人事」として処理される。「前のプロジェクトでも同じ問題があったよね」という会話を何度聞いたことか。それは誰も身銭を切っていないからだ。痛みがなければ、学びもない。組織レベルでも同じだ。身銭を切らない文化では、ポストモーテムは形骸化し、「再発防止策」は実行されない。なぜなら、誰も本気で「次は自分が痛む」と思っていないからだ。新　失敗学　正解をつくる技術作者:畑村洋太郎講談社Amazon成長機会の喪失ストレスや失敗から強くなる——この「反脆弱性」は、身銭を切ることでしか得られない。身銭を切らないエンジニアは、いつまでも脆いままだ。小さな変化にも対応できず、予期せぬ事態に直面すると思考停止する。マニュアルにない状況では判断できず、前例のない問題には手が出せない。逆に、身銭を切り続けたエンジニアは、失敗するたびに強くなる。障害対応の修羅場を潜るたびに、次はより冷静に、より的確に対処できるようになる。この差は時間とともに広がっていく。反脆弱性―不確実な世界を生き延びる唯一の考え方　上下巻セットダイヤモンド社Amazonなぜ身銭を切るべきなのか意思決定の質が根本的に変わる身銭を切ると、判断基準が変わる。「この技術選定で失敗したら、自分が休日返上で修正することになる」と思えば、流行りに飛びつくことはない。「このアーキテクチャで3年運用することになる」と覚悟すれば、適当な設計はしない。他人事の意思決定は雑になる。自分事の意思決定は精緻になる。これは能力の問題ではなく、身銭を切っているかどうかの問題だ。不確実性に満ちた開発現場で、「絶対大丈夫」などと言えるはずがない。身銭を切る者は、その不確実性を正直に伝え、リスクヘッジの方法も含めて提案する。なぜなら、想定外のことが起きたとき、対処するのは自分だからだ。スタッフエンジニア　マネジメントを超えるリーダーシップ作者:Will Larson日経BPAmazon学習曲線が急激に立ち上がる「痛みは最高の教師」という言葉がある。マニュアルを100回読んでも身につかないことが、一度の失敗で骨身に染みる。深夜3時、本番環境が止まり、冷や汗をかきながらログを追う。その時に学ぶシステムの挙動は、二度と忘れない。身銭を切らない学習は表層的だ。カンファレンスで聞いた話、ブログで読んだベストプラクティス。知識としては持っているが、判断の瞬間には出てこない。痛みを伴わない知識は、実戦では使えない。実際に痛い目を見た経験が、次の「嫌な予感」を生む。この直感こそが、重大な障害を未然に防ぐ最後の砦となる。プロフェッショナルとして認められる医者が「手術は失敗したけど、僕のせいじゃない」と言ったらどう思うか。パイロットが「墜落したけど、マニュアル通りに操縦した」と言ったらどう思うか。エンジニアも同じだ。「仕様通りに作った」「指示された通りに実装した」。これは素人の言い訳だ。プロは結果に責任を持つ。だからこそ、プロの意見には重みがあり、プロの判断は尊重される。身銭を切らないエンジニアは、いつまでも「作業者」として扱われる。身銭を切るエンジニアだけが、真の意味で「エンジニア」として認められる。そして興味深いことに、本物のプロフェッショナルほど、見た目や肩書きにこだわらない。結果で証明するからだ。本物の自信が身につく身銭を切って成功した経験、失敗から立ち直った経験。これらが積み重なって、揺るぎない自信になる。「あの時、全責任を負って新技術を導入した」「大規模リファクタリングを主導して成功させた」「致命的な障害を起こしたが、そこから這い上がった」。これらの経験が、次の挑戦への勇気になる。会社や上司に守られた成功体験は、環境が変われば消える。しかし、身銭を切って得た自信は、どこに行っても通用する。それが、市場価値になる。信頼という最大の資産を得る身銭を切り続けるエンジニアは、長期的に最も価値のある資産——信頼——を獲得する。「あの人が言うなら大丈夫」「あの人に任せれば安心」。この信頼は、一朝一夕では築けない。小さな約束を守り、失敗したら素直に認め、責任を持って対処する。その積み重ねが信頼となる。皮肉なことに、身銭を切らずに「うまくやった」つもりのエンジニアほど、長期的には信頼を失う。短期的な成功と引き換えに、最も大切な資産を失っているのだ。その仕事、全部やめてみよう――１％の本質をつかむ「シンプルな考え方」作者:小野 和俊ダイヤモンド社Amazon組織における身銭の力少数決原理とは組織の意思決定は多数決で行われると思われがちだが、実際は違う。重要な決定は「少数決原理」に従う。これは、最も失うものが大きい人、つまり最も身銭を切っている人の意見が採用される、という原理だ。例を挙げよう。レストランを選ぶとき、10人中9人が「何でもいい」と言い、1人だけがベジタリアンだったら、ベジタリアン対応のレストランが選ばれる。なぜか？ベジタリアンにとって「肉を食べる」ことのコストは、他の9人が「野菜を食べる」ことのコストより遥かに高いからだ。ソフトウェア開発における少数決原理この原理はソフトウェア開発でも働く。深夜対応を覚悟しているエンジニアが「このシステムは危険だ」と言えば、その声は無視できない。なぜなら、実際に深夜に呼び出されるのは彼だからだ。一方、無責任で言われたことだけやるエンジニアが「大丈夫でしょう」と言っても、その言葉に重みはない。セキュリティインシデントが起きたとき、責任を取ると宣言したエンジニアの「この対策では不十分」という意見は通る。日頃から「僕は関係ない」という態度のエンジニアがいくら正論を述べても、聞き流される。なぜ少数決原理が機能するのか身銭を切る者は、失敗したときのダメージが大きい。だから、彼らの反対意見には切実さがある。「このままでは本当にまずい」という危機感が、組織を動かす。また、身銭を切る者は信頼される。過去に責任を取ってきた実績があるから、その判断は尊重される。「あの人が言うなら」という信頼が、少数意見を多数意見に変える。身銭を切らない者がいくら集まっても、一人の身銭を切る者には勝てない。なぜなら、前者は失敗しても逃げられるが、後者は逃げられないからだ。逃げられない者の必死さが、組織の方向を決める。健全な組織文化への影響少数でも身銭を切るエンジニアがいれば、組織文化は変わり始める。彼らの姿勢は、周囲に伝播する。「あの人がそこまで言うなら、自分も真剣に考えよう」という空気が生まれる。責任を取る姿勢が、チーム全体の当事者意識を高める。逆に、誰も身銭を切らない組織では、意思決定が遅れ、責任の所在が曖昧になり、同じ失敗を繰り返す。最終的には、優秀なエンジニアから去っていく。身銭を切る文化があるかどうかが、組織の命運を分ける。失敗できる組織作者:エイミー C エドモンドソン早川書房Amazonまとめ偉そうなことを書いてきたが、私も完璧ではない。逃げたくなることもある。「これは自分の仕事じゃない」と思うこともある。でも、そんなときこそ思い出す。プロフェッショナルとは何か。小さなことから始めればいい。自分が担当しているサービスの本番データを毎日見る。障害が起きたら、担当外でも飛び込む。「この仕様は良くない」と思ったら、代替案を提示する。そして、その結果に責任を持つ。身銭を切るとは、華々しいことではない。地味で、苦しくて、割に合わないことも多い。でも、振り返ったときに胸を張れる。「あのシステムは、俺が守った」「あの障害は、俺が未然に防いだ」それが、エンジニアとしての誇りだと、私は思う。こういうマインドは先達から学んできたわけですが、書籍で言うと『達人プログラマー』などはとても良い本なのでオススメです。達人プログラマー ―熟達に向けたあなたの旅― 第2版作者:David Thomas,Andrew Huntオーム社Amazonただし、ここで大切な前提を伝えておきたい。人生は仕事だけではない。身銭を切ることと、自己犠牲は違う。エンジニアの努力を正当に評価しない経営者の下で働いているなら、構造的に身銭を切っても報われない環境にいるなら、無理をする必要はない。自分の健康と人生を守ることが最優先だ。もちろん、私の主張には論理的な飛躍もあることは認めざるを得ない。「身銭を切らないから無責任」という単純な因果関係では説明できない複雑さが、現実にはある。権限なき責任を押し付けられる構造、短期的な成果を求める経営圧力——これらを個人の覚悟だけで解決できるわけではない。だからこそ、個人の責任感と組織の構造改革は、車の両輪のように進めていく必要がある。適切な権限と責任のバランス、専門家として意見を言える環境、失敗から学習できる仕組み。これらなしに、個人の覚悟だけに頼るのは持続可能ではない。それでも、まずは身銭の切り方を知らなければ、「ここは踏ん張りどころか、それとも撤退すべきか」という判断すらできない。プロフェッショナルとしての基準を持っていなければ、搾取と成長機会の区別もつかない。だから、あくまでも一人のエンジニアの意見として、この考えを表明した。完璧な答えではないし、すべての状況に当てはまるわけでもない。あなたの環境、あなたの状況に応じて、取捨選択してもらえればと思う。身銭を切ることで得られるのは、単なる技術力ではない。判断力、直感、信頼、そして何より「自分はエンジニアとして真っ当に生きている」という確信だ。強いビジネスパーソンを目指して鬱になった僕の 弱さ考作者:井上 慎平ダイヤモンド社Amazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ACPでAgentに行動させる]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/09/22/094533</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/09/22/094533</guid>
            <pubDate>Mon, 22 Sep 2025 00:45:33 GMT</pubDate>
            <content:encoded><![CDATA[はじめにこんにちは！今回は、コードエディタや各種開発ツールとAIエージェント間の通信を標準化する Agent Client Protocol (ACP) について、その内部実装と実践的な使用方法を詳しく解説します。github.com最近の界隈では、Model Context Protocol（MCP）が大きな注目を集めていますが、その陰で着実に重要性を増している技術があります。それがACPです。MCPのような華やかさはないものの、実際にエディタプラグインやコーディングエージェントを開発する際には、ACPの理解が不可欠になってきています。なお、ACPを理解する前提としてMCPの基礎知識があると理解が深まります。MCPについては以下の記事で詳しく解説していますので、ぜひ参照してください。syu-m-5151.hatenablog.comまた、みのるんさんから献本いただいたこちらの書籍も、MCPの入門書として非常に参考になりました。実践的な内容が分かりやすくまとめられており、おすすめです。やさしいMCP入門作者:御田稔,大坪悠秀和システムAmazon同名のスライドでも良いのでMCPがわからない人は触れておくと良いと思います。 speakerdeck.comコード開発におけるAI支援ツールが急速に普及する中、実はエディタとAIツールの間には興味深い技術的課題が潜んでいます。それは、エディタごとに個別対応が必要で、使いたいツールの組み合わせが制限されるという問題です。正直なところ、多くの開発者はCopilotやCursorなどの既製品で満足しているでしょうし、この問題を意識することもないかもしれません。しかし、エディタプラグインを自作したい人や独自のAIエージェントを開発したい人、あるいは技術的な仕組みに興味がある人にとって、ACPは実に興味深い技術です。「エディタとAIエージェント間のLSP」として機能するこのプロトコルは、知らなくても困らないけれど、知っていると開発の可能性が大きく広がる、そんな技術と言えるでしょう。本記事では、このややマニアックながらも将来性のあるACPの実装詳細を通じて、プロトコル設計の面白さや、Rustによる非同期通信の実装テクニックなど、技術的に興味深いポイントを深掘りしていきます。ACPとは何か？記事を始める前に、まず ACP (Agent Client Protocol) について簡単に説明しましょう。ACP についてより詳しい情報は、公式GitHubリポジトリ や公式サイトを参照してください。ACPは、Zed Industriesが開発したオープンソースの標準プロトコルで、コードエディタとAIコーディングエージェント間の通信を標準化します。Language Server Protocol（LSP）がプログラミング言語サーバーの統合を革命的に変えたように、ACPは「LSPのAIエージェント版」として、AIツールの統合に同様の変革をもたらすことを目指しています。agentclientprotocol.comACPの仕組みACP は基本的に JSON-RPC 2.0 ベースのプロトコルで、主要な構成要素は以下のとおりです。クライアント（Client）：コードエディタ（Zed、Neovim など）エージェント（Agent）：AIコーディング支援プログラム（Claude Code、Gemini CLI など）セッション（Session）：会話の単位、複数のセッションを並行して管理可能エージェントはエディタのサブプロセスとして実行され、標準入出力（stdin/stdout）を通じて通信を行います。agentclientprotocol.comACPとMCPの関係ACPの技術仕様において重要なのは、Model Context Protocol（MCP）との関係です。MCPは、LLMが外部サービスやローカルリソースにアクセスするためのプロトコルです。ACPは可能な限りMCPの型を再利用し、エディタが既存のMCPサーバー設定を持つ場合、その設定をエージェントに渡すことができます。agentclientprotocol.com{  "mcpServers": {    "filesystem": {      "command": "npx",      "args": ["-y", "@modelcontextprotocol/server-filesystem"],      "env": {        "ALLOWED_PATHS": "/path/to/project"      }    }  }}JSON-RPC の基本ACP は JSON-RPC 2.0 仕様に基づいており、以下の3種類のメッセージ形式が使われます。agentclientprotocol.comリクエスト：クライアントからエージェントへの要求{  "jsonrpc": "2.0",  "id": 1,  "method": "prompt",  "params": {    "sessionId": "session-123",    "prompt": [{"type": "text", "text": "Hello Agent!"}]  }}レスポンス：エージェントからクライアントへの応答{  "jsonrpc": "2.0",  "id": 1,  "result": {    "stopReason": "endTurn",    "meta": null  }}通知：レスポンスを必要としない一方向メッセージ{  "jsonrpc": "2.0",  "method": "session/notification",  "params": {    "sessionId": "session-123",    "update": {      "type": "agentMessageChunk",      "content": {"type": "text", "text": "Processing..."}    }  }}Rustで実装するACPの詳細解説それでは、実際のRustコードを通じてACPの動作原理を深く理解していきましょう。公式リポジトリの実装例（agent.rsとclient.rs）を詳しく解説します。agentclientprotocol.com実装の準備と実行まず、ACPの実装を実際に動かすための手順を確認しましょう：# リポジトリのクローンgit clone https://github.com/zed-industries/agent-client-protocolcd agent-client-protocol/rust# エージェントのビルドRUST_LOG=info cargo build --example agent# クライアントの実行（エージェントを自動起動）cargo run --example client -- ../target/debug/examples/agent# 実行時の対話例> Hello, Agent!| Agent: Client sent: Hello, Agent!> How can you help me with coding?| Agent: Client sent: How can you help me with coding!この実行により、以下の通信フローが発生します。初期化フェーズ: プロトコルバージョンのネゴシエーションセッション確立: 作業ディレクトリとMCPサーバー設定の共有メッセージループ: プロンプトの送信と応答のストリーミンググレースフルシャットダウン: プロセス終了時のリソースクリーンアップエージェント側の実装（agent.rs）基本構造とトレイト実装use std::cell::Cell;use agent_client_protocol::{    self as acp, AuthenticateResponse, Client, ExtNotification,     ExtRequest, ExtResponse, SessionNotification, SetSessionModeResponse,};use tokio::sync::{mpsc, oneshot};struct ExampleAgent {    session_update_tx: mpsc::UnboundedSender<(acp::SessionNotification, oneshot::Sender<()>)>,    next_session_id: Cell<u64>,}構造体の設計思想：session_update_tx：非同期チャネルの送信側で、セッション更新をバックグラウンドタスクに送信next_session_id：Cell<u64>による内部可変性パターンで、&selfの不変参照でも値を更新可能ACPトレイトの実装#[async_trait::async_trait(?Send)]impl acp::Agent for ExampleAgent {    async fn initialize(        &self,        arguments: acp::InitializeRequest,    ) -> Result<acp::InitializeResponse, acp::Error> {        log::info!("Received initialize request {arguments:?}");        Ok(acp::InitializeResponse {            protocol_version: acp::V1,            agent_capabilities: acp::AgentCapabilities::default(),            auth_methods: Vec::new(),            meta: None,        })    }重要なポイント：async_trait(?Send)：非Sendなfutureを許可し、LocalSet環境での実行を可能にプロトコルバージョンの明示的な宣言ケイパビリティ交換による機能のネゴシエーションセッション管理async fn new_session(    &self,    arguments: acp::NewSessionRequest,) -> Result<acp::NewSessionResponse, acp::Error> {    log::info!("Received new session request {arguments:?}");    let session_id = self.next_session_id.get();    self.next_session_id.set(session_id + 1);    Ok(acp::NewSessionResponse {        session_id: acp::SessionId(session_id.to_string().into()),        modes: None,        meta: None,    })}セッションの概念：各セッションは独立した会話コンテキストMCPサーバー設定の引き継ぎ作業ディレクトリの設定プロンプト処理とストリーミングasync fn prompt(    &self,    arguments: acp::PromptRequest,) -> Result<acp::PromptResponse, acp::Error> {    log::info!("Received prompt request {arguments:?}");        for content in ["Client sent: ".into()].into_iter().chain(arguments.prompt) {        let (tx, rx) = oneshot::channel();                // セッション更新の非同期送信        self.session_update_tx            .send((                SessionNotification {                    session_id: arguments.session_id.clone(),                    update: acp::SessionUpdate::AgentMessageChunk { content },                    meta: None,                },                tx,            ))            .map_err(|_| acp::Error::internal_error())?;                // バックプレッシャー制御        rx.await.map_err(|_| acp::Error::internal_error())?;    }        Ok(acp::PromptResponse {        stop_reason: acp::StopReason::EndTurn,        meta: None,    })}ストリーミング設計：チャンク単位でのメッセージ送信oneshot::channel()による同期制御バックプレッシャーによる流量制御メインループとタスク管理メインループは、非同期ランタイムの中核部分であり、実際にエージェントが起動される場所です。#[tokio::main(flavor = "current_thread")]async fn main() -> anyhow::Result<()> {    env_logger::init();  // RUST_LOG環境変数でログレベルを制御    let outgoing = tokio::io::stdout().compat_write();    let incoming = tokio::io::stdin().compat();    let local_set = tokio::task::LocalSet::new();    local_set        .run_until(async move {            let (tx, mut rx) = tokio::sync::mpsc::unbounded_channel();                        // エージェント接続の確立            let (conn, handle_io) = acp::AgentSideConnection::new(                ExampleAgent::new(tx),                 outgoing,                 incoming,                 |fut| {                    tokio::task::spawn_local(fut);                }            );                        // セッション通知処理タスク            tokio::task::spawn_local(async move {                while let Some((session_notification, tx)) = rx.recv().await {                    let result = conn.session_notification(session_notification).await;                    if let Err(e) = result {                        log::error!("{e}");                        break;                    }                    tx.send(()).ok();                }            });                        handle_io.await        })        .await}非同期ランタイムの設計：LocalSet：シングルスレッド実行環境（current_threadフレーバーと連携）spawn_local：非Sendタスクの実行チャネルによるタスク間通信RUST_LOG=info環境変数でログ出力を制御（デバッグ時はRUST_LOG=debug）クライアント側の実装（client.rs）プロセス管理とライフサイクルクライアントは、エージェントをサブプロセスとして起動し管理します。実行時はコマンドライン引数でエージェントのパスを指定します：# 実行例：ビルド済みのエージェントを指定cargo run --example client -- target/debug/examples/agent#[tokio::main(flavor = "current_thread")]async fn main() -> anyhow::Result<()> {    let command = std::env::args().collect::<Vec<_>>();    let (outgoing, incoming, child) = match command.as_slice() {        [_, program, args @ ..] => {            let mut child = tokio::process::Command::new(program)                .args(args.iter())                .stdin(std::process::Stdio::piped())                .stdout(std::process::Stdio::piped())                .kill_on_drop(true)  // 自動クリーンアップ                .spawn()?;                        (                child.stdin.take().unwrap().compat_write(),                child.stdout.take().unwrap().compat(),                child,            )        }        _ => bail!("Usage: client AGENT_PROGRAM AGENT_ARG..."),    };プロセス管理のベストプラクティス：kill_on_drop(true)：親プロセス終了時の自動クリーンアップ（孤児プロセスを防ぐ）ストリーム所有権の明示的な管理（take()メソッド）エラー時のグレースフルシャットダウンエージェントプログラムへの引数の柔軟な受け渡しプロトコル初期化// 接続の確立let (conn, handle_io) = acp::ClientSideConnection::new(    ExampleClient {},     outgoing,     incoming,     |fut| {        tokio::task::spawn_local(fut);    });// バックグラウンドI/O処理tokio::task::spawn_local(handle_io);// 初期化ハンドシェイクconn.initialize(acp::InitializeRequest {    protocol_version: acp::V1,    client_capabilities: acp::ClientCapabilities::default(),    meta: None,}).await?;// セッション作成let response = conn    .new_session(acp::NewSessionRequest {        mcp_servers: Vec::new(),  // MCPサーバー設定        cwd: std::env::current_dir()?,        meta: None,    })    .await?;対話的REPLの実装Rustylineを使用した対話的インターフェースにより、ユーザーはエージェントと直接対話できます：// Rustylineによる対話インターフェースlet mut rl = rustyline::DefaultEditor::new()?;while let Ok(line) = rl.readline("> ") {    let result = conn        .prompt(acp::PromptRequest {            session_id: response.session_id.clone(),            prompt: vec![line.into()],            meta: None,        })        .await;        if let Err(e) = result {        log::error!("{e}");    }}REPLの動作例：> Hello, Agent!| Agent: Client sent: Hello, Agent!> What's the weather like?| Agent: Client sent: What's the weather like?> exitRustylineの利点：履歴管理（上下矢印キーで過去の入力を参照）カーソル移動とテキスト編集機能Ctrl+C/Ctrl+Dによる適切な終了処理将来的な自動補完機能の追加が可能セッション通知の処理#[async_trait::async_trait(?Send)]impl acp::Client for ExampleClient {    async fn session_notification(        &self,        args: acp::SessionNotification,    ) -> anyhow::Result<(), acp::Error> {        match args.update {            acp::SessionUpdate::AgentMessageChunk { content } => {                let text = match content {                    acp::ContentBlock::Text(text_content) => text_content.text,                    acp::ContentBlock::Image(_) => "<image>".into(),                    acp::ContentBlock::Audio(_) => "<audio>".into(),                    acp::ContentBlock::ResourceLink(resource_link) => resource_link.uri,                    acp::ContentBlock::Resource(_) => "<resource>".into(),                };                println!("| Agent: {text}");            }            acp::SessionUpdate::ToolCall(tool_call) => {                println!("| Tool call: {}", tool_call.name);            }            acp::SessionUpdate::Plan(plan) => {                println!("| Plan: {}", plan.description);            }            _ => {}        }        Ok(())    }エラーハンドリングとプロトコルの堅牢性タイムアウトとリトライの実装use tokio::time::{timeout, Duration};async fn prompt_with_timeout(    conn: &ClientSideConnection,    request: PromptRequest,    timeout_secs: u64,) -> Result<PromptResponse, Error> {    match timeout(        Duration::from_secs(timeout_secs),        conn.prompt(request)    ).await {        Ok(Ok(response)) => Ok(response),        Ok(Err(e)) => {            log::error!("Prompt error: {}", e);            Err(e)        }        Err(_) => {            log::error!("Prompt timeout after {} seconds", timeout_secs);            Err(Error::request_timeout())        }    }}エクスポネンシャルバックオフasync fn reconnect_with_backoff(    max_retries: u32,) -> Result<Connection, Error> {    let mut delay = Duration::from_secs(1);        for attempt in 1..=max_retries {        match establish_connection().await {            Ok(conn) => {                log::info!("Connected on attempt {}", attempt);                return Ok(conn);            }            Err(e) if attempt < max_retries => {                log::warn!("Attempt {} failed: {}", attempt, e);                tokio::time::sleep(delay).await;                delay *= 2;  // エクスポネンシャルバックオフ            }            Err(e) => return Err(e),        }    }        Err(Error::max_retries_exceeded())}実践的な統合例Claude Code ACPの設定Claude Code ACP は、AnthropicのClaude AIをACPプロトコル経由で利用可能にする実装です。github.com{  "agent_servers": {    "Claude Code": {      "command": "npx",      "args": ["@zed-industries/claude-code-acp"],      "env": {        "ANTHROPIC_API_KEY": "your-api-key",        "ACP_PERMISSION_MODE": "acceptEdits"      }    }  }}Avante.nvimの設定Avante.nvim は、NeovimでACPを利用するための実装です。github.com{  "yetone/avante.nvim",  event = "VeryLazy",  build = "make",  opts = {    provider = "claude",    mode = "agentic",    acp_providers = {      ["claude-code"] = {        command = "npx",        args = { "@zed-industries/claude-code-acp" },        env = { ANTHROPIC_API_KEY = os.getenv("ANTHROPIC_API_KEY") }      }    }  }}ccswarm での実装筆者が開発している ccswarm プロジェクトでは、当初は独自の仮想ターミナル実装を使用していましたが、ACPの登場を機に、より標準化されたアプローチへの移行を決定しました。github.comセキュリティに関する考慮事項ACPを使用する際には、以下の点に注意が必要です。ACPのセキュリティリスク作っていて思ったのですが、ACPはエージェントにローカル環境への強いアクセス権を付与するので、本質的にセキュリティ上の懸念があります：サードパーティエージェントのリスク: 信頼できない「野良エージェント」をインストールすると、マルウェアや情報漏洩のリスクが高まります権限の過剰付与: エージェントが必要以上の権限を持つと、システムリソースへの不正アクセスの可能性がありますデータ漏洩のリスク: ローカルファイルやクレデンシャルなどの機密情報が、エージェントを通じて外部に漏洩する可能性がありますプロンプトインジェクション攻撃: 悪意あるプロンプトを通じて、エージェントに予期しない操作を実行させるリスクがあります安全なACP利用のための対策信頼できるソースからのみエージェントをインストール: 公式リポジトリや信頼できる開発者からのエージェントのみを使用最小権限の原則を適用: エージェントには必要最小限の権限のみを付与サンドボックス環境での実行: 可能であれば、エージェントを隔離された環境で実行監査ログの有効化: エージェントを通じて実行されたすべてのコマンドや操作を記録機密情報のフィルタリング: APIキーやパスワードなどの機密情報を検出・削除するメカニズムを実装定期的なセキュリティレビュー: エージェントの設定やコードを定期的にレビュー確実なテストの実行: 本番環境に導入する前に、テスト環境で動作を徹底的に検証ACPのメリットと今後の展望開発者にもたらす価値ベンダーロックインからの解放: どのACP対応エディタでも、どのACP対応エージェントでも使用可能開発効率の向上: 統一されたプロトコルにより、新しいAIエージェントの導入が簡単にエコシステムの成長: 標準化により、開発者はそれぞれの得意分野に集中可能実践的な活用シナリオ大規模リファクタリング: プロジェクト全体の構造改善バグ修正フロー: エラー解析から修正まで一貫した支援コードレビュー自動化: セキュリティや品質の包括的チェックプロジェクト横断的な分析: アーキテクチャレベルの改善提案おわりにAgent Client Protocolは、AIコーディング支援ツールの統合における新たな標準として、着実に開発者コミュニティで採用が進んでいます。MCPが大きな話題を集めた一方で、ACPはそこまで注目を浴びていないかもしれません。しかし、エディタ開発者やコーディングエージェントを実装したい開発者にとって、ACPは極めて実用的で学ぶ価値の高い技術です。本記事で詳しく解説したRustの実装例は、ACPの設計思想を理解し、独自のエージェントを開発するための出発点となるでしょう。特に注目すべきは、Rustの所有権システムとACPの非同期通信モデルが見事に調和している点です。LocalSetによる非Sendなfutureの処理、mpscとoneshotチャネルを組み合わせた確実な通信、kill_on_dropによる安全なプロセス管理など、これらの技術的選択は、堅牢で効率的なACP実装の基礎となります。ACPの魅力は、JSON-RPCベースのシンプルなプロトコル設計により、数百行のコードで基本的なエージェントを実装できる敷居の低さにあります。一度ACPに対応すれば、Zed、Neovim、その他のACP対応エディタですぐに利用可能になり、独自のコーディングアシスタントやドメイン特化型エージェントの開発も容易になります。エディタとAIエージェントの統合は今後も加速することが予想され、ACPの知識は長期的な資産となるでしょう。一般的な開発者にとって重要なのは、ACPが派手さはないものの、日々のコーディング作業を着実に改善する実用的な基盤技術であるという点です。MCPのような革新的な印象はないかもしれませんが、LSPがそうであったように、気がつけば開発環境に不可欠な存在となっているでしょう。特に、独自のエディタプラグインやAIコーディングツールを開発したいと考えている方は、ぜひACPの仕様を学び、実装してみることをお勧めします。この標準化されたプロトコルは、あなたのツールを幅広いエコシステムに接続する架け橋となるはずです。参考リソースAgent Client Protocol GitHubリポジトリACP 公式ドキュメントClaude Code ACP実装Avante.nvim プロジェクトModel Context ProtocolJSON-RPC 2.0 仕様zed.dev]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[claude codeにtesseract書かせてみた]]></title>
            <link>https://zenn.dev/akasan/articles/8ac71d6cc3057a</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/8ac71d6cc3057a</guid>
            <pubDate>Sun, 21 Sep 2025 11:09:13 GMT</pubDate>
            <content:encoded><![CDATA[今回はclaude codeに作らせたシリーズの続編です。前回は3次元のフラクタル図形を書かせてみましたが、今回はtesseractを書かせてみました。https://zenn.dev/akasan/articles/f90c2940cf1ef3 tesseractとは？Wikipediaによると、正八胞体（せいはちほうたい、または四次元超立方体、英語: 8-cell、オクタコロン〈英: octachoron〉、テッセラクト〈英: tesseract、テセラクトとも〉）とは、四次元正多胞体の一種で8個の立方体からなる、四次元の超立方体である。とのことです。自分の認識では4...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[モジュールを意識したTerraform構成でColabのテンプレートを作成してみた]]></title>
            <link>https://zenn.dev/akasan/articles/9c48ed7e2457a6</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/9c48ed7e2457a6</guid>
            <pubDate>Sat, 20 Sep 2025 09:15:40 GMT</pubDate>
            <content:encoded><![CDATA[今回は、昨日公開したColab Enterpriseのテンプレート作成のTerraformをモジュールを意識した構成で実装してみます。今までの記事ではルートディレクトリだけでmain.tfやvariables.tfを管理していましたが、実際に利用するときはモジュールを意識した構成が必要になるので、今回からその構成を意識して実装します。https://zenn.dev/akasan/articles/2966eb1a9f9a38 ディレクトリ構成今回は以下の構成でディレクトリを編成しました。main.tfvariables.tfmodules/  colab-templat...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[クラウド環境におけるシークレットの扱い]]></title>
            <link>https://blog.masasuzu.net/entry/2025/09/19/203626</link>
            <guid isPermaLink="false">https://blog.masasuzu.net/entry/2025/09/19/203626</guid>
            <pubDate>Fri, 19 Sep 2025 11:36:26 GMT</pubDate>
            <content:encoded><![CDATA[この内容は、社内のエンジニア勉強会で話した内容です。 speakerdeck.comみなさん。プロダクション環境のシークレット情報をどう扱っていますか?クラウドネイティブなアプリケーション開発において、DBのパスワードや外部APIキーといったシークレットの管理は、セキュリティを確保する上で避けては通れない課題です。この記事では、アプリケーションとインフラそれぞれの視点から、クラウド環境におけるシークレット管理のアンチパターンとベストプラクティスを探っていきます。ここで言うシークレットとはDBのパスワードやAPIキーなどの秘匿すべき情報のことを指します。アプリケーション側の視点まずは、アプリケーションがどのようにシークレットを扱うべきかを見ていきましょう。管理のアンチパターン最初に管理方法のアンチパターンとしては以下のものがありますソースコードに直接記述設定ファイルに平文で記述環境変数に平文で記述(Dockerfileや.envファイルでgit管理するなど)base64エンコードして保存ソースコードに記述すれば、すべての環境で同じ値しか使えず柔軟性がありません。設定ファイルや環境変数に平文で記述し、それをGitで管理してしまうと、何かのミスでリポジトリが流出した際にシークレットも漏れてしまいます。また、隠しているつもりでBase64エンコードするのも同様に危険です。Base64は暗号化ではなく、誰でも簡単に元の文字列に戻せるため、平文で保存しているのと大差ありません。KMSによる暗号化の検討次に考えられるのが、暗号鍵を使った暗号化です。AWSのKMSやGoogle CloudのCloud KMSといった鍵管理サービスを利用する方法が考えられます。フローとしては以下のようになりますでしょうかアプリケーション起動時にKMSのから鍵を取得取得した鍵を利用して暗号化されたシークレットを復号平文のシークレット情報をアプリで利用する一見これで良さそうですが、復号処理をアプリケーションの責務にすると、コードが複雑になるだけでなく、KMSの復号権限をアプリケーション自体に付与する必要があり、管理の懸念点が増えてしまいます。クラウド側のシークレットストアの利用そこで推奨されるのが、クラウドが提供するシークレット管理の仕組みを利用することです。AWSAWS Secrets ManagerAWS Systems Manager Parameter Store(SecureString)Google CloudSecret Managerこれらのサービスは、ECS FargateやCloud Runなどのコンテナ実行環境と統合されています。コンテナの起動時に、これらのストアに保存されたシークレットを、自動的に環境変数やファイルとしてマウントしてくれるのです。これによりアプリケーション側では、シークレットがどこで管理されているかを意識することなく、従来通り環境変数やファイルから値を読み込むだけで済むようになり、責務をシンプルに保つことができます。インフラ側の視点さて、アプリケーションの課題は解決しました。次に、インフラ側で、そのシークレットストアをどう管理するかという課題に移りましょう。取れる手段としては主に以下ものが考えられます。手動でコンソールから設定シークレットの値を平文でIaC管理(tfvarsファイルをgit管理から外す)シークレットの値を暗号化してIaCで管理シークレットストアをIaCで管理、値は手動設定まず手動で管理ですが、これはこれでありだと思ってます。ただし、扱うシークレットの数が増えてきたときに作業が煩雑であったり、手作業がゆえに起こるリソースタグなどの付け間違いなどのミスが発生しうるので、規模が大きくなると現実的ではありません。2つ目ですが、シークレットの値だけあつかるtfvarsファイルをgitignoreしてあげることでレポジトリが漏れてもシークレットの値が漏れないことになります。が、うっかりシークレットの値を人為的なミスでコミットしうるので完全に安全とはいいにくいです。3つ目ですが、これはsops providerを利用するパターンです。これを使うことでKMSキーを利用して暗号/復号がterraformとシームレスに統合できます。一見これで良さそうですが、2点課題があります。KMSリソースを余計に管理なくてはならないStateには平文で保存される前者は必要経費としていいとして、後者は課題となります。Terraformにおいてはstateを見る権限がある人にはシークレットも見れてしまうという懸念があります。シークレットのリソースと値を分離するこの方法の利点は、IaCでシークレット リソースが存在することは管理しつつ、その実際の値はGitの管理下から完全に分離できる点です。初回適用後にコンソールから実際のシークレット値を設定すれば、それ以降 terraform apply を実行しても値がダミー値で上書きされることはありません。これにより、コードレビューなどで誤ってシークレットが漏洩するリスクを原理的に防ぐことができ、非常にバランスの取れた管理方法と言えます。以下サンプルコードです。resource "aws_ssm_parameter" "db_password" {  type     = "SecureString"  name     = "/test/db_password"  value    =  "Dummy"  lifecycle {    ignore_changes = [value]  }}まとめ現時点でのクラウドにおけるシークレット管理のベストプラクティスは、以下のようにまとめることができるでしょう。アプリケーションクラウドのシークレットストア(Secrets Managerなど)と実行環境(ECS, Cloud Runなど)の統合機能を使い、環境変数またはファイルとしてシークレットを読み込む。インフラ(IaC)クラウドのシークレットストアのリソース自体はTerraformで管理する。実際のシークレットの値は ignore_changes を活用して手動で設定し、Gitの管理から分離する。もちろん要件によって取りうる手段は変わるとは思います。他になにか良い方法をご存知でしたら教えて下さい。それでは良いシークレットライフを!関連ページblog.masasuzu.net]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Colab EnterpriseのランタイムテンプレートをTerraformで作る方法について]]></title>
            <link>https://zenn.dev/akasan/articles/2966eb1a9f9a38</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/2966eb1a9f9a38</guid>
            <pubDate>Fri, 19 Sep 2025 04:12:08 GMT</pubDate>
            <content:encoded><![CDATA[今回はVertex AIのColab EnterpriseのランタイムテンプレートをTerraformで記述してみました。以前コンソールからランタイムテンプレートを作ったことはありましたが、今回はその設定をTerraformで再現してみようと思います。以前の該当記事は以下になるので、ぜひ合わせてご覧ください。https://zenn.dev/akasan/articles/454f57beb383e9Google CloudでTerraformを試してみた系は以下のスクラップにまとめていますので合わせてご覧ください！https://zenn.dev/akasan/scraps/c6...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2025-09-19 クラウドにおけるシークレット管理]]></title>
            <link>https://speakerdeck.com/masasuzu/2025-09-19-kuraudoniokerusikuretutoguan-li</link>
            <guid isPermaLink="false">https://speakerdeck.com/masasuzu/2025-09-19-kuraudoniokerusikuretutoguan-li</guid>
            <pubDate>Fri, 19 Sep 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[スリーシェイク社内のエンジニア勉強会で発表した資料クラウドにおいてプロダクション環境でのシークレットの扱い方についてアプリケーションおよびインフラ側でどう管理していくのが望ましいかを詳解]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vertex AI Feature Storeの機能グループをTerraformで作る方法について]]></title>
            <link>https://zenn.dev/akasan/articles/3954f50f913bae</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/3954f50f913bae</guid>
            <pubDate>Thu, 18 Sep 2025 04:55:06 GMT</pubDate>
            <content:encoded><![CDATA[今回はVertex AIのFeature Storeの機能グループをTerraformから作成する方法について調べてみました。機能グループを利用するにはバックエンドとなるBigQueryデータセットの作成が必要であり、これら二つのリソースの作成をしてみます。Google CloudでTerraformを試してみた系は以下のスクラップにまとめていますので合わせてご覧ください！https://zenn.dev/akasan/scraps/c6182a7d763bc8 早速作ってみる！今回作成する機能グループについて、リソース定義は以下をベースに実施します。https://regi...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google CloudのサービスアカウントをTerraformで作る方法について]]></title>
            <link>https://zenn.dev/akasan/articles/b07c3ffab7f2ec</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/b07c3ffab7f2ec</guid>
            <pubDate>Wed, 17 Sep 2025 13:32:45 GMT</pubDate>
            <content:encoded><![CDATA[今回は、Google CloudのサービスアカウントをTerraformから作成する方法について調べてみました。最近K8sに加えてTerraformの学習もどんどん進めており、その勉強として今回はサービスアカウントを取り扱ってみます。Google CloudでTerraformを試してみた系は以下のスクラップにまとめていますので合わせてご覧ください！https://zenn.dev/akasan/scraps/c6182a7d763bc8 早速やってみる！ 変数の作成まずはGoogle CloudのプロジェクトIDやリージョンを設定するためにvariables.tfを以下の...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2025-08-05 Google Cloud Next Tokyo 2025 Cloud RunとCloud SQLの接続方式と事例]]></title>
            <link>https://speakerdeck.com/masasuzu/2025-08-05-google-cloud-next-tokyo-2025-cloud-runtocloud-sqlnojie-sok-fang-shi-toshi-li</link>
            <guid isPermaLink="false">https://speakerdeck.com/masasuzu/2025-08-05-google-cloud-next-tokyo-2025-cloud-runtocloud-sqlnojie-sok-fang-shi-toshi-li</guid>
            <pubDate>Wed, 17 Sep 2025 04:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Google CloudのModel ArmorのテンプレートをTerraformで記述してみた]]></title>
            <link>https://zenn.dev/akasan/articles/314b22ced3c9c1</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/314b22ced3c9c1</guid>
            <pubDate>Tue, 16 Sep 2025 13:11:02 GMT</pubDate>
            <content:encoded><![CDATA[今回はGoogle CloudのSecurity Command Centerで提供されているModel Armorについて、Terraformを利用してテンプレートを作成してみました。なお、内容については前回コンソール画面上で作成した設定を再現する形で実装してみます。https://zenn.dev/akasan/articles/7ce40551040ccc 早速実装してみる Model Armorのリソースについて今回は以下のgoogle_model_armor_templateを利用してModel Armorのテンプレートを実装します。https://registr...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[actでGithub ActionsのVibe Codingを加速させる]]></title>
            <link>https://speakerdeck.com/kojake_300/actdegithub-actionsnovibe-codingwojia-su-saseru</link>
            <guid isPermaLink="false">https://speakerdeck.com/kojake_300/actdegithub-actionsnovibe-codingwojia-su-saseru</guid>
            <pubDate>Tue, 16 Sep 2025 04:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Sreakeの英語ブログをはじめました！]]></title>
            <link>https://sreake.com/blog/enabling-en-blog/</link>
            <guid isPermaLink="false">https://sreake.com/blog/enabling-en-blog/</guid>
            <pubDate>Tue, 16 Sep 2025 01:00:00 GMT</pubDate>
            <content:encoded><![CDATA[こんにちは！ Sreake事業部のイリドリシ愛民 (@realaminevg) です。 2020年から継続してきたSreakeブログの運用経験を活かし、今月からSreakeの英語ブログ（Sreake English Bl […]The post Sreakeの英語ブログをはじめました！ first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rayシリーズ：Ray Coreを利用したバッチ予測例の検証]]></title>
            <link>https://zenn.dev/akasan/articles/e1501d2852e602</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/e1501d2852e602</guid>
            <pubDate>Mon, 15 Sep 2025 04:46:41 GMT</pubDate>
            <content:encoded><![CDATA[今回はRay Coreの例として提供されているバッチ予測のサンプルを通して、バッチ予測の実装方法をみていきたいと思います。Rayに関するシリーズは以下でまとめていますのでぜひご覧ください。https://zenn.dev/akasan/scraps/73a90764c065d1 早速例を試してみる今回は以下の例を試してみます。この例では、バッチで取得したデータを対象として、どのように推論を行うかを試す例となっております。https://docs.ray.io/en/latest/ray-core/examples/batch_prediction.html 環境構築uvを...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GoogleのセキュアAIフレームワークについて]]></title>
            <link>https://zenn.dev/akasan/articles/2b9291950d99ef</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/2b9291950d99ef</guid>
            <pubDate>Sun, 14 Sep 2025 04:16:27 GMT</pubDate>
            <content:encoded><![CDATA[今回はGoogleが提唱するセキュアAIフレームワークについて調べてみました。さまざまなAIが導入されている昨今、よりセキュアにAIシステムを運用できることが求められています。AIを案件で取り扱っている立場でもあるので、このフレームワークについて調べてみました。 セキュアAIフレームワークとは？Googleが提唱するセキュアAIフレームワーク（以下、SAIF）は、責任を持ってAIを開発し導入するための高いセキュリティ基準が求めらている状況に対して、システムをより安全に保護するための概念的なフレームワークとして提唱されました。https://safety.google/intl/j...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google Cloud 認定資格奮闘記 ~Professional Machine Learning Engineer編~]]></title>
            <link>https://zenn.dev/akasan/articles/062b9d9e44922a</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/062b9d9e44922a</guid>
            <pubDate>Sat, 13 Sep 2025 05:17:04 GMT</pubDate>
            <content:encoded><![CDATA[今回はGoogle Cloud認定資格の一つであるProfessional Machine Learning Engineer(以下、PMLE)を受験したのでその体験記になります。前回取得した資格についても記事にしているのでぜひご覧ください。https://zenn.dev/akasan/articles/c0d347a37065bc Professional Machine Learning EngineerについてPMLEはGoogle Cloudの認定資格の一つであり、特に機械学習に関するサービスおよびその取り扱い、実務への応用などについて問われる資格となります。PMLEで...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[claude codeに3次元のフラクタル図形書かせてみた]]></title>
            <link>https://zenn.dev/akasan/articles/f90c2940cf1ef3</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/f90c2940cf1ef3</guid>
            <pubDate>Fri, 12 Sep 2025 14:07:09 GMT</pubDate>
            <content:encoded><![CDATA[昨日は2次元のフラクタル図形をClaude Codeに作成させましたが、今回は3Dのフラクタル図形を作成させてみました。ぜひ昨日の記事もご覧ください。https://zenn.dev/akasan/articles/91d41376641ffc 早速やってみるまずは環境構築をします。uv init fractal_3d -p 3.12cd fractal_3duv add matplotlib numpy pillow今回claude codeに与えた指示は以下になります。pythonを使って、3次元のフラクタル図形を段階的に生成してアニメーションとして保存するコード...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイク、 Google Cloud Partner Advantage プログラムにおいて「Application Development」のスペシャライゼーション認定を取得]]></title>
            <link>https://sreake.com/blog/appdev_specialization/</link>
            <guid isPermaLink="false">https://sreake.com/blog/appdev_specialization/</guid>
            <pubDate>Fri, 12 Sep 2025 01:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Google Cloud Sell および Service エンゲージメントモデルのプレミアパートナーである株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）は、Google Cloud Partner Advantage プログラムにおいて、「Application Development - サービス」のスペシャライゼーション認定を取得したことをお知らせします。The post スリーシェイク、 Google Cloud Partner Advantage プログラムにおいて「Application Development」のスペシャライゼーション認定を取得 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
    </channel>
</rss>