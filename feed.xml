<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Fri, 06 Jun 2025 11:35:06 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[Oracle Database＠Google Cloudの紹介～ついに日本のリージョンも使えるようになったぞ！～]]></title>
            <link>https://sreake.com/blog/oracle-database-google-cloud-japan-launch/</link>
            <guid>https://sreake.com/blog/oracle-database-google-cloud-japan-launch/</guid>
            <pubDate>Fri, 06 Jun 2025 10:48:27 GMT</pubDate>
            <content:encoded><![CDATA[2025年4月のGoogle Cloud Nextでの発表から2か月、ついにOracle Database＠Google CloudがTokoy・Osakaリージョンで利用可能になりました。 Oracle Databas […]The post Oracle Database＠Google Cloudの紹介～ついに日本のリージョンも使えるようになったぞ！～ first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Claude Code の CLAUDE.mdは設定した方がいい]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/06/190847</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/06/190847</guid>
            <pubDate>Fri, 06 Jun 2025 10:08:47 GMT</pubDate>
            <content:encoded><![CDATA[※こちらは社内で発表したものを外部で公開できるように修正したものです。[社内共有版「Claude Code、どこまでも」]はじめに先日の記事に続いて、今回はCLAUDE.mdについて深掘りしたい。元々社内勉強会で利用したものを転用しました。syu-m-5151.hatenablog.com3ヶ月前、私は「生成AIといっしょ: 動作するきれいなコードを生成AIとつくる」という記事で、生成AIとテスト駆動開発を組み合わせて「動作するきれいなコード」を実現する方法について理論的に考察した。あの時点では、AIとの完全な協業はまだ概念的な話だった。私はまだ運転席に座っていた。syu-m-5151.hatenablog.comそして今、Claude Codeを使い始めて1週間。理論は現実となり、想像を超えた世界が広がっている。まずは、Claude MAXを契約してチュートリアルを試してみてほしい。docs.anthropic.comこの2週間でCLAUDE.mdこそが生産性向上の根幹だと確信した。3ヶ月前に描いた「助手席」での開発が、まさに現実のものとなっている。ちなみにまた、Anthropicの公式ドキュメントは最高なのでまたこちらを読んでください。www.anthropic.comCLAUDE.mdとは何かCLAUDE.mdは、Claude Codeが自動的にコンテキストに読み込む特別なファイルだ。プロジェクト固有の情報、規約、コマンドを記載することで、毎回の説明を省略できる。メモリファイルは3種類ある。まず、プロジェクトルート（./CLAUDE.md）に配置するプロジェクトメモリは、Git管理してチーム全体で共有する設定を記載する。プロジェクトアーキテクチャやコーディング規約、共通ワークフローなどがこれに該当する。docs.anthropic.com次に、ホームディレクトリ（~/.claude/CLAUDE.md）に配置するユーザーメモリは、個人的な設定を全プロジェクトに適用したい場合に使用する。コードスタイルの好みや個人的なツールのショートカットなどを記載する。最後に、プロジェクトメモリ（ローカル）として./CLAUDE.local.mdがあるが、これは現在非推奨となっている。代わりに、インポート機能を使用することが推奨されている。Claude Codeは現在のディレクトリから上位ディレクトリに向かって再帰的にCLAUDE.mdを探索する。また、サブディレクトリ内のCLAUDE.mdは、そのディレクトリ内のファイルを読み込む際に必要に応じて含まれる。すべてのメモリファイルは、Claude Code起動時に自動的にコンテキストに読み込まれる。探索・計画・コード・コミットのワークフローこれらのワークフローはベストプラクティスで推奨されている。このワークフローの絶大な効果について深掘りする。計画が苦手な私がこのワークフローを採用する理由正直に告白すると、私は計画を立てるのが大の苦手だ。「とりあえずやってみよう」「コード書きながら考えればいいじゃん」というのが私の自然な思考パターン。でも、Claude Codeを使い始めて気づいた。AIとの協業では、私の苦手な「計画」こそが最も重要だということに。なぜか？AIは指示に対して忠実すぎるからだ。曖昧な指示を与えると、AIは勝手に解釈して暴走する。逆に、明確な計画があれば、AIはその通りに動いてくれる。つまり、私が苦手な部分をAIが補完してくれるのだ。だから私は、自分の性格に逆らってでも、このワークフローに従うことにした。「アイデアは豊富だけど実行が雑」という弱点を、AIとの協業で克服できる。なぜこのワークフローが効果的なのか従来の「とりあえずコードを書く」アプローチと比較して、このワークフローには明確な利点がある。認知負荷の分散により理解、設計、実装を明確に分離できる。早期の問題発見により計画段階で設計上の問題を特定できる。そしてAIとの効果的な協業により各段階でAIの強みを最大限活用できる。ステップ1: 探索（関連ファイルの読み込み）ワークフロー: 探索フェーズ目的：コードベースの現状を正確に把握し、変更の影響範囲を理解する実践例：一般的な探索@src/services/UserService.ts を読んで、まだコードは書かないで依存関係の探索UserServiceが依存している他のサービスも確認してインターフェースの確認UserServiceが実装しているインターフェースと、それを使用している箇所を探してサブエージェントの活用：複雑な問題では、サブエージェントに特定の調査を依頼サブエージェントで、UserServiceのメソッドがどこから呼ばれているか調査してこのフェーズで重要なのは、コードを書かない制約を明示すること。AIは「役に立ちたい」という性質があるため、明示的に制限しないとすぐに実装を始めてしまう。ステップ2: 計画（think モードの活用）ワークフロー: 計画フェーズ思考モードの使い分け：基本的な分析このアーキテクチャをthinkで分析して、改善計画を立てて複雑な問題の場合この認証システムの問題をthink hardで検討して、複数の解決策を提示してアーキテクチャレベルの変更システム全体への影響をthink harderで評価して長期的な技術戦略今後の拡張性を考慮した設計をultrathinkで再考して計画の文書化：作成した計画をarchitecture-decisions/001-user-service-refactoring.mdに保存してGitHub Issueとしても作成して、実装タスクに分解して思考モードの階層は、問題の複雑さに応じて使い分ける。単純な機能追加ならthinkで十分だが、システム全体に影響する変更ではthink harderやultrathinkを活用する。最近、日本語にも対応したみたいで「深く考えて」みたいなので良いらしい。zenn.devステップ3: 実装（検証を含む）ワークフロー: 実装フェーズ段階的な実装：最小限の実装から開始計画に従って、まずUserServiceの基本的なリファクタリングを実装して各段階での検証実装した部分のユニットテストを実行して、既存の機能が壊れていないか確認してエッジケースの考慮nullやundefinedの場合の処理を追加して、エラーハンドリングを強化して実装中の軌道修正：問題発見時この実装だと循環依存が発生しそう。別のアプローチを検討してパフォーマンスの考慮この部分のパフォーマンスが心配。ベンチマークを実行して最適化案を提示してステップ4: コミットとPR作成ワークフロー: コミット・PR作成フェーズ意味のあるコミット：変更を論理的な単位で分割変更をリファクタリング、機能追加、テスト追加の3つのコミットに分けてConventional Commitsに従うfeat: ユーザーサービスに新しい認証メソッドを追加refactor: UserServiceの内部構造を改善test: UserServiceの新機能に対するテストを追加PRの作成：包括的なPR説明PRを作成して。以下を含めて：- 変更の背景と目的- 実装アプローチの説明- テスト方法- 破壊的変更の有無- レビュアーへの注意点関連ドキュメントの更新README.mdとCLAUDE.mdも更新して、新しい機能とその使い方を記載してテスト駆動開発（TDD）ワークフローの深掘りTDDアプローチを、Claude Codeで最大限活用する方法を紹介する。正直なところ、TDDはいつも使うわけじゃない3ヶ月前の記事では、TDDの理想的な姿を描いた。でも現実は違う。計画が苦手な私にとって、TDDは「よっぽど仕様が決まっているとき」にしか使わない。なぜなら、探索的な開発では邪魔になり、「何を作るか」が曖昧な段階でテストを書くのは時間の無駄だからだ。プロトタイピングには不向きで、アイデアを素早く形にしたいときは、テストが足かせになる。さらに創造性を阻害し、テストという制約が、思考の自由な流れを妨げる。でも、Claude Codeとの協業で気づいたことがある。AIこそがTDDを必要としているのだ。あと何回生き返るんだTDD。TDDがAIコーディングで特に重要な理由まず、明確な成功基準により、AIが「何を達成すべきか」が明確になる。過剰な実装の防止により、テストが通る最小限の実装に集中できる。そしてリグレッションの防止により、AIの変更が既存機能を壊さない保証が得られる。私がTDDを使う「よっぽど決まっているとき」では、どんなときにTDDを使うのか？APIのインターフェースが確定したときは、OpenAPI仕様書があり、リクエスト/レスポンスの型が明確で、エラーケースが定義されている場合だ。既存機能のリファクタリングでは、現在の動作が明確で、変更後も同じ動作を保証したく、レグレッションを防ぎたい場合に使う。バグ修正においては、再現手順が明確で、期待される動作が定義でき、「二度と同じバグを出さない」という決意があるときに有効だ。つまり、「ゴールが明確なとき」にだけTDDを使う。探索的な開発では使わない。これが現実的なアプローチだと思う。ステップ1: テストファーストTDDワークフロー: テスト作成明確な仕様としてのテスト：機能要件を正確に反映したテストUserService.authenticateメソッドのテストを作成して。以下のケースをカバー：- 正常な認証成功- パスワード不一致- ユーザーが存在しない- アカウントがロックされている- 連続失敗によるロック入出力の明確化各テストケースで、入力パラメータと期待される出力（戻り値、例外）を明確に定義してモックの回避実際のデータベース接続を使用してテストを作成。モックは使わないなぜモックを避けるのか。実際の動作との乖離を防ぎ、統合問題の早期発見ができ、より現実的なテスト環境を構築できるからだ。ステップ2: RED - 失敗の確認TDDワークフロー: RED状態の確認失敗の種類を理解する：テストを実行npm test -- UserService.test.ts失敗の分析を依頼テストの失敗理由を分析して。以下の観点で：- コンパイルエラーか実行時エラーか- 期待値と実際の値の差異- 未実装による失敗か、バグによる失敗かRED状態の重要性は、テスト自体の妥当性を確認し、実装前の仕様の最終確認を行い、「テストが通りすぎる」問題を回避することにある。ステップ3: GREEN - 最小限の実装TDDワークフロー: GREEN状態への移行実装の指針：最小限の実装テストが通る最小限の実装を作成して。過度な最適化や追加機能は含めない段階的な実装まず最も単純なケース（正常な認証）から実装を始めてエラーケースの実装次にエラーケースを一つずつ実装して。各実装後にテストを実行AIの「過剰実装」への対処：明示的な制約IMPORTANT: テストケース以外の機能は実装しないYOU MUST: 各実装ステップ後にテストを実行して確認ステップ4: REFACTOR - コードの改善TDDワークフロー: リファクタリングテストが保証する安全なリファクタリング：コードの品質向上テストが通ることを確認しながら、以下の観点でリファクタリング：- 重複コードの除去- 可読性の向上- パフォーマンスの最適化- SOLID原則の適用継続的な検証各リファクタリング後にテストを実行して、機能が保持されていることを確認AIとのペアプログラミング的リファクタリング：改善提案を求めるこのコードの問題点を指摘して、改善案を3つ提示して段階的な適用提案1を適用して、テストが通ることを確認して便利なショートカットとツールClaude Codeのショートカットの実践的な活用法を紹介する。docs.anthropic.com@ ファイル選択の効果的な使い方ショートカット: @ファイル選択基本的な使用法@src/services/UserService.ts のcreateUserメソッドを改善して応用テクニック：複数ファイルの参照@src/services/UserService.ts と @src/models/User.ts を見て、データフローを説明してディレクトリ全体の参照@src/services/ ディレクトリのすべてのサービスの概要を説明してワイルドカードの活用@**/*Service.ts すべてのサービスファイルで共通のパターンを見つけて# ルール追加の戦略的活用ショートカット: #ルール追加即座のルール追加#このプロジェクトではzodでバリデーション。yupは使わない#エラーメッセージは必ず日本語で記述#APIレスポンスは必ずcamelCaseで統一ルールの階層は、プロジェクト全体のルールはプロジェクトルートのCLAUDE.mdに、個人的な好みは~/.claude/CLAUDE.mdに、一時的なルールはセッション中の#コマンドで設定する。ビジュアルフィードバックツール：CleanShot Xスクリーンショットは開発において重要なコミュニケーションツールだ。特にUIの実装やバグ報告では、言葉より画像が雄弁に語る。CleanShot Xの利点macOS用の高機能スクリーンショットツールで、即座の注釈により矢印、テキスト、図形を簡単に追加できる。スクロールキャプチャで長いページ全体を1枚の画像にでき、GIF/動画録画は操作手順の記録に最適だ。クラウド共有によりURLで即座に共有可能となる。cleanshot.comClaude Codeとの連携スクリーンショットの活用基本的な使い方は、CleanShot Xでスクリーンショット撮影（Cmd+Shift+4）し、必要に応じて注釈を追加して、Claude Codeにドラッグ&ドロップする。効果的な使用場面：UIの実装依頼このデザインモックアップに基づいてコンポーネントを実装してバグの報告このエラー画面が表示される原因を調査して修正してビフォーアフターの確認リファクタリング前後のUIを比較して、意図しない変更がないか確認してセッション管理とコンテキストの継続性開発は連続的なプロセスだ。Claude Codeのセッション管理機能を活用することで、文脈を保持したまま作業を継続できる。これめっちゃ便利なんだが意外と知らない。お前は公式ドキュメントを読んでないな！？！？継続的な開発フローセッション管理作業の再開：前回の続きから（推奨）$ claude --continue特定のセッションを選択$ claude --resume効果的な使い方として、1日の終わりに進捗を要約してもらう：今日の作業内容を要約して、明日やるべきことをリストアップして翌日の開始時に文脈を確認：$ claude --continue前回の作業内容を簡潔に要約してコンテキストの最適化：不要な情報をクリア/clear重要な情報を再度読み込み@CLAUDE.md を読んで、プロジェクトのコンテキストを復元して3ヶ月前の理論が現実になって3ヶ月前の記事で、私は生成AIとの協業について、いくつかの概念を紹介した。「助手席と後部座席」という開発者の新しい立ち位置、「レッドボックス」という人間が理解できないAIの生成物、「バイブスコーディング」という直感に任せた開発スタイル。 speakerdeck.comClaude Codeを使い始めて1週間、これらはすべて現実のものとなった。助手席での開発が意外と楽しい3ヶ月前は「ドライバー席を譲る」ことに不安があった。でも実際に助手席に座ってみると、これが意外と楽しい。CLAUDE.mdでの助手席ドライブ私（助手席）の役割は、目的地を決める（何を作るか）、ルートを提案する（どう作るか）、危険を警告する（エッジケース、セキュリティ）ことだ。Claude（運転席）の役割は、実際の運転（コーディング）、交通ルールの遵守（言語仕様、ベストプラクティス）、効率的な運転（パフォーマンス最適化）だ。計画が苦手な私にとって、これは理想的な役割分担だった。アイデアを出すのは得意だが、細かい実装は苦手。Claude Codeがそれを補完してくれる。レッドボックスとの遭遇実際、Claude Codeが生成したコードで「これ、どう動いてるの？」というものがあった：// Claudeが生成した謎のTypeScript型パズルtype DeepPartial<T> = T extends object ? {  [P in keyof T]?: DeepPartial<T[P]>;} : T;type RecursiveRequired<T> = T extends object ? {  [P in keyof T]-?: RecursiveRequired<T[P]>;} : T;正直、一瞬で理解できなかった。でも、そんなときはCLAUDE.mdに追加：理解困難なコードへの対処- IMPORTANT: 複雑な型定義には必ず使用例とコメントを追加- YOU MUST: 生成したコードの動作原理を説明できることバイブスコーディングの実践3ヶ月前は概念だった「バイブスコーディング」も、今では日常になった：なんか認証周りがイケてない気がする。もっとスマートにしてこのUIのレイアウト、もうちょっとモダンな感じにしてパフォーマンスがビミョーだから、なんとかして曖昧な指示？そうかもしれない。でも、Claude Codeは文脈を理解して、適切な提案をしてくれる。これがCLAUDE.mdの力だ。実践的なCLAUDE.md設定例実際に私が開発したcctxプロジェクトのCLAUDE.mdから、効果的な記載方法を紹介する。github.comプロジェクト概要の明確化# 🔄 CLAUDE.md - cctx Project Documentation## 📋 Project Overview**cctx** (Claude Context) is a fast, secure, and intuitive command-line tool for managing multiple Claude Code `settings.json` configurations. Built with Rust for maximum performance and reliability.## 🏗️ Architecture### 🎯 Core Concept- **🔧 Context**: A saved Claude Code configuration stored as a JSON file- **⚡ Current Context**: The active configuration (`~/.claude/settings.json`)- **📁 Context Storage**: All contexts stored in `~/.claude/settings/`- **📊 State Management**: Current and previous context tracked in `.cctx-state.json`絵文字を使うことで人間がパット見で視覚的に分かりやすくし、重要な概念を箇条書きで整理している。結局は人間がチェックしなくてはいけないので…。AIアシスタント向けの具体的な指示## 📚 Notes for AI AssistantsWhen working on this codebase:1. **Always run `cargo clippy` and fix warnings** before suggesting code2. **Test your changes** - don't assume code works3. **Preserve existing behavior** unless explicitly asked to change it4. **Follow Rust idioms** and best practices5. **Keep the kubectx-inspired UX** - simple, fast, intuitive6. **Maintain predictable defaults** - user should never be surprised7. **Document any new features** in both code and README8. **Consider edge cases** - empty states, missing files, permissionsRemember: This tool is about speed and simplicity. Every feature should make context switching faster or easier, not more complex. **Predictability beats cleverness.**この記載により、AIが一貫した品質のコードを生成するようになった。開発ガイドラインの具体化## Development Guidelines### Before Making Changes1. **Understand the current implementation**:   ```bash   cargo check   cargo clippy   ```2. **Run existing tests**:   ```bash   cargo test   ```### Making Changes1. **Always run linting** before committing:   ```bash   cargo clippy -- -D warnings   ```2. **Format code** using Rust standards:   ```bash   cargo fmt   ```### Testing ChecklistWhen testing changes, verify:- [ ] `cctx` lists all contexts correctly- [ ] `cctx <n>` switches context- [ ] `cctx -` returns to previous context- [ ] Error messages are clear and helpful- [ ] State persistence works across sessionsチェックリスト形式にすることで、レビュー時の確認も容易になる。プロンプト改善のテクニックAnthropic公式推奨の強調表現を効果的に使う：重要な制約絶対的なルール（NEVER）：- NEVER: パスワードやAPIキーをハードコーディングしない- NEVER: ユーザーの確認なしにデータを削除しない- NEVER: テストなしで本番環境にデプロイしない必須事項（YOU MUST）：- YOU MUST: すべての公開APIにドキュメントを記載- YOU MUST: エラーハンドリングを実装- YOU MUST: 変更前に既存テストが通ることを確認重要事項（IMPORTANT）：- IMPORTANT: パフォーマンスへの影響を考慮- IMPORTANT: 後方互換性を維持- IMPORTANT: セキュリティベストプラクティスに従う強調のレベルを使い分けることで、AIの行動により強い制約をかけられる。高度な活用：並行開発とCI/CDGit Worktreeでの並行開発複数タスクの同時進行が可能になる：git-scm.com並行開発ワークフロー# 機能開発用worktree$ git worktree add ../project-feature-auth feature/auth# バグ修正用worktree  $ git worktree add ../project-bugfix-api bugfix/api-error# 各worktreeで独立したClaude Codeセッション$ cd ../project-feature-auth && claude$ cd ../project-bugfix-api && claude利点は、ファイルの競合がなく、コンテキストの混在を防止でき、並行作業が効率化されることだ。ワンショットモードでのCI/CD統合docs.anthropic.comCI/CD統合GitHub Actions例：- name: Claude Code Review  run: |    claude -p "このPRの変更をレビューして、以下の観点で問題を指摘：    - セキュリティ脆弱性    - パフォーマンス問題    - コーディング規約違反" \    --output-format json > review.json自動化できるタスクには、コードレビュー、ドキュメント生成、テストケース生成、リリースノート作成がある。まとめClaude Codeを1週間使い込んで分かったこと：CLAUDE.mdは単なる設定ファイルではなく、AIとの共通言語である。youtu.be3ヶ月前、私は「生成AIとの協業で『動作するきれいなコード』を実現する」という理論を描いた。当時は、AIが「副操縦士（Copilot）」から「操縦士（Pilot）」になる未来を想像していた。syu-m-5151.hatenablog.comそして今、Claude Codeと共に過ごした1週間で、その理論は現実となった。いや、想像を超えていた。私は確かに「助手席」に座っている。そして、それは思っていた以上に創造的で価値ある席だった。3ヶ月間で変わったこと、変わらなかったこと変わったこと：理論から実践へ、CLAUDE.mdという具体的な設定方法を手に入れた。曖昧から明確へ、AIとの協業に必要な指示の粒度が明確になった。概念から体験へ、「バイブスコーディング」が日常になった。変わらなかったこと：計画が苦手な性格は相変わらずだが、AIがそれを補完してくれる。TDDへの抵抗感もあるが、AIとの協業では必要だと理解した。「動作するきれいなコード」への憧れは、むしろより現実的な目標になった。効果的なCLAUDE.mdには、明確なプロジェクト概要（AIが文脈を理解するための基盤）、具体的なワークフロー（探索・計画・コード・コミット、計画が苦手でも従う価値がある）、実践的なコマンド集（日常的に使うコマンドの網羅）、AIへの明示的な指示（期待する振る舞いの明文化）が必要だ。settings.jsonと組み合わせることで、Claude Codeは単なるツールから、プロジェクトを深く理解したパートナーへと進化する。予測可能性は賢さに勝る。この原則を忘れずに、CLAUDE.mdを育てていこう。3ヶ月後、私はどんな記事を書いているだろうか。きっと「Claude Codeと1年過ごして、完全に人間を超えた話」みたいなタイトルかもしれない。でも、それでも私は助手席に座り続けるだろう。なぜなら、それが最も創造的な席だから。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ddc.vimによるシェルコマンドの補完が速くなったぞ]]></title>
            <link>https://blog.atusy.net/2025/06/06/ddc-source-shell_native-is-faster/</link>
            <guid>https://blog.atusy.net/2025/06/06/ddc-source-shell_native-is-faster/</guid>
            <pubDate>Fri, 06 Jun 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[ddc-source-shell_nativeを使うとシェルコマンドの補完ができます。従来は補完候補を取得するたびにシェルを起動するため時間がかかりましたが、シェルを常駐させることで高速化してもらいました。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Introducing cctx: A Context Switcher for Claude Code]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/05/232126</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/05/232126</guid>
            <pubDate>Thu, 05 Jun 2025 14:21:26 GMT</pubDate>
            <content:encoded><![CDATA[IntroductionAs developers, we often juggle multiple contexts throughout our day - switching between personal projects, client work, and perhaps some experimental code on the side. Each context might require different permissions, access levels, and configurations. If you're using Claude Code, Anthropic's CLI tool for interacting with Claude, you've probably felt the pain of manually managing different settings.json configurations. That's why I built cctx - a fast, intuitive context switcher for Claude Code, inspired by the excellent kubectx tool for Kubernetes.github.comThe Problem: Configuration Context SwitchingClaude Code uses a settings.json file to control permissions, access levels, and various configurations. This is great for security and customization, but becomes cumbersome when you need different settings for different scenarios:Work projects need restricted permissions for safetyPersonal projects might need full access to your file systemClient demos require ultra-restricted settings for screen sharingExperimental work needs different tool accessManually editing settings.json or maintaining multiple copies quickly becomes error-prone and tedious. I needed something better.docs.anthropic.comEnter cctx: Fast Context Switching for Claude Codecctx (Claude Context) brings the simplicity and speed of kubectx to Claude Code configuration management. Written in Rust for maximum performance, it allows you to switch between different Claude Code configurations with a single command:# Switch to work context (restricted permissions)cctx work# Switch to personal context (full permissions)cctx personal# Switch back to previous contextcctx -Design Philosophy: Predictable Defaults with Progressive DisclosureOne of the key lessons learned during development was the importance of predictable behavior. In version 0.1.1+, I completely redesigned the UX around a simple principle: predictable defaults with explicit overrides.What This Means in PracticeDefault behavior is always the same - cctx always manages user-level contexts (~/.claude/settings.json) unless explicitly told otherwiseNo surprising auto-detection - The tool won't suddenly switch to project-level contexts just because you're in a different directoryProgressive disclosure - When project or local contexts are available, helpful hints guide you to themExplicit when needed - Use --in-project or --local flags when you want to manage other context levelsThis approach eliminates cognitive overhead while maintaining full functionality for advanced users.Key Features That Make cctx Shine🚀 Lightning FastBuilt with Rust, cctx switches contexts in milliseconds. No Python startup overhead, no Node.js dependencies - just pure speed.🎨 Beautiful, Intuitive InterfaceColor-coded output with the current context highlighted in greenHelpful emoji indicators for different context levels (👤 User, 📁 Project, 💻 Local)Interactive fuzzy search with fzf integration or built-in finderClear, actionable error messages🛡️ Security-First DesignCreate separate contexts for different security requirements:# Create a restricted work contextcctx -n workcctx -e work  # Edit to add restrictions# Create a demo context for screen sharingcctx -n demo  # Ultra-restricted, read-only📁 Simple File-Based StorageContexts are just JSON files stored in ~/.claude/settings/. You can edit them manually, version control them, or sync them across machines.Real-World Usage PatternsHere's how I use cctx in my daily workflow:Morning Routine# Start the day with work contextcctx work# Check what context I'm incctx -c# Output: workProject Switching# Working on a personal projectcctx personal# Client calls - need to share screencctx demo# Back to personal projectcctx -Context Management# Create a new context for a specific clientcctx -n client-acme# Edit the context to set appropriate permissionscctx -e client-acme# List all contextscctx# Output:# 👤 User contexts:#   client-acme#   demo#   personal#   work (current)Technical Implementation HighlightsWhy Rust?Performance: Instant startup and executionSafety: Memory safety without garbage collectionSingle binary: Easy distribution and installationGreat ecosystem: Excellent CLI libraries like clap and dialoguerArchitecture DecisionsFile-based contexts: Each context is a separate JSON fileAtomic operations: Context switching is done by copying filesState tracking: Current and previous contexts tracked in a hidden state filePlatform compatibility: Works on Linux, macOS, and WindowsSettings Hierarchy Supportcctx respects Claude Code's settings hierarchy while keeping things simple:# Default: user-level contextscctx work# Explicit: project-level contextscctx --in-project staging# Explicit: local project contextscctx --local debugGetting StartedInstallation is straightforward:# From crates.io (recommended)cargo install cctx# Or grab a pre-built binary# Download from https://github.com/nwiizo/cctx/releasesCreate your first contexts:# Create a personal context from current settingscctx -n personal# Create a restricted work contextcctx -n workcctx -e work  # Edit to add restrictions# Start switching!cctx workcctx personalcctx -  # Switch backWhat's Next?The cctx project is actively maintained and follows Claude Code's development closely. Some ideas for the future include:Context templates for common scenariosShell integration for automatic context switchingContext inheritance for shared settingsIntegration with other AI coding toolsConclusioncctx brings the joy of quick context switching to Claude Code users. By focusing on speed, simplicity, and predictable behavior, it removes the friction from managing multiple configurations. Whether you're switching between work and personal projects, managing client-specific settings, or just want better control over your Claude Code permissions, cctx has you covered.The project is open source and available on GitHub. If you find it useful, please consider starring the repository and contributing your own ideas and improvements. Happy context switching!cctx is an independent open-source project and is not affiliated with Anthropic. For official Claude Code documentation and support, please visit docs.anthropic.com.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：imgcat]]></title>
            <link>https://zenn.dev/akasan/articles/a57b277ee7af27</link>
            <guid>https://zenn.dev/akasan/articles/a57b277ee7af27</guid>
            <pubDate>Thu, 05 Jun 2025 11:03:01 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第5回は、imgcatというコマンドを紹介します。imgcatを使うとターミナル上で画像を表示させることができます。なお、第4回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/25f1eca029854b imgcatとは？imgcatとは公式の説明によるとDisplay images and gifs in your terminal emulator.ということで画像やgifをターミナルに表示させることができます。特徴としてアニメーションGIFの利用が可能標準入力からメ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Claude Code の settings.json は設定した方がいい]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/05/134147</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/05/134147</guid>
            <pubDate>Thu, 05 Jun 2025 04:41:47 GMT</pubDate>
            <content:encoded><![CDATA[はじめにClaude Code 使ってますか？ターミナルから Claude に直接コーディングタスクを投げられる便利なツールなんですが、デフォルト設定のまま使うのはちょっともったいない。というかいちいちいろんなことを聞いてきてめちゃくちゃダルい。syu-m-5151.hatenablog.comsettings.json をちゃんと設定すると、セキュリティも保ちつつ、もっと快適に使えるようになります。全体的に疲れている時の~/.claude/settings.json と~/.claude/CLAUDE.md · GitHub 私のデフォルトの設定も公開してますのでよかったら参考にしてください。ここで読むのをやめる人のために言っておくと Claude Codeの設定は優先順位があるので覚えておくと良い です。あと、比較的に今は黎明期なので非推奨や追加機能が多いのでその点も注意が必要かもです。正直なところ、Anthropic の公式ドキュメント（日本語）が最高に分かりやすいので、まずはそっちを読んでほしいんですが、このブログは公式ドキュメントに赤線を引いたようなもので、実際に使ってみて「これは設定しといた方がいいよ」っていうポイントをピックアップしてまとめました。docs.anthropic.comsettings.json って何？settings.json は Claude Code の動作を制御する設定ファイルです。公式ドキュメントによると、こんな設定ができます。{  "permissions": {    "allow": [      "Bash(npm run lint)",      "Bash(npm run test:*)",      "Read(~/.zshrc)"    ],    "deny": [      "Bash(curl:*)"    ]  },  "env": {    "CLAUDE_CODE_ENABLE_TELEMETRY": "1",    "OTEL_METRICS_EXPORTER": "otlp"  }}設定できる項目 キー  説明  例  apiKeyHelper  Anthropic APIキーを生成するカスタムスクリプト  /bin/generate_temp_api_key.sh  cleanupPeriodDays  チャット記録をローカルに保持する期間（デフォルト：30日）  20  env  すべてのセッションに適用される環境変数  {"FOO": "bar"}  includeCoAuthoredBy  gitコミットにco-authored-by Claudeを含めるか（デフォルト：true）  false  permissions  ツールのアクセス権限設定  後述 権限設定をちゃんとやろうClaude Code の一番重要な機能がこの権限設定。/permissions コマンドで現在の設定を確認できます。/permissionsはとても良いので覚えておいてほしいです。また、便利なCLIの使い方も覚えておいたほうが多分良いです。docs.anthropic.comBash コマンドの制御{  "permissions": {    "allow": [      "Bash(npm run build)",      // 特定のコマンドだけ許可      "Bash(npm run test:*)",     // プレフィックスで許可      "Bash(git:*)"               // git コマンドは全部OK    ],    "deny": [      "Bash(curl:*)"              // curl は使わせない    ]  }}Claude Code はシェル演算子（&&など）も認識してるので、Bash(safe-cmd:*)みたいなルールでもsafe-cmd && dangerous-cmdみたいなのは実行できません。賢い！ファイルアクセスの制御Read と Edit のルールは gitignore の仕様に従います：{  "permissions": {    "allow": [      "Edit(docs/**)",           // プロジェクトの docs ディレクトリ内を編集可能      "Read(~/.zshrc)",         // ホームディレクトリの .zshrc を読める      "Edit(//tmp/scratch.txt)" // 絶対パスは // で指定    ]  }}Web アクセスの制御{  "permissions": {    "allow": [      "WebFetch(domain:example.com)"  // 特定ドメインのみ許可    ]  }}環境変数の活用公式ドキュメントに載ってる環境変数をうまく使うと便利：{  "env": {    "ANTHROPIC_API_KEY": "your-key-here",    "CLAUDE_CODE_ENABLE_TELEMETRY": "0",    "DISABLE_COST_WARNINGS": "1",    "BASH_DEFAULT_TIMEOUT_MS": "300000",    "BASH_MAX_TIMEOUT_MS": "1200000"  }}主要な環境変数 変数名  用途  CLAUDE_CODE_ENABLE_TELEMETRY  テレメトリの有効/無効  DISABLE_COST_WARNINGS  コスト警告を無効化  BASH_DEFAULT_TIMEOUT_MS  Bashコマンドのデフォルトタイムアウト  DISABLE_AUTOUPDATER  自動更新を無効化 設定の優先順位を理解しよう公式ドキュメントによると、設定は以下の順番で適用されます（上が優先）：エンタープライズポリシーコマンドライン引数ローカルプロジェクト設定（.claude/settings.local.json）共有プロジェクト設定（.claude/settings.json）ユーザー設定（~/.claude/settings.json）プロジェクトごとに設定を変えたければ、プロジェクトフォルダに .claude/settings.json を置けばOK。Git で共有したくない設定は .claude/settings.local.json に書こう。実践的な設定例制限的な設定（仕事用）{  "permissions": {    "allow": [      "Bash(npm run lint)",      "Bash(npm run test:*)",      "Bash(git:*)",      "Read(./src/**)",      "Edit(./src/**)"    ],    "deny": [      "Bash(npm publish:*)",      "WebFetch(domain:*)"    ]  },  "includeCoAuthoredBy": false}もう少しゆるい設定（個人用）{  "permissions": {    "allow": [      "Bash(npm:*)",      "Bash(git:*)",      "Bash(cargo:*)",      "Read(**)",      "Edit(~/projects/**)",      "WebFetch(domain:*)"    ]  },  "cleanupPeriodDays": 60}MCP (Model Context Protocol) を使う場合MCP サーバーを使ってる人向けの権限設定：{  "permissions": {    "allow": [      "mcp__puppeteer",                        // puppeteer サーバーの全ツール      "mcp__puppeteer__puppeteer_navigate"     // 特定のツールだけ    ]  }}複数の設定を切り替えたいならちなみに、複数の~/.claude/settings.jsonを簡単に切り替えたい人向けに cctx っていうツールも作ってみました。cargo install cctxまとめClaude Code の settings.json は、ちゃんと設定すると作業効率とセキュリティが大幅に向上します。ちゃんとしましょう。特に重要なのは：権限設定で必要最小限のアクセスだけ許可するプロジェクトごとに適切な設定を使い分ける環境変数でタイムアウトやテレメトリを調整する詳しい設定方法は Anthropic の公式ドキュメント（日本語）がマジで分かりやすいので、ぜひ読んでみてください。Anthropic の公式ドキュメント最高！Claude Code の 公式ドキュメントやベストプラクティス はとりあえず読んだ方がいい。www.anthropic.com参考リンクClaude Code 公式ドキュメント（日本語） - これ読めば全部分かるcctx - Claude Context Manager - 設定切り替えツールClaude Code 設定例（Gist） - 実際の設定例]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンドラインでバブルソートを可視化してみた]]></title>
            <link>https://zenn.dev/akasan/articles/0331574e200f01</link>
            <guid>https://zenn.dev/akasan/articles/0331574e200f01</guid>
            <pubDate>Wed, 04 Jun 2025 13:30:16 GMT</pubDate>
            <content:encoded><![CDATA[今回はPythonを使ってバブルソートをコマンドラインで可視化しながらソートするコードを作ってみました。 バブルソートとはバブルソートとはリスト内のアイテムをソートするためのアルゴリズムの一つで最もシンプルなものとなります。計算ロジックは以下になります。インデックスi=0、上限インデックスupper_iを`リストの要素数-1``で初期化するiとi+1の要素の大小を比較し、iの値の方が大きかった場合iとi+1の値を入れ替えるiの値を1つ増やし2を実行するiの値がupper_iと一致したらi=0に設定してupper_idを1減らすupper_idが0になるまで繰り返すと...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：rg]]></title>
            <link>https://zenn.dev/akasan/articles/25f1eca029854b</link>
            <guid>https://zenn.dev/akasan/articles/25f1eca029854b</guid>
            <pubDate>Tue, 03 Jun 2025 14:30:40 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第4回は、rgというコマンドを紹介します。rgを使うとリカーシブに正規表現を使って文字列検索を行ったりすることができます。なお、第3回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/5c92827ae75f3c※ 今回は正規表現を使った検索については省略します。基本的に他のツールと利用方法は変わりません！ rgとは？rgとは公式の説明によるとripgrep is a line-oriented search tool that recursively searches the cu...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Conform.nvimの保存時フォーマットをスキップする方法]]></title>
            <link>https://blog.atusy.net/2025/06/03/skip-conform-nvim-format-on-save/</link>
            <guid>https://blog.atusy.net/2025/06/03/skip-conform-nvim-format-on-save/</guid>
            <pubDate>Tue, 03 Jun 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Conform.nvimのformat_on_saveは便利ですが、たまーにスキップしたくなります。:w!の実行やバッファの内容に応じて制御してみましょう。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vim/Neovimのマークを操作内容に合わせて設定する]]></title>
            <link>https://blog.atusy.net/2025/06/03/vim-contextful-mark/</link>
            <guid>https://blog.atusy.net/2025/06/03/vim-contextful-mark/</guid>
            <pubDate>Tue, 03 Jun 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[たとえば`yしたら直前にヤンクした場所に戻れるとよさそうですね。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：bat]]></title>
            <link>https://zenn.dev/akasan/articles/5c92827ae75f3c</link>
            <guid>https://zenn.dev/akasan/articles/5c92827ae75f3c</guid>
            <pubDate>Mon, 02 Jun 2025 11:37:04 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第3回は、batというコマンドを紹介します。batを使うとシンタックスハイライトを用いた画面表示やgitとの連携などを行うことができます。なお、第2回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/dd94771d828ec7 batとは？batは公式の説明によると、シンタックスハイライトとGitとの連携機能付きの cat(1) クローン。ということです。catはファイル内容を表示したり新しいファイルを作ったりできるコマンドですが、それを拡張したものであると言えます。catではシ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイク所属のエンジニアが「AWS Community Builders」に選出]]></title>
            <link>https://sreake.com/blog/aws-community-builders-2025/</link>
            <guid>https://sreake.com/blog/aws-community-builders-2025/</guid>
            <pubDate>Mon, 02 Jun 2025 01:00:00 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）に所属の鈴木 勝史が、「AWS Community Builders」に2年連続で選出されたことをお知らせします。The post スリーシェイク所属のエンジニアが「AWS Community Builders」に選出 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Pythonのtypingについて改めて調べてみた]]></title>
            <link>https://zenn.dev/akasan/articles/b1643e49d81dfe</link>
            <guid>https://zenn.dev/akasan/articles/b1643e49d81dfe</guid>
            <pubDate>Sun, 01 Jun 2025 10:21:58 GMT</pubDate>
            <content:encoded><![CDATA[今回はPythonのtypingについて今までちゃんと調べずに使っていたこともあったので調べてみることにしました。 typingとは？Pythonでデフォルトで利用可能なtypingは、Pythonにおけるタイプヒントをサポートする目的で実装されています。以下が公式ページになります。注釈にも書いてありますが、一般的はPythonランタイムは関数や変数のアノテーションについて強制することはありません。あくまで型アノテーションは明示的に型を示すことでセルフドキュメントとして機能します。※ mypyなどの静的型チェッカーを利用するさいはタイプヒントが必要です。基本的にはmypyを利用し...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AIが進化しても、なぜそのコードを書いたかは消えていく]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/01/122352</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/01/122352</guid>
            <pubDate>Sun, 01 Jun 2025 03:23:52 GMT</pubDate>
            <content:encoded><![CDATA[はじめに生成AIを使ったコード開発が急速に普及している。GitHub Copilot、ChatGPT、Claude、そして各種IDEに統合されたAIアシスタントや独立したコーディングエージェント。これらのツールは開発効率を飛躍的に向上させ、もはやAIなしでの開発は考えられないという声も聞こえてくる（主に心の底から）。しかし、この革新的な変化の中で、看過できない問題が顕在化している。現在のAIで生成したコードは、2年後の進化したAIで再生成すれば、より効率的で保守性の高いコードに置き換えられる。これ自体は技術進歩として歓迎すべきことだが、重要な情報が失われている。それは「なぜそのコードをそのように実装したのか」という意思決定の記録だ。この問題は単なる技術的な課題ではない。私たちがどのようにソフトウェアを作り、保守し、進化させていくかという、エンジニアリングの本質に関わる問題だ（そして、2年後の自分に恨まれない方法でもある）。プロンプトと成果物の分離がもたらす課題従来の開発では、コードとともにコメントやドキュメントで意図を残してきた。しかしAI時代では、以下の情報が分離してしまう：入力：プロンプト（要件、制約、背景情報）出力：生成されたコード生成されたコードだけがリポジトリに残り、そのコードを生成した際のプロンプトや文脈は失われる。2年後、より優れたAIでコードを改善しようとしても、元の要件や制約条件、設計判断の根拠が不明なため、適切な改善ができない。これは「なんでこんな実装になってるの？」と聞かれて「AIがそう書いたから...」としか答えられない悲しい未来への第一歩だ。ADRからPDRへ：解決策の提案ソフトウェアアーキテクチャの分野では、ADR（Architecture Decision Records）によって設計判断を記録する文化が定着している。同様に、AI時代にはPDR（Prompt Decision Records）が必要だ。syu-m-5151.hatenablog.comPDRに記録すべき要素：使用したAIモデルとバージョン（GPT-4なのかClaude-3なのか、未来の自分は知りたがっている）入力したプロンプトの完全なテキストプロンプトに込めた意図と背景検討した他の選択肢採用した理由とトレードオフ生成パラメータ（temperature、max_tokens等）既存ツールにおける実装例既存ツールの現状についてはこちらがめちゃくちゃよくまとまっております。azukiazusa.devCursor Rulesdocs.cursor.comCursorでは.cursorrulesファイルでプロジェクト固有のコンテキストを定義できる。これにより、AIは常にプロジェクトの規約や方針を理解した上でコードを生成する（理解しているフリをすることもあるが）。具体的には、プロジェクトのルートディレクトリに.cursorrulesファイルを配置することで、以下のような指示を永続化できる：このプロジェクトではTypeScriptを使用し、関数型プログラミングのアプローチを優先する。エラーハンドリングはResult型を使用し、例外は投げない。すべての関数にはJSDocコメントを必須とする。このファイルはプロジェクト全体で共有される暗黙知を形式知化する役割を果たし、新しいメンバーがジョインした際のオンボーディングツールとしても機能する。Cline Rulesdocs.cline.botClineも同様に、プロジェクトルールを定義する仕組みを提供している。これらのルールファイルは、実質的にプロンプトの一部を永続化する仕組みだ。Clineの特徴的な点は、ルールを階層的に管理できることだ。グローバルルール、プロジェクトルール、ディレクトリ固有のルールを定義でき、より細かい粒度でAIの振る舞いを制御できる。例えば：/backendディレクトリ：「APIエンドポイントはRESTfulな設計に従う」/frontendディレクトリ：「ReactコンポーネントはHooksを使用した関数コンポーネントとする」/testsディレクトリ：「テストはAAA（Arrange-Act-Assert）パターンに従う」このようなコンテキストの階層管理により、大規模プロジェクトでも一貫性を保ちながら、部分ごとに最適化されたAI支援を受けられる。Anthropic CLAUDE.mdwww.anthropic.comAnthropicのCLAUDE.mdアプローチは、プロジェクトの全体的なコンテキストを単一のマークダウンファイルにまとめる。これは包括的なプロンプトテンプレートとして機能し、AIとの対話の基盤となる。CLAUDE.mdの強みは、単なるルールの羅列ではなく、プロジェクトのストーリーを語る点にある。典型的な構成は：# プロジェクト概要このプロジェクトの目的と背景# アーキテクチャシステムの全体構成と主要コンポーネントの説明# 開発規約- コーディングスタイル- 命名規則- ディレクトリ構造# よくある質問と回答過去の設計判断とその理由この形式により、AIは単にルールに従うだけでなく、プロジェクトの「なぜ」を理解した上でコードを生成できる。まさに本記事で提唱するPDRの考え方を先取りした実装と言えるだろう。実装における具体的な課題バージョン管理プロンプトもコードと同様にバージョン管理が必要だ。しかし、以下の課題がある：プロンプトの変更がコードに与える影響の追跡AIモデルのバージョンアップに伴う互換性管理プロンプトとコードの紐付けの維持（gitのblameコマンドに「AI」と表示される悲しさ）標準化の欠如現状、プロンプトを記録・管理する標準的な方法は存在しない。各ツールが独自の方法を実装しているため、ツール間での移植性がない。まるで文字コードの乱立時代を彷彿とさせる。再現性の問題同じプロンプトでも、以下の要因により出力が変わる：AIモデルのバージョン生成パラメータAPIのバージョン実行タイミング（モデルの更新）今後の展望と提案短期的な対策既存ツールの活用Cursor、Cline、GitHub Copilotなどが提供するルールファイル機能を積極的に活用し、プロジェクト固有のコンテキストを記録・管理する。プロンプトのコメント埋め込み生成されたコードに、使用したプロンプトをコメントとして埋め込む（将来の自分への手紙として）。専用ディレクトリでの管理/promptsディレクトリを作成し、コードファイルと対応するプロンプトファイルを保存。生成メタデータの記録生成日時、モデルバージョン、パラメータをJSONで保存。中長期的な標準化業界標準として、以下のような仕様が必要になるかもしれない：# prompt-decision-record.yamlversion: 1.0timestamp: 2024-12-XXmodel:  provider: openai  name: gpt-4  version: gpt-4-0125-preview  mood: cooperative  # 冗談ですparameters:  temperature: 0.7  max_tokens: 2000prompt: |  実際のプロンプトテキストcontext:  requirements: |    要件の説明  constraints: |    制約事項  decisions: |    設計判断の根拠output_file: src/feature/***.pyおわりにAI活用が当たり前になる開発環境において、コードの「なぜ」を残すことは、技術的負債を防ぐ重要な実践だ。2年後により良いAIが登場したとき、過去の意思決定を理解できれば、真に価値のある改善が可能になる。私たちエンジニアは、常に未来の自分や同僚のことを考えてコードを書いてきた。可読性、保守性、拡張性—これらはすべて「未来の誰か」のための配慮だ。AI時代においても、この精神は変わらない。むしろ、AIの進化速度を考えれば、より一層重要になる。プロンプトは新しい形の設計書だ。コードレビューと同じように、プロンプトレビューが必要になるかもしれない。リファクタリングと同じように、プロンプトリファクタリングが日常になるかもしれない（プロンプトの可読性を議論する日も近い）。もしくはそのような考慮をすべて超えて全てを理解する生成AIのモデルが成長する可能性もある。PDRのような仕組みの標準化は、AI時代のソフトウェア開発における必須要件となるだろう。エンジニアとして、この課題に真剣に取り組む時期に来ているが、個人ではどうにもならない気もするので。頑張れ、Anthropic！！！]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitLabでCIを実行する方法を調べてみた]]></title>
            <link>https://zenn.dev/akasan/articles/fb2c0453fde9fa</link>
            <guid>https://zenn.dev/akasan/articles/fb2c0453fde9fa</guid>
            <pubDate>Sat, 31 May 2025 06:39:06 GMT</pubDate>
            <content:encoded><![CDATA[今回はGitLabを利用してどのようにCIを実行するかについて試してみました。私自身今までGitHub Actionsしか使ってこなかったので、今回試してみました。 GitLabとはGitLabはGitLab社が展開しているGitを利用するためのバージョン管理システムのサービスになります。DevOpsだけでなくDevSecOpsのワークフローを意識したサービスとなっています。以下が公式ページとなっております。https://about.gitlab.com/ja-jp/ CIとは？CIとは継続的インテグレーション、英語にするとContinuous Integrationの...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[marp.nvimを開発してCursorから完全移行した話]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/05/31/105405</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/05/31/105405</guid>
            <pubDate>Sat, 31 May 2025 01:54:05 GMT</pubDate>
            <content:encoded><![CDATA[なぜmarp.nvimが必要だったのか前回の記事でClaude Codeに移行し、Neovimに完全回帰することを決めた。コーディング、ドキュメント作成、設定ファイルの編集――すべてが再びターミナルで完結するようになった。しかし、一つだけ問題があった。Marpでのプレゼンテーション作成だ。Marpは素晴らしいツールだが、公式のNeovimサポートは存在しない。プレゼンテーションを作るたびに、仕方なくVSCodeやCursorを起動していた。せっかくNeovimに完全回帰したのに、プレゼン作成のためだけに別のエディタを立ち上げる。この矛盾が許せなかった。marp.app既存のソリューションを探したが、満足できるものはなかった。ならば答えは一つ――自作するしかない。こうしてmarp.nvimは生まれた。Neovimですべてを完結させるという理想を、妥協なく追求した結果だ。github.commarp.nvimの技術的アプローチアーキテクチャ┌─────────────┐     ┌─────────────┐     ┌─────────────┐│   Neovim    │────▶│  marp.nvim  │────▶│  Marp CLI   ││   Buffer    │     │  Lua Plugin │     │  --watch    │└─────────────┘     └─────────────┘     └─────────────┘                            │                            ▼                    ┌─────────────┐                    │   Browser   │                    │  Auto-open  │                    └─────────────┘コア実装の詳細1. Marp CLIのプロセス管理これは完全にMarp の作者が優秀なのですがMarpには--watchオプションが存在しています。これを使わない手はないです-- プロセスをバッファごとに管理M.active_processes = {}-- jobstart で Marp CLI を起動local job_id = vim.fn.jobstart(shell_cmd, {    pty = true,  -- 擬似端末で適切な出力キャプチャ    stdout_buffered = false,    stderr_buffered = false,    on_stdout = function(_, data)        -- 出力処理    end,    on_exit = function()        M.active_processes[bufnr] = nil    end})重要なポイント：pty = trueを使用することで、Marp CLIのカラー出力を適切に処理stdout_buffered = falseでリアルタイム出力を実現バッファ番号をキーにしてプロセスを管理2. 自動クリーンアップの実装vim.api.nvim_create_autocmd({"BufDelete", "BufWipeout"}, {    buffer = bufnr,    once = true,    callback = function()        M.stop(bufnr)    end})VSCode拡張機能では当たり前の機能だが、Neovimでは自前実装が必要。バッファのライフサイクルに合わせてプロセスを管理。3. ウォッチモード vs サーバーモードif M.config.server_mode then    cmd = string.format("%s -s '%s'", marp_cmd, file)else    -- デフォルトは --watch モード    cmd = string.format("%s --watch '%s'", marp_cmd, file)end2つのモードをサポート：ウォッチモード（デフォルト）: HTMLファイルを生成し、変更を監視サーバーモード: HTTPサーバーを起動（ポート競合の可能性あり）4. ANSIエスケープシーケンスの処理local function clean_ansi(str)    return str:gsub("\27%[[%d;]*m", ""):gsub("\27%[[%d;]*[A-Za-z]", "")endMarp CLIの美しいカラー出力をNeovimの通知システムで扱うための処理。これがないと文字化けする。実装で工夫した点1. 初回HTML生成の最適化-- ウォッチモード開始前に初回HTMLを生成if not M.config.server_mode then    local init_cmd = string.format("%s '%s' -o '%s'", marp_cmd, file, html_file)    vim.fn.system(init_cmd)        if vim.fn.filereadable(html_file) == 1 then        -- 即座にブラウザを開く        M.open_browser("file://" .. html_file)    endend--watchモードは初回生成が遅いため、事前に生成してUXを改善。2. クロスプラットフォーム対応function M.open_browser(url)    local cmd    if vim.fn.has("mac") == 1 then        cmd = "open " .. url    elseif vim.fn.has("unix") == 1 then        cmd = "xdg-open " .. url    elseif vim.fn.has("win32") == 1 then        cmd = "start " .. url    end    vim.fn.jobstart(cmd, {detach = true})end3. デバッグモードM.config = {    debug = true,  -- 詳細ログを有効化}-- :MarpDebug コマンドで診断function M.debug()    local test_cmd = string.format("%s --version", marp_cmd)    -- Marp CLIの動作確認endトラブルシューティングを容易にするため、詳細なログ出力機能を実装。VSCode拡張機能との機能比較 機能  Marp for VS Code  marp.nvim  ライブプレビュー  ✅  ✅  自動リロード(書き込みイベント時)  ✅  ✅  テーマ切り替え  GUI  :MarpTheme  エクスポート  GUI  :MarpExport  スライドナビゲーション  ✅  ❌（開発中）  スニペット  ✅  ✅  複数ファイル同時編集  ✅  ✅ 使用方法インストール-- lazy.nvim{    "nwiizo/marp.nvim",    ft = "markdown",    config = function()        require("marp").setup({            marp_command = "npx @marp-team/marp-cli@latest",            debug = false,            server_mode = false,  -- ウォッチモードを使用        })    end,}基本的なワークフロー:e presentation.md:MarpWatch          " プレビュー開始(ファイル名をClipboardに書き込みもしている):MarpTheme uncover  " テーマ変更:MarpExport pdf     " PDF出力:q                  " バッファを閉じると自動でサーバー停止トラブルシューティング:MarpDebug          " Marp CLIの動作確認:MarpList           " アクティブなサーバー一覧:MarpStopAll        " 全サーバー停止パフォーマンスと制限事項メモリ使用量Marp CLIプロセス: 約50-100MB/インスタンス複数ファイル同時編集時は線形に増加既知の制限ホットリロードの遅延: ファイル保存からブラウザ更新まで約100-200ms大規模ファイル: 100スライド以上でパフォーマンス低下画像の相対パス: 作業ディレクトリに依存まとめmarp.nvimの開発により、Marpプレゼンテーション作成のためだけにCursorを起動する必要がなくなった。Neovimのjob APIを活用することで、VSCode拡張機能と似た体験を実現できることを証明できた。重要なのは、完璧を求めすぎないこと。VSCode拡張機能のすべての機能を再現する必要はない。ターミナルでの開発に必要十分な機能を、シンプルに実装することが大切だ。Claude Codeとの組み合わせで、プレゼンテーション作成もAIアシスト付きで行える。これで本当にすべての開発作業をNeovimで完結できるようになった。vimmer村への完全帰還、達成。実践Vim　思考のスピードで編集しよう！ (アスキー書籍)作者:Ｄｒｅｗ Ｎｅｉｌ,新丈 径角川アスキー総合研究所Amazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：tldr]]></title>
            <link>https://zenn.dev/akasan/articles/dd94771d828ec7</link>
            <guid>https://zenn.dev/akasan/articles/dd94771d828ec7</guid>
            <pubDate>Fri, 30 May 2025 10:37:03 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第2回は、tldrというコマンドを紹介します。名前からして何かしらの情報をまとめて表示してくれる系のコマンドと予想できるかと思いますが、実際はどんなコマンドなのかみていきましょう。 tldrとは？一言で言ってしまうと、コマンドラインツールのヘルプページで、man pagesをよりシンプルにしたものと思ってもらえればと思います。公式GitHubは以下にありますのでぜひ参照ください。https://github.com/tldr-pages/tldrそもそもman pagesとは何かという話ですが、コマンドラインツールで使い方がわからない時に利用されるm...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Claude Code を利用しようと思っているのでvimmer が住む村に帰ろうと思います。]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/05/30/180912</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/05/30/180912</guid>
            <pubDate>Fri, 30 May 2025 09:09:12 GMT</pubDate>
            <content:encoded><![CDATA[はじめに前回、「NeovimをCursorのように進化させる - yetone/avante.nvim の導入」を書いた。あの記事では、まるで自分だけの剣を鍛え上げていくように、エディターと共に成長していくPDEの哲学について語った。syu-m-5151.hatenablog.comあれから数ヶ月、私のNeovimはavante.nvimによってCursor + Roo-Codeライクな体験を手に入れ、PDEとしてさらなる進化を遂げた。しかし、告白しなければならないことがある。vimmerを自称しながら、実は日常的にCursorを使っていた。この矛盾と向き合う時が来た。www.cursor.comそして先週の土曜日、私はClaude Codeを使い始めた。今日で1週間。短い期間だが、これが私のPDEに新たな可能性をもたらすことを確信している。そして、Cursor のサブスクを解約してClaude をMAX Planにした。www.youtube.com私は、Claude Code を利用しようと思っているのでvimmer が住む村に帰ろうと思います。一旦、お別れです。 pic.twitter.com/Is5fAUD5hI— nwiizo (@nwiizo) 2025年5月29日   「いいえ、Neovimはもっと強くなれます」前回からの旅路：PDEという哲学前回の記事で、私はこう書いた：Neovimの最大の魅力は、その圧倒的なカスタマイズ性。それは単なるIDE（統合開発環境）ではなく、PDE（Personal Development Environment：個人開発環境）とも呼べる存在です。この言葉は、今思えば預言的だった。PDEという概念は、単にツールをカスタマイズすることではない。それは、開発者が自分自身の思考プロセスと一体化したツールを作り上げることだ。まるで自分だけの剣を鍛え上げていくように、エディターと共に成長していく。そして今、私は気づいた。PDEとは、一人で剣の丘で鉄を鍛つような孤独で崇高な作業なのだと。誰かが用意した完成品ではなく、自分の手で、自分のために、一つ一つ形作っていくもの。avante.nvimは、その第一歩だった。しかし、6ヶ月間Cursor + Roo-Codeを使い込んだことで、私は逆説的にPDEの価値を理解した。Cursor + Roo-Codeは確かに完成度の高い「製品」だ。しかし、私が求めていたのは「作品」—自分の手で育てていけるものだった。実際には育ててなくても育てている感覚があるものだ。正直に告白しよう。vimmerを自称しながらも、実は各所でCursor + Roo-Codeを使っていた。クライアントワークでは生産性を優先してCursor、個人プロジェクトではNeovim。そんな二重生活を送っていた。この矛盾に、私自身も気づいていた。なぜ今、Claude Codeなのか正直に言えば、Claude Codeを使い始めた最大の理由は、Claude Opus 4がリリースされたからだ。最新にして最強のモデル。その能力を、私の愛するターミナル環境で直接使えるなんて—これは試さずにはいられなかった。zenn.devしかし、それだけではない。Claude Codeが掲げる「Terminal Velocity」という概念に、私は強く惹かれた。www.anthropic.com考えてみてほしい。私たちvimmerは、なぜターミナルから離れないのか？それは、思考の流れを断ち切りたくないからだ。GUIアプリケーションへの切り替え、マウスへの手の移動、異なるUIパラダイムへの適応—これらすべてが、私たちの集中を妨げる。Claude Codeは、その問題を根本から解決する。「コンテキストスイッチをゼロにする」—これは、PDEの究極の形かもしれない。そしてもう一つ、個人的に重要だったのがMAX Planという料金体系だ。トークン数無制限。これは貧乏性の私にとって革命的だった。Cursorでは常に「今月あとどれくらい使えるか」を気にしていた。コーディングエージェントでコードを書く前に「これ、AIに聞くほどの価値があるかな？」と躊躇する。そんな心理的ブレーキが、創造性を阻害していたことに気づいた。MAX Planは、その制限から私を解放してくれた。思考のままに、遠慮なくAIと対話できる。まるで無限のメモ帳を手に入れたような感覚だ。「トークンがもったいない」という貧乏性マインドから解放されて初めて、本当の意味でAIとの協働が始まる。これこそが、私のメンタルモデルと完璧に合致した。先週土曜日から使い始めて、まだ1週間。しかし、その短い期間でも、Claude Codeの持つ独特の「控えめな賢さ」に魅了された。Roo-Codeのような積極性はない。しかし、それがかえって心地よい。必要な時に、必要なだけ、的確な支援をしてくれる。Claude Opus 4の高い理解力が、控えめながらも的確なアドバイスを可能にしているのだろう。そして何より、もうトークン数を気にする必要がない。深夜のコーディングセッションで「あと何回質問できるかな...」と計算する必要もない。この精神的な自由度が、私の開発スタイルを根本から変えつつある。zenn.devzenn.devnote.comCursor + Roo-Codeへの敬意、そして決別誤解しないでほしい。私はCursor + Roo-Codeを否定したいわけではない。実際、この6ヶ月間、私は久しぶりにVSCodeベースのCursorをメインエディタとして使い込んだ。そしてそれは、驚くほど素晴らしい体験だった。特にRoo-Codeとの組み合わせで実感したのは、これは単にAIモデルを統合しただけのツールではないということだ。それは開発体験そのものが根本的に違う。github.com考えてみてほしい。従来の開発では、私たちは一つのファイルを開き、一行ずつコードを書いていた。しかしCursor + Roo-Codeの世界では、コードベース全体が一つの有機体として扱われる。「このコンポーネントをリファクタリングして」と言えば、関連する全てのファイルが瞬時に更新される。「このテストを追加して」と言えば、適切なディレクトリに適切な形式でテストが生成される。さらに驚くべきは、Roo-Codeが持つ「意図の理解」だ。曖昧な指示でも、プロジェクトの文脈を読み取り、開発者が本当に必要としているものを推測して提案してくる。それは、経験豊富な同僚とペアプログラミングをしているような感覚だった。これは単なる効率化ではない。これは開発の概念そのものの再定義だった。正直に言えば、これほど生産的な6ヶ月は久しぶりだった。前回の記事でavante.nvimを導入したのも、このCursor + Roo-Codeの革新的な開発体験に触発されたからこそだった。6ヶ月のCursor + Roo-Code体験は、確かに私の開発スタイルを変えた。Tab補完を超えた、AIペアプログラミング。しかし同時に、ある種の違和感も育っていった。それは、自分がコードを「書いている」のか「選んでいる」のか、境界が曖昧になる感覚だった。そして、もう一つの違和感。朝はNeovimで始めたはずが、気がつけばCursorを開いている。締切が迫ると、つい効率的な方を選んでしまう。vimmerとしてのアイデンティティが揺らいでいた。この6ヶ月は、技術的な進歩と同時に、自分自身との葛藤の期間でもあった。Roo-Codeが見せてくれた「開発体験の違い」は革新的だった。しかし、それゆえに気づいたことがある。開発者として長年培ってきた直感が教えてくれる。私たちには「まだ形になっていないアイデアを、コードという形で具現化する」という独特の能力がある。AIはコードを生成できる。しかし、なぜそのコードが必要なのか、それが解決すべき本質的な問題は何かを理解することはできない。そして今、6ヶ月の濃密な体験を経て、私は確信を持って言える—Cursor + Roo-Codeは素晴らしい。その組み合わせは革命的だ。しかし、私にはPDEとしてのNeovimがある。それは単なるエディタではなく、私の思考の延長線上にある道具なのだ。PDEの完成形を目指してしかし、正直に言えば、この6ヶ月はNeovimとCursorの間で揺れ動いていた。月曜の朝は「今週こそNeovimで」と決意するも、水曜には締切に追われてCursorを開く。金曜には罪悪感を感じながらも、Roo-Codeの生産性に頼っていた。vimmerとしての矜持はどこへ行ったのか。だが、この葛藤の中で私は気づいた。PDEとは、単に優れたツールを集めることではない。それは、自分の開発哲学と完全に一致した環境を構築することだ。そして今、NeovimコミュニティはAI時代に適応し、驚くべき進化を遂げている。以下に紹介する3つのプラグインは、その進化の最前線にある。yetone/avante.nvim - 前回の記事で導入したこのプラグインは、Cursor AI IDEの体験をNeovimで完璧に再現する。サイドバーでのAI対話、差分の視覚的表示、ワンクリックでのコード適用など、Cursor + Roo-Codeユーザーが慣れ親しんだ機能をすべて提供する。しかし、それだけではない。Neovimのモーダル編集と完全に統合されているため、思考の流れを妨げることなくAIとの対話を行える。ravitemer/mcphub.nvim - AnthropicのModel Context Protocol (MCP)をNeovimに統合する革新的なプラグイン。MCPサーバーの集中管理により、AIが外部ツールやデータソースにシームレスにアクセスできるようになる。データベースへの直接クエリ、ファイルシステムの操作、外部APIとの連携—これらすべてがNeovimの中で完結する。これこそが、未来のAI開発環境の標準となるだろう。こちらでMCP経由でもclaude-codeを利用している。greggh/claude-code.nvim - Claude Code CLIとNeovimを完全に融合させる野心的なプロジェクト。ターミナル内でClaude Opus 4を含む最新モデルの全能力を解き放ち、まさに「Terminal Velocity」を体現する。:ClaudeCodeコマンド一つで、現在のバッファやプロジェクト全体のコンテキストを理解した上で、最適な提案を行ってくれる。これは単なるプラグインではない—開発体験の再定義だ。これらのツールを組み合わせることで、私のNeovimは単なるテキストエディタから、真のAI統合開発環境へと進化した。もはやCursorを羨む必要はない。むしろ、より深く、より個人的な形でAIと協働できる環境が、ここにある。github.comPDEという哲学の深化PDEとは何か。それは、開発者の思考パターンとツールが完全に一体化した環境だ。前回の記事で初めてこの概念を提示したが、6ヶ月の実践を経て、その意味がより深く理解できるようになった。筆者は専門家ではないため、あくまで個人的な経験に基づく話として聞いていただきたいが、優れたPDEには以下の特徴がある：思考の流れを妨げない：Warp + Neovim + Claude Codeの組み合わせ拡張可能性：新しいツールを取り込める柔軟性個人の哲学の反映：設定ファイルという形での思想の具現化私の~/.config/nvim/lua/plugins/init.luaは、単なる設定ファイルではない。これは私の開発思想の結晶だ。Lazy.nvimを通じて管理されるプラグインの一つ一つが、私の開発哲学を体現している。Cursor + Roo-Codeの体験を経て、その設定はさらに洗練された。そして何より、PDEの構築は一人で剣の丘で鉄を鍛つ行為に似ている。誰も代わりにはできない。自分の手で、自分のために、ひたすら打ち続ける。時に孤独で、時に苦しい。しかし、その先に待っているのは、自分だけの、世界に一つだけの剣だ。Cursor + Roo-Codeが示してくれた新しい開発体験は、確かに革新的だった。しかし、それらは「完成品」だ。一方、PDEとしてのNeovimは「進化し続ける生き物」のようなものだ。私の成長と共に、私の理解と共に、そして私の哲学と共に変化していく。この1週間、Claude Codeを使いながら感じたのは、「これこそが私の求めていたAIとの距離感だ」ということだった。過度に依存せず、しかし必要な時には頼れる。まさに理想的なパートナーシップだ。そして何より、もう環境を使い分ける必要がない。朝から晩まで、クライアントワークも個人プロジェクトも、すべてを私のPDEで完結できる。この統一感が、開発者としての一貫性を取り戻してくれた。おわりに前回の記事から始まった旅は、今、新たな段階に入った。avante.nvimで手に入れたCursor + Roo-Codeライクな体験に、Claude Codeの「Terminal Velocity」が加わることで、私のPDEは更に進化した。興味深いのは、最先端を追求した結果、最も原始的なツール—ターミナルとテキストエディタ—に戻ってきたことだ。しかし、これは後退ではない。これは螺旋的な進化だ。AIとの協働が当たり前になる時代において、私たちに必要なのは、AIとの適切な距離感を保ちながら、共に新たな地平を切り開いていく勇気かもしれない。そして、その第一歩が、自分のPDEを完成させることなのだ。Cursor + Roo-Codeが示してくれた新しい開発体験は、確かに未来の一つの形だ。しかし、それが唯一の答えではない。私たちには、自分自身の開発哲学に基づいて、自分だけの環境を構築する自由がある。「いいえ、Neovimはもっと強くなれます」—この言葉は、単なる願望ではない。それは、PDEという哲学を持つ私たちvimmerの確信なのだ。そして今、Claude Codeの登場により、私はついに二重生活から解放される。もうクライアントワークでCursor、個人でNeovimという使い分けをする必要はない。私のPDEが、すべての開発シーンで通用する強さを手に入れたのだから。そして、PDEの構築とは、一人で剣の丘で鉄を鍛つような営みだ。誰かが用意した剣ではなく、自分の手で打ち、自分の手で研ぎ、自分だけの刃を作り上げる。その過程こそが、私たちを真の開発者にするのかもしれない。この記事を書いている間、私はWarpターミナル上でNeovimとClaude Codeを行き来している。前回のavante.nvim導入から数ヶ月、そして Claude Code導入から1週間。私のPDEは確実に進化した。Lazy.nvimの設定ファイルは公開しているので、興味があれば参考にしてほしい。「Terminal Velocity」を「ターミナルベロシティ」とカタカナ表記したのは、この概念の持つ物理学的な含意—終端速度、つまり最高効率—を日本語でも感じてもらいたかったからだ。「Cursor + Roo-Codeのサブスクリプションを払い続けるか、vimの学習コストを払うか」—これは単なる経済的判断ではない。私たちが開発という行為にどう向き合うか、そしてPDEという哲学をどこまで追求するかという、実存的な選択なのかもしれない。6ヶ月のCursor + Roo-Code体験は本当に素晴らしかった。特にRoo-Codeが示してくれた「開発体験の違い」は、私の開発観を根本から変えた。もしあなたがまだ試していないなら、一度は体験する価値がある。その上で、自分にとっての最適な開発環境を選ぶべきだ。私にとって、それはPDEとしてのNeovimだった。この二重生活は疲れるものだった。.vimrcと.vscode/settings.jsonを行き来し、キーバインドの違いに戸惑い、どちらが本当の自分なのか分からなくなることもあった。しかし、その経験があったからこそ、今の決断に至ることができた。あなたも、vimmer村への帰郷を考えてみてはどうだろうか。Claude Codeという新しい仲間と共に、自分だけのPDEを完成させるために。VimConf 2025 Smallにも行こうかな…。今度こそ、胸を張って「私はvimmerです(え、Neovim ですよね？)」と言えるように。vimconf.org実践Vim　思考のスピードで編集しよう！ (アスキー書籍)作者:Ｄｒｅｗ Ｎｅｉｌ,新丈 径角川アスキー総合研究所Amazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GoogleのAI Agent]]></title>
            <link>https://speakerdeck.com/shukob/googlenoai-agent</link>
            <guid>https://speakerdeck.com/shukob/googlenoai-agent</guid>
            <pubDate>Fri, 30 May 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[2025年5月30日(金) AI Agent 勉強会 Vol.3 にて、Google CloudのAI AgentサービスとGoogle I/O 2025 で発表された内容の概要を紹介させていただきました。https://almondo.connpass.com/event/355297/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[宝くじに当たる方法を思い出して、明日も頑張ることにした]]></title>
            <link>https://blog.atusy.net/2025/05/30/how-to-win/</link>
            <guid>https://blog.atusy.net/2025/05/30/how-to-win/</guid>
            <pubDate>Fri, 30 May 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[宝くじに当たりたければ、まず買うことだ。成功も行動の先にある。宝くじと違って、うまくいかなかった時も戦略を練り直せるから、どんどん挑戦しよう。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google Cloud 認定資格奮闘記 ~Generative AI Leader編~]]></title>
            <link>https://zenn.dev/akasan/articles/c0d347a37065bc</link>
            <guid>https://zenn.dev/akasan/articles/c0d347a37065bc</guid>
            <pubDate>Thu, 29 May 2025 13:24:41 GMT</pubDate>
            <content:encoded><![CDATA[この記事の続編になります。https://zenn.dev/akasan/articles/e2416e40a90499 Generative AI LeaderについてGenerative AI Leader（以下、GenAI Leader）は、今月公開された新しいGoogle Cloudの認定資格です。こちらの資格については公式で以下のように説明がされています。A Generative AI Leader is a visionary professional with comprehensive knowledge of how generative AI (gen A...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイク、「KubeCon + CloudNativeCon Japan 2025」にGoldスポンサーとして協賛およびブース出展]]></title>
            <link>https://sreake.com/blog/kubecon-cloudnativecon-japan-2025/</link>
            <guid>https://sreake.com/blog/kubecon-cloudnativecon-japan-2025/</guid>
            <pubDate>Thu, 29 May 2025 01:00:00 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）は、 2025年6月16日（月）・17日（火）に開催される「KubeCon + CloudNativeCon Japan 2025」にGoldスポンサーとして協賛します。The post スリーシェイク、「KubeCon + CloudNativeCon Japan 2025」にGoldスポンサーとして協賛およびブース出展 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Dockerを使用せずにイメージを作成し実行してみる – go-containerregistryによる実装]]></title>
            <link>https://sreake.com/blog/image-creation-and-execution-with-go-containerregistry/</link>
            <guid>https://sreake.com/blog/image-creation-and-execution-with-go-containerregistry/</guid>
            <pubDate>Thu, 29 May 2025 00:40:36 GMT</pubDate>
            <content:encoded><![CDATA[この記事ではコンテナイメージがどのように作成されているのかを、go-containerregistryライブラリを使った実装例を通して解説します。Dockerfileを使わずに、プログラムからコンテナイメージを作成する過 […]The post Dockerを使用せずにイメージを作成し実行してみる – go-containerregistryによる実装 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[セルフエンドレスアドベントカレンダーを通してエンジニアとして成長できました報告]]></title>
            <link>https://zenn.dev/akasan/articles/4aba4d3a0616ce</link>
            <guid>https://zenn.dev/akasan/articles/4aba4d3a0616ce</guid>
            <pubDate>Wed, 28 May 2025 12:47:33 GMT</pubDate>
            <content:encoded><![CDATA[今回は、私が仕事とも関係なく勝手にやっているセルフエンドレスアドベントカレンダーを通して、どう成長していると感じているか共有しようと思います。今回は技術的な話はあまりないですが、仕事以外の時間をどう使うかについて共有できればと思います。 そもそもアドベントカレンダーとは？というか、そもそもアドベントカレンダーとは何かについて理解しておかないといけないですね、、、。Wikipediaによるとインターネット上などで、12月の1日から25日までに、特定のテーマに沿って毎日ブログなどに記事を投稿していくという企画がある[1][2]。元々のアドベントカレンダーになぞらえて、この企画も...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイク、Google Cloud Next Tokyo にDiamondスポンサーとして協賛]]></title>
            <link>https://sreake.com/blog/google-cloud-next-tokyo-2025/</link>
            <guid>https://sreake.com/blog/google-cloud-next-tokyo-2025/</guid>
            <pubDate>Wed, 28 May 2025 06:27:59 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）は、2025 年 8 ⽉ 5 日（火）~  6 ⽇（水）に東京ビッグサイトにて開催される Google Cloud Next Tokyo  (主催：グーグル・クラウド・ジャパン合同会社) にDiamondスポンサーとして協賛いたします。The post スリーシェイク、Google Cloud Next Tokyo にDiamondスポンサーとして協賛 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AIコードエディタは開発を変えるか？Cursorをチームに導入して1ヶ月経った本音]]></title>
            <link>https://speakerdeck.com/ota1022/aikodoedeitahakai-fa-wobian-eruka-cursorwotimunidao-ru-site1keyue-jing-tutaben-yin</link>
            <guid>https://speakerdeck.com/ota1022/aikodoedeitahakai-fa-wobian-eruka-cursorwotimunidao-ru-site1keyue-jing-tutaben-yin</guid>
            <pubDate>Wed, 28 May 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[2025年5月28日 Qiita Bash 最近ハマっている生成AI活用法を語ろう！のLT登壇資料です。https://increments.connpass.com/event/351227/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ディレクトリ構成 ~フィーチャーベース編~]]></title>
            <link>https://sreake.com/blog/feature-based-directory-structure-good-practice/</link>
            <guid>https://sreake.com/blog/feature-based-directory-structure-good-practice/</guid>
            <pubDate>Wed, 28 May 2025 02:18:09 GMT</pubDate>
            <content:encoded><![CDATA[はじめに アプリケーション開発において、ディレクトリ構成は保守性・拡張性・開発効率に直結する設計要素です。 本記事では、以下のような課題に悩む現場に向けて、「機能ごとに整理しやすく、拡張にも強い」フィーチャーベース構成を […]The post ディレクトリ構成 ~フィーチャーベース編~ first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[RedisのPub/Subを使用したリアルタイム通知の実現]]></title>
            <link>https://sreake.com/blog/realtime-notification-with-redis-pubsub/</link>
            <guid>https://sreake.com/blog/realtime-notification-with-redis-pubsub/</guid>
            <pubDate>Wed, 28 May 2025 01:18:04 GMT</pubDate>
            <content:encoded><![CDATA[はじめに Sreake事業部のアプリケーションエンジニアの角谷です。 リアルタイム通信を実現する手段は様々ありますが、その一つにPub/Subがあります。 Pub/Subを実装する方法は様々ありますが、今回はRedisを […]The post RedisのPub/Subを使用したリアルタイム通知の実現 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Nix Meetup #3 大阪に参加した]]></title>
            <link>https://blog.atusy.net/2025/05/28/nix-meetup-3-in-osaka/</link>
            <guid>https://blog.atusy.net/2025/05/28/nix-meetup-3-in-osaka/</guid>
            <pubDate>Wed, 28 May 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Nix meetup #3 大阪が2025-05-24に開催されました。技術への愛溢れた濃いい話がいっぱいできてよかったです。いっぱい聞けて、じゃなくてできてってところがまた素敵。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：thefuck]]></title>
            <link>https://zenn.dev/akasan/articles/fff0cfa9beadbc</link>
            <guid>https://zenn.dev/akasan/articles/fff0cfa9beadbc</guid>
            <pubDate>Tue, 27 May 2025 11:22:06 GMT</pubDate>
            <content:encoded><![CDATA[今回から、私が普段使ってるコマンドを紹介していくシリーズを始めたいと思います。記念すべき第一回は、thefuckというコマンドを紹介します。名前だけ見るとなかなかにパンチが効いたものですが、スター数も多いコマンドですので、ぜひ興味がある方はみてください。※ 本記事を書くにあたり、果たしてこの文字を入力して良いのか迷いましたが、①あくまでコマンド紹介であること、②他の記事で4文字が入っている記事も結構ありそうだったので採用しました thefuckとは？一言で言ってしまうと、コマンド入力をミスした時に、本来実行したかったコマンドを想定して出してくれるコマンドになります。例えば...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイク、「開発生産性Conference 2025」にGoldスポンサーとして協賛およびブース出展・登壇]]></title>
            <link>https://sreake.com/blog/developer-productivity-conference-2025/</link>
            <guid>https://sreake.com/blog/developer-productivity-conference-2025/</guid>
            <pubDate>Tue, 27 May 2025 01:00:00 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）は、 2025年 7月3日（木）4日（金）に開催される「開発生産性Conference 2025」にGoldスポンサーとして協賛します。The post スリーシェイク、「開発生産性Conference 2025」にGoldスポンサーとして協賛およびブース出展・登壇 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[alphaXivを使って論文要約してみた]]></title>
            <link>https://zenn.dev/akasan/articles/feaca6271b5f0c</link>
            <guid>https://zenn.dev/akasan/articles/feaca6271b5f0c</guid>
            <pubDate>Mon, 26 May 2025 13:01:26 GMT</pubDate>
            <content:encoded><![CDATA[今回は、先日Xにて見つけたalphaXivというものを使って、arXiv上の論文を要約する方法を調べてみました。 alphaXivとは？alphaXivとは、arXiv上にアップロードされている論文を要約できるサービスです。自分の指定した論文を要約できるだけでなく、コミュニティを作成・参加したりおすすめの論文を一覧に出してもらったりと、様々なことを実施できます。また、なんと言っても一番の特徴が、要約に利用されるLLMに関して料金がかからないところです。記事執筆時点ではaplhaXivで利用されるLLMについて無料で使えており、このサービスが無料で使えるのが不思議ですw。http...]]></content:encoded>
        </item>
    </channel>
</rss>