<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Sat, 07 Jun 2025 22:34:59 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：eza]]></title>
            <link>https://zenn.dev/akasan/articles/5870bda267256b</link>
            <guid>https://zenn.dev/akasan/articles/5870bda267256b</guid>
            <pubDate>Sat, 07 Jun 2025 08:24:02 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第6回は、ezaというコマンドを紹介します。ezaはlsコマンドのモダンな代替コマンドとなっております。どのように使うかについて紹介していきたいと思います。なお、前回の記事などもぜひ参照してもらえると嬉しいです。https://zenn.dev/akasan/articles/a57b277ee7af27 ezaとは？ezaとは公式ページの言及をみるとeza is a modern alternative for the venerable file-listing command-line program ls that ships with Unix...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[zshのコマンド履歴みてみた]]></title>
            <link>https://zenn.dev/akasan/articles/6333702fc35afc</link>
            <guid>https://zenn.dev/akasan/articles/6333702fc35afc</guid>
            <pubDate>Fri, 06 Jun 2025 13:41:14 GMT</pubDate>
            <content:encoded><![CDATA[今回は、私の使っているzshに蓄えられた過去のコマンド履歴について、何を一番使ってきたのかをただ確認したかったので確認するためのコードを書いたという内容を共有します。 実装開始！！！ .zsh_historyのフォーマット意外と~/.zsh_historyを直接みたことがある人は少ないのではないでしょうか？かくいう自分も今回はじめてみました。ファイルは以下のようになっています。以下は最初の20行をお見せしています。このようなフォーマットになっており、実行したコマンドは基本的には;の直ごに来ていそうなので、実装ではその部分を取り出すようにしました。: 1702554011:0;...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Oracle Database＠Google Cloudの紹介～ついに日本のリージョンも使えるようになったぞ！～]]></title>
            <link>https://sreake.com/blog/oracle-database-google-cloud-japan-launch/</link>
            <guid>https://sreake.com/blog/oracle-database-google-cloud-japan-launch/</guid>
            <pubDate>Fri, 06 Jun 2025 10:48:27 GMT</pubDate>
            <content:encoded><![CDATA[2025年4月のGoogle Cloud Nextでの発表から2か月、ついにOracle Database＠Google CloudがTokoy・Osakaリージョンで利用可能になりました。 Oracle Databas […]The post Oracle Database＠Google Cloudの紹介～ついに日本のリージョンも使えるようになったぞ！～ first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Claude Code の CLAUDE.mdは設定した方がいい]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/06/190847</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/06/190847</guid>
            <pubDate>Fri, 06 Jun 2025 10:08:47 GMT</pubDate>
            <content:encoded><![CDATA[[社内共有版「Claude Code、どこまでも」]はじめにClaude Codeを使い始めて1週間。私の開発スタイルは完全に変わった。きっかけは3ヶ月前に書いた「生成AIといっしょ: 動作するきれいなコードを生成AIとつくる」という記事だった。当時はAIとの協業について考察していたが、正直なところ、まだ私が「運転席」に座っているつもりでいた。AIはあくまで「副操縦士」だと。syu-m-5151.hatenablog.com現実は違った。実際にClaude Codeを使ってみて最初に感じたのは、自分の開発スタイルとAIの特性のミスマッチだった。私は根っからの「とりあえずコード書いてみよう」タイプ。設計書？計画？そんなものは書きながら考えればいい—それが私の流儀だった。ところが、AIは違う。指示に対して忠実すぎるのだ。「認証機能を実装して」と曖昧に伝えれば、私の意図とは全く違う方向に突き進んでしまう。かといって、毎回細かく指示を出すのは面倒すぎる。この問題を解決したのがCLAUDE.mdという設定ファイルだった。プロジェクトの文脈、コーディング規約、よく使うコマンド—すべてをAIが理解できる形で記述しておける。これにより、3ヶ月前に理論として描いていた「助手席からの開発」が現実のものとなった。私が大まかな方向を示せば、AIが詳細を埋めてくれる。計画嫌いの私にとって、これほど相性の良いツールはなかった。先日の記事でClaude Codeの基本的な使い方は紹介したが、今回はCLAUDE.mdに焦点を当てて深掘りしたい。実際のプロジェクトで使っている設定を公開し、どのようなワークフローで開発しているかを具体的に示す。syu-m-5151.hatenablog.comもしまだClaude Codeを触ったことがないなら、公式チュートリアルから始めることをお勧めする。また、Anthropicのベストプラクティスも必読だ。本記事はこれらの内容を前提として、より実践的な活用方法を掘り下げていく。docs.anthropic.comwww.anthropic.com全体的に疲れている時の~/.claude/settings.json と~/.claude/CLAUDE.md · GitHub 私の標準の設定もしているのでぜひ、読んでみてもらいたいです。※この記事は社内勉強会で発表した内容をベースに、外部公開用に再構成したものです。CLAUDE.mdとは何か毎回Claude Codeを起動するたびに「うちのプロジェクトはTypeScriptで、ESLintはこの設定で、テストはVitestを使っていて...」と説明するのは面倒だ。チームメンバーが同じプロジェクトで作業する時、全員が同じ説明を繰り返すのも非効率的だ。この問題を解決するのがCLAUDE.mdという特別なファイルだ。何も考えたくなければとりあえず、起動して/initと入力すれば良い。それで終わり。CLAUDE.mdは、Claude Codeが起動時に自動的に読み込む設定ファイルで、プロジェクトの文脈をAIに伝える役割を持つ。アーキテクチャの説明、コーディング規約、よく使うコマンドなど、プロジェクトで必要な情報をすべて記載しておける。一度書けば、毎回の説明が不要になる。docs.anthropic.com実は、CLAUDE.mdには配置場所によって3つの種類がある。最も基本的なのは、プロジェクトルート（./CLAUDE.md）に配置するプロジェクトメモリだ。これはGit管理してチーム全体で共有する。プロジェクトのアーキテクチャ、使用している技術スタック、開発フローなど、チーム全員が守るべきルールを記載する。私の経験では、ここに書く内容がプロジェクトの品質を大きく左右する。次に、ホームディレクトリ（~/.claude/CLAUDE.md）に配置するユーザーメモリがある。これは個人的な設定で、すべてのプロジェクトに適用される。例えば「console.logではなく必ずloggerを使う」といった個人的なコーディングスタイルや、よく使うスニペットを登録しておける。私はここに「コミットメッセージは必ず日本語で書く」という設定を入れている。3つ目の./CLAUDE.local.md（プロジェクトメモリ・ローカル）は現在非推奨となっており、代わりにインポート機能を使うことが推奨されている。Claude Codeがこれらのファイルをどう探すかも理解しておくと便利だ。現在のディレクトリから上位に向かって再帰的に探索し、見つかったものをすべて読み込む。さらに、サブディレクトリ内のCLAUDE.mdも、そのディレクトリのファイルを扱う時に自動的に参照される。つまり、モジュールごとに固有の設定を持たせることも可能だ。これらのメモリファイルは/memoryコマンドで確認・編集できる。ただ、複数のCLAUDE.mdを一度に確認したい場合もあるので、そのためのツール（ccat）も作成した。プロジェクトが大きくなるとCLAUDE.mdも複雑になるので、こういったツールがあると管理が楽になる。github.com探索・計画・コード・コミットのワークフローAnthropicのベストプラクティスでは、このワークフローが推奨されている。最初は「面倒くさそう」と思ったが、実際にやってみると驚くほど効果的だった。計画が苦手な私がこのワークフローを採用する理由私の開発スタイルは昔から一貫している。アイデアが浮かんだらすぐコードを書き始める。設計？後から考えればいい。ドキュメント？動いてから書けばいい。アイデアのつくり方作者:ジェームス W.ヤングCCC MEDIA HOUSEAmazonこのスタイルで10年以上やってきた。そして正直、それなりにうまくいっていた。でもClaude Codeは違った。曖昧な指示を与えると、想像もしない方向に突き進む。「ユーザー認証を実装して」と伝えたら、JWTトークンを使った本格的なOAuth2.0実装を始めてしまった。私が欲しかったのは、シンプルなセッション認証だったのに。そこで気づいた。AIは私の頭の中を読めない。当たり前だが、これが想像以上に大きな問題だった。だからこそ、このワークフローが必要なのだ。探索→計画→実装→コミットという流れは、私の頭の中を整理し、AIに正確に伝えるための仕組みだった。面白いことに、AIのために始めたこの習慣が、私自身のコードの質も向上させた。なぜこのワークフローが効果的なのか「とりあえずコードを書く」スタイルの最大の問題は、全体像が見えないまま進むことだ。気づいたら収拾がつかなくなっている。リファクタリングしようにも、影響範囲が分からない。このワークフローはその問題を解決する。各段階を明確に分けることで、思考が整理される。そして何より、AIが各段階で最適な支援をしてくれる。ステップ1: 探索（関連ファイルの読み込み）最初にやるのは現状把握だ。変更したいコードがどこでどう使われているか、依存関係はどうなっているか。これを理解せずに始めると、後で必ず痛い目を見る。私がよく使うコマンド：@src/services/UserService.ts を読んで、まだコードは書かないで「まだコードは書かないで」という制約が重要だ。これを付けないと、AIは親切心から勝手に実装を始めてしまう。依存関係を調べるときは：UserServiceが依存している他のサービスも確認して複雑なプロジェクトでは、サブエージェントを使うこともある：サブエージェントで、UserServiceのメソッドがどこから呼ばれているか調査してこの探索フェーズで全体像を掴む。急がば回れ、というやつだ。ステップ2: 計画（think モードの活用）探索が終わったら、次は計画だ。ここでClaude Codeの「思考モード」が威力を発揮する。問題の複雑さに応じて使い分ける：このアーキテクチャをthinkで分析して、改善計画を立ててより複雑な問題には：この認証システムの問題をthink hardで検討して、複数の解決策を提示してシステム全体に関わる変更なら：システム全体への影響をthink harderで評価して最近は日本語でも「深く考えて」で動作するようになったらしい。個人的には英語の方が確実だと思うが。zenn.dev計画ができたら必ず文書化する：作成した計画をarchitecture-decisions/001-user-service-refactoring.mdに保存してこの文書化が後で自分を救う。「なぜこの設計にしたんだっけ？」という疑問に即答できる。ステップ3: 実装（検証を含む）計画ができたら、いよいよ実装だ。でも、一気に全部作らない。小さく始めて、段階的に拡張する。計画に従って、まずUserServiceの基本的なリファクタリングを実装して実装したら必ず検証：実装した部分のユニットテストを実行して、既存の機能が壊れていないか確認してエッジケースも忘れずに：nullやundefinedの場合の処理を追加して、エラーハンドリングを強化して途中で問題に気づいたら、軌道修正を恐れない：この実装だと循環依存が発生しそう。別のアプローチを検討して私の経験では、この段階的な実装が品質を大きく左右する。一気に作ると、どこで問題が起きたか分からなくなる。ステップ4: コミットとPR作成最後の仕上げがコミットとPR作成だ。ここも手を抜かない。コミットは論理的な単位で分ける：変更をリファクタリング、機能追加、テスト追加の3つのコミットに分けてコミットメッセージはConventional Commitsに従う：feat: ユーザーサービスに新しい認証メソッドを追加refactor: UserServiceの内部構造を改善test: UserServiceの新機能に対するテストを追加PRの説明は詳細に：PRを作成して。以下を含めて：- 変更の背景と目的- 実装アプローチの説明- テスト方法- 破壊的変更の有無- レビュアーへの注意点最後にドキュメントの更新も忘れずに、これらはCLAUDE.mdに記載してもよいREADME.mdとCLAUDE.mdも更新して、新しい機能とその使い方を記載してこのワークフローを続けた結果、コードの品質が明らかに向上した。何より、「なんとなく動く」コードから「なぜ動くか説明できる」コードになった。計画嫌いの私でも、このワークフローの価値は認めざるを得ない。テスト駆動開発（TDD）ワークフローの深掘りTDDについて正直に話そう。3ヶ月前の記事では理想論を書いた。でも現実は全然違う。正直なところ、TDDはいつも使うわけじゃない私のTDD使用率は、せいぜい10%くらいだ。5%ぐらいかもしれない。なぜそんなに低いのか。理由は単純で、私は「作りながら考える」タイプだから。最初から仕様が決まっていることなんて、実際に私がやっているような開発ではほとんどない。要求があるだけです。顧客も「動くものを見てから判断したい」と言うし、私も「とりあえず動かしてみないと分からない」と思っている。でもClaude Codeを使い始めて、面白い発見があった。AIこそがTDDを必要としているのだ。「また生き返ったのかTDD」と思うかもしれない。でも今回は違う。人間のためのTDDではなく、AIのためのTDDだ。TDDがAIコーディングで特に重要な理由AIの問題は「親切すぎる」ことだ。テストがないと、頼んでもいない機能まで実装してしまう。「ユーザー認証を実装して」と言ったら、ログイン履歴機能やパスワードリセット機能、二要素認証まで作り始める。テストがあれば違う。「このテストが通ればOK」という明確なゴールがある。AIは迷わない。過剰な実装もしない。これが快適だ。私がTDDを使う「よっぽど決まっているとき」では、具体的にどんな時にTDDを使うのか。1. APIのインターフェースが確定したときOpenAPI仕様書がある場合は迷わずTDDだ。リクエストとレスポンスの型が決まっていて、エラーケースも定義されている。こういう時は最初にテストを書く方が早い。2. 既存機能のリファクタリング「動作を変えずに内部構造を改善する」という明確な目標がある。現在の動作をテストで固定してから、安心してリファクタリングできる。3. バグ修正「このバグ、二度と出したくない」という強い決意がある時。再現手順が明確で、期待される動作も分かっている。テストを書いてから修正すれば、同じバグは二度と起きない。つまり、ゴールが明確な時だけTDDを使う。探索的な開発では使わない。これが私の現実的なアプローチだ。ステップ1: テストファーストAIとTDDを組み合わせる時、最初のテスト作成が肝心だ。例えば、ユーザー認証機能を作る場合：UserService.authenticateメソッドのテストを作成して。以下のケースをカバー：- 正常な認証成功- パスワード不一致- ユーザーが存在しない- アカウントがロックされている- 連続失敗によるロックポイントは「網羅的に書く」こと。人間なら「まあこれくらいでいいか」と手を抜くところも、AIは真面目に全部実装してくれる。あと、個人的にはモックを使わない派だ：実際のデータベース接続を使用してテストを作成。モックは使わないモックを使うと、実際の動作と乖離することがある。開発環境でDockerを使えば、本物のデータベースでテストできる。遅い？確かに。でも「動くと思ったのに本番で動かない」よりマシだ。あと同時に大切なのが本番環境を絶対に触らせないことです。ステップ2: RED - 失敗の確認テストを書いたら、必ず失敗することを確認する。これ、意外と重要。npm test -- UserService.test.ts失敗を見たら、AIに分析してもらう：テストの失敗理由を分析して。以下の観点で：- コンパイルエラーか実行時エラーか- 期待値と実際の値の差異- 未実装による失敗か、バグによる失敗かなぜわざわざ失敗を確認するのか。「最初から成功するテスト」は信用できないからだ。それはテストが甘いか、既に実装されているかのどちらかだ。ステップ3: GREEN - 最小限の実装ここでAIの「親切心」と戦う必要がある。テストが通る最小限の実装を作成して。過度な最適化や追加機能は含めないそれでもAIは余計なことをしたがる。だから明示的に制約する：IMPORTANT: テストケース以外の機能は実装しないYOU MUST: 各実装ステップ後にテストを実行して確認段階的に進めるのもコツだ：まず最も単純なケース（正常な認証）から実装を始めて一気に全部作らせると、どこで問題が起きたか分からなくなる。ステップ4: REFACTOR - コードの改善テストが通ったら、ようやくリファクタリングだ。ここでAIの本領発揮。テストが通ることを確認しながら、以下の観点でリファクタリング：- 重複コードの除去- 可読性の向上- パフォーマンスの最適化- ドキュメントの記載(README.md,CLAUDE.md,etc)- コメントの記載個人的には、このタイミングでドキュメントを書いてもらうことが多い。実装が終わってからだと、細かい仕様を忘れてしまうから。時には複数の改善案を比較することも：このコードの問題点を指摘して、改善案を3つ提示してAIは客観的に問題点を指摘してくれる。人間のレビュアーと違って、遠慮がない。便利なショートカットとツールClaude Codeには知らないと損するショートカットがたくさんある。docs.anthropic.com@ ファイル選択の効果的な使い方最も使うのが@によるファイル選択だ。基本形：@src/services/UserService.ts のcreateUserメソッドを改善してでも、本当の威力は複数ファイルを扱う時に発揮される：@src/services/UserService.ts と @src/models/User.ts を見て、データフローを説明してAIが関連ファイルを横断的に分析してくれる。人間だと「えーと、このファイルとあのファイルを開いて...」となるところが、一瞬で終わる。ディレクトリ全体を見ることも：@src/services/ ディレクトリのすべてのサービスの概要を説明して私のお気に入りはワイルドカード：@**/*Service.ts すべてのサービスファイルで共通のパターンを見つけてリファクタリングの時、これで共通化できる部分を見つけてもらう。通知設定これ、本当に知らない人が多い。Claude Codeは長時間のタスクも黙々とこなしてくれるが、通知設定をしていないと完了に気づけない。docs.anthropic.com私は「タスク完了時に音を鳴らす」設定にしている。コーヒーを飲みながら待てる。# ルール追加の戦略的活用その場限りのルールを追加したい時は#を使う：#このプロジェクトではzodでバリデーション。yupは使わない#エラーメッセージは必ず日本語で記述#APIレスポンスは必ずcamelCaseで統一CLAUDE.mdに書くほどでもない、一時的なルールに便利だ。例えば「今日は英語のコメントで統一」みたいな時に使う。ルールの優先順位は：1. セッション中の#コマンド（最優先）2. プロジェクトのCLAUDE.md3. ユーザーのCLAUDE.md（~/.claude/）この階層を理解していると、柔軟にルールを管理できる。スクショを使う、CleanShot Xを購入せよ私のTDD使用率コードだけでなく、ビジュアルでの確認も重要だ。特にUI開発では必須。なぜCleanShot XなのかmacOSの標準スクリーンショットも悪くない。でもCleanShot Xは別次元だ。cleanshot.com何が違うか：- 撮影後すぐに注釈を追加できる（矢印、テキスト、モザイク）- スクロールキャプチャで長いページも1枚に- GIF録画で操作手順を記録- クラウドにアップロードしてURLで共有特に「注釈」機能が神。「ここのマージンがおかしい」とか「このボタンの色を変えて」とか、視覚的に伝えられる。Claude Codeとの連携テクニック私のワークフロー：CleanShot Xでスクリーンショット（Cmd+Shift+4）問題箇所に赤丸や矢印で注釈Claude Codeにドラッグ&ドロップ例えば：このデザインモックアップに基づいてコンポーネントを実装して画像を見せながら指示すると、AIの理解度が格段に上がる。「左側のサイドバーの幅を...」とか説明するより、画像1枚の方が早い。バグ報告でも威力を発揮：このエラー画面が表示される原因を調査して修正してエラーメッセージだけでなく、画面全体の状態を伝えられる。セッション管理とコンテキストの継続性「昨日の続きから作業したいけど、どこまでやったっけ？」この問題、Claude Codeなら解決できる。でも意外と知られていない。継続的な開発フローの構築朝一番のコマンド：$ claude --continueこれで前回のセッションの続きから始められる。AIは前回の作業内容を覚えている。特定のセッションを選びたい時：$ claude --resume複数のプロジェクトを並行して進めている時に便利。プロンプト履歴の編集:[Esc][Esc] → 前のプロンプトを編集 → EnterダブルEscapeで過去のプロンプトを編集可能。異なるアプローチを試すときに便利。具体的な指示を心がける。私の日課は、1日の終わりに：今日の作業内容を要約して、明日やるべきことをリストアップしてこれをやっておくと、翌日スムーズに始められる。AIが秘書みたいに働いてくれる。コンテキストの最適化長時間作業していると、コンテキストがゴチャゴチャしてくる。そんな時は：/clearでリセット。その後：@CLAUDE.md を読んで、プロジェクトのコンテキストを復元してこれで必要な情報だけを再読み込みできる。「お前は公式ドキュメントを読んでないな！？」と言いたくなるくらい、みんなこの機能を知らない。もったいない。3ヶ月前の理論が現実になって3ヶ月前、私は生成AIとの未来について妄想を書いた。「助手席での開発」「レッドボックス」「バイブスコーディング」...正直、半分くらいは願望だった。 speakerdeck.comでも、Claude Codeを1週間使った今、それらは全て現実になっている。いや、想像以上だった。助手席での開発が意外と楽しい「運転席を譲る」ことへの恐怖があった。エンジニアとしてのアイデンティティが揺らぐような気がして。でも実際は違った。助手席は助手席で、やることがたくさんある。私の役割：目的地を決める（何を作るか）ルートを提案する（アーキテクチャ）危険を察知する（セキュリティ、パフォーマンス）Claudeの役割：実際の運転（コーディング）交通ルールの遵守（言語仕様、ベストプラクティス）効率的なルート選択（アルゴリズム、最適化）この役割分担が心地いい。特に「計画は苦手だけどアイデアは豊富」な私にとって、理想的なパートナーだ。レッドボックスとの遭遇実際にあった話。Claude Codeがこんなコードを生成した：// Claudeが生成した謎のTypeScript型パズルtype DeepPartial<T> = T extends object ? {  [P in keyof T]?: DeepPartial<T[P]>;} : T;type RecursiveRequired<T> = T extends object ? {  [P in keyof T]-?: RecursiveRequired<T[P]>;} : T;正直、5秒見つめても理解できなかった。これが「レッドボックス」だ。でも大丈夫。CLAUDE.mdに追加すればいい：## 理解困難なコードへの対処- IMPORTANT: 複雑な型定義には必ず使用例とコメントを追加- YOU MUST: 生成したコードの動作原理を説明できることこれで次からは、AIが勝手に説明を追加してくれる。バイブスコーディングの実践これが一番楽しい発見だった。曖昧な指示でも、AIは文脈を読んでくれる：なんか認証周りがイケてない気がする。もっとスマートにしてこのUIのレイアウト、もうちょっとモダンな感じにしてパフォーマンスがビミョーだから、なんとかして「ビミョー」で伝わるAI。これがCLAUDE.mdの威力だ。プロジェクトの文脈を理解しているから、曖昧な指示でも適切に解釈してくれる。実践的なCLAUDE.md設定例理論はもういい。実際のCLAUDE.mdを見せよう。私が開発しているcctxプロジェクトから、効果的な部分を抜粋する。プロジェクト概要：読みやすさの工夫# 🔄 CLAUDE.md - cctx Project Documentation## 📋 Project Overview**cctx** (Claude Context) is a fast, secure, and intuitive command-line tool for managing multiple Claude Code `settings.json` configurations. Built with Rust for maximum performance and reliability.## 🏗️ Architecture### 🎯 Core Concept- **🔧 Context**: A saved Claude Code configuration stored as a JSON file- **⚡ Current Context**: The active configuration (`~/.claude/settings.json`)- **📁 Context Storage**: All contexts stored in `~/.claude/settings/`- **📊 State Management**: Current and previous context tracked in `.cctx-state.json`絵文字を使っているのは、人間（つまり私）が見た時に分かりやすいから。AIは絵文字なくても理解するが、私が理解できない。AIへの具体的な指示：成功の秘訣曖昧な指示より具体的な指示の方が成功率が大幅に向上します。曖昧さは、AIには毒だ。## 📚 Notes for AI AssistantsWhen working on this codebase:1. **Always run `cargo clippy` and fix warnings** before suggesting code2. **Test your changes** - don't assume code works3. **Preserve existing behavior** unless explicitly asked to change it4. **Follow Rust idioms** and best practices5. **Keep the kubectx-inspired UX** - simple, fast, intuitive6. **Maintain predictable defaults** - user should never be surprised7. **Document any new features** in both code and README8. **Consider edge cases** - empty states, missing files, permissionsRemember: This tool is about speed and simplicity. Every feature should make context switching faster or easier, not more complex. **Predictability beats cleverness.**最後の一文が効いている。「賢いより予測可能」。AIは時々、賢すぎる解決策を提案してくる。でもユーザーが求めているのは、予測可能な動作だ。開発ガイドライン：チェックリストの威力### Testing ChecklistWhen testing changes, verify:- [ ] `cctx` lists all contexts correctly- [ ] `cctx <n>` switches context- [ ] `cctx -` returns to previous context- [ ] Error messages are clear and helpful- [ ] State persistence works across sessionsチェックリスト形式にすると、AIもチェックしながら作業してくれる。レビュー時も楽。プロンプト改善のテクニックAnthropic公式が推奨する強調表現、実は3段階ある。使い分けが重要だ。強調レベルの使い分けNEVER（絶対禁止）：NEVER: パスワードやAPIキーをハードコーディングしないNEVER: ユーザーの確認なしにデータを削除しないNEVER: テストなしで本番環境にデプロイしないこれは本当にやってはいけないこと。AIは素直なので、明示的に禁止しないとやってしまう可能性がある。YOU MUST（必須事項）：YOU MUST: すべての公開APIにドキュメントを記載YOU MUST: エラーハンドリングを実装YOU MUST: 変更前に既存テストが通ることを確認必ずやってほしいこと。でも、状況によっては例外もありえる。IMPORTANT（重要事項）：IMPORTANT: パフォーマンスへの影響を考慮IMPORTANT: 後方互換性を維持IMPORTANT: セキュリティベストプラクティスに従う考慮してほしいこと。判断はAIに委ねる。この3段階を使い分けることで、AIの行動を適切にコントロールできる。高度な活用：並行開発とCI/CDカスタムスラッシュコマンドで定型作業を自動化公式例：GitHub Issue対応の自動化.claude/commands/fix-github-issue.md:Please analyze and fix the GitHub issue: $ARGUMENTS.Follow these steps:1. Use `gh issue view` to get the issue details2. Understand the problem described in the issue3. Search the codebase for relevant files4. Implement the necessary changes to fix the issue5. Write and run tests to verify the fix6. Ensure code passes linting and type checking7. Create a descriptive commit message8. Push and create a PRRemember to use the GitHub CLI (`gh`) for all GitHub-related tasks.使用方法：> /project:fix-github-issue 1234Git Worktreeで複数タスクを同時進行これは上級テクニック。でも覚えると手放せなくなる。git-scm.com例えば、機能開発しながらバグ修正もしたい時：# 機能開発用worktree$ git worktree add ../project-feature-auth feature/auth# バグ修正用worktree  $ git worktree add ../project-bugfix-api bugfix/api-error# 各worktreeで独立したClaude Codeセッション$ cd ../project-feature-auth && claude$ cd ../project-bugfix-api && claudeそれぞれのディレクトリで独立したClaude Codeセッションが動く。コンテキストが混ざらない。最高。というか人の業の深さを感じれてよい…。CI/CDへの統合Claude Codeはコマンドラインツールなので、CI/CDにも組み込める。docs.anthropic.comGitHub Actionsの例：- name: Claude Code Review  run: |    claude -p "このPRの変更をレビューして、以下の観点で問題を指摘：    - セキュリティ脆弱性    - パフォーマンス問題    - コーディング規約違反" \    --output-format json > review.json自動化できることは自動化する。人間はもっとクリエイティブなことに時間を使うべきだ。permissions.allowの推奨設定セッション中に「Always allow」を選択するか、/permissionsコマンドで追加できるがsetting.json でも追加できる。syu-m-5151.hatenablog.com公式が推奨する基本的な許可リスト：{  "permissions": {    "allow": [      "List(*)",      "Fetch(https://*)",      "Edit(*)",      "Bash(git:*)",      "Bash(npm:*)",      "Bash(ls:*)",      "Bash(cat:*)",      "Bash(mkdir:*)",      "Bash(mv:*)"    ]  }}まとめClaude Codeを1週間使い込んで確信した。CLAUDE.mdは単なる設定ファイルじゃない。AIとの共通言語だ。youtu.be3ヶ月前、私は理想を語った。「生成AIとの協業で『動作するきれいなコード』を実現する」と。正直、半分は願望だった。syu-m-5151.hatenablog.comでも今、それは現実になっている。私は「助手席」に座り、AIが「運転席」でコードを書く。最初は違和感があったが、今では心地いい。むしろ、なぜ今まで全部自分でやろうとしていたのか不思議にさえ思う。www.oreilly.com3ヶ月で変わったこと、変わらなかったこと変わったこと：理論が実践になった曖昧な指示でも伝わるようになったコードの品質が向上した開発速度が圧倒的に上がった変わらなかったこと：計画を立てるのは相変わらず苦手TDDへの抵抗感は残っている「とりあえず動かしてみる」精神は健在コードを書く楽しさは失われていない最後の点が重要だ。AIに仕事を奪われたのではない。つまらない部分を任せて、楽しい部分に集中できるようになった。効果的なCLAUDE.mdを書くコツ：明確なプロジェクト概要 - AIも人間も理解できるように具体的なワークフロー - 探索→計画→実装→コミット実用的なコマンド集 - よく使うものを網羅AIへの明示的な指示 - NEVER、YOU MUST、IMPORTANTを使い分けるこれらを押さえれば、AIは最高のパートナーになる。「予測可能性は賢さに勝る」 - この原則を胸に、CLAUDE.mdを育てていこう。3ヶ月後、私はまた記事を書いているだろう。タイトルは分からない。でも一つ確実なのは、私はまだ助手席に座っているということ。そして、それを楽しんでいるということだ。なぜなら、助手席こそが最も楽しい席だから。他社も同じぐらいのプランをいずれ出すのでCodex CLIやjulesが楽しみです。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ddc.vimによるシェルコマンドの補完が速くなったぞ]]></title>
            <link>https://blog.atusy.net/2025/06/06/ddc-source-shell_native-is-faster/</link>
            <guid>https://blog.atusy.net/2025/06/06/ddc-source-shell_native-is-faster/</guid>
            <pubDate>Fri, 06 Jun 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[ddc-source-shell_nativeを使うとシェルコマンドの補完ができます。従来は補完候補を取得するたびにシェルを起動するため時間がかかりましたが、シェルを常駐させることで高速化してもらいました。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Introducing cctx: A Context Switcher for Claude Code]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/05/232126</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/05/232126</guid>
            <pubDate>Thu, 05 Jun 2025 14:21:26 GMT</pubDate>
            <content:encoded><![CDATA[IntroductionAs developers, we often juggle multiple contexts throughout our day - switching between personal projects, client work, and perhaps some experimental code on the side. Each context might require different permissions, access levels, and configurations. If you're using Claude Code, Anthropic's CLI tool for interacting with Claude, you've probably felt the pain of manually managing different settings.json configurations. That's why I built cctx - a fast, intuitive context switcher for Claude Code, inspired by the excellent kubectx tool for Kubernetes.github.comThe Problem: Configuration Context SwitchingClaude Code uses a settings.json file to control permissions, access levels, and various configurations. This is great for security and customization, but becomes cumbersome when you need different settings for different scenarios:Work projects need restricted permissions for safetyPersonal projects might need full access to your file systemClient demos require ultra-restricted settings for screen sharingExperimental work needs different tool accessManually editing settings.json or maintaining multiple copies quickly becomes error-prone and tedious. I needed something better.docs.anthropic.comEnter cctx: Fast Context Switching for Claude Codecctx (Claude Context) brings the simplicity and speed of kubectx to Claude Code configuration management. Written in Rust for maximum performance, it allows you to switch between different Claude Code configurations with a single command:# Switch to work context (restricted permissions)cctx work# Switch to personal context (full permissions)cctx personal# Switch back to previous contextcctx -Design Philosophy: Predictable Defaults with Progressive DisclosureOne of the key lessons learned during development was the importance of predictable behavior. In version 0.1.1+, I completely redesigned the UX around a simple principle: predictable defaults with explicit overrides.What This Means in PracticeDefault behavior is always the same - cctx always manages user-level contexts (~/.claude/settings.json) unless explicitly told otherwiseNo surprising auto-detection - The tool won't suddenly switch to project-level contexts just because you're in a different directoryProgressive disclosure - When project or local contexts are available, helpful hints guide you to themExplicit when needed - Use --in-project or --local flags when you want to manage other context levelsThis approach eliminates cognitive overhead while maintaining full functionality for advanced users.Key Features That Make cctx Shine🚀 Lightning FastBuilt with Rust, cctx switches contexts in milliseconds. No Python startup overhead, no Node.js dependencies - just pure speed.🎨 Beautiful, Intuitive InterfaceColor-coded output with the current context highlighted in greenHelpful emoji indicators for different context levels (👤 User, 📁 Project, 💻 Local)Interactive fuzzy search with fzf integration or built-in finderClear, actionable error messages🛡️ Security-First DesignCreate separate contexts for different security requirements:# Create a restricted work contextcctx -n workcctx -e work  # Edit to add restrictions# Create a demo context for screen sharingcctx -n demo  # Ultra-restricted, read-only📁 Simple File-Based StorageContexts are just JSON files stored in ~/.claude/settings/. You can edit them manually, version control them, or sync them across machines.Real-World Usage PatternsHere's how I use cctx in my daily workflow:Morning Routine# Start the day with work contextcctx work# Check what context I'm incctx -c# Output: workProject Switching# Working on a personal projectcctx personal# Client calls - need to share screencctx demo# Back to personal projectcctx -Context Management# Create a new context for a specific clientcctx -n client-acme# Edit the context to set appropriate permissionscctx -e client-acme# List all contextscctx# Output:# 👤 User contexts:#   client-acme#   demo#   personal#   work (current)Technical Implementation HighlightsWhy Rust?Performance: Instant startup and executionSafety: Memory safety without garbage collectionSingle binary: Easy distribution and installationGreat ecosystem: Excellent CLI libraries like clap and dialoguerArchitecture DecisionsFile-based contexts: Each context is a separate JSON fileAtomic operations: Context switching is done by copying filesState tracking: Current and previous contexts tracked in a hidden state filePlatform compatibility: Works on Linux, macOS, and WindowsSettings Hierarchy Supportcctx respects Claude Code's settings hierarchy while keeping things simple:# Default: user-level contextscctx work# Explicit: project-level contextscctx --in-project staging# Explicit: local project contextscctx --local debugGetting StartedInstallation is straightforward:# From crates.io (recommended)cargo install cctx# Or grab a pre-built binary# Download from https://github.com/nwiizo/cctx/releasesCreate your first contexts:# Create a personal context from current settingscctx -n personal# Create a restricted work contextcctx -n workcctx -e work  # Edit to add restrictions# Start switching!cctx workcctx personalcctx -  # Switch backWhat's Next?The cctx project is actively maintained and follows Claude Code's development closely. Some ideas for the future include:Context templates for common scenariosShell integration for automatic context switchingContext inheritance for shared settingsIntegration with other AI coding toolsConclusioncctx brings the joy of quick context switching to Claude Code users. By focusing on speed, simplicity, and predictable behavior, it removes the friction from managing multiple configurations. Whether you're switching between work and personal projects, managing client-specific settings, or just want better control over your Claude Code permissions, cctx has you covered.The project is open source and available on GitHub. If you find it useful, please consider starring the repository and contributing your own ideas and improvements. Happy context switching!cctx is an independent open-source project and is not affiliated with Anthropic. For official Claude Code documentation and support, please visit docs.anthropic.com.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：imgcat]]></title>
            <link>https://zenn.dev/akasan/articles/a57b277ee7af27</link>
            <guid>https://zenn.dev/akasan/articles/a57b277ee7af27</guid>
            <pubDate>Thu, 05 Jun 2025 11:03:01 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第5回は、imgcatというコマンドを紹介します。imgcatを使うとターミナル上で画像を表示させることができます。なお、第4回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/25f1eca029854b imgcatとは？imgcatとは公式の説明によるとDisplay images and gifs in your terminal emulator.ということで画像やgifをターミナルに表示させることができます。特徴としてアニメーションGIFの利用が可能標準入力からメ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Claude Code の settings.json は設定した方がいい]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/05/134147</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/05/134147</guid>
            <pubDate>Thu, 05 Jun 2025 04:41:47 GMT</pubDate>
            <content:encoded><![CDATA[はじめにClaude Code 使ってますか？ターミナルから Claude に直接コーディングタスクを投げられる便利なツールなんですが、デフォルト設定のまま使うのはちょっともったいない。というかいちいちいろんなことを聞いてきてめちゃくちゃダルい。syu-m-5151.hatenablog.comsettings.json をちゃんと設定すると、セキュリティも保ちつつ、もっと快適に使えるようになります。全体的に疲れている時の~/.claude/settings.json と~/.claude/CLAUDE.md · GitHub 私のデフォルトの設定も公開してますのでよかったら参考にしてください。ここで読むのをやめる人のために言っておくと Claude Codeの設定は優先順位があるので覚えておくと良い です。あと、比較的に今は黎明期なので非推奨や追加機能が多いのでその点も注意が必要かもです。正直なところ、Anthropic の公式ドキュメント（日本語）が最高に分かりやすいので、まずはそっちを読んでほしいんですが、このブログは公式ドキュメントに赤線を引いたようなもので、実際に使ってみて「これは設定しといた方がいいよ」っていうポイントをピックアップしてまとめました。docs.anthropic.comsettings.json って何？settings.json は Claude Code の動作を制御する設定ファイルです。公式ドキュメントによると、こんな設定ができます。{  "permissions": {    "allow": [      "Bash(npm run lint)",      "Bash(npm run test:*)",      "Read(~/.zshrc)"    ],    "deny": [      "Bash(curl:*)"    ]  },  "env": {    "CLAUDE_CODE_ENABLE_TELEMETRY": "1",    "OTEL_METRICS_EXPORTER": "otlp"  }}設定できる項目 キー  説明  例  apiKeyHelper  Anthropic APIキーを生成するカスタムスクリプト  /bin/generate_temp_api_key.sh  cleanupPeriodDays  チャット記録をローカルに保持する期間（デフォルト：30日）  20  env  すべてのセッションに適用される環境変数  {"FOO": "bar"}  includeCoAuthoredBy  gitコミットにco-authored-by Claudeを含めるか（デフォルト：true）  false  permissions  ツールのアクセス権限設定  後述 権限設定をちゃんとやろうClaude Code の一番重要な機能がこの権限設定。/permissions コマンドで現在の設定を確認できます。/permissionsはとても良いので覚えておいてほしいです。また、便利なCLIの使い方も覚えておいたほうが多分良いです。docs.anthropic.comBash コマンドの制御{  "permissions": {    "allow": [      "Bash(npm run build)",      // 特定のコマンドだけ許可      "Bash(npm run test:*)",     // プレフィックスで許可      "Bash(git:*)"               // git コマンドは全部OK    ],    "deny": [      "Bash(curl:*)"              // curl は使わせない    ]  }}Claude Code はシェル演算子（&&など）も認識してるので、Bash(safe-cmd:*)みたいなルールでもsafe-cmd && dangerous-cmdみたいなのは実行できません。賢い！ファイルアクセスの制御Read と Edit のルールは gitignore の仕様に従います：{  "permissions": {    "allow": [      "Edit(docs/**)",           // プロジェクトの docs ディレクトリ内を編集可能      "Read(~/.zshrc)",         // ホームディレクトリの .zshrc を読める      "Edit(//tmp/scratch.txt)" // 絶対パスは // で指定    ]  }}Web アクセスの制御{  "permissions": {    "allow": [      "WebFetch(domain:example.com)"  // 特定ドメインのみ許可    ]  }}環境変数の活用公式ドキュメントに載ってる環境変数をうまく使うと便利：{  "env": {    "ANTHROPIC_API_KEY": "your-key-here",    "CLAUDE_CODE_ENABLE_TELEMETRY": "0",    "DISABLE_COST_WARNINGS": "1",    "BASH_DEFAULT_TIMEOUT_MS": "300000",    "BASH_MAX_TIMEOUT_MS": "1200000"  }}主要な環境変数 変数名  用途  CLAUDE_CODE_ENABLE_TELEMETRY  テレメトリの有効/無効  DISABLE_COST_WARNINGS  コスト警告を無効化  BASH_DEFAULT_TIMEOUT_MS  Bashコマンドのデフォルトタイムアウト  DISABLE_AUTOUPDATER  自動更新を無効化 設定の優先順位を理解しよう公式ドキュメントによると、設定は以下の順番で適用されます（上が優先）：エンタープライズポリシーコマンドライン引数ローカルプロジェクト設定（.claude/settings.local.json）共有プロジェクト設定（.claude/settings.json）ユーザー設定（~/.claude/settings.json）プロジェクトごとに設定を変えたければ、プロジェクトフォルダに .claude/settings.json を置けばOK。Git で共有したくない設定は .claude/settings.local.json に書こう。実践的な設定例制限的な設定（仕事用）{  "permissions": {    "allow": [      "Bash(npm run lint)",      "Bash(npm run test:*)",      "Bash(git:*)",      "Read(./src/**)",      "Edit(./src/**)"    ],    "deny": [      "Bash(npm publish:*)",      "WebFetch(domain:*)"    ]  },  "includeCoAuthoredBy": false}もう少しゆるい設定（個人用）{  "permissions": {    "allow": [      "Bash(npm:*)",      "Bash(git:*)",      "Bash(cargo:*)",      "Read(**)",      "Edit(~/projects/**)",      "WebFetch(domain:*)"    ]  },  "cleanupPeriodDays": 60}MCP (Model Context Protocol) を使う場合MCP サーバーを使ってる人向けの権限設定：{  "permissions": {    "allow": [      "mcp__puppeteer",                        // puppeteer サーバーの全ツール      "mcp__puppeteer__puppeteer_navigate"     // 特定のツールだけ    ]  }}複数の設定を切り替えたいならちなみに、複数の~/.claude/settings.jsonを簡単に切り替えたい人向けに cctx っていうツールも作ってみました。cargo install cctxまとめClaude Code の settings.json は、ちゃんと設定すると作業効率とセキュリティが大幅に向上します。ちゃんとしましょう。特に重要なのは：権限設定で必要最小限のアクセスだけ許可するプロジェクトごとに適切な設定を使い分ける環境変数でタイムアウトやテレメトリを調整する詳しい設定方法は Anthropic の公式ドキュメント（日本語）がマジで分かりやすいので、ぜひ読んでみてください。Anthropic の公式ドキュメント最高！Claude Code の 公式ドキュメントやベストプラクティス はとりあえず読んだ方がいい。www.anthropic.com参考リンクClaude Code 公式ドキュメント（日本語） - これ読めば全部分かるcctx - Claude Context Manager - 設定切り替えツールClaude Code 設定例（Gist） - 実際の設定例]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンドラインでバブルソートを可視化してみた]]></title>
            <link>https://zenn.dev/akasan/articles/0331574e200f01</link>
            <guid>https://zenn.dev/akasan/articles/0331574e200f01</guid>
            <pubDate>Wed, 04 Jun 2025 13:30:16 GMT</pubDate>
            <content:encoded><![CDATA[今回はPythonを使ってバブルソートをコマンドラインで可視化しながらソートするコードを作ってみました。 バブルソートとはバブルソートとはリスト内のアイテムをソートするためのアルゴリズムの一つで最もシンプルなものとなります。計算ロジックは以下になります。インデックスi=0、上限インデックスupper_iを`リストの要素数-1``で初期化するiとi+1の要素の大小を比較し、iの値の方が大きかった場合iとi+1の値を入れ替えるiの値を1つ増やし2を実行するiの値がupper_iと一致したらi=0に設定してupper_idを1減らすupper_idが0になるまで繰り返すと...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：rg]]></title>
            <link>https://zenn.dev/akasan/articles/25f1eca029854b</link>
            <guid>https://zenn.dev/akasan/articles/25f1eca029854b</guid>
            <pubDate>Tue, 03 Jun 2025 14:30:40 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第4回は、rgというコマンドを紹介します。rgを使うとリカーシブに正規表現を使って文字列検索を行ったりすることができます。なお、第3回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/5c92827ae75f3c※ 今回は正規表現を使った検索については省略します。基本的に他のツールと利用方法は変わりません！ rgとは？rgとは公式の説明によるとripgrep is a line-oriented search tool that recursively searches the cu...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Conform.nvimの保存時フォーマットをスキップする方法]]></title>
            <link>https://blog.atusy.net/2025/06/03/skip-conform-nvim-format-on-save/</link>
            <guid>https://blog.atusy.net/2025/06/03/skip-conform-nvim-format-on-save/</guid>
            <pubDate>Tue, 03 Jun 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Conform.nvimのformat_on_saveは便利ですが、たまーにスキップしたくなります。:w!の実行やバッファの内容に応じて制御してみましょう。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vim/Neovimのマークを操作内容に合わせて設定する]]></title>
            <link>https://blog.atusy.net/2025/06/03/vim-contextful-mark/</link>
            <guid>https://blog.atusy.net/2025/06/03/vim-contextful-mark/</guid>
            <pubDate>Tue, 03 Jun 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[たとえば`yしたら直前にヤンクした場所に戻れるとよさそうですね。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：bat]]></title>
            <link>https://zenn.dev/akasan/articles/5c92827ae75f3c</link>
            <guid>https://zenn.dev/akasan/articles/5c92827ae75f3c</guid>
            <pubDate>Mon, 02 Jun 2025 11:37:04 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第3回は、batというコマンドを紹介します。batを使うとシンタックスハイライトを用いた画面表示やgitとの連携などを行うことができます。なお、第2回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/dd94771d828ec7 batとは？batは公式の説明によると、シンタックスハイライトとGitとの連携機能付きの cat(1) クローン。ということです。catはファイル内容を表示したり新しいファイルを作ったりできるコマンドですが、それを拡張したものであると言えます。catではシ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイク所属のエンジニアが「AWS Community Builders」に選出]]></title>
            <link>https://sreake.com/blog/aws-community-builders-2025/</link>
            <guid>https://sreake.com/blog/aws-community-builders-2025/</guid>
            <pubDate>Mon, 02 Jun 2025 01:00:00 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）に所属の鈴木 勝史が、「AWS Community Builders」に2年連続で選出されたことをお知らせします。The post スリーシェイク所属のエンジニアが「AWS Community Builders」に選出 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Pythonのtypingについて改めて調べてみた]]></title>
            <link>https://zenn.dev/akasan/articles/b1643e49d81dfe</link>
            <guid>https://zenn.dev/akasan/articles/b1643e49d81dfe</guid>
            <pubDate>Sun, 01 Jun 2025 10:21:58 GMT</pubDate>
            <content:encoded><![CDATA[今回はPythonのtypingについて今までちゃんと調べずに使っていたこともあったので調べてみることにしました。 typingとは？Pythonでデフォルトで利用可能なtypingは、Pythonにおけるタイプヒントをサポートする目的で実装されています。以下が公式ページになります。注釈にも書いてありますが、一般的はPythonランタイムは関数や変数のアノテーションについて強制することはありません。あくまで型アノテーションは明示的に型を示すことでセルフドキュメントとして機能します。※ mypyなどの静的型チェッカーを利用するさいはタイプヒントが必要です。基本的にはmypyを利用し...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AIが進化しても、なぜそのコードを書いたかは消えていく]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/01/122352</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/01/122352</guid>
            <pubDate>Sun, 01 Jun 2025 03:23:52 GMT</pubDate>
            <content:encoded><![CDATA[はじめに生成AIを使ったコード開発が急速に普及している。GitHub Copilot、ChatGPT、Claude、そして各種IDEに統合されたAIアシスタントや独立したコーディングエージェント。これらのツールは開発効率を飛躍的に向上させ、もはやAIなしでの開発は考えられないという声も聞こえてくる（主に心の底から）。しかし、この革新的な変化の中で、看過できない問題が顕在化している。現在のAIで生成したコードは、2年後の進化したAIで再生成すれば、より効率的で保守性の高いコードに置き換えられる。これ自体は技術進歩として歓迎すべきことだが、重要な情報が失われている。それは「なぜそのコードをそのように実装したのか」という意思決定の記録だ。この問題は単なる技術的な課題ではない。私たちがどのようにソフトウェアを作り、保守し、進化させていくかという、エンジニアリングの本質に関わる問題だ（そして、2年後の自分に恨まれない方法でもある）。プロンプトと成果物の分離がもたらす課題従来の開発では、コードとともにコメントやドキュメントで意図を残してきた。しかしAI時代では、以下の情報が分離してしまう：入力：プロンプト（要件、制約、背景情報）出力：生成されたコード生成されたコードだけがリポジトリに残り、そのコードを生成した際のプロンプトや文脈は失われる。2年後、より優れたAIでコードを改善しようとしても、元の要件や制約条件、設計判断の根拠が不明なため、適切な改善ができない。これは「なんでこんな実装になってるの？」と聞かれて「AIがそう書いたから...」としか答えられない悲しい未来への第一歩だ。ADRからPDRへ：解決策の提案ソフトウェアアーキテクチャの分野では、ADR（Architecture Decision Records）によって設計判断を記録する文化が定着している。同様に、AI時代にはPDR（Prompt Decision Records）が必要だ。syu-m-5151.hatenablog.comPDRに記録すべき要素：使用したAIモデルとバージョン（GPT-4なのかClaude-3なのか、未来の自分は知りたがっている）入力したプロンプトの完全なテキストプロンプトに込めた意図と背景検討した他の選択肢採用した理由とトレードオフ生成パラメータ（temperature、max_tokens等）既存ツールにおける実装例既存ツールの現状についてはこちらがめちゃくちゃよくまとまっております。azukiazusa.devCursor Rulesdocs.cursor.comCursorでは.cursorrulesファイルでプロジェクト固有のコンテキストを定義できる。これにより、AIは常にプロジェクトの規約や方針を理解した上でコードを生成する（理解しているフリをすることもあるが）。具体的には、プロジェクトのルートディレクトリに.cursorrulesファイルを配置することで、以下のような指示を永続化できる：このプロジェクトではTypeScriptを使用し、関数型プログラミングのアプローチを優先する。エラーハンドリングはResult型を使用し、例外は投げない。すべての関数にはJSDocコメントを必須とする。このファイルはプロジェクト全体で共有される暗黙知を形式知化する役割を果たし、新しいメンバーがジョインした際のオンボーディングツールとしても機能する。Cline Rulesdocs.cline.botClineも同様に、プロジェクトルールを定義する仕組みを提供している。これらのルールファイルは、実質的にプロンプトの一部を永続化する仕組みだ。Clineの特徴的な点は、ルールを階層的に管理できることだ。グローバルルール、プロジェクトルール、ディレクトリ固有のルールを定義でき、より細かい粒度でAIの振る舞いを制御できる。例えば：/backendディレクトリ：「APIエンドポイントはRESTfulな設計に従う」/frontendディレクトリ：「ReactコンポーネントはHooksを使用した関数コンポーネントとする」/testsディレクトリ：「テストはAAA（Arrange-Act-Assert）パターンに従う」このようなコンテキストの階層管理により、大規模プロジェクトでも一貫性を保ちながら、部分ごとに最適化されたAI支援を受けられる。Anthropic CLAUDE.mdwww.anthropic.comAnthropicのCLAUDE.mdアプローチは、プロジェクトの全体的なコンテキストを単一のマークダウンファイルにまとめる。これは包括的なプロンプトテンプレートとして機能し、AIとの対話の基盤となる。CLAUDE.mdの強みは、単なるルールの羅列ではなく、プロジェクトのストーリーを語る点にある。典型的な構成は：# プロジェクト概要このプロジェクトの目的と背景# アーキテクチャシステムの全体構成と主要コンポーネントの説明# 開発規約- コーディングスタイル- 命名規則- ディレクトリ構造# よくある質問と回答過去の設計判断とその理由この形式により、AIは単にルールに従うだけでなく、プロジェクトの「なぜ」を理解した上でコードを生成できる。まさに本記事で提唱するPDRの考え方を先取りした実装と言えるだろう。実装における具体的な課題バージョン管理プロンプトもコードと同様にバージョン管理が必要だ。しかし、以下の課題がある：プロンプトの変更がコードに与える影響の追跡AIモデルのバージョンアップに伴う互換性管理プロンプトとコードの紐付けの維持（gitのblameコマンドに「AI」と表示される悲しさ）標準化の欠如現状、プロンプトを記録・管理する標準的な方法は存在しない。各ツールが独自の方法を実装しているため、ツール間での移植性がない。まるで文字コードの乱立時代を彷彿とさせる。再現性の問題同じプロンプトでも、以下の要因により出力が変わる：AIモデルのバージョン生成パラメータAPIのバージョン実行タイミング（モデルの更新）今後の展望と提案短期的な対策既存ツールの活用Cursor、Cline、GitHub Copilotなどが提供するルールファイル機能を積極的に活用し、プロジェクト固有のコンテキストを記録・管理する。プロンプトのコメント埋め込み生成されたコードに、使用したプロンプトをコメントとして埋め込む（将来の自分への手紙として）。専用ディレクトリでの管理/promptsディレクトリを作成し、コードファイルと対応するプロンプトファイルを保存。生成メタデータの記録生成日時、モデルバージョン、パラメータをJSONで保存。中長期的な標準化業界標準として、以下のような仕様が必要になるかもしれない：# prompt-decision-record.yamlversion: 1.0timestamp: 2024-12-XXmodel:  provider: openai  name: gpt-4  version: gpt-4-0125-preview  mood: cooperative  # 冗談ですparameters:  temperature: 0.7  max_tokens: 2000prompt: |  実際のプロンプトテキストcontext:  requirements: |    要件の説明  constraints: |    制約事項  decisions: |    設計判断の根拠output_file: src/feature/***.pyおわりにAI活用が当たり前になる開発環境において、コードの「なぜ」を残すことは、技術的負債を防ぐ重要な実践だ。2年後により良いAIが登場したとき、過去の意思決定を理解できれば、真に価値のある改善が可能になる。私たちエンジニアは、常に未来の自分や同僚のことを考えてコードを書いてきた。可読性、保守性、拡張性—これらはすべて「未来の誰か」のための配慮だ。AI時代においても、この精神は変わらない。むしろ、AIの進化速度を考えれば、より一層重要になる。プロンプトは新しい形の設計書だ。コードレビューと同じように、プロンプトレビューが必要になるかもしれない。リファクタリングと同じように、プロンプトリファクタリングが日常になるかもしれない（プロンプトの可読性を議論する日も近い）。もしくはそのような考慮をすべて超えて全てを理解する生成AIのモデルが成長する可能性もある。PDRのような仕組みの標準化は、AI時代のソフトウェア開発における必須要件となるだろう。エンジニアとして、この課題に真剣に取り組む時期に来ているが、個人ではどうにもならない気もするので。頑張れ、Anthropic！！！]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitLabでCIを実行する方法を調べてみた]]></title>
            <link>https://zenn.dev/akasan/articles/fb2c0453fde9fa</link>
            <guid>https://zenn.dev/akasan/articles/fb2c0453fde9fa</guid>
            <pubDate>Sat, 31 May 2025 06:39:06 GMT</pubDate>
            <content:encoded><![CDATA[今回はGitLabを利用してどのようにCIを実行するかについて試してみました。私自身今までGitHub Actionsしか使ってこなかったので、今回試してみました。 GitLabとはGitLabはGitLab社が展開しているGitを利用するためのバージョン管理システムのサービスになります。DevOpsだけでなくDevSecOpsのワークフローを意識したサービスとなっています。以下が公式ページとなっております。https://about.gitlab.com/ja-jp/ CIとは？CIとは継続的インテグレーション、英語にするとContinuous Integrationの...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[marp.nvimを開発してCursorから完全移行した話]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/05/31/105405</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/05/31/105405</guid>
            <pubDate>Sat, 31 May 2025 01:54:05 GMT</pubDate>
            <content:encoded><![CDATA[なぜmarp.nvimが必要だったのか前回の記事でClaude Codeに移行し、Neovimに完全回帰することを決めた。コーディング、ドキュメント作成、設定ファイルの編集――すべてが再びターミナルで完結するようになった。しかし、一つだけ問題があった。Marpでのプレゼンテーション作成だ。Marpは素晴らしいツールだが、公式のNeovimサポートは存在しない。プレゼンテーションを作るたびに、仕方なくVSCodeやCursorを起動していた。せっかくNeovimに完全回帰したのに、プレゼン作成のためだけに別のエディタを立ち上げる。この矛盾が許せなかった。marp.app既存のソリューションを探したが、満足できるものはなかった。ならば答えは一つ――自作するしかない。こうしてmarp.nvimは生まれた。Neovimですべてを完結させるという理想を、妥協なく追求した結果だ。github.commarp.nvimの技術的アプローチアーキテクチャ┌─────────────┐     ┌─────────────┐     ┌─────────────┐│   Neovim    │────▶│  marp.nvim  │────▶│  Marp CLI   ││   Buffer    │     │  Lua Plugin │     │  --watch    │└─────────────┘     └─────────────┘     └─────────────┘                            │                            ▼                    ┌─────────────┐                    │   Browser   │                    │  Auto-open  │                    └─────────────┘コア実装の詳細1. Marp CLIのプロセス管理これは完全にMarp の作者が優秀なのですがMarpには--watchオプションが存在しています。これを使わない手はないです-- プロセスをバッファごとに管理M.active_processes = {}-- jobstart で Marp CLI を起動local job_id = vim.fn.jobstart(shell_cmd, {    pty = true,  -- 擬似端末で適切な出力キャプチャ    stdout_buffered = false,    stderr_buffered = false,    on_stdout = function(_, data)        -- 出力処理    end,    on_exit = function()        M.active_processes[bufnr] = nil    end})重要なポイント：pty = trueを使用することで、Marp CLIのカラー出力を適切に処理stdout_buffered = falseでリアルタイム出力を実現バッファ番号をキーにしてプロセスを管理2. 自動クリーンアップの実装vim.api.nvim_create_autocmd({"BufDelete", "BufWipeout"}, {    buffer = bufnr,    once = true,    callback = function()        M.stop(bufnr)    end})VSCode拡張機能では当たり前の機能だが、Neovimでは自前実装が必要。バッファのライフサイクルに合わせてプロセスを管理。3. ウォッチモード vs サーバーモードif M.config.server_mode then    cmd = string.format("%s -s '%s'", marp_cmd, file)else    -- デフォルトは --watch モード    cmd = string.format("%s --watch '%s'", marp_cmd, file)end2つのモードをサポート：ウォッチモード（デフォルト）: HTMLファイルを生成し、変更を監視サーバーモード: HTTPサーバーを起動（ポート競合の可能性あり）4. ANSIエスケープシーケンスの処理local function clean_ansi(str)    return str:gsub("\27%[[%d;]*m", ""):gsub("\27%[[%d;]*[A-Za-z]", "")endMarp CLIの美しいカラー出力をNeovimの通知システムで扱うための処理。これがないと文字化けする。実装で工夫した点1. 初回HTML生成の最適化-- ウォッチモード開始前に初回HTMLを生成if not M.config.server_mode then    local init_cmd = string.format("%s '%s' -o '%s'", marp_cmd, file, html_file)    vim.fn.system(init_cmd)        if vim.fn.filereadable(html_file) == 1 then        -- 即座にブラウザを開く        M.open_browser("file://" .. html_file)    endend--watchモードは初回生成が遅いため、事前に生成してUXを改善。2. クロスプラットフォーム対応function M.open_browser(url)    local cmd    if vim.fn.has("mac") == 1 then        cmd = "open " .. url    elseif vim.fn.has("unix") == 1 then        cmd = "xdg-open " .. url    elseif vim.fn.has("win32") == 1 then        cmd = "start " .. url    end    vim.fn.jobstart(cmd, {detach = true})end3. デバッグモードM.config = {    debug = true,  -- 詳細ログを有効化}-- :MarpDebug コマンドで診断function M.debug()    local test_cmd = string.format("%s --version", marp_cmd)    -- Marp CLIの動作確認endトラブルシューティングを容易にするため、詳細なログ出力機能を実装。VSCode拡張機能との機能比較 機能  Marp for VS Code  marp.nvim  ライブプレビュー  ✅  ✅  自動リロード(書き込みイベント時)  ✅  ✅  テーマ切り替え  GUI  :MarpTheme  エクスポート  GUI  :MarpExport  スライドナビゲーション  ✅  ❌（開発中）  スニペット  ✅  ✅  複数ファイル同時編集  ✅  ✅ 使用方法インストール-- lazy.nvim{    "nwiizo/marp.nvim",    ft = "markdown",    config = function()        require("marp").setup({            marp_command = "npx @marp-team/marp-cli@latest",            debug = false,            server_mode = false,  -- ウォッチモードを使用        })    end,}基本的なワークフロー:e presentation.md:MarpWatch          " プレビュー開始(ファイル名をClipboardに書き込みもしている):MarpTheme uncover  " テーマ変更:MarpExport pdf     " PDF出力:q                  " バッファを閉じると自動でサーバー停止トラブルシューティング:MarpDebug          " Marp CLIの動作確認:MarpList           " アクティブなサーバー一覧:MarpStopAll        " 全サーバー停止パフォーマンスと制限事項メモリ使用量Marp CLIプロセス: 約50-100MB/インスタンス複数ファイル同時編集時は線形に増加既知の制限ホットリロードの遅延: ファイル保存からブラウザ更新まで約100-200ms大規模ファイル: 100スライド以上でパフォーマンス低下画像の相対パス: 作業ディレクトリに依存まとめmarp.nvimの開発により、Marpプレゼンテーション作成のためだけにCursorを起動する必要がなくなった。Neovimのjob APIを活用することで、VSCode拡張機能と似た体験を実現できることを証明できた。重要なのは、完璧を求めすぎないこと。VSCode拡張機能のすべての機能を再現する必要はない。ターミナルでの開発に必要十分な機能を、シンプルに実装することが大切だ。Claude Codeとの組み合わせで、プレゼンテーション作成もAIアシスト付きで行える。これで本当にすべての開発作業をNeovimで完結できるようになった。vimmer村への完全帰還、達成。実践Vim　思考のスピードで編集しよう！ (アスキー書籍)作者:Ｄｒｅｗ Ｎｅｉｌ,新丈 径角川アスキー総合研究所Amazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：tldr]]></title>
            <link>https://zenn.dev/akasan/articles/dd94771d828ec7</link>
            <guid>https://zenn.dev/akasan/articles/dd94771d828ec7</guid>
            <pubDate>Fri, 30 May 2025 10:37:03 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第2回は、tldrというコマンドを紹介します。名前からして何かしらの情報をまとめて表示してくれる系のコマンドと予想できるかと思いますが、実際はどんなコマンドなのかみていきましょう。 tldrとは？一言で言ってしまうと、コマンドラインツールのヘルプページで、man pagesをよりシンプルにしたものと思ってもらえればと思います。公式GitHubは以下にありますのでぜひ参照ください。https://github.com/tldr-pages/tldrそもそもman pagesとは何かという話ですが、コマンドラインツールで使い方がわからない時に利用されるm...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Claude Code を利用しようと思っているのでvimmer が住む村に帰ろうと思います。]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/05/30/180912</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/05/30/180912</guid>
            <pubDate>Fri, 30 May 2025 09:09:12 GMT</pubDate>
            <content:encoded><![CDATA[はじめに前回、「NeovimをCursorのように進化させる - yetone/avante.nvim の導入」を書いた。あの記事では、まるで自分だけの剣を鍛え上げていくように、エディターと共に成長していくPDEの哲学について語った。syu-m-5151.hatenablog.comあれから数ヶ月、私のNeovimはavante.nvimによってCursor + Roo-Codeライクな体験を手に入れ、PDEとしてさらなる進化を遂げた。しかし、告白しなければならないことがある。vimmerを自称しながら、実は日常的にCursorを使っていた。この矛盾と向き合う時が来た。www.cursor.comそして先週の土曜日、私はClaude Codeを使い始めた。今日で1週間。短い期間だが、これが私のPDEに新たな可能性をもたらすことを確信している。そして、Cursor のサブスクを解約してClaude をMAX Planにした。www.youtube.com私は、Claude Code を利用しようと思っているのでvimmer が住む村に帰ろうと思います。一旦、お別れです。 pic.twitter.com/Is5fAUD5hI— nwiizo (@nwiizo) 2025年5月29日   「いいえ、Neovimはもっと強くなれます」前回からの旅路：PDEという哲学前回の記事で、私はこう書いた：Neovimの最大の魅力は、その圧倒的なカスタマイズ性。それは単なるIDE（統合開発環境）ではなく、PDE（Personal Development Environment：個人開発環境）とも呼べる存在です。この言葉は、今思えば預言的だった。PDEという概念は、単にツールをカスタマイズすることではない。それは、開発者が自分自身の思考プロセスと一体化したツールを作り上げることだ。まるで自分だけの剣を鍛え上げていくように、エディターと共に成長していく。そして今、私は気づいた。PDEとは、一人で剣の丘で鉄を鍛つような孤独で崇高な作業なのだと。誰かが用意した完成品ではなく、自分の手で、自分のために、一つ一つ形作っていくもの。avante.nvimは、その第一歩だった。しかし、6ヶ月間Cursor + Roo-Codeを使い込んだことで、私は逆説的にPDEの価値を理解した。Cursor + Roo-Codeは確かに完成度の高い「製品」だ。しかし、私が求めていたのは「作品」—自分の手で育てていけるものだった。実際には育ててなくても育てている感覚があるものだ。正直に告白しよう。vimmerを自称しながらも、実は各所でCursor + Roo-Codeを使っていた。クライアントワークでは生産性を優先してCursor、個人プロジェクトではNeovim。そんな二重生活を送っていた。この矛盾に、私自身も気づいていた。なぜ今、Claude Codeなのか正直に言えば、Claude Codeを使い始めた最大の理由は、Claude Opus 4がリリースされたからだ。最新にして最強のモデル。その能力を、私の愛するターミナル環境で直接使えるなんて—これは試さずにはいられなかった。zenn.devしかし、それだけではない。Claude Codeが掲げる「Terminal Velocity」という概念に、私は強く惹かれた。www.anthropic.com考えてみてほしい。私たちvimmerは、なぜターミナルから離れないのか？それは、思考の流れを断ち切りたくないからだ。GUIアプリケーションへの切り替え、マウスへの手の移動、異なるUIパラダイムへの適応—これらすべてが、私たちの集中を妨げる。Claude Codeは、その問題を根本から解決する。「コンテキストスイッチをゼロにする」—これは、PDEの究極の形かもしれない。そしてもう一つ、個人的に重要だったのがMAX Planという料金体系だ。トークン数無制限。これは貧乏性の私にとって革命的だった。Cursorでは常に「今月あとどれくらい使えるか」を気にしていた。コーディングエージェントでコードを書く前に「これ、AIに聞くほどの価値があるかな？」と躊躇する。そんな心理的ブレーキが、創造性を阻害していたことに気づいた。MAX Planは、その制限から私を解放してくれた。思考のままに、遠慮なくAIと対話できる。まるで無限のメモ帳を手に入れたような感覚だ。「トークンがもったいない」という貧乏性マインドから解放されて初めて、本当の意味でAIとの協働が始まる。これこそが、私のメンタルモデルと完璧に合致した。先週土曜日から使い始めて、まだ1週間。しかし、その短い期間でも、Claude Codeの持つ独特の「控えめな賢さ」に魅了された。Roo-Codeのような積極性はない。しかし、それがかえって心地よい。必要な時に、必要なだけ、的確な支援をしてくれる。Claude Opus 4の高い理解力が、控えめながらも的確なアドバイスを可能にしているのだろう。そして何より、もうトークン数を気にする必要がない。深夜のコーディングセッションで「あと何回質問できるかな...」と計算する必要もない。この精神的な自由度が、私の開発スタイルを根本から変えつつある。zenn.devzenn.devnote.comCursor + Roo-Codeへの敬意、そして決別誤解しないでほしい。私はCursor + Roo-Codeを否定したいわけではない。実際、この6ヶ月間、私は久しぶりにVSCodeベースのCursorをメインエディタとして使い込んだ。そしてそれは、驚くほど素晴らしい体験だった。特にRoo-Codeとの組み合わせで実感したのは、これは単にAIモデルを統合しただけのツールではないということだ。それは開発体験そのものが根本的に違う。github.com考えてみてほしい。従来の開発では、私たちは一つのファイルを開き、一行ずつコードを書いていた。しかしCursor + Roo-Codeの世界では、コードベース全体が一つの有機体として扱われる。「このコンポーネントをリファクタリングして」と言えば、関連する全てのファイルが瞬時に更新される。「このテストを追加して」と言えば、適切なディレクトリに適切な形式でテストが生成される。さらに驚くべきは、Roo-Codeが持つ「意図の理解」だ。曖昧な指示でも、プロジェクトの文脈を読み取り、開発者が本当に必要としているものを推測して提案してくる。それは、経験豊富な同僚とペアプログラミングをしているような感覚だった。これは単なる効率化ではない。これは開発の概念そのものの再定義だった。正直に言えば、これほど生産的な6ヶ月は久しぶりだった。前回の記事でavante.nvimを導入したのも、このCursor + Roo-Codeの革新的な開発体験に触発されたからこそだった。6ヶ月のCursor + Roo-Code体験は、確かに私の開発スタイルを変えた。Tab補完を超えた、AIペアプログラミング。しかし同時に、ある種の違和感も育っていった。それは、自分がコードを「書いている」のか「選んでいる」のか、境界が曖昧になる感覚だった。そして、もう一つの違和感。朝はNeovimで始めたはずが、気がつけばCursorを開いている。締切が迫ると、つい効率的な方を選んでしまう。vimmerとしてのアイデンティティが揺らいでいた。この6ヶ月は、技術的な進歩と同時に、自分自身との葛藤の期間でもあった。Roo-Codeが見せてくれた「開発体験の違い」は革新的だった。しかし、それゆえに気づいたことがある。開発者として長年培ってきた直感が教えてくれる。私たちには「まだ形になっていないアイデアを、コードという形で具現化する」という独特の能力がある。AIはコードを生成できる。しかし、なぜそのコードが必要なのか、それが解決すべき本質的な問題は何かを理解することはできない。そして今、6ヶ月の濃密な体験を経て、私は確信を持って言える—Cursor + Roo-Codeは素晴らしい。その組み合わせは革命的だ。しかし、私にはPDEとしてのNeovimがある。それは単なるエディタではなく、私の思考の延長線上にある道具なのだ。PDEの完成形を目指してしかし、正直に言えば、この6ヶ月はNeovimとCursorの間で揺れ動いていた。月曜の朝は「今週こそNeovimで」と決意するも、水曜には締切に追われてCursorを開く。金曜には罪悪感を感じながらも、Roo-Codeの生産性に頼っていた。vimmerとしての矜持はどこへ行ったのか。だが、この葛藤の中で私は気づいた。PDEとは、単に優れたツールを集めることではない。それは、自分の開発哲学と完全に一致した環境を構築することだ。そして今、NeovimコミュニティはAI時代に適応し、驚くべき進化を遂げている。以下に紹介する3つのプラグインは、その進化の最前線にある。yetone/avante.nvim - 前回の記事で導入したこのプラグインは、Cursor AI IDEの体験をNeovimで完璧に再現する。サイドバーでのAI対話、差分の視覚的表示、ワンクリックでのコード適用など、Cursor + Roo-Codeユーザーが慣れ親しんだ機能をすべて提供する。しかし、それだけではない。Neovimのモーダル編集と完全に統合されているため、思考の流れを妨げることなくAIとの対話を行える。ravitemer/mcphub.nvim - AnthropicのModel Context Protocol (MCP)をNeovimに統合する革新的なプラグイン。MCPサーバーの集中管理により、AIが外部ツールやデータソースにシームレスにアクセスできるようになる。データベースへの直接クエリ、ファイルシステムの操作、外部APIとの連携—これらすべてがNeovimの中で完結する。これこそが、未来のAI開発環境の標準となるだろう。こちらでMCP経由でもclaude-codeを利用している。greggh/claude-code.nvim - Claude Code CLIとNeovimを完全に融合させる野心的なプロジェクト。ターミナル内でClaude Opus 4を含む最新モデルの全能力を解き放ち、まさに「Terminal Velocity」を体現する。:ClaudeCodeコマンド一つで、現在のバッファやプロジェクト全体のコンテキストを理解した上で、最適な提案を行ってくれる。これは単なるプラグインではない—開発体験の再定義だ。これらのツールを組み合わせることで、私のNeovimは単なるテキストエディタから、真のAI統合開発環境へと進化した。もはやCursorを羨む必要はない。むしろ、より深く、より個人的な形でAIと協働できる環境が、ここにある。github.comPDEという哲学の深化PDEとは何か。それは、開発者の思考パターンとツールが完全に一体化した環境だ。前回の記事で初めてこの概念を提示したが、6ヶ月の実践を経て、その意味がより深く理解できるようになった。筆者は専門家ではないため、あくまで個人的な経験に基づく話として聞いていただきたいが、優れたPDEには以下の特徴がある：思考の流れを妨げない：Warp + Neovim + Claude Codeの組み合わせ拡張可能性：新しいツールを取り込める柔軟性個人の哲学の反映：設定ファイルという形での思想の具現化私の~/.config/nvim/lua/plugins/init.luaは、単なる設定ファイルではない。これは私の開発思想の結晶だ。Lazy.nvimを通じて管理されるプラグインの一つ一つが、私の開発哲学を体現している。Cursor + Roo-Codeの体験を経て、その設定はさらに洗練された。そして何より、PDEの構築は一人で剣の丘で鉄を鍛つ行為に似ている。誰も代わりにはできない。自分の手で、自分のために、ひたすら打ち続ける。時に孤独で、時に苦しい。しかし、その先に待っているのは、自分だけの、世界に一つだけの剣だ。Cursor + Roo-Codeが示してくれた新しい開発体験は、確かに革新的だった。しかし、それらは「完成品」だ。一方、PDEとしてのNeovimは「進化し続ける生き物」のようなものだ。私の成長と共に、私の理解と共に、そして私の哲学と共に変化していく。この1週間、Claude Codeを使いながら感じたのは、「これこそが私の求めていたAIとの距離感だ」ということだった。過度に依存せず、しかし必要な時には頼れる。まさに理想的なパートナーシップだ。そして何より、もう環境を使い分ける必要がない。朝から晩まで、クライアントワークも個人プロジェクトも、すべてを私のPDEで完結できる。この統一感が、開発者としての一貫性を取り戻してくれた。おわりに前回の記事から始まった旅は、今、新たな段階に入った。avante.nvimで手に入れたCursor + Roo-Codeライクな体験に、Claude Codeの「Terminal Velocity」が加わることで、私のPDEは更に進化した。興味深いのは、最先端を追求した結果、最も原始的なツール—ターミナルとテキストエディタ—に戻ってきたことだ。しかし、これは後退ではない。これは螺旋的な進化だ。AIとの協働が当たり前になる時代において、私たちに必要なのは、AIとの適切な距離感を保ちながら、共に新たな地平を切り開いていく勇気かもしれない。そして、その第一歩が、自分のPDEを完成させることなのだ。Cursor + Roo-Codeが示してくれた新しい開発体験は、確かに未来の一つの形だ。しかし、それが唯一の答えではない。私たちには、自分自身の開発哲学に基づいて、自分だけの環境を構築する自由がある。「いいえ、Neovimはもっと強くなれます」—この言葉は、単なる願望ではない。それは、PDEという哲学を持つ私たちvimmerの確信なのだ。そして今、Claude Codeの登場により、私はついに二重生活から解放される。もうクライアントワークでCursor、個人でNeovimという使い分けをする必要はない。私のPDEが、すべての開発シーンで通用する強さを手に入れたのだから。そして、PDEの構築とは、一人で剣の丘で鉄を鍛つような営みだ。誰かが用意した剣ではなく、自分の手で打ち、自分の手で研ぎ、自分だけの刃を作り上げる。その過程こそが、私たちを真の開発者にするのかもしれない。この記事を書いている間、私はWarpターミナル上でNeovimとClaude Codeを行き来している。前回のavante.nvim導入から数ヶ月、そして Claude Code導入から1週間。私のPDEは確実に進化した。Lazy.nvimの設定ファイルは公開しているので、興味があれば参考にしてほしい。「Terminal Velocity」を「ターミナルベロシティ」とカタカナ表記したのは、この概念の持つ物理学的な含意—終端速度、つまり最高効率—を日本語でも感じてもらいたかったからだ。「Cursor + Roo-Codeのサブスクリプションを払い続けるか、vimの学習コストを払うか」—これは単なる経済的判断ではない。私たちが開発という行為にどう向き合うか、そしてPDEという哲学をどこまで追求するかという、実存的な選択なのかもしれない。6ヶ月のCursor + Roo-Code体験は本当に素晴らしかった。特にRoo-Codeが示してくれた「開発体験の違い」は、私の開発観を根本から変えた。もしあなたがまだ試していないなら、一度は体験する価値がある。その上で、自分にとっての最適な開発環境を選ぶべきだ。私にとって、それはPDEとしてのNeovimだった。この二重生活は疲れるものだった。.vimrcと.vscode/settings.jsonを行き来し、キーバインドの違いに戸惑い、どちらが本当の自分なのか分からなくなることもあった。しかし、その経験があったからこそ、今の決断に至ることができた。あなたも、vimmer村への帰郷を考えてみてはどうだろうか。Claude Codeという新しい仲間と共に、自分だけのPDEを完成させるために。VimConf 2025 Smallにも行こうかな…。今度こそ、胸を張って「私はvimmerです(え、Neovim ですよね？)」と言えるように。vimconf.org実践Vim　思考のスピードで編集しよう！ (アスキー書籍)作者:Ｄｒｅｗ Ｎｅｉｌ,新丈 径角川アスキー総合研究所Amazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GoogleのAI Agent]]></title>
            <link>https://speakerdeck.com/shukob/googlenoai-agent</link>
            <guid>https://speakerdeck.com/shukob/googlenoai-agent</guid>
            <pubDate>Fri, 30 May 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[2025年5月30日(金) AI Agent 勉強会 Vol.3 にて、Google CloudのAI AgentサービスとGoogle I/O 2025 で発表された内容の概要を紹介させていただきました。https://almondo.connpass.com/event/355297/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[宝くじに当たる方法を思い出して、明日も頑張ることにした]]></title>
            <link>https://blog.atusy.net/2025/05/30/how-to-win/</link>
            <guid>https://blog.atusy.net/2025/05/30/how-to-win/</guid>
            <pubDate>Fri, 30 May 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[宝くじに当たりたければ、まず買うことだ。成功も行動の先にある。宝くじと違って、うまくいかなかった時も戦略を練り直せるから、どんどん挑戦しよう。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google Cloud 認定資格奮闘記 ~Generative AI Leader編~]]></title>
            <link>https://zenn.dev/akasan/articles/c0d347a37065bc</link>
            <guid>https://zenn.dev/akasan/articles/c0d347a37065bc</guid>
            <pubDate>Thu, 29 May 2025 13:24:41 GMT</pubDate>
            <content:encoded><![CDATA[この記事の続編になります。https://zenn.dev/akasan/articles/e2416e40a90499 Generative AI LeaderについてGenerative AI Leader（以下、GenAI Leader）は、今月公開された新しいGoogle Cloudの認定資格です。こちらの資格については公式で以下のように説明がされています。A Generative AI Leader is a visionary professional with comprehensive knowledge of how generative AI (gen A...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイク、「KubeCon + CloudNativeCon Japan 2025」にGoldスポンサーとして協賛およびブース出展]]></title>
            <link>https://sreake.com/blog/kubecon-cloudnativecon-japan-2025/</link>
            <guid>https://sreake.com/blog/kubecon-cloudnativecon-japan-2025/</guid>
            <pubDate>Thu, 29 May 2025 01:00:00 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）は、 2025年6月16日（月）・17日（火）に開催される「KubeCon + CloudNativeCon Japan 2025」にGoldスポンサーとして協賛します。The post スリーシェイク、「KubeCon + CloudNativeCon Japan 2025」にGoldスポンサーとして協賛およびブース出展 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Dockerを使用せずにイメージを作成し実行してみる – go-containerregistryによる実装]]></title>
            <link>https://sreake.com/blog/image-creation-and-execution-with-go-containerregistry/</link>
            <guid>https://sreake.com/blog/image-creation-and-execution-with-go-containerregistry/</guid>
            <pubDate>Thu, 29 May 2025 00:40:36 GMT</pubDate>
            <content:encoded><![CDATA[この記事ではコンテナイメージがどのように作成されているのかを、go-containerregistryライブラリを使った実装例を通して解説します。Dockerfileを使わずに、プログラムからコンテナイメージを作成する過 […]The post Dockerを使用せずにイメージを作成し実行してみる – go-containerregistryによる実装 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[セルフエンドレスアドベントカレンダーを通してエンジニアとして成長できました報告]]></title>
            <link>https://zenn.dev/akasan/articles/4aba4d3a0616ce</link>
            <guid>https://zenn.dev/akasan/articles/4aba4d3a0616ce</guid>
            <pubDate>Wed, 28 May 2025 12:47:33 GMT</pubDate>
            <content:encoded><![CDATA[今回は、私が仕事とも関係なく勝手にやっているセルフエンドレスアドベントカレンダーを通して、どう成長していると感じているか共有しようと思います。今回は技術的な話はあまりないですが、仕事以外の時間をどう使うかについて共有できればと思います。 そもそもアドベントカレンダーとは？というか、そもそもアドベントカレンダーとは何かについて理解しておかないといけないですね、、、。Wikipediaによるとインターネット上などで、12月の1日から25日までに、特定のテーマに沿って毎日ブログなどに記事を投稿していくという企画がある[1][2]。元々のアドベントカレンダーになぞらえて、この企画も...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイク、Google Cloud Next Tokyo にDiamondスポンサーとして協賛]]></title>
            <link>https://sreake.com/blog/google-cloud-next-tokyo-2025/</link>
            <guid>https://sreake.com/blog/google-cloud-next-tokyo-2025/</guid>
            <pubDate>Wed, 28 May 2025 06:27:59 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）は、2025 年 8 ⽉ 5 日（火）~  6 ⽇（水）に東京ビッグサイトにて開催される Google Cloud Next Tokyo  (主催：グーグル・クラウド・ジャパン合同会社) にDiamondスポンサーとして協賛いたします。The post スリーシェイク、Google Cloud Next Tokyo にDiamondスポンサーとして協賛 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AIコードエディタは開発を変えるか？Cursorをチームに導入して1ヶ月経った本音]]></title>
            <link>https://speakerdeck.com/ota1022/aikodoedeitahakai-fa-wobian-eruka-cursorwotimunidao-ru-site1keyue-jing-tutaben-yin</link>
            <guid>https://speakerdeck.com/ota1022/aikodoedeitahakai-fa-wobian-eruka-cursorwotimunidao-ru-site1keyue-jing-tutaben-yin</guid>
            <pubDate>Wed, 28 May 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[2025年5月28日 Qiita Bash 最近ハマっている生成AI活用法を語ろう！のLT登壇資料です。https://increments.connpass.com/event/351227/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ディレクトリ構成 ~フィーチャーベース編~]]></title>
            <link>https://sreake.com/blog/feature-based-directory-structure-good-practice/</link>
            <guid>https://sreake.com/blog/feature-based-directory-structure-good-practice/</guid>
            <pubDate>Wed, 28 May 2025 02:18:09 GMT</pubDate>
            <content:encoded><![CDATA[はじめに アプリケーション開発において、ディレクトリ構成は保守性・拡張性・開発効率に直結する設計要素です。 本記事では、以下のような課題に悩む現場に向けて、「機能ごとに整理しやすく、拡張にも強い」フィーチャーベース構成を […]The post ディレクトリ構成 ~フィーチャーベース編~ first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[RedisのPub/Subを使用したリアルタイム通知の実現]]></title>
            <link>https://sreake.com/blog/realtime-notification-with-redis-pubsub/</link>
            <guid>https://sreake.com/blog/realtime-notification-with-redis-pubsub/</guid>
            <pubDate>Wed, 28 May 2025 01:18:04 GMT</pubDate>
            <content:encoded><![CDATA[はじめに Sreake事業部のアプリケーションエンジニアの角谷です。 リアルタイム通信を実現する手段は様々ありますが、その一つにPub/Subがあります。 Pub/Subを実装する方法は様々ありますが、今回はRedisを […]The post RedisのPub/Subを使用したリアルタイム通知の実現 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Nix Meetup #3 大阪に参加した]]></title>
            <link>https://blog.atusy.net/2025/05/28/nix-meetup-3-in-osaka/</link>
            <guid>https://blog.atusy.net/2025/05/28/nix-meetup-3-in-osaka/</guid>
            <pubDate>Wed, 28 May 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Nix meetup #3 大阪が2025-05-24に開催されました。技術への愛溢れた濃いい話がいっぱいできてよかったです。いっぱい聞けて、じゃなくてできてってところがまた素敵。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：thefuck]]></title>
            <link>https://zenn.dev/akasan/articles/fff0cfa9beadbc</link>
            <guid>https://zenn.dev/akasan/articles/fff0cfa9beadbc</guid>
            <pubDate>Tue, 27 May 2025 11:22:06 GMT</pubDate>
            <content:encoded><![CDATA[今回から、私が普段使ってるコマンドを紹介していくシリーズを始めたいと思います。記念すべき第一回は、thefuckというコマンドを紹介します。名前だけ見るとなかなかにパンチが効いたものですが、スター数も多いコマンドですので、ぜひ興味がある方はみてください。※ 本記事を書くにあたり、果たしてこの文字を入力して良いのか迷いましたが、①あくまでコマンド紹介であること、②他の記事で4文字が入っている記事も結構ありそうだったので採用しました thefuckとは？一言で言ってしまうと、コマンド入力をミスした時に、本来実行したかったコマンドを想定して出してくれるコマンドになります。例えば...]]></content:encoded>
        </item>
    </channel>
</rss>