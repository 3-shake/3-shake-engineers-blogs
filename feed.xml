<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com/</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Thu, 16 Feb 2023 18:32:53 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com/</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[Helm Chart の歩き方 導入前に読みたいドキュメントについて]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2023/02/16/141433</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2023/02/16/141433</guid>
            <pubDate>Thu, 16 Feb 2023 05:14:33 GMT</pubDate>
            <content:encoded><![CDATA[Helm  を導入する前にChartについて読んでおいてほしいドキュメントをまとました。Chart の作成各ファイルの説明についてChart.yamlvalues.yaml.helmignoretemplate/templates/NOTES.txttemplates/_helpers.tplHelm について知るHelm Template Language の記法values.yaml へのアクセスHelm Template で利用できる関数Helm Chart で利用できる制御構文Named Templates を用いて一つのページで定義していく空白を管理する - の話Helm Chart をよくしていくHelm Chart のデバッグHelm Chart のリファクタリングHelm Chart のテストHelm Chart のリポジトリ化さいごに参考資料Chart の作成helm create でHelm Chart を作成します。Chart とは、Kubernetes リソースのまとまりを定義するファイル群のことです。helm create で構築したもの$ helm create mychartCreating mychart$ tree -a ./mychart./chart-namemychart/├── .helmignore├── Chart.yaml├── charts├── templates│   ├── NOTES.txt│   ├── _helpers.tpl│   ├── deployment.yaml│   ├── hpa.yaml│   ├── ingress.yaml│   ├── service.yaml│   ├── serviceaccount.yaml│   └── tests│       └── test-connection.yaml└── values.yamlこれにより、mychart ディレクトリが作成されます。特別なことがなければ基本的にはこれをベースに作成していくことになると思います。Helm Create各ファイルの説明について作成した mychart ディレクトリに移動して、Chart の設定を編集します。Chart.yamlChart.yaml は、作成した Chart のメタ情報を管理するファイルです。幾つかの必須パラメーターと追加のパラメーターがあります。詳細は公式のドキュメントを読んでください。Chart.yamlvalues.yamlvalues.yaml は、Helm Template Language で利用する変数の、デフォルト値を指定したファイルです。上書きしたい時は別途指定してあげます。チャート内のvalues.yamlファイルサブチャートの場合、親チャートのvalues.yamlファイルhelm install または helm upgrade に -f フラグを付けて渡した場合の values ファイル (helm install -f myvals.yaml ./mychart)set で渡される個々のパラメータ (helm install --set foo=bar ./mychart のように)Values Files.helmignoreChart をリポジトリ化する際には、作成したファイル一式を helm package コマンドを利用して tar ファイルにするのですが、.helmignore を利用すると、その tar ファイルに含めたくないファイルを指定できるようなります。The .helmignore filetemplate/templates/ はテンプレートファイル用のディレクトリです。テンプレートとして利用するファイルが納入されています。A First Templatetemplates/NOTES.txttemplates/NOTES.txt は、Chart をインストールやアップデートした時にターミナル上で表示される文言を記述できます。アクセスすべきURLやリリース結果が見れるものを記載したりしてます。{{ .Chart.Name }} や {{ .Chart.Version }} といった記述できます、これが Helm Template Language となります。Helm Template Language の記法については後述。Creating a NOTES.txt Filetemplates/_helpers.tpltemplates/\_helpers.tpl は、マニフェストファイルではなく、マニフェストファイル内で利用されるグローバル変数（Helm では Named Template と呼ばれます）を定義したファイルとなります。Using "Partials" and Template IncludesHelm について知るHelm Template Language の記法コメントは # の他、{{/*...*/}}のような記法を利用できます。# を利用したコメントはデバッグモードで表示される、という違いがあります。Comments (YAML Comments vs. Template Comments)values.yaml へのアクセスBuilt-in Object とは、Helm Template Lunguage で利用できるオブジェクトというかインスタンスとなります。values.yaml 等に定義した値を取得するには、Values オブジェクト内のインスタンス変数 なになに にアクセスする、みたいな感じで利用するイメージとなります。Release のほか、Valuesや Chart といった Built-in Object を利用しています。Values は、values.yaml に定義された値へアクセスできるオブジェクトです。Chart は、Chart.yaml に定義された値へアクセスできるオブジェクトです。Built-in ObjectsHelm Template で利用できる関数Helmファイルを書いていくとこうしたいあぁしたいとなると思うのですがHelm Template Language 内では、様々な関数がビルトインされています。Helmは60以上の利用可能な関数を持っています。そのうちのいくつかは、Go　Tepｍplate自体で定義されています。{{ .Release.Name | quote }} という記述があったとして、.Release.Name という値に対して、パイプを介し、 quote という引用符を付与する関数を実行しているものになります。こんな感じで、実行したい関数をパイプを介して記述していくことなります。Template Function ListHelm Chart で利用できる制御構文Helm には制御構造が利用できます。 これは、テンプレートの生成の流れを制御する機能を提供します。制御構文は、以下が用意されています。if/else for creating conditional blockswith to specify a scoperange, which provides a "for each"-style loopちなみにGo Tepｍplate自体で定義されています。Flow ControlNamed Templates を用いて一つのページで定義していく名前付きテンプレートとは、単にファイルの中で定義され、名前が付けられたテンプレートのことです。Named Template は、{{ define }} ... {{ end }} アクションで定義を行い、{{ template }} や {{ include }} アクションで、その値を利用することとなります。Named Templates{{ template }} でなく、 {{ include }} しないと、パイプを介した関数の実行できないため、{{ include }} が良い。Using the 'include' Function空白を管理する - の話まず、テンプレート宣言の中括弧の構文を特別な文字で変更し、テンプレートエンジンに空白を切り詰めるように指示する。{{- xxx }} や {{ XX -}}とかで出てきているハイフンですが、これは Helm Template Lunguate を利用した行の空白を管理するものです。ハイフンの有無により空白の除去を実行してくれます。Helm Chart をよくしていくHelm Chart をデバッグしたりリファクタリングする時のヒントを書いていきます。Helm Chart のデバッグHelm Chart ではデバッグする方法をいくつか用意しています。Debugging Templateshelm lint は、Chart がベストプラクティスに沿っているかを確認するためのツールです。helm template --debug はローカルでChart template のレンダリングをテストします。困ったらこれでyaml を直接、確認します。helm install --dry-run --debugは、サーバーがテンプレートをレンダリングし、その結果のマニフェストファイルを返すという素晴らしい方法です。helm get manifestは、サーバーにインストールされているテンプレートを確認する良い方法です。Helm Chart のリファクタリングHelm Chart の品質をあげるためのヒントとコツをいくつか取り上げられています。テンプレートの関数を知り有用と判断すれば利用する文字列を引用する、整数を引用しない。これは絶対に頼む。1つのコマンドでリリースをインストールまたはアップグレードChart Development Tips and TricksHelm Chart のテストtemplates/tests/ ディレクトリ配下においたマニフェストファイルは、helm testコマンドにより実行することができます。Chart TestsHelm Chart のリポジトリ化リポジトリ化するには、index.yaml というファイルとChart 一式を固めた tar ファイルを静的 Web ホスティングサイトにアップロードすることで実現されます。The Chart Repository Guideさいごにこれもあれば読んでほしいという内容があれば名前付きで掲載させていただくので連絡いただきたいです。参考資料Helm Docs | Getting Started]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[運用の効率化を支える AWS Systems Manager Automation の紹介]]></title>
            <link>https://sreake.com/blog/aws-ssm-automation/</link>
            <guid>https://sreake.com/blog/aws-ssm-automation/</guid>
            <pubDate>Thu, 16 Feb 2023 02:40:28 GMT</pubDate>
            <content:encoded><![CDATA[AWS Systems Manager（SSM）では運用に役立つ機能が提供されています。 ただし、提供されている機能が多く、今まで使用した経験があるのは一部の機能に限られていましたので、どのようなことができるのか調べてみ […]The post 運用の効率化を支える AWS Systems Manager Automation の紹介 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitHub Actions でプライベートリポジトリを checkout する]]></title>
            <link>https://zenn.dev/kou_pg_0131/articles/gh-actions-checkout-private-repo</link>
            <guid>https://zenn.dev/kou_pg_0131/articles/gh-actions-checkout-private-repo</guid>
            <pubDate>Mon, 13 Feb 2023 09:40:56 GMT</pubDate>
            <content:encoded><![CDATA[GitHub Actions で別のプライベートリポジトリを checkout する方法のメモ。 サンプルコードこの記事で紹介するサンプルコードは以下のリポジトリで管理しています。https://github.com/koki-develop/gh-actions-checkout-private-repo-example 前置きこのドキュメントでは次の 2 通りの方法についてまとめます。Deploy keys を使う方法Personal Access Token を使う方法いずれの方法も GitHub Actions ワークフローを作成するリポジトリと chec...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Caddy の Internal TLS 証明書の有効期間を指定する]]></title>
            <link>https://blog.1q77.com/2023/02/caddy-internal-tls-cert-lifetime/</link>
            <guid>https://blog.1q77.com/2023/02/caddy-internal-tls-cert-lifetime/</guid>
            <pubDate>Thu, 09 Feb 2023 14:29:32 GMT</pubDate>
            <content:encoded><![CDATA[以前 ワンライナーで https の Reverse Proxy を実行する という記事で Caddy を使うと local での開発用に任意のドメインの証明書を簡単に発行できるし CA の証明書も OS の証明書ストアに保存してくれるた]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[『ポストモーテムはじめました』というタイトルで登壇しました。]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2023/02/09/113316</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2023/02/09/113316</guid>
            <pubDate>Thu, 09 Feb 2023 02:33:16 GMT</pubDate>
            <content:encoded><![CDATA[概要インシデントにどう対応してきたか？みんなで学ぶポストモーテム Lunch LT というイベントで『ポストモーテムはじめました』というタイトルで登壇しました。この登壇には元記事があって良いポストモーテムを執筆するために必要な5つのポイントです。この記事に対していくつかの加筆修正を行い資料にしました。資料登壇資料になります。 speakerdeck.comあとがきポストモーテムについて考えたり調べていくと仕組みよりも組織としての心がけが大事だと思いました。発表の性質や時間の都合上SREでの話に留めたのですが、品質管理についても言及しながらまとめていく活動もしたい。組織を作っていくなら下の2冊はとてもオススメです。心理的安全性のつくりかた　「心理的柔軟性」が困難を乗り越えるチームに変える作者:石井遼介日本能率協会マネジメントセンターAmazon失敗の科学 失敗から学習する組織、学習できない組織作者:マシュー・サイドディスカヴァー・トゥエンティワンAmazon品質管理についてはこちらを参考にしました。失敗を後悔する「恥」として捉えてはいけない。学習する機会と捉え、次に活かせば良い。そのためのスキルが品質管理。ビジュアル品質管理の基本 第5版作者:内田 治日経BPマーケティング(日本経済新聞出版Amazon参考資料SREとはなにかhttps://sreake.com/blog/what-is-sre/良いポストモーテムを執筆するために必要な5つのポイントhttps://sreake.com/blog/5point-good-postmortem/Part III. Practiceshttps://sre.google/sre-book/part-III-practices/SRE サイトリライアビリティエンジニアリングhttps://www.oreilly.co.jp/books/9784873117911/ウェブオペレーションhttps://www.oreilly.co.jp/books/9784873114934/Postmortem Culture: Learning from Failurehttps://sre.google/sre-book/postmortem-culture/チームが機能するとはどういうことか──「学習力」と「実行力」を高める実践アプローチよりhttps://www.amazon.co.jp/dp/B00N8J1NPQ]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitHub Actions から ECR に Docker イメージを push する]]></title>
            <link>https://zenn.dev/kou_pg_0131/articles/gh-actions-ecr-push-image</link>
            <guid>https://zenn.dev/kou_pg_0131/articles/gh-actions-ecr-push-image</guid>
            <pubDate>Wed, 08 Feb 2023 10:03:48 GMT</pubDate>
            <content:encoded><![CDATA[備忘録。 サンプルコード今回紹介するサンプルコードは以下のリポジトリで管理しています。https://github.com/koki-develop/github-actions-ecr-push-example 準備 1. GitHub Actions 用の ID プロバイダと IAM ロールを作成するGitHub Actions で OIDC を使用して AWS 認証を行うために、下記ドキュメントを参考に ID プロバイダと IAM ロールを作成します。https://zenn.dev/kou_pg_0131/articles/gh-actions-oidc-aw...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[OpenSLO とは？]]></title>
            <link>https://sreake.com/blog/openslo/</link>
            <guid>https://sreake.com/blog/openslo/</guid>
            <pubDate>Tue, 07 Feb 2023 03:37:40 GMT</pubDate>
            <content:encoded><![CDATA[はじめに OpenSLO の概要に触れながら SLO as Code の現状についてお話しします。 OpenSLOとは？ OpenSLO とは、サービスレベル目標 (SLO)、それに関連するリソースの記述形式を標準化する […]The post OpenSLO とは？ first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Docker イメージのタグ一覧を取得する docker-tags CLI の紹介]]></title>
            <link>https://zenn.dev/kou_pg_0131/articles/docker-tags-cli-usage</link>
            <guid>https://zenn.dev/kou_pg_0131/articles/docker-tags-cli-usage</guid>
            <pubDate>Mon, 06 Feb 2023 09:19:35 GMT</pubDate>
            <content:encoded><![CDATA[概要Docker イメージのタグ一覧を取得する docker-tags CLI を公開しました。https://github.com/koki-develop/docker-tags以下のように任意の Docker イメージのタグ一覧を取得して出力することができます。$ docker-tags alpinelatestedge3.9.63.9.53.9.4# ...# 名前付きで出力することもできる$ docker-tags alpine -nalpine:latestalpine:edgealpine:3.9.6alpine:3.9.5alpin...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitHub Actions で GitHub の画像キャッシュをクリアする]]></title>
            <link>https://zenn.dev/kou_pg_0131/articles/hub-purge-action-usage</link>
            <guid>https://zenn.dev/kou_pg_0131/articles/hub-purge-action-usage</guid>
            <pubDate>Mon, 30 Jan 2023 10:22:30 GMT</pubDate>
            <content:encoded><![CDATA[GitHub では README などに載せた画像は Camo という画像プロキシ経由で https://camo.githubusercontent.com/... のような URL で配信されるのですが、たまにこれらの画像が長期間キャッシュされてしまうことがあります。例えば僕の GitHub Profile には Badge Generator で作成した Zenn や Qiita のバッジを表示しているのですが、これらの画像が長期間キャッシュされて正しい数値が表示されていないことがありました。GitHub Profileこれらの画像キャッシュをクリアするシェルスクリプトなど...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitLabで指定したグループ内の全てのリポジトリを一括でcloneする]]></title>
            <link>https://zenn.dev/tayusa/articles/ae5911391c9440</link>
            <guid>https://zenn.dev/tayusa/articles/ae5911391c9440</guid>
            <pubDate>Sun, 29 Jan 2023 17:07:31 GMT</pubDate>
            <content:encoded><![CDATA[概要1個1個丹精込めて手動でcloneすることに限界を感じたので、一括で自分に関連するリポジトリをcloneする シェルスクリプト.zshrc# リポジトリのディレクトリを作成してからcloneする# 第1引数 URL(https://gitlab.example.com/diaspora/diaspora-client.git)function git_clone_to_path() {  [[ -z ${commands[git]} ]] \    && { echo 'git is required'; return 1; }  loca...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitHub の README はリポジトリのルートディレクトリ以外にも置ける]]></title>
            <link>https://zenn.dev/kou_pg_0131/articles/github-readme-path</link>
            <guid>https://zenn.dev/kou_pg_0131/articles/github-readme-path</guid>
            <pubDate>Thu, 26 Jan 2023 10:02:07 GMT</pubDate>
            <content:encoded><![CDATA[Twitter で以下のツイートを見かけました。https://twitter.com/azu_re/status/1614458485055586305そこで調べてみたところ、 GitHub では次の場所に置かれている README を認識するようです。.github/リポジトリのルートディレクトリdocs/複数の README が含まれている場合は、 .github/ 、ルートディレクトリ、 docs/ の順に優先されます。例えば冒頭のツイートの reduxjs/redux-toolkit は .github/ ディレクトリ内に README.md (正確には pa...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[【Terraform】CloudFront Functions を使用して Basic 認証を設定する]]></title>
            <link>https://zenn.dev/kou_pg_0131/articles/tf-cloudfront-basicauth</link>
            <guid>https://zenn.dev/kou_pg_0131/articles/tf-cloudfront-basicauth</guid>
            <pubDate>Mon, 23 Jan 2023 10:22:18 GMT</pubDate>
            <content:encoded><![CDATA[たまに必要になるのでメモ。 検証環境Terraform v1.3.7AWS Provider v4.49.0 サンプルコード今回紹介するサンプルコードは下記リポジトリで管理しています。https://github.com/koki-develop/cloudfront-basic-auth-example 準備今回は例として S3 バケットのオブジェクトを配信する CloudFront Distribution を作成します。主題ではないので気になる方のみ読んでください。サンプルコードprovider.tf# AWS Provider の設定prov...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[aws-vault のすすめ]]></title>
            <link>https://sreake.com/blog/aws-vault/</link>
            <guid>https://sreake.com/blog/aws-vault/</guid>
            <pubDate>Thu, 19 Jan 2023 05:45:36 GMT</pubDate>
            <content:encoded><![CDATA[aws-vault とは AWS の認証情報をローカルに安全に保管する事が出来る CLI ツール GitHub Star 7K⭐ (2022-12-22現在) brew で下記のコマンドのようにインストール可能 リポジト […]The post aws-vault のすすめ first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[yaml 管理を自動化する時の必須道具 yq(v4) の倒し方]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2023/01/17/011521</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2023/01/17/011521</guid>
            <pubDate>Mon, 16 Jan 2023 16:15:21 GMT</pubDate>
            <content:encoded><![CDATA[yq とはyq はgoで書かれている軽量でポータブルなコマンドライン YAML、JSON、XML プロセッサです。yq は jq に似た構文を使用しますが、json、xml、properties、csv、tsv と同様に yaml ファイルを処理します。記事の執筆時点の2023 年01月17日時点でv4.30.8 がリリースされています。github.comyqyq のv4 はv3 とはかなり異なっています。v3 で端的に書けていたものが、v4 ではより表現力のある構文言語となった結果としてちょっと冗長になったように思えるんですけどjq っぽいので慣れてしまえばよいものだとおもいます 。mikefarah.gitbook.ioyq 使ってみる今回の目的はapplication/deployment.yaml のimageの値をnginx:1.14.2をnginx:1.23.3に書き換えたいと思います。yaml をCIで変更するなんてなんぼでもやってますからね。Path などの概念については説明を省略します。普通にシェル芸としてやっていくときには1日1問、半年以内に習得　シェル・ワンライナー160本ノックなどを参考にすると良い。apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx-deploymentspec:  selector:    matchLabels:      app: nginx  replicas: 2 # tells deployment to run 2 pods matching the template  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: nginx:1.14.2 # 書き換えたいんじゃ        ports:        - containerPort: 80yq(v4) 使ってみるyq(v4) でreadyq '.spec.template.spec.containers[0].image' deployment.yamlnginx:1.14.2yq(v4) でwriteyq -i '.spec.template.spec.containers[0].image = "nginx:1.23.3"' deployment.yaml確認します。yq '.spec.template.spec.containers[0].image' deployment.yamlnginx:1.23.3で目的達成しました簡単！yq(v3) との違いyq(v3) にはwriteやreadなどのサブコマンドが撤廃されたので準拠した書き方を覚える必要があると思います。mikefarah.gitbook.ioyq(v4) での変数利用yq(v4)ではstrenv(<env>)を利用することで変数を利用することができるIMAGE=nginx yq -i '.spec.template.spec.containers[0].image = strenv(IMAGE)' deployment.yaml確認します。yq '.spec.template.spec.containers[0].image' deployment.yaml nginxﾔｯﾀﾈ!!左辺にはこちら代入できないみたいなのでそのときには作成してからyq に読むこませると良いみたい(他にいい方法があれば教えてほしいです)。    YQ_INPLACE=".${EXE_APP}.image.tag = \"${TAG_HASH}\""    yq -i "${YQ_INPLACE}" "$CHANGE_FILE"おわりv3 -> v4 には変更点がいくつかあります。皆さんもCIで使っている時は気をつけましょう。あとはCI で書き換えで使っている時は-vを使っておきましょう。1日1問、半年以内に習得　シェル・ワンライナー160本ノック Software Design plus作者:上田 隆一,山田 泰宏,田代 勝也,中村 壮一,今泉 光之,上杉 尚史技術評論社Amazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GoReleaser で Go 製 CLI のリリースを自動化＆ Homebrew でインストールできるようにする]]></title>
            <link>https://zenn.dev/kou_pg_0131/articles/goreleaser-usage</link>
            <guid>https://zenn.dev/kou_pg_0131/articles/goreleaser-usage</guid>
            <pubDate>Mon, 16 Jan 2023 10:09:24 GMT</pubDate>
            <content:encoded><![CDATA[GoReleaser と GitHub Actions を使って Go で作った CLI のリリースを自動化して、ついでに Homebrew でインストールできるようにするまでの手順メモです。ちなみに先日、 Go で CLI を作る時に便利だったパッケージについて簡単に紹介する記事を公開しました。こちらも興味があれば見てみてください。https://zenn.dev/kou_pg_0131/articles/go-cli-packages 検証環境Go v1.19GoReleaser v1.14.1GoReleaser Action v4.1.0 GoReleas...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[【Istio⛵️】サイドカーインジェクションの仕組み]]></title>
            <link>https://hiroki-hasegawa.hatenablog.jp/entry/2023/01/14/223815</link>
            <guid>https://hiroki-hasegawa.hatenablog.jp/entry/2023/01/14/223815</guid>
            <pubDate>Sat, 14 Jan 2023 13:38:15 GMT</pubDate>
            <content:encoded><![CDATA[目次01. はじめに02. サイドカーによるサービスメッシュ03. admission-controllersアドオンについて04. サイドカーインジェクションの仕組み05. おわりに01. はじめにどーも。正月で激太りしましたが、ダイエットの予定はありません🙋🏻‍♂️今回は、サービスメッシュを実装するIstio⛵️のサイドカーインジェクションに関する記事を投稿しました。前回の記事に引き続きIstioです。hiroki-hasegawa.hatenablog.jp執筆時点 (2023/01/14) では、Istioが実装するサービメッシュには、『サイドカープロキシメッシュ』と『アンビエントメッシュ』があります。サイドカープロキシメッシュの仕組みの軸になっているものは、サイドカーコンテナであるistio-proxyコンテナです。Istioは、KubernetesのPodの作成時に、istio-proxyコンテナをPod内に自動的にインジェクション (注入) します本記事では、このサイドカーのインジェクションの仕組みをもりもり布教しようと思います😗 (沼のまわりに餌をまく)02. サイドカーによるサービスメッシュなぜサイドカーが必要なのかそもそも、なぜサービスメッシュでサイドカーが必要になったのでしょうか。マイクロサービスアーキテクチャのシステムには、アーキテクチャ固有のインフラ領域の問題 (例：サービスディスカバリーの必要性、マイクロサービス間通信の暗号化、テレメトリー収集、など) があります。アプリエンジニアが各マイクロサービス内にインフラ領域の問題に関するロジックを実装すれば、これらの問題の解決できます。しかし、アプリエンジニアはアプリ領域の問題に責務を持ち、インフラ領域の問題はインフラエンジニアで解決するようにした方が、互いに効率的に開発できます。そこで、インフラ領域の問題を解決するロジックをサイドカーとして切り分けます。これにより、アプリエンジニアとインフラエンジニアの責務を分離できるようになります。また、インフラ領域の共通ロジックをサイドカーとして各マイクロサービスに提供できるため、単純性が高まります。こういった流れの中で、サイドカーを使用したサービスメッシュが登場しました。↪️ 参考：サービスメッシュ、Istioがマイクロサービスのトラフィック制御、セキュリティ、可観測性に欠かせない理由：Cloud Nativeチートシート（9） - ＠ITWhat is Service Mesh and Why is it Necessary?サイドカープロキシメッシュIstioのサイドカーによるサービスメッシュ (サイドカープロキシメッシュ) は、サイドカーコンテナ (istio-proxyコンテナ) が稼働するデータプレーンサイドカーを中央集権的に管理するIstiod (discoveryコンテナ) が稼働するコントロールプレーンからなります。↪️ 参考：Istio / Architecture03. admission-controllersアドオンについてadmission-controllersアドオンとはIstioのPod内へのサイドカーインジェクションの前提知識として、admission-controllersアドオンを理解する必要があります。もし、admission-controllersアドオンをご存知の方は、04. サイドカーインジェクションの仕組み まで飛ばしてください。kube-apiserverでは、admission-controllersアドオンとして有効化できます。有効化すると、認証ステップと認可ステップの後にmutating-admissionステップとvalidating-admissionステップを実行でき、admissionプラグインの種類に応じた処理を挿入できます。クライアント (kubectlクライアント、Kubernetesリソース) からのリクエスト (例：Kubernetesリソースに対する作成/更新/削除、kube-apiserverからのプロキシへの転送) 時に、各ステップでadmissionプラグインによる処理 (例：アドオンビルトイン処理、独自処理) を発火させられます。↪️ 参考：Admission Controllers Reference | KubernetesKubernetes Best Practices: Blueprints for Building Successful Applications on Kubernetes: Burns, Brendan, Villalba, Eddie, Strebel, Dave, Evenson, Lachlan: 9781492056478: Amazon.com: Booksadmissionプラグインの種類admission-controllersアドオンのadmissionプラグインには、たくさんの種類があります。IstioがPod内にサイドカーをインジェクションする時に使用しているアドオンは、『MutatingAdmissionWebhook』です。CertificateApprovalCertificateSigningCertificateSubjectRestrictionDefaultIngressClassDefaultStorageClassDefaultTolerationSecondsLimitRangerMutatingAdmissionWebhook 👈 これ！NamespaceLifecyclePersistentVolumeClaimResizePodSecurityPriorityResourceQuotaRuntimeClassServiceAccountStorageObjectInUseProtectionTaintNodesByConditionValidatingAdmissionWebhook↪️ 参考：Admission Controllers Reference | KubernetesMutatingAdmissionWebhookプラグインMutatingAdmissionWebhookプラグインとはMutatingAdmissionWebhookプラグインを使用すると、mutating-admissionステップ時に、リクエスト内容を変更する処理をフックできます。フックする具体的な処理として、webhookサーバーにAdmissionRequestリクエストとして送信することにより、レスポンスのAdmissionResponseに応じてリクエスト内容を動的に変更します。MutatingWebhookConfigurationで、MutatingAdmissionWebhookプラグインの発火条件やwebhookサーバーの宛先情報を設定します。MutatingWebhookConfigurationの具体的な実装については、サイドカーインジェクションの仕組みの中で説明していきます。↪️ 参考：Diving into Kubernetes MutatingAdmissionWebhook | by Morven Cao | IBM Cloud | Mediumhttps://gashirar.hatenablog.com/entry/2020/10/31/141357/Admission Webhookを作って遊んで、その仕組みを理解しよう（説明編）AdmissionReview、AdmissionRequest、AdmissionResponse▼ AdmissionReviewAdmissionReviewは以下のようなJSONであり、kube-apiserverとwebhookサーバーの間でAdmissionRequestとAdmissionResponseを運びます。{  "apiVersion": "admission.k8s.io/v1",  "kind": "AdmissionReview",  # AdmissionRequest  "request": {},  # AdmissionResponse  "response": {}  }↪️ 参考：v1 package - k8s.io/api/admission/v1 - Go Packages▼ AdmissionRequestAdmissionRequestは以下のようなJSONです。kube-apiserverがクライアントから受信した操作内容が持つことがわかります。例で挙げたAdmissionRequestでは、クライアントがDeploymentをCREATE操作するリクエストをkube-apiserverに送信したことがわかります。{  "apiVersion": "admission.k8s.io/v1",  "kind": "AdmissionReview",  # AdmissionRequest  "request": {    ...    # 変更されるKubernetesリソースの種類を表す。    "resource": {      "group": "apps",      "version": "v1",      "resource": "deployments"    },    # kube-apiserverの操作の種類を表す。    "operation": "CREATE",    ...  }}↪️ 参考：Dynamic Admission Control | Kubernetes▼ AdmissionResponse一方でAdmissionResponseは、例えば以下のようなJSONです。AdmissionResponseに応じたマニフェスト変更処理をpatchキーの値に持ち、これはbase64方式でエンコードされています。{  "apiVersion": "admission.k8s.io/v1",  "kind": "AdmissionReview",  # AdmissionResponse  "response": {    "uid": "<value from request.uid>",    # 宛先のwebhookサーバーが受信したか否かを表す。    "allowed": true,    # PathによるPatch処理を行う。    "patchType": "JSONPatch",    # Patch処理の対象となるKubernetesリソースと処理内容を表す。base64方式でエンコードされている。    "patch": "W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0="  }}エンコード値をデコードしてみると、例えば以下のようなpatch処理が定義されています。# patchキーをbase64方式でデコードした場合[  {    "op": "add",    "path": "/spec/replicas",    "value": 3  }]マニフェストに対する操作 (op) 、キー (path) 、値 (value) が設定されています。kube-apiserverがこれを受信すると、指定されたキー (.spec.replicas) に値 (3) に追加します。↪️ 参考：Dynamic Admission Control | Kubernetes04. サイドカーインジェクションの仕組み全体のフロー前提知識を踏まえた上で、admission-controllersアドオンの仕組みの中で、サイドカーのistio-proxyコンテナがどのようにPodにインジェクションされるのかを見ていきましょう。最初に、サイドカーインジェクションのフローは以下の通りになっています。画像の文字が小さくなってしまったため、拡大していただけると🙇🏻‍♂️↪️ 参考：Amazon.co.jp: Istio in Action (English Edition) 電子書籍: Posta, Christian E., Maloku, Rinor: 洋書クライアント ➡︎ kube-apiserverここで説明するフロー箇所『クライアント ➡︎ kube-apiserver』の箇所を説明します。(１) Podの作成をリクエストまずは、クライアントがkube-apiserverにリクエストを送信するところです。クライアント (Deployment、DaemonSet、StatefulSet、を含む) は、Podの作成リクエストをkube-apiserverに送信します。この時のリクエスト内容は、以下の通りとします。# Podを作成する。$ kubectl apply -f foo-pod.yaml# foo-pod.yamlファイルapiVersion: v1kind: Podmetadata:  name: foo-pod  namespace: foo-namespacespec:  containers:    - name: foo      image: foo:1.0.0      ports:        - containerPort: 80またNamespaceでは、あらかじめistio-proxyコンテナのインジェクションが有効化されているとします。Istioではv1.10以降、リビジョンの番号のエイリアスを使用して、istio-proxyコンテナのインジェクションを有効化するようになりました。エイリアスの名前は自由であり、私の携わっているプロジェクトではstableを使用しています。apiVersion: v1kind: Namespacemetadata:  name: foo-namespace  labels:    # istio-proxyコンテナのインジェクションを有効化する。    # エイリアス名は自由    istio.io/rev: <エイリアス>↪️ 参考：Istio / Announcing Support for 1.8 to 1.10 Direct Upgradeskube-apiserver ➡︎ Serviceここで説明するフロー箇所『kube-apiserver ➡︎ Service』の箇所を説明します。(２) 認証認可処理をコールkube-apiserverは、認証ステップと認可ステップにて、クライアントからのリクエストを許可します。(３) アドオンの処理をコールkube-apiserverは、mutating-admissionステップにて、MutatingAdmissionWebhookプラグインの処理をコールします。前提知識の部分で具体的な実装を省略しましたが、Istioのバージョン1.14.3時点で、MutatingWebhookConfigurationは以下のようになっています。Namespaceでサイドカーインジェクションを有効化する時に使用したエイリアスは、このMutatingWebhookConfigurationで実体のリビジョン番号と紐づいています。$ kubectl get mutatingwebhookconfiguration istio-revision-tag-stable -o yamlapiVersion: admissionregistration.k8s.io/v1beta1kind: MutatingWebhookConfigurationmetadata:  name: istio-revision-tag-stable  labels:    app: sidecar-injector    # エイリアスの実体    istio.io/rev: <リビジョン番号>    # リビジョン番号のエイリアス    istio.io/tag: <エイリアス>webhooks:  - name: rev.namespace.sidecar-injector.istio.io    # MutatingAdmissionWebhookプラグインの処理の発火条件を登録する。    rules:      - apiGroups: [""]        apiVersions: ["v1"]        operations: ["CREATE"]        resources: ["pods"]        scope: "*"    # Webhookの前段にあるServiceの情報を登録する。    clientConfig:      service:        name: istiod-<リビジョン番号>        namespace: istio-system        path: "/inject" # エンドポイント        port: 443      caBundle: Ci0tLS0tQk ...    # Namespace単位のサイドカーインジェクション    # 特定のNamespaceでMutatingAdmissionWebhookプラグインの処理を発火させる。    namespaceSelector:      matchExpressions:        - key: istio.io/rev          operator: DoesNotExist        - key: istio-injection          operator: DoesNotExist    # Pod単位のサイドカーインジェクション    # 特定のオブジェクトでMutatingAdmissionWebhookプラグインの処理を発火させる。    objectSelector:      matchExpressions:        - key: sidecar.istio.io/inject          operator: NotIn          values:            - "false"        - key: istio.io/rev          operator: In          values:            - <エイリアス>    ...MutatingWebhookConfigurationには、MutatingAdmissionWebhookプラグインの発火条件やwebhookサーバーの宛先情報を定義します。MutatingAdmissionWebhookプラグインの発火条件に関して、例えばIstioでは、NamespaceやPod.metadata.labelsキーに応じてサイドカーインジェクションの有効化/無効化を切り替えることができ、これをMutatingAdmissionWebhookプラグインで制御しています。webhookサーバーの宛先情報に関して、Istioではwebhookサーバーの前段にServiceを配置しています。MutatingAdmissionWebhookプラグインが発火した場合、Serviceの/inject:443にHTTPSプロトコルのリクエストを送信するようになっています。また、送信先のServiceの名前がistiod-<リビジョン番号>となっていることからもわかるように、Serviceは特定のバージョンのIstiodコントロールプレーンに対応しており、想定外のバージョンのIstiodコントロールプレーンを指定しないように制御しています。一方で発火しなかった場合には、以降のAdmissionReviewの処理には進みません。(４) AdmissionRequestに値を詰めるkube-apiserverは、mutating-admissionステップにて、クライアントからのリクエスト内容 (Podの作成リクエスト) をAdmissionReveiew構造体のAdmissionRequestに詰めます。{  "apiVersion": "admission.k8s.io/v1",  "kind": "AdmissionReview",  # AdmissionRequest  "request": {    ...    # 変更されるKubernetesリソースの種類を表す。    "resource": {      "group": "core",      "version": "v1",      "resource": "pods"    },    # kube-apiserverの操作の種類を表す。    "operation": "CREATE",    ...  }}(５) AdmissionReviewを送信kube-apiserverは、mutating-admissionステップにて、Serviceの/inject:443にAdmissionReview構造体を送信します。Service ➡︎ webhookサーバーここで説明するフロー箇所『Service ➡︎ webhookサーバー』の箇所を説明します。(６) 15017番ポートにポートフォワーディングServiceは、/inject:443でリクエストを受信し、discoveryコンテナの15017番ポートにポートフォワーディングします。Istioのバージョン1.14.3時点で、Serviceは以下のようになっています。$ kubectl get svc istiod-service -n istio-system -o yamlapiVersion: v1kind: Servicemetadata:  namespace: istio-system  name: istiod-<リビジョン番号>  labels:    app: istiodspec:  type: ClusterIP  selector:    app: istiod    istio.io/rev: <リビジョン番号>  ports:    - name: grpc-xds      port: 15010      protocol: TCP      targetPort: 15010    - name: https-dns      port: 15012      protocol: TCP      targetPort: 15012    # webhookサーバーにポートフォワーディングする。    - name: https-webhook      port: 443      protocol: TCP      targetPort: 15017    - name: http-monitoring      port: 15014      protocol: TCP      targetPort: 15014.spec.selector.istio.io/revキーに、ポートフォワーディング先のPodを指定するためのリビジョン番号が設定されており、このPodはdiscoveryコンテナを持ちます。Istioは、discoveryコンテナ内でwebhookサーバーを実行し、15017番ポートでリクエストを待ち受けます。ここで、discoveryコンテナがリクエストを待ち受けているポート番号を見てみると、15017番ポートでリッスンしていることを確認できます。$ kubectl exec foo-istiod -n istio-system -- netstat -tulpnActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    tcp        0      0 127.0.0.1:9876          0.0.0.0:*               LISTEN      1/pilot-discovery   tcp6       0      0 :::15017                :::*                    LISTEN      1/pilot-discovery   tcp6       0      0 :::8080                 :::*                    LISTEN      1/pilot-discovery   tcp6       0      0 :::15010                :::*                    LISTEN      1/pilot-discovery   tcp6       0      0 :::15012                :::*                    LISTEN      1/pilot-discovery   tcp6       0      0 :::15014                :::*                    LISTEN      1/pilot-discovery ↪️ 参考：istio/webhook.go at 1.14.3 · istio/istio · GitHubIstio / Application Requirementskube-apiserver ⬅︎ Service ⬅︎ webhookサーバーここで説明するフロー箇所『kube-apiserver ⬅︎ Service ⬅︎ webhookサーバー』の箇所を説明します。(７) patch処理を定義仕組みの中でも、ここは重要な部分です。discoveryコンテナ内のwebhookサーバーは、リクエスト内容を書き換えるためのpatch処理を定義します。webhookサーバーは、マニフェストの.spec.containers[1]パスにistio-proxyキーを追加させるようなpatch処理を定義します。この定義によって、結果的にサイドカーのインジェクションが起こるということになります。[  ...  {    "op": "add",    # .spec.initContainers[1] を指定する。    "path": "/spec/initContainers/1",    # マニフェストファイルに追加される構造を表す。    "value": {      "name": "istio-init",      "resources": {                     ...      }    }  },  {    "op": "add",    # .spec.containers[1] を指定する。    "path": "/spec/containers/1",    # マニフェストファイルに追加される構造を表す。    "value": {      "name": "istio-proxy",      "resources": {                     ...      }    }  }  ...]↪️ 参考：istio/webhook.go at a19b2ac8af3ad937640f6e29eed74472034de2f5 · istio/istio · GitHubistio/webhook_test.go at 1.14.3 · istio/istio · GitHub本題と話が逸れるため今回は詳しく言及しませんが、上記のpathc処理ではサイドカーコンテナのistio-proxyコンテナの他に、initコンテナのistio-initコンテナもインジェクションできるようにします。このistio-initコンテナは、istio-proxyコンテナを持つPodでインバウンド/アウトバウンド通信の経路を制御できるように、Pod内にiptablesのルールを適用する責務を担っています。↪️ 参考：Istio Sidecar's interception mechanism for traffic - SoByte(８) AdmissionResponseに値を詰めるdiscoveryコンテナ内のwebhookサーバーは、patch処理の定義をAdmissionReveiew構造体のAdmissionResponseに詰めます。patchキーの値に、先ほどのpatch処理の定義をbase64方式でエンコードした文字列が割り当てられています。{  "apiVersion": "admission.k8s.io/v1",  "kind": "AdmissionReview",  # AdmissionResponse  "response": {    "uid": "*****",    "allowed": true,    "patchType": "JSONPatch",    # Patch処理の対象となるKubernetesリソースと処理内容を表す。base64方式でエンコードされている。    "patch": "<先ほどのpatch処理の定義をbase64方式でエンコードした文字列>"  }}↪️ 参考：istio/webhook.go at 1.14.3 · istio/istio · GitHub(９) AdmissionReviewを返信discoveryコンテナ内のwebhookサーバーは、AdmissionReview構造体をレスポンスとしてkube-apiserverに返信します。kube-apiserver ➡︎ etcdここで説明するフロー箇所『kube-apiserver ➡︎ etcd』の箇所を説明します。(１０) patch処理をコールkube-apiserverは、AdmissionReview構造体を受信し、AdmissionResponseに応じてリクエスト内容を書き換えます。patch処理の定義をAdmissionReview構造体から取り出し、クライアントからのリクエスト内容を書き換えます。具体的には、istio-proxyコンテナとistio-initコンテナを作成できるように、リクエストしたマニフェストの該当箇所にキーを追加します。apiVersion: v1kind: Podmetadata:  name: foo-pod  namespace: foo-namespacespec:  containers:    - name: foo      image: foo:1.0.0      ports:        - containerPort: 80    # kube-apiserverが追加    - name: istio-proxy      ...  # kube-apiserverが追加  initContainers:    - name: istio-init    ...(１１) マニフェストを永続化kube-apiserverは、etcdにPodのマニフェストを永続化します。クライアント ⬅︎ kube-apiserverここで説明するフロー箇所『クライアント ⬅︎ kube-apiserver』の箇所を説明します。(１２) コール完了を返信kube-apiserverは、クライアントにレスポンスを受信します。$ kubectl apply -f foo-pod.yaml# kube-apiserverからレスポンスが返ってくるpod "foo-pod" created以降の仕組みkube-apiserverは、他のNodeコンポーネント (kube-controlleretcd、kube-scheduler、kubelet、など) と通信し、Podを作成します。このPodのマニフェストは、アプリコンテナの他に、istio-proxyコンテナとistio-initコンテナを持ちます。結果として、サイドカーコンテナのistio-proxyコンテナをインジェクションしたことになります。本題と話が逸れるため今回は詳しく言及しませんが、kube-apiserverと他コンポーネントの通信については、以下の方の記事と図が非常に参考になると思います🙇🏻‍♂️↪️ 参考：Kubernetes Master Components: Etcd, API Server, Controller Manager, and Scheduler | by Jorge Acetozi | jorgeacetozi | Medium05. おわりに今回、Istioのサイドカーインジェクションの仕組みをもりもり布教しました。最後までお付き合いいただきありがとうございました。今回登場したMutatingAdmissionWebhookプラグインに関して、私の関わっているプロダクトではIstio以外 (例：CertManager、Prometheus、AWSのaws-eks-vpc-cniアドオン、など) でも使用しています。そのため、MutatingAdmissionWebhookプラグインをどのように使っているのかを一度知れば、知識の汎用性が高いと考えています✌🏻サイドカーインジェクションはIstioでも基本的な機能であり、もし未体験の方がいらっしゃれば、お手元でサイドカーコンテナが追加されることを確認していただくとよいかもしれません👍]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2023年1月版キャッシュレス生活まとめ]]></title>
            <link>https://pranc1ngpegasus.hatenablog.com/entry/2023/01/13/225206?utm_source=feed</link>
            <guid>https://pranc1ngpegasus.hatenablog.com/entry/2023/01/13/225206?utm_source=feed</guid>
            <pubDate>Fri, 13 Jan 2023 13:52:06 GMT</pubDate>
            <content:encoded><![CDATA[去年も書いたので今年も書く。pranc1ngpegasus.hatenablog.com図および下記文章における「夫」は筆者を指す。主なアップデート内容夫の収入の流入経路が簡素化されました妻が住信SBIネット銀行およびSBI証券を開設しました妻がつみたてNISAをはじめました2021年に生まれた第一子を追加しました第一生命NEOBANK2023年1月からサービスが開始された第一生命NEOBANKが追加された。通常の住信SBIネット銀行は15歳以上のみ口座開設ができるのだが、第一生命との提携NEOBANKでは親が第一生命支店に口座を持っている場合に限り0歳から口座開設が可能になった。我が家ではSBI証券を通じてつみたてNISAやジュニアNISAを利用しているので銀行も住信SBIネット銀行であるほうがありがたい。これまで子の銀行口座は楽天銀行を使っていたが、第一生命NEOBANKに移行したことで親から子への振込手数料などが発生しなくなった。「親が第一生命支店に口座を持っている場合に限り…」の制約があるので夫のおこづかい口座も第一生命NEOBANKになった。まとめいろんなサービスを試してみたり、辞めてみたりしていると持ち物が多くなってしまって煩雑になる。年に一度でも図に起こしてみると、本当に必要なものなのか判断できるし無駄な部分に気づけるのでおすすめ。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[xmllint で HTML 内の任意の値を取り出す]]></title>
            <link>https://blog.1q77.com/2023/01/xmllint-html-xpath/</link>
            <guid>https://blog.1q77.com/2023/01/xmllint-html-xpath/</guid>
            <pubDate>Thu, 12 Jan 2023 14:40:51 GMT</pubDate>
            <content:encoded><![CDATA[サクッと shell script で HTML の中の何かを取り出したい時があります。 そんな時に使えるのが xmllint. しっかりやるなら python の Beautiful Soup を使ったりしますが、本当に簡単なことを簡単にやりたい場合に xmllint]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[MongoDB Atlas の紹介]]></title>
            <link>https://sreake.com/blog/mongodb-atlas/</link>
            <guid>https://sreake.com/blog/mongodb-atlas/</guid>
            <pubDate>Wed, 11 Jan 2023 23:57:02 GMT</pubDate>
            <content:encoded><![CDATA[MongoDB Atlas とは MongoDB Atlas (以下 Atlas という)は、MongoDB Inc.によって作られた MongoDB の DBaaS(DB as a Service) です。 Atlas […]The post MongoDB Atlas の紹介 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitHub Actions で機密性の無い変数を設定できるようになったので試してみる]]></title>
            <link>https://zenn.dev/kou_pg_0131/articles/gh-actions-configurations-variables</link>
            <guid>https://zenn.dev/kou_pg_0131/articles/gh-actions-configurations-variables</guid>
            <pubDate>Wed, 11 Jan 2023 10:07:51 GMT</pubDate>
            <content:encoded><![CDATA[GitHub Actions で変数を設定できるようになりました 🎉🎉🎉🎉https://github.blog/changelog/2023-01-10-github-actions-support-for-configuration-variables-in-workflows/これまではワークフローで再利用可能な値を使用するためには Secret として保存する必要がありました。しかし Secret は一度設定すると値を確認することができないため、機密性の無いデータでもどんな値が設定されているかを確認することができないのが不便でした。今回の更新で、機密性の無いデータは変数と...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Go でイケてる CLI を作るために利用したパッケージ]]></title>
            <link>https://zenn.dev/kou_pg_0131/articles/go-cli-packages</link>
            <guid>https://zenn.dev/kou_pg_0131/articles/go-cli-packages</guid>
            <pubDate>Tue, 10 Jan 2023 10:05:41 GMT</pubDate>
            <content:encoded><![CDATA[先日、 cLive というターミナルを自動操作する Go 製のコマンドラインツールを公開しました。https://github.com/koki-develop/clive#readmecLive で JavaScript のライブコーディングをするデモこの記事では Go でイケてる感じの CLI を作るために利用したパッケージを簡単に紹介します。cLive については以下の記事をご参照ください。https://zenn.dev/kou_pg_0131/articles/clive-introduction 利用したパッケージCobra : CLI フレームワーク...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CodeDeploy Agent のバージョンアップを自動化する]]></title>
            <link>https://sreake.com/blog/codedeploy-agent-update/</link>
            <guid>https://sreake.com/blog/codedeploy-agent-update/</guid>
            <pubDate>Tue, 10 Jan 2023 01:22:39 GMT</pubDate>
            <content:encoded><![CDATA[概要 Auto Scaling Group 内のインスタンスで CodeDeploy を使用する場合、Agent のバージョンアップが手間なので AMI にインストールしない方がよいです。 Systems Manager […]The post CodeDeploy Agent のバージョンアップを自動化する first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[HTML/CSS を SVG に変換する Vercel 製のパッケージ「satori」を試してみる]]></title>
            <link>https://zenn.dev/kou_pg_0131/articles/satori-usage</link>
            <guid>https://zenn.dev/kou_pg_0131/articles/satori-usage</guid>
            <pubDate>Mon, 02 Jan 2023 10:42:56 GMT</pubDate>
            <content:encoded><![CDATA[Next.js では Vercel's Edge Functions を使用して動的に OGP 画像を生成できる @vercel/og という Vercel 製のパッケージが公開されています。https://www.npmjs.com/package/@vercel/ogこの @vercel/og では内部的に satori という HTML/CSS を SVG に変換するパッケージが使用されています。https://www.npmjs.com/package/satori面白そうだったので簡単に試してみたメモです。こういう SVG も簡単に作れます。バッジっぽいやつ ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[イェーイ あけまして 2023]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2023/01/01/145552</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2023/01/01/145552</guid>
            <pubDate>Sun, 01 Jan 2023 05:55:52 GMT</pubDate>
            <content:encoded><![CDATA[あいさつ謹んで新春をお祝い申し上げます。旧年中は大変お世話になり、誠にありがとうございました。皆様は、にぎやかに、楽しくお過ごしのことと存じます。旧年は同棲をする、家を締め出される、原因不明の体調不良に陥る、クリスマスにフラれる、転居決定 など、人生の不条理さ否応なしに思い知らされた2022年でした。イェーイ！登壇登壇をいくつかしましたがあまり注目されることはなかった気がします。もう少し有用だと思われる発表を頑張りたいと思います。b.hatena.ne.jpブログいくつかのブログを書いた。たまにはてなブックマークにあがったりなどしました。来年はもう少しブログを書いて量を出していきたいと思いました。b.hatena.ne.jp2022年の振り返り（KPT）Keep技術書籍以外もたくさん読むことができた登壇の目標は達成できた人生ができていたブログの投稿数は目標達成できた人を巻き込んで仕事ができたProblem人生をやった分、手を動かす時間が少なくなってしまった人生でもっと頭を使っていくそこそこ大きな失敗をしてメンタルブレイクしてた時期があり、復旧に時間が掛かった原因不明の体調不良の時間が増えたTry積ん読を減らす人生を推測せず計測する心身の健康(運動して痩せる)ブログを書くさいごに2023年も引き続きよろしくお願いします。知らない人からでも、お茶に誘われると喜ぶので誘ってください。2023年の目標は健康と健忘です。ごめん、同級会にはいけません。いま、ジムにいます。あけましておめでとうございます🎍⛩ pic.twitter.com/AjjH18g1JC— nwiizo (@nwiizo) 2022年12月31日]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2022年を振り返る]]></title>
            <link>https://pranc1ngpegasus.hatenablog.com/entry/2022/12/30/100437?utm_source=feed</link>
            <guid>https://pranc1ngpegasus.hatenablog.com/entry/2022/12/30/100437?utm_source=feed</guid>
            <pubDate>Fri, 30 Dec 2022 01:04:37 GMT</pubDate>
            <content:encoded><![CDATA[年の瀬ですね。個人的あっという間に終わった1年ランキング第一位の2022年を掻い摘んで振り返ってみます。2021年から継続していたこと自宅の新築計画毎週のように工務店さんに通って計画を練っていた子育て2021年6月に娘が生まれた1月娘がつかまり立ち、伝い歩きをするようになった2月娘が靴デビューした外で靴に慣れる練習をしはじめた娘氏はじめての散髪前髪が伸びてきたので切った3月娘を連れてはじめての帰省娘から見たひいひいおばあちゃんに会った (高祖母というらしい)帰省中に実家で一人歩きが急成長した初節句の写真撮影をした4月娘がヘルメット治療をはじめたpranc1ngpegasus.hatenablog.com5月新築計画を断念しばらくはペット可の戸建て賃貸で暮らそうとなった娘がワンコのリードを持って散歩したがりはじめた散歩してるのか、散歩されてるのかわからん6月娘が1歳になった一升餅を軽々と背負って歩いた引っ越した新築を断念して一軒家の賃貸へKyashを退職したpranc1ngpegasus.hatenablog.com7月スリーシェイクにジョインしたpranc1ngpegasus.hatenablog.com8月秋田県に大曲の花火を見にいった雨で空腹 + おんぶ移動したら歩きたいでギャン泣きはじめての花火を驚いた顔をして楽しんでいた様子9月ライカSL2-Sを買った娘が活動的になってきたので写真できれいに残したくなった娘との朝んぽがさらに楽しくなった10月娘のヘルメット治療がおわったヘルメット内が蒸れる時期を一緒にがんばった遅いスタートだったけどめちゃめちゃ改善した娘がはじめて風邪をひいた40℃の発熱寒くなってきたのに薄着のまま外で遊ばせてしまったせいかも…11月来夏から履くクルマのホイールを買ったいままで純正ホイールに夏/冬タイヤを履き替えてもらっていた満足のいくデザインのホイールを手に入れたので満足娘のイヤイヤ期が顕著になってきたまだまだ序章なんだろうけど難しい!はじめてワンワンわんだーらんどを観にいった娘氏、大興奮親も初わんわんで楽しめた12月娘氏はじめてのクリスマスパーティご飯もプレゼントも喜んでくれたまとめほとんど子育ての内容だった。来年はまた家族が増える予定なので、さらにがんばっていこー。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Lima の vmType VZ と virtiofs を試す]]></title>
            <link>https://blog.1q77.com/2022/12/lima-vz/</link>
            <guid>https://blog.1q77.com/2022/12/lima-vz/</guid>
            <pubDate>Thu, 29 Dec 2022 15:49:47 GMT</pubDate>
            <content:encoded><![CDATA[Lima が version 0.14.0 で QEMU だけではなく macOS の Virtualization.Framework に対応していました。 vmtype という設定項目が増えています。 この新しい Framework では Host のディレクトリをマウントするのに virtiofs が使えるようになっており、]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[rbspy で ruby の stacktrace を flamegraph にする]]></title>
            <link>https://blog.1q77.com/2022/12/rbspy/</link>
            <guid>https://blog.1q77.com/2022/12/rbspy/</guid>
            <pubDate>Wed, 28 Dec 2022 11:26:10 GMT</pubDate>
            <content:encoded><![CDATA[中身をよく知らない Rails アプリでどこが遅いのかな？と思って rbspy ( github) を試してみたのでメモ。 とりあえず使って flamegraph を書き出してみたんだけどそもそも flamegraph がどういうものなのか分かっ]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Professional Cloud Security Engineer の振り返り]]></title>
            <link>https://qiita.com/dirtymosschan/items/2c66eec7919220a4ec06</link>
            <guid>https://qiita.com/dirtymosschan/items/2c66eec7919220a4ec06</guid>
            <pubDate>Wed, 28 Dec 2022 08:57:17 GMT</pubDate>
            <content:encoded><![CDATA[はじめに2022/12/28 に Google Cloud Certification の１つである、Professional Cloud Security Engineer に合格したので、そち…]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[go.mod の更新]]></title>
            <link>https://blog.1q77.com/2022/12/updage-go-mod/</link>
            <guid>https://blog.1q77.com/2022/12/updage-go-mod/</guid>
            <pubDate>Tue, 27 Dec 2022 03:52:31 GMT</pubDate>
            <content:encoded><![CDATA[たまに使い捨ての code を書いて放置する程度だと毎回ググってしまうのでメモ。 go.mod の更新は go get や go mod tidy で行うことができる。 go の version を更新> go の version を更新 # go.mod 内の go の version は次のよ]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitHub Actions でプライベートリポジトリの Action を共有できるようになったので試してみる]]></title>
            <link>https://zenn.dev/kou_pg_0131/articles/gh-actions-share-private</link>
            <guid>https://zenn.dev/kou_pg_0131/articles/gh-actions-share-private</guid>
            <pubDate>Mon, 26 Dec 2022 10:51:28 GMT</pubDate>
            <content:encoded><![CDATA[先日 GitHub Actions で同一ユーザーもしくは組織内でプライベートリポジトリの Action が共有できるようになりました。https://github.blog/changelog/2022-12-14-github-actions-sharing-actions-and-reusable-workflows-from-private-repositories-is-now-ga/実際の挙動や必要な設定が気になったので試してみたメモです。 要約プライベートリポジトリの Action・Reusable Workflow・Composite Action を同一オー...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[【Istio⛵️】サービスディスカバリーの仕組み]]></title>
            <link>https://hiroki-hasegawa.hatenablog.jp/entry/2022/12/25/060000</link>
            <guid>https://hiroki-hasegawa.hatenablog.jp/entry/2022/12/25/060000</guid>
            <pubDate>Sat, 24 Dec 2022 21:00:00 GMT</pubDate>
            <content:encoded><![CDATA[目次01. はじめに02. サービスディスカバリーについて03. Istioのサービスディスカバリー04. istio-proxyコンテナ内のEnvoyの仕組み05. おわりに謝辞01. はじめに3-shake Advent Calender 2022 最終日の記事です🎅🎄私は普段は 俺の技術ノート に知見を記録しており、はてなブログはデビュー戦となります。さて今回は、サービスメッシュを実装するIstio⛵️のサービスディスカバリーに関する記事を投稿しました。Istioの機能の一つである『サービスディスカバリー』の仕組みを、Envoyを交えながら、もりもり布教しようと思います (沼のまわりに餌をまく) 。今回の記事では、先日の 3-shake SRE Tech Talk で発表した内容に加えて、スライドの余白と発表時間の制約で記載できなかったことも記載しました😗↪️ 参考：Istio⛵️によるサービスディスカバリーの仕組み - Speaker Deck02. サービスディスカバリーについてマイクロサービスアーキテクチャにおけるサービスディスカバリーサービスディスカバリーとはマイクロサービスアーキテクチャでは、マイクロサービスからマイクロサービスにリクエストを送信する場面があります。サービスディスカバリーとは、宛先マイクロサービスの宛先情報 (例：IPアドレス、完全修飾ドメイン名、など) を検出し、送信元マイクロサービスが宛先マイクロサービスにリクエストを継続的に送信できるようにする仕組みのことです。なぜサービスディスカバリーが必要なのかそもそも、なぜサービスディスカバリーが必要なのでしょうか。マイクロサービスアーキテクチャでは、システムの信頼性 (定められた条件下で定められた期間にわたり、障害を発生させることなく実行する程度) を担保するために、マイクロサービスのインスタンスの自動スケーリングを採用します。この時、自動スケーリングのスケールアウトでマイクロサービスが増加するたびに、各インスタンスには新しい宛先情報が割り当てられてしまいます。また、マイクロサービスが作り直された場合にも、宛先情報は更新されてしまいます。このように、たとえインスタンスの宛先情報が更新されたとしても、インスタンスへのリクエストに失敗しない仕組みが必要です。サービスディスカバリーの要素サービスディスカバリーの仕組みは、次の要素からなります。名前解決に関しては、DNSベースのサービスディスカバリー (例：CoreDNS + Service + kube-proxyによるサービスディスカバリー) で必要となり、Istioでは使いません。そのため、本記事では言及しないこととします🙇🏻‍♂️ 要素            責務                                          送信元マイクロサービス  リクエストを送信する。                                 宛先マイクロサービス    リクエストを受信する。                                 サービスレジストリ       宛先マイクロサービスの宛先情報を保管する。                 ロードバランサー        宛先マイクロサービスのインスタンスにロードバランシングする。              名前解決        宛先マイクロサービスへのリクエスト送信時に、名前解決できるようにする。 サービスディスカバリーのパターンサービスディスカバリーのパターンとはサービスディスカバリーの仕組みにはいくつか種類があります。Istioのサービスディスカバリーは、このうちのサーバーサイドパターンを実装したものになります。サーバーサイドパターン送信元マイクロサービスから、問い合わせとロードバランシングの責務が切り離されています。送信元マイクロサービスは、ロードバランサーにリクエストを送信します。ロードバランサーは、宛先マイクロサービスの宛先をサービスレジストリに問い合わせ、またリクエストをロードバランシングする責務を担います。 (例) Istio、Linkerd、など↪️ 参考：https://www.amazon.co.jp/dp/B09782D5HZ/Server-side service discovery patternクライアントサイドパターン通信の送信元マイクロサービスは、宛先マイクロサービスの宛先をサービスレジストリに問い合わせ、さらにロードバランシングする責務を担います。 (例) NeflixのEureka、など↪️ 参考：https://www.amazon.co.jp/dp/B09782D5HZ/Client-side service discovery patternService Discovery in Kubernetes: Combining the Best of Two Worlds03. IstioのサービスディスカバリーIstioのサービスディスカバリーの仕組みIstioが実装するサービスメッシュには、サイドカープロキシメッシュとアンビエントメッシュがあり、今回はサイドカープロキシメッシュのサービスディスカバリーを取り上げます。Istioのサービスディスカバリーは、discoveryコンテナとistio-proxyコンテナが軸となり、サーバーサイドパターンのサービスディスカバリーを実装します。各コンテナについて詳しく見ていく前に、全体像を解説します。 (１) kube-apiserverは、Pod等の宛先情報をetcd等に保管する。これは、Kubernetesの通常の仕組みである。 (２) discoveryコンテナは、kube-apiserverからPod等の宛先情報を取得し、自身に保管する。 (３) istio-proxyコンテナは、discoveryコンテナからPod等の宛先情報を双方向ストリーミングRPCで取得する。 (４) 送信元マイクロサービスがリクエストを送信する。Pod内のiptablesがこれをリダイレクトし、istio-proxyコンテナが受信する。 (５) istio-proxyコンテナは、リクエストをロードバランシングし、宛先Podにこれを送信する。上記では、サーバーサイドパターンでの責務通り、送信元マイクロサービスはロードバランサー (ここではistio-proxyコンテナ) にリクエストを送信しています。この時、送信元マイクロサービスがistio-proxyコンテナに直接的にリクエストを送信しているというよりは、iptablesがistio-proxyコンテナにリクエストをリダイレクトしてくれています。またistio-proxyコンテナは、サービスレジストリへの問い合わせと、ロードバランシングする責務を担っています。↪️ 参考：https://www.amazon.co.jp/dp/1617295825/Jimmy Song - 专注于探索后 Kubernetes 时代的云原生新范式Tech-赵化冰的博客 | Zhaohuabing Blogdiscoveryコンテナの仕組みdiscoveryコンテナを詳しく見てみましょう。discoveryコンテナは、別名Istiodと呼ばれています。XDS-APIというエンドポイントを公開しており、XDS-APIのうち、サービスディスカバリーに関係するAPIは以下の通りです。 APIの種類  説明                                       LDS-API   Envoyのリスナー値を取得できる。                      RDS-API   Envoyのルート値を取得できる。                       CDS-API   Envoyのクラスター値を取得できる。                     EDS-API   Envoyのエンドポイント値できる。                        ADS-API   各XDS-APIから取得できる宛先情報を整理して取得できる。 discoveryコンテナは、kube-apiserverからPod等の宛先情報を取得して自身のメモリ上に保管し、各XDS-APIから提供します。XDS-APIとistio-proxyコンテナの間では、gRPCの双方向ストリーミングRPCの接続が確立されています。そのため、istio-proxyコンテナからのリクエストに応じて宛先情報を返却するだけでなく、リクエストがなくとも、XDS-APIからもistio-proxyコンテナに対して宛先情報を送信します。各種XDS-APIから個別に宛先情報を取得できますが、Envoy上で宛先情報のバージョンの不整合が起こる可能性があるため、Istioでは実際にはADS-APIを使用しています。↪️ 参考：https://www.amazon.co.jp/dp/1617295825/istio-proxyコンテナの仕組みistio-proxyコンテナを詳しく見てみましょう。istio-proxyコンテナでは、pilot-agentとEnvoyが稼働しています。先ほどistio-proxyコンテナは、双方向ストリーミングRPCでADS-APIから宛先情報を取得すると説明しました。厳密にはEnvoyが、pilot-agentを介して、ADS-APIから双方向ストリーミングRPCで宛先情報を取得します。istio-proxyコンテナが送信元マイクロサービスからリクエストを受信すると、EnvoyはADS-APIから取得した宛先情報に基づいて、宛先マイクロサービスのインスタンスにロードバランシングします。↪️ 参考：https://www.amazon.co.jp/dp/1617295825/Jimmy Song - 专注于探索后 Kubernetes 时代的云原生新范式Tech-赵化冰的博客 | Zhaohuabing Blog04. istio-proxyコンテナ内のEnvoyの仕組みEnvoyの処理の流れEnvoyがADS-APIから取得した宛先情報を見ていく前に、Envoyの処理の流れを解説します。istio-proxyコンテナ内のEnvoyでは、以下の仕組みでリクエストを処理します。 (１) istio-proxyコンテナは、送信元マイクロサービスからリクエストを受信する。 (２) Envoyは、リクエストの宛先情報 (例：宛先IPアドレス、ポート番号、パス、ホスト、など) に応じてリスナー値を選ぶ。 (３) Envoyは、リスナーに紐づくルート値を選ぶ。 (４) Envoyは、クラスターに紐づくクラスター値を選ぶ。 (５) Envoyは、クラスターに紐づくエンドポイント値を選ぶ。 (６) Envoyは、エンドポイント値に対応するインスタンスにリクエストを送信する。Envoyで確認した宛先情報を👆に当てはめて見ていくことにしましょう。↪️ 参考：Amazon.co.jp: Istio in Action (English Edition) 電子書籍: Posta, Christian E., Maloku, Rinor: 洋書https://www.amazon.co.jp/dp/1492043788/Architecture Analysis of Istio: The Most Popular Service Mesh Project - Alibaba Cloud CommunityEnvoyがADS-APIから取得した宛先情報を見てみようconfig_dumpエンドポイント実際にEnvoyに登録されている宛先情報は、istio-proxyコンテナ自体のlocalhost:15000/config_dumpからJSONで取得できます。ただし、JSONだと見にくいので、yqコマンドでYAMLに変換すると見やすくなります。もしお手元にIstioがある場合は、Envoyにどんな宛先情報が登録されているか、Envoyを冒険してみてください👍🏻$ kubectl exec \    -it foo-pod \    -n foo-namespace \    -c istio-proxy \    -- bash -c "curl http://localhost:15000/config_dump" | yq -Pリスナー値▼ 確認方法istio-proxyコンテナがADS-APIから取得したリスナー値は、/config_dump?resource={dynamic_listeners}から確認できます。ここでは、foo-pod内でbar-podのリスナー値を確認したと仮定します。$ kubectl exec \    -it foo-pod \    -n foo-namespace \    -c istio-proxy \    -- bash -c "curl http://localhost:15000/config_dump?resource={dynamic_listeners}" | yq -P▼ 結果以下を確認できました。宛先IPアドレスや宛先ポート番号に応じてリスナー値を選べるようになっており、ここでは<任意のIPアドレス>:50002。リスナー値に紐づくルート値の名前configs:  - "@type": type.googleapis.com/envoy.admin.v3.ListenersConfigDump.DynamicListener    # リスナー名    name: 0.0.0.0_50002    active_state:      version_info: 2022-11-24T12:13:05Z/468      listener:        "@type": type.googleapis.com/envoy.config.listener.v3.Listener        name: 0.0.0.0_50002        address:          socket_address:            # 受信したパケットのうちで、宛先IPアドレスでフィルタリング            address: 0.0.0.0            # 受信したパケットのうちで、宛先ポート番号でフィルタリング            port_value: 50002        filter_chains:          - filter_chain_match:              transport_protocol: raw_buffer              application_protocols:                - http/1.1                - h2c            filters:              - name: envoy.filters.network.http_connection_manager                typed_config:                  "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager                  stat_prefix: outbound_0.0.0.0_50001                  rds:                    config_source:                      ads: {}                      initial_fetch_timeout: 0s                      resource_api_version: V3                    # 本リスナーに紐づくルート値の名前                    route_config_name: 50002  ...    - "@type": type.googleapis.com/envoy.admin.v3.ListenersConfigDump.DynamicListener  ...↪️ 参考：Administration interface — envoy 1.26.0-dev-7cc893 documentationConfigDump (proto) — envoy 1.26.0-dev-7cc893 documentationルート値▼ 確認方法istio-proxyコンテナがADS-APIから取得したリスナー値は、/config_dump?resource={dynamic_route_configs}から確認できます。ここでは、foo-pod内でbar-podのルート値を確認したと仮定します。$ kubectl exec \    -it foo-pod \    -n foo-namespace \    -c istio-proxy \    -- bash -c "curl http://localhost:15000/config_dump?resource={dynamic_route_configs}" | yq -P▼ 結果コマンドを実行するとYAMLを取得でき、以下を確認できました。リスナー値を取得した時に確認できたルート値の名前リクエストのパスやホストヘッダーに応じてルート値を選べるようになっているルート値に紐づくクラスター値の名前configs:  - "@type": type.googleapis.com/envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig    version_info: 2022-11-24T12:13:05Z/468    route_config:      "@type": type.googleapis.com/envoy.config.route.v3.RouteConfiguration      # ルート値の名前      name: 50002      virtual_hosts:        - name: bar-service.bar-namespace.svc.cluster.local:50002          # ホストベースルーティング          domains:            - bar-service.bar-namespace.svc.cluster.local            - bar-service.bar-namespace.svc.cluster.local:50002            - bar-service            - bar-service:50002            - bar-service.bar-namespace.svc            - bar-service.bar-namespace.svc:50002            - bar-service.bar-namespace            - bar-service.bar-namespace:50002            - 172.16.0.2            - 172.16.0.2:50002          routes:            - match:                # パスベースルーティング                prefix: /              route:                # 本ルートに紐づくクラスター値の名前                cluster: outbound|50002|v1|bar-service.bar-namespace.svc.cluster.local                timeout: 0s                retry_policy:                  retry_on: connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes                  num_retries: 2                  retry_host_predicate:                    - name: envoy.retry_host_predicates.previous_hosts                  host_selection_retry_max_attempts: "5"                  retriable_status_codes:                    - 503                max_stream_duration:                  max_stream_duration: 0s                  grpc_timeout_header_max: 0s              decorator:                operation: bar-service.bar-namespace.svc.cluster.local:50002/*                  ...                    - '@type': type.googleapis.com/envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig    ...↪️ 参考：Administration interface — envoy 1.26.0-dev-7cc893 documentationConfigDump (proto) — envoy 1.26.0-dev-7cc893 documentationクラスター値▼ 確認方法istio-proxyコンテナがADS-APIから取得したクラスター値は、/config_dump?resource={dynamic_active_clusters}から確認できます。ここでは、foo-pod内でbar-podのクラスター値を確認したと仮定します。$ kubectl exec \    -it foo-pod \    -n foo-namespace \    -c istio-proxy \    -- bash -c "curl http://localhost:15000/config_dump?resource={dynamic_active_clusters}" | yq -P▼ 結果コマンドを実行するとYAMLを取得でき、以下を確認できました。ルート値を取得した時に確認できたクラスター値の名前クラスター値に紐づくエンドポイント値の親名configs:  - "@type": type.googleapis.com/envoy.admin.v3.ClustersConfigDump.DynamicCluster    version_info: 2022-11-24T12:13:05Z/468    cluster:      "@type": type.googleapis.com/envoy.config.cluster.v3.Cluster      # クラスター値の名前      name: outbound|50002|v1|bar-service.bar-namespace.svc.cluster.local      type: EDS      eds_cluster_config:        eds_config:          ads: {}          initial_fetch_timeout: 0s          resource_api_version: V3        # 本クラスターに紐づくエンドポイント値の親名        service_name: outbound|50002|v1|bar-service.bar-namespace.svc.cluster.local  ...  - "@type": type.googleapis.com/envoy.admin.v3.ClustersConfigDump.DynamicCluster  ...↪️ 参考：Administration interface — envoy 1.26.0-dev-7cc893 documentationConfigDump (proto) — envoy 1.26.0-dev-7cc893 documentationエンドポイント値▼ 確認方法istio-proxyコンテナがADS-APIから取得したクラスター値は、/config_dump?include_edsから確認できます。ここでは、foo-pod内でbar-podのクラスター値を確認したと仮定します。$ kubectl exec \    -it foo-pod \    -n foo-namespace \    -c istio-proxy \    -- bash -c "curl http://localhost:15000/config_dump?include_eds" | yq -P▼ 結果コマンドを実行するとYAMLを取得でき、以下を確認できました。クラスター値を取得した時に確認できたエンドポイントの親名bar-podのインスタンスが3個あるため、3個のエンドポイントがあります全てのエンドポイントのload_balancing_weightキー値が等しい場合、EnvoyはP2Cアルゴリズムに基づいてロードバランシングします。configs:  dynamic_endpoint_configs:    - endpoint_config:        "@type": type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment        # エンドポイントの親名        cluster_name: outbound|50002|v1|bar-service.bar-namespace.svc.cluster.local        endpoints:          - locality:              region: ap-northeast-1              zone: ap-northeast-1a            lb_endpoints:              - endpoint:                  address:                    socket_address:                      # 冗長化されたbar-podのIPアドレス                      address: 11.0.0.1                      # bar-pod内のコンテナが待ち受けているポート番号                      port_value: 80                  health_check_config: {}                health_status: HEALTHY                metadata:                  filter_metadata:                    istio:                      workload: bar                    envoy.transport_socket_match:                      tlsMode: istio                # ロードバランシングアルゴリズムを決める数値                load_balancing_weight: 1          - locality:              region: ap-northeast-1              zone: ap-northeast-1d            lb_endpoints:              - endpoint:                  address:                    socket_address:                      # 冗長化されたbar-podのIPアドレス                      address: 11.0.0.2                      # bar-pod内のコンテナが待ち受けているポート番号                      port_value: 80                  health_check_config: {}                health_status: HEALTHY                metadata:                  filter_metadata:                    istio:                      workload: bar                    envoy.transport_socket_match:                      tlsMode: istio                # ロードバランシングアルゴリズムを決める数値                load_balancing_weight: 1          - locality:              region: ap-northeast-1              zone: ap-northeast-1d            lb_endpoints:              - endpoint:                  address:                    socket_address:                      # 冗長化されたbar-podのIPアドレス                      address: 11.0.0.3                      # bar-pod内のコンテナが待ち受けているポート番号                      port_value: 80                  health_check_config: {}                health_status: HEALTHY                metadata:                  filter_metadata:                    istio:                      workload: bar                    envoy.transport_socket_match:                      tlsMode: istio                # ロードバランシングアルゴリズムを決める数値                load_balancing_weight: 1        policy:          overprovisioning_factor: 140    ...    - endpoint_config:    ...↪️参考：Administration interface — envoy 1.26.0-dev-7cc893 documentationConfigDump (proto) — envoy 1.26.0-dev-7cc893 documentationSupported load balancers — envoy 1.26.0-dev-7cc893 documentationEnvoyの処理の流れのまとめ確認できた宛先情報を、Envoyの処理の流れに当てはめてみました。 (１) 送信元マイクロサービスは、宛先マイクロサービス (<任意のIP>/:50002) にリクエストを送信し、サイドカーコンテナのistio-proxyコンテナはこれを受信します。 (２) Envoyは、リクエストの宛先 (IPアドレス、ポート番号、パス) からPodのリスナー値 (0.0.0.0_50002) を選ぶ。 (３) Envoyは、リスナーに紐づくPodのルート値 (50002) を選ぶ。 (４) Envoyは、クラスターに紐づくPodのクラスター値 (outbound|50002|v1|bar-service.bar-namespace.svc.cluster.local) を選ぶ。 (５) Envoyは、クラスターに紐づくPodのインスタンスのエンドポイント値 (11.0.0.X/:80) を選ぶ。 (６) Envoyは、エンドポイント値の宛先にPodのリクエストを送信する。サービスディスカバリーの冒険は以上です。05. おわりに今回、Istioの機能の一つである『サービスディスカバリー』の仕組みを、Envoyを交えながら布教しました。もりもりでしたが、最後までお付き合いいただきありがとうございました。ここまで見ていただいたそこのあなた、片足が沼に浸かってます😏謝辞3-shake SRE Tech Talk での発表前後に、以下の方々に、発表内容について助言をいただきました。@ido_kara_deru さん@yosshi_ さん@yteraoka さん (アルファベット順)また、今回の 3-shake Advent Calender 2022 は、以下の方々に企画いただきました。@jigyakkuma_ さん@nwiizo さん (アルファベット順)皆様に感謝申し上げます🙇🏻‍♂️]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Steam Deck に Windows を入れたい方の参考になれば...!]]></title>
            <link>https://qiita.com/tozastation/items/a57df36a369b5425795a</link>
            <guid>https://qiita.com/tozastation/items/a57df36a369b5425795a</guid>
            <pubDate>Sat, 24 Dec 2022 08:36:33 GMT</pubDate>
            <content:encoded><![CDATA[この記事は 3-shake Advent Calendar 2022 の24日目の記事です。はじめに年末、しかもクリスマスということで散財させていただきました。初めまして、戸澤といいます。日常…]]></content:encoded>
        </item>
    </channel>
</rss>