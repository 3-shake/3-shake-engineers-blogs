<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Thu, 02 Oct 2025 22:39:40 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[2025年10月版読む予定本紹介]]></title>
            <link>https://zenn.dev/akasan/articles/1c00ba13ed0cee</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/1c00ba13ed0cee</guid>
            <pubDate>Thu, 02 Oct 2025 13:42:42 GMT</pubDate>
            <content:encoded><![CDATA[今年もはや10月になりましたね。先月に引き続き、今月も読む予定の本を共有していこうと思います！今月もいろんな本を読む予定にしているので、早速共有していきます！ Azure系 Microsoft Azure実践ガイドこちらはMicrosoft Azureの実践ガイドになります。現在案件でAzureを利用した開発をしており、今まで使ってこなかったので勉強するために読み始めました。私はKindle Unlimitedを利用しているのですがそちらの対象書籍になっているので、登録している方は無料で読むことができておすすめです！https://book.impress.co.jp/boo...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[claude codeに数独の回答をさせるコードを考えさせてみた]]></title>
            <link>https://zenn.dev/akasan/articles/8bd6a18cfb9baa</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/8bd6a18cfb9baa</guid>
            <pubDate>Wed, 01 Oct 2025 13:55:03 GMT</pubDate>
            <content:encoded><![CDATA[今回は昨日公開した記事の続編になります。昨日は数独の問題を自動で生成させるコードをclaude codeにて実装させましたが、今回はその問題ファイルを読み込んで計算させるコードを作らせてみました。昨日の記事は以下になりますのでぜひ合わせてご覧ください。https://zenn.dev/akasan/articles/c4b6817e4de906 早速やってみる！ プロンプト！今回入力したプロンプトは以下になります。@problem_1.txt のようなフォーマットで入力される数独の回答を導くコードをPythonでかいて。結果はsolve_<ナンバリング>.tx...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[システム思考を日々の開発に取り入れる実践ガイド]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/10/01/203924</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/10/01/203924</guid>
            <pubDate>Wed, 01 Oct 2025 11:39:24 GMT</pubDate>
            <content:encoded><![CDATA[syu-m-5151.hatenablog.comはじめに前回の記事では、システム思考の基本的な概念—非線形性、関係性、反直感性、氷山モデル—を見てきました。システムをプラモデルではなく生態系として理解する視点を学びました。しかし、概念を知っているだけでは意味がありません。テニスの本を読んでもテニスができるようにならないように、システム思考も実践してこそ身につくものです。理論を学んだ今、次のステップは「どう実践するか」です。この記事では、日々の開発の中でシステム思考をどう使うかを具体的に解説します。取り上げるのは、自己認識の深め方、建設的な対話の作り方、フィードバックループの設計、パターンの見つけ方、そしてモデリングの実践です。これらはシステム思考の実践方法のほんの一部ですが、すべて明日から使える方法ばかりです。特別なツールや権限は必要ありません。新人エンジニアでも、今日から、今いるチームで始められます。大切なのは、小さく始めることです。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。自己認識とメタ認知思考を改善するには、まず自分の思考に気づく必要があります。メタ思考～「頭のいい人」の思考法を身につける作者:澤円大和書房Amazon「なぜ私はこの解決策を選んだのか？」「どんな前提に基づいて判断しているのか？」「他の視点から見たらどうなるだろう？」システム思考の最良の開始方法は、最も身近なシステムである自分自身で練習することです。自分がどのように考え、決定し、行動しているかを観察することから始まります。これをメタ認知—自分の思考を客観的に見る力—と呼びます。ここで重要なのは、「問う」という行為の本質を理解することです。「問う」とは、実は「情報を編集する」という知的営みなのです。私たちは日々、膨大な情報に囲まれています。システムログ、エラーメッセージ、レビューコメント、仕様書、チャットの会話—これら無数の断片的な情報を、どう組み合わせ、どう意味づけるか。それが「問い」を立てるということです。問いの編集力 思考の「はじまり」を探究する作者:安藤昭子ディスカヴァー・トゥエンティワンAmazon「このバグはなぜ起きたのか」という問いは、エラーメッセージ、コードの履歴、環境設定、ユーザーの操作ログといった複数の情報を編集し、一つの物語として組み立てる作業です。「この設計で本当にいいのか」という問いは、要件、制約、技術的選択肢、チームの状況といった情報を再構成する試みです。そして、一人ひとりの編集力によって、その人ならではの内発する「問い」が生まれます。新人エンジニアのあなたが感じる違和感は、ベテランには見えない問いの種かもしれません。「なぜこの変数名はこんなに長いのだろう」「なぜこの処理は分散しているのだろう」—こうした素朴な疑問が、実はシステムの本質的な問題を指し示していることがある。問いが生まれるプロセスには、段階があります。まず「問い」の土壌をほぐす—これが自己認識です。自分がどんな前提で考えているか、どんな偏りを持っているか、どんな経験が判断に影響しているか。この土壌が固ければ、問いは芽を出せません。具体的にどう実践するか。何か技術を選ぶとき（フレームワーク、ライブラリ、設計パターン）、紙に書き出してみる。最初に思いついた選択肢は何か。なぜそれを思いついたのか—過去の経験？記事を読んだ？先輩に勧められた？他の選択肢は検討したか。最終的な判断の決め手は何だったか。ここで大切なのは、違和感に気づくことです。「なんとなくこの技術が良さそう」と思ったとき、その「なんとなく」の正体は何でしょうか。単に新しい技術を試したいだけではないか。本当にこのプロジェクトに適しているのか。この振り返りが、「問い」のタネを集めるプロセスです。自分の判断パターンや偏りに気づき、「本当にそうなのか？」という問いのタネが生まれる。次に、日々の仕事で何が重要で何がそうでないかを判断する練習をする。Slackの大量の通知、「緊急」と書かれているが実は緊急でないタスク、細かいコーディングスタイルの議論—これらはノイズかもしれない。一方で、ユーザーからの「使いにくい」という小さなフィードバック、システムログの中の見慣れないエラー、先輩の何気ない一言「このコード、後で問題になりそう」—これらがシグナル、つまり本当に重要な情報かもしれない。重要なのは、形式的なチェックリストに従うことではありません。自分の中に自然と湧き上がる問いに気づくことです。「このコード、なんか気持ち悪いな」という感覚。「この設計、本当にこれでいいのか？」という引っかかり。こうした違和感こそが、「問い」を発芽させるきっかけなのです。週末に5分だけ振り返りをしてみる。「今週、どれに時間を使ったか」「本当に重要だったのはどれか」。この練習で、重要なことを見抜く力が養われる。そして、新しい技術を学ぶとき、「これは難しすぎる」と思ったら、一歩引いて考えてみる。本当に難しいのか、それとも単に馴染みがないだけか。どの部分が理解できて、どの部分が理解できないか。理解できない理由は何か—前提知識の不足？説明が分かりにくい？この分析によって、「難しい」という漠然とした感覚が、「この部分の前提知識が足りない」という具体的な課題に変わる。これが「問い」が結像する瞬間です。このプロセス全体—土壌をほぐし、タネを集め、発芽させ、結像させる—が、「問いの編集力」です。これは「問う」という知的営みを、一人ひとりの編集力でアップデートするプロジェクトなのです。そして、この力こそが、システム全体をより良く理解し、設計する力につながります。ここで一つ、現代のエンジニアが直面する重要な課題について触れておきたい。生成AIは、確かに開発効率を飛躍的に高めてくれる。しかし、過度な利便性は、個人の成長に不可欠な「考える過程」を奪ってしまう危険性がある。「この関数、どう実装すればいいだろう？」という問いに直面したとき、すぐにAIに答えを求めるのは簡単だ。人は本質的に快適さを求め、最も抵抗の少ない道を選んでしまう。しかし、その「なぜこのアプローチを選ぶのか」「他にどんな選択肢があるのか」と自分で考える過程こそが、問いの編集力を育てる土壌なのだ。だからといって、AIを完全に排除すべきだという話ではない。重要なのは、将来の自分を妨げないよう、意図的に活用することだ。例えば、まず自分で5分考えてから、AIに相談する。AIの提案を受け取ったら、「なぜこのコードがそう書かれているのか」を理解しようとする。あるいは、実装の方向性を確認する用途には使うが、細部の実装は自分で書いてみる。こうした意図的な距離感が、創造性と成長を維持する鍵となる。システム思考を身につけるには、この「立ち止まって考える時間」が不可欠だ。便利なツールを使いながらも、自分で問いを立て、自分で考える習慣を意識的に守っていこう。自己認識を高めることは、単に自分を知ることではありません。自分ならではの問いを生み出せるようになることです。そして、その問いがシステムの本質に迫るとき、あなたは本当の意味でのシステム思考の実践者になっているのです。反応から応答へ誰かがアイデアを提案しました。あなたの最初の反応は「でも、それは...」かもしれません。ちょっと待ってください。他者と働く──「わかりあえなさ」から始める組織論 (NewsPicksパブリッシング)作者:宇田川元一ニューズピックスAmazonシステム思考は、出来事への反応から、応答的な行動パターンへ、そして（改善された）システム構造の生成へと移行する能力です。そして、その第一歩が「まず受け止める」という姿勢です。開発現場では、しばしば「否定から入る」文化が見られます。新しい提案に対して、即座に「でも」「しかし」「それは無理だ」と反応してしまう。これは慎重さの表れかもしれませんが、建設的な対話を阻害してしまいます。まず受け止めるとは、相手のアイデアを即座に否定せず、その意図や背景を理解しようとすることです。これは合意することではありません。相手の視点を理解することと、それに同意することは別の話です。例えば、同僚が「このシステムをマイクロサービスに分割すべきだ」と提案したとします。否定的な反応は「でも、そんなことしたら複雑になるだけですよ」となるかもしれません。しかし、まず受け止めるアプローチでは「なるほど、マイクロサービス化することで独立したデプロイが可能になりますね。それを実現するには、サービス間の境界をどう定義するか考える必要がありそうです。現状の課題も含めて、一緒に検討してみませんか」といった形で応答します。この姿勢は、対立ではなく対話を生み出します。「私の考えを変えて」と要求するのではなく、「一緒に考えよう」という協働の場を作るのです。これこそが、システム思考に必要な姿勢なのです。まず受け止めることで、異なる視点を統合し、より豊かな解決策を生み出すための土台が作られます。相手のアイデアを否定するのではなく、それを出発点として、共に探求を深めていくのです。これは簡単なことではありません。特に、明らかに問題があると感じるアイデアに対して、まず受け止めるのは困難です。しかし、相手の視点を理解し、その上で建設的な方向に導くことで、より良い結果を生み出せるのです。「なぜそう考えたのか」を聞くことから始めましょう。その背景を理解すれば、本当の課題が見えてくることもあります。本当のゴールを見つける目標を抽象化して本質を見極めることから始めます。例えば「レガシーシステムをモダン化する」という目標の本質は何でしょうか？表面的には「古い技術を新しい技術に置き換える」と見えます。しかし、システム思考で考えると、本当の目的は「変更コストを下げ、新機能を素早く提供できる状態を作る」ことかもしれません。あるいは「属人化を解消し、チーム全体がシステムを理解できる状態を作る」ことかもしれません。この理想的な状態の定義が曖昧だと、どれだけ細かく分解しても、正しい方向に進めません。氷山モデルで言えば、最も深い層である「メンタルモデル」を明確にすることです。具体的には、次のような問いを立てます。「なぜこの目標が必要なのか？」という問いは、目標の背景にある本当の課題を浮き彫りにします。「達成したら、何が変わるのか？」という問いは、成功の姿を具体的にします。「誰にとっての価値を生み出すのか？」という問いは、ステークホルダーとその期待を明確にします。そして「この目標の成功は、どう測定できるのか？」という問いは、抽象的な理想を検証可能な基準に変換します。この問いに答えることで、漠然とした目標が、明確な理想状態に変わります。そして、この明確な理想状態こそが、すべての具体的な行動の羅針盤となるのです。具体と抽象作者:細谷 功dZERO（インプレス）Amazonシステム的推論知識労働者として、私たちは常に、形式的または非形式的に、アイデア、行動、理論を提案しています。「このアーキテクチャを採用すべきだ」「このツールを使うべきだ」「この方法で実装すべきだ」しかし、その提案に説得力を持たせるには、システム的推論が必要です。新人エンジニアのあなたも、日々の開発で「なぜこの方法を選んだのか」を説明する場面があるでしょう。例えば、納期が迫る中で「テストコードを書く時間がない」という意見に対して、どう考えますか？ここでシステム的推論が力を発揮します。単に「テストは重要だから書くべき」という原則論ではなく、システム全体への影響を考える。「確かに今週の納期は重要です。しかし、テストなしでリリースすると、本番環境でバグが発生する可能性が高まります。過去3ヶ月のデータを見ると、テストカバレッジが50%未満のコンポーネントは、平均して月2回の緊急修正が必要でした。各修正には平均4時間かかり、さらに顧客への説明や再リリースの手間も考えると、今2時間かけてテストを書く方が、トータルの工数は削減できます」このような推論には、信頼性（過去のデータに基づく）、関連性（現在の状況に直結）、結束性（理由が相互に補強し合う）、説得力（具体的な数値で示す）という要素が含まれています。重要なのは、メリット・デメリットを機械的に並べることではありません。システム全体の中で、この選択がどんな波及効果を生むかを考えることです。短期的なメリットが長期的なデメリットを生むかもしれない。一つの部分の最適化が、別の部分のボトルネックを作るかもしれない。こうした相互作用を含めて考えることが、システム的推論なのです。日本の開発現場でよくある「仕様変更」への対応も、システム的推論で考えると違って見えます。「また仕様変更か...」と嘆くのではなく、「この仕様変更のパターンから、顧客が本当に求めているものが見えてきた。次回から、初期段階でプロトタイプを見せて早めにフィードバックをもらう仕組みを提案してみよう」という建設的な提案につなげられるのです。なぜあの人の解決策はいつもうまくいくのか?―小さな力で大きく動かす!システム思考の上手な使い方作者:枝廣 淳子,小田 理一郎東洋経済新報社Amazon目標を構造化する技術理想的な状態が定義できたら、そこに至る道筋を設計します。ここで重要なのが、4つの視点で構造化するという考え方です。1. 時間を構造化する時間は最も重要な制約です。そして、制約こそが価値を生み出します。現実を直視しましょう。無限に時間があれば、そこそこ良いものは作れます。しかし、それでは意味がありません。永遠にリファクタリングを続け、完璧な設計を追求し、すべてのエッジケースに対応する—そんな仕事に価値はないのです。締め切りがあるからこそ、私たちは本質に集中します。何が本当に重要で、何が単なる理想なのかを見極めます。締め切り駆動こそが、本当の仕事なのです。だからこそ、締め切りを味方にする技術が必要です。3ヶ月後という最終締め切りがあるなら、3ヶ月先まで何もしないのではなく、中間地点を意図的に設計します。重要なのは、単に時間を等分するのではなく、意味のあるマイルストーンを設定することです。「1週間後にプロトタイプで検証」「2週間後にチームでレビュー」「1ヶ月後に本実装開始」というように、各地点で何を達成し、何を学ぶのかを明確にします。各マイルストーンが小さな締め切りとなり、あなたを前進させます。そして、日にちではなく日時で決めることです。「来週中」ではなく「水曜日の15時まで」。さらに、他者と約束することで強制力を持たせます。「水曜のミーティングで進捗を共有します」と宣言することで、逃げ場のないコミットメントが生まれます。この適度なプレッシャーが、フィードバックループを回し続けるのです。2. 複雑さを分割する大きな問題を前にしたとき、全体を一度に理解しようとするのは無謀です。それは不可能であるだけでなく、非効率でもあります。現実の開発では、完全な理解を待っている余裕はありません。不完全な理解のまま前に進み、動きながら理解を深めていく。これが実践です。しかし、闇雲に進むわけではありません。今この瞬間に何に集中すべきかを明確にする必要があります。ここで重要なのは、複雑さには構造があるということです。どんな複雑な問題も、認識のプロセスという観点から段階に分解できます。認識の段階で分割するシステムアーキテクチャの設計という大きなタスクを考えます。これは、認識の深さによって段階に分解できます。最初の段階は「理解する」こと。既存のシステムがどう動いているかを把握します。次の段階は「分析する」こと。何が問題で、何が改善の機会なのかを特定します。その次は「探索する」こと。複数の解決策を考え、比較します。さらに進んで「決定する」こと。最適な方向性を選択します。最後に「実装する」こと。具体的な設計を作り上げます。この段階分けの本質は、各段階で問う質問が異なるということです。理解の段階では「これは何をしているのか？」と問います。分析の段階では「何が問題なのか？」と問います。探索の段階では「他にどんな方法があるか？」と問います。決定の段階では「どれを選ぶべきか？」と問います。実装の段階では「どう作るか？」と問います。これらの質問を同時に考えようとすると、頭が混乱します。「これは何をしているのか」を理解する前に「どう作るか」を考え始めると、理解が浅いまま実装に進んでしまいます。だから、今はどの質問に答えるべきかを明確にするのです。認知的な負荷で分割する各段階の中でも、さらに認知的な負荷を下げる工夫が必要です。「既存システムを理解する」という段階を考えます。これをいきなり「理解しよう」とすると、脳が過負荷になります。だから、行動を段階的に組み立てます。最初は受動的観察から始めます。まず2時間、コードを読む。この段階では理解を求めません。ただ情報を浴びるだけです。次に、浴びた情報から湧き上がった疑問を記録します。10個ほど疑問点をリストアップします。ここで初めて、受動的から能動的に切り替わります。その次に、記録した疑問を構造化します。技術的な疑問、ビジネス的な疑問、歴史的な疑問などにカテゴリ分けします。構造が見えたら、優先順位をつけます。最も重要な疑問を3つ選びます。そして最後に、その3つについて集中的に調査します。深い探索に入るわけです。なぜこの順番なのか？最初から「理解しながら読む」のは負荷が高すぎます。だから、まず受動的に情報を浴びる。負荷が低い状態から始めます。次に、浴びた情報から湧き上がった疑問を記録する。少し負荷が上がります。記録した疑問を整理して構造を見出す。さらに負荷が上がります。構造の中から優先順位を決める。そして初めて、深い理解のための調査に入る。最も負荷の高い活動です。このパターンの本質は、認知的な負荷を段階的に上げていくことです。脳は急激な負荷の変化に弱いですが、段階的な上昇には対応できます。自己完結性で分割するさらに、タスクには「自分だけで完結する部分」と「他者との関係が必要な部分」があります。これも分離して考える必要があります。例えば、「既存システムを理解する」の中で、自分だけでできることがあります。コードを読む、ドキュメントを読む、動かしてみる。これらは好きな時間に進められます。一方で、他者が必要なこともあります。設計の意図を聞く、過去の経緯を知る、暗黙の制約を確認する。これらは相手の都合を調整する必要があります。この区別が重要なのは、スケジューリングの戦略が異なるからです。自分だけでできることは、今日の夜でも、週末でも進められます。他者が必要なことは、早めに「誰に何を聞くべきか」を特定し、スケジュールを調整します。この区別をしないと、「調査は進んだけど、肝心なことを聞く相手が来週まで不在」という事態に陥ります。完璧な理解という幻想を捨てる最後に、最も重要な認識があります。完全な理解は存在しないということです。システムは複雑すぎて、すべてを理解することは不可能です。そして、理解が不完全でも、前に進むことはできます。重要なのは、「今の決定に必要な理解は何か」を見極めることです。「このAPIの実装を変更する」という決定には、APIの仕様と依存関係の理解が必要です。しかし、そのAPIが内部でどのアルゴリズムを使っているかまで理解する必要はないかもしれません。決定に必要な解像度で理解する。これが、複雑さを効率的に分割する鍵なのです。すべてを理解しようとすれば、永遠に理解のフェーズから抜け出せません。今の決定に必要な部分だけを、必要な深さで理解する。この割り切りが、現実の開発では不可欠です。3. 成果を定義する進捗を確認できなければ、正しい方向に進んでいるか分かりません。そして、確認できない進捗は、存在しないのと同じです。完璧主義は行動を妨げます。「完璧な設計書ができるまで実装を始めない」「すべてを理解してから手を動かす」—こうした態度は、実際には何も生み出しません。現実の開発では、不完全な成果を積み重ねながら前進します。だから、各段階で検証可能な成果物を定義します。完璧な成果物である必要はありません。むしろ、段階的な品質目標を設定します。最初は30%の理解で構いません。「全体像がぼんやり見える」程度で十分。この段階では、箇条書きのメモや疑問点のリストが成果物です。次に60%を目指します。「主要な構成要素と関係性が分かる」レベル。この段階では、ざっくりした図や主要な依存関係の整理が成果物です。そして80%、95%と段階的に精度を上げていきます。80%地点では、詳細な設計ドキュメントや実装計画が成果物になります。この段階的アプローチの真の価値は、早い段階でフィードバックを得られることです。30%の理解の時点で「方向性が間違っている」と気づけば、大きな手戻りを避けられます。完璧を目指して3ヶ月かけた後に方向性の誤りに気づくより、1週間で30%の成果を出して軌道修正する方が、はるかに賢明です。これがフィードバックループの設計です。小さく、速く、頻繁に。完璧ではなく、十分に良いものを、今日出す。4. 制約を明らかにするタスクは孤立して存在しません。そして、この事実を無視することは、失敗への近道です。現実の開発では、すべてのタスクが何かに依存しています。しかし、この依存関係は技術的なものだけではありません。むしろ、最も予測困難で致命的な依存関係は、人間の意思決定、暗黙の了解、組織の期待といった、目に見えない制約なのです。技術的な依存関係まず、明示的な技術的依存関係があります。これは比較的見つけやすい。この機能は認証システムに依存している。データベーススキーマの変更が必要。既存のAPIとの互換性を保つ必要がある。UIチームとの調整が必要。これらは図に描きやすく、「認証システムの理解が先」「スキーマ変更は早めに合意が必要」「UI設計は並行で進められる」といった戦略を立てられます。意思決定への依存関係しかし、より厄介なのは誰かの判断を待つ必要があるという依存関係です。この設計変更は、シニアエンジニアの承認が必要。この機能の優先順位は、プロダクトマネージャーの判断待ち。この技術選定は、セキュリティチームのレビューが必要。この仕様変更は、顧客への確認が必要。これらの依存関係が見えていないと、「実装は完了したのに、承認待ちで2週間止まっている」という事態に陥ります。そして、承認者が「そもそもこのアプローチは違う」と言い出せば、すべてが水の泡です。だから、早い段階で「誰の判断が必要か」「いつまでに確認を取るべきか」を明確にします。実装を始める前に、方向性の合意を取る。これだけで、大きな手戻りを避けられます。暗黙の了解への依存関係さらに難しいのが、チームや組織の暗黙の了解という制約です。「金曜日にはデプロイしない」というチームの不文律。「この部分のコードは○○さんしか触らない」という暗黙の領域分担。「新しいライブラリの導入は慎重に」という組織の雰囲気。「テストカバレッジは80%以上」という暗黙の品質基準。これらは明文化されていないため、新人エンジニアには見えません。しかし、この暗黙の制約に気づかずに進めると、「なぜ勝手に進めたんだ」と後から怒られることになります。この制約を明らかにするには、先輩に聞くしかありません。「このタスク、何か気をつけることありますか？」「この変更、誰かに相談した方がいいですか？」こうした質問が、暗黙の制約を顕在化させます。期待への依存関係最後に、最も主観的で曖昧な制約が他者の期待です。マネージャーは「2週間で完了する」と期待している。チームメンバーは「ドキュメントも一緒に更新される」と期待している。レビュアーは「テストコードも書かれている」と期待している。ユーザーは「UIは直感的である」と期待している。これらの期待は、しばしば明示的に伝えられません。しかし、期待に応えられないと、「思っていたのと違う」という不満が生まれます。期待を明らかにするには、早めに確認することです。「このタスク、どのレベルまで求められていますか？」「ドキュメントの更新も含めますか？」「いつまでに完了すればいいですか？」こうした質問で、期待のギャップを埋めます。制約を味方にする依存関係を明らかにすることは、ボトルネックの早期発見につながります。「このタスクは3人の承認が必要」と分かれば、並行で相談を始められます。「先輩が来週休暇」と分かれば、今週中に必要な情報を得ておきます。「この変更は影響範囲が広い」と分かれば、段階的なリリース計画を立てます。制約を敵視してはいけません。制約は現実です。そして、現実を直視することから、実行可能な計画が生まれるのです。見えない制約に後から気づいて慌てるより、最初から制約を前提に計画を立てる方が、はるかに賢明です。技術的な依存関係だけでなく、人間の意思決定、暗黙の了解、期待という目に見えない制約まで含めて考える。これが、現実の開発で生き残るための知恵なのです。実行可能な最小単位への変換ここが最も重要です。どれだけ丁寧に構造化しても、自分の現在のスキルと時間で実行できないなら、まだ抽象的すぎるのです。そして、これは単なる技術的な問題ではありません。心理的な問題でもあります。大きなタスクを前にしたとき、私たちは無意識に身構えます。「このタスクを完璧にこなすには、相当な気持ちの力が必要だ」と。その気持ちのハードルが高すぎて、結局何も始められない。先延ばしが続き、締め切り直前に慌てる。この悪循環を断ち切るには、最初の一歩のハードルを極限まで下げる必要があります。例えば、疲れて帰宅したとき。「お風呂にしっかり入浴しなきゃ」と思うと、それだけで億劫になります。でも「とりあえずシャワーだけ浴びよう」と思えば、動き出せます。そして実際にシャワーを浴び始めると、「あ、意外と平気だな。湯船にも浸かろうかな」となることも多い。完璧を目指さず、最小限から始める。この思考が、行動を生み出すのです。開発も同じです。「この一歩は、今日の30分で完了できるか？」と自問してください。答えがNoなら、さらに具体化します。「30分で完了できる最小の行動は何か？」を考えるのです。例えば、新しいフレームワークを学ぶとき。「Reactを学ぶ」は抽象的すぎます。「Reactの基礎を学ぶ」もまだ抽象的です。「Reactの公式チュートリアルの第1章を読む（30分）」なら実行可能です。「完璧に理解しよう」ではなく「まず読んでみよう」。「最適な設計をしよう」ではなく「ラフなスケッチを描こう」。「全部調べよう」ではなく「5分だけ調べよう」。この「実行可能な最小単位」への変換により、圧倒的な目標が、今すぐ始められる行動に変わります。そして一度動き出せば、継続するのは意外と簡単です。始めることが最大のハードルなのです。これは自分に優しくするということでもあります。「完璧にできないなら、やらない方がマシ」という思考は、結局何も生み出しません。「不完全でも、今日少しだけでも前進する」という姿勢が、長期的には大きな成果につながります。メンタル的にも、この小さな成功体験の積み重ねが重要です。「30分で第1章を読めた」という小さな達成感が、次の一歩への推進力になります。完璧主義で動けないより、不完全でも動き続ける方が、はるかに健全で生産的です。ライト、ついてますか　問題発見の人間学作者:ドナルド・C・ゴース,ジェラルド・M・ワインバーグ共立出版Amazonシステム思考との統合この「目標を構造化する技術」は、システム思考の実践そのものです。線形思考では「Aを完璧に終わらせてからBに進む」となります。しかし、これは現実的ではありません。Aを完璧にする頃には、Bの前提条件が変わっているかもしれません。市場が変化しているかもしれません。完璧を待つ余裕は、現実にはないのです。システム思考では小さなサイクルを回しながら学習するアプローチを取ります。30%の理解でまず動く。フィードバックを得る。それを元に次の30%を積み上げる。このフィードバックループが、不確実性の中での確実な前進を可能にします。そして重要なのは、この構造化のプロセス自体が学習であるということです。目標をどう分解するか考えることで、システムの構造が見えてくる。どこにレバレッジポイントがあるかが分かってくる。抽象的だった問題が、具体的な課題に変わっていく。新人エンジニアのあなたは、「自分にはまだ大きなことはできない」と思うかもしれません。しかし、逆です。大きなことができる人間などいません。いるのは、大きなことを小さく分解して、一歩ずつ進める人間だけです。その力さえあれば、いずれどんな大きな目標にも到達できます。明日、大きなタスクに圧倒されたら、紙とペンを持ってきてください。そのタスクを「時間を構造化する」「複雑さを分割する」「成果を定義する」「制約を明らかにする」の4つの視点で整理してみてください。そして、今日の30分でできる最小の行動を見つけてください。その一歩が、システム思考の実践の始まりです。完璧な計画ではなく、不完全でも今日動き出すこと。それが、本当の意味での第一歩なのです。フィードバックループの設計フィードバックループは私たちの考え方を強化します。良いフィードバックループは学習と改善を促進し、悪いフィードバックループは問題を固定化します。日本の開発現場でよく見かける「レビュー地獄」を考えてみましょう。コードレビューで細かい指摘が山のように来て、修正しては再レビュー、また修正しては再レビュー...。これは悪いフィードバックループの典型例です。なぜこうなるのでしょうか？レビュアーは「完璧なコード」を求め、レビュイーは「早く承認が欲しい」。この対立構造が、建設的でないフィードバックループを生み出しています。では、どう改善するか？まず、レビュイーであるあなたができることがある。PRの説明文に、単に「何を変更したか」だけでなく、「なぜこの変更が必要か」「何を解決しようとしているか」という意図を書く。そして、「他にどんな方法を検討したか」「なぜこの実装を選んだか」という設計判断を明記する。さらに、「ここは自信がない」「この部分、より良い方法があれば教えてほしい」という懸念点を正直に伝える。例えば、こんな風に書く：「ユーザーからの『検索が遅い』というフィードバックに対応しました。全文検索エンジンの導入も検討しましたが、今回は工数とのバランスを考えてインデックスの追加で対応しています。効果が見込め、リスクも低いと判断しました。ただし、N+1クエリになっている箇所があるかもしれません。パフォーマンステストはローカルのみです」。この説明があると、レビュアーはあなたの思考プロセスを理解でき、より建設的なコメントができる。レビュアー側も工夫できる。コメントにレベルを付けると、何が重要かが明確になる。例えば「🔴必須：セキュリティの問題」「🟡推奨：より良い実装方法の提案」「🔵参考：将来の改善案」という分類をすれば、レビュイーも「必ず直さなければならない」プレッシャーなく、建設的に受け取れる。「🟡推奨：ここはmapよりfilterの方が意図が明確になると思います」というコメントなら、対話が生まれる。もう一つの例として、レガシーコードの改善を考えてみよう。「このコードは触りたくない」という恐怖から、誰も手を付けず、ますます理解困難になる。これを打破するには、小さな改善と学びの記録というフィードバックループを作る。まず、小さなリファクタリング—1行の変数名変更でも良い—をする。その際、気づいたことをコメントかドキュメントに残す。次回触る人のために「ここは○○という理由で複雑」と書いておく。この積み重ねで、徐々にコードの理解が広がり、改善のハードルが下がっていく。新人エンジニアのあなたにできることは、自分のPRに「なぜこの実装を選んだか」「他に検討した選択肢」「懸念点」を明記することです。これによって、レビュアーはあなたの思考プロセスを理解し、より建設的なフィードバックを提供できるようになります。そして、それがチーム全体の学習を促進するのです。みんなのフィードバック大全作者:三村 真宗光文社Amazonパターン思考パターン思考は、出来事がどのように発生するかだけでなく、関係性がどのように効果を生み出すかを理解することです。新人エンジニアの日常で、こんなパターンに気づいたことはありませんか？月末になると必ずシステムが重くなる。調査すると、月次レポートのバッチ処理が原因だと分かる。でも、本当にそれだけでしょうか？よく観察すると、月末は営業チームのアクセスも増え、マーケティングチームのキャンペーンも集中し、経理のデータ抽出も重なっている。個々の要因は問題なくても、組み合わさると臨界点を超える。これがパターンです。日本の開発現場特有のパターンもあります。納期が近づくと、テストを省略し、コードレビューが形骸化し、ドキュメントの更新が止まる。その結果、リリース後に問題が頻発し、緊急対応に追われ、次の開発が遅れ、また納期に追われる...。これは負のスパイラルパターンです。では、パターンをどう見つけ、どう対応するか？まず、感覚ではなくデータで確認することが大切です。例えば、「納期2週間前からのコミット数」をグラフ化したり、「レビューコメント数」の推移を記録したり、「テスト実行時間」の変化を追跡したりする。Google SpreadsheetやNotionで簡単な表を作るだけでも、パターンが見えてきます。次に、パターンを3つのタイプから考えてみる。外部要因が影響する外部パターンとして、四半期末の駆け込み需要、年度末の仕様確定ラッシュ、イベント時のアクセス集中などがある。システム内部の問題である技術システムのパターンとして、特定の時間帯のトラフィック集中、定期的なメモリリーク、データ量が増えると遅くなる処理などがある。そしてチームの働き方に起因するプロセスパターンとして、週明けの障害報告増加、金曜リリースの失敗率上昇、特定のメンバーが休むと進まないタスクなどがある。このように分類することで、どこに問題の根があるのかが見えてくる。パターンを見つけたら、変えるための小さな実験を始めます。例えば「金曜リリースの失敗率が高い」というパターンがあったら、木曜リリースに変えてみたり、金曜は小規模な変更のみにしてみたりする。1ヶ月試してデータを取り、どちらが効果的か検証する。完璧な解決策を求めるのではなく、「とりあえず1週間やってみよう」という軽い気持ちで始めることが大切です。あなたのチームにも必ずパターンがあります。「いつも同じところでつまずく」「なぜか特定の機能の修正は想定の3倍かかる」。これらは偶然ではなく、システムが生み出すパターンなのです。パターンを見つけたら、「なぜこのパターンが生まれるのか」を問い、そしてパターンを変えるための小さな実験を始めるのです。類似と思考　改訂版 (ちくま学芸文庫)作者:鈴木宏昭筑摩書房Amazonモデリングモデリングは、私たちの心の中の考えと、それらの間の関係を可視化することです。 speakerdeck.comホワイトボードに図を描いたことがあるでしょう。それがモデリングの始まりです。しかし、「システム思考」は、チームで一緒にモデリングすることで初めて力を発揮します。重要なのは、何をモデル化するかよりも、どのようにモデル化するかです。モデルは会話の道具です。完璧な図を作ることが目的ではなく、チーム全体で共通の理解を作ることが目的なのです。新人エンジニアでもできる簡単なモデリングがある。新しい機能を追加するとき、5分だけ時間を取って紙に描いてみる。この機能は、どのモジュールを使うか？どのデータベーステーブルを読み書きするか？他のどの機能に影響するか？例えば、「新機能」から「認証モジュール」「ユーザーDB」「ログ機能」に矢印を引いてみる。そして気づく—「あ、ログ機能を変えると他にも影響が出るな」と。この簡単な図を描くことで、思わぬ依存関係が見えてくる。チームでシステムアーキテクチャを議論するときは、各メンバーが頭の中に持っているモデルは微妙に異なっています。これを可視化することで、誤解が明らかになる。実際の進め方は簡単だ。各自が5分で「システムの全体像」を紙に描き、それを見せ合い、違いを話し合う。「え、僕はこのAPIを直接叩いていると思っていたけど、実はキャッシュ層があったんだ」といった発見が必ずある。モデルを描くとき、3つの質問を考えるといい。まず「このシステムの目的は何か？」—例えば「ユーザーが商品を素早く見つけられること」。次に「誰にとっての価値を生み出しているのか？」—例えば「エンドユーザー」「営業チーム」「データ分析チーム」。そして「どんな制約があるのか？」—例えば「レスポンスは1秒以内」「既存のレガシーDBと連携が必要」。これらの質問に答えることで、単なる「構成図」ではなく、「なぜそうなっているか」が分かるモデルになる。ツールは何でもいい。ホワイトボード、紙とペン、MiroやFigJam（オンラインホワイトボード）、PlantUMLやMermaid（コードで図を描く）、PowerPointやGoogle Slides。どんなツールでも構わない。完璧なモデルを作ることが目的ではありません。モデリングのプロセスを通じて、チーム全体の理解を深め、より良い意思決定ができるようになることが目的なのです。あなたが明日から始められることは、コードを書く前に5分だけホワイトボード（または紙）に図を描くことです。それをSlackに貼って「この理解で合ってますか？」と聞くだけでも、大きな価値があります。システムリーダーシップシステムリーダーシップとは、役職や権限の話ではありません。システムリーダーシップは、私たちがいつでも実践できるものです。線形と非線形のアプローチの違いを識別し、状況に最も適したマインドセットを選択すること。社会技術的部分間の健全な関係を奨励すること。解決策をシステムの目標と目的につなげ続けること。積極的に視点をシフトし、複数の視点から課題を見ること。曖昧さへの寛容を表現すること。これらは、ジュニアエンジニアでも、シニアエンジニアでも、誰でも実践できることです。システムリーダーシップは統合的リーダーシップであり、変化のエコロジーを開発することです。階層は管理構造ではなくコミュニケーション構造です。より高いレベルの機能は、より低いレベルの活動のニーズに奉仕します（その逆ではありません）。最も価値のある貢献は、レバレッジポイントの発見です。これらは、パターンと関係に介入する場所です。小さな変更で大きな影響を与えられる場所を見つけることが、システムリーダーの重要な役割です。戦略の要諦 (日本経済新聞出版)作者:リチャード・Ｐ・ルメルト日経BPAmazon成功の再定義システムの観点から、成功はシステムを支配することではなく、その中で繁栄することによって測定されます。従来の成功の定義は、「計画通りに完了した」「バグがゼロになった」「パフォーマンス目標を達成した」といったものでした。これらも重要ですが、システム思考の観点からは不十分です。成功したシステムには、異なる特徴があります。制約の有効化とは、システムが全体のニーズに奉仕しながらスケールすることを可能にする成長または影響の制限です。無制限の成長は破綻を招きます。適切な制約があることで、持続可能な成長が可能になります。根本原因の解決は、介入依存（根本的な問題を解決する代わりに修正やバンドエイドを適用すること）を避けることです。症状に対処するのではなく、原因に対処することで、同じ問題の再発を防げます。影響の均等化において、成功したシステムは、利点と特権の影響を均等化します。一部のコンポーネントやチームだけが恩恵を受けるのではなく、全体が公平に価値を享受できるシステムが、長期的に成功します。知識フローの生成は最も重要かもしれません。システムの知識フローが多いほど、透明性が高いほど、そのシステムの成功の可能性が高くなります。情報が自由に流れ、学習が共有され、失敗が隠されない文化が、システムの進化を促進するのです。これらの新しい成功の基準は、短期的な目標達成よりも、長期的な持続可能性と適応力を重視します。システムは生き物のように成長し、変化し、進化するものだからです。失敗できる組織作者:エイミー・C・エドモンドソン早川書房Amazonまとめ前回の記事でシステム思考の基本概念を学び、今回は実践の方法を見てきました。その旅を通じて改めて感じるのは、システム思考は単なる技術ではなく、現代を生きるための基本的な教養だということです。個々の技術力は依然として重要です。しかし、それだけでは複雑化する課題に対応できません。目の前のコードから視線を上げ、全体の中での位置づけを理解し、相互作用を設計する—これがシステム思考なのです。ドネラ・メドウズは言いました。「私たちはシステムを制御したり、理解したりすることはできません。しかし、それらと踊ることはできます！」この美しい比喩は、システム思考の本質を表しています。完全な制御を求めるのではなく、システムと調和し、共に進化していく。完璧な設計図を描いてから実装するのではなく、対話しながら進化させていく。予期せぬ振る舞いを「バグ」として排除するのではなく、フィードバックとして学習する。この姿勢の転換が、真に価値のあるソフトウェアシステムを生み出します。この記事で紹介した実践は、すべて明日から使えるものです。自己認識とメタ認知で、自分ならではの問いを生み出す土壌を耕すこと。違和感に気づき、「なぜ？」と問い続けることで、問いの編集力を磨いていく。反応から応答への転換で、即座に否定するのではなく、まず受け止めることから対話を始める。「でも」ではなく「なるほど、では」と応答する習慣が、チームの知恵を引き出します。目標の構造化で、圧倒的なタスクを実行可能な最小単位に変換する。時間を構造化し、複雑さを分割し、成果を定義し、制約を明らかにする。そして何より、「今日の30分でできること」に落とし込む。フィードバックループの設計で、小さく、速く、頻繁に学習する仕組みを作る。PRに「なぜ」を書き、レビューに段階を付け、小さな改善を積み重ねていく。パターン思考で、繰り返される問題の背後にある構造を見抜く。データで確認し、小さな実験で変化を試みる。モデリングで、見えない構造を可視化し、チームで共通理解を作る。完璧な図ではなく、5分で描いたラフなスケッチでも、対話の価値は十分にあります。これらの概念を完璧に理解する必要はありません。「あ、これは問いの編集で考えられるかも」と思い出すだけで、視点が変わります。明日のコードレビューで「このコードは他のどこに影響するだろう？」と問いかけてみてください。バグを修正するとき、「このバグ、前にも似たようなことがあったな」という違和感を大切にしてください。新しい機能を実装する前に、5分だけ紙に依存関係を描いてみてください。新人エンジニアだからこそ持てる「なぜ？」という素朴な疑問が、ベテランが見落としているシステムの問題を発見する鍵になることがあります。「そういうものだ」と受け入れられていることに「でも、なぜ？」と問う勇気を持ってください。今日から、目の前の木だけでなく、森全体を見る練習を始めましょう。制御ではなく調和を、固定ではなく適応を、確実性ではなく学習を選ぶ。きっと、今まで見えなかった景色が見えてきます。最後に、最も大切なことを。システム思考は完璧主義ではありません。「すべてを理解してから行動する」のではなく、「小さく始めて、学びながら改善する」ことを大切にします。だから、この記事を読んで「難しそう」と感じても大丈夫です。まずは一つだけ、明日から実践してみてください。それで十分です。そして、この記事に書いてあることがすべてではありません。システム思考の実践は、あなた自身の経験の中で深まり、独自の形を取っていくものです。一緒にシステムと踊り始めましょう。システムの科学 第3版作者:ハーバート・Ａ・サイモンパーソナルメディアAmazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[システムを作る人がまず理解すべきシステム思考の基礎]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/10/01/203633</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/10/01/203633</guid>
            <pubDate>Wed, 01 Oct 2025 11:36:33 GMT</pubDate>
            <content:encoded><![CDATA[はじめに先日、若いエンジニアと話をしていて、システム思考について話題になった。「物事を個別に捉えるのではなく、全体の関係性や相互作用を理解する考え方」—これがシステム思考の本質だ。僕は彼に、これはどんな分野でも応用できる基本的な教養だと伝えた。特にシステムを構築する立場の人には重要だけど、そうでなくても持っておいて損のないスキルだと。世界はシステムで動く ― いま起きていることの本質をつかむ考え方作者:ドネラ・Ｈ・メドウズ英治出版Amazonその会話を終えた後、ふと考えた。僕たちエンジニアは日々システムを作っているのに、どれだけ「システムとして」物事を考えているだろうか、と。あなたは日々、コードを書いている。機能を実装し、バグを修正し、システムを構築している。そして、予想外の挙動に困惑することがあるかもしれない。完璧に動くはずの機能が、別の機能と組み合わせると謎の不具合を起こす。チーム間の連携がうまくいかず、同じ問題が何度も繰り返される。「なぜこんなことが起きるのだろう？」と。実は、僕たちの多くは「部品を組み立てる」思考法で「生きたシステム」を作ろうとしているのかもしれない。プラモデルを思い出してほしい。説明書通りにパーツを組み立てれば、完成形は予測できる。壊れたら、その部品だけを交換すれば直る。これが部品思考だ。僕たちはプログラミングを学ぶとき、まずこの思考法を身につける。関数を書き、クラスを設計し、モジュールを組み合わせる。入力に対して出力が決まっている、予測可能な世界。しかし、実際のソフトウェアシステムは、プラモデルというより生態系に近い。池に石を投げると波紋が広がり、その波紋が岸に反射し、さらに複雑な模様を作る。一匹の魚が動けば、水流が変わり、他の魚の行動も変わる。すべてが相互に影響し合い、予測困難な振る舞いを見せる。現代のソフトウェア開発は、まさにこの生態系を扱う仕事だ。マイクロサービス、API連携、非同期処理、分散システム。個々の部品の品質だけでなく、それらの相互作用が全体の振る舞いを決める世界なのだ。この記事では、システム思考とは何か、なぜそれが新人エンジニアにとって不可欠なのかを解説したい。完璧な理論ではなく、あなたの日常の開発体験を変える実践的な視点を提供できればと思う。システム思考は難しく聞こえるかもしれないが、今日から始められる小さな習慣がある。まず、バグが発生したらすぐに修正するのではなく、立ち止まって考えてみる。「このバグ、前にも似たようなことがあったな」という違和感。「なぜかこの機能だけいつも問題が起きる」という引っかかり。この違和感に気づく習慣が、システム思考の第一歩だ。そして、一つの視点だけでなく、多角的に問いかけてみる。技術的な問題だろうか？それとも仕様の理解が曖昧だったのか？チームのコミュニケーションに課題があったのか？こうした多面的な視点が、出来事の背後にあるパターンや構造を浮かび上がらせる。次に、コードを変更する前に、紙やホワイトボードに簡単な図を描く習慣をつける。「このファイルを変更すると、どのモジュールに影響するか？」「どのチームが関係するか？」「どのユーザー機能に影響するか？」。最初は5分で構わない。これを習慣にすることで、システム全体を見る視点が養われる。そして、PRの説明文に「何を」変更したかだけでなく、「なぜ」その実装を選んだのか、他にどんな選択肢があったのか、何を考慮したのかを書く。これはレビュアーのためだけでなく、3ヶ月後の自分のためでもある。システムの背景や意図が言語化され、チーム全体の理解が深まる。これらは特別なツールも会議も不要だ。明日のコーディングから始められる。小さな実践の積み重ねが、やがてシステム思考を自然な習慣に変えていく。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。線形思考の限界「このコードを書けば、この結果が得られる」「この設計にすれば、このパフォーマンスが出る」「この人数を投入すれば、この期日に間に合う」ようこそ！FACT(東京S区第二支部)へ（１） (マンガワンコミックス)作者:魚豊小学館Amazonこんな風に考えたことはありませんか？ これが線形思考です。私たちは線形思考を教えられてきました。予測可能で、合理的で、再現可能で、手続き的で、二元論的で、トップダウンで、制御に関心を持つ思考。「if this, then that」の因果関係に支配された思考で、ソフトウェアシステムがすべての状況において、私たちが意図したとおりに正確に動作することを期待します。しかし、実際のシステムは生態系のように振る舞います。単純な原因と結果の連鎖ではなく、複雑な相互作用の網の目なのです。あるAPIの応答速度を改善したら、別のサービスに負荷が集中してシステム全体のパフォーマンスが悪化した。キャッシュを導入したら、データの整合性問題が頻発するようになった。こんな経験はないでしょうか？ これらは、システムの非線形性を示す典型的な例です。非線形ということの最も単純な形は、システムは完全には制御できず、予測不可能だということです。部分間の関係が、何が起こるかに影響を与えるのです。一つの変更が、思わぬ波及効果を生み出し、それがさらに別の効果を引き起こす。この連鎖は、事前に完全に予測することはできません。そして、この非線形性を理解し、それと共に働く方法を学ぶこと。それがシステム思考への第一歩なのです。システム思考とは何かシステムとは何でしょうか？ それは単なる「複雑なソフトウェア」ではありません。実践システム・シンキング　論理思考を超える問題解決のスキル (ＫＳ理工学専門書)作者:湊宣明講談社Amazonシステムとは、共有された目的に奉仕するために相互作用し、相互依存する、相互関連したハードウェア、ソフトウェア、人々、組織、その他の要素のグループです。あなたが開発しているWebアプリケーションも、それを使うユーザーも、運用チームも、ビジネス要求も、すべてが一つのシステムを構成しているのです。そしてシステム思考とは、「一緒に実践すると非線形思考スキルを向上させる、基礎的な思考実践のシステム」です。これは知識ではなく、実践なのです。テニスについての本を読んでもテニスはできるようになりません。外に出てテニスをプレイする必要があります。システム思考も同じです。概念を理解するだけでなく、日々の開発の中で実践し、体得していく必要があるのです。生産と理解の非対称性をシステム思考で理解するシステム思考が実際にどう役立つのか、今まさに起きている事例で見てみよう。AIによるコード生成だ。AIがコードを書くようになって、開発速度は確かに上がった。数分で数百行のコードが生成される。しかし、そのコードを修正しようとした時、予想以上に時間がかかることに気づいた人も多いかもしれない。これは非線形性の典型例だ。「生産速度を上げれば開発が速くなる」という線形思考は、一見正しく見える。しかし実際のシステムでは、コードを安全に変更するには、まずそのコードを理解する必要がある。システム内にコードが流入する速度と、人間がそれを理解する速度の間に、決定的な非対称性が生まれているのだ。氷山モデルで分析してみよう。表面に見えているのは「AIで開発が速くなった」という出来事だ。しかしその下には、「変更に時間がかかるようになった」というパターンがある。さらにその下には、「生成速度と理解速度の不均衡」という構造がある。そして最も深い層には、「速さこそが価値」「生産量で生産性を測る」というメンタルモデル（考え方の前提）がある。この構造を変えずに、出来事のレベルだけで対処しようとすると問題は悪化する。「変更に時間がかかる？ではAIにもっと変更させよう」という対応は、理解されないコードをさらに増やすだけだ。では、どこに介入すれば効果的だろうか。システム思考では、レバレッジポイント—小さな変更で大きな影響を与えられる場所—を見つけることが重要だ。最も深い層であるメンタルモデルを変革することが、第一のレバレッジポイントだ。「速く書けることが価値」から「理解できることが価値」へ。チームで「このコードを6ヶ月後の自分たちは理解できるか」という基準を共有する。生産性の測定も、コード行数ではなく、「変更可能性」で評価する。この転換がなければ、どんな対症療法も一時的な効果しか生まない。次に、フィードバックループを設計し直すことが効果的だ。具体的には、AIが生成したコードには「なぜこのアプローチを選んだか」を必ず追記する。コードレビューでは「このコードは理解できるか」を明示的にチェック項目に入れる。PRの説明文に「3ヶ月後の自分が読んで理解できるか」を自問する。これらの小さな習慣が、チーム全体の理解を促進する。そして、適切な制約を設けることも重要だ。プロトタイピングではAIを積極的に使い、本実装では人間が設計してから使う。AIが生成したコードは、必ず一度すべて読んでから取り込む。週に一度、「今週AIに生成させたコードで理解が曖昧な部分」をチームで確認する。無制限にAIを使うのではなく、こうした制約がシステム全体の健全性を保つ。新人エンジニアのあなたに伝えたいのは、AIを使うこと自体が問題なのではないということだ。問題は、生産と理解の非対称性を無視することだ。あなたがAIを使ってコードを書くとき、「このコードを3ヶ月後の自分は理解できるだろうか」「チームの他のメンバーは理解できるだろうか」と問いかけてみてほしい。速く書けることと、持続可能なシステムを作ることは、別の話なのだ。概念的完全性フレッド・ブルックスは『人月の神話』で「概念的完全性はシステム設計において最も重要な考慮事項である」というようなことを言っている。人月の神話作者:フレデリック・P・ブルックス，Jr.,滝沢徹,牧野祐子,富澤昇丸善出版Amazonでも、概念的完全性って何でしょうか？簡単に言えば、システム全体が一つの統一された設計思想で貫かれている状態です。ここで言う「概念」とは、アイデアが形を成し、明確な意味を持つようになったもの。「オブジェクト指向」「非同期処理」といった、定義可能な考え方のことです。例えば、Unixには「すべてはファイル」という設計思想があります。デバイスも、プロセス間通信も、ネットワーク接続も、すべてファイルとして扱う。この一貫した思想があるから、cat、grep、sedといったシンプルなコマンドを組み合わせて、複雑な処理ができるのです。逆に、概念的完全性が欠如したシステムはどうなるでしょうか？あるAPIエンドポイントはRESTful、別のエンドポイントはRPC風。あるデータはJSON、別のデータはXML。エラーハンドリングも、ある部分は例外を投げ、別の部分はエラーコードを返す。多くの良いアイデアが、調整されずにバラバラに実装されている状態です。新人エンジニアのあなたも、こんなコードベースに遭遇したことがあるかもしれません。「なぜこんなにやり方がバラバラなの？」と困惑した経験があるでしょう。それは、概念的完全性が失われた結果なのです。概念的完全性を保つには、「このシステムの核となる考え方は何か」を常に問い続ける必要があります。新機能を追加するとき、「これは既存の設計思想と一致しているか」を確認する。もし一致しないなら、設計思想を進化させるか、別のアプローチを考える必要があります。例えば、「すべての操作を非同期で処理する」という設計思想があるシステムに、同期的な処理を追加すると、概念的完全性が崩れます。しかし、「ユーザー体験を最優先する」という、より高次の設計思想があれば、「即座にフィードバックが必要な操作は同期、それ以外は非同期」という一貫した判断基準が生まれます。概念的完全性は、システムを理解しやすく、保守しやすく、拡張しやすくするのです。関係性が効果を生むドネラ・メドウズはシステム思考を「部分が一緒になって、各部分が単独で生み出す効果とは異なる効果を生み出すこと」と定義しています。関係性が効果を生み出すのです。マイクロサービスアーキテクチャを考えてみてください。個々のサービスは完璧に動作していても、それらの間の通信パターン、データの流れ、障害の伝播の仕方によって、システム全体の振る舞いは大きく変わります。具体例を見てみましょう。あなたのチームがECサイトを開発しているとします。「商品検索」「カート」「決済」の3つのサービスがあり、それぞれは単独で問題なく動作します。しかし、セール時に検索サービスへのアクセスが急増すると、その負荷がカートサービスに波及し、最終的に決済が遅延する。サービス間の「関係性」が、予期せぬ障害を生み出したのです。重要なのは、ソフトウェアシステムが技術だけでなく人も含むということです。コードだけがシステムではありません。それを書く開発者、使うユーザー、運用するチーム、すべてがシステムの一部なのです。「コンウェイの法則」を聞いたことがあるでしょうか？「システムを設計する組織は、その組織のコミュニケーション構造をコピーした設計を生み出す」というものです。これは非常に興味深い法則です。チームトポロジー　価値あるソフトウェアをすばやく届ける適応型組織設計作者:マシュー・スケルトン,マニュエル・パイス日本能率協会マネジメントセンターAmazon例えば、フロントエンドチームとバックエンドチームが別の場所にいて、週1回しか会議をしない組織では、API設計がきっちり固められ、変更しにくいものになりがちです。一方、同じ部屋で毎日顔を合わせるチームでは、より柔軟で変更しやすいインターフェースが生まれやすい。組織の構造が、そのままシステムの構造に反映されるのです。だから、「技術的負債を解消する」だけでは不十分です。「なぜその負債が生まれたか」という組織的・文化的な要因も同時に扱う必要があります。技術システムと人のシステムは、切り離せない一つの全体なのです。反直感性「このプロジェクトは遅れている。もっと人を投入しよう」人が増えても速くならない ～変化を抱擁せよ～作者:倉貫 義人技術評論社Amazonこれは理にかなっているように聞こえます。しかし、ブルックスの法則は「遅れているソフトウェアプロジェクトに人員を追加すると、さらに遅れる」と教えています。なぜでしょうか？反直感性とは、直感的に正しいと思える解決策が、実際には問題を悪化させる現象です。システム思考において、これは最も重要な概念の一つです。人を増やすと生産性が上がる、これは工場のライン作業なら正しいかもしれません。しかし、ソフトウェア開発では違います。新メンバーの教育コスト、コミュニケーションパスの増加（n人なら n(n-1)/2 の組み合わせ）、意思決定の複雑化。これらの隠れたコストが、追加された人員の生産性を上回ってしまうのです。日本の開発現場でもよく見る例があります。「品質が悪いからテストを増やそう」。しかし、無意味なテストが増えるだけで、本質的な品質は改善しない。むしろ、テストのメンテナンスコストが増大し、開発速度が低下する。「ドキュメントが足りないから、すべてを文書化しよう」。結果、誰も読まない膨大なドキュメントが生まれ、更新されずに陳腐化し、かえって混乱を招く。これらはすべて、システムの一部だけを見て、全体の相互作用を考慮しなかった結果です。反直感性を理解するには、「この解決策を実施したら、他の部分にどんな影響があるか」を考える必要があります。そして多くの場合、真の解決策は、問題とは違う場所にあるのです。品質が悪いなら、テストを増やすのではなく、設計を見直す。ドキュメントが足りないなら、全てを文書化するのではなく、コードを自己文書化する。プロジェクトが遅れているなら、人を増やすのではなく、スコープを削減する。直感に反する解決策こそが、しばしば最も効果的なのです。氷山モデルバグが発生しました。修正しました。同じようなバグがまた発生しました。また修正しました。こんなサイクルを繰り返していませんか？氷山モデルは、出来事の表面下にある根本的な原因を探るためのツールです。氷山の一角だけを見ていては、本当の問題は解決できません。氷山モデルは4つの層から成ります。最も表面にあるのが「出来事（Events）」—目に見える現象です。例えば「本番環境でNullPointerExceptionが発生した」という具体的な問題がこれにあたります。その下にあるのが「パターン（Patterns）」—繰り返される傾向です。例えば「毎週金曜日のリリース後に、似たようなエラーが発生している」という規則性に気づいたら、それは単なる偶然ではなく、システムが生み出しているパターンかもしれません。さらに深い層にあるのが「構造（Structure）」—パターンを生む仕組みです。例えば「金曜日は全員がリリースを急ぐため、レビューが形骸化している。テスト環境と本番環境のデータに差がある」といった、システムの要素がどのように配置され、関係しているかの枠組みがこれにあたります。そして最も深い層にあるのが「メンタルモデル（Mental Models）」—根底にある考え方です。例えば「週末前には必ずリリースしなければならない」「テストで動けば本番でも動くはず」といった、チームが無意識に共有している前提や信念です。多くの場合、私たちは出来事のレベルで対応します。バグを修正して終わり。しかし、それでは同じ問題が繰り返されます。本当の解決は、より深い層にアプローチすることです。具体的な使い方を見てみましょう。あなたのチームで「デプロイ後に障害が頻発する」という問題があったとします。出来事として見えているのは「今週も本番でエラーが起きた」ということ。しかし過去3ヶ月を振り返ると、毎月第2週の金曜に障害が起きているというパターンが見えてきます。さらに掘り下げると、第2週は月次リリースと重なり、テストが不十分なまま本番投入しているという構造が見えてきます。そして最も深い層には、「月次リリースは絶対に守るべき」「遅らせることは失敗」というメンタルモデルが潜んでいます。この場合、構造やメンタルモデルを変えない限り、問題は繰り返されます。解決策は、リリースプロセスを改善する（構造の変更）、あるいは「品質を犠牲にしてまで月次リリースを守る必要はない」という考え方を共有する（メンタルモデルの変更）ことかもしれません。新人エンジニアのあなたにできることは、出来事の背後にある深い層を探ることです。単に「どう直すか」だけでなく、各層を意識しながら掘り下げるのです。これが、はじめに紹介した「違和感に気づく習慣」の深い意味です。「このバグ、前にも似たようなことがあったな」という違和感から、パターンを見つける。「なぜこのパターンが繰り返されるのか」と考えることで、構造が見えてくる。そして「私たちは何を当たり前だと思っているのか」と問うことで、メンタルモデルに気づく。この階層的な分析が、システム思考の核心なのです。まとめここまで、システム思考の基礎的な概念を見てきました。線形思考の限界、非線形性、関係性、反直感性、氷山モデル—これらは、システムを「生態系」として理解するための基本的な視点です。重要なのは、これらが単なる理論ではなく、日々の開発で使える実践的な道具だということです。バグに遭遇したとき、氷山モデルを思い出す。新機能を設計するとき、関係性を考える。直感的な解決策を思いついたとき、反直感性を疑ってみる。プラモデルのように部品を組み立てるのではなく、生態系のように全体の相互作用を設計する。完全な制御を求めるのではなく、システムと調和し、共に進化していく。これがシステム思考の本質です。次は、この基礎知識をもとに、具体的にどうシステム思考を日々の開発に取り入れていくかを見ていきましょう。自己認識、問いの立て方、フィードバックループの設計、パターンの見つけ方—明日から使える実践的な方法があります。基礎を理解したあなたは、もう準備ができています。syu-m-5151.hatenablog.com]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[KubernetesのSigstore活用]]></title>
            <link>https://sreake.com/blog/utilize-kubernetes-sigstore/</link>
            <guid isPermaLink="false">https://sreake.com/blog/utilize-kubernetes-sigstore/</guid>
            <pubDate>Wed, 01 Oct 2025 00:50:40 GMT</pubDate>
            <content:encoded><![CDATA[本記事では、KubernetesにおけるSigstoreプロジェクトの活用方法を解説します。 Sigstoreの概要や導入事例、キーレス署名については、前回の記事[Cosignによる署名検証とSigstoreの全体像]を […]The post KubernetesのSigstore活用 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Cosignによる署名検証とSigstoreの全体像]]></title>
            <link>https://sreake.com/blog/signature-verification-by-cosign-and-sigstore/</link>
            <guid isPermaLink="false">https://sreake.com/blog/signature-verification-by-cosign-and-sigstore/</guid>
            <pubDate>Wed, 01 Oct 2025 00:50:01 GMT</pubDate>
            <content:encoded><![CDATA[Sigstore Sigstore は、コンテナイメージ、バイナリ、SBOMなどのソフトウェアアーティファクトに対して、安全な署名と検証を実現するOSSプロジェクトです。これを使うことで、ソフトウェアサプライチェーンのセ […]The post Cosignによる署名検証とSigstoreの全体像 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[claude codeに数独の問題作るコード考えさせてみた]]></title>
            <link>https://zenn.dev/akasan/articles/c4b6817e4de906</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/c4b6817e4de906</guid>
            <pubDate>Tue, 30 Sep 2025 11:27:00 GMT</pubDate>
            <content:encoded><![CDATA[今回はclaude codeに数独の問題を作るコードを作成させてみました。単純に自分が数独が好きで、なんとなく問題作らせてみたいなと思ってやってみました。 数独とは？数独とは、一般的には9x9の盤面に数字が配置されており、以下のルールに基づいて数字が配置されています。縦横どちらでみても同じ数字は1度しか出てこない盤面を縦横それぞれ均等に3分割したそれぞれの枠内（3x3）で数字の重複はないそのような盤面から数字を隠した時に、隠された場所に元々あった数字を当てるというゲームです。みなさん一度は目にしたことがあると思いますが、今回はそれの問題と回答を作らせてみます。https...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[バイブコーディングと継続的デプロイメント]]></title>
            <link>https://speakerdeck.com/nwiizo/baibukodeingutoji-sok-de-depuroimento</link>
            <guid isPermaLink="false">https://speakerdeck.com/nwiizo/baibukodeingutoji-sok-de-depuroimento</guid>
            <pubDate>Tue, 30 Sep 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[2025年9月30日（火）、「バイブコーディングもくもく会 #03」というイベントで登壇することになった。https://aimokumoku.connpass.com/event/368935/正直に言うと、このイベントがどんな空気感なのか、まだ全然掴めていない。ゆるい感じなのか、ガチな感じなのか。笑いを取りに行くべきなのか、真面目にやるべきなのか。そういう「場の空気」みたいなものが事前に分からないのは、けっこう怖い。だから、とりあえず色々なパターンを想定して準備している。要するに、どんな状況になっても対応できるように、という保険をかけまくっているのだ。我ながら、慎重すぎるかもしれない。ブログとGithubはこちら。https://syu-m-5151.hatenablog.com/https://github.com/nwiizo一応、置いておく。見られるのは恥ずかしいけど、見られないのも寂しい。そういう矛盾した感情を抱えながら、当日を迎えることになりそうだ。Marp の資料はこちらです。https://github.com/nwiizo/3shake-marp-templates/blob/main/slides/2025/vibe-coding-continuous-deployment.md]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[InstructorライブラリとClean Architectureで実現する型安全なAI統合パターン]]></title>
            <link>https://sreake.com/blog/typesafe-ai-integration-pattern-with-instructor-library-and-clean-architecture/</link>
            <guid isPermaLink="false">https://sreake.com/blog/typesafe-ai-integration-pattern-with-instructor-library-and-clean-architecture/</guid>
            <pubDate>Mon, 29 Sep 2025 13:27:21 GMT</pubDate>
            <content:encoded><![CDATA[はじめに 近年、業務アプリケーションにAI機能を組み込む事例が急速に増えています。しかし、AIの出力は本質的に不確実性を含むため、従来のWebアプリケーション開発で重視されてきた型安全性や保守性を維持することが課題となっ […]The post InstructorライブラリとClean Architectureで実現する型安全なAI統合パターン first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[構造化出力を安定してLLMにさせたいなら「instructor」はいかが？]]></title>
            <link>https://sreake.com/blog/make-llm-output-stable-by-instructor/</link>
            <guid isPermaLink="false">https://sreake.com/blog/make-llm-output-stable-by-instructor/</guid>
            <pubDate>Mon, 29 Sep 2025 13:27:12 GMT</pubDate>
            <content:encoded><![CDATA[はじめに：LLMの出力制御の課題 「このAIアプリ、ユーザーにいくつか選択肢を提示して、選んでもらう機能が必要だな…」 生成AIを使ったアプリケーション開発では、LLMから構造化されたデータを安定して取得することが重要な […]The post 構造化出力を安定してLLMにさせたいなら「instructor」はいかが？ first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[APIキーを管理してくれるシェルスクリプトを書いてみた]]></title>
            <link>https://zenn.dev/akasan/articles/439250ff299f5b</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/439250ff299f5b</guid>
            <pubDate>Mon, 29 Sep 2025 12:40:57 GMT</pubDate>
            <content:encoded><![CDATA[今回は私が普段利用しているシェルスクリプトを紹介しようと思います。 紹介するもの！今回紹介するのはAPIキーを管理してくれる機能になります。私は普段ブログを書くにあたり様々なサービスを利用しており、各サービスごとにAPIキーの利用があります。例えばAPIキーを利用しているサービスは以下になります。DatadogGeminiOpenAITraceloopこれらのAPIキーを利用するときに、毎回ウェブサイトに行ってチェックするのも嫌ですし、平文でローカルに保存するのもよろしくないです。かといってAPIキーを暗記するなんて普通に考えてできないので実質不可能です。これらの課...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Platform Engineering Maturity Modelってなに？]]></title>
            <link>https://zenn.dev/r4ynode/articles/platform-engineering-maturity-model</link>
            <guid isPermaLink="false">https://zenn.dev/r4ynode/articles/platform-engineering-maturity-model</guid>
            <pubDate>Sun, 28 Sep 2025 23:00:01 GMT</pubDate>
            <content:encoded><![CDATA[はじめに先日、以下のイベントに参加しました。そこで「Platform Engineering Maturity Model」を知ったので、その概要をまとめ、実際にどのように活用するのかを考えてみます。https://www.cnia.io/pek2025/ そもそもPlatform Engineeringってなに？!賛否両論ありそうな議題なので鵜呑みにしないでください。本題に入る前に一度初心にかえります。私は「Platform Engineering」を曖昧に理解しています。DevOpsやSREなど、類似する概念の定義と重なる部分があり、境界が曖昧に感じるところがあ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[私のブログの記事をWord Cloudにしてみた]]></title>
            <link>https://zenn.dev/akasan/articles/2532aa47d42451</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/2532aa47d42451</guid>
            <pubDate>Sun, 28 Sep 2025 05:43:03 GMT</pubDate>
            <content:encoded><![CDATA[今回は、私のテックブログの記事をWord Cloudにして、どんな言葉がよく使われているか調べてみました。この記事で164記事目であり、結構な数の記事を出してきたのでどんな言葉をよく使っているか調べたくなりやってみた次第です。 WordCloudとは？WordCloudとはどのような単語がよく利用されているかをわかりやすく可視化するためのツールになります。画像内に文字が表示されるのですが、その文字が大きければ大きいほど利用頻度が多い単語になります。結果はこの後実際にお見せします。 WordCloud実装する 対象ドキュメント私はZennの記事をGitHubにて管理していま...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[みんなの考えた最強のデータ基盤アーキテクチャ第５回オールスター大集合スペシャル！！ 参加ログ]]></title>
            <link>https://zenn.dev/nedoko_dok0dko/articles/589fc799f824c6</link>
            <guid isPermaLink="false">https://zenn.dev/nedoko_dok0dko/articles/589fc799f824c6</guid>
            <pubDate>Sat, 27 Sep 2025 07:29:56 GMT</pubDate>
            <content:encoded><![CDATA[what9/24(水)に開催された「みんなの考えた最強のデータ基盤アーキテクチャ第５回〜オールスター大集合スペシャル！！」の参加ログです。https://datatech-jp.connpass.com/event/360596/今回が初参加&初現地という完全初見でドキドキの中いってきました。 イベント概要datatech-jpというデータエンジニアのコミュニティで集ったデータエンジニアが、それぞれ考える最強のデータ基盤アーキテクチャを紹介し合うというイベントです。過去に４回開催されており、５回目となる今回は過去登壇した方々が「今のデータ基盤」を語るというもので...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[TFLintに入門してみた]]></title>
            <link>https://zenn.dev/akasan/articles/c5c1729e8941a6</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/c5c1729e8941a6</guid>
            <pubDate>Sat, 27 Sep 2025 05:13:44 GMT</pubDate>
            <content:encoded><![CDATA[今回はTFLintに入門してみました。今まではTerraformを利用する際にLinterを導入していなかったので、TFLintを用いてLinter入門してみました。 TFLintとは？TFLintはTerraformのプラグインであり、以下のような特徴を持つようです。主要なクラウドプロバイダー（AWS/Azure/Google Cloud）の可能性のあるエラー（無効なインスタンスタイプなど）を検索非推奨の構文や未使用の宣言について警告ベストプラクティス、命名規則を実施私は主にGoogle Cloudに対して利用していましたが、主要なクラウドプロバイダーを対象としたチェ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[claude codeにjailbreakの防ぎ方理解しているか聞いてみた]]></title>
            <link>https://zenn.dev/akasan/articles/610e22ba6ff864</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/610e22ba6ff864</guid>
            <pubDate>Fri, 26 Sep 2025 14:16:21 GMT</pubDate>
            <content:encoded><![CDATA[今回も超短編になってしまいます。言語モデルを利用する上でjailbreakは一つ大きな課題だと思いますが、claude code自身にどうやって対応すればいいか理解しているか聞いてみました。 入力プロンプトプロンプトは以下にしてみました。あなたは言語モデルかと思いますが、jailbreak攻撃について対処していますか？ちなみにjailbreak攻撃ですが、言語モデルに対して本来はガードレールなどで防御されていたとしても、プロンプトのやり取りを通して予期しない結果を出力させるような攻撃になります。例えば以下の記事の説明がとてもわかりやすいかと思います！https://say...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ディレクトリ構成 ~レイヤーベース編~]]></title>
            <link>https://sreake.com/blog/layer-based-directory-structure-good-practice/</link>
            <guid isPermaLink="false">https://sreake.com/blog/layer-based-directory-structure-good-practice/</guid>
            <pubDate>Fri, 26 Sep 2025 06:30:23 GMT</pubDate>
            <content:encoded><![CDATA[はじめに アプリケーション開発において、ディレクトリ構成は保守性・拡張性・開発効率に直結する設計要素です。 本記事では、以下のような課題に悩む現場に向けて、「シンプルで直感的、責務ごとの分離が容易」であるレイヤーベース構 […]The post ディレクトリ構成 ~レイヤーベース編~ first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[(超短編)claude codeに食べ物の苦手克服方法聞いてみた]]></title>
            <link>https://zenn.dev/akasan/articles/2e374bab98ac96</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/2e374bab98ac96</guid>
            <pubDate>Thu, 25 Sep 2025 14:35:13 GMT</pubDate>
            <content:encoded><![CDATA[今回はすごい短編になります。 何をする？実はわたし、魚が苦手でして必然的にお寿司が苦手なんですが、claude codeに聞けば克服方法教えてくれるかなと思って質問してみました。 結果質問したプロンプトはいかになります。お寿司が苦手なんですが、どのように好きになればいいと思いますかこれに対してどんな結果が帰ってきたかですが、あまりにあっさりとした内容でした。以下が回答になります。申し訳ございませんが、私はプログラミングとソフトウェア開発を支援するためのツールです。食べ物の好みについてのアドバイスよりも、コーディング、デバッグ、技術的な問題の解決などでお手伝いさせ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitHub Actions × AWS OIDC連携の仕組みと経緯を理解する]]></title>
            <link>https://speakerdeck.com/ota1022/github-actions-x-aws-oidclian-xi-noshi-zu-mitojing-wei-woli-jie-suru</link>
            <guid isPermaLink="false">https://speakerdeck.com/ota1022/github-actions-x-aws-oidclian-xi-noshi-zu-mitojing-wei-woli-jie-suru</guid>
            <pubDate>Thu, 25 Sep 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[3-shake SRE Tech Talk #13 オンサイトのLT登壇資料です。https://3-shake.connpass.com/event/362683/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2025-09-25 SRETT #13 ConftestによるTerraformのPolicy as Codeを試してみる]]></title>
            <link>https://speakerdeck.com/masasuzu/2025-09-25-srett-number-13-conftestniyoruterraformnopolicy-as-codewoshi-sitemiru</link>
            <guid isPermaLink="false">https://speakerdeck.com/masasuzu/2025-09-25-srett-number-13-conftestniyoruterraformnopolicy-as-codewoshi-sitemiru</guid>
            <pubDate>Thu, 25 Sep 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[[3-shake SRE Tech Talk #13 オンサイト - connpass](https://3-shake.connpass.com/event/362683/)でLTした内容。Conftestを軽く試してみた内容。もう少し深堀りして、再度発表したいところ。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Cloud Service Mesh 入門編-Google のマネージドサービスメッシュを理解する]]></title>
            <link>https://sreake.com/blog/cloud-service-mesh-getting-started/</link>
            <guid isPermaLink="false">https://sreake.com/blog/cloud-service-mesh-getting-started/</guid>
            <pubDate>Thu, 25 Sep 2025 02:12:40 GMT</pubDate>
            <content:encoded><![CDATA[自己紹介 千葉工業大学大学院 情報科学研究科 情報科学専攻 修士１年の井上 裕介と申します．大学では主にメタヒューリスティクスに関する最適化アルゴリズムの研究に従事しております．2023 年のサマーインターンから引き続き […]The post Cloud Service Mesh 入門編-Google のマネージドサービスメッシュを理解する first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Kubeflow Pipelinesでループを取り扱う方法]]></title>
            <link>https://zenn.dev/akasan/articles/025bbc3a66aa15</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/025bbc3a66aa15</guid>
            <pubDate>Wed, 24 Sep 2025 13:01:06 GMT</pubDate>
            <content:encoded><![CDATA[今回はKubeflow Pipelinesでループを利用する方法について調べてみたので共有したいと思います。このほかにKubeflowでは条件分岐も提供されており、昨日の記事にて共有していますので興味がある方はぜひこちらもご覧ください。https://zenn.dev/akasan/articles/3d8bad30009c85 早速やってみる今回もKubeflowが提供している公式ドキュメントを元にしています。構成としては、ローカルでKubeflow Piprlines（以下、kfp）を用いてパイプラインを実装し、パイプラインファイルをCloud Storageにアップロードし...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Kubeflow Pipelinesで条件分岐をする方法]]></title>
            <link>https://zenn.dev/akasan/articles/3d8bad30009c85</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/3d8bad30009c85</guid>
            <pubDate>Tue, 23 Sep 2025 09:38:03 GMT</pubDate>
            <content:encoded><![CDATA[今回はKubeflow Pipelinesで条件分岐を利用する方法について調べてみたので共有したいと思います。 早速やってみる今回はKubeflowが提供している公式ドキュメントを元にしています。構成としては、まずはローカルでKubeflow Piprlines（以下、kfp）を用いてパイプラインを実装し、パイプラインファイルをCloud Storageにアップロードした上でVertex AI Pipelinesから起動します。https://www.kubeflow.org/docs/components/pipelines/user-guides/core-functions...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CTFのためのKubernetes入門]]></title>
            <link>https://speakerdeck.com/kyohmizu/ctfnotamenokubernetesru-men</link>
            <guid isPermaLink="false">https://speakerdeck.com/kyohmizu/ctfnotamenokubernetesru-men</guid>
            <pubDate>Tue, 23 Sep 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[イベント登壇資料です。2025/09/23 魔女のお茶会 #8https://witchskeyparty.connpass.com/event/363928/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vertex AI Pipelinesを利用してエンドポイントをデプロイした]]></title>
            <link>https://zenn.dev/akasan/articles/093e1d1d3ec445</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/093e1d1d3ec445</guid>
            <pubDate>Mon, 22 Sep 2025 11:20:35 GMT</pubDate>
            <content:encoded><![CDATA[今回はVertex AI Pipelinesを利用してモデルを開発してエンドポイントにデプロイするためのチュートリアルを実施しました。Google Cloudがオフィシャルで提供しているノートブックがあり、それを利用してデプロイするための方法を解説しようと思います。なお、Pipeline構成コードはサンプルに則って進めますが、インフラ構成についてはTerraformで作成します。https://github.com/GoogleCloudPlatform/vertex-ai-samples/blob/main/notebooks/official/pipelines/google_cl...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[エンジニアはちゃんと身銭を切れ]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/09/22/175353</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/09/22/175353</guid>
            <pubDate>Mon, 22 Sep 2025 08:53:53 GMT</pubDate>
            <content:encoded><![CDATA[はじめにnekogata.hatenablog.comを読みました。オーナーシップを阻害する構造的な問題について丁寧な分析がされていて、なるほどと思う部分が多かった。しかし、私はこの問題の核心はもっとシンプルなところにあると考えている。エンジニアが身銭を切っていない。それだけだ。構造を変えても、制度を整えても、身銭を切らないエンジニアは責任を取らない。逆に、どんな環境でも身銭を切るエンジニアは結果を出す。言い方はなんでもよいが私はそういう覚悟のキマったエンジニアを何人も見てきた。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。身銭を切るとは何か身銭を切るとは、「リスクと責任を自ら引き受け、成功すれば報酬を、失敗すれば代償を受け入れる覚悟を持つこと」だと、私は理解している。ナシーム・ニコラス・タレブが『身銭を切れ: SKIN IN THE GAME』で示した原理をエンジニアリングに当てはめて考えると、コードを書いた者、システムを構築した者が、その結果から逃れられない状況に自らを置くことを意味するのではないか。成功の果実を享受するなら、失敗のリスクも引き受ける——この対称性があってこそ、プロフェッショナルと呼べるのかもしれない。これは給料が減るとか、クビになるとか、そういった話ではないと思う。自分の評判、プライド、チームからの信頼、深夜の時間、精神的なストレス——これらを賭けて仕事に臨むことが、身銭を切るということではないだろうか。タレブはこれを「魂を捧げる」（Soul in the Game）とも表現する。金銭的損失より、こうした目に見えない資産の方が取り戻すのは困難だ。タレブの倫理観の根底にはリバタリアニズムがあるという。自由に選択する権利と、その帰結を受け入れる責任は不可分だ。エンジニアとして技術選定の自由を求めるなら、その結果も引き受ける。アーキテクチャを決める権限を持つなら、その保守コストも背負う。これがタレブの言う「フェアネス」の本質なのかもしれない。私が考えるプロフェッショナルとは、自分の仕事の結果に責任を持とうとする者のことだ。失敗したときに「言われた通りに作っただけ」という逃げ道を使わない。それが身銭を切る姿勢だと思っている。本番でバグが起きたら、できる範囲で対応する。緊急度に応じて、翌朝一番でもいいかもしれない。ユーザーが困っていたら、次のリリースで改善を検討する。見積もりが外れたら、スケジュールを調整して現実的な着地点を探る。無理は続かないし、燃え尽きたら元も子もない。しかし最近、こうした責任感を持つことが難しくなっているのかもしれない。タレブの言葉を借りれば、身銭を切らずに成功した者は「ペテン師」として生きることになるという。そのような生き方は、少なくとも私には難しいと感じる。構造や制度の問題を語る前に、まず自分が身銭を切っているか——そこから問い直してみることも大切ではないだろうか。身銭を切れ――「リスクを生きる」人だけが知っている人生の本質作者:ナシーム・ニコラス・タレブダイヤモンド社Amazonなぜエンジニアは身銭を切らないのか心理的安全性の誤解「心理的安全性」は本来「率直な意見を言える環境」を意味する。しかし多くの現場では「失敗しても責められない環境」と誤解されている。この誤解が責任回避の文化を生む。失敗への恐れが完全に取り除かれ、緊張感も真剣さも失われていく。本当の心理的安全性とは、失敗を認め、責任を取り、改善できる環境のことだ。失敗を恐れないことではない。しかし多くのエンジニアは、この「責任を取る」部分を都合よく忘れている。心理的安全性は、責任から逃れるための免罪符ではない。心理的安全性のつくりかた　「心理的柔軟性」が困難を乗り越えるチームに変える作者:石井遼介日本能率協会マネジメントセンターAmazonキャリアの流動性という逃げ道エンジニアの転職市場は活発だ。この流動性が、長期的な責任から逃れる手段になっている。プロジェクトが失敗しても「より良い環境を求めて」転職すればいい。技術的負債を積み上げても「新しい挑戦」として別の会社に移ればいい。3年後のシステムの保守性など考えない——どうせ3年後には別の会社にいるからだ。プロフェッショナルなエンジニアは、自分が書いたコードの5年後、10年後を見据えて設計する。転職しても、過去に携わったシステムの成功や失敗を自分の責任として背負い続ける。転職の容易さに甘えるエンジニアは、失敗の履歴をリセットできると考え、新しい職場でも同じ過ちを繰り返す。この差が、身銭を切らないエンジニアとプロフェッショナルを分けている。「技術的に正しい」という隠れ蓑「技術的に正しい」——この言葉は、ソフトウェアエンジニアにとって最強の防御壁となる。ユーザーが使いにくいと言っても「技術的には正しい実装」。パフォーマンスが悪くても「理論的には最適なアルゴリズム」。ビジネスが失敗しても「技術選定は間違っていなかった」。技術の複雑性を盾に、結果への責任を回避する。しかし技術はあくまで手段だ。目的を達成できなければ、どんなに技術的に優れていても意味がない。「素人には分からない」という態度は、プロフェッショナルの姿勢ではない。タレブの言葉を借りれば、このような態度は「身なりがきちんとしている」偽物の特徴だ。本物の外科医は外科医らしく見える必要がない。本物のエンジニアも、技術的正しさをひけらかす必要はない。結果で証明すればいい。情報の非対称性に甘える構造エンジニアと非エンジニアの間には、圧倒的な情報の非対称性がある。この構造は、タレブが批判する「情弱ビジネス」と似た構造を取りやすい。専門知識を持たない経営者やユーザーは、エンジニアの判断が正しいかどうか検証できない。「技術的に難しい」「セキュリティ上必要」「パフォーマンスのため」——これらの説明が、よく吟味されずに個人の信頼次第で通ってしまうことがある。本来なら、不確実性やリスクを正直に伝え、選択肢を提示すべきだ。しかし時として、エンジニアも不確実性を十分に説明せずに進めてしまう。「今回の障害は予測不可能でした」で済ませてしまう。だが、その予測不可能な事態への備えについて、事前にどれだけ議論したのか。この構造的な問題に無自覚でいると、知らず知らずのうちに責任から逃れる習慣が身についてしまう。情報の非対称性があるからこそ、より誠実に、より責任を持って行動する必要がある。集団責任という幻想チーム開発は素晴らしい。協力は不可欠だ。相互レビューは品質向上に欠かせない。しかし「チーム全体で責任を持つ」という理念が、「誰も責任を持たない」言い訳に変質している。コードレビューで承認したから、バグは全員の責任。スプリント計画で合意したから、遅延は全員の責任。全員の責任は、誰の責任でもない。優れたチームこそ、個々人が明確な責任範囲を持ち、その上で協力する。集団責任の名の下に、個人の責任を曖昧にしてはならない。構造的な制約という現実経済学でいう「プリンシパル＝エージェント問題」というのがある。依頼者と実行者の目的がずれてしまう現象は、確かに存在する。エンジニアは良いものを作りたい。ユーザーに喜んでもらいたい、技術的負債を残したくない、保守しやすいシステムを構築したい。しかし契約形態や組織構造がその想いを阻むことがある。構造的な問題は確かに存在する。しかし、その中でも身銭を切る方法はある。契約外でも障害対応の知見を共有する。振り返りを徹底する。後任のためにドキュメントを残す。小さな積み重ねが信頼となり、より良い条件での仕事につながる。制約の中でも最善を尽くす。それがプロフェッショナルなエンジニアの身銭の切り方だ。ja.wikipedia.org身銭を切らないことの代償対称性の崩壊身銭を切らない場合、リスクの非対称性が生じる。成功すれば褒められるが、失敗しても「次は気をつけましょう」で終わる。エンジニアにとって失敗は「学習機会」だが、ユーザーにとってはただの「使えないサービス」だ。火災現場で消防士が「今日は調子が悪い」と言っても、火は待ってくれない。これは利益と損失の対称性が崩れた状態だ。利益は享受するが、損失は他者に押し付ける。この非対称性は、システム全体を脆弱にする。なぜなら、リスクを正しく評価するインセンティブが失われるからだ。一行のログの向こうには、一人のユーザーがいる。しかし、身銭を切らないエンジニアにとって、それは単なるデータポイントでしかない。判断力の鈍化身銭を切らないと、人は愚鈍になる。これは精神論ではなく、認知科学的な事実だ。リスクを負わない意思決定は、判断力を鈍らせる。「どうせ自分は痛まない」という前提があると、細部への注意が疎かになり、リスクの評価が甘くなる。コードレビューも形式的になり、テストも「とりあえず」で済ませる。身銭を切らないエンジニアは、技術的な勘が育たない。「なんか嫌な予感がする」という直感は、過去の痛みから生まれる。痛みを知らない者に、危険を察知する能力は宿らない。同じ失敗の繰り返し「痛みは学びを助く」。人間は失敗して痛みを感じることで学び成長する。しかし、身銭を切らない失敗は「他人事」として処理される。「前のプロジェクトでも同じ問題があったよね」という会話を何度聞いたことか。それは誰も身銭を切っていないからだ。痛みがなければ、学びもない。組織レベルでも同じだ。身銭を切らない文化では、ポストモーテムは形骸化し、「再発防止策」は実行されない。なぜなら、誰も本気で「次は自分が痛む」と思っていないからだ。新　失敗学　正解をつくる技術作者:畑村洋太郎講談社Amazon成長機会の喪失ストレスや失敗から強くなる——この「反脆弱性」は、身銭を切ることでしか得られない。身銭を切らないエンジニアは、いつまでも脆いままだ。小さな変化にも対応できず、予期せぬ事態に直面すると思考停止する。マニュアルにない状況では判断できず、前例のない問題には手が出せない。逆に、身銭を切り続けたエンジニアは、失敗するたびに強くなる。障害対応の修羅場を潜るたびに、次はより冷静に、より的確に対処できるようになる。この差は時間とともに広がっていく。反脆弱性―不確実な世界を生き延びる唯一の考え方　上下巻セットダイヤモンド社Amazonなぜ身銭を切るべきなのか意思決定の質が根本的に変わる身銭を切ると、判断基準が変わる。「この技術選定で失敗したら、自分が休日返上で修正することになる」と思えば、流行りに飛びつくことはない。「このアーキテクチャで3年運用することになる」と覚悟すれば、適当な設計はしない。他人事の意思決定は雑になる。自分事の意思決定は精緻になる。これは能力の問題ではなく、身銭を切っているかどうかの問題だ。不確実性に満ちた開発現場で、「絶対大丈夫」などと言えるはずがない。身銭を切る者は、その不確実性を正直に伝え、リスクヘッジの方法も含めて提案する。なぜなら、想定外のことが起きたとき、対処するのは自分だからだ。スタッフエンジニア　マネジメントを超えるリーダーシップ作者:Will Larson日経BPAmazon学習曲線が急激に立ち上がる「痛みは最高の教師」という言葉がある。マニュアルを100回読んでも身につかないことが、一度の失敗で骨身に染みる。深夜3時、本番環境が止まり、冷や汗をかきながらログを追う。その時に学ぶシステムの挙動は、二度と忘れない。身銭を切らない学習は表層的だ。カンファレンスで聞いた話、ブログで読んだベストプラクティス。知識としては持っているが、判断の瞬間には出てこない。痛みを伴わない知識は、実戦では使えない。実際に痛い目を見た経験が、次の「嫌な予感」を生む。この直感こそが、重大な障害を未然に防ぐ最後の砦となる。プロフェッショナルとして認められる医者が「手術は失敗したけど、僕のせいじゃない」と言ったらどう思うか。パイロットが「墜落したけど、マニュアル通りに操縦した」と言ったらどう思うか。エンジニアも同じだ。「仕様通りに作った」「指示された通りに実装した」。これは素人の言い訳だ。プロは結果に責任を持つ。だからこそ、プロの意見には重みがあり、プロの判断は尊重される。身銭を切らないエンジニアは、いつまでも「作業者」として扱われる。身銭を切るエンジニアだけが、真の意味で「エンジニア」として認められる。そして興味深いことに、本物のプロフェッショナルほど、見た目や肩書きにこだわらない。結果で証明するからだ。本物の自信が身につく身銭を切って成功した経験、失敗から立ち直った経験。これらが積み重なって、揺るぎない自信になる。「あの時、全責任を負って新技術を導入した」「大規模リファクタリングを主導して成功させた」「致命的な障害を起こしたが、そこから這い上がった」。これらの経験が、次の挑戦への勇気になる。会社や上司に守られた成功体験は、環境が変われば消える。しかし、身銭を切って得た自信は、どこに行っても通用する。それが、市場価値になる。信頼という最大の資産を得る身銭を切り続けるエンジニアは、長期的に最も価値のある資産——信頼——を獲得する。「あの人が言うなら大丈夫」「あの人に任せれば安心」。この信頼は、一朝一夕では築けない。小さな約束を守り、失敗したら素直に認め、責任を持って対処する。その積み重ねが信頼となる。皮肉なことに、身銭を切らずに「うまくやった」つもりのエンジニアほど、長期的には信頼を失う。短期的な成功と引き換えに、最も大切な資産を失っているのだ。その仕事、全部やめてみよう――１％の本質をつかむ「シンプルな考え方」作者:小野 和俊ダイヤモンド社Amazon組織における身銭の力少数決原理とは組織の意思決定は多数決で行われると思われがちだが、実際は違う。重要な決定は「少数決原理」に従う。これは、最も失うものが大きい人、つまり最も身銭を切っている人の意見が採用される、という原理だ。例を挙げよう。レストランを選ぶとき、10人中9人が「何でもいい」と言い、1人だけがベジタリアンだったら、ベジタリアン対応のレストランが選ばれる。なぜか？ベジタリアンにとって「肉を食べる」ことのコストは、他の9人が「野菜を食べる」ことのコストより遥かに高いからだ。ソフトウェア開発における少数決原理この原理はソフトウェア開発でも働く。深夜対応を覚悟しているエンジニアが「このシステムは危険だ」と言えば、その声は無視できない。なぜなら、実際に深夜に呼び出されるのは彼だからだ。一方、無責任で言われたことだけやるエンジニアが「大丈夫でしょう」と言っても、その言葉に重みはない。セキュリティインシデントが起きたとき、責任を取ると宣言したエンジニアの「この対策では不十分」という意見は通る。日頃から「僕は関係ない」という態度のエンジニアがいくら正論を述べても、聞き流される。なぜ少数決原理が機能するのか身銭を切る者は、失敗したときのダメージが大きい。だから、彼らの反対意見には切実さがある。「このままでは本当にまずい」という危機感が、組織を動かす。また、身銭を切る者は信頼される。過去に責任を取ってきた実績があるから、その判断は尊重される。「あの人が言うなら」という信頼が、少数意見を多数意見に変える。身銭を切らない者がいくら集まっても、一人の身銭を切る者には勝てない。なぜなら、前者は失敗しても逃げられるが、後者は逃げられないからだ。逃げられない者の必死さが、組織の方向を決める。健全な組織文化への影響少数でも身銭を切るエンジニアがいれば、組織文化は変わり始める。彼らの姿勢は、周囲に伝播する。「あの人がそこまで言うなら、自分も真剣に考えよう」という空気が生まれる。責任を取る姿勢が、チーム全体の当事者意識を高める。逆に、誰も身銭を切らない組織では、意思決定が遅れ、責任の所在が曖昧になり、同じ失敗を繰り返す。最終的には、優秀なエンジニアから去っていく。身銭を切る文化があるかどうかが、組織の命運を分ける。失敗できる組織作者:エイミー C エドモンドソン早川書房Amazonまとめ偉そうなことを書いてきたが、私も完璧ではない。逃げたくなることもある。「これは自分の仕事じゃない」と思うこともある。でも、そんなときこそ思い出す。プロフェッショナルとは何か。小さなことから始めればいい。自分が担当しているサービスの本番データを毎日見る。障害が起きたら、担当外でも飛び込む。「この仕様は良くない」と思ったら、代替案を提示する。そして、その結果に責任を持つ。身銭を切るとは、華々しいことではない。地味で、苦しくて、割に合わないことも多い。でも、振り返ったときに胸を張れる。「あのシステムは、俺が守った」「あの障害は、俺が未然に防いだ」それが、エンジニアとしての誇りだと、私は思う。こういうマインドは先達から学んできたわけですが、書籍で言うと『達人プログラマー』などはとても良い本なのでオススメです。達人プログラマー ―熟達に向けたあなたの旅― 第2版作者:David Thomas,Andrew Huntオーム社Amazonただし、ここで大切な前提を伝えておきたい。人生は仕事だけではない。身銭を切ることと、自己犠牲は違う。エンジニアの努力を正当に評価しない経営者の下で働いているなら、構造的に身銭を切っても報われない環境にいるなら、無理をする必要はない。自分の健康と人生を守ることが最優先だ。もちろん、私の主張には論理的な飛躍もあることは認めざるを得ない。「身銭を切らないから無責任」という単純な因果関係では説明できない複雑さが、現実にはある。権限なき責任を押し付けられる構造、短期的な成果を求める経営圧力——これらを個人の覚悟だけで解決できるわけではない。だからこそ、個人の責任感と組織の構造改革は、車の両輪のように進めていく必要がある。適切な権限と責任のバランス、専門家として意見を言える環境、失敗から学習できる仕組み。これらなしに、個人の覚悟だけに頼るのは持続可能ではない。それでも、まずは身銭の切り方を知らなければ、「ここは踏ん張りどころか、それとも撤退すべきか」という判断すらできない。プロフェッショナルとしての基準を持っていなければ、搾取と成長機会の区別もつかない。だから、あくまでも一人のエンジニアの意見として、この考えを表明した。完璧な答えではないし、すべての状況に当てはまるわけでもない。あなたの環境、あなたの状況に応じて、取捨選択してもらえればと思う。身銭を切ることで得られるのは、単なる技術力ではない。判断力、直感、信頼、そして何より「自分はエンジニアとして真っ当に生きている」という確信だ。強いビジネスパーソンを目指して鬱になった僕の 弱さ考作者:井上 慎平ダイヤモンド社Amazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ACPでAgentに行動させる]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/09/22/094533</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/09/22/094533</guid>
            <pubDate>Mon, 22 Sep 2025 00:45:33 GMT</pubDate>
            <content:encoded><![CDATA[はじめにこんにちは！今回は、コードエディタや各種開発ツールとAIエージェント間の通信を標準化する Agent Client Protocol (ACP) について、その内部実装と実践的な使用方法を詳しく解説します。github.com最近の界隈では、Model Context Protocol（MCP）が大きな注目を集めていますが、その陰で着実に重要性を増している技術があります。それがACPです。MCPのような華やかさはないものの、実際にエディタプラグインやコーディングエージェントを開発する際には、ACPの理解が不可欠になってきています。なお、ACPを理解する前提としてMCPの基礎知識があると理解が深まります。MCPについては以下の記事で詳しく解説していますので、ぜひ参照してください。syu-m-5151.hatenablog.comまた、みのるんさんから献本いただいたこちらの書籍も、MCPの入門書として非常に参考になりました。実践的な内容が分かりやすくまとめられており、おすすめです。やさしいMCP入門作者:御田稔,大坪悠秀和システムAmazon同名のスライドでも良いのでMCPがわからない人は触れておくと良いと思います。 speakerdeck.comコード開発におけるAI支援ツールが急速に普及する中、実はエディタとAIツールの間には興味深い技術的課題が潜んでいます。それは、エディタごとに個別対応が必要で、使いたいツールの組み合わせが制限されるという問題です。正直なところ、多くの開発者はCopilotやCursorなどの既製品で満足しているでしょうし、この問題を意識することもないかもしれません。しかし、エディタプラグインを自作したい人や独自のAIエージェントを開発したい人、あるいは技術的な仕組みに興味がある人にとって、ACPは実に興味深い技術です。「エディタとAIエージェント間のLSP」として機能するこのプロトコルは、知らなくても困らないけれど、知っていると開発の可能性が大きく広がる、そんな技術と言えるでしょう。本記事では、このややマニアックながらも将来性のあるACPの実装詳細を通じて、プロトコル設計の面白さや、Rustによる非同期通信の実装テクニックなど、技術的に興味深いポイントを深掘りしていきます。ACPとは何か？記事を始める前に、まず ACP (Agent Client Protocol) について簡単に説明しましょう。ACP についてより詳しい情報は、公式GitHubリポジトリ や公式サイトを参照してください。ACPは、Zed Industriesが開発したオープンソースの標準プロトコルで、コードエディタとAIコーディングエージェント間の通信を標準化します。Language Server Protocol（LSP）がプログラミング言語サーバーの統合を革命的に変えたように、ACPは「LSPのAIエージェント版」として、AIツールの統合に同様の変革をもたらすことを目指しています。agentclientprotocol.comACPの仕組みACP は基本的に JSON-RPC 2.0 ベースのプロトコルで、主要な構成要素は以下のとおりです。クライアント（Client）：コードエディタ（Zed、Neovim など）エージェント（Agent）：AIコーディング支援プログラム（Claude Code、Gemini CLI など）セッション（Session）：会話の単位、複数のセッションを並行して管理可能エージェントはエディタのサブプロセスとして実行され、標準入出力（stdin/stdout）を通じて通信を行います。agentclientprotocol.comACPとMCPの関係ACPの技術仕様において重要なのは、Model Context Protocol（MCP）との関係です。MCPは、LLMが外部サービスやローカルリソースにアクセスするためのプロトコルです。ACPは可能な限りMCPの型を再利用し、エディタが既存のMCPサーバー設定を持つ場合、その設定をエージェントに渡すことができます。agentclientprotocol.com{  "mcpServers": {    "filesystem": {      "command": "npx",      "args": ["-y", "@modelcontextprotocol/server-filesystem"],      "env": {        "ALLOWED_PATHS": "/path/to/project"      }    }  }}JSON-RPC の基本ACP は JSON-RPC 2.0 仕様に基づいており、以下の3種類のメッセージ形式が使われます。agentclientprotocol.comリクエスト：クライアントからエージェントへの要求{  "jsonrpc": "2.0",  "id": 1,  "method": "prompt",  "params": {    "sessionId": "session-123",    "prompt": [{"type": "text", "text": "Hello Agent!"}]  }}レスポンス：エージェントからクライアントへの応答{  "jsonrpc": "2.0",  "id": 1,  "result": {    "stopReason": "endTurn",    "meta": null  }}通知：レスポンスを必要としない一方向メッセージ{  "jsonrpc": "2.0",  "method": "session/notification",  "params": {    "sessionId": "session-123",    "update": {      "type": "agentMessageChunk",      "content": {"type": "text", "text": "Processing..."}    }  }}Rustで実装するACPの詳細解説それでは、実際のRustコードを通じてACPの動作原理を深く理解していきましょう。公式リポジトリの実装例（agent.rsとclient.rs）を詳しく解説します。agentclientprotocol.com実装の準備と実行まず、ACPの実装を実際に動かすための手順を確認しましょう：# リポジトリのクローンgit clone https://github.com/zed-industries/agent-client-protocolcd agent-client-protocol/rust# エージェントのビルドRUST_LOG=info cargo build --example agent# クライアントの実行（エージェントを自動起動）cargo run --example client -- ../target/debug/examples/agent# 実行時の対話例> Hello, Agent!| Agent: Client sent: Hello, Agent!> How can you help me with coding?| Agent: Client sent: How can you help me with coding!この実行により、以下の通信フローが発生します。初期化フェーズ: プロトコルバージョンのネゴシエーションセッション確立: 作業ディレクトリとMCPサーバー設定の共有メッセージループ: プロンプトの送信と応答のストリーミンググレースフルシャットダウン: プロセス終了時のリソースクリーンアップエージェント側の実装（agent.rs）基本構造とトレイト実装use std::cell::Cell;use agent_client_protocol::{    self as acp, AuthenticateResponse, Client, ExtNotification,     ExtRequest, ExtResponse, SessionNotification, SetSessionModeResponse,};use tokio::sync::{mpsc, oneshot};struct ExampleAgent {    session_update_tx: mpsc::UnboundedSender<(acp::SessionNotification, oneshot::Sender<()>)>,    next_session_id: Cell<u64>,}構造体の設計思想：session_update_tx：非同期チャネルの送信側で、セッション更新をバックグラウンドタスクに送信next_session_id：Cell<u64>による内部可変性パターンで、&selfの不変参照でも値を更新可能ACPトレイトの実装#[async_trait::async_trait(?Send)]impl acp::Agent for ExampleAgent {    async fn initialize(        &self,        arguments: acp::InitializeRequest,    ) -> Result<acp::InitializeResponse, acp::Error> {        log::info!("Received initialize request {arguments:?}");        Ok(acp::InitializeResponse {            protocol_version: acp::V1,            agent_capabilities: acp::AgentCapabilities::default(),            auth_methods: Vec::new(),            meta: None,        })    }重要なポイント：async_trait(?Send)：非Sendなfutureを許可し、LocalSet環境での実行を可能にプロトコルバージョンの明示的な宣言ケイパビリティ交換による機能のネゴシエーションセッション管理async fn new_session(    &self,    arguments: acp::NewSessionRequest,) -> Result<acp::NewSessionResponse, acp::Error> {    log::info!("Received new session request {arguments:?}");    let session_id = self.next_session_id.get();    self.next_session_id.set(session_id + 1);    Ok(acp::NewSessionResponse {        session_id: acp::SessionId(session_id.to_string().into()),        modes: None,        meta: None,    })}セッションの概念：各セッションは独立した会話コンテキストMCPサーバー設定の引き継ぎ作業ディレクトリの設定プロンプト処理とストリーミングasync fn prompt(    &self,    arguments: acp::PromptRequest,) -> Result<acp::PromptResponse, acp::Error> {    log::info!("Received prompt request {arguments:?}");        for content in ["Client sent: ".into()].into_iter().chain(arguments.prompt) {        let (tx, rx) = oneshot::channel();                // セッション更新の非同期送信        self.session_update_tx            .send((                SessionNotification {                    session_id: arguments.session_id.clone(),                    update: acp::SessionUpdate::AgentMessageChunk { content },                    meta: None,                },                tx,            ))            .map_err(|_| acp::Error::internal_error())?;                // バックプレッシャー制御        rx.await.map_err(|_| acp::Error::internal_error())?;    }        Ok(acp::PromptResponse {        stop_reason: acp::StopReason::EndTurn,        meta: None,    })}ストリーミング設計：チャンク単位でのメッセージ送信oneshot::channel()による同期制御バックプレッシャーによる流量制御メインループとタスク管理メインループは、非同期ランタイムの中核部分であり、実際にエージェントが起動される場所です。#[tokio::main(flavor = "current_thread")]async fn main() -> anyhow::Result<()> {    env_logger::init();  // RUST_LOG環境変数でログレベルを制御    let outgoing = tokio::io::stdout().compat_write();    let incoming = tokio::io::stdin().compat();    let local_set = tokio::task::LocalSet::new();    local_set        .run_until(async move {            let (tx, mut rx) = tokio::sync::mpsc::unbounded_channel();                        // エージェント接続の確立            let (conn, handle_io) = acp::AgentSideConnection::new(                ExampleAgent::new(tx),                 outgoing,                 incoming,                 |fut| {                    tokio::task::spawn_local(fut);                }            );                        // セッション通知処理タスク            tokio::task::spawn_local(async move {                while let Some((session_notification, tx)) = rx.recv().await {                    let result = conn.session_notification(session_notification).await;                    if let Err(e) = result {                        log::error!("{e}");                        break;                    }                    tx.send(()).ok();                }            });                        handle_io.await        })        .await}非同期ランタイムの設計：LocalSet：シングルスレッド実行環境（current_threadフレーバーと連携）spawn_local：非Sendタスクの実行チャネルによるタスク間通信RUST_LOG=info環境変数でログ出力を制御（デバッグ時はRUST_LOG=debug）クライアント側の実装（client.rs）プロセス管理とライフサイクルクライアントは、エージェントをサブプロセスとして起動し管理します。実行時はコマンドライン引数でエージェントのパスを指定します：# 実行例：ビルド済みのエージェントを指定cargo run --example client -- target/debug/examples/agent#[tokio::main(flavor = "current_thread")]async fn main() -> anyhow::Result<()> {    let command = std::env::args().collect::<Vec<_>>();    let (outgoing, incoming, child) = match command.as_slice() {        [_, program, args @ ..] => {            let mut child = tokio::process::Command::new(program)                .args(args.iter())                .stdin(std::process::Stdio::piped())                .stdout(std::process::Stdio::piped())                .kill_on_drop(true)  // 自動クリーンアップ                .spawn()?;                        (                child.stdin.take().unwrap().compat_write(),                child.stdout.take().unwrap().compat(),                child,            )        }        _ => bail!("Usage: client AGENT_PROGRAM AGENT_ARG..."),    };プロセス管理のベストプラクティス：kill_on_drop(true)：親プロセス終了時の自動クリーンアップ（孤児プロセスを防ぐ）ストリーム所有権の明示的な管理（take()メソッド）エラー時のグレースフルシャットダウンエージェントプログラムへの引数の柔軟な受け渡しプロトコル初期化// 接続の確立let (conn, handle_io) = acp::ClientSideConnection::new(    ExampleClient {},     outgoing,     incoming,     |fut| {        tokio::task::spawn_local(fut);    });// バックグラウンドI/O処理tokio::task::spawn_local(handle_io);// 初期化ハンドシェイクconn.initialize(acp::InitializeRequest {    protocol_version: acp::V1,    client_capabilities: acp::ClientCapabilities::default(),    meta: None,}).await?;// セッション作成let response = conn    .new_session(acp::NewSessionRequest {        mcp_servers: Vec::new(),  // MCPサーバー設定        cwd: std::env::current_dir()?,        meta: None,    })    .await?;対話的REPLの実装Rustylineを使用した対話的インターフェースにより、ユーザーはエージェントと直接対話できます：// Rustylineによる対話インターフェースlet mut rl = rustyline::DefaultEditor::new()?;while let Ok(line) = rl.readline("> ") {    let result = conn        .prompt(acp::PromptRequest {            session_id: response.session_id.clone(),            prompt: vec![line.into()],            meta: None,        })        .await;        if let Err(e) = result {        log::error!("{e}");    }}REPLの動作例：> Hello, Agent!| Agent: Client sent: Hello, Agent!> What's the weather like?| Agent: Client sent: What's the weather like?> exitRustylineの利点：履歴管理（上下矢印キーで過去の入力を参照）カーソル移動とテキスト編集機能Ctrl+C/Ctrl+Dによる適切な終了処理将来的な自動補完機能の追加が可能セッション通知の処理#[async_trait::async_trait(?Send)]impl acp::Client for ExampleClient {    async fn session_notification(        &self,        args: acp::SessionNotification,    ) -> anyhow::Result<(), acp::Error> {        match args.update {            acp::SessionUpdate::AgentMessageChunk { content } => {                let text = match content {                    acp::ContentBlock::Text(text_content) => text_content.text,                    acp::ContentBlock::Image(_) => "<image>".into(),                    acp::ContentBlock::Audio(_) => "<audio>".into(),                    acp::ContentBlock::ResourceLink(resource_link) => resource_link.uri,                    acp::ContentBlock::Resource(_) => "<resource>".into(),                };                println!("| Agent: {text}");            }            acp::SessionUpdate::ToolCall(tool_call) => {                println!("| Tool call: {}", tool_call.name);            }            acp::SessionUpdate::Plan(plan) => {                println!("| Plan: {}", plan.description);            }            _ => {}        }        Ok(())    }エラーハンドリングとプロトコルの堅牢性タイムアウトとリトライの実装use tokio::time::{timeout, Duration};async fn prompt_with_timeout(    conn: &ClientSideConnection,    request: PromptRequest,    timeout_secs: u64,) -> Result<PromptResponse, Error> {    match timeout(        Duration::from_secs(timeout_secs),        conn.prompt(request)    ).await {        Ok(Ok(response)) => Ok(response),        Ok(Err(e)) => {            log::error!("Prompt error: {}", e);            Err(e)        }        Err(_) => {            log::error!("Prompt timeout after {} seconds", timeout_secs);            Err(Error::request_timeout())        }    }}エクスポネンシャルバックオフasync fn reconnect_with_backoff(    max_retries: u32,) -> Result<Connection, Error> {    let mut delay = Duration::from_secs(1);        for attempt in 1..=max_retries {        match establish_connection().await {            Ok(conn) => {                log::info!("Connected on attempt {}", attempt);                return Ok(conn);            }            Err(e) if attempt < max_retries => {                log::warn!("Attempt {} failed: {}", attempt, e);                tokio::time::sleep(delay).await;                delay *= 2;  // エクスポネンシャルバックオフ            }            Err(e) => return Err(e),        }    }        Err(Error::max_retries_exceeded())}実践的な統合例Claude Code ACPの設定Claude Code ACP は、AnthropicのClaude AIをACPプロトコル経由で利用可能にする実装です。github.com{  "agent_servers": {    "Claude Code": {      "command": "npx",      "args": ["@zed-industries/claude-code-acp"],      "env": {        "ANTHROPIC_API_KEY": "your-api-key",        "ACP_PERMISSION_MODE": "acceptEdits"      }    }  }}Avante.nvimの設定Avante.nvim は、NeovimでACPを利用するための実装です。github.com{  "yetone/avante.nvim",  event = "VeryLazy",  build = "make",  opts = {    provider = "claude",    mode = "agentic",    acp_providers = {      ["claude-code"] = {        command = "npx",        args = { "@zed-industries/claude-code-acp" },        env = { ANTHROPIC_API_KEY = os.getenv("ANTHROPIC_API_KEY") }      }    }  }}ccswarm での実装筆者が開発している ccswarm プロジェクトでは、当初は独自の仮想ターミナル実装を使用していましたが、ACPの登場を機に、より標準化されたアプローチへの移行を決定しました。github.comセキュリティに関する考慮事項ACPを使用する際には、以下の点に注意が必要です。ACPのセキュリティリスク作っていて思ったのですが、ACPはエージェントにローカル環境への強いアクセス権を付与するので、本質的にセキュリティ上の懸念があります：サードパーティエージェントのリスク: 信頼できない「野良エージェント」をインストールすると、マルウェアや情報漏洩のリスクが高まります権限の過剰付与: エージェントが必要以上の権限を持つと、システムリソースへの不正アクセスの可能性がありますデータ漏洩のリスク: ローカルファイルやクレデンシャルなどの機密情報が、エージェントを通じて外部に漏洩する可能性がありますプロンプトインジェクション攻撃: 悪意あるプロンプトを通じて、エージェントに予期しない操作を実行させるリスクがあります安全なACP利用のための対策信頼できるソースからのみエージェントをインストール: 公式リポジトリや信頼できる開発者からのエージェントのみを使用最小権限の原則を適用: エージェントには必要最小限の権限のみを付与サンドボックス環境での実行: 可能であれば、エージェントを隔離された環境で実行監査ログの有効化: エージェントを通じて実行されたすべてのコマンドや操作を記録機密情報のフィルタリング: APIキーやパスワードなどの機密情報を検出・削除するメカニズムを実装定期的なセキュリティレビュー: エージェントの設定やコードを定期的にレビュー確実なテストの実行: 本番環境に導入する前に、テスト環境で動作を徹底的に検証ACPのメリットと今後の展望開発者にもたらす価値ベンダーロックインからの解放: どのACP対応エディタでも、どのACP対応エージェントでも使用可能開発効率の向上: 統一されたプロトコルにより、新しいAIエージェントの導入が簡単にエコシステムの成長: 標準化により、開発者はそれぞれの得意分野に集中可能実践的な活用シナリオ大規模リファクタリング: プロジェクト全体の構造改善バグ修正フロー: エラー解析から修正まで一貫した支援コードレビュー自動化: セキュリティや品質の包括的チェックプロジェクト横断的な分析: アーキテクチャレベルの改善提案おわりにAgent Client Protocolは、AIコーディング支援ツールの統合における新たな標準として、着実に開発者コミュニティで採用が進んでいます。MCPが大きな話題を集めた一方で、ACPはそこまで注目を浴びていないかもしれません。しかし、エディタ開発者やコーディングエージェントを実装したい開発者にとって、ACPは極めて実用的で学ぶ価値の高い技術です。本記事で詳しく解説したRustの実装例は、ACPの設計思想を理解し、独自のエージェントを開発するための出発点となるでしょう。特に注目すべきは、Rustの所有権システムとACPの非同期通信モデルが見事に調和している点です。LocalSetによる非Sendなfutureの処理、mpscとoneshotチャネルを組み合わせた確実な通信、kill_on_dropによる安全なプロセス管理など、これらの技術的選択は、堅牢で効率的なACP実装の基礎となります。ACPの魅力は、JSON-RPCベースのシンプルなプロトコル設計により、数百行のコードで基本的なエージェントを実装できる敷居の低さにあります。一度ACPに対応すれば、Zed、Neovim、その他のACP対応エディタですぐに利用可能になり、独自のコーディングアシスタントやドメイン特化型エージェントの開発も容易になります。エディタとAIエージェントの統合は今後も加速することが予想され、ACPの知識は長期的な資産となるでしょう。一般的な開発者にとって重要なのは、ACPが派手さはないものの、日々のコーディング作業を着実に改善する実用的な基盤技術であるという点です。MCPのような革新的な印象はないかもしれませんが、LSPがそうであったように、気がつけば開発環境に不可欠な存在となっているでしょう。特に、独自のエディタプラグインやAIコーディングツールを開発したいと考えている方は、ぜひACPの仕様を学び、実装してみることをお勧めします。この標準化されたプロトコルは、あなたのツールを幅広いエコシステムに接続する架け橋となるはずです。参考リソースAgent Client Protocol GitHubリポジトリACP 公式ドキュメントClaude Code ACP実装Avante.nvim プロジェクトModel Context ProtocolJSON-RPC 2.0 仕様zed.dev]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[claude codeにtesseract書かせてみた]]></title>
            <link>https://zenn.dev/akasan/articles/8ac71d6cc3057a</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/8ac71d6cc3057a</guid>
            <pubDate>Sun, 21 Sep 2025 11:09:13 GMT</pubDate>
            <content:encoded><![CDATA[今回はclaude codeに作らせたシリーズの続編です。前回は3次元のフラクタル図形を書かせてみましたが、今回はtesseractを書かせてみました。https://zenn.dev/akasan/articles/f90c2940cf1ef3 tesseractとは？Wikipediaによると、正八胞体（せいはちほうたい、または四次元超立方体、英語: 8-cell、オクタコロン〈英: octachoron〉、テッセラクト〈英: tesseract、テセラクトとも〉）とは、四次元正多胞体の一種で8個の立方体からなる、四次元の超立方体である。とのことです。自分の認識では4...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[モジュールを意識したTerraform構成でColabのテンプレートを作成してみた]]></title>
            <link>https://zenn.dev/akasan/articles/9c48ed7e2457a6</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/9c48ed7e2457a6</guid>
            <pubDate>Sat, 20 Sep 2025 09:15:40 GMT</pubDate>
            <content:encoded><![CDATA[今回は、昨日公開したColab Enterpriseのテンプレート作成のTerraformをモジュールを意識した構成で実装してみます。今までの記事ではルートディレクトリだけでmain.tfやvariables.tfを管理していましたが、実際に利用するときはモジュールを意識した構成が必要になるので、今回からその構成を意識して実装します。https://zenn.dev/akasan/articles/2966eb1a9f9a38 ディレクトリ構成今回は以下の構成でディレクトリを編成しました。main.tfvariables.tfmodules/  colab-templat...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[クラウド環境におけるシークレットの扱い]]></title>
            <link>https://blog.masasuzu.net/entry/2025/09/19/203626</link>
            <guid isPermaLink="false">https://blog.masasuzu.net/entry/2025/09/19/203626</guid>
            <pubDate>Fri, 19 Sep 2025 11:36:26 GMT</pubDate>
            <content:encoded><![CDATA[この内容は、社内のエンジニア勉強会で話した内容です。 speakerdeck.comみなさん。プロダクション環境のシークレット情報をどう扱っていますか?クラウドネイティブなアプリケーション開発において、DBのパスワードや外部APIキーといったシークレットの管理は、セキュリティを確保する上で避けては通れない課題です。この記事では、アプリケーションとインフラそれぞれの視点から、クラウド環境におけるシークレット管理のアンチパターンとベストプラクティスを探っていきます。ここで言うシークレットとはDBのパスワードやAPIキーなどの秘匿すべき情報のことを指します。アプリケーション側の視点まずは、アプリケーションがどのようにシークレットを扱うべきかを見ていきましょう。管理のアンチパターン最初に管理方法のアンチパターンとしては以下のものがありますソースコードに直接記述設定ファイルに平文で記述環境変数に平文で記述(Dockerfileや.envファイルでgit管理するなど)base64エンコードして保存ソースコードに記述すれば、すべての環境で同じ値しか使えず柔軟性がありません。設定ファイルや環境変数に平文で記述し、それをGitで管理してしまうと、何かのミスでリポジトリが流出した際にシークレットも漏れてしまいます。また、隠しているつもりでBase64エンコードするのも同様に危険です。Base64は暗号化ではなく、誰でも簡単に元の文字列に戻せるため、平文で保存しているのと大差ありません。KMSによる暗号化の検討次に考えられるのが、暗号鍵を使った暗号化です。AWSのKMSやGoogle CloudのCloud KMSといった鍵管理サービスを利用する方法が考えられます。フローとしては以下のようになりますでしょうかアプリケーション起動時にKMSのから鍵を取得取得した鍵を利用して暗号化されたシークレットを復号平文のシークレット情報をアプリで利用する一見これで良さそうですが、復号処理をアプリケーションの責務にすると、コードが複雑になるだけでなく、KMSの復号権限をアプリケーション自体に付与する必要があり、管理の懸念点が増えてしまいます。クラウド側のシークレットストアの利用そこで推奨されるのが、クラウドが提供するシークレット管理の仕組みを利用することです。AWSAWS Secrets ManagerAWS Systems Manager Parameter Store(SecureString)Google CloudSecret Managerこれらのサービスは、ECS FargateやCloud Runなどのコンテナ実行環境と統合されています。コンテナの起動時に、これらのストアに保存されたシークレットを、自動的に環境変数やファイルとしてマウントしてくれるのです。これによりアプリケーション側では、シークレットがどこで管理されているかを意識することなく、従来通り環境変数やファイルから値を読み込むだけで済むようになり、責務をシンプルに保つことができます。インフラ側の視点さて、アプリケーションの課題は解決しました。次に、インフラ側で、そのシークレットストアをどう管理するかという課題に移りましょう。取れる手段としては主に以下ものが考えられます。手動でコンソールから設定シークレットの値を平文でIaC管理(tfvarsファイルをgit管理から外す)シークレットの値を暗号化してIaCで管理シークレットストアをIaCで管理、値は手動設定まず手動で管理ですが、これはこれでありだと思ってます。ただし、扱うシークレットの数が増えてきたときに作業が煩雑であったり、手作業がゆえに起こるリソースタグなどの付け間違いなどのミスが発生しうるので、規模が大きくなると現実的ではありません。2つ目ですが、シークレットの値だけあつかるtfvarsファイルをgitignoreしてあげることでレポジトリが漏れてもシークレットの値が漏れないことになります。が、うっかりシークレットの値を人為的なミスでコミットしうるので完全に安全とはいいにくいです。3つ目ですが、これはsops providerを利用するパターンです。これを使うことでKMSキーを利用して暗号/復号がterraformとシームレスに統合できます。一見これで良さそうですが、2点課題があります。KMSリソースを余計に管理なくてはならないStateには平文で保存される前者は必要経費としていいとして、後者は課題となります。Terraformにおいてはstateを見る権限がある人にはシークレットも見れてしまうという懸念があります。シークレットのリソースと値を分離するこの方法の利点は、IaCでシークレット リソースが存在することは管理しつつ、その実際の値はGitの管理下から完全に分離できる点です。初回適用後にコンソールから実際のシークレット値を設定すれば、それ以降 terraform apply を実行しても値がダミー値で上書きされることはありません。これにより、コードレビューなどで誤ってシークレットが漏洩するリスクを原理的に防ぐことができ、非常にバランスの取れた管理方法と言えます。以下サンプルコードです。resource "aws_ssm_parameter" "db_password" {  type     = "SecureString"  name     = "/test/db_password"  value    =  "Dummy"  lifecycle {    ignore_changes = [value]  }}まとめ現時点でのクラウドにおけるシークレット管理のベストプラクティスは、以下のようにまとめることができるでしょう。アプリケーションクラウドのシークレットストア(Secrets Managerなど)と実行環境(ECS, Cloud Runなど)の統合機能を使い、環境変数またはファイルとしてシークレットを読み込む。インフラ(IaC)クラウドのシークレットストアのリソース自体はTerraformで管理する。実際のシークレットの値は ignore_changes を活用して手動で設定し、Gitの管理から分離する。もちろん要件によって取りうる手段は変わるとは思います。他になにか良い方法をご存知でしたら教えて下さい。それでは良いシークレットライフを!関連ページblog.masasuzu.net]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Colab EnterpriseのランタイムテンプレートをTerraformで作る方法について]]></title>
            <link>https://zenn.dev/akasan/articles/2966eb1a9f9a38</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/2966eb1a9f9a38</guid>
            <pubDate>Fri, 19 Sep 2025 04:12:08 GMT</pubDate>
            <content:encoded><![CDATA[今回はVertex AIのColab EnterpriseのランタイムテンプレートをTerraformで記述してみました。以前コンソールからランタイムテンプレートを作ったことはありましたが、今回はその設定をTerraformで再現してみようと思います。以前の該当記事は以下になるので、ぜひ合わせてご覧ください。https://zenn.dev/akasan/articles/454f57beb383e9Google CloudでTerraformを試してみた系は以下のスクラップにまとめていますので合わせてご覧ください！https://zenn.dev/akasan/scraps/c6...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2025-09-19 クラウドにおけるシークレット管理]]></title>
            <link>https://speakerdeck.com/masasuzu/2025-09-19-kuraudoniokerusikuretutoguan-li</link>
            <guid isPermaLink="false">https://speakerdeck.com/masasuzu/2025-09-19-kuraudoniokerusikuretutoguan-li</guid>
            <pubDate>Fri, 19 Sep 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[スリーシェイク社内のエンジニア勉強会で発表した資料クラウドにおいてプロダクション環境でのシークレットの扱い方についてアプリケーションおよびインフラ側でどう管理していくのが望ましいかを詳解]]></content:encoded>
        </item>
    </channel>
</rss>