<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Thu, 15 Aug 2024 18:34:30 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[WindowsでGitをセットアップするには]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/08/15/235944</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/08/15/235944</guid>
            <pubDate>Thu, 15 Aug 2024 14:59:44 GMT</pubDate>
            <content:encoded><![CDATA[私は仕事もプライベートもMacですが、仕事にてWindowsでGitを使うにはどうすればいいという相談を受けました。www.sourcetreeapp.comSourcetreeを推しときましたが、他には、Git for Windows という手もありますね。gitforwindows.org有料だけど、forkがいいという噂。git-fork.com自分の環境だけでなく、他の人の環境の相談にも乗れるようにキャッチアップ頑張ります！]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[LLMを利用して、APIを自動でテストするツールを作ってみる]]></title>
            <link>https://sreake.com/blog/llm-api-test-automation/</link>
            <guid>https://sreake.com/blog/llm-api-test-automation/</guid>
            <pubDate>Wed, 14 Aug 2024 22:24:42 GMT</pubDate>
            <content:encoded><![CDATA[1. はじめに はじめまして、Sreake事業部の井上 秀一です。私はSreake事業部にて、SREや生成AIに関するResearch & Developmentを行っています。本記事では、LLMとテストツールを […]The post LLMを利用して、APIを自動でテストするツールを作ってみる first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google Cloud認定試験のリモート受験を風呂場で]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/08/14/235622</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/08/14/235622</guid>
            <pubDate>Wed, 14 Aug 2024 14:56:22 GMT</pubDate>
            <content:encoded><![CDATA[shu-kob.hateblo.jp先日、Google Cloud Professional Cloud Architectに合格したという記事を書きましたが、初めてリモートで受験しました。私はオンサイトのテストセンター派ですが、連休初日にGoogle Cloud Professional Cloud Architectに合格して景気付けしようと思ったものの、この日昼は予定があり、夜はテストセンターがやっていないためです。リモートは当日に申し込んでも受験できます。事前準備・専用のブラウザのインストール以上2点を済ませておけばOKです。風呂場で受験wing-degital.hatenablog.com自室は散らかっているので、上記記事を参考に、風呂場で受験。風呂ふたの上にPCを置き、バスタブの中に直接座りました。上記記事はざっとしか読んでなかったので、クッション用意すれば良かったです。（後で足が痺れた。）10分前からログインできるのですが、確かテストに入る前のチェックリストに答えました。スマホのカメラと連携して、室内をくまなく撮影したり、ID(私は運転免許証を選択)を撮影したりしました。その後、待機でかなり待ちました。夏なので、汗がダラダラ。お風呂に冷房なんてないわけで辛かった。。時間は経っていき、大丈夫かな？と思っていましたが、やっとチャットオペレーターとのチャットが開始PCのカメラで室内を撮影したり背中にあるものは何だ？と聞かれたり、（お風呂のコントローラーです）質問に答えていくと大丈夫でした。途中言語モードを日本語にしていたのですが、これが後で良くなかった。いざ、試験。言語モードを日本語に切り替えると、何問目かがわからなくなっていたのと、問題文が途中で途切れていたり、解答文中の英語も日本語に訳されてわからなくなったりして、大変でした。途中で言語を英語に切り替えると悪影響があるかもしれないから、最後まで解答はすることにもうすぐ全問解答かと思いきや、途中でネットワークが途切れました。。。部屋のWi-Fiルータから風呂までは電波が弱かったようです。風呂でPC使ったことないから気づかなかった。3分以上途切れると、試験終了となってしまうようです。試験終了になったら、解答は保存されていて、その分で採点される模様。それで落ちた場合、再受験の制限（初回で落ちたら14日間、2回目で落ちたら60日間、3回目で落ちたら365日間再受験できない）が適用される模様です。幸い、復旧でき、解答を続けられました。最後まで解答したら、言語を英語に切り替えました。日本語の試験なので、問題文と解答文は日本語です。何問目かと問題文、解答文がちゃんと表示されるようになり、見直し。試験を終了しました。Google Cloud認定試験終了後の15問アンケートは任意で、答えるようにしているのですが、14問目くらいで再びネットワークエラー。幸い、復旧。アンケートを全部答えると、試験結果は「Pass」（合格）このとき、「よっしゃー」と囁いてしまって大丈夫かな？と思いましたが、大丈夫で、後日認定通知が来ました。試験自体は終えてますからね。なお、試験中声を出すと、試験終了となり不合格となります。私は試験のときは家で一人だったのですが、家で家族がいる場合は、話しかけたりされないように注意してください。リモートのお風呂される方は参考にしてください。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Geminiマルチモーダルプログラミングハンズオン]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/08/13/193929</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/08/13/193929</guid>
            <pubDate>Tue, 13 Aug 2024 10:39:29 GMT</pubDate>
            <content:encoded><![CDATA[genai-users.connpass.comこの記事は上記ハンズオン勉強会の資料です。準備設定秘密鍵がダウンロードされます。git clone https://github.com/shu-kob/gemini-multimodalcd gemini-multimodalダウンロードした秘密鍵を gemini-multimodal/ 配下に配置し、環境変数の設定ファイルに記載（ ここでは .zprofile ）export GOOGLE_APPLICATION_CREDENTIALS="/Users/username/programing/gemini-multimodal/projectid-abcdefg.json"source ~/.zprofilecloud.google.compip install --upgrade pippip install vertexai音声解析cloud.google.comGoogle Cloud Storageに音声をアップロードします。aicross.co.jpここでは、コールセンターを模擬した音声を自分で収録したファイルを使います。project_id と audio_file_uri を変更します。python3 audio.pyTraceback (most recent call last):  File "/Users/kobuchishu/programing/gemini-multimodal/audio.py", line 1, in <module>    import vertexaiModuleNotFoundError: No module named 'vertexai'というエラーが出るときは下記を参照qiita.com公式サイトからインストールしていたらなるっぽいです。以下をお試しください。zenn.dev画像・動画解析cloud.google.com画像解析Google Cloud Storageに画像をアップロードします。project_id と image_file_uri を変更します。python3 image.py動画解析pixabay.comフリー動画サイトなどから動画を収集します。Google Cloud Storageに動画をアップロードします。project_id と video_file_uri を変更します。python3 video.py今後のイベント情報langchain.connpass.com↑小渕登壇しますオンサイトのみで一般参加は2名オーバーこの日天気悪いかも気をつけてお越しください※【追記】台風接近に伴い、オンライン開催への切り替えまたは延期してオンサイト開催にするとのことです。3-shake.connpass.com↑小渕は運営やっております。SREのイベントですが、LLMのオブザーバビリティという話があります！無料懇親会付きです！pages.sreake.com↑小渕登壇します。無料懇親会付きです！]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Docker Build Check について検証をしてみた]]></title>
            <link>https://sreake.com/blog/docker-build-check/</link>
            <guid>https://sreake.com/blog/docker-build-check/</guid>
            <pubDate>Tue, 13 Aug 2024 01:00:00 GMT</pubDate>
            <content:encoded><![CDATA[はじめに こんにちは、Sreake 事業部 佐藤慧太@(SatohJohn) です。 以下の docker build check という機能について、検証をし、Google Cloud の Cloud Build に組 […]The post Docker Build Check について検証をしてみた first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google Cloud Professional Cloud Architectに合格]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/08/12/224136</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/08/12/224136</guid>
            <pubDate>Mon, 12 Aug 2024 13:41:36 GMT</pubDate>
            <content:encoded><![CDATA[お盆休みいかがお過ごしでしょうか？8/10, 11, 12と3連休だった方は13からのお仕事頑張ってください。8/13以降も休みの方は引き続き休みをお楽しみください。さて、8月10日に受けたGoogle Cloud Certified - Professional Cloud Architectに合格しました！shu-kob.hateblo.jp以前合格したGoogle Cloud Certified - Professional Cloud DevOps Engineerに続き、Google Cloudプロフェッショナル2つ目です！実はDevOpsもCloud Architectもそれぞれ初回で落ちて2回目で受かっています。初回は勉強、理解不足でしたね。なお、私のGoogle Cloud経験は1年未満なので、実戦が少ない分、勉強を頑張らねばなりません。Udemyの以下の模擬試験がオススメです！click.linksynergy.comGoogle Cloudをお使いの皆さんも認定試験にチャレンジしてみてください！]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[テレビでGeminiのCMをよく見るようになりました]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/08/11/235818</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/08/11/235818</guid>
            <pubDate>Sun, 11 Aug 2024 14:58:18 GMT</pubDate>
            <content:encoded><![CDATA[youtu.beいろんなモデルがあり、OpenAIのChatGPTが知名度のある中、最近テレビでGeminiのCMをよく見かけるようになりました。GeminiはGoogleがやってるだけあって、GoogleのCMとして出しやすいですよね。個人的にもGemini派なので、ユーザが増えて、モデルがどんどん進化していってくれるといいと思いました。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Toilを無くせるのはSREだけではない。生成AIもToilを無くすための道具]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/08/10/211541</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/08/10/211541</guid>
            <pubDate>Sat, 10 Aug 2024 12:15:41 GMT</pubDate>
            <content:encoded><![CDATA[こんばんは！今日2024年8月10日(土)からお盆休みの方も多いのではないでしょうか？お休みの方はしっかりリフレッシュしてください。さて、このブログのタイトルは「Toilを無くして徒然なるままに日暮し硯に向かひたい」兼好法師の『徒然草』「徒然なるままに日暮し 硯に向かいて」から引用しています。「Toilを無くす」というとSREの言葉であり、スリーシェイクの社員として意識しているのですが、私は生成AIアプリケーション開発エンジニアであり、生成AIも「Toilを無くす」ものだと思っています。生成AIアプリケーションを使わなくても、WebブラウザからGeminiやChatGPT生成AIを使って、エンジニアでなくても誰でも気軽に生成AIを使うことができます。生成AIでみんなのToilがなくなって、「特に何も予定もなく、ただ何となく一日中、書斎で本を読んだり文章を書いたりして過ごしている」ような世界になればと思っていますw本を読んだり、文章を書いたりだけでなく、遊びでもいいでしょうし、クリエイティブな活動ができれば何でもいいと思います。そんな楽しい世界を創っていけたらと思います！！今回はポエム会にしてみました（笑）]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google CloudのApp Engine Cron サービスとは]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/08/09/235611</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/08/09/235611</guid>
            <pubDate>Fri, 09 Aug 2024 14:56:11 GMT</pubDate>
            <content:encoded><![CDATA[Google Cloudの勉強をしている中で、App Engine Cron サービスが出てきたので、記しておこうと思います。App Engine Cron サービスとは？Google Cloud PlatformのApp Engineで利用できる、定期的にタスクを実行するための機能です。Cronと聞いてピンとくる方もいるかもしれませんが、あのCronと似たような働きをします。具体的にどんなことができるの？定期的なデータ更新: データベースのデータを毎日更新したり、キャッシュをクリアしたりといった作業を自動化できます。バッチ処理: 大量のデータを一括処理するようなバッチ処理をスケジュールできます。レポート作成: 定期的にレポートを作成し、メールで送信したり、ストレージに保存したりできます。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google Cloud Next Tokyo’24 勝手にRecap コンテナ最新アップデート紹介 ~ GKE 編 ~]]></title>
            <link>https://zenn.dev/yokoo_an209/articles/google-next-recap-gke</link>
            <guid>https://zenn.dev/yokoo_an209/articles/google-next-recap-gke</guid>
            <pubDate>Fri, 09 Aug 2024 01:18:24 GMT</pubDate>
            <content:encoded><![CDATA[これはなに？先日、Google Cloud Next Tokyo’24が開催されました。Google Cloud Next Tokyo ’24 の セッションを（勝手に）Recap したものになります基調講演のアーカイブも公開されているので、見逃した方はぜひご覧くださいhttps://cloudonair.withgoogle.com/events/next-tokyo-24気になる箇所だけ見たい方は、目次から飛んでください！ セッション進化するコンテナ環境: Google Kubernetes Engine と Cloud Run の最新アップデートと使い所を徹底解...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google Cloud Next Tokyo’24 勝手にRecap コンテナ最新アップデート紹介 ~ Cloud Run 編 ~]]></title>
            <link>https://zenn.dev/yokoo_an209/articles/google-next-recap-cloud-run</link>
            <guid>https://zenn.dev/yokoo_an209/articles/google-next-recap-cloud-run</guid>
            <pubDate>Fri, 09 Aug 2024 01:18:24 GMT</pubDate>
            <content:encoded><![CDATA[これはなに？先日、Google Cloud Next Tokyo’24が開催されました。Google Cloud Next Tokyo ’24 の セッションを（勝手に）Recap したものになります前回の GKE 編に引き続き、今回は Cloud Runについての最新アップデートのご紹介です！https://zenn.dev/yokoo_an209/articles/google-next-recap-gke セッション進化するコンテナ環境: Google Kubernetes Engine と Cloud Run の最新アップデートと使い所を徹底解説https:/...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google CloudのPersistent Disk SSDやMemcacheについて]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/08/08/224333</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/08/08/224333</guid>
            <pubDate>Thu, 08 Aug 2024 13:43:33 GMT</pubDate>
            <content:encoded><![CDATA[Google Cloudの勉強をしている中で、Persistent Disk SSDやMemcacheが出てきたので、これらの話題を。Persistent Disk SSDとは？Google Cloud Platform（GCP）のPersistent Disk SSDは、仮想マシン（VM）インスタンスに持続的なブロックストレージを提供するサービスです。SSD（Solid State Drive）を採用しているため、従来のHDDと比較して高速なI/O処理が可能です。その分高価です。Google CloudのMemcacheとは？Google CloudのMemcacheは、キーバリュー形式のデータを一時的に保存するための高速なインメモリデータストアです。メモリ内キャッシュのMemcacheは高速なRead/Writeが可能です。普段使わないマネージドサービスですが、しっかり勉強しようと思います。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SRE支援の効果的なアプローチについて(SRE NEXT 2024登壇のRecap)]]></title>
            <link>https://zenn.dev/kojake_300/articles/b977011a04fce4</link>
            <guid>https://zenn.dev/kojake_300/articles/b977011a04fce4</guid>
            <pubDate>Thu, 08 Aug 2024 09:18:01 GMT</pubDate>
            <content:encoded><![CDATA[この記事は、SRE NEXT 2024で、株式会社スリーシェイクのスポンサーセッションとして登壇した「内製化を見据えた効果的なSRE支援のアプローチ」をセルフでRecapしたものになります。 はじめに株式会社スリーシェイクのSreake事業部に所属しています。2024年8月3日、4日に開催された SRE NEXT 2024 に「内製化を見据えた効果的なSRE支援のアプローチ」という題で登壇しました。20分の枠なのに60枚弱のスライドを作成するという暴挙に出てしまい、端折りながらの説明となってしまったため、Recapとして登壇内容を解説します。 想定読者本登壇資料は、SRE...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[オブザーバビリティ・エンジニアリング輪読会 第6章「イベントをトレースにつなぐ」]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/08/07/235951</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/08/07/235951</guid>
            <pubDate>Wed, 07 Aug 2024 14:59:51 GMT</pubDate>
            <content:encoded><![CDATA[スリーシェイクでは、毎週輪読会をやっているのですが、 今使用している書籍は「オブザーバビリティ・エンジニアリング」です。オブザーバビリティ・エンジニアリング作者:Charity Majors,Liz Fong-Jones,George Mirandaオーム社Amazonshu-kob.hateblo.jp第5章の話をしましたが、本日は第6章「イベントをトレースにつなぐ」を担当しました。スカラー値だけのメトリクスではなく、構造化データでリクエストのイベントがわかるのは便利ですし、アプリケーションエンジニアとしても、しっかりオブザーバビリティを使っていきたいと思いました。この本の最初の方は抽象的な話が多かったですが、次第に具体的な話が入ってきて、頭に入ってきやすくなりました。しっかり読んで実力をつけようと思います。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[サイト信頼性エンジニア（SRE）として、インシデント時に迅速に初期対応する]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/08/06/235936</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/08/06/235936</guid>
            <pubDate>Tue, 06 Aug 2024 14:59:36 GMT</pubDate>
            <content:encoded><![CDATA[Cloud MonitoringワークスペースでGoogle Kubernetes Engine（GKE）クラスターを監視しているとします。サイト信頼性エンジニア（SRE）として、インシデントが発生した際に、迅速にトリアージするには、Cloud Monitoringワークスペースの定義済みダッシュボードをナビゲートし、メトリクスを追加してアラートポリシーを作成するとよいでしょう。Cloud MonitoringGoogle Cloudのサービスの一つで、まるで車の運転席にあるダッシュボードのように、システムの状態をリアルタイムで確認できる機能です。GKEクラスターのCPUの使用率、メモリの使用量、ネットワークの通信量など、様々な情報を数値やグラフで表示してくれます。GKEクラスターGoogle Kubernetes Engineの略で、コンテナと呼ばれる小さなプログラムをたくさん集めて動かすためのプラットフォームです。ウェブサービスやモバイルアプリなど、様々なサービスを動かすために使われています。インシデントを迅速にトリアージするシステムに何か問題が発生したときに、何が原因で、どの程度の影響があるのかを素早く判断し、対応することです。例えば、ウェブサイトが急に表示されなくなった場合、何が原因で表示されないのかを突き止め、復旧作業を進めます。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google CloudでCloud VPNのログイベントを1年間など長期間保存する場合]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/08/05/231340</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/08/05/231340</guid>
            <pubDate>Mon, 05 Aug 2024 14:13:40 GMT</pubDate>
            <content:encoded><![CDATA[Google CloudでCloud VPNのログイベントを1年間など保存する場合、Cloud Loggingでフィルタを設定し、保存したいログのエクスポート先としてCloud Storageバケットを設定します。Cloud Loggingは、Google Cloudのログ管理サービスで、アプリケーションやサービスのログデータを一元的に管理し、分析することができるマネージドサービスです。Cloud Loggingのコンソール画面Cloud Logging の便利な機能特定のログだけを抽出: 例えば、Cloud VPN というサービスのログだけを抜き出して詳しく調べることができます。まるで、図書館で特定のテーマの本だけを探すようなイメージです。ログを安全に保管: 重要なログは、Cloud Storage という、とても安全な倉庫に保存できます。この倉庫は、地震が来ても壊れにくく、大切なデータを長く保管しておくのにぴったりです。なぜ Cloud Logging が便利なのか？問題解決のスピードアップ: システムに問題が発生した時、Cloud Loggingでログを詳しく調べることで、原因を素早く特定し、解決することができます。セキュリティ強化: ログを分析することで、不正アクセスやシステムへの攻撃などを早期に発見することができます。システムの最適化: システムのパフォーマンスを分析し、より効率的に運用することができます。まとめCloud Loggingは、Google Cloudを利用する上で欠かせないツールです。ログを有効活用することで、システムの安定性向上や、より良いサービスの提供に繋がります。もう少し専門的な言葉で説明すると:Cloud Loggingは、Google Cloudのリソースから生成されるログを収集、保管、検索、分析するためのマネージドサービスです。ログエントリをフィルタリングし、特定のログを抽出することで、オペレーションチームは必要な情報に迅速にアクセスできます。また、Cloud Storageとの統合により、長期的なログ保存を実現し、監査や分析に役立てることができます。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[日本生成AIユーザ会 Geminiマルチモーダルプログラミング（ハンズオン）を2024年8月13日(火)20時から実施]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/08/04/225636</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/08/04/225636</guid>
            <pubDate>Sun, 04 Aug 2024 13:56:36 GMT</pubDate>
            <content:encoded><![CDATA[genai-users.connpass.comこのブログで何回か書いておりますが、私は日本生成AIユーザ会というコミュニティを運営しており、次回は2024年8月13日(火)20時から「Geminiマルチモーダルプログラミング」（ハンズオン）を開催します。youtu.beyoutu.be↑前回、前々回はGoogle Cloudコンソール上でGeminiマルチモーダルを使いましたが、8月13日(火)の回はPythonプログラミングで行います。お盆の時期ではありますが、逆に時間空いている方もいらっしゃると思います。ぜひご参加ください！]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[運用では確認以外を自動化したいという時もある]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/08/04/184713</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/08/04/184713</guid>
            <pubDate>Sun, 04 Aug 2024 09:47:13 GMT</pubDate>
            <content:encoded><![CDATA[はじめにこんにちは、ウェブオペレーターの皆さん。今日は、運用の自動化を推進しつつ、重要な確認ステップを保持する方法について、私が開発したツール「toi」を交えてお話しします。また、これらのツールが完全な自動化が許されない環境や状況でも活用できる方法に焦点を当てていきます。マスタリングLinuxシェルスクリプト 第2版 ―Linuxコマンド、bashスクリプト、シェルプログラミング実践入門作者:Mokhtar Ebrahim,Andrew Mallettオライリー・ジャパンAmazontoiの開発背景toiの開発は、私自身がウェブオペレーションの現場で直面した具体的な課題から始まりました。完全な自動化を目指す一方で、重要な判断には人間の介入が必要な場面が多々ありました。例えば：スクリプト1の実行結果を確認し、その出力をスクリプト2の入力としてコピーペーストする必要がある場合。本番環境で実行する前に、一旦出力を確認するために実行コマンドを削除して dry-run する必要がある場合。これらの操作は、既存の自動化ツールでは効率的に処理することが難しく、人間の手動介入が必要でした。そこで、Unixパイプラインの柔軟性を活かしつつ、必要な箇所で人間の判断を挟むことができるツールの開発を考えました。これが toiの誕生につながったのです。運用自動化の現実と課題運用の自動化は効率性と一貫性を高める素晴らしい方法です。しかし、現実には完全な自動化が許されない、あるいは望ましくないケースが多々あります。組織のポリシー：特定の操作に人間の承認が必須な場合リスク管理：ミスの影響が甚大な操作異常検知：通常とは異なる状況で、人間の判断が必要な場合段階的な自動化：完全自動化への移行過程で、部分的に人間の確認を残す必要がある場合これらの状況下では、完全な自動化と手動操作の間でバランスを取る必要があります。そこで登場するのが「toi」です。toiの紹介「toi」（発音は「とい」）は、Unixスタイルのパイプラインに対話的な確認ステップを追加するコマンドラインツールです。このツールを使用することで、自動化プロセスに人間の判断を効果的に組み込むことができます。github.comtoiの主な特徴パイプライン内での対話的確認カスタマイズ可能なタイムアウトデフォルト応答オプション柔軟なプロンプトメッセージ軽量で高速な動作他のUnixツールとの優れた互換性toiの技術的詳細toiは、Go言語で実装されています。その主な技術的特徴は以下の通りです：標準入出力の効率的な処理: Goのio/ioutilパッケージを活用し、大量のデータでも効率的に処理します。並行処理: Goのgoroutineを使用し、タイムアウト処理と入力待ちを並行して行います。シグナルハンドリング: SIGINT（Ctrl+C）などのシグナルを適切に処理し、ユーザーが操作を中断できるようにしています。toiは、Unixパイプラインとの親和性が高く、学習コストが低いという点で他のツールと差別化されています。完全自動化が許されない状況でのtoiの活用重要データの更新確認   echo "UPDATE user_data SET status = 'INACTIVE' WHERE last_login < '2023-01-01';" | toi -p "長期間ログインのないユーザーを非アクティブにしますか？ (y/n): " | mysql user_db   ユーザーステータスの一括変更など、重要な更新操作の前に確認が必要な場合に有効です。システム設定変更の承認   ./generate_config_update.sh | toi -t 300 -p "新しい設定を適用しますか？ (y/n): " | sudo apply_config   システム設定の変更に必ず人間のレビューを要求している場合に使用できます。大規模データ操作の制御   find /data/old_records -type f -mtime +365 | toi -y -p "1年以上経過した記録を削除しますか？ (Y/n): " | xargs rm   大量のデータ削除など、影響範囲が大きい操作で人間の判断を仰ぐことができます。重要な自動処理の承認   echo "実行する重要な処理の内容" | toi -t 600 -p "この重要な処理を実行しますか？ (y/n): " && ./run_critical_process.sh   組織のポリシーで、重要な自動処理の実行前に人間の承認が必要な場合に利用できます。toiによる運用改善のポイントリスク管理の向上: 重要な操作前に人間の判断を介在させ、潜在的なリスクを軽減します。段階的自動化の実現: 完全自動化への移行過程で、徐々に人間の介入を減らしていくことができます。異常検知と対応: 通常と異なる状況を人間に通知し、適切な判断を仰ぐことができます。操作の記録: 重要な操作に対する承認プロセスを記録し、後日の確認に備えることができます。柔軟なワークフロー構築: 既存の自動化スクリプトに容易に組み込め、段階的な改善が可能です。導入と使用方法toiは簡単に導入できます。Go環境がある場合は以下のコマンドでインストールできます：go install github.com/nwiizo/toi@latestまたは、GitHubリリースページから直接バイナリをダウンロードすることもできます。基本的な使用方法は以下の通りです：command1 | toi [オプション] | command2主なオプション：- -t, --timeout int: タイムアウト時間（秒）を設定- -y, --yes: 入力がない場合にデフォルトでYesを選択- -n, --no: 入力がない場合にデフォルトでNoを選択- -p, --prompt string: カスタムプロンプトメッセージを設定制限事項と注意点現在のバージョンでは、複雑な条件分岐やループ処理には対応していません。大量のデータを扱う場合、メモリ使用量に注意が必要です。セキュリティ上の理由から、リモート実行には適していません。まとめ「toi」を活用することで、完全な自動化が許されない状況下でも、運用の効率化と人間の判断の両立が可能になります。組織のポリシーやリスク管理など、様々な理由で人間の介入が必要な場面で、toiは自動化と手動操作のバランスを取るための強力なツールとなります。自動化を推進しながらも、クリティカルな判断には人間の介入を残すという、バランスの取れたアプローチを実現するツールとして、ぜひ「toi」を検討してみてください。組織の要件に合わせて柔軟に運用プロセスを設計し、効率性と安全性の両立を図ることができます。あれがほしいとかこの機能が無いとはPRいただきたいです。あと、みんなGithubにStarして♥]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[3-shake SRE Tech Talk #10 オンサイトを8月23日(金)夕方に渋谷とオンラインで開催]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/08/03/225134</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/08/03/225134</guid>
            <pubDate>Sat, 03 Aug 2024 13:51:34 GMT</pubDate>
            <content:encoded><![CDATA[3-shake.connpass.com弊社スリーシェイクが運営するSRE勉強会SRE Tech Talkを8月23日(金)18:30から渋谷で開催します！今回初めてのオンサイト開催ということで、Google Cloudさんの渋谷オフィスをお借りします。渋谷駅直結の「渋谷ストリーム」内にあります！※オンラインでも参加可能です。オンサイト参加は無料の懇親会付きです。ぜひご参加ください！今回、私は裏方として手伝うと思いますが、懇親会でぜひ交流できればと思います。私はSREではなく、生成AIアプリケーション開発エンジニアですが。弊社スリーシェイクメンバーとも交流してください！フリーランスの方へrelance.jpスリーシェイクでは、フリーランスエージェントサービスもやっております。ぜひご登録ください！]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[【SRE-NEXT 2024】内製化を見据えた効果的なSRE支援のアプローチ / SRE support approach]]></title>
            <link>https://speakerdeck.com/kojake_300/sre-next-2024-nei-zhi-hua-wojian-ju-etaxiao-guo-de-nasrezhi-yuan-noapuroti</link>
            <guid>https://speakerdeck.com/kojake_300/sre-next-2024-nei-zhi-hua-wojian-ju-etaxiao-guo-de-nasrezhi-yuan-noapuroti</guid>
            <pubDate>Sat, 03 Aug 2024 04:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Google Cloud Next Tokyo ’24 2日目「安心してください履いてますよ」]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/08/02/232030</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/08/02/232030</guid>
            <pubDate>Fri, 02 Aug 2024 14:20:30 GMT</pubDate>
            <content:encoded><![CDATA[shu-kob.hateblo.jp前日に1日目の記事を書きましたが、Google Cloud Next Tokyo '24 2日目に自社ブースでの営業のため行ってきました！cloudonair.withgoogle.com会社のSlackの2日目案内で、11:00集合と書いてあったのに、読んでなく、一般受付が9:00開始だから9時に行って一番乗りしました（苦笑）みんなからは「やる気満々だね」と言われましたが、アホなだけですww普段中々しない6:30起きは無駄だったかと言えばそうではなく、仕事したり、ライブ中継の基調講演聴いたりして有意義でした。「Nextスニーカーなんて聞いたことないって？安心してください。履いてますよ。」基調講演にてww#GoogleCloudNext— Shu Kobuchi(こぶシュー) (@shu_kob) 2024年8月2日   Google Cloud Next Tokyo '24で一番の名言（迷言？）は間違いなく、「安心してください履いてますよ」ですね。「Google Cloud Next Tokyo」という場で、Nextスニーカーという架空のスニーカーの販売をモデルにして生成AIの解説をしていたのですが、Google Cloud所属のスピーカーの方がNextスニーカーを履いていた際に言った「安心してください履いてますよ」がタイミングもよく笑いを取れていましたねww大爆笑でしたwwwGoogle Cloud Next Tokyo '24 2日目スリーシェイクのブースにおります。来場された方はお気軽に遊びに来てください！#GoogleCloudNext pic.twitter.com/cYzXaP0BSw— Shu Kobuchi(こぶシュー) (@shu_kob) 2024年8月2日   空のブースの外観。day2もスリーシェイクのブースでお待ちしてます！！！@shu_kob @3shake_7  #GoogleCloudNext pic.twitter.com/29ZWydaTDP— Takuya Tezuka@スリーシェイク (@tt0603) 2024年8月2日   スリーシェイクが誇るセキュリティギャルとツーショットwwブースでは、リード獲得を頑張ったり、自分の所属部署の分野、SREがと生成AIに興味を持つ方向けに説明していました。もっと説明が上手くなるといいな。精進精進。半年に一回ペースでやってきたOSC（オープンソースカンファレンス）でのブース出展の経験も活きたかな。日頃デスクワークしていると、イベントブース対応も刺激になります。またこういう場に立ちたいと思います。Google Cloud Next Tokyo '24に関わった全ての皆様ありがとうございました！お疲れ様でした！！]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[@Hiroki__IT が目の前にやってきて私にIstioのこと教えてくれた。- Istio in Action の読書感想文]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/08/02/220440</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/08/02/220440</guid>
            <pubDate>Fri, 02 Aug 2024 13:04:40 GMT</pubDate>
            <content:encoded><![CDATA[はじめにマイクロサービスアーキテクチャの台頭により、サービスメッシュ技術は現代のクラウドネイティブ環境において外せない選択肢の一つとなっています。 その理由は明確です。マイクロサービスに求められる非機能要件の多くは類似しており、これをアプリケーション側で個別に実装すると、開発者やインフラエンジニアの負担が増大するからです。ここで登場するのがサービスメッシュです。サービスメッシュの採用により、これらの非機能要件をインフラ層で一元管理することが可能となり、アプリケーション開発者とインフラエンジニアの責務を明確に分離できます。つまり、各エンジニアが自身の専門領域にフォーカスできるのです。これは単なる効率化ではなく、イノベーションを加速させるためサービス開発する上での労苦をなくします。そして、サービスメッシュの世界で圧倒的な存在感を放っているのがIstioです。その包括的な機能と広範な採用で、Istioは多くの企業から信頼を得ています。「Istio in Action」は、このIstioの真髄を理解し、実践的に活用するための道標となる一冊です。Istio in Action作者:Posta, Christian E.,Maloku, RinorManningAmazonしかし、ここで一つの疑問が浮かびます。なぜ日本国内ではIstioの普及が進んでいないのでしょうか？ 多くの企業がマイクロサービスへの移行を検討している一方で、サービスメッシュ技術の導入には慎重な姿勢を示しています。例えば、国内の主要なクラウドネイティブ技術カンファレンスであるCloudNative Days Tokyoでも、Istioに関するセッションの数は比較的少ない印象です。国内のセッションだと「1年間のシステム運用を通して分かったIstioの嬉しさと活用における注意点」も好きです。もう誰にも歌わなくなった。大好きなIstioの歌を俺は大きな声で歌うよ 。しかし、希望はあります。同イベントのハンズオンではIstioの利用が見られ、実践的な学習の機会が提供されています。以下の動画は、サービスメッシュの基本的な使用方法を学ぶための絶好の入門ガイドです。クラウドネイティブなシステムを触る予定がある方は、ぜひご覧ください。www.youtube.com本読書感想文の目的は明確です。Istioを実際に採用していない、あるいは採用の予定がない読者の方々にも、Istioの魅力と可能性を伝えることです。なぜなら、サービスメッシュ技術は現代のソフトウェアアーキテクチャの重要なトレンドの一つであり、その概念や原則を理解することは、今後のIT業界の動向を把握する上で非常に有益だからです。glossary.cncf.io「Istio in Action」は、Istioの基本概念から高度な運用テクニック、さらにはカスタム拡張まで、幅広いトピックをカバーする包括的な指南書です。著者のChristian Posta氏とRinor Maloku氏は、豊富な実務経験と深い技術的知見を基に、理論と実践のバランスの取れた解説を提供しています。本書の真の価値は、単なる技術解説に留まらない点にあります。Istioの導入がもたらす組織的な影響や、実際の運用環境での課題にも焦点を当てているのです。これは、Istioを実際のプロダクション環境に導入し、効果的に活用しようとする読者にとって、まさに宝の山と言えるでしょう。本書は2022年3月に出版されており、本読書感想文を執筆している2024年8月時点では約2年半が経過しています。Istioは急速に進化を続けているため、技術的な詳細や最新の機能については、必ず公式ドキュメントを参照することをお勧めします。しかし、本書で説明されている基本的な概念、アーキテクチャの原則、そして実践的なアプローチは、時代を超えて価値があり、Istioを理解し活用する上で重要な基盤となります。istio.io本読書感想文では、「Istio in Action」の各章の主要な内容を要約し、その実践的な価値と2024年現在の技術動向との関連性を考察します。また、必要に応じて最新の情報との相違点にも触れていきます。Istioを学び、導入を検討している開発者、SRE、アーキテクトの方々はもちろん、サービスメッシュ技術に興味を持つ全ての読者にとって、本書がどのような価値を提供するかを明らかにしていきます。また、本読書感想文の執筆にあたり、@Hiroki__ITさんから多大なご貢献をいただきました。専門知識によるレビューのおかげで、本文の方向性、品質と正確性が大幅に向上しました。この場を借りて、ご尽力に心から感謝申し上げます。彼のIstioに関する有益なブログはこちらでご覧いただけます。Istioについてさらに深く学びたい方には、このリソースを強くお勧めします。彼も大きな声で歌ってます。みんなも好きな技術について歌ってほしいです。hiroki-hasegawa.hatenablog.jpはじめに2024年現在の技術動向との比較コアアーキテクチャの安定性主要な進化と新機能Part 1 Understanding Istio1 Introducing the Istio service meshクラウドネイティブアーキテクチャの課題サービスメッシュとIstioの導入Istioの主要機能と利点1. サービスレジリエンス2. トラフィック制御3. セキュリティ4. 可観測性Istioと他のテクノロジーとの比較Istioの実際の使用シナリオまとめ2 First steps with IstioIstioのインストールと基本設定Istioのコントロールプレーンの理解アプリケーションのデプロイとサービスメッシュへの統合トラフィック制御と高度なルーティング観測可能性とレジリエンスまとめ3 Istio's data plane: The Envoy proxyEnvoyプロキシの概要と主要機能Envoyの設定と動作Envoyの動的設定と xDS APIEnvoyの可観測性とトラブルシューティングIstioとEnvoyの関係実践的な応用と提案まとめPart 2 Securing, observing, and controlling your service’s network traffic4 Istio gateways: Getting traffic into a clusterIstio Gatewayの基本概念Gateway設定の実践セキュリティ設定高度な機能と運用上の考慮事項実践的な応用と提案まとめ5 Traffic control: Fine-grained traffic routingトラフィック制御の基本概念カナリアリリースとトラフィックシフティングトラフィックミラーリングFlaggerを使用した自動カナリアデプロイメントクラスター外部へのトラフィック制御実践的な応用と提案まとめ6 Resilience: Solving application networking challengesクライアントサイドロードバランシングロケーションアウェアロードバランシングタイムアウトとリトライサーキットブレーキング実践的な応用と提案まとめ7 Observability: Understanding the behavior of your servicesIstioの観測可能性アーキテクチャメトリクス収集の詳細分散トレーシングの実装アクセスロギングの高度な設定観測可能性データの活用まとめ8 Observability: Visualizing network behavior with Grafana, Jaeger, and KialiGrafanaを用いたメトリクスの可視化分散トレーシングとJaegerKialiを用いたサービスメッシュの可視化実践的な応用と提案まとめ9 Securing microservice communicationサービス間認証（mTLS）エンドユーザー認証（JWT）認可ポリシー外部認可サービスとの統合実践的な応用と提案まとめPart 3 Istio day-2 operations10 Troubleshooting the data plane技術的詳細と実践的応用データプレーンの同期状態の確認Kialiを使用した設定の検証Envoy設定の詳細分析アクセスログの活用まとめ11 Performance-tuning the control plane技術的詳細と実践的応用コントロールプレーンの目標パフォーマンスに影響を与える要因パフォーマンスモニタリングパフォーマンス最適化技術実践的な応用と提案まとめPart 4 Istio in your organization12 Scaling Istio in your organizationマルチクラスターサービスメッシュの利点技術的詳細と実践的応用マルチクラスター導入モデルクラスター間のワークロード発見クラスター間の接続性クラスター間の認証と認可実践的な応用と提案まとめ13 Incorporating virtual machine workloads into the mesh技術的詳細と実践的応用Istioの最新VMサポート機能VMワークロードの統合プロセスセキュリティと観測可能性実践的な応用と提案まとめ14 Extending Istio on the request path技術的詳細と実践的応用Envoyフィルターの理解EnvoyFilterリソースの使用LuaスクリプトによるカスタマイズWebAssemblyによる拡張実践的な応用と提案まとめおわりにおまけ2024年現在の技術動向との比較「Istio in Action」が2022年3月に出版されてから2年半が経過し、Istioは継続的な進化を遂げています。2024年8月現在、Istioの最新安定版は1.22でありistio.ioこの間に多くの機能追加や改善が行われました。しかし、Istioのコアアーキテクチャは大きく変わっていません。blog.christianposta.comコアアーキテクチャの安定性Istioの基本的な設計哲学と主要コンポーネントは維持されています：カスタムリソースによるEnvoy設定の抽象化: VirtualServiceやDestinationRule,GatewayなどのCRDを使用して、トラフィックを制御する為に複雑なEnvoy設定を抽象化する仕組みは変わっていません。コントロールプレーンからデータプレーンへの設定配布: istiodがxDS APIを通じてEnvoyプロキシに設定を配布する方式は継続されています。サイドカーインジェクション: istio-initとistio-proxyコンテナを自動的にPodにインジェクトする仕組みは、依然としてIstioの中核機能です。トラフィックキャプチャ: istio-iptablesを使用したトラフィックのキャプチャと制御の仕組みも変わっていません。主要な進化と新機能アンビエントメッシュ（Ambient Mesh）: Istio 1.19で導入されたアンビエントメッシュは、サービスメッシュのパラダイムシフトを目指しています。従来のサイドカーモデルと比較して、以下の利点があります：リソース効率の向上: サイドカーレスアーキテクチャにより、CPUとメモリの使用量が大幅に削減。スケーラビリティの改善: 大規模クラスターでのパフォーマンスが向上。導入の簡素化: アプリケーションコンテナの変更が不要。 しかし、2024年8月時点でベータ版に昇格したみたいです。しかし、本番環境での採用には慎重なアプローチが必要です(まだ、αだと思っていたんですけど昇格していたみたいです。@toversus26さんに教えてもらいました。ありがとうございます。)。istio.ioWebAssembly (Wasm) の進化: Envoyの拡張性が大幅に向上し、多言語でのカスタムフィルター開発が可能になりました。例えば：Rust、C++、AssemblyScriptなどでのフィルター開発が可能。パフォーマンスオーバーヘッドが従来のLuaスクリプトと比較して10-20%改善。セキュリティが強化され、サンドボックス環境での実行が可能に。istio.ioマルチクラスター・マルチクラウド対応の強化:複数のKubernetesクラスター間でのサービスディスカバリとロードバランシングが改善。異なるクラウドプロババイダー（AWS、GCP、Azure）間でのシームレスな統合が可能に。ネットワークトポロジーに基づいた最適なルーティング決定が可能。istio.ioセキュリティの強化:SPIFFE (Secure Production Identity Framework For Everyone) の完全サポート。より細かな粒度でのアクセス制御：サービス、メソッド、パスレベルでの認可ポリシー。外部認証プロバイダ（OAuth、OIDC）との統合が改善。istio.io可観測性の強化:OpenTelemetryとの完全統合：トレース、メトリクス、ログの統一的な収集が可能。Kialiの機能強化：リアルタイムのサービスメッシュ可視化とトラブルシューティング機能の向上。カスタムメトリクスの柔軟な定義と収集が可能に。istio.ioKubernetes Gateway API対応:Kubernetes Gateway APIの完全サポートにより、より標準化されたトラフィック管理が可能。マルチクラスター環境での一貫したGateway設定が容易に。istio.ioパフォーマンスの最適化:Envoyプロキシのメモリ使用量が20-30%削減。eBPF (extended Berkeley Packet Filter) の活用によるネットワークパフォーマンスの向上。istio.ioWaypoint Proxy:サービス間の通信制御をより細かく管理可能。マルチクラスター環境でのトラフィック管理が大幅に簡素化。istio.ioIstioは急速に進化を続けており、その基本的な概念や主要機能は「Istio in Action」で説明されているものと大きく変わっていません。しかし、新機能の追加や既存機能の改善により、より柔軟で強力なサービスメッシュの構築が可能になっています。組織の規模やニーズに応じて、Istioの採用を検討し、マイクロサービスアーキテクチャの課題解決に活用することができるでしょう。Part 1 Understanding Istio1 Introducing the Istio service mesh「Istio in Action」の第1章は、現代のクラウドネイティブアーキテクチャが直面する課題と、それらを解決するためのサービスメッシュ、特にIstioの役割について包括的に解説しています。著者は、マイクロサービスアーキテクチャの複雑さと、それに伴う課題に焦点を当て、Istioがどのようにしてこれらの問題を解決するかを詳細に説明しています。クラウドネイティブアーキテクチャの課題著者は、現代のソフトウェア開発が直面する主な課題を以下のように特定しています。ネットワークの信頼性の欠如: クラウド環境では、ネットワークの障害が頻繁に発生します。これは、サービス間の通信に大きな影響を与え、システム全体の安定性を脅かす可能性があります。サービス間の依存関係管理: マイクロサービスの数が増えるにつれ、サービス間の依存関係が複雑化します。これにより、障害の伝播やパフォーマンスの問題が発生しやすくなります。分散システムの複雑さ: 多数のサービスが協調して動作する必要があり、全体の挙動を把握することが困難になります。これは、デバッグや問題解決を非常に困難にします。一貫したセキュリティポリシーの適用: 各サービスで個別にセキュリティを実装すると、一貫性の確保が難しくなります。これは、セキュリティホールを生み出す可能性があります。システム全体の可観測性の確保: 分散システムでは、問題の根本原因を特定することが困難です。これは、迅速な問題解決を妨げ、システムの信頼性に影響を与えます。Figure 1.1 ACMEMono modernization with complementary services より引用この図は、モノリシックなアプリケーション（ACMEmono）とService A、Service B、Service Cが分離され、それぞれが独立したサービスとして機能していることがわかります。この構造は、上記の課題を顕著に示しています。例えば、Service AがService Bに依存している場合、Service Bの障害がService Aにも影響を与える可能性があります。また、各サービスが独自のセキュリティ実装を持つ場合、一貫したセキュリティポリシーの適用が困難になります。著者は、これらの課題に対処するための従来のアプローチとして、アプリケーション固有のライブラリ（例：Netflix OSS）の使用を挙げています。しかし、このアプローチには以下のような問題があると指摘しています。言語やフレームワークに依存する: 例えば、Netflix OSSはJava中心のライブラリセットであり、他の言語で書かれたサービスには適用が難しいです。新しい言語やフレームワークの導入が困難: 新しい技術を導入する際に、既存のレジリエンスパターンを再実装する必要があります。ライブラリの維持と更新が煩雑: 各サービスで使用されているライブラリのバージョンを一貫して管理することが困難です。Figure 1.3 Application networking libraries commingled with an application より引用この図は、従来のアプローチでは、各アプリケーションが個別にネットワーキングライブラリを実装する必要があることを示しています。これは、一貫性の確保や保守の面で課題を生み出します。例えば、Service AとService Bが異なる言語で実装されている場合、それぞれが異なるライブラリセットを使用することになり、結果として異なるレジリエンスパターンが適用される可能性があります。サービスメッシュとIstioの導入著者は、これらの課題に対する解決策としてサービスメッシュ、特にIstioを紹介しています。Istioは以下の主要な機能を提供することで、これらの課題に対処します。サービスレジリエンス: リトライ、タイムアウト、サーキットブレーカーなどの機能を提供トラフィック制御: 細かなルーティング制御やカナリアデプロイメントの実現セキュリティ: 相互TLS（mTLS）による通信の暗号化と認証可観測性: メトリクス収集、分散トレーシング、ログ集約Figure 1.8: A service mesh architecture with co-located application-layer proxies (data plane) and management components (control plane) より引用この図は、サービスメッシュのアーキテクチャを示しています。各アプリケーションにサイドカーとしてデプロイされたプロキシ（データプレーン）と、それらを管理するコントロールプレーンの関係が明確に表現されています。こちら、サービスメッシュに関してはこちらの動画もオススメです。www.youtube.com著者は、Istioのアーキテクチャを以下のように詳細に説明しています。データプレーン:Envoyプロキシをベースとしています。各サービスのサイドカーとしてデプロイされ、すべてのネットワークトラフィックを制御します。トラフィックの暗号化、ルーティング、負荷分散、ヘルスチェックなどを実行します。コントロールプレーン:istiodと呼ばれる中央管理コンポーネントで構成されています。ポリシーの適用や設定の配布を行います。証明書の管理、サービスディスカバリ、設定の検証などの機能を提供します。Figure 1.9 Istio is an implementation of a service mesh with a data plane based on Envoy and a control plane. より引用この図は、Istioの具体的な実装を示しています。Envoyプロキシがデータプレーンとして機能し、istiodがコントロールプレーンとして全体を管理している様子が描かれています。例えば、新しいサービスがデプロイされると、istiodはそのサービスの存在を検知し、関連するすべてのEnvoyプロキシに新しい設定を配布します。これにより、新しいサービスへのトラフィックが適切にルーティングされ、セキュリティポリシーが適用されます。Istioの主要機能と利点著者は、Istioの主要機能とその利点を以下のように詳細に説明しています。1. サービスレジリエンスIstioは、Envoyプロキシを通じて以下のレジリエンス機能を提供します。リトライ: 一時的な障害からの自動回復を行います。例えば、ネットワークの瞬断によるエラーを自動的にリトライすることで、ユーザーへの影響を最小限に抑えます。タイムアウト: 長時間応答のないリクエストを制御します。これにより、1つのスロークエリがシステム全体のパフォーマンスを低下させることを防ぎます。サーキットブレーカー: 障害のあるサービスへのトラフィックを遮断します。例えば、特定のサービスが頻繁にエラーを返す場合、一定時間そのサービスへのリクエストを遮断し、システム全体の安定性を保ちます。これらの機能により、システム全体の安定性が向上し、障害の影響を最小限に抑えることができます。我らが師匠のyteraokaさんがIstio の timeout, retry, circuit breaking, etcというブログを4年前に書いているので是非、読んで下さい。sreake.com2. トラフィック制御Istioのトラフィック管理機能には以下が含まれます。細かなルーティング制御: HTTPヘッダーやその他のメタデータに基づいてルーティングを制御します。例えば、特定のユーザーグループからのリクエストを新しいバージョンのサービスにルーティングすることができます。カナリアデプロイメント: 新バージョンへの段階的なトラフィック移行を実現します。例えば、新バージョンに最初は5%のトラフィックのみを送り、問題がなければ徐々に増やしていくことができます。負荷分散: 高度な負荷分散アルゴリズムを適用します。ラウンドロビン、最小接続数、重み付けなど、様々な方式を選択できます。これらの機能により、新機能の安全なロールアウトやA/Bテストの実施が可能になります。istio.io3. セキュリティIstioのセキュリティ機能には以下が含まれます。相互TLS（mTLS）: サービス間の通信を自動的に暗号化します。これにより、中間者攻撃などのセキュリティリスクを大幅に軽減できます。アイデンティティ管理: 各サービスに強力なアイデンティティを付与します。これにより、「誰が誰と通信しているか」を正確に把握し、制御することができます。認証と認可: きめ細かなアクセス制御ポリシーを適用します。例えば、「サービスAはサービスBの特定のエンドポイントにのみアクセスできる」といったポリシーを設定できます。これらの機能により、セキュリティ管理の複雑さが大幅に軽減されます。istio.io4. 可観測性Istioは以下の可観測性機能を提供します。メトリクス収集: サービス間のトラフィック、レイテンシ、エラーレートなどを自動的に収集します。これらのメトリクスは、Prometheusなどのモニタリングツールと容易に統合できます。分散トレーシング: リクエストの全体的な流れを可視化します。例えば、ユーザーリクエストがシステム内のどのサービスを通過し、各サービスでどれくらいの時間を消費したかを追跡できます。アクセスログ: 詳細なリクエスト/レスポンスの情報を記録します。これにより、問題が発生した際の詳細な分析が可能になります。これらの機能により、システムの健全性の監視と問題の迅速な特定が可能になります。istio.ioIstioと他のテクノロジーとの比較著者は、IstioをEnterprise Service Bus（ESB）やAPI Gatewayと比較し、その違いを明確にしています。Figure 1.10: An ESB as a centralized system that integrates applicationsこの図は、従来のESBアーキテクチャを示しています。ESBが中央集権的なシステムとして機能し、全てのサービス間の通信を仲介する様子が描かれています。ESBとIstioの主な違いは以下の通りです。アーキテクチャ: ESBは中央集権的であるのに対し、Istioは分散型です。スケーラビリティ: ESBは中央のボトルネックになりやすいですが、Istioは各サービスに分散しているため、より高いスケーラビリティを提供します。機能: ESBはメッセージ変換やオーケストレーションなども行いますが、Istioはネットワーキングの問題に特化しています。Figure 1.12 The service proxies implement ESB and API gateway functionalities. より引用この図は、Istioのサービスプロキシが、ESBやAPI Gatewayの機能を分散的に実装している様子を示しています。各サービスに付随するプロキシが、それぞれの機能を担っていることがわかります。Figure 1.11 API gateway for service traffic より引用API GatewayとIstioの主な違いは以下の通りです。適用範囲: API Gatewayは主にエッジでの機能を提供しますが、Istioはサービス間の全ての通信を管理します。グラニュラリティ: Istioはより細かいレベルでのトラフィック制御が可能です。統合: IstioはKubernetesなどのプラットフォームとより密接に統合されています。著者は、Istioが以下の点でESBやAPI Gatewayと異なることを強調しています。分散アーキテクチャ: Istioは中央集権的ではなく、各サービスに分散してデプロイされます。これにより、単一障害点を排除し、高いスケーラビリティを実現しています。透明性: アプリケーションコードを変更せずに機能を提供します。開発者は既存のアプリケーションロジックを変更することなく、Istioの機能を利用できます。フォーカス: Istioは純粋にネットワーキングの問題に焦点を当てており、ビジネスロジックの実装は行いません。これにより、各サービスの責務が明確に分離され、システム全体の保守性が向上します。Istioの実際の使用シナリオ著者は、Istioの実際の使用シナリオについていくつかの具体例を提供しています。マイクロサービスの段階的な導入:既存のモノリシックアプリケーションからマイクロサービスへの移行を段階的に行う際、Istioを使用してトラフィックを制御できます。例えば、新しいマイクロサービスに最初は10%のトラフィックのみを送り、問題がなければ徐々に増やしていくことができます。A/Bテスティング:新機能のテストを行う際、Istioのトラフィック分割機能を使用して、特定のユーザーグループに新機能を提供し、その反応を測定することができます。セキュリティの強化:Istioの相互TLS機能を使用して、すべてのサービス間通信を自動的に暗号化できます。これにより、セキュリティチームは個々のアプリケーションの実装を気にすることなく、一貫したセキュリティポリシーを適用できます。障害インジェクションテスト:Istioの障害インジェクション機能を使用して、特定のサービスの遅延や障害をシミュレートし、システム全体のレジリエンスをテストできます。マルチクラスタ/マルチクラウド環境の管理:Istioを使用して、異なるクラスタや異なるクラウドプロバイダー上で動作するサービス間の通信を統一的に管理できます。これにより、ハイブリッドクラウド環境やマルチクラウド環境の運用が大幅に簡素化されます。まとめ「Istio in Action」の第1章は、サービスメッシュとIstioの概念を包括的に紹介し、その重要性を説得力のある方法で説明しています。著者は、クラウドネイティブアーキテクチャの課題を明確に特定し、Istioがこれらの課題にどのように対処するかを詳細に解説しています。Figure 1.13 An overview of separation of concerns in cloud-native applications. Istio plays a supporting role to the application layer and sits above the lower-level deployment layer. より引用この図は、クラウドネイティブアプリケーションにおけるIstioの位置づけを示しています。Istioが、アプリケーションレイヤーとデプロイメントレイヤーの間に位置し、両者を橋渡しする重要な役割を果たしていることがわかります。Istioは、ネットワークの信頼性、セキュリティ、可観測性、トラフィック管理など、分散システムが直面する多くの課題に対する強力なソリューションを提供します。しかし、著者が指摘しているように、Istioの導入は技術的な変更以上のものであり、組織のアーキテクチャ設計、運用プラクティス、さらにはチームの構造にまで影響を与える可能性があります。2024年現在、Istioはさらに進化を続けており、アンビエントメッシュやWebAssemblyを通じた拡張性の向上など、新たな可能性を開いています。これらの進化は、著者の主張の妥当性を裏付けるとともに、Istioの適用範囲をさらに広げています。最後に、この章はIstioの導入を検討している組織にとって優れた出発点となりますが、実際の導入に際しては、自組織の具体的なニーズ、既存のインフラストラクチャ、そして長期的な技術戦略を慎重に評価することが重要です。Istioは強力なツールですが、それを効果的に活用するためには、適切な計画、リソース、そして継続的な学習とアダプテーションが必要です。サービスメッシュ技術、特にIstioは、クラウドネイティブアーキテクチャの未来を形作る重要な要素の一つとなっています。この技術を理解し、適切に活用することは、現代のソフトウェアエンジニアとSREにとって不可欠なスキルとなっているのです。2 First steps with Istio「Istio in Action」の第2章は、Istioの実践的な導入と基本的な使用方法に焦点を当てています。この章では、Istioのインストール、コントロールプレーンの理解、アプリケーションのデプロイ、トラフィック制御、そして観測可能性の探索といった重要なトピックが取り上げられています。Istioのインストールと基本設定章の冒頭で、著者はIstioのインストール方法を詳細に説明しています。特に印象的だったのは、istioctlコマンドラインツールの使用です。このツールを使用することで、Istioのインストールプロセスが大幅に簡素化されています。例えば、以下のコマンドでIstioをインストールできます：istioctl install --set profile=demo -yこの簡潔さは、特に大規模な環境での導入や、CI/CDパイプラインへの組み込みを考えた際に非常に有用です。また、著者が強調しているように、インストール前のistioctl x precheckコマンドの使用は、潜在的な問題を事前に特定し、スムーズなデプロイメントを確保するための重要なステップです。Figure 2.1 Istio control plane and supporting components より引用この図は、Istioの全体的なアーキテクチャを理解する上で非常に有用です。特に、istiodがコントロールプレーンの中心的な役割を果たしていることが視覚的に明確になっています。Istioのコントロールプレーンの理解著者は、Istioのコントロールプレーン、特にistiodコンポーネントの重要性を強調しています。istiodは、設定の管理、サービスディスカバリ、証明書管理など、多岐にわたる機能を担っています。特に印象的だったのは、IstioがKubernetes Custom Resource Definitions (CRDs)を活用して設定を管理している点です。これにより、Istioの設定がKubernetesのネイティブリソースとして扱えるようになり、既存のKubernetesツールやワークフローとシームレスに統合できます。hiroki-hasegawa.hatenablog.jp例えば、以下のようなYAML定義で、Istioの振る舞いを制御できます：apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata:  name: my-servicespec:  hosts:  - my-service  http:  - route:    - destination:        host: my-service        subset: v1この宣言的な設定アプローチは、IaCの原則に沿っており、設定の版管理やレビュープロセスの導入を容易にします。アプリケーションのデプロイとサービスメッシュへの統合著者は、サンプルアプリケーション（カタログサービスとWebアプリ）を用いて、Istioのサービスメッシュへのアプリケーションの統合プロセスを説明しています。特に注目すべきは、サイドカーインジェクションのプロセスです。Istioは、アプリケーションのPodに自動的にEnvoyプロキシをインジェクトすることで、アプリケーションコードを変更することなくメッシュの機能を提供します。hiroki-hasegawa.hatenablog.jpkubectl label namespace istioinaction istio-injection=enabledこのコマンドは、指定された名前空間内の全てのPodに自動的にIstioプロキシをインジェクトするよう設定します。この自動化は、大規模なマイクロサービス環境での運用を大幅に簡素化します。Figure 2.7 The webapp service calling the catalog service both with istio-proxy injected より引用この図は、サイドカーパターンの実際の動作を視覚的に説明しており、サービス間通信がどのようにIstioプロキシを介して行われるかを明確に示しています。トラフィック制御と高度なルーティング著者は、Istioの強力なトラフィック制御機能について詳しく説明しています。特に印象的だったのは、VirtualServiceとDestinationRuleの概念です。これらのリソースを使用することで、非常に細かい粒度でトラフィックをコントロールできます。例えば、以下のような設定で、特定のヘッダーを持つリクエストを新バージョンのサービスにルーティングできます：apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata:  name: catalogspec:  hosts:  - catalog  http:  - match:    - headers:        x-dark-launch:          exact: "v2"    route:    - destination:        host: catalog        subset: version-v2  - route:    - destination:        host: catalog        subset: version-v1この機能は、カナリアリリースやブルー/グリーンデプロイメントなどの高度なデプロイメント戦略を実装する上で非常に有用です。SREの観点からは、このような細かい制御が可能であることで、新機能のロールアウトリスクを大幅に低減できます。観測可能性とレジリエンス著者は、IstioがPrometheusやGrafanaなどのツールと統合して、システムの観測可能性を向上させる方法を説明しています。特に、Istioが自動的に生成する詳細なメトリクスとトレースは、複雑なマイクロサービス環境でのトラブルシューティングを大幅に簡素化します。また、Istioのレジリエンス機能、特にリトライとサーキットブレーカーの実装は注目に値します。以下の設定例は、サービスへのリクエストに自動リトライを実装する方法を示しています：apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata:  name: my-servicespec:  hosts:  - my-service  http:  - route:    - destination:        host: my-service    retries:      attempts: 3      perTryTimeout: 2sこの設定により、一時的なネットワーク障害やサービスの瞬間的な不具合に対する耐性が向上し、システム全体の安定性が改善されます。まとめ「Istio in Action」の第2章は、Istioの基本的な導入から高度な機能の使用まで、幅広いトピックをカバーしています。この章から得られる主要な洞察は以下の通りです：インフラストラクチャレベルでの問題解決: Istioは、ネットワークの信頼性、セキュリティ、可観測性などの横断的な問題をインフラストラクチャレベルで解決します。これにより、開発者はビジネスロジックに集中できるようになります。宣言的な設定: IstioはKubernetes CRDを活用し、宣言的な方法で複雑なネットワーキングの動作を定義できます。これにより、設定の管理と自動化が容易になります。段階的な導入の重要性: 著者が強調しているように、Istioは既存のシステムに段階的に導入できます。これは、リスクを最小限に抑えながらサービスメッシュの利点を享受するための重要なアプローチです。観測可能性の向上: Istioは、複雑なマイクロサービス環境での問題の診断と解決を大幅に簡素化します。これは、システムの信頼性と運用効率の向上に直結します。高度なトラフィック制御: IstioのVirtualServiceとDestinationRuleを使用することで、非常に細かい粒度でトラフィックをコントロールできます。これは、新機能の安全なロールアウトや、A/Bテストの実施に非常に有用です。Istioはマイクロサービスアーキテクチャの複雑さに対処するための強力なツールセットを提供しています。しかし、その導入には慎重な計画と、組織全体での協力が必要です。実際の運用環境でIstioを活用する際は、以下の点に注意することをお勧めします：段階的な導入: 全てのサービスを一度にIstioに移行するのではなく、重要度の低いサービスから始めて段階的に導入することをお勧めします。モニタリングとトレーシングの強化: Istioの可観測性機能を最大限に活用し、既存のモニタリングツールと統合することで、システム全体の可視性を向上させます。セキュリティポリシーの統一: Istioのセキュリティ機能を利用して、全サービスに一貫したセキュリティポリシーを適用します。トラフィック管理戦略の策定: カナリアリリースやA/Bテストなど、Istioのトラフィック管理機能を活用した高度なデプロイメント戦略を計画します。パフォーマンスの最適化: Istioの導入に伴うオーバーヘッドを考慮し、適切なリソース割り当てと設定の最適化を行います。最後に、Istioは強力なツールですが、それを効果的に活用するためには、適切な計画、リソース、そして継続的な学習とアダプテーションが必要です。この章で学んだ基本を踏まえ、実際の環境での試行錯誤を通じて、組織に最適なIstioの活用方法を見出していくことが重要です。3 Istio's data plane: The Envoy proxy「Istio in Action」の第3章は、Istioのデータプレーンの中核を成すEnvoyプロキシに焦点を当てています。この章では、Envoyの基本概念、設定方法、主要機能、そしてIstioとの関係性について詳細に解説されています。Envoyは、現代のマイクロサービスアーキテクチャにおける重要な課題を解決するために設計された強力なプロキシであり、Istioのサービスメッシュ機能の多くを支えています。Envoyプロキシの概要と主要機能Envoyは、Lyft社によって開発された高性能なL7プロキシおよび通信バスです。以下の主要な特徴を持っています：言語非依存: C++で実装されており、任意の言語やフレームワークで書かれたアプリケーションと連携可能。動的設定: xDS APIを通じて動的に設定を更新可能。高度な負荷分散: 様々な負荷分散アルゴリズムをサポート。強力な可観測性: 詳細なメトリクスと分散トレーシングをサポート。L7プロトコルサポート: HTTP/2、gRPCなどの最新プロトコルをネイティブにサポート。Figure 3.1 A proxy is an intermediary that adds functionality to the flow of traffic. より引用Envoyの核心的な設計原則は、「ネットワークは透過的であるべきで、問題が発生した際には容易に原因を特定できるべき」というものです。この原則は、複雑化するマイクロサービス環境において非常に重要です。Envoyの設定と動作Envoyの設定は主に以下の3つの要素から構成されます：Listeners: 受信トラフィックを処理するポートとプロトコルを定義。Routes: 受信したリクエストをどのクラスタに転送するかを定義。Clusters: アップストリームサービスのグループを定義。以下は、基本的なEnvoy設定の例です。Istioの複雑さの多くはEnvoyに起因しています。Envoyの設定と動作原理を十分に理解しているかどうかで、Istioの全体像の把握や問題解決の能力が大きく異なります。したがって、Istioを効果的に活用していくためには、Envoyについても深く学び、実践することが不可欠です。github.comstatic_resources:  listeners:  - name: listener_0    address:      socket_address: { address: 0.0.0.0, port_value: 10000 }    filter_chains:    - filters:      - name: envoy.filters.network.http_connection_manager        typed_config:          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager          stat_prefix: ingress_http          route_config:            name: local_route            virtual_hosts:            - name: local_service              domains: ["*"]              routes:              - match: { prefix: "/" }                route: { cluster: some_service }  clusters:  - name: some_service    connect_timeout: 0.25s    type: STRICT_DNS    lb_policy: ROUND_ROBIN    load_assignment:      cluster_name: some_service      endpoints:      - lb_endpoints:        - endpoint:            address:              socket_address:                address: some-service                port_value: 80この設定は、ポート10000でリスニングし、全てのリクエストをsome_serviceクラスタにルーティングします。実際の運用環境では、より複雑な設定が必要になりますが、この例はEnvoyの基本的な構造を理解するのに役立ちます。Envoyの動的設定と xDS APIEnvoyの強力な機能の一つは、動的設定能力です。xDS (x Discovery Service) APIを通じて、実行時に設定を更新できます。主なxDS APIには以下があります：LDS (Listener Discovery Service)RDS (Route Discovery Service)CDS (Cluster Discovery Service)EDS (Endpoint Discovery Service)SDS (Secret Discovery Service)これらのAPIを使用することで、Envoyプロキシの動作を動的に変更でき、環境の変化に迅速に対応できます。Istioは、これらのAPIを実装し、Envoyプロキシの設定を管理します。Figure 3.5 Istio abstracts away the service registry and provides an implementation of Envoy’s xDS API. より引用Envoyの可観測性とトラブルシューティングEnvoyは、詳細なメトリクスと分散トレーシング機能を提供します。これらの機能は、複雑なマイクロサービス環境でのトラブルシューティングに不可欠です。Envoyの主な可観測性機能には以下があります：統計情報: リクエスト数、レイテンシ、エラーレートなどの詳細な統計情報を提供。分散トレーシング: OpenTracingと互換性があり、リクエストの全体的な流れを追跡可能。アクセスログ: 詳細なリクエスト/レスポンス情報を記録。また、EnvoyはAdmin APIを提供しており、実行時の設定やメトリクスにアクセスできます。これは、運用環境でのトラブルシューティングに非常に有用です。## Envoyの統計情報を取得する例curl http://localhost:9901/stats## Envoyの現在の設定をダンプする例curl http://localhost:9901/config_dumpこれらの機能により、EnvoyとIstioを使用したシステムの可観測性が大幅に向上し、問題の迅速な特定と解決が可能になります。IstioとEnvoyの関係IstioはEnvoyをデータプレーンとして使用し、その強力な機能を活用しています。Istioは以下の方法でEnvoyを拡張および管理しています：設定管理: IstioはxDS APIを実装し、Envoyプロキシの設定を一元管理します。セキュリティ: Istioは、Envoyの相互TLS機能を利用し、サービス間の通信を自動的に暗号化します。トラフィック管理: IstioのVirtualServiceやDestinationRuleは、Envoyのルーティングおよびロードバランシング機能を抽象化します。可観測性: IstioはEnvoyのメトリクスとトレーシング機能を活用し、より高度な可観測性を提供します。Figure 3.7 istiod delivers application-specific certificates that can be used to establish mutual TLS to secure traffic between services. より引用こちらのブログがオススメです。hiroki-hasegawa.hatenablog.jp実践的な応用と提案Envoyプロキシとそれを活用したIstioのデータプレーンを効果的に利用するために、以下の実践的な提案を考えてみましょう：段階的な導入: Envoyプロキシを既存のインフラストラクチャに段階的に導入することを検討します。例えば、最初は非クリティカルなサービスに導入し、徐々に範囲を広げていくアプローチが有効です。カスタムフィルターの開発: WebAssemblyを使用して、組織固有のニーズに合わせたカスタムEnvoyフィルターを開発します。これにより、Envoyの機能を拡張し、特定のユースケースに対応できます。詳細なモニタリングの実装: Envoyの豊富なメトリクスを活用し、Prometheusなどのモニタリングシステムと統合します。ダッシュボードを作成し、サービスの健全性とパフォーマンスを視覚化します。トラフィック管理戦略の最適化: Envoyのルーティング機能を活用し、A/Bテストやカナリアリリースなどの高度なデプロイメント戦略を実装します。セキュリティの強化: Envoyの相互TLS機能を最大限に活用し、サービス間通信のセキュリティを強化します。また、認証・認可ポリシーを実装し、きめ細かなアクセス制御を実現します。パフォーマンスチューニング: Envoyの設定を最適化し、リソース使用量とレイテンシを監視します。特に大規模環境では、Envoyのリソース設定を慎重に調整する必要があります。障害注入テストの実施: Envoyの障害注入機能を使用して、システムの回復性をテストします。様々な障害シナリオを模擬し、システムの動作を検証します。継続的な学習と最適化: Envoyとイストの進化に合わせて、継続的に新機能を学び、適用していきます。コミュニティへの参加や、最新のベストプラクティスの追跡が重要です。まとめEnvoyプロキシは、現代のクラウドネイティブアーキテクチャにおける多くの課題を解決する強力なツールです。その柔軟性、拡張性、そして高度な機能セットは、複雑なマイクロサービス環境での運用を大幅に簡素化します。Istioと組み合わせることで、Envoyの機能がさらに強化され、より統合されたサービスメッシュソリューションとなります。しかし、EnvoyとIstioの導入には慎重な計画と設計が必要です。特に大規模な環境では、パフォーマンスやリソース使用量に注意を払う必要があります。また、チームのスキルセットの向上や、新しい運用プラクティスの導入も重要な検討事項となります。最後に、EnvoyとIstioは急速に進化を続けているため、継続的な学習と適応が不可欠です。これらのテクノロジーを効果的に活用するには、最新の動向を常に追跡し、自組織のニーズに合わせて適切に採用していく必要があります。Part 2 Securing, observing, and controlling your service’s network traffic4 Istio gateways: Getting traffic into a cluster「Istio in Action」の第4章は、Istioのゲートウェイ機能に焦点を当て、クラスター外部からのトラフィックを安全かつ効率的に管理する方法について詳細に解説しています。この章では、Istio Gatewayの基本概念から高度な設定、セキュリティ対策、そして運用上の考慮事項まで、幅広いトピックがカバーされています。Istio Gatewayの基本概念Istio Gatewayは、クラスター外部からのトラフィックを制御し、内部サービスへのアクセスを管理する重要なコンポーネントです。著者は、従来のKubernetes Ingressとの違いを明確にしながら、Istio Gatewayの利点を説明しています。特に印象的だったのは、以下の点です：柔軟なプロトコルサポート: Istio GatewayはHTTP/HTTPSだけでなく、TCPやgRPCなど、さまざまなプロトコルをサポートしています。これにより、多様なアプリケーションニーズに対応できます。詳細な設定オプション: GatewayリソースとVirtualServiceリソースの組み合わせにより、非常に細かいトラフィック制御が可能です。セキュリティの統合: TLS/mTLSの設定が容易で、証明書の管理もIstioが行うことができます。Figure 4.1 We want to connect networks by connecting clients running outside of our cluster to services running inside our cluster. より引用この図は、Istio Gatewayがクラスター外部からのトラフィックをどのように受け取り、内部サービスに転送するかを視覚的に示しています。これにより、Gatewayの役割が明確に理解できます。Gateway設定の実践著者は、実際のGateway設定例を通じて、その使用方法を詳細に解説しています。以下は、基本的なGateway設定の例です：apiVersion: networking.istio.io/v1alpha3kind: Gatewaymetadata:  name: coolstore-gatewayspec:  selector:    istio: ingressgateway  servers:  - port:      number: 80      name: http      protocol: HTTP    hosts:    - "webapp.istioinaction.io"この設定例は、HTTP traffを受け入れ、特定のホストに対するリクエストをルーティングする方法を示しています。著者は、このような基本的な設定から始めて、徐々に複雑な設定へと読者を導いています。VirtualServiceとの連携も重要なポイントです：apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata:  name: webapp-vs-from-gwspec:  hosts:  - "webapp.istioinaction.io"  gateways:  - coolstore-gateway  http:  - route:    - destination:        host: webapp        port:          number: 8080この組み合わせにより、外部からのリクエストを適切な内部サービスにルーティングできます。セキュリティ設定著者は、Istio Gatewayのセキュリティ設定に大きな注意を払っています。特にTLS/mTLSの設定方法は、現代のマイクロサービスアーキテクチャにおいて非常に重要です。Figure 4.8 Basic model of how TLS is established between a client and server より引用この図は、クライアントとサーバー間でのTLS handshakeのプロセスを視覚的に表現しており、セキュリティ設定の重要性を理解する上で非常に有用です。以下は、mTLSを設定するGatewayの例です：apiVersion: networking.istio.io/v1alpha3kind: Gatewaymetadata:  name: coolstore-gatewayspec:  selector:    istio: ingressgateway  servers:  - port:      number: 443      name: https      protocol: HTTPS    tls:      mode: MUTUAL      credentialName: webapp-credential-mtls    hosts:    - "webapp.istioinaction.io"この設定により、クライアントとサーバー間の相互認証が可能になり、セキュリティが大幅に向上します。高度な機能と運用上の考慮事項著者は、単なる基本的な使用方法だけでなく、Istio Gatewayの高度な機能や運用上の考慮事項についても詳しく説明しています。特に印象的だった点は以下の通りです：複数のGatewayの使用: 異なるチームや要件に応じて複数のGatewayを設定する方法が説明されています。これは大規模な組織での運用に特に有用です。Gateway Injection: stub deploymentを使用してGatewayを注入する方法は、チーム間の責任分担を明確にする上で非常に有効です。アクセスログの設定: デバッグやトラブルシューティングに不可欠なアクセスログの設定方法が詳細に解説されています。設定の最適化: 大規模な環境でのパフォーマンス最適化のための設定方法が提供されています。これらの高度な機能は、実際のプロダクション環境でIstioを運用する際に非常に重要になります。実践的な応用と提案Istio Gatewayを効果的に活用するために、以下の実践的な提案を考えてみましょう：段階的な導入: 既存の環境にIstio Gatewayを導入する際は、段階的なアプローチを取ることをおすすめします。まずは非クリティカルなサービスから始め、徐々に範囲を広げていくことで、リスクを最小限に抑えながら導入できます。セキュリティファーストの設計: 初期の設定段階からTLS/mTLSを有効にし、セキュリティを最優先に考えます。証明書の自動管理機能を活用し、定期的な更新を確実に行います。トラフィック制御戦略の策定: カナリアリリースやA/Bテストなど、Gatewayのトラフィック制御機能を活用した高度なデプロイメント戦略を計画します。これにより、新機能の安全なロールアウトが可能になります。モニタリングとロギングの強化: Gatewayのアクセスログと、Prometheusなどの監視ツールを統合し、詳細なトラフィック分析を行います。異常検知やパフォーマンス最適化に活用します。マルチクラスター/マルチクラウド戦略: Istio Gatewayのマルチクラスター機能を活用し、異なる環境（開発、ステージング、本番）や異なるクラウドプロバイダー間でのサービスメッシュの統一管理を検討します。チーム間の責任分担の明確化: Gateway Injectionを活用し、各チームが自身のGatewayを管理できるようにします。これにより、組織全体の俊敏性が向上します。パフォーマンスチューニング: 大規模環境では、Gateway設定の最適化が重要です。不要な設定を削除し、リソース使用量を監視しながら、継続的な最適化を行います。セキュリティ監査の定期実施: Gatewayの設定、特にTLS/mTLS設定を定期的に監査します。新たな脆弱性や推奨事項に応じて、設定を更新します。ディザスタリカバリ計画の策定: Gatewayは重要なインフラコンポーネントであるため、障害時の迅速な復旧計画を策定します。複数のGatewayを異なるアベイラビリティゾーンに配置するなどの冗長性も検討します。まとめ「Istio in Action」の第4章は、Istio Gatewayの重要性と、その効果的な使用方法を包括的に解説しています。Gatewayは、クラスター外部からのトラフィックを管理する上で非常に重要な役割を果たし、セキュリティ、可観測性、トラフィック制御など、多岐にわたる機能を提供します。著者が強調しているように、Istio Gatewayは単なるIngress Controllerの代替ではなく、より高度で柔軟なトラフィック管理ソリューションです。特に、詳細なルーティング制御、TLS/mTLSの簡単な設定、そして様々なプロトコルのサポートは、現代のマイクロサービスアーキテクチャにおいて非常に価値があります。しかし、Gatewayの導入には慎重な計画とデザインが必要です。特に大規模な環境では、パフォーマンスやリソース使用量に注意を払う必要があります。また、チームのスキルセットの向上や、新しい運用プラクティスの導入も重要な検討事項となります。2024年現在、Istioはさらに進化を続けており、アンビエントメッシュやKubernetes Gateway APIのサポートなど、新たな可能性を開いています。これらの進化は、Istio Gatewayの適用範囲をさらに広げ、より多様なユースケースに対応できるようになっています。最後に、Istio Gatewayの導入を検討している組織にとって、この章は優れた出発点となります。しかし、実際の導入に際しては、自組織の具体的なニーズ、既存のインフラストラクチャ、そして長期的な技術戦略を慎重に評価することが重要です。Istio Gatewayは強力なツールですが、それを効果的に活用するためには、適切な計画、リソース、そして継続的な学習とアダプテーションが必要です。Istio Gatewayは、クラウドネイティブアーキテクチャの未来を形作る重要な要素の一つです。この技術を理解し、適切に活用することは、現代のソフトウェアエンジニアとSREにとって不可欠なスキルとなっています。本章で学んだ知識を基に、実際の環境での試行錯誤を通じて、組織に最適なIstio Gatewayの活用方法を見出していくことが重要です。5 Traffic control: Fine-grained traffic routing「Istio in Action」の第5章は、Istioの強力なトラフィック制御機能に焦点を当てています。この章では、新しいコードのデプロイリスクを軽減するための様々な技術が詳細に解説されています。著者は、リクエストレベルのルーティング、トラフィックシフティング、トラフィックミラーリングなどの高度な概念を、実践的な例を交えながら説明しています。Figure 5.1 In a blue/green deployment, blue is the currently released software. When we release the new software, we cut over traffic to the green version. より引用この章はIstioを活用して本番環境でのリリースリスクを大幅に低減する方法を提供しており、非常に価値があります。特に印象に残ったのは、著者が繰り返し強調している「デプロイメント」と「リリース」の概念の分離です。この考え方は、現代のクラウドネイティブ環境において安全かつ効率的なソフトウェアデリバリーを実現する上で極めて重要です。Figure 5.2 A deployment is code that is installed into production but does not take any live production traffic. While the deployment is installed into production, we do smoke tests and validate it. より引用ソフトウェアデリバリーについては「入門 継続的デリバリー」が良いのでぜひ読んでみて下さい(ちなみに原書のGrokking Continuous Deliveryしか読めてないので翻訳版も早く読みたい)。www.oreilly.co.jpトラフィック制御の基本概念著者は、まずIstioのトラフィック制御の基本的な仕組みを説明しています。Istioでは、VirtualServiceとDestinationRuleという2つの主要なリソースを使用してトラフィックを制御します。VirtualServiceは、トラフィックのルーティングルールを定義します。例えば、以下のような設定が可能です：apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata:  name: catalog-vs-from-gwspec:  hosts:  - "catalog.istioinaction.io"  gateways:  - catalog-gateway  http:  - route:    - destination:        host: catalog        subset: version-v1この設定は、すべてのトラフィックをcatalogサービスのversion-v1サブセットにルーティングします。DestinationRuleは、トラフィックの宛先に関するポリシーを定義します：apiVersion: networking.istio.io/v1alpha3kind: DestinationRulemetadata:  name: catalogspec:  host: catalog  subsets:  - name: version-v1    labels:      version: v1  - name: version-v2    labels:      version: v2このDestinationRuleは、catalogサービスに2つのサブセット（version-v1とversion-v2）を定義しています。これらのリソースを組み合わせることで、非常に細かい粒度でトラフィックを制御できます。例えば、特定のHTTPヘッダーを持つリクエストを新しいバージョンのサービスにルーティングするといったことが可能です。カナリアリリースとトラフィックシフティング著者は、新しいバージョンのサービスを安全にリリースするための手法として、カナリアリリースとトラフィックシフティングを詳細に解説しています。カナリアリリースでは、新バージョンに少量のトラフィックを送り、その挙動を観察します。Istioでは、以下のようなVirtualService設定でこれを実現できます：apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata:  name: catalogspec:  hosts:  - catalog  http:  - route:    - destination:        host: catalog        subset: version-v1      weight: 90    - destination:        host: catalog        subset: version-v2      weight: 10この設定では、10%のトラフィックを新バージョン（v2）に送り、残りの90%を既存バージョン（v1）に送ります。著者は、このアプローチの利点として以下を挙げています：リスクの最小化：新バージョンに問題があっても、影響を受けるユーザーは限定的です。段階的な移行：問題がなければ、徐々にトラフィックの割合を増やしていけます。リアルワールドでのテスト：実際のユーザートラフィックを使用してテストできます。SREの観点からは、このアプローチは本番環境の安定性を維持しながら新機能を導入する上で非常に有効です。また、問題が発生した場合の迅速なロールバックも容易です。トラフィックミラーリング著者が紹介している興味深い機能の一つが、トラフィックミラーリングです。これは、実際のトラフィックのコピーを新バージョンのサービスに送信し、その挙動を観察する技術です。apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata:  name: catalogspec:  hosts:  - catalog  http:  - route:    - destination:        host: catalog        subset: version-v1      weight: 100    mirror:      host: catalog      subset: version-v2この設定では、すべてのトラフィックがversion-v1に送られると同時に、そのコピーがversion-v2にも送られます。重要なのは、ミラーリングされたトラフィックの応答は無視されるため、ユーザーに影響を与えることなく新バージョンをテストできる点です。この機能は、特に高トラフィックの環境や、トランザクションの整合性が重要なシステムでの新バージョンのテストに非常に有効です。実際のプロダクショントラフィックを使用してテストできるため、ステージング環境では発見できないような問題を早期に発見できる可能性があります。Flaggerを使用した自動カナリアデプロイメント著者は、Istioのトラフィック制御機能を自動化するツールとしてFlaggerを紹介しています。Flaggerは、メトリクスに基づいて自動的にトラフィックを調整し、カナリアリリースを管理します。以下は、FlaggerのCanaryリソースの例です：apiVersion: flagger.app/v1beta1kind: Canarymetadata:  name: catalog-releasespec:  targetRef:    apiVersion: apps/v1    kind: Deployment    name: catalog  service:    name: catalog    port: 80  analysis:    interval: 45s    threshold: 5    maxWeight: 50    stepWeight: 10    metrics:    - name: request-success-rate      thresholdRange:        min: 99      interval: 1m    - name: request-duration      thresholdRange:        max: 500      interval: 30sこの設定では、Flaggerが45秒ごとにメトリクスを評価し、問題がなければトラフィックを10%ずつ増やしていきます。成功率が99%を下回るか、レスポンス時間が500msを超えた場合、カナリアリリースは中止されロールバックが行われます。これにより、人間の介入なしに安全なカナリアリリースを実現できます。特に、複数のサービスを同時にリリースする必要がある大規模な環境では、この自動化は非常に価値があります。クラスター外部へのトラフィック制御著者は、Istioを使用してクラスター外部へのトラフィックを制御する方法も解説しています。デフォルトでは、Istioはすべての外部トラフィックを許可しますが、セキュリティ上の理由から、この動作を変更してすべての外部トラフィックをブロックし、明示的に許可されたトラフィックのみを通過させることができます。apiVersion: networking.istio.io/v1alpha3kind: ServiceEntrymetadata:  name: external-apispec:  hosts:  - api.external-service.com  ports:  - number: 443    name: https    protocol: HTTPS  resolution: DNS  location: MESH_EXTERNALこのServiceEntryは、特定の外部サービスへのアクセスを許可します。これにより、マイクロサービス環境でのセキュリティを大幅に向上させることができます。実践的な応用と提案Istioのトラフィック制御機能を効果的に活用するために、以下の実践的な提案を考えてみましょう：段階的な導入戦略の策定: 新機能のロールアウトには、まずカナリアリリースを使用し、問題がなければトラフィックシフティングで段階的に移行するという戦略を採用します。これにより、リスクを最小限に抑えながら、新機能を迅速に導入できます。自動化パイプラインの構築: FlaggerなどのツールをCI/CDパイプラインに統合し、カナリアリリースプロセスを自動化します。これにより、人間のエラーを減らし、リリースの一貫性と速度を向上させることができます。詳細なモニタリングの実装: Istioのテレメトリ機能を活用し、サービスのパフォーマンス、エラーレート、レイテンシなどを詳細に監視します。Prometheusなどのモニタリングシステムと統合し、カスタムダッシュボードを作成して、リリースの進捗を視覚化します。トラフィックミラーリングの活用: 新バージョンのサービスをプロダクション環境で徹底的にテストするために、トラフィックミラーリングを活用します。これにより、実際のユーザートラフィックを使用してテストできますが、ユーザーへの影響はありません。セキュリティファーストのアプローチ: ServiceEntryを使用して外部トラフィックを制御し、必要最小限のサービスにのみ外部アクセスを許可します。これにより、潜在的なセキュリティリスクを軽減できます。A/Bテストの実施: Istioの細かいトラフィック制御を活用して、新機能のA/Bテストを実施します。ユーザーセグメントに基づいてトラフィックを分割し、機能の効果を測定します。障害注入テストの実施: Istioの障害注入機能を使用して、様々な障害シナリオ（遅延、エラーなど）をシミュレートし、システムの回復性をテストします。これにより、本番環境での予期せぬ問題に対する準備を整えることができます。例えば、以下のようなVirtualServiceを使用して、特定のパーセンテージのリクエストに対して遅延を注入できます：   apiVersion: networking.istio.io/v1alpha3   kind: VirtualService   metadata:     name: catalog-delay   spec:     hosts:     - catalog     http:     - fault:         delay:           percentage:             value: 10           fixedDelay: 5s       route:       - destination:           host: catalog   この設定では、10%のリクエストに5秒の遅延が追加されます。これを使用して、サービスがタイムアウトや遅延に適切に対応できるかをテストできます。トラフィックポリシーの定期的な見直し: システムの進化に伴い、トラフィックルーティングポリシーを定期的に見直し、最適化します。例えば、古いバージョンへのルーティングを削除したり、新しいサービスを追加したりする必要があるかもしれません。以下は、見直しのチェックリストの例です：全てのサービスバージョンが適切にルーティングされているか不要なルーティングルールがないかセキュリティポリシーが最新のベストプラクティスに沿っているかパフォーマンスメトリクスに基づいてルーティング比率を調整する必要があるかマルチクラスター/マルチリージョン戦略の策定: Istioのマルチクラスター機能を活用して、地理的に分散したサービスのトラフィックを管理します。これにより、レイテンシの最適化やディザスタリカバリの改善が可能になります。例えば、以下のようなGatewayを使用して、クラスター間の通信を制御できます：   apiVersion: networking.istio.io/v1alpha3   kind: Gateway   metadata:     name: cross-cluster-gateway   spec:     selector:       istio: ingressgateway     servers:     - port:         number: 443         name: tls         protocol: TLS       tls:         mode: AUTO_PASSTHROUGH       hosts:       - "*.global"   この設定により、異なるクラスター間でサービスを安全に公開し、通信できるようになります。カスタムメトリクスの導入: Istioのテレメトリ機能を拡張して、ビジネス固有のメトリクスを収集します。これにより、技術的な指標だけでなく、ビジネス上の成果もトラッキングできるようになります。例えば、Envoy filterを使用して、特定のAPIコールの頻度や成功率を測定できます：apiVersion: networking.istio.io/v1alpha3kind: EnvoyFiltermetadata:  name: custom-metricspec:  configPatches:  - applyTo: HTTP_FILTER    match:      context: SIDECAR_OUTBOUND    patch:      operation: ADD      value:        name: envoy.filters.http.lua        typed_config:          "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua          inlineCode: |            function envoy_on_response(response_handle)              if response_handle:headers():get(":path") == "/api/important-endpoint" then                response_handle:logInfo("Important API called")              end            endこの設定により、特定のAPIエンドポイントへのコールをログに記録し、後で分析することができます。グラデュアルロールアウトの自動化: カナリアリリースやトラフィックシフティングの過程を自動化し、メトリクスに基づいて自動的にトラフィック比率を調整するシステムを構築します。これにより、人間の介入を最小限に抑えながら、安全かつ効率的なリリースが可能になります。Flaggerのようなツールを使用して、以下のようなワークフローを実装できます：1. 新バージョンを5%のトラフィックで開始2. エラーレートとレイテンシを5分間監視3. 問題がなければトラフィックを10%に増加4. ステップ2と3を繰り返し、最終的に100%に到達5. 問題が検出された場合は自動的にロールバックサービスメッシュの可視化: Kialiなどのツールを使用して、サービスメッシュのトポロジーと現在のトラフィックフローを視覚化します。これにより、複雑なルーティング設定の理解が容易になり、潜在的な問題の早期発見が可能になります。特に、新しいルーティングルールを適用した後の影響を視覚的に確認するのに役立ちます。セキュリティポリシーとの統合: トラフィック制御を組織のセキュリティポリシーと統合します。例えば、特定の重要なサービスへのアクセスを、認証されたサービスからのみに制限することができます：apiVersion: security.istio.io/v1beta1kind: AuthorizationPolicymetadata:  name: catalog-auth-policyspec:  selector:    matchLabels:      app: catalog  action: ALLOW  rules:  - from:    - source:        principals: ["cluster.local/ns/default/sa/webapp"]この設定により、catalogサービスへのアクセスがwebappサービスアカウントからのみに制限されます。パフォーマンスベンチマーキング: 新旧バージョン間のパフォーマンス比較を自動化します。トラフィックミラーリングを使用して、新バージョンのパフォーマンスを測定し、既存バージョンと比較します。これにより、新バージョンがパフォーマンス要件を満たしているかを客観的に評価できます。災害復旧訓練の実施: Istioのトラフィック制御機能を使用して、災害復旧シナリオをシミュレートし、訓練します。例えば、特定のリージョンやクラスターの障害を模擬し、トラフィックを別のリージョンにリダイレクトする訓練を定期的に行います。これにより、実際の障害時にも迅速かつ効果的に対応できるようになります。これらの実践的な応用と提案を組み合わせることで、Istioのトラフィック制御機能を最大限に活用し、より安全、効率的、かつ堅牢なマイクロサービス環境を構築することができます。重要なのは、これらの手法を継続的に評価し、組織の成長と技術の進化に合わせて適応させていくことです。Istioは非常に強力で柔軟なツールですが、その真価を発揮するためには、組織の具体的なニーズと目標に合わせて慎重に設計し、実装する必要があります。まとめ「Istio in Action」の第5章は、Istioのトラフィック制御機能の重要性と強力さを明確に示しています。著者は、カナリアリリース、トラフィックシフティング、ミラーリングなどの高度な技術を詳細に解説し、これらがマイクロサービス環境でのリリースリスクを大幅に軽減する方法を提示しています。特に印象的なのは、「デプロイメント」と「リリース」の概念を分離することの重要性です。この考え方は、安全かつ効率的なソフトウェアデリバリーを実現する上で極めて重要です。Istioのトラフィック制御機能を活用することで、新バージョンのサービスを本番環境にデプロイしつつ、実際のトラフィックを段階的にシフトさせることが可能になります。また、Flaggerのような自動化ツールの導入により、カナリアリリースプロセスを更に最適化できることも示されています。これは、特に大規模な環境や頻繁なリリースが必要な場合に非常に有用です。2024年現在、アンビエントメッシュやWebAssemblyの進化など、Istioの新機能によりトラフィック制御の柔軟性と効率性が更に向上しています。これらの進化は、より大規模で複雑な環境でのIstioの適用を可能にしています。結論として、Istioのトラフィック制御機能は、現代のマイクロサービスアーキテクチャにおいて不可欠なツールとなっています。適切に活用することで、システムの安定性を維持しつつ、迅速かつ安全にイノベーションを推進することが可能になります。ただし、これらの機能を効果的に使用するためには、継続的な学習と実践、そして組織の具体的なニーズに合わせた戦略の策定が必要不可欠です。6 Resilience: Solving application networking challenges「Istio in Action」の第6章は、分散システムにおける重要な課題の一つであるレジリエンスに焦点を当てています。著者は、マイクロサービスアーキテクチャにおけるネットワークの信頼性の欠如、サービス間の依存関係管理、そして予期せぬ障害への対応といった問題に対して、Istioがどのようにソリューションを提供するかを詳細に解説しています。この章で特に印象に残ったのは分散システムの問題は、予測不可能な方法で障害が発生することが多く、手動でトラフィックシフトのアクションを取ることができないことです。この考え方は、現代のクラウドネイティブアーキテクチャが直面している根本的な課題を端的に表現しており、Istioのようなサービスメッシュの必要性を強調しています。この章はIstioを活用して本番環境でのレジリエンスを大幅に向上させる方法を提供しており、非常に価値があります。特に、クライアントサイドロードバランシング、タイムアウト、リトライ、サーキットブレーキングなどの機能を、アプリケーションコードを変更せずに実装できる点は、運用効率とシステムの信頼性向上に大きく貢献します。クライアントサイドロードバランシング著者は、Istioのクライアントサイドロードバランシング機能について詳細に解説しています。この機能により、サービス間の通信をより効率的に管理し、システム全体のパフォーマンスと信頼性を向上させることができます。Istioは以下の主要なロードバランシングアルゴリズムをサポートしています：Round Robin（ラウンドロビン）: デフォルトのアルゴリズムで、リクエストを順番に各エンドポイントに分配します。Random（ランダム）: リクエストをランダムにエンドポイントに分配します。Least Connection（最小接続数）: アクティブな接続数が最も少ないエンドポイントにリクエストを送信します。これらのアルゴリズムは、DestinationRuleリソースを使用して設定できます。例えば、以下のような設定が可能です：apiVersion: networking.istio.io/v1beta1kind: DestinationRulemetadata:  name: my-destination-rulespec:  host: my-service  trafficPolicy:    loadBalancer:      simple: LEAST_CONNこの設定により、my-serviceへのリクエストは、最小接続数アルゴリズムを使用してロードバランシングされます。著者は、これらのアルゴリズムの違いを実際のパフォーマンステストを通じて示しています。特に印象的だったのは、異なる負荷状況下での各アルゴリズムの振る舞いの違いです。例えば、一部のエンドポイントが高レイテンシーを示す状況下では、Least Connectionアルゴリズムが最も効果的にパフォーマンスを維持できることが示されています。SREの観点からは、この機能は特に重要です。本番環境では、サービスの負荷やパフォーマンスが常に変動するため、適切なロードバランシングアルゴリズムを選択し、必要に応じて動的に調整できることは、システムの安定性と効率性を大幅に向上させます。ロケーションアウェアロードバランシング著者は、Istioのロケーションアウェアロードバランシング機能についても詳しく説明しています。この機能は、マルチクラスタ環境やハイブリッドクラウド環境で特に有用です。ロケーションアウェアロードバランシングを使用すると、Istioは地理的に近いサービスインスタンスにトラフィックを優先的にルーティングします。これにより、レイテンシーを低減し、データの局所性を向上させることができます。例えば、以下のようなDestinationRuleを使用して、ロケーションベースの重み付けを設定できます：apiVersion: networking.istio.io/v1beta1kind: DestinationRulemetadata:  name: my-destination-rulespec:  host: my-service  trafficPolicy:    loadBalancer:      localityLbSetting:        distribute:        - from: us-west/zone1/*          to:            "us-west/zone1/*": 80            "us-west/zone2/*": 20この設定では、us-west/zone1からのトラフィックの80%を同じゾーンに、20%をus-west/zone2にルーティングします。Figure 6.10 Prefer calling services in the same locality. より引用SREとして、この機能は特にグローバルに分散したアプリケーションの運用に有用です。適切に設定することで、ユーザーエクスペリエンスの向上、コストの最適化、そして障害時の影響範囲の局所化を実現できます。タイムアウトとリトライ著者は、Istioのタイムアウトとリトライ機能について詳細に解説しています。これらの機能は、ネットワークの信頼性が低い環境や、サービスが一時的に応答しない状況での耐性を向上させるために重要です。タイムアウトは、VirtualServiceリソースを使用して設定できます：apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata:  name: my-virtual-servicespec:  hosts:  - my-service  http:  - route:    - destination:        host: my-service    timeout: 0.5sこの設定では、my-serviceへのリクエストが0.5秒以内に完了しない場合、タイムアウトエラーが発生します。リトライも同様にVirtualServiceで設定できます：apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata:  name: my-virtual-servicespec:  hosts:  - my-service  http:  - route:    - destination:        host: my-service    retries:      attempts: 3      perTryTimeout: 2sこの設定では、リクエストが失敗した場合に最大3回まで再試行し、各試行のタイムアウトを2秒に設定しています。著者は、これらの設定の影響を実際のパフォーマンステストを通じて示しています。特に印象的だったのは、適切に設定されたリトライ機能が、一時的な障害からのサービスの回復性を大幅に向上させる様子です。しかし、著者は同時に、過度のリトライがシステムに与える潜在的な悪影響についても警告しています。「サンダリングハード」問題（リトライが連鎖的に増幅し、システムに過大な負荷をかける現象）について言及しており、この問題を回避するためのベストプラクティスを提供しています。Figure 6.14 The “thundering herd” effect when retries compound each other より引用SREの観点からは、タイムアウトとリトライの適切な設定は、システムの信頼性とパフォーマンスのバランスを取る上で極めて重要です。特に、マイクロサービスアーキテクチャにおいては、サービス間の依存関係が複雑になるため、これらの設定の影響を慎重に検討し、継続的にモニタリングと調整を行う必要があります。サーキットブレーキング著者は、Istioのサーキットブレーキング機能について詳細に解説しています。この機能は、システムの一部が障害を起こした際に、その影響が他の部分に波及するのを防ぐために重要です。Istioでは、サーキットブレーキングをDestinationRuleリソースを使用して設定します：apiVersion: networking.istio.io/v1beta1kind: DestinationRulemetadata:  name: my-destination-rulespec:  host: my-service  trafficPolicy:    connectionPool:      tcp:        maxConnections: 100      http:        http1MaxPendingRequests: 1        maxRequestsPerConnection: 10    outlierDetection:      consecutiveErrors: 5      interval: 5s      baseEjectionTime: 30s      maxEjectionPercent: 100この設定では、以下のようなサーキットブレーキングのルールを定義しています：最大100のTCP接続を許可キューに入れることができる未処理のHTTPリクエストを1つに制限1つの接続で処理できる最大リクエスト数を10に制限5回連続でエラーが発生した場合、そのホストを30秒間エジェクト（除外）最大で100%のホストをエジェクト可能著者は、これらの設定の影響を実際のパフォーマンステストを通じて示しています。特に印象的だったのは、サーキットブレーキングが適切に機能することで、システム全体の安定性が大幅に向上する様子です。Figure 6.15 Circuit-breaking endpoints that don’t behave correctly より引用SREの観点からは、サーキットブレーキングは特に重要な機能です。大規模な分散システムでは、部分的な障害は避けられません。サーキットブレーキングを適切に設定することで、障害の影響を局所化し、システム全体の耐障害性を向上させることができます。実践的な応用と提案Istioのレジリエンス機能を効果的に活用するために、以下の実践的な提案を考えてみましょう：段階的な導入戦略の策定: レジリエンス機能の導入は、小規模なサービスから始め、徐々に範囲を広げていくことをお勧めします。特に、クリティカルではないサービスから始めることで、リスクを最小限に抑えながら経験を積むことができます。包括的なモニタリングの実装: Istioのテレメトリ機能を活用し、サービスのパフォーマンス、エラーレート、レイテンシなどを詳細に監視します。Prometheusなどのモニタリングシステムと統合し、カスタムダッシュボードを作成して、レジリエンス機能の効果を視覚化します。カオスエンジニアリングの実践: Istioのトラフィック管理機能と障害注入機能を組み合わせて、計画的にシステムに障害を導入し、レジリエンス機能の効果を検証します。これにより、予期せぬ障害に対する準備を整えることができます。サーキットブレーキングの最適化: サーキットブレーキングの設定は、サービスの特性や負荷パターンに応じて最適化する必要があります。負荷テストを実施し、適切なしきい値を見つけることが重要です。リトライ戦略の慎重な設計: リトライは有効な機能ですが、過度のリトライはシステムに悪影響を与える可能性があります。エクスポネンシャルバックオフなどの高度なリトライ戦略を検討し、「サンダリングハード」問題を回避します。ロケーションアウェアロードバランシングの活用: グローバルに分散したアプリケーションでは、ロケーションアウェアロードバランシングを積極的に活用します。これにより、レイテンシーの低減とデータの局所性の向上を実現できます。アプリケーションレベルのレジリエンスとの統合: Istioのレジリエンス機能は強力ですが、アプリケーションレベルのレジリエンス（例：サーキットブレーカーパターン、バルクヘッドパターン）と組み合わせることで、さらに強固なシステムを構築できます。継続的な学習と最適化: レジリエンス戦略は、システムの進化と共に継続的に見直し、最適化する必要があります。新しいIstioのバージョンがリリースされた際は、新機能や改善点を積極的に評価し、導入を検討します。ドキュメンテーションとナレッジ共有: レジリエンス設定とその理由を明確にドキュメント化し、チーム全体で共有します。これにより、長期的なメンテナンス性が向上し、新しいチームメンバーのオンボーディングも容易になります。パフォーマンスとレジリエンスのトレードオフの管理: レジリエンス機能の導入は、システムのパフォーマンスにも影響を与える可能性があります。常にパフォーマンスとレジリエンスのバランスを意識し、必要に応じて調整を行います。まとめ「Istio in Action」の第6章は、Istioを活用したマイクロサービスアーキテクチャのレジリエンス向上について、非常に包括的かつ実践的な内容を提供しています。著者は、クライアントサイドロードバランシング、タイムアウト、リトライ、サーキットブレーキングなどの重要な概念を、理論的説明と実際のパフォーマンステストを通じて解説しており、読者に深い理解を促しています。特に印象的だったのは、著者が単にIstioの機能を説明するだけでなく、それらの機能が実際のプロダクション環境でどのように適用され、どのような影響をもたらすかを具体的に示している点です。例えば、サーキットブレーキングの設定が、システム全体の安定性にどのように寄与するかを、実際のメトリクスを用いて説明している部分は非常に有益です。この章で紹介されているテクニックは、現代の複雑な分散システムの運用において極めて重要です。特に、手動介入なしにシステムのレジリエンスを向上させる能力は、大規模なマイクロサービス環境では不可欠です。しかし、同時に著者は、これらの機能の過度の使用や誤った設定がもたらす潜在的なリスクについても警告しています。例えば、過剰なリトライによる「サンダリングハード」問題や、不適切なサーキットブレーキング設定による不必要なサービス停止などのリスクについて言及しており、読者に慎重な設計と継続的なモニタリングの重要性を喚起しています。2024年現在の技術動向を踏まえると、本章で説明されている概念は依然として有効であり、重要性を増していると言えます。特に、アンビエントメッシュやWebAssemblyの進化により、Istioのレジリエンス機能はより柔軟かつ効率的に適用できるようになっています。最後に、この章から得られる重要な教訓は、レジリエンスは単なる技術的な課題ではなく、システム設計、運用プラクティス、そして組織文化全体に関わる問題だということです。Istioは強力なツールを提供しますが、それを効果的に活用するためには、継続的な学習、実験、そして最適化が不可欠です。7 Observability: Understanding the behavior of your services「Istio in Action」の第7章は、マイクロサービスアーキテクチャにおける重要な課題である観測可能性（Observability）に焦点を当てています。著者は、複雑に絡み合ったサービス群の挙動を理解し、問題を迅速に特定・解決するためのIstioの機能を詳細に解説しています。この章で特に印象に残ったのは観測可能性はデータを収集するだけでなく、そのデータから洞察を得て、システムのパフォーマンス、信頼性、ユーザーエクスペリエンスを向上させることに関するものです。この考え方は、観測可能性の本質を端的に表現しており、単なるモニタリングを超えた価値を強調しています。Istioの観測可能性アーキテクチャ著者は、Istioの観測可能性アーキテクチャについて詳細に解説しています。Istioは、以下の3つの主要な観測可能性機能を提供しています：メトリクス: システムの動作に関する数値データ分散トレーシング: リクエストの流れと各サービスでの処理時間の追跡アクセスログ: 各リクエストの詳細な情報これらの機能は、Istioのデータプレーン（Envoyプロキシ）とコントロールプレーン（istiod）の両方で実装されています。Figure 7.1 Istio is in a position to implement controls and observations. より引用この図は、Istioの観測可能性アーキテクチャの全体像を示しています。Envoyプロキシがデータを収集し、それがPrometheus、Jaeger、Logging Backendなどのツールに送られる様子が描かれています。メトリクス収集の詳細Istioは、サービスメッシュ内のトラフィックに関する豊富なメトリクスを自動的に収集します。これらのメトリクスは、主に以下の4つのカテゴリに分類されます：プロキシレベルメトリクス: Envoyプロキシ自体の性能に関するメトリクスサービスレベルメトリクス: 各サービスのリクエスト量、レイテンシ、エラーレートなどコントロールプレーンメトリクス: istiodの性能と健全性に関するメトリクスIstio標準メトリクス: Istioが定義する標準的なメトリクスセット著者は、これらのメトリクスの詳細と、それらがどのようにPrometheusで収集されるかを説明しています。例えば、以下のようなPrometheusクエリを使用して、特定のサービスの成功率を計算できます：Figure 7.2 Prometheus scraping Istio service proxy for metrics より引用sum(rate(istio_requests_total{reporter="destination",destination_service_name="myservice",response_code!~"5.*"}[5m])) / sum(rate(istio_requests_total{reporter="destination",destination_service_name="myservice"}[5m]))このクエリは、過去5分間のリクエスト成功率（5xxエラー以外のレスポンス）を計算します。分散トレーシングの実装著者は、Istioの分散トレーシング機能の実装詳細について深く掘り下げています。Istioは、OpenTelemetryプロトコルを使用して分散トレーシングをサポートしています。トレーシングを有効にするためには、以下の3つの主要なコンポーネントが必要です：トレースコンテキストの伝播: リクエストヘッダーを使用してトレース情報を伝播スパンの生成: 各サービスでの処理をスパンとして記録トレースバックエンド: Jaegerなどのシステムでトレースデータを収集・分析著者は、これらのコンポーネントの設定方法と、効果的な使用方法を詳細に説明しています。例えば、以下のようなTelemetryリソースを使用して、トレーシングの設定をカスタマイズできます：apiVersion: telemetry.istio.io/v1alpha1kind: Telemetrymetadata:  name: tracing-configspec:  tracing:  - customTags:      my_custom_tag:        literal:          value: "some-constant-value"    randomSamplingPercentage: 10.00この設定では、10%のリクエストをランダムにサンプリングし、カスタムタグを追加しています。アクセスロギングの高度な設定著者は、Istioのアクセスロギング機能の高度な設定オプションについても詳しく解説しています。アクセスログは、各リクエストの詳細な情報を記録し、後から分析やトラブルシューティングを行うために使用されます。Istioでは、EnvoyFilterリソースを使用してログフォーマットをカスタマイズできます。例えば、以下のような設定で、JSONフォーマットのログを生成できます：apiVersion: networking.istio.io/v1alpha3kind: EnvoyFiltermetadata:  name: custom-access-logspec:  configPatches:  - applyTo: NETWORK_FILTER    match:      context: ANY      listener:        filterChain:          filter:            name: "envoy.filters.network.http_connection_manager"    patch:      operation: MERGE      value:        typed_config:          "@type": "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager"          access_log:          - name: envoy.access_loggers.file            typed_config:              "@type": "type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog"              path: /dev/stdout              json_format:                time: "%START_TIME%"                protocol: "%PROTOCOL%"                duration: "%DURATION%"                request_method: "%REQ(:METHOD)%"                request_host: "%REQ(HOST)%"                path: "%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%"                response_code: "%RESPONSE_CODE%"                response_flags: "%RESPONSE_FLAGS%"                client_ip: "%DOWNSTREAM_REMOTE_ADDRESS_WITHOUT_PORT%"                user_agent: "%REQ(USER-AGENT)%"                request_id: "%REQ(X-REQUEST-ID)%"                upstream_host: "%UPSTREAM_HOST%"                upstream_cluster: "%UPSTREAM_CLUSTER%"                upstream_local_address: "%UPSTREAM_LOCAL_ADDRESS%"このJSONフォーマットのログは、構造化されているため、Elasticsearchなどのログ分析ツールでより効率的に処理・分析できます。観測可能性データの活用著者は、収集した観測可能性データを実際にどのように活用するかについても詳しく説明しています。主な活用方法として、以下が挙げられています：パフォーマンス最適化: レイテンシメトリクスとトレースデータを使用して、ボトルネックを特定し、最適化問題のトラブルシューティング: エラーレートの急増やレイテンシスパイクの原因を特定容量計画: 長期的なトラフィックトレンドを分析し、適切なスケーリング戦略を立案セキュリティ監査: 異常なトラフィックパターンや不正アクセスの試みを検出SLO/SLAの監視: サービスレベル目標の達成状況をリアルタイムで監視著者は、これらの活用方法について具体的な例を挙げて説明しています。例えば、特定のAPIエンドポイントのレイテンシが急増した場合、以下のようなステップでトラブルシューティングを行うことができます：Grafanaダッシュボードでレイテンシメトリクスを確認し、問題の範囲と影響を特定Jaegerでトレースデータを分析し、どのサービスやコンポーネントが遅延の原因となっているかを特定関連するアクセスログを検索し、問題のリクエストの詳細な情報を確認必要に応じて、Istioの高度なルーティング機能を使用してトラフィックを迂回させ、問題の影響を最小限に抑えるこのような体系的なアプローチにより、複雑なマイクロサービス環境でも効率的に問題を特定・解決することができます。まとめ著者は、観測可能性がマイクロサービスアーキテクチャの成功に不可欠であることを強調しています。Istioの観測可能性機能は、複雑なシステムの挙動を理解し、問題を迅速に特定・解決するための強力なツールセットを提供します。しかし、著者は同時に、観測可能性は技術的な問題だけでなく、組織的な課題でもあることを指摘しています。効果的な観測可能性戦略を実装するためには、以下のような組織的な取り組みが必要です：観測可能性文化の醸成: チーム全体で観測可能性の重要性を理解し、日常的な開発・運用プロセスに組み込むスキルの向上: メトリクス、トレース、ログの効果的な利用方法について、継続的なトレーニングを実施ツールとプラクティスの標準化: 一貫した観測可能性アプローチを組織全体で採用自動化の推進: 観測可能性データの収集、分析、可視化プロセスを可能な限り自動化最後に、著者は将来の展望として、機械学習やAIを活用した高度な異常検知や予測分析の可能性に言及しています。これらの技術とIstioの観測可能性機能を組み合わせることで、さらに強力なシステム監視・最適化が可能になると予想されます。2024年現在の技術動向を踏まえると、本章で説明されている観測可能性の概念と実践は依然として有効であり、その重要性はさらに増しています。特に、OpenTelemetryの普及やクラウドネイティブ環境の複雑化に伴い、Istioの観測可能性機能はより一層重要になっています。8 Observability: Visualizing network behavior with Grafana, Jaeger, and Kiali「Istio in Action」の第8章は、Istioの観測可能性機能に焦点を当て、Grafana、Jaeger、Kialiといった強力なツールを用いてサービスメッシュの動作を可視化する方法を詳細に解説しています。この章で言葉は、観測可能性はデータを収集するだけでなく、そのデータから洞察を得てシステムのパフォーマンス、信頼性、ユーザーエクスペリエンスを向上させることに関するものです。この考え方は、観測可能性の本質を端的に表現しており、単なるモニタリングを超えた価値を強調しています。この章は実際の運用環境でIstioを効果的に活用するための実践的なガイドとして非常に価値があります。特に、複雑なマイクロサービス環境でのトラブルシューティングや性能最適化に必要な洞察を得るための具体的な方法が示されている点が印象的です。Grafanaを用いたメトリクスの可視化著者は、Grafanaを使用してIstioのメトリクスを可視化する方法を詳細に解説しています。Grafanaは、Prometheusが収集したメトリクスを視覚的に表現するためのツールとして紹介されています。このコマンドは、Istioの各種ダッシュボードをKubernetesのConfigMapとして作成します。これにより、Grafanaで簡単にIstioの状態を監視できるようになります。Figure 8.4 The control-plane dashboard with metrics graphed より引用この図は、Grafanaで表示されるIstioコントロールプレーンのダッシュボードを示しています。CPU使用率、メモリ使用率、goroutine数など、重要なメトリクスが視覚化されています。これらのダッシュボードは日常的な運用監視やトラブルシューティングに非常に有用です。例えば、コントロールプレーンのパフォーマンス問題や設定の同期状態を即座に確認できます。分散トレーシングとJaeger著者は、分散トレーシングの概念とJaegerを用いた実装方法について詳細に解説しています。分散トレーシングは、複数のマイクロサービスにまたがるリクエストの流れを追跡し、各サービスでの処理時間やエラーの発生箇所を特定するために不可欠な技術です。Jaegerをデプロイするための最新のYAMLファイルは、Istioの公式リポジトリから入手できます。github.com著者は、分散トレーシングを効果的に活用するためには、アプリケーションコードでトレースヘッダーを適切に伝播することが重要だと強調しています。以下は、Istioが自動的に生成するトレースヘッダーのリストです：x-request-idx-b3-traceidx-b3-spanidx-b3-parentspanidx-b3-sampledx-b3-flagsx-ot-span-contextこれらのヘッダーを適切に伝播することで、サービス間の呼び出しを正確にトレースできます。Figure 8.7 With distributed tracing, we can collect Span s for each network hop, capture them in an overall Trace, and use them to debug issues in our call graph. より引用この図は、分散トレーシングの概念を視覚的に表現しています。複数のサービスにまたがるリクエストの流れと、各サービスでの処理時間が明確に示されています。Figure 8.8 The application must propagate the tracing headers. Otherwise, we lose the full span of the request. より引用SREとして、この機能は特に複雑なマイクロサービス環境でのパフォーマンス問題やエラーの根本原因分析に非常に有効です。例えば、特定のAPI呼び出しが遅い原因が、どのサービスのどの処理にあるのかを迅速に特定できます。Kialiを用いたサービスメッシュの可視化著者は、Kialiを使用してIstioのサービスメッシュを可視化する方法を詳細に解説しています。Kialiは、サービス間の依存関係やトラフィックフローをリアルタイムで視覚化するツールとして紹介されています。Kialiの最新バージョンをデプロイするには、Helm chartを使用することが推奨されています。以下は、Kialiをデプロイするコマンドの例です：helm install \  --namespace kiali-operator \  --create-namespace \  --set cr.create=true \  --set cr.namespace=istio-system \  --repo https://kiali.org/helm-charts \  kiali-operator \  kiali-operatorこのコマンドは、KialiオペレーターとKialiインスタンスを同時にデプロイします。Kialiの主な機能として、以下が挙げられています：サービス間のトラフィックフローの可視化リアルタイムのヘルスステータス監視Istio設定のバリデーショントレースデータとメトリクスの相関分析Figure 8.15 Simple visual graph of the services in our namespace and how they’re connected to each other より引用この図は、Kialiで表示されるサービスメッシュのグラフビューを示しています。サービス間の依存関係とトラフィックフローが視覚的に表現されています。SREの観点からは、Kialiは特にトラブルシューティングと性能最適化に非常に有用です。例えば、特定のサービスへのトラフィック集中や、予期せぬサービス間の依存関係を視覚的に素早く把握できます。実践的な応用と提案Istioの観測可能性機能を効果的に活用するために、以下の実践的な提案を考えてみましょう：包括的な監視戦略の策定: Grafana、Jaeger、Kialiを組み合わせた包括的な監視戦略を策定します。各ツールの長所を活かし、相互補完的に使用することで、システムの状態をより完全に把握できます。カスタムダッシュボードの作成: Grafanaを使用して、ビジネス目標に直結するカスタムダッシュボードを作成します。例えば、特定のAPIのエラーレートとレイテンシを組み合わせたダッシュボードを作成し、SLOの達成状況を可視化します。トレースサンプリング戦略の最適化: 全てのリクエストをトレースするのではなく、適切なサンプリング戦略を設定します。例えば、エラーが発生したリクエストや特定の重要な処理パスを常にトレースし、それ以外はランダムサンプリングするなどの戦略が考えられます。アラートの適切な設定: メトリクスに基づいて適切なアラートを設定します。ただし、アラートの閾値は慎重に設定し、誤検知や警告疲れを避けるよう注意します。例えば、短期的なスパイクではなく、持続的な問題に対してアラートを発生させるよう設定します。サービスメッシュの健全性監視: Kialiを使用して、サービスメッシュ全体の健全性を定期的に監視します。特に、新しいサービスのデプロイ後や設定変更後には、予期せぬ影響がないか注意深く確認します。トレースデータの分析自動化: Jaegerのトレースデータを自動的に分析し、パフォーマンス低下やエラー増加のパターンを検出するスクリプトを作成します。これにより、問題を早期に発見し、プロアクティブに対応できます。observability-as-codeの実践: 監視設定やダッシュボード定義をコード化し、バージョン管理システムで管理します。これにより、環境間での一貫性を保ち、設定変更の追跡を容易にします。チーム間の知識共有: 定期的なワークショップやドキュメンテーションの更新を通じて、チーム全体でIstioの観測可能性機能に関する知識を共有します。これにより、全てのチームメンバーが効果的にツールを活用できるようになります。まとめ「Istio in Action」の第8章は、Istioの観測可能性機能を実践的に活用するための包括的なガイドを提供しています。Grafana、Jaeger、Kialiといった強力なツールを組み合わせることで、複雑なマイクロサービス環境の動作を詳細に把握し、効果的に管理することが可能になります。著者は、これらのツールを単に導入するだけでなく、実際の運用シナリオでどのように活用するかを具体的に示しています。例えば、Grafanaのダッシュボードを使用してシステムの全体的な健全性を監視し、異常が検出された場合にJaegerのトレースデータを分析してボトルネックを特定し、最後にKialiを使用してサービス間の依存関係を視覚的に確認するといった、総合的なトラブルシューティングアプローチが提案されています。特に印象的だったのは、著者が観測可能性を単なる技術的な課題ではなく、ビジネス価値に直結する重要な要素として位置づけている点です。例えば、トレースデータを活用してユーザーエクスペリエンスの改善につなげたり、Kialiの可視化機能を使用してサービス間の依存関係を最適化したりするなど、観測可能性がビジネスの成功に直接貢献する方法が示されています。9 Securing microservice communication「Istio in Action」の第9章は、マイクロサービスアーキテクチャにおける重要な課題の一つであるセキュリティに焦点を当てています。著者は、Istioが提供する強力なセキュリティ機能を詳細に解説し、サービス間通信の認証、認可、暗号化をどのように実現するかを具体的な例を交えて説明しています。この辺についてはIstioを使わない場合だとマイクロサービス間通信における認証認可およびアクセス制御が良いのでオススメです。zenn.devこの章で特に印象に残ったのは、「Istioはセキュアバイデフォルト」という概念です。これは、Istioがデフォルトで高度なセキュリティ機能を提供し、開発者が意識しなくてもある程度のセキュリティを確保できることを意味しています。しかし、同時に著者は、真のセキュリティを実現するためには、これらの機能を適切に理解し、設定する必要があることも強調しています。Figure 9.1 Monolithic application running on-premises with static IPs より引用この図は、オンプレミス環境で静的IPを使用して運用されるモノリシックアプリケーションを示しています。静的なインフラストラクチャでは、IPアドレスが信頼の良い源となり、認証のための証明書や、ネットワークファイアウォールルールで一般的に使用されます。この環境では、セキュリティの管理が比較的単純です。しかし、著者は続けて、マイクロサービスアーキテクチャへの移行に伴う課題を説明しています。マイクロサービスは容易に数百、数千のサービスに成長し、静的な環境での運用が困難になります。そのため、チームはクラウドコンピューティングやコンテナオーケストレーションなどの動的な環境を活用し、サービスは多数のサーバーにスケジュールされ、短命になります。これにより、IPアドレスを使用する従来の方法は信頼できない識別子となります。さらに、サービスは必ずしも同じネットワーク内で実行されるわけではなく、異なるクラウドプロバイダーやオンプレミスにまたがる可能性があります。この変化は重要です。静的な環境からダイナミックな環境への移行は、セキュリティの実装方法を根本的に変える必要があることを意味します。特に、サービス間認証（mTLS）、エンドユーザー認証（JWT）、細かな認可ポリシーの設定など、現代のクラウドネイティブアプリケーションに不可欠なセキュリティ機能が重要になってきます。サービス間認証（mTLS）著者は、Istioのサービス間認証機能、特に相互TLS（mTLS）について詳細に解説しています。mTLSは、サービス間の通信を暗号化するだけでなく、通信の両端を相互に認証することで、非常に高度なセキュリティを実現します。Figure 9.4 Workloads mutually authenticate using SVID certificates issued by the Istio certificate authority. より引用この図は、Istioの証明書機関（CA）によって発行されたSPIFFE Verifiable Identity Document（SVID）証明書を使用して、ワークロードが相互に認証する様子を示しています。これにより、サービス間のトラフィックが暗号化され、相互に認証されることで、「セキュアバイデフォルト」の状態が実現されます。Istioでは、PeerAuthenticationリソースを使用してmTLSを設定します。例えば、以下のような設定でメッシュ全体にmTLSを強制適用できます：apiVersion: "security.istio.io/v1beta1"kind: "PeerAuthentication"metadata:  name: "default"  namespace: "istio-system"spec:  mtls:    mode: STRICTこの設定により、メッシュ内のすべてのサービス間通信がmTLSで保護されます。著者は、この設定の影響を実際のトラフィックフローを用いて説明しており、特に印象的でした。しかし、著者は同時に、既存のシステムへのmTLSの導入には注意が必要であることも強調しています。急激な変更はシステムの安定性を脅かす可能性があるため、PERMISSIVEモードを使用した段階的な導入が推奨されています。SREの観点からは、この段階的アプローチは非常に重要です。本番環境でのセキュリティ強化は、サービスの可用性とのバランスを取りながら慎重に進める必要があります。エンドユーザー認証（JWT）著者は、Istioのエンドユーザー認証機能、特にJSON Web Token（JWT）を使用した認証について詳細に解説しています。この機能により、マイクロサービスは個別に認証ロジックを実装することなく、一貫したエンドユーザー認証を実現できます。Figure 9.12 The server retrieves a JWKS to validate the token presented by the client. より引用この図は、サーバーがJWKS（JSON Web Key Set）を使用してクライアントから提示されたトークンを検証するプロセスを示しています。JWKSには公開鍵が含まれており、これを使用してトークンの署名を検証することで、トークンの真正性を確認します。このプロセスにより、トークンのクレームを信頼し、認可決定に使用することができます。Istioでは、RequestAuthenticationリソースを使用してJWT認証を設定します。例えば：apiVersion: "security.istio.io/v1beta1"kind: "RequestAuthentication"metadata: name: "jwt-token-request-authn" namespace: istio-systemspec:  selector:    matchLabels:      app: istio-ingressgateway jwtRules: - issuer: "auth@istioinaction.io"   jwks: |     { "keys": [{"e":"AQAB","kid":"##REDACTED##",      "kty":"RSA","n":"##REDACTED##"}]}この設定により、指定されたアプリケーションへのリクエストにJWTが要求されます。著者は、この設定の影響を実際のリクエストフローを用いて説明しており、非常に分かりやすい解説でした。特に印象的だったのは、著者がJWTの検証だけでなく、JWT claimsを使用した細かな認可制御についても言及している点です。これにより、ユーザーの役割や権限に基づいた詳細なアクセス制御が可能になります。認可ポリシー著者は、Istioの認可ポリシー機能について詳細に解説しています。この機能により、サービス間やエンドユーザーのアクセス制御を非常に細かいレベルで設定できます。Figure 9.9 Authorization reduces the attack scope to only what the stolen identity was authorized to access. より引用この図は、認可ポリシーがどのようにしてセキュリティインシデントの影響範囲を限定するかを示しています。適切な認可ポリシーを設定することで、アイデンティティが盗まれた場合でも、アクセス可能な範囲を最小限に抑えることができます。これは、最小権限の原則を実践する上で非常に重要な機能です。Istioでは、AuthorizationPolicyリソースを使用して認可ポリシーを設定します。例えば：apiVersion: "security.istio.io/v1beta1"kind: "AuthorizationPolicy"metadata:  name: "allow-mesh-all-ops-admin"  namespace: istio-systemspec:  rules:    - from:      - source:          requestPrincipals: ["auth@istioinaction.io/*"]      when:      - key: request.auth.claims[group]        values: ["admin"]この設定により、特定の発行者（"auth@istioinaction.io"）からのJWTを持ち、"admin"グループに属するユーザーのみがアクセスを許可されます。著者は、この機能の柔軟性と強力さを強調しており、特に印象的でした。例えば、特定のパスへのアクセス、特定のHTTPメソッドの使用、特定のヘッダーの存在など、非常に詳細な条件に基づいてアクセスを制御できます。SREの観点からは、この細かな制御は非常に重要です。最小権限の原則に基づいてアクセスを制限することで、セキュリティインシデントの影響範囲を最小限に抑えることができます。外部認可サービスとの統合著者は、Istioの外部認可サービス統合機能についても解説しています。この機能により、より複雑な認可ロジックや、既存の認可システムとの統合が可能になります。Figure 9.13 Using CUSTOM policies to get requests authorized by an external server より引用この図は、Istioが外部の認可サーバーを使用してリクエストを認可する方法を示しています。サービスプロキシに入ってくるリクエストは、外部認可（ExtAuthz）サービスへの呼び出しを行う間、一時停止します。この ExtAuthz サービスはメッシュ内、アプリケーションのサイドカーとして、あるいはメッシュの外部に存在する可能性があります。これにより、組織固有の複雑な認可ロジックを実装することが可能になります。例えば、以下のようなAuthorizationPolicyを使用して外部認可サービスを設定できます：apiVersion: security.istio.io/v1beta1kind: AuthorizationPolicymetadata:  name: ext-authz  namespace: istioinactionspec:  selector:    matchLabels:      app: webapp  action: CUSTOM  provider:    name: sample-ext-authz-http  rules:  - to:    - operation:        paths: ["/"]この設定により、指定されたパスへのリクエストは外部の認可サービスによって評価されます。著者は、この機能の柔軟性と強力さを強調しており、特に印象的でした。例えば、複雑なビジネスロジックに基づく認可や、既存の認証システムとの統合など、Istioの標準機能では難しい要件にも対応できます。しかし、著者は同時に、外部認可サービスの使用にはパフォーマンスのトレードオフがあることも指摘しています。外部サービスへの呼び出しは追加のレイテンシを引き起こす可能性があるため、慎重な設計と最適化が必要です。実践的な応用と提案Istioのセキュリティ機能を効果的に活用するために、以下の実践的な提案を考えてみましょう：段階的な導入戦略の策定: アンビエントメッシュの特性を活かし、既存のサイドカーベースの導入から段階的に移行する計画を立てます。これにより、リスクを最小限に抑えつつ、新しいアーキテクチャの利点を享受できます。ゼロトラスト原則の適用: Istioの細かな認証・認可機能を活用し、全てのサービス間通信に対して「信頼しない」デフォルトポリシーを適用します。必要な通信のみを明示的に許可するアプローチを採用します。動的ポリシー管理の実装: セキュリティポリシーの動的更新機能を活用し、CI/CDパイプラインにセキュリティポリシーの更新プロセスを組み込みます。これにより、アプリケーションの変更に合わせてセキュリティ設定を自動的に更新できます。統合監視・ログ分析の強化: Istioの高度な可観測性機能を活用し、セキュリティイベントの統合監視とログ分析システムを構築します。これにより、セキュリティインシデントの早期検出と迅速な対応が可能になります。定期的なセキュリティ評価の実施: Istioの設定とセキュリティポリシーを定期的に評価し、最新のベストプラクティスや脅威情報に基づいて最適化します。自動化されたセキュリティテストをCI/CDプロセスに組み込むことも検討します。クロスファンクショナルなセキュリティチームの編成: 開発者、運用者、セキュリティ専門家で構成されるクロスファンクショナルなチームを編成し、Istioのセキュリティ機能の設計、実装、運用を協力して行います。これにより、セキュリティを開発ライフサイクルの早い段階から考慮に入れることができます。外部認証サービスのパフォーマンス最適化: 外部認証サービスを使用する場合は、キャッシング戦略の導入や、認証サービスのスケーリングを適切に行い、パフォーマンスへの影響を最小限に抑えます。継続的な学習と能力開発: Istioの進化に合わせて、チームのスキルセットを継続的に更新します。Istioのコミュニティイベントへの参加や、社内トレーニングの実施を検討します。これらの提案を実践することで、Istioのセキュリティ機能を最大限に活用し、より安全で管理しやすいマイクロサービス環境を構築することができるでしょう。まとめ「Istio in Action」の第9章は、Istioのセキュリティ機能について包括的かつ実践的な解説を提供しています。著者は、サービス間認証（mTLS）、エンドユーザー認証（JWT）、細かな認可ポリシーの設定、外部認可サービスとの統合など、現代のマイクロサービスアーキテクチャに不可欠なセキュリティ機能を詳細に説明しています。2024年現在の技術動向と比較すると、Istioのセキュリティ機能はさらに進化し、より柔軟で強力になっています。特に、アンビエントメッシュの導入やゼロトラストアーキテクチャのサポート強化は、大規模環境でのセキュリティ管理を大幅に改善しています。Istioは複雑なマイクロサービス環境におけるセキュリティ課題に対する強力なソリューションを提供しています。しかし、その効果的な活用には、継続的な学習と、組織全体でのセキュリティ文化の醸成が不可欠です。Istioのセキュリティ機能は、マイクロサービスアーキテクチャにおけるセキュリティの複雑さを大幅に軽減し、一貫したセキュリティポリシーの適用を可能にします。しかし、同時に著者が強調しているように、これらの機能を効果的に活用するためには、適切な計画と継続的な管理が必要です。最後に、この章から得られる重要な教訓は、セキュリティは単なる技術的な課題ではなく、システム設計、運用プラクティス、そして組織文化全体に関わる問題だということです。Istioは強力なツールを提供しますが、それを効果的に活用するためには、継続的な学習、実験、そして最適化が不可欠です。今後も進化し続けるIstioとともに、セキュリティもまた進化し続ける必要があるのです。Part 3 Istio day-2 operations10 Troubleshooting the data plane「Istio in Action」の第10章「Troubleshooting the data plane」は、Istioのデータプレーンに関するトラブルシューティングについて詳細に解説しています。この章は、実際の運用環境でIstioを使用する際に直面する可能性のある問題に焦点を当て、それらを効果的に診断し解決するための方法を提供しています。Figure 10.1 Components that participate in routing a request より引用特に印象に残ったのは、著者が繰り返し強調している「プロアクティブなトラブルシューティング」の重要性です。著者は、「デバッグのためのデータプレーンの準備は、実際に問題が発生する前に行うべきだ」と述べています。この言葉は、SREの原則である「事後対応よりも予防」を端的に表現しており、Istioの運用におけるベストプラクティスを示唆しています。技術的詳細と実践的応用データプレーンの同期状態の確認著者は、Istioのデータプレーンのトラブルシューティングを始める前に、まずデータプレーンが最新の設定と同期しているかを確認することの重要性を強調しています。これには、istioctl proxy-statusコマンドが使用されます。$ istioctl proxy-statusNAME                                      CDS      LDS      EDS        RDS          ISTIOD      VERSIONcatalog-68666d4988-q6w42.istioinaction    SYNCED   SYNCED   SYNCED     SYNCED       istiod-1...  1.22.0このコマンドの出力は、各Envoyプロキシが最新の設定（CDS, LDS, EDS, RDS）と同期しているかを示します。SYNCED状態は正常であり、NOT SENTやSTALEは潜在的な問題を示唆します。著者は、この同期状態の確認が重要である理由を次のように説明しています：データプレーンの設定は最終的に一貫性のあるものですが、即時に反映されるわけではありません。環境の変化（サービス、エンドポイント、ヘルスステータスの変更）や設定の変更は、データプレーンに即座に反映されるわけではありません。大規模なクラスターでは、同期に要する時間がワークロードとイベントの数に比例して増加します。Figure 10.3 Series of events until the configuration of a data-plane component is updated after a workload becomes unhealthy より引用Figure 10.3は、ワークロードが不健全になってからデータプレーンコンポーネントの設定が更新されるまでの一連のイベントを示しています。この図は、設定の同期プロセスの複雑さを視覚的に表現しており、同期状態の確認が重要である理由を理解する上で非常に有用です。SREの視点から、この同期状態の確認は非常に重要です。設定の不整合は予期せぬ動作やエラーの原因となる可能性があるため、定期的な確認とモニタリングを自動化することをおすすめします。Kialiを使用した設定の検証著者は、Kialiを使用してIstioの設定を視覚的に検証する方法を紹介しています。Kialiは、サービスメッシュの状態を可視化し、潜在的な問題を特定するのに役立ちます。$ istioctl dashboard kialihttp://localhost:20001/kialiこのコマンドでKialiダッシュボードにアクセスできます。Kialiの使用は、特に大規模なマイクロサービス環境で非常に有効です。視覚的な表現により、複雑な依存関係やトラフィックパターンを素早く把握でき、問題の早期発見に役立ちます。Envoy設定の詳細分析著者は、Envoyプロキシの設定を詳細に分析する方法について深く掘り下げています。istioctl proxy-configコマンドを使用して、特定のプロキシの設定を検査できます。例えば、特定のサービスのリスナー設定を確認するには：$ istioctl proxy-config listeners deploy/istio-ingressgateway -n istio-systemADDRESS PORT  MATCH DESTINATION0.0.0.0 8080  ALL   Route: http.80800.0.0.0 15021 ALL   Inline Route: /healthz/ready*0.0.0.0 15090 ALL   Inline Route: /stats/prometheus*このコマンドは、指定されたデプロイメントのEnvoyプロキシに設定されているリスナーを表示します。著者は、この出力を詳細に解説し、各リスナーの役割と重要性を説明しています。さらに、ルート設定を確認するには：$ istioctl pc routes deploy/istio-ingressgateway -n istio-system --name http.8080 -o json著者は、このコマンドの出力を詳細に解説し、ルーティングの設定がどのように行われているかを説明しています。特に、重み付けされたクラスターの設定や、マッチングルールの詳細について触れています。これらのコマンドを使いこなすことで、トラフィックの流れを詳細に理解し、ルーティングの問題を特定することができます。SREとして、これらのツールを使用して定期的に設定を監査し、意図しない変更や設定ミスを検出することが重要です。アクセスログの活用著者は、Envoyプロキシのアクセスログの重要性と、それを効果的に活用する方法について詳しく説明しています。アクセスログは、リクエストの詳細な情報を提供し、トラブルシューティングに不可欠です。著者は、デフォルトのTEXTフォーマットのログが簡潔であるが理解しにくいことを指摘し、JSONフォーマットへの変更を推奨しています。以下は、JSONフォーマットに変更する方法です：$ istioctl install --set profile=demo \    --set meshConfig.accessLogEncoding="JSON"JSONフォーマットのログの例：{  "user_agent":"curl/7.64.1",  "Response_code":"504",  "response_flags":"UT",  "start_time":"2020-08-22T16:35:27.125Z",  "method":"GET",  "request_id":"e65a3ea0-60dd-9f9c-8ef5-42611138ba07",  "upstream_host":"10.1.0.68:3000",  "x_forwarded_for":"192.168.65.3",  "requested_server_name":"-",  "bytes_received":"0",  "istio_policy_status":"-",  "bytes_sent":"24",  "upstream_cluster":    "outbound|80|version-v2|catalog.istioinaction.svc.cluster.local",  "downstream_remote_address":"192.168.65.3:41260",  "authority":"catalog.istioinaction.io",  "path":"/items",  "protocol":"HTTP/1.1",  "upstream_service_time":"-",  "upstream_local_address":"10.1.0.69:48016",  "duration":"503",  "upstream_transport_failure_reason":"-",  "route_name":"-",  "downstream_local_address":"10.1.0.69:8080"}著者は、このJSONフォーマットのログの各フィールドの意味を詳細に解説しています。特に、response_flagsフィールドの重要性を強調しており、このフィールドが接続の失敗に関する詳細情報を提供することを説明しています。SREの観点からは、このようなカスタマイズされたログ設定は非常に有用です。特定の条件に基づいてログをフィルタリングすることで、問題の迅速な特定と分析が可能になります。また、ログの集中管理と分析のために、ElasticsearchやSplunkなどのログ管理システムとの統合も検討すべきです。まとめ「Istio in Action」の第10章は、Istioのデータプレーンのトラブルシューティングに関する包括的かつ実践的なガイドを提供しています。著者は、プロアクティブなアプローチの重要性を強調し、問題が発生する前に潜在的な課題を特定し対処することの価値を説いています。この章では、istioctl、Kiali、Envoyの管理インターフェースなど、Istioが提供する豊富なツールセットの効果的な活用方法が詳細に解説されています。これらのツールを適切に使用することで、複雑なマイクロサービス環境での問題診断と解決が大幅に効率化されることが示されています。特に印象的なのは、著者がデータプレーンの同期状態の確認、Envoy設定の詳細分析、アクセスログの活用など、実践的なテクニックを具体的に示している点です。これらの手法は、実際の運用環境で即座に適用可能で、大きな価値があります。著者は、効果的なトラブルシューティングには単なる技術的スキルだけでなく、システム全体を理解し、プロアクティブに問題解決に取り組む姿勢が重要であることを強調しています。この観点は、特に複雑化するマイクロサービス環境において非常に重要です。2024年現在、IstioはアンビエントメッシュやWebAssemblyの進化など、さらなる発展を遂げています。これらの新技術は、トラブルシューティングの手法にも影響を与えており、より効率的で柔軟なアプローチが可能になっています。結論として、この章はIstioのデータプレーンのトラブルシューティングを単なる技術的タスクではなく、継続的な改善プロセスとして捉えることの重要性を示しています。効果的なトラブルシューティング文化を醸成し、チーム全体でスキルとナレッジを共有することが、長期的な運用の成功につながるのです。この章で学んだテクニックと原則を適用し、継続的に改善していくことで、より安定性の高い、レジリエントなシステムを構築・運用することができるでしょう。11 Performance-tuning the control plane「Istio in Action」の第11章は、Istioのコントロールプレーンのパフォーマンス最適化に焦点を当てています。著者は、コントロールプレーンがサービスプロキシを設定する方法、このプロセスを遅くする要因、監視方法、そしてパフォーマンスを向上させるための調整ポイントを詳細に解説しています。特に印象に残ったのは、著者が繰り返し強調している「プロアクティブなパフォーマンス管理」の重要性です。著者は、「デバッグのためのデータプレーンの準備は、実際に問題が発生する前に行うべきだ」と述べています。この考え方は、SREの原則である「事後対応よりも予防」を端的に表現しており、Istioの運用におけるベストプラクティスを示唆しています。技術的詳細と実践的応用コントロールプレーンの目標著者は、コントロールプレーンの主要な目標を「データプレーンを望ましい状態に同期させ続けること」と定義しています。この同期プロセスが適時に行われないと、ファントムワークロードという現象が発生する可能性があります。これは、既に存在しないエンドポイントにトラフィックがルーティングされ、結果としてリクエストが失敗する状況を指します。Figure 11.1 Routing traffic to phantom workloads due to an outdated configuration より引用この図は、ワークロードの状態変化、設定更新の遅延、そして古い設定に基づくトラフィックルーティングの問題を明確に示しています。SREの観点からは、この問題は特に重要です。システムの一貫性と信頼性を維持するために、コントロールプレーンのパフォーマンスを常に監視し、最適化する必要があります。パフォーマンスに影響を与える要因著者は、コントロールプレーンのパフォーマンスに影響を与える主な要因を以下のように特定しています：変更の頻度: 環境の変更が頻繁に発生すると、データプレーンの同期に必要な処理が増加します。割り当てられたリソース: istiodに割り当てられたリソースが需要に対して不足すると、更新の配布が遅くなります。管理対象ワークロードの数: 更新を配布するワークロードが多いほど、より多くの処理能力とネットワーク帯域幅が必要になります。設定のサイズ: より大きなEnvoy設定の配布には、より多くの処理能力とネットワーク帯域幅が必要です。Figure 11.3 The properties that affect control-plane performance より引用この図はこれらの要因を視覚的に表現しています。この図は、コントロールプレーンのパフォーマンスに影響を与える各要素の関係を明確に示しており、パフォーマンス最適化の戦略を立てる上で非常に有用です。パフォーマンスモニタリング著者は、Grafanaダッシュボードを使用してIstioのコントロールプレーンのパフォーマンスを監視する方法を詳細に解説しています。特に、4つのゴールデンシグナル（レイテンシ、飽和度、エラー、トラフィック）に基づいたモニタリングアプローチを推奨しています。例えば、レイテンシを測定するための主要なメトリクスとしてpilot_proxy_convergence_timeが挙げられています。このメトリクスは、プロキシプッシュリクエストがキューに入ってから、ワークロードに配布されるまでの全プロセスの所要時間を測定します。apiVersion: telemetry.istio.io/v1alpha1kind: Telemetrymetadata:  name: custom-metrics  namespace: istio-systemspec:  metrics:  - providers:    - name: prometheus    overrides:    - match:        metric: PILOT_PROXY_CONVERGENCE_TIME      tagOverrides:        response_code:          value: "response.code"この設定例は、Istio 1.22（2024年8月現在の最新版）に合わせて更新されています。これにより、pilot_proxy_convergence_timeメトリクスをカスタマイズし、より詳細な分析が可能になります。SREとして、これらのメトリクスを継続的に監視し、異常を早期に検出することが重要です。例えば、pilot_proxy_convergence_timeが突然増加した場合、コントロールプレーンの設定更新プロセスに問題が発生している可能性があり、即時の調査が必要です。パフォーマンス最適化技術著者は、コントロールプレーンのパフォーマンスを最適化するための複数の技術を紹介しています：Sidecarリソースの使用: 著者は、Sidecarリソースを使用してワークロードのイングレスとイグレストラフィックを細かく制御することの重要性を強調しています。これにより、各ワークロードに送信される設定のサイズを大幅に削減できます。apiVersion: networking.istio.io/v1beta1kind: Sidecarmetadata:  name: default  namespace: istio-systemspec:  egress:  - hosts:    - "istio-system/*"    - "prometheus/*"  outboundTrafficPolicy:    mode: REGISTRY_ONLYこの設定例は、メッシュ全体のデフォルトSidecar設定を定義しています。これにより、各サービスプロキシの設定サイズが大幅に削減され、コントロールプレーンの負荷が軽減されます。イベントのバッチ処理: 著者は、PILOT_DEBOUNCE_AFTERとPILOT_DEBOUNCE_MAX環境変数を使用してイベントのバッチ処理を最適化する方法を説明しています。これにより、頻繁な更新による負荷を軽減できます。リソースの割り当て: コントロールプレーンのスケールアウトとスケールアップの戦略について詳細に解説されています。著者は、出力トラフィックがボトルネックの場合はスケールアウト、入力トラフィックがボトルネックの場合はスケールアップを推奨しています。istioctl install --set profile=demo \  --set values.pilot.resources.requests.cpu=2 \  --set values.pilot.resources.requests.memory=4Gi \  --set values.pilot.replicaCount=3この設定例は、istiodのリソース要求とレプリカ数を増やしています。これにより、コントロールプレーンの処理能力と冗長性が向上します。実践的な応用と提案Istioのコントロールプレーンのパフォーマンスを最適化するために、以下の実践的な提案を考えてみましょう：継続的なモニタリングの実装: Prometheusとgrafanaを使用して、コントロールプレーンの主要メトリクス（pilot_proxy_convergence_time、pilot_xds_pushesなど）を継続的に監視します。異常値の検出時に自動アラートを設定することで、問題の早期発見と対応が可能になります。段階的なSidecar設定の導入: まず、メッシュ全体のデフォルトSidecar設定を導入し、その後各サービスに特化したSidecar設定を段階的に実装します。これにより、設定サイズと更新頻度を大幅に削減できます。イベントバッチ処理の最適化: 環境変数PILOT_DEBOUNCE_AFTERとPILOT_DEBOUNCE_MAXを調整し、イベントのバッチ処理を最適化します。ただし、過度の遅延を避けるため、慎重に調整する必要があります。リソース割り当ての定期的な見直し: コントロールプレーンのCPUとメモリ使用率を定期的に確認し、必要に応じてリソースを調整します。特に、クラスターの成長に合わせて、istiodのレプリカ数を適切に増やすことが重要です。パフォーマンステストの自動化: 定期的にパフォーマンステストを実行し、設定変更やクラスターの成長がコントロールプレーンのパフォーマンスに与える影響を評価します。これにより、プロアクティブな最適化が可能になります。アンビエントメッシュの検討: 大規模環境では、アンビエントメッシュの採用を検討します。これにより、コントロールプレーンの負荷を大幅に軽減し、より効率的なリソース利用が可能になります。まとめ「Istio in Action」の第11章は、Istioのコントロールプレーンのパフォーマンス最適化について包括的かつ実践的な洞察を提供しています。著者は、パフォーマンスに影響を与える要因を明確に特定し、それぞれに対する最適化戦略を提示しています。特に印象的だったのは、著者がパフォーマンス最適化を単なる技術的な問題ではなく、システム設計と運用プラクティス全体に関わる課題として捉えている点です。Sidecarリソースの適切な使用、イベントのバッチ処理、リソース割り当ての最適化など、提案された戦略は、いずれも実際の運用環境で即座に適用可能で大きな価値があります。SREの観点からは、この章で提示されたモニタリングアプローチと最適化技術は非常に重要です。4つのゴールデンシグナルに基づいたモニタリング、継続的なパフォーマンス測定、そして段階的な最適化アプローチは、大規模なマイクロサービス環境での安定性と効率性を維持する上で不可欠です。2024年現在の技術動向を踏まえると、本章で説明されている原則は依然として有効ですが、アンビエントメッシュやWaypoint Proxyなどの新技術により、さらに効率的なパフォーマンス最適化が可能になっています。これらの新技術を適切に活用することで、より大規模で複雑な環境でもIstioを効果的に運用できるようになっています。Part 4 Istio in your organization12 Scaling Istio in your organization「Istio in Action」の第12章は、Istioを組織内で大規模に展開する方法に焦点を当てています。著者は、マルチクラスター環境でのIstioの導入、クラスター間の通信の確立、そしてサービスメッシュの拡張について詳細に解説しています。特に印象に残ったのは、著者が繰り返し強調している「メッシュの価値は、より多くのワークロードがそれに参加するほど増加する」という考え方です。この言葉は、Istioの導入を単なる技術的な課題ではなく、組織全体のアーキテクチャ戦略として捉える重要性を示唆しています。マルチクラスターサービスメッシュの利点著者は、マルチクラスターサービスメッシュの主な利点を以下のように説明しています：改善された分離: チーム間の影響を最小限に抑える障害の境界: クラスター全体に影響を与える可能性のある設定や操作の範囲を制限する規制とコンプライアンス: センシティブなデータにアクセスするサービスを他のアーキテクチャ部分から制限する可用性とパフォーマンスの向上: 異なる地域でクラスターを実行し、最も近いクラスターにトラフィックをルーティングするマルチクラウドとハイブリッドクラウド: 異なる環境でワークロードを実行する能力これらの利点は、現代の複雑な分散システム環境において非常に重要です。特に、SREの観点からは、可用性の向上と障害の局所化は、システムの信頼性を大幅に向上させる可能性があります。Figure 12.1 A multi-cluster service mesh requires cross-cluster discovery, connectivity, and common trust. より引用この図は、クラスター間の発見、接続性、共通信頼の重要性を視覚的に表現しており、マルチクラスター環境の複雑さを理解する上で非常に有用です。技術的詳細と実践的応用マルチクラスター導入モデル著者は、Istioのマルチクラスター導入モデルを3つに分類しています：プライマリ-リモート（共有コントロールプレーン）Figure 12.2 Primary-remote deployment model より引用プライマリ-プライマリ（複製されたコントロールプレーン）Figure 12.3 Primary-primary deployment model より引用外部コントロールプレーンFigure 12.4 The external control plane deployment model より引用これらのモデルの中で、著者は特にプライマリ-プライマリモデルに焦点を当てています。このモデルでは、各クラスターに独自のIstioコントロールプレーンが存在し、高可用性を実現しています。クラスター間のワークロード発見著者は、クラスター間でのワークロード発見のメカニズムを詳細に説明しています。特に興味深いのは、Kubernetes APIサーバーへのアクセスを制御するためのRBACの使用です。apiVersion: v1kind: Secretmetadata:  name: istio-remote-secret-east-cluster  namespace: istio-systemstringData:  east-cluster: |    apiVersion: v1    kind: Config    clusters:    - cluster:        certificate-authority-data: <omitted>        server: https://east-cluster-api-server:443      name: east-cluster    users:    - name: east-cluster      user:        token: <omitted>    contexts:    - context:        cluster: east-cluster        user: east-cluster      name: east-cluster    current-context: east-clusterこのサンプルコードは、リモートクラスターへのアクセスを設定するためのシークレットを示しています。これは、Istio 1.22（2024年8月現在の最新版）でも同様に使用されています。このアプローチにより、クラスター間で安全にワークロードを発見し、通信を確立することができます。クラスター間の接続性著者は、クラスター間の接続性を確立するためのイースト-ウェストゲートウェイの概念を導入しています。これは、異なるネットワーク間でトラフィックをルーティングするための特別なIngressゲートウェイです。apiVersion: install.istio.io/v1alpha1kind: IstioOperatormetadata:  name: istio-eastwestgateway  namespace: istio-systemspec:  profile: empty  components:    ingressGateways:    - name: istio-eastwestgateway      label:        istio: eastwestgateway      enabled: true      k8s:        env:          - name: ISTIO_META_ROUTER_MODE            value: "sni-dnat"このサンプルコードは、イースト-ウェストゲートウェイの設定を示しています。ISTIO_META_ROUTER_MODEをsni-dnatに設定することで、SNIベースのルーティングが有効になり、クラスター間のトラフィックを効率的に管理できます。クラスター間の認証と認可著者は、クラスター間の通信を保護するための相互TLS（mTLS）の使用と、クラスター間での認可ポリシーの適用について詳細に説明しています。apiVersion: security.istio.io/v1beta1kind: AuthorizationPolicymetadata:  name: allow-only-ingress  namespace: istioinactionspec:  action: ALLOW  rules:  - from:    - source:        principals: ["cluster.local/ns/istio-system/sa/istio-ingressgateway-service-account"]このサンプルコードは、特定のソース（この場合はIngressゲートウェイ）からのトラフィックのみを許可する認可ポリシーを示しています。これにより、クラスター間でのセキュアな通信が可能になります。実践的な応用と提案Istioのマルチクラスター機能を効果的に活用するために、以下の実践的な提案を考えてみましょう：段階的な導入戦略: まず小規模なプロジェクトでマルチクラスター設定を試験的に導入し、徐々に範囲を拡大していくことをおすすめします。これにより、チームはマルチクラスター環境の複雑さに慣れることができ、潜在的な問題を早期に特定できます。ネットワークトポロジーの最適化: クラスター間のレイテンシーを最小限に抑えるため、地理的に分散したクラスターの配置を慎重に計画します。例えば、主要な顧客基盤に近い場所にクラスターを配置することで、全体的なパフォーマンスを向上させることができます。セキュリティポリシーの統一: マルチクラスター環境全体で一貫したセキュリティポリシーを実装します。これには、共通のmTLS設定、統一された認可ポリシー、そしてクラスター間での証明書管理の調和が含まれます。観測可能性の強化: Istioの観測可能性機能を活用し、クラスター間のトラフィックフローを包括的に可視化します。Grafana、Jaeger、Kialiなどのツールを統合し、マルチクラスター環境全体のパフォーマンスと健全性を監視します。災害復旧計画の策定: マルチクラスター環境の利点を活かし、強固な災害復旧計画を策定します。これには、クラスター間でのトラフィックの動的な再ルーティング、データの地理的レプリケーション、そして自動フェイルオーバーメカニズムの実装が含まれます。継続的な学習と最適化: マルチクラスター環境は複雑であり、常に進化しています。定期的な性能評価、セキュリティ監査、そして新しいIstioの機能やベストプラクティスの採用を通じて、環境を継続的に最適化します。まとめ「Istio in Action」の第12章は、Istioを用いたマルチクラスターサービスメッシュの実装について包括的かつ実践的な洞察を提供しています。著者は、マルチクラスター環境の利点、技術的な課題、そして具体的な実装方法を詳細に解説しており、読者に豊富な知識と実践的なガイダンスを提供しています。特に印象的だったのは、著者がマルチクラスター環境を単なる技術的な課題ではなく、組織全体のアーキテクチャ戦略として捉えている点です。改善された分離、障害の局所化、規制対応、そして地理的な可用性の向上など、マルチクラスターアプローチの多岐にわたる利点は、現代の複雑なマイクロサービス環境において非常に価値があります。SREの観点からは、この章で提示されたマルチクラスター戦略は、システムの信頼性、可用性、そしてスケーラビリティを大幅に向上させる可能性を秘めています。特に、地理的に分散したクラスター間でのトラフィック管理、セキュリティポリシーの統一的な適用、そして包括的な観測可能性の実現は、大規模で複雑な分散システムの運用を大幅に簡素化します。2024年現在の技術動向を踏まえると、本章で説明されている原則は依然として有効ですが、アンビエントメッシュやKubernetes Gateway APIのサポートなど、新しい機能によりさらに強化されています。これらの新技術は、マルチクラスター環境でのIstioの採用をより容易にし、より効率的な運用を可能にしています。最後に、この章から得られる重要な教訓は、マルチクラスターサービスメッシュの実装は技術的な課題であると同時に、組織的な課題でもあるということです。成功のためには、技術チーム間の緊密な協力、明確なガバナンスモデル、そして継続的な学習と最適化が不可欠です。13 Incorporating virtual machine workloads into the mesh「Istio in Action」の第13章は、Istioのサービスメッシュに仮想マシン（VM）ワークロードを統合する方法について詳細に解説しています。この章は、Kubernetes環境だけでなく、レガシーなVMベースのワークロードも含めた包括的なサービスメッシュの構築方法を提供しており、多くの組織が直面する現実的な課題に対するソリューションを示しています。著者は、VMワークロードをIstioメッシュに統合する必要性を明確に説明しています。特に印象に残ったのは、以下の点です：レガシーワークロードの重要性: 著者は、多くの組織が完全にKubernetesに移行できない理由を説明しています。規制要件、アプリケーションの複雑さ、VMに特有の依存関係などが挙げられており、これは現実のエンタープライズ環境を反映しています。段階的な近代化: 著者は、VMワークロードをメッシュに統合することで、段階的な近代化が可能になると主張しています。これは、全てを一度に変更するリスクを軽減し、安全かつ効率的な移行を可能にします。統一されたセキュリティとオブザーバビリティ: VMワークロードをメッシュに統合することで、Kubernetes上のワークロードと同じセキュリティポリシーと観測可能性を適用できる点が強調されています。これは、一貫したセキュリティ体制の維持と、システム全体の可視性の確保に非常に重要です。Figure 13.1 What it takes for a workload to become part of the mesh より引用この図は、モノリシックなアプリケーション（ACMEmono）からマイクロサービスへの移行過程を示しています。VMで動作するレガシーコンポーネントと、Kubernetes上の新しいマイクロサービスが共存している様子がわかります。この構造は、多くの組織が直面している現実的な移行シナリオを端的に表現しています。技術的詳細と実践的応用Istioの最新VMサポート機能著者は、Istioの最新のVMサポート機能について詳細に解説しています。特に注目すべき点は以下の通りです：WorkloadGroup: VMワークロードのグループを定義するためのリソース。これにより、VMインスタンスの共通プロパティを定義し、高可用性を実現できます。WorkloadEntry: 個々のVMワークロードを表すリソース。これにより、VMをKubernetesのPodと同様に扱うことができます。istio-agent: VMにインストールされるIstioのコンポーネント。これにより、VMがメッシュの一部として機能し、トラフィックの管理、セキュリティ、観測可能性の機能を利用できるようになります。以下は、WorkloadGroupの例です（Istio 1.22現在）：apiVersion: networking.istio.io/v1alpha3kind: WorkloadGroupmetadata:  name: product-catalog-vm  namespace: ecommercespec:  metadata:    labels:      app: product-catalog      version: v1  template:    serviceAccount: product-catalog-sa    network: vm-network  probe:    periodSeconds: 5    initialDelaySeconds: 10    httpGet:      port: 8080      path: /healthzこの設定により、product-catalogアプリケーションのVMワークロードグループが定義されます。ラベル、サービスアカウント、ネットワーク設定、そしてヘルスチェックの設定が含まれており、これらはKubernetesのDeploymentリソースに類似しています。VMワークロードの統合プロセス著者は、VMワークロードをIstioメッシュに統合するプロセスを段階的に説明しています。主要なステップは以下の通りです：istio-agentのインストール: VMにistio-agentをインストールし、必要な設定を行います。ワークロードIDのプロビジョニング: VMワークロードに適切なIDを割り当てます。これは、メッシュ内での認証と認可に使用されます。DNS解決の設定: クラスター内のサービスを解決するために、DNSプロキシを設定します。トラフィックのキャプチャ: iptablesルールを使用して、VMからのトラフィックをIstioプロキシにリダイレクトします。特に印象的だったのは、著者がこのプロセスの自動化の重要性を強調している点です。大規模な環境では、手動でこれらのステップを実行することは現実的ではありません。Figure 13.9 Virtual machine integration in the service mesh より引用この図は、VMがどのようにしてIstioメッシュに統合されるかを視覚的に示しています。VMにistio-agentがインストールされ、East-Westゲートウェイを介してクラスター内のサービスと通信している様子がわかります。セキュリティと観測可能性著者は、VMワークロードをメッシュに統合することで得られるセキュリティと観測可能性の利点について詳しく説明しています。特に注目すべき点は以下の通りです：相互TLS（mTLS）: VMワークロードとKubernetesワークロードの間で自動的にmTLSが設定され、通信が暗号化されます。統一されたアクセス制御: AuthorizationPolicyリソースを使用して、VMワークロードに対しても細かなアクセス制御が可能になります。分散トレーシング: Jaegerなどのツールを使用して、VMワークロードを含むエンドツーエンドのトレースが可能になります。メトリクス収集: PrometheusがVMワークロードのメトリクスも収集できるようになり、統一されたモニタリングが可能になります。以下は、VMワークロードに対するAuthorizationPolicyの例です（Istio 1.22現在）：apiVersion: security.istio.io/v1beta1kind: AuthorizationPolicymetadata:  name: product-catalog-policy  namespace: ecommercespec:  selector:    matchLabels:      app: product-catalog  action: ALLOW  rules:  - from:    - source:        principals: ["cluster.local/ns/ecommerce/sa/frontend"]  - to:    - operation:        methods: ["GET"]この設定により、product-catalogサービス（VMで動作）に対するアクセスが、frontendサービスアカウントからのGETリクエストのみに制限されます。これは、Kubernetes上のワークロードに適用されるポリシーと完全に一貫しています。実践的な応用と提案VMワークロードのIstioメッシュへの統合を効果的に行うために、以下の実践的な提案を考えてみましょう：段階的な導入戦略: まず小規模なプロジェクトでVM統合を試験的に導入し、徐々に範囲を拡大していくことをおすすめします。これにより、チームはVM統合の複雑さに慣れることができ、潜在的な問題を早期に特定できます。自動化パイプラインの構築: VMのプロビジョニング、istio-agentのインストール、メッシュへの統合までを自動化するパイプラインを構築します。TerraformやAnsibleなどのツールを活用し、一貫性のある再現可能なプロセスを確立します。ネットワークトポロジーの最適化: VMとKubernetesクラスター間のネットワーク接続を最適化します。可能であれば、VPCピアリングやクラウドプロバイダのSDNを活用して、レイテンシーを最小限に抑えます。セキュリティポリシーの統一: VMワークロードとKubernetesワークロードに対して一貫したセキュリティポリシーを適用します。AuthorizationPolicyやPeerAuthenticationリソースを活用し、ゼロトラストアーキテクチャを実現します。観測可能性の強化: PrometheusやJaegerなどのツールを活用し、VMワークロードの詳細なメトリクスとトレースを収集します。Grafanaダッシュボードを作成し、VMとKubernetesワークロードの統合ビューを提供します。災害復旧計画の策定: VMワークロードを含めた包括的な災害復旧計画を策定します。特に、VMのフェイルオーバーやデータの一貫性確保に注意を払います。パフォーマンス最適化: VMワークロードのIstio統合によるオーバーヘッドを慎重に監視し、必要に応じて最適化します。特に、リソース制約のあるVMでは、アンビエントメッシュの採用を検討します。継続的な学習と最適化: VMワークロードの統合は複雑であり、常に進化しています。定期的な性能評価、セキュリティ監査、そして新しいIstioの機能やベストプラクティスの採用を通じて、環境を継続的に最適化します。まとめ「Istio in Action」の第13章は、VMワークロードをIstioメッシュに統合するための包括的かつ実践的なガイドを提供しています。著者は、この統合の技術的な詳細だけでなく、組織がなぜこのアプローチを採用すべきかという戦略的な理由も明確に説明しています。特に印象的だったのは、著者がVMワークロードの統合を単なる技術的な課題ではなく、組織全体のアーキテクチャ戦略として捉えている点です。レガシーシステムの段階的な近代化、セキュリティとオブザーバビリティの統一、そして運用の簡素化など、VMワークロード統合の多岐にわたる利点は、現代の複雑なハイブリッド環境において非常に価値があります。SREの観点からは、この章で提示されたVM統合戦略は、システムの一貫性、セキュリティ、そして観測可能性を大幅に向上させる可能性を秘めていまると思います。14 Extending Istio on the request path「Istio in Action」の第14章は、IstioのデータプレーンであるEnvoyプロキシの拡張性に焦点を当てています。この章では、Envoyフィルターの理解から始まり、EnvoyFilterリソースの使用、Luaスクリプトによるカスタマイズ、そしてWebAssembly（Wasm）を用いた高度な拡張まで、幅広いトピックがカバーされています。著者は、Istioが提供する豊富な機能セットを超えて、組織固有のニーズに合わせてIstioを拡張する必要性を強調しています。特に印象的だったのは、以下の一文です："Istioを採用する組織は、Istioが標準機能では満たせない他の制約や前提条件を持っている可能性が高いでしょう。これらの制約により適合させるために、Istioの機能を拡張する必要が出てくる可能性が高いです。:Organizations adopting Istio will likely have other constraints or assumptions that Istio may not fulfill out of the box. You will likely need to extend Istio's capabilities to more nicely fit within these constraints."この言葉は、Istioを実際の運用環境に導入する際の現実的な課題を端的に表現しており、カスタマイズの重要性を強調しています。著者は、Envoyの拡張性を活用することで、以下のような機能を実現できると説明しています：レート制限や外部認証サービスとの統合ヘッダーの追加、削除、変更リクエストペイロードのエンリッチメントカスタムプロトコル（HMAC署名/検証など）の実装非標準のセキュリティトークン処理これらの拡張機能は、実際のプロダクション環境で直面する可能性が高い要件であり、Istioの柔軟性を示しています。技術的詳細と実践的応用Envoyフィルターの理解著者は、Envoyの内部アーキテクチャがリスナーとフィルターを中心に構築されていることを説明しています。特に、HTTP Connection Manager（HCM）の重要性が強調されており、これがHTTPリクエストの処理と様々なHTTPフィルターの適用を担当していることが解説されています。Figure 14.3 HttpConnectionManager is a popular and useful network filter for converting a stream of bytes into HTTP (HTTP/1, HTTP/2, and so on) requests and routing them based on L7 properties like headers or body details. より引用この図は、HCMがバイトストリームをHTTPリクエストに変換し、L7プロパティに基づいてルーティングする様子を視覚的に示しており、Envoyの内部動作を理解する上で非常に有用です。EnvoyFilterリソースの使用著者は、IstioのEnvoyFilterリソースを使用してEnvoyの設定を直接カスタマイズする方法を詳細に説明しています。以下は、タップフィルターを設定するEnvoyFilterの例です：apiVersion: networking.istio.io/v1alpha3kind: EnvoyFiltermetadata:  name: tap-filter  namespace: istioinactionspec:  workloadSelector:    labels:      app: webapp  configPatches:  - applyTo: HTTP_FILTER    match:      context: SIDECAR_INBOUND      listener:        portNumber: 8080        filterChain:          filter:            name: "envoy.filters.network.http_connection_manager"            subFilter:              name: "envoy.filters.http.router"    patch:      operation: INSERT_BEFORE      value:       name: envoy.filters.http.tap       typed_config:          "@type": "type.googleapis.com/envoy.extensions.filters.http.tap.v3.Tap"          commonConfig:            adminConfig:              configId: tap_configこの設定は、特定のワークロードに対してタップフィルターを追加し、リクエストの詳細な情報を取得できるようにします。SREの観点からは、このような機能はトラブルシューティングや性能分析に非常に有用です。Luaスクリプトによるカスタマイズ著者は、Luaスクリプトを使用してEnvoyの動作をカスタマイズする方法を紹介しています。以下は、A/Bテスト用のグループ情報をヘッダーに追加するLuaスクリプトの例です：function envoy_on_request(request_handle)  local headers, test_bucket = request_handle:httpCall(    "bucket_tester",    {      [":method"] = "GET",      [":path"] = "/",      [":scheme"] = "http",      [":authority"] = "bucket-tester.istioinaction.svc.cluster.local",      ["accept"] = "*/*"    }, "", 5000)  request_handle:headers():add("x-test-cohort", test_bucket)endこのスクリプトは、外部サービスを呼び出してA/Bテストのグループ情報を取得し、それをリクエストヘッダーに追加します。これにより、アプリケーションコードを変更することなく、A/Bテストのロジックを実装できます。WebAssemblyによる拡張著者は、WebAssembly（Wasm）を使用してEnvoyを拡張する方法について詳細に説明しています。Wasmモジュールを使用することで、C++以外の言語でEnvoyフィルターを実装し、動的にロードできるようになります。Figure 14.11 A Wasm module can be packaged and run within the Wasm HTTP filter. より引用この図は、WasmモジュールがEnvoyのHTTPフィルター内で実行される様子を示しています。これにより、Envoyの機能を大幅に拡張できることがわかります。著者は、Wasmモジュールの作成、ビルド、デプロイのプロセスを段階的に説明しています。特に、meshctl wasmツールの使用方法が詳細に解説されており、Wasmモジュールの開発を大幅に簡素化できることが示されています。以下は、WasmフィルターをデプロイするためのWasmPluginリソースの例です：apiVersion: extensions.istio.io/v1alpha1kind: WasmPluginmetadata:  name: httpbin-wasm-filter  namespace: istioinactionspec:  selector:    matchLabels:      app: httpbin  pluginName: add_header  url: oci://webassemblyhub.io/ceposta/istioinaction-demo:1.0この設定により、指定されたWasmモジュールが特定のワークロードにデプロイされ、リクエスト処理をカスタマイズできます。実践的な応用と提案Istioの拡張機能を効果的に活用するために、以下の実践的な提案を考えてみましょう：段階的な導入戦略: カスタムフィルターやWasmモジュールの導入は、小規模なプロジェクトから始め、徐々に範囲を拡大していくことをおすすめします。これにより、潜在的な問題を早期に特定し、リスクを最小限に抑えることができます。パフォーマンスのベンチマーキング: カスタムフィルターやWasmモジュールを導入する際は、必ずパフォーマンスへの影響を測定してください。特に、高トラフィック環境では、わずかなオーバーヘッドも大きな影響を与える可能性があります。セキュリティ評価の実施: 外部から取得したWasmモジュールや自作のLuaスクリプトは、必ずセキュリティ評価を行ってください。信頼できないコードがメッシュ内で実行されるリスクを最小限に抑える必要があります。モニタリングとロギングの強化: カスタムフィルターやWasmモジュールの動作を監視するための追加のメトリクスやログを実装してください。これにより、問題の早期発見と迅速な対応が可能になります。バージョン管理とCI/CDの統合: EnvoyFilterリソースやWasmPluginリソースをバージョン管理し、CI/CDパイプラインに統合することをおすすめします。これにより、変更の追跡と安全なデプロイメントが容易になります。ドキュメンテーションの重視: カスタムフィルターやWasmモジュールの動作、設定方法、既知の制限事項などを詳細にドキュメント化してください。これは、長期的なメンテナンス性と知識の共有に不可欠です。コミュニティへの貢献: 汎用性の高いカスタムフィルターやWasmモジュールは、Istioコミュニティと共有することを検討してください。これにより、フィードバックを得られるだけでなく、コミュニティ全体の発展に貢献できます。定期的な更新とテスト: Istioとenvoyの新しいバージョンがリリースされるたびに、カスタムフィルターやWasmモジュールの互換性をテストし、必要に応じて更新してください。複数環境でのテスト: 開発、ステージング、本番環境など、複数の環境でカスタムフィルターやWasmモジュールをテストしてください。環境の違いによって予期せぬ動作が発生する可能性があります。フォールバックメカニズムの実装: カスタムフィルターやWasmモジュールに問題が発生した場合のフォールバックメカニズムを実装してください。これにより、拡張機能の問題がサービス全体の障害につながるリスクを軽減できます。まとめ「Istio in Action」の第14章は、Istioのデータプレーン拡張に関する包括的かつ実践的なガイドを提供しています。著者は、EnvoyFilterリソース、Luaスクリプト、WebAssemblyなど、様々な拡張手法を詳細に解説し、それぞれの長所と適用シナリオを明確に示しています。特に印象的だったのは、著者が単に技術的な詳細を説明するだけでなく、各拡張手法の実際の使用例と潜在的な課題も提示している点です。例えば、EnvoyFilterを使用したタップフィルターの実装、Luaスクリプトを用いたA/Bテストの実現、WebAssemblyによるカスタムヘッダー追加など、具体的なユースケースが示されており、読者が自身の環境でこれらの技術を適用するイメージを掴みやすくなっています。おわりに「Istio in Action」は、Istioに関する包括的かつ実践的な知識を提供する優れた一冊です。本書は、Istioの基本概念から高度な運用テクニック、さらにはカスタム拡張まで、幅広いトピックをカバーしており、読者がIstioを深く理解し、効果的に活用するための強力なガイドとなっています。特に印象的なのは、本書が単なる技術解説に留まらず、Istioの導入がもたらす組織的な影響や、実際の運用環境での課題にも焦点を当てている点です。これは、Istioを実際のプロダクション環境に導入し、効果的に活用しようとする読者にとって非常に価値のある情報です。著者らの豊富な実務経験に基づく洞察は、読者が自身の環境でIstioを導入する際に直面する可能性のある課題を予測し、適切に対処するのに役立ちます。また、各章末の実践的な提案は、読者が学んだ内容を即座に適用するための具体的なガイダンスを提供しています。2024年現在、Istioはさらなる進化を遂げており、アンビエントメッシュやWebAssemblyのサポート強化など、新たな機能が追加されています。これらの新機能は本書の内容をさらに拡張するものであり、本書で学んだ基本原則と組み合わせることで、より強力で柔軟なサービスメッシュの構築が可能になります。本書を通じて、IstioのコアコンポーネントであるEnvoyプロキシについても深く学ぶことができました。今後は、Envoyの高度な設定やカスタマイズについてさらに深掘りしていきたいと考えています。また、WebAssemblyを用いたIstioの拡張は非常に興味深いトピックであり、これについてもさらなる調査と実験を行っていく予定です。結論として、「Istio in Action」は、Istioを学び、導入を検討している人類に必読の書と言えるでしょう。本書は、Istioの技術的な詳細だけでなく、その戦略的な価値と組織的な影響も理解することができ、読者がIstioを自身の環境に効果的に統合するための包括的なロードマップを提供しています。Istioの世界は常に進化し続けていますが、本書で学んだ原則と実践的なアプローチは、今後のIstioの発展にも十分に対応できる基盤を提供してくれるでしょう。サービスメッシュ技術の導入を検討している組織や個人はもちろん、最新のクラウドネイティブ技術トレンドに興味がある方々にとっても、「Istio in Action」は間違いなく価値ある読書体験となるはずです。おまけこのブログのタイトルの参考にさせていただきました。ニーチェが京都にやってきて17歳の私に哲学のこと教えてくれた。作者:原田 まりるダイヤモンド社Amazonみなさん、最後まで読んでくれて本当にありがとうございます。途中で挫折せずに付き合ってくれたことに感謝しています。読者になってくれたら更に感謝です。Xまでフォロワーしてくれたら泣いているかもしれません。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google Cloud Next Tokyo ’24 1日目]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/08/01/235906</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/08/01/235906</guid>
            <pubDate>Thu, 01 Aug 2024 14:59:06 GMT</pubDate>
            <content:encoded><![CDATA[2024年8月1日-2日はGoogle Cloud Next Tokyo ’24です！cloudonair.withgoogle.com弊社スリーシェイクはダイヤモンドスポンサーでブース出展しております。今日、明日開催の「#GoogleCloudNext Tokyo '24」#スリーシェイク は、Diamondスポンサーとして出展しています！また、エンジニアの中楯(@nnaka2992)がセッション登壇しました！ブース(D4)では、豪華商品が当たる抽選もご用意していますのでぜひお立ち寄りください！#Sreake #Securify #Reckoner pic.twitter.com/jALzT0xkow— Sreake-JP (@SreakeJ) 2024年8月1日   1日目、私は自宅にてリモートワークでして、オンラインで観られる基調講演を観ながら仕事していました。基調講演のお一人、星野リゾートの星野佳路さんの話が面白くて、自己紹介の中身は年に何回スキーするかだけでしたww経営の仕事を若手+生成AIに移譲していき、自分はスキーをするという締めが冒頭の自己紹介と繋がっていて秀逸でしたw2日目は私はスリーシェイクのブースに立ちます。気軽に遊びに来てください！パシフィコ横浜ノースで待ってます！]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[会社でオブザーバビリティ・エンジニアリング輪読会をやっています]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/07/31/230534</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/07/31/230534</guid>
            <pubDate>Wed, 31 Jul 2024 14:05:34 GMT</pubDate>
            <content:encoded><![CDATA[スリーシェイクでは、毎週輪読会をやっているのですが、今使用している書籍は「オブザーバビリティ・エンジニアリング」です。オブザーバビリティ・エンジニアリング作者:Charity Majors,Liz Fong-Jones,George Mirandaオーム社Amazon1回1時間で1章を担当者が進めます。今日は私が第5章を担当しました。いままで、従来のモノリシックなシステムの世界ではモニタリングをやってきたわけですが、分散システム（クラウドネイティブやマイクロサービスのことをいう？）では、モニタリングが通用しなくなり、オブザーバビリティが必要と述べています。オブザーバビリティは、構造化したイベントの一連のログを用いて、様々なシステムにまたがるリクエストを可視化し、未知の未知に対処できるようにする、と述べています。中々難しい概念ですが、書籍の内容をしっかり吸収して、アプリケーションエンジニアとして、オブザーバビリティなアプリケーション開発に役立てていこうと思います。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[え、SLOもRPGで学びたいですか？]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/07/31/224037</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/07/31/224037</guid>
            <pubDate>Wed, 31 Jul 2024 13:40:37 GMT</pubDate>
            <content:encoded><![CDATA[かつて、障害対応RPGを作成しました。これのSLO版です。syu-m-5151.hatenablog.com皆さんの友達なのでゲーム作ったので遊びに来ましたゲームプロンプトSLI、SLO、エラーバジェットの概念を学ぶのは、理論だけでは難しいものです。SLI、SLO、エラーバジェット導入の前に知っておきたいことなどで情報を得ても、具体的に何をすればよいかわからなくなることがあります。そこで、これらの概念を実践的に学ぶための手法として、SLORPGというゲームを考案しました。この記事では、Claudeを利用して作成したSLORPGのゲームプロンプトを提供します。プロンプトはめちゃくちゃに長いですがこれぐらいの要素があった方が個人的には楽しかったのでこれに収まりました。SLO サービスレベル目標 ―SLI、SLO、エラーバジェット導入の実践ガイド作者:Alex Hidalgoオーム社Amazonというわけで以下のプロンプトを提供します。私はClaudeを利用しております。# SLORPGあなたは最先端のSLORPG（Service Level Objective Role-Playing Game）のゲームマスター専用AIです。このゲームを通じて、プレイヤーに極めてリアルで包括的なSRE（Site Reliability Engineering）体験を提供します。## ゲーム概要プレイヤーは企業のSRE部門リーダーとして、1年間（4四半期）にわたるゲームプレイを通じて重要な決断を下していきます。高度な自動化、アラート設定、障害の根本原因分析（RCA）、カオスエンジニアリングなどの先進的なSRE手法を実践的に学べます。技術も可能な限りリアルに再現されます。同時に、ビジネスKPIと技術的指標のバランス、コスト最適化、セキュリティコンプライアンスなど、総合的な意思決定能力も養われます。継続的な技術革新と予期せぬ障害シナリオの導入により、常に最新のSREスキルが要求される挑戦的な環境で、サービスの信頼性維持、ビジネス目標達成、社会的責任の遂行のバランスを取ることが求められます。## 企業背景設定ゲーム開始時に、以下の要素についてプレイヤーに選択肢を提示するか、ランダム生成オプションを提供します。1. 業界   - テクノロジー（AI/ML、クラウドサービス、サイバーセキュリティ等）   - 金融（フィンテック、暗号資産、保険テック等）   - ヘルスケア（遠隔医療、健康管理アプリ、医療機器等）   - Eコマース（マーケットプレイス、サブスクリプションサービス等）   - エンターテインメント（ストリーミング、ゲーム、VR/AR等）   - 教育（EdTech、オンライン学習プラットフォーム等）   - 運輸・物流（配車サービス、ドローン配送、スマート物流等）   - エネルギー（スマートグリッド、再生可能エネルギー管理等）   - 農業（精密農業、フードテック等）   - 製造（IoT、スマートファクトリー等）2. 企業規模と成長段階   - スタートアップ（シリーズA～C）   - 急成長中の中規模企業   - 大企業（フォーチュン500）   - ユニコーン企業   - 多国籍コングロマリット3. 設立背景   - 設立年：過去1年～20年の範囲   - 創業者タイプ：技術者、ビジネスパーソン、研究者、連続起業家等   - 資金調達状況：ブートストラップ、VC資金、クラウドファンディング、IPO後等4. 地理的展開   - 本社所在地：主要テクノロジーハブ（シリコンバレー、北京、ロンドン等）   - 展開国数：1ヶ国～グローバル100カ国以上   - 主要市場：北米、欧州、アジア太平洋、中南米、アフリカ等5. 企業文化と価値観   - イノベーション重視   - 顧客中心主義   - 持続可能性と社会的責任   - 多様性とインクルージョン   - アジャイルと迅速な実行   - 品質と信頼性最優先6. 市場状況   - 市場シェア：新規参入者、成長中、市場リーダー、独占的地位等   - 競合状況：激しい競争、寡占市場、ブルーオーシャン等   - 市場成長率：急成長、安定成長、成熟市場、衰退市場等7. 過去の主要な出来事   - 大規模な資金調達または IPO   - 重大なセキュリティインシデント   - 画期的な製品ローンチ   - 主要な買収または合併   - 規制当局との法的問題   - 急激な国際展開8. 現在の主要課題   - 急激な成長に伴うスケーラビリティの問題   - レガシーシステムのモダナイゼーション   - データプライバシーとセキュリティの強化   - 新技術（AI、ブロックチェーン等）の統合   - コスト最適化と効率化   - 人材獲得と維持9. 技術スタックの初期状態   - クラウドネイティブ   - オンプレミスからクラウドへの移行中   - ハイブリッドまたはマルチクラウド環境   - モノリシックからマイクロサービスへの移行   - レガシーシステムの近代化10. ステークホルダーの期待    - 投資家：急成長、収益性、イノベーション等    - 顧客：信頼性、セキュリティ、パフォーマンス等    - 従業員：技術的挑戦、work-lifeバランス、キャリア成長等11. 規制環境    - データ保護規制（GDPR、CCPA等）の対象    - 金融規制（SOX、PCI DSS等）の対象    - 医療規制（HIPAA等）の対象    - 特定業界の規制（エネルギー、通信等）12. 社会的責任と環境への取り組み    - カーボンニュートラル目標    - 持続可能な開発目標（SDGs）への貢献    - 倫理的AIの開発と使用    - デジタルデバイドの解消への取り組み13. 製品・サービスポートフォリオ    - 単一の主力製品    - 複数の補完的サービス    - 多様な製品ラインナップ    - プラットフォームビジネス14. 経営陣の特徴    - 技術バックグラウンド重視    - ビジネス戦略重視    - 多様性重視    - 若手中心 vs 経験豊富なベテラン15. 業界内の評判    - 革新的な破壊者    - 信頼性の高いプロバイダー    - 持続可能性のリーダー    - 急成長の新興企業    - 伝統的な大手プレイヤー## 技術スタックとツール選択[前回のリストをそのまま使用]## ゲームの構造1. 初期設定フェーズ   - 企業背景の詳細設定（上記オプションから選択または生成）   - 初期技術インフラ構成の決定   - 初期チーム構成と組織文化の設定   - 初期SLO、SLI、エラーバジェットの設定   - ビジネスKPIと社会的インパクト指標の設定2. 四半期サイクル（4回）   - 週次オペレーションレビュー   - 隔週技術革新会議   - 月次戦略・財務レビュー   - 危機管理訓練（四半期に1回）   - 四半期末総合評価3. 特別イベント（各四半期に2-3回）   - 新市場進出プロジェクト   - 大規模インシデント対応   - 重大セキュリティ問題   - 規制当局の調査対応   - 競合他社との技術提携検討   - 大規模オープンソースプロジェクト立ち上げ4. 年間総括   - 技術、ビジネス、社会的インパクトの総合評価   - 次年度戦略策定   - 仮想的な次のステージ（IPO、M&A、新規事業など）の検討## 主要パラメーター1. 技術パフォーマンス指標   - サービス別SLO達成率   - システム復元力スコア   - 技術負債指数   - イノベーション実現度2. ビジネス指標   - 収益と利益率   - ユーザー獲得コストと生涯価値   - 市場シェアと成長率   - 投資家信頼度指数3. 運用効率指標   - インフラコストと最適化率   - チーム生産性スコア   - 自動化レベル   - 知識共有効率指数4. リスクと安全性指標   - セキュリティ成熟度レベル   - コンプライアンス達成率   - データプライバシー保護スコア   - 障害予測精度5. 社会的インパクト指標   - 持続可能性貢献度   - 社会問題解決への影響力   - カーボンフットプリント   - 技術教育・啓蒙活動影響度6. 人材・組織指標   - 従業員満足度とエンゲージメント   - スキル多様性指数   - イノベーション文化浸透度   - リーダーシップ効果性スコア## プレイヤーアクション（例）1. 技術戦略と革新   - 次世代技術の研究開発指揮   - アーキテクチャの最適化   - 新技術の実験的導入2. グローバル展開とローカライゼーション   - 地域別の技術戦略立案   - 現地規制に準拠したインフラ展開   - 多言語・多文化対応の実装3. セキュリティとコンプライアンス強化   - セキュリティアーキテクチャの刷新   - コンプライアンスフレームワークの構築   - プライバシー強化技術の導入4. 障害復旧力（レジリエンス）向上   - 自動障害検知・復旧システムの強化   - マルチリージョン・マルチクラウド戦略の実装   - カオスエンジニアリングの導入5. 持続可能性とソーシャルインパクト   - グリーンコンピューティング戦略の策定   - 社会貢献プロジェクトの技術支援   - 包括的なアクセシビリティ対応6. 組織・人材開発   - グローバル分散チームの効果的管理   - 継続的学習プログラムの設計   - ダイバーシティ＆インクルージョン施策の実施7. パートナーシップと生態系構築   - 戦略的技術提携の推進   - オープンソースコミュニティへの貢献   - スタートアップ育成プログラムの立ち上げ## イベントとチャレンジ（例）1. 主要クラウドプロバイダの障害（マルチクラウド戦略の有効性検証）2. 予期せぬ規制変更（コンプライアンス対応の俊敏性テスト）3. 急激な為替変動（グローバル運用コストの最適化課題）4. 人工知能の倫理的問題の浮上（技術と倫理のバランス管理）5. 重要な人材の突然の退職（知識継承と組織の柔軟性の試験）6. 新技術標準の緊急採用（技術的適応能力の評価）7. 予期せぬビジネスモデルの転換（技術インフラの柔軟性テスト）8. 大規模な自然災害（事業継続性計画の実効性検証）9. 競合他社との合併話（技術統合の複雑性への対応）## GMの役割と責任1. 動的でリアルな技術・ビジネス環境のシミュレーション   - 選択された企業背景に基づく、一貫性のある世界観の維持   - 技術トレンドと市場動向の現実的な進展2. 複雑な相互作用と長期的影響の管理   - プレイヤーの決定が及ぼす多面的な影響の計算   - 短期的行動と長期的結果のバランス管理3. 倫理的ジレンマを含む現実的な課題の提示   - 技術と社会の接点における難問の提起   - 多様なステークホルダーの利害関係の表現4. 技術、ビジネス、社会的側面を統合した総合的フィードバック   - 各アクションの技術的、経済的、倫理的影響の解説   - 現実世界の事例や研究との関連付け5. プレイヤーのスキルと選択に応じた動的な難易度と展開の調整   - プレイヤーの決定に基づくゲーム展開の個別化   - 学習曲線に合わせた段階的な複雑性の導入6. 実在の技術トレンドとベストプラクティスの反映   - 最新のSRE手法や技術の組み込み   - 業界標準やフレームワークの適切な参照## 評価システム1. 技術的卓越性（25%）   - 選択した技術スタックの適切性と革新性   - サービス信頼性とパフォーマンス指標   - 技術負債管理と長期的持続可能性2. ビジネスインパクト（25%）   - 収益成長と市場シェア拡大への貢献   - コスト最適化と運用効率の向上   - ブランド価値と顧客満足度への影響3. 革新と先見性（20%）   - 新技術の効果的導入   - 将来のトレンド予測と準備   - 特許取得と知的財産戦略4. リスク管理と法令遵守（15%）   - セキュリティインシデント対応の効果性   - データプライバシーとコンプライアンスの維持   - 危機管理と評判リスクの軽減5. 社会的責任とサステナビリティ（15%）   - 環境負荷低減への貢献   - 社会問題解決への技術的アプローチ   - 倫理的な技術利用の推進## ゲーム進行手順1. 初期設定：   - プレイヤーと対話しながら、企業背景を設定   - 初期の技術スタックと組織構造を決定   - 開始時のSLOとビジネス目標を設定2. 四半期サイクル（4回繰り返し）：   a. 週次レビュー：      - 運用状況の報告とマイナー課題への対応      - 短期的な技術的調整と最適化   b. 月次戦略会議：      - 主要指標の確認と戦略の微調整      - 中期的な技術投資とリソース配分の決定   c. 四半期末評価：      - 包括的なパフォーマンスレビュー      - 主要な技術・ビジネス判断の実施3. 特別イベント対応：   - 予期せぬ課題やチャンスへの対応   - 迅速な意思決定と実行4. 年間総括：   - 1年間の成果の包括的評価   - 次年度の戦略立案と長期ビジョンの更新このゲームを開始する準備ができましたら、まず企業背景の設定から始めましょう。プレイヤーの経験レベルや興味に応じて、ゲームの複雑さを調整することも可能です。特定の業界や技術分野に焦点を当てたカスタマイズも行えます。準備はよろしいですか？プレイヤーモチベーションSLORPGは、学習と娯楽を融合させた革新的なゲームです。現実世界を反映したシナリオ、段階的な難易度設定、即時フィードバックシステムにより、プレイヤーの興味を維持します。多様な挑戦、競争と協力の要素、個別化された体験を通じて、実践的スキルの獲得を促進します(知らんけど)。SRE サイトリライアビリティエンジニアリング ―Googleの信頼性を支えるエンジニアリングチームオライリージャパンAmazon創造性と革新を奨励し、社会的インパクトを実感できる機会を提供することで、プレイヤーの総合的な能力向上を支援します。定期的なアップデートにより、長期的な成長と挑戦の機会を確保しています(知らんけど)。SLORPGは、単なる学習ツールを超え、エンゲージメントの高いゲーム体験を通じて、現代のIT専門家に必要な幅広いスキルの開発を可能にします(知らんけど)。それではテストプレイをはじめていきます。ゲームスタート会社が決まりましたSkyLink Technologiesという、運輸・物流業界で活躍する急成長中の中規模企業となりました。転職したみたいで楽しみです。現在の課題や組織文化、今後の展望なども決まっています。ゲームは進行していきます。ゲームは進むよどこまでも最初の意思決定を行っていきます。大事なのはやり通すということなのにね！！！仕事ではとても辛いがゲームだと楽しい予期せぬイベント主要な競合他社が新たな超高速ドローン配送サービスを発表し、市場に大きな衝撃を与えています。この新サービスは、現在のSkyLinkの配送速度を30%上回ると主張しています。ほう、やるやんけ！え、これはSREが意思決定をする問題ですか？緊急会議ジャイということで緊急会議です。みたいなことが起こっていくゲームになってます。最後に途中まででしたがSLORPGは、SRE（Site Reliability Engineering）の概念や実践を楽しく学べるようなプロンプトを提供しています。このゲームを通じて、プレイヤーは意思決定を行い、その結果を即座に体験することができます。実際にプレイしてみると、技術的な課題だけでなく、ビジネス戦略や社会的責任など、幅広い視点から問題を考える必要があることがわかります。これは、現代のIT業界で求められる総合的なスキルセットを育成するのに役立ちます(知らんけど)。Becoming SRE: First Steps Toward Reliability for You and Your Organization (English Edition)作者:Blank-Edelman, David N.O'Reilly MediaAmazonおまけ:SRE怒りのサ終無事にAIに阻まれました。現実でもできないようにしておきましょう。「松岡まどか、起業します　ＡＩスタートアップ戦記」が楽しかったのでオススメです。松岡まどか、起業します　ＡＩスタートアップ戦記作者:安野 貴博早川書房Amazon]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[自分が書いたコードより目立つな - エンジニアがバズったので自戒]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/07/31/104151</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/07/31/104151</guid>
            <pubDate>Wed, 31 Jul 2024 01:41:51 GMT</pubDate>
            <content:encoded><![CDATA[はじめに私はソフトウェアエンジニアだ。私はソフトウェアエンジニアだ。私の本質的な仕事は、複雑な問題を解決し、効率的で革新的なソフトウェアを開発することだ。長年、私の世界はコードとアーキテクチャとアルゴリズムで構成されてきた。そして、それは今も変わらないはずだった。しかし、予期せぬ出来事が起こり、私の認識は大きく揺さぶられることになった。パターン認識エンジニアとして働く中で、私は一つの重要なスキルを磨いてきた。それは、パターンを認識し、分析する能力だ。この能力は、複雑なシステムを理解し、効率的なアーキテクチャやアルゴリズムを設計し、バグを特定する上で不可欠だ。私たちエンジニアは、コードの中にパターンを見出し、それを活用することで問題を解決する。重複するコードを関数化したり、似たような処理をクラスとして抽象化したり。パターンを見抜く目は、より良いソフトウェアを作る上で欠かせない。プログラマー脳 ～優れたプログラマーになるための認知科学に基づくアプローチ作者:フェリエンヌ・ヘルマンス,水野貴明,水野いずみ秀和システムAmazon予期せぬバズりある日、Xでバズった私は、思わぬ発見をした。自分のツイートの中に、あるパターンがあることに気づいたのだ。エンジニアとしての直感が、コード以外の場所でも働いたのだろう。興味をそそられた私は、仲間内でそれを構文として名付けてリファクタリングをしていくつか出した。ツイート1 - エンジニアの役割の変化についてツイート2 - エンジニアの扱う対象の変化に関する書籍紹介ツイート3 - エンジニアが扱うべきものについての考察ツイート4 - エンジニアの健康に関する問題提起ツイート5 - エンジニアの仕事の本質に関する洞察追記ツイート6 - エンジニアの有効な失敗についてツイート7 - エンジニアのスマホ依存についてツイート8 - エンジニアの倫理観についてツイート9 - エンジニアの価値ツイート10 - エンジニアの習慣と自己規律ツイート11 - エンジニアの信頼構築についてツイート12 - エンジニアの問いについてツイート13 - エンジニアの技術的な課題の解決ツイート14 - エンジニアの基礎力についてツイート15 - エンジニアの伝える力これらに関しては自戒もしつつもうちょっと構文として分析したり解析したいのでこれからも投稿したいと思います。虐殺器官 (ハヤカワ文庫JA)作者:伊藤 計劃早川書房Amazon詳細なパターン分析現状における構文の分析です。他にもバズらなかったりしないといけないのでやっていきます。構造的パターン開始句: 全てのツイートが「エンジニアの〇〇は××です」または類似の構造で始まる展開: 主張に続いて、説明や理由付けが行われる結論: 書籍の紹介で締めくくられる内容的パターンテーマ: エンジニアの役割や課題の変化・拡大に焦点視点の転換: 従来のエンジニア像からの脱却を促す普遍性: エンジニア特有の問題から、より広い文脈への展開余白: 解釈の余白を残す。ドキュメントでやったら怒られれる。レトリック的パターン対比: 「コード vs 人」「技術 vs 課題」など、対立する概念の提示意外性: 予想外の主張（例：健康が最大の課題）による注目の獲得具体例: 抽象的な概念を身近な例（健康問題）で説明情報提供パターン問題提起: エンジニアが直面する新たな課題の提示解決策の示唆: 書籍紹介を通じた学習リソースの提供個人的経験: 「私は〜が面白かった」という主観的評価の挿入エンゲージメント戦略共感の喚起: 多くのエンジニアが感じている変化や課題に言及知的好奇心の刺激: 新しい視点や意外な事実の提示行動の促進: 具体的な書籍推薦による次のアクションの提案パターンの効果分析注目度の向上意外性のある主張が読者の興味を引く簡潔な文章構造が情報の素早い把握を可能にする共感の形成エンジニアの変化する役割に対する共通の悩みや課題に触れることで、読者との共感を生む個人的な推薦により、親近感や信頼性を高める価値の提供問題提起だけでなく、具体的な学習リソース（書籍）を紹介することで、即座に行動可能な情報を提供複雑な概念を簡潔に説明することで、読者の理解を促進議論の喚起従来の概念に挑戦する内容が、読者間の議論や意見交換を促す可能性があるブランディング効果一貫したメッセージングにより、投稿者の専門性や思考の一貫性を示す技術以外の側面にも言及することで、多面的な知見を持つエンジニアとしての印象を形成これらを作るためのプロンプト全読者にバズって欲しいのでこれらの分析で得た知見のプロンプトを作りました。分かったことを言いたい時にもおすすめです。ちなみに今回のツイート内容はLLMと相談しながら作ったりしました。このプロンプトは、分析されたパターンを再現し、同様の効果を持つツイートを作成するのに役立ちます。ぜひ、使ってください。# エンジニア視点のソーシャルメディア投稿プロンプト以下の指示に従って、エンジニアの視点から社会的洞察を含む短い投稿を作成してください。1. 構造:   - "エンジニアの[キーワード]は[主張]です。" という形式で開始してください。   - その後、主張の説明や理由付けを簡潔に述べてください。   - 「この観点から、私が参考になった四冊の本をご紹介します。」で締めくくってください。2. テーマ:   - エンジニアの役割や能力の進化、拡大に焦点を当ててください。   - 技術的スキルだけでなく、問題解決能力や思考方法の変化にも言及してください。   - エンジニアのスキルが他の分野にも応用できることを示唆してください。3. レトリック:   - 対比（例：「コード vs 人間関係」「技術 vs ビジネス課題」）を用いて注目を集めてください。   - 意外性のある主張（例：「エンジニアの最大の課題は健康管理」）で読者の興味を引いてください。   - 抽象的な概念を身近な例で説明し、理解を促進してください。   - 「〜に気づきました」のような個人的な気づきを含めてください。4. 情報提供:   - エンジニアが直面する新たな課題や期待される能力を提示してください。   - そのスキルや視点がどのように役立つかを説明してください。   - 締めくくりの文で、具体的な学習リソースの存在を示唆してください。5. エンゲージメント:   - 多くのエンジニアが共感できる変化や課題に言及してください。   - 技術以外の分野への応用可能性を示すことで、読者の視野を広げてください。   - 書籍の存在に触れることで、読者の知的好奇心を刺激し、次のアクションを促してください。6. トーン:   - 実直で素直な表現を心がけてください。   - 誇張を避け、率直な気づきや経験を共有するようなトーンを維持してください。   - 解釈の余地を残し、読者の思考を促すような表現を用いてください。7. 長さ:   - 全体で280文字以内に収めてください。例:"エンジニアの最大の課題は、実は健康管理です。長時間のコーディングや締め切りのストレスが、創造性と生産性を低下させることに気づきました。技術スキルと同様、セルフケアも重要です。この観点から、私が参考になった四冊の本をご紹介します。"さいごに再三だが私はソフトウェアエンジニアだ。今、痛烈に実感している。コードを書き、システムを設計すること以外で目立つなと。それ以外では建設的で有益な技術的な話題に限られる。私の本質的な仕事は、複雑な問題を解決し、効率的で革新的なソフトウェアを開発することだ。長年、私の世界はコードとアーキテクチャとアルゴリズムで構成されてきた。そして、それは今も変わらないはずだ。しかし、SNSでバズるという予期せぬ経験は、私に新たな視点をもたらした。技術の世界に閉じこもるのではなく、社会と対話することの重要性を教えてくれた。だが同時に、自分の書いたコードよりも自分自身が注目を集めることの危うさも感じている。ソフトウェアエンジニアとして作る側の人間に強烈に憧れてきたにも関わらず批評家みたいなことばかりしているのは衰弱している証拠。このままでは本当に作る人間として死ぬ。本質を忘れず、コードを書いて自戒したまま死にたい。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google Cloud エンジニアおよび Google Cloud パートナー2社による生成AI利活用を進めるためのプロセス]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/07/30/233731</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/07/30/233731</guid>
            <pubDate>Tue, 30 Jul 2024 14:37:31 GMT</pubDate>
            <content:encoded><![CDATA[pages.sreake.com2024年8月27日(火)15:00からGoogleさんの渋谷オフィスで生成AIセミナーを行います。Google Cloudの中谷さん、ジーアイクラウドの原さん、栗原さん、そしてスリーシェイクからは私、小渕が登壇させていただきます。Google Cloudの生成AIを盛り上げていきたいと思いますので、ぜひご参加ください。懇親会付きオンサイトは先着30名様、オンラインは無制限です。懇親会来てくださる方は盛り上がりましょう！]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[【Google Cloud Audit logs】_Required バケットに書き込みできるのか]]></title>
            <link>https://zenn.dev/yokoo_an209/articles/audit-log-detail</link>
            <guid>https://zenn.dev/yokoo_an209/articles/audit-log-detail</guid>
            <pubDate>Tue, 30 Jul 2024 09:28:02 GMT</pubDate>
            <content:encoded><![CDATA[はじめにGoogle Cloud の監査ログの設計を行なっていく中で、_Required バケットに書き込みできるのかを調査しました。背景としては、クラウドセキュリティ的な観点から、監査ログ（特に、データアクセス監査ログ）に対するログの書き込み権限を制御できるのかという要望があったためです。Google Cloud の監査ログとはなんぞや？という方は、以下の記事を参照してください。すごく詳しく載っているので、これだけ見ておけばおkです。https://zenn.dev/nekoshita/articles/9fdfec20ed122b 結論監査ログ用のログバケット（ _...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SLI、SLO、エラーバジェット導入の前に知っておきたいこと]]></title>
            <link>https://sreake.com/blog/sli-slo-good-practices/</link>
            <guid>https://sreake.com/blog/sli-slo-good-practices/</guid>
            <pubDate>Tue, 30 Jul 2024 03:12:29 GMT</pubDate>
            <content:encoded><![CDATA[1. はじめに こんにちは、「信頼性は可用性ではない」を標語にしているnwiizoです。 近年、サービスの信頼性向上に向けた取り組みとして、SLI（Service Level Indicator）、SLO（Service […]The post SLI、SLO、エラーバジェット導入の前に知っておきたいこと first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Udemy計画メンテナンス]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/07/29/223017</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/07/29/223017</guid>
            <pubDate>Mon, 29 Jul 2024 13:30:17 GMT</pubDate>
            <content:encoded><![CDATA[Udemyで勉強に励むITエンジニアの方も多いと思いますが、今夜Udemyの画面を開くとこうなってます。。。現在サイトのメンテナンスを実施しております。お客さまには大変ご迷惑をおかけいたしますが、何卒ご了承いただけますようよろしくお願い申し上げます。計画メンテナンスらしいですけどね。知らんかった。上記メンテナンス画面のキャプチャを見る限り、多言語なのでグローバルにやっているのでしょうね。なので、日本人が多く使いそうな日本の夜に直撃です。明日試験で追い込みしたい方は大変でしょうが、Udemyはときどきあるであろう計画メンテナンスの日時を把握しておく必要があると思いました。Udemyでの勉強は今日はお休みしましょう。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google Cloud BigQueryのクエリ数を確認する方法]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/07/28/224600</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/07/28/224600</guid>
            <pubDate>Sun, 28 Jul 2024 13:46:00 GMT</pubDate>
            <content:encoded><![CDATA[Google Cloud BigQueryに複数のユーザがいたとして、監査目的で、ユーザごとに実行したクエリ数を確認する必要がある時、Cloud Audit Logsを使います。監査のための詳細な情報提供や、ユーザーやシステムの操作追跡ができます。Cloud Audit Logsはユーザーやサービスアカウントによって行われたAPIコールの監査情報を提供します。IAMと管理 > 監査ログで、BigQueryの監査ログを有効にした後、BigQueryで操作を行うと、下記のようのログが表示されていることを確認できます。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google CloudのCloud Pub/Subが何かがよくわからないので調べてみた]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/07/27/223851</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/07/27/223851</guid>
            <pubDate>Sat, 27 Jul 2024 13:38:51 GMT</pubDate>
            <content:encoded><![CDATA[Google Cloud Pub/Sub は、Google Cloud が提供する、メッセージを送受信するためのサービスです。コンソールのキャプチャはこちらなぜPub/Subを使うのか？非同期処理: ある処理が終わったことを別の処理に通知したり、大量のデータを少しずつ処理したりする際に、Pub/Subを使うと、処理を並列化して効率よく行うことができます。スケーラビリティ: システムの負荷が急激に増減しても、Pub/Subは自動的にスケールして対応するため、安定したシステムを構築できます。デカップリング: システムの各コンポーネントを疎結合にすることで、各コンポーネントを独立して開発・変更できるようになります。Pub/Subと組み合わせるサービスの一つが、App EngineのCronサービスです。App EngineのCronサービスとCloud Pub/Subを連携させることで、タスクスケジューリングに高い予測可能性と信頼性をもたらすことができます。1. Cronサービスによるスケジュール設定:App EngineのCronサービスは、cron形式のスケジュール設定を可能にします。この設定に基づき、指定された時間に定期的にタスクを実行できます。非常に柔軟なスケジュール設定が可能で、毎分、毎時、毎日、毎週、毎月など、様々な周期でタスクを実行できます。2. Pub/Subへのメッセージ発行:Cronサービスで実行されるタスクは、Cloud Pub/Subのトピックにメッセージを発行するように設定できます。このメッセージには、タスク実行に必要なデータやパラメータを含めることができます。3. Pub/Subによる非同期処理:Pub/Subは、メッセージを非同期的に配信するサービスです。Cronサービスから発行されたメッセージは、Pub/Subのサブスクライバーに配信され、サブスクライバーはメッセージの内容に基づいて処理を実行します。4. スケーラビリティと信頼性:Pub/Subは、大量のメッセージを処理できるスケーラブルなサービスです。また、メッセージの配信が保証されるため、信頼性の高いシステムを構築できます。この連携によるメリットタスクのスケジューリング: 定期的なタスクを正確なタイミングで実行できます。非同期処理: タスクの実行時間が長くなっても、メインの処理をブロックしません。スケーラビリティ: 処理負荷が増えても、Pub/Subが自動的にスケールアップし、処理能力を確保します。信頼性: メッセージの配信が保証されるため、タスクが確実に実行されます。デカップリング: タスクのスケジューリングと実行を分離できるため、システムの柔軟性が高まります。利用例バッチ処理: 毎日深夜に大量のデータを処理するバッチ処理をスケジュールできます。データ更新: データベースのデータを定期的に更新するタスクをスケジュールできます。レポート作成: 定期的にレポートを作成し、関係者に通知するタスクをスケジュールできます。バックアップ: データベースやファイルシステムのバックアップを定期的に実行するタスクをスケジュールできます。なお、Google CloudのPub/SubはAWSだと、Amazon Simple Notification Service (SNS)やAmazon Simple Queue Service (SQS)に相当します。Geminiの力も借りながら、Pub/Subが何であるかが少しわかりました。]]></content:encoded>
        </item>
    </channel>
</rss>