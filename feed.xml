<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Tue, 28 Oct 2025 22:41:38 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[Rayシリーズ：NumPyやpandasデータをRay Dataで取り込む]]></title>
            <link>https://zenn.dev/akasan/articles/db0b5b634d453d</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/db0b5b634d453d</guid>
            <pubDate>Tue, 28 Oct 2025 14:21:11 GMT</pubDate>
            <content:encoded><![CDATA[今回はRay Dataを利用して、NumPyとpandasのデータを読み込む方法をまとめます。 早速試してみる内容はこちらを参考にしています。https://docs.ray.io/en/latest/data/loading-data.html#loading-data-from-other-libraries 環境構築uvを利用して以下のように構築します。uv init ray_data_numpy_pandas -p 3.12cd ray_data_numpy_pandasuv add "ray[data]" numpy pandas NumPyからデータを...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ソフトウェアエンジニアにおける才能という幻想、あるいは成長を阻む最大の敵について]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/10/28/113009</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/10/28/113009</guid>
            <pubDate>Tue, 28 Oct 2025 02:30:09 GMT</pubDate>
            <content:encoded><![CDATA[はじめに「才能がない」と言われたことがあるでしょうか。それとも、友人や知り合いと自分を比べて、自分で自分にそう言い聞かせたことがあるでしょうか。学生の頃からエンジニアを志してきた私は、コンテストで優秀な成績を残す人たちを目の当たりにしてきました。大手IT企業に入社し、優秀な同期と出会いました。勉強会やカンファレンスに足を運び、そこで出会った人たちの軌跡を追ってきました。華々しくスタートアップを立ち上げた人、革新的なプロダクトを生み出した人、OSSコミュニティで名を馳せる人。一方で、いつの間にか表舞台から姿を消した人もいます。これらがごく一部の狭い世界でしかないことも、自覚しています。そして今、インターンシップやワークショップで若手エンジニアと接する機会が増えました。3年ほど前に始めたこの活動──正直に言うと、自分が未熟なまま始めてしまったという不安は、今でもどこかにあります。彼らと一緒に作業する中で、「才能がない」と自己評価する学生やインターン生に出会うことがよくあります。彼らは真剣な表情で「自分には向いていないかもしれません」と告げます。コードを書くのが遅い。エラーの意味が理解できない。他の人は簡単にできることが、自分には難しい──そう語る彼らの目には、諦めと不安が混じっています。私はその度に、ある問いを投げかけます。「才能って、何だと思う?」「君には才能がある」とも「才能なんて関係ない」とも言わず、まず考えてもらう。しかし大抵の場合、明確な答えは返ってきません。実は、私もかつて、才能という言葉に深く囚われていました。コンテスト会場で、企業の開発フロアで、勉強会の懇親会で、私は何度も「天才」と呼ばれるエンジニアたちに出会いました。彼らは難解なアルゴリズムを一瞬で理解し、複雑なバグを数分で特定し、誰も思いつかないような解決策を次々と生み出していました。そして私は何度も思いました。「自分には才能がない」と。しかし、多くの「一流」と呼ばれる人々と接し、彼らの日常を観察し、そして時には彼らが立ち止まる瞬間や、消えていく瞬間も目撃する中で、ある重要な事実に気づきました。才能という言葉は、実は成長を阻む最大の敵なのかもしれない。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。技術力という幻想才能について語る前に、まずソフトウェアエンジニアリングにおける「技術力」とは何かを整理しておく必要があります。我々の文脈では、才能という言葉はこの技術力と結びつけて語られることが多いためです。技術力という言葉の曖昧さ私たちは「技術力が高い」「技術力が低い」という言葉を安易に使いがちです。しかし、その実態は何でしょうか。率直に言えば、ソフトウェアエンジニアの「技術力」と呼ばれるものの多くは、実は「ちょっと詳しい」「似たようなトラブルを経験している」「これとこれを組み合わせれば行けそう」という程度のものです。私が使ってきた「エンジニアリング」という言葉にも、工学的な要素はあまり含まれていませんでした。正しくは「テクニック」──つまり、実践的な技術や方法論の集積です。特別なスキルというよりは、日々の積み重ねで身につく経験知なのです。では、技術力とは何なのか。私の観察では、それは大きく二つの軸に分解できます。一つは「経験の蓄積」、もう一つは「洞察力としてのセンス」です。センスは知識からはじまる作者:水野学朝日新聞出版Amazon第一の軸：経験の蓄積技術力の第一の要素は、経験の蓄積です。これは、しばしば「同じ失敗を繰り返さない力」として評価されます。具体的には、こういうことです。あるエラーに遭遇したとき、以前に似たようなエラーを見たことがあれば、解決は早くなります。データベースのデッドロック、非同期処理のタイミング問題、キャッシュの不整合──こうした問題は、一度経験していれば「ああ、これか」と気づけます。これは確かに価値のある能力です。経験豊富なエンジニアが重宝されるのは、このためです。しかし、これを「才能」と呼ぶのは適切でしょうか。違います。これは単に時間をかけて様々な問題に向き合った結果であり、誰でも積み重ねられるものです。早く始めた人、多く失敗した人が、より多くの経験を持っているだけです。具体と抽象作者:細谷 功dZERO（インプレス）Amazon第二の軸：洞察力としてのセンス技術力のもう一つの要素、それが「センス」です。音楽をやっている人たちの中で「あいつは耳が良い」と評価される能力があります。単に楽器を弾く技術だけでなく、音のバランス、リズムの微妙なズレ、和音の響き方──こうした細部を感じ取る力のことです。ソフトウェアエンジニアリングにも、これに似たものがあります。コードを見たとき、「このコード、何か変だな」と直感的に感じる。実行する前から「ここでバグが出そう」と予感する。設計図を見て「この構造は将来的に問題になる」と察知する。これが、エンジニアにおける「センス」です。重要なのは、これは単なる経験の蓄積とは質的に異なるということです。同じ年数働いていても、このセンスを持つ人と持たない人がいます。では、このセンスとは何なのでしょうか。センスの哲学 (文春e-book)作者:千葉 雅也文藝春秋Amazonセンスの正体──三つの具体的な現れ方センスは抽象的な概念に聞こえますが、実は具体的に分解できます。私の観察では、センスは主に三つの形で現れます。1. 細部への注目力センスのあるエンジニアは、コード全体の機能だけでなく、細部のリズムやバランスに気づきます。例えば、関数の長さのバランス。あるファイルに25行の関数と5行の関数が混在しているとき、「なぜこの差があるのか」と気づきます。命名の一貫性。ある場所ではgetUserDataと書き、別の場所ではfetchUserと書いているとき、その揺らぎに違和感を覚えます。これらは動作に直接影響しないこともあります。でも、コードの「匂い」として現れます。そして、この匂いに気づけるかどうかが、センスの有無を分けます。ルールズ・オブ・プログラミング ―より良いコードを書くための21のルール作者:Chris Zimmermanオーム社Amazon2. 構造の美しさへの感受性センスのあるエンジニアは、「美しいコード」と「醜いコード」を区別できます。そして最も重要なのは、なぜ美しいと感じるのか、その理由を言語化できることです。「この関数は単一責任原則を守っているから美しい」「この命名は意図が明確に伝わるから良い」「この抽象化は読みやすさと柔軟性を両立しているから綺麗」単に「良い」「悪い」と感じるだけでなく、その判断の根拠を意識できる。これがセンスです。そして、この言語化能力が、他者にも伝えられる知見へと昇華されます。Good Code, Bad Code ～持続可能な開発のためのソフトウェアエンジニア的思考作者:Tom Long秀和システムAmazon改訂新版　良いコード／悪いコードで学ぶ設計入門 ―保守しやすい　成長し続けるコードの書き方作者:仙塲 大也技術評論社Amazon3. 問題の本質を見抜く力最も価値が高いのは、表面的な問題の背後にある本質的な問題を見抜く力です。例えば、バグが報告されたとします。表面的には「nullポインタ例外」かもしれません。しかし、センスのあるエンジニアは、その背後に「状態管理の設計が不適切」という本質的な問題があることに気づきます。エラーログを見て、「このエラーが頻発しているということは、そもそもこの処理フローに問題がある」と洞察します。パフォーマンスの問題を見て、「これは単にクエリの最適化の問題ではなく、データモデルの設計から見直すべき」と判断します。この「一歩踏み込んで問題を捉える力」こそが、経験を超えたセンスの核心です。ライト、ついてますか　問題発見の人間学作者:ドナルド・C・ゴース,ジェラルド・M・ワインバーグ共立出版Amazonセンスは訓練できるのかここまで読んで、「じゃあセンスは才能じゃないか」と思うかもしれません。違います。センスも訓練できます。なぜなら、センスとは突き詰めれば「何に注目するか」という習慣と、「それを面白がれるか」という姿勢だからです。どちらも意識的に育てることができます。熟達論―人はいつまでも学び、成長できる―作者:為末大新潮社Amazon訓練法1：意識的な観察の習慣最初は意識的に練習します。コードレビューをするとき、ただ「動くか動かないか」だけでなく、以下の点に注目してみます。関数の長さのバランスは適切か命名に一貫性はあるか、揺らぎは意図的か抽象度の上下動に違和感はないかコメントの密度は適切か変数のスコープの範囲は適切か最初は面倒です。でも、こうした細部に意識的に注目する習慣を続けていると、やがて自然と細部が目に入るようになります。これがセンスを磨くということです。訓練法2：本質を掴む読み方優れたエンジニアのコードを読むとき、ただ写経するのではなく、その背後にある思考を読み取ろうとします。なぜこの構造を選んだのかなぜこの命名にしたのかなぜこの順序で処理しているのかなぜこの部分だけ抽象化したのかそして、そこから本質的な要素を抽出し、自分のコードに応用する。この「本質を掴む」プロセスを繰り返すことで、表面的なパターンの暗記を超えた理解が生まれます。訓練法3：面白がる回路を作る最も重要なのは、問題を面白がる姿勢を育てることです。センスのあるエンジニアは、エラーや問題を「厄介だ」ではなく「興味深い」と捉えています。この姿勢は、選択できるものです。最初は意識的に「これは面白い」と自分に言い聞かせます。「このバグ、再現条件が複雑で面白い」「このエラーメッセージ、何を伝えようとしているのか興味深い」「この設計の問題、どう解決すべきか考えるのが楽しい」こうした「面白がる回路」を作ることが、センスを磨く本質です。すると徐々に、本当に面白く感じられるようになってきます。そして、面白がれるようになると、自然と深く考えるようになり、結果としてセンスが磨かれます。技術力もセンスも、どちらも成長可能結局のところ、技術力を構成する二つの軸──経験の蓄積とセンスという洞察力──は、どちらも成長可能な能力です。経験は、時間をかけて多くの問題に向き合うことで自然と積み重なります。失敗を恐れず、様々なことに挑戦することで、経験値は増えていきます。センスは、意識的な訓練によって磨かれます。細部に注目し、本質を掴もうとし、問題を面白がることで、徐々に洞察力が深まっていきます。どちらも「才能」という固定的な能力ではありません。時間と意識的な努力によって育てられるスキルなのです。「あの人は技術力がある」と言われる人は、単に先に始めて多くの経験を積んだか、意識的にセンスを磨く習慣を持っているか、あるいはその両方です。そして、その両方とも、今からでも始められます。才能という名の逃避「才能がない」という言葉は、一見すると謙虚に聞こえます。しかし実のところ、これは危険な自己欺瞞です。なぜなら、才能という言葉を使った瞬間、私たちは変化の可能性を放棄してしまうからです。「才能がないからできない」は、「努力してもどうせ無理」と同義です。そして一度この思考に陥ると、成長のための努力そのものが無意味に思えてきます。私自身、新人時代にこの罠に嵌っていました。新しい技術概念と格闘していた頃、何度もこう思いました。「自分にはこの考え方を理解する才能がないのだろう」と。そしてその思考は、学習を放棄する口実となりました。難しいドキュメントを読むことを避け、エラーメッセージと真剣に向き合うことから逃げました。でも、ある時気づきました。私が「才能がない」と諦めていた領域で活躍している先輩たちも、実は最初から理解していたわけではありませんでした。彼らは単に、私が避けていた苦痛と向き合い続けていただけだったのです。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazon性格と人格才能を考える上で、重要な区別があります。それは性格と人格の違いです。性格とは、通常の日にどう反応するか──つまり、私たちの自然な傾向や気質のことを指します。一方で人格とは、困難な日にどう振る舞うか──つまり、意図的に選択される態度や行動のことです。この区別は、才能という概念を理解する上でとても重要です。私たちはよく、性格と人格を混同してしまいます。「私は物覚えが悪い」「集中力がない」「創造性がない」──これらは一見すると先天的な限界のように聞こえます。しかし実際には、これらの多くは人格、つまり訓練可能な能力の領域なのです。例えば、「集中力がない」と自己評価する人の多くは、実は集中する環境や方法を知らないだけかもしれません。スマートフォンの通知をオフにし、作業を25分単位に区切り、定期的に休憩を取る──こうした具体的な方法を実践することで、「集中力」は劇的に向上します。重要なのは、こうした能力を「才能」ではなく「性格スキル」として捉え直すことです。才能は固定的で変えられないものですが、スキルは練習によって向上させることができます。この視点の転換が、成長への扉を開くのです。世界一やさしい「才能」の見つけ方　一生ものの自信が手に入る自己理解メソッド作者:八木 仁平KADOKAWAAmazon不快感という成長の証才能という幻想から抜け出すために、もう一つ重要な認識があります。それは、学習における不快感の本質的な役割です。「快適に学べる」というのは、実は矛盾した概念かもしれません。スキルを真に習得するまで快適にはなれないのですが、習得する前の練習は必然的に不快だからです。そして人は、その不快感を避けようとします。これが、多くの人が成長の途中で挫折する根本的な理由です。Docker最適化の学習を例に取りましょう。BuildKitのキャッシュ戦略を理解しようとするとき、最初はかなり混乱します。レイヤーの仕組み、マウントの種類、キャッシュの無効化条件──これらの概念は最初、全く繋がらない断片として現れます。この混乱は不快です。だから多くの人は、「とりあえず動けばいい」と表面的な理解で妥協します。しかし、この不快感こそが成長の証なのです。脳が新しい構造を構築しようとしている証。既存の理解の枠組みが崩れ、新しい理解が生まれつつある証です。この不快感から逃げずに、むしろそれを「成長が起きている」というサインとして受け入れられるかどうか──それが、習得できる人とできない人を分ける分岐点になります。「快適なら、やり方が間違っている」という言葉があります。この言葉は、学習の本質を突いています。本当の成長は、常にコンフォートゾーンの外側で起きるのです。ネガティブ・ケイパビリティ　答えの出ない事態に耐える力 (朝日選書)作者:帚木　蓬生朝日新聞出版Amazon才能がないと言う前にインターンシップやワークショップで若手と一緒に作業をしていて気づいたことがあります。「才能がない」と自己評価する人の多くが、実は才能の問題ではなく、もっと基礎的なプロセスを飛ばしているだけだということです。syu-m-5151.hatenablog.comドキュメントを読んでいない「自分には向いていない」と言う学生がいました。コードがうまく動かないし、エラーが理解できないと。しかし彼は、エラーメッセージを実際には読み飛ばしていたのです。エラーメッセージには「Expected type X, but got type Y」と明確に書いてあります。しかし「type X」という文字列だけを拾って、期待される型と実際の型が違うという関係性を読み取っていませんでした。これは彼だけの問題ではありません。ドキュメントを「読んでいるつもり」でも、実際には自分の仮説に都合のよい部分だけを拾い読みしている人は驚くほど多いのです。APIのリファレンスに「このメソッドは非同期です」と書いてあっても、Promiseを返すのか、コールバックを受け取るのか、await可能なのか──書かれているはずの詳細を読んでいません。仮説を一つずつ潰していない別の学生は「バグが見つからない」と何時間も格闘していました。しかし彼は、複数の仮説を同時に追いかけて、どれも中途半端に確認していたのです。「ネットワークの問題かもしれない」と言いながらネットワークのログを確認せず、「データベースの問題かもしれない」と言いながらクエリを確認しない。問題解決には、仮説を一つずつ潰していくプロセスが必要です。この地道なプロセスを飛ばして、「なんとなく」で進めようとするから、何時間経っても解決しないのです。仮説行動――マップ・ループ・リープで学びを最大化し、大胆な未来を実現する作者:馬田隆明英治出版Amazon主語と述語を把握していない技術文書を読むとき、主語と述語の関係を曖昧にしたまま読み進めている人は非常に多いのです。「誰が」「誰に」「何を」しているのか──この基本的な構造を把握しないまま、「なんとなく」で理解したつもりになっています。小さなことの積み重ねエラーメッセージをちゃんと読む。仮説を一つずつ潰す。主語と述語を把握する。誰でもできることです。しかし、この「小さなこと」の積み重ねが、「才能がある」ように見える人と「才能がない」と思い込む人を分けています。才能があるように見える人は、これらの基礎的なプロセスを、意識的か無意識的に実践しています。これらは訓練可能です。才能ではありません。最初は意識的にやる必要があります。めんどくさいと感じるかもしれません。でも、この「めんどくさい」基礎作業を飛ばすから、結果的に何倍も時間がかかってしまうのです。なぜ、ちゃんと読めないのか「ちゃんと読むことによる成功体験」が積めていない──これが、根本的な問題かもしれません。奪われた集中力: もう一度〝じっくり〟考えるための方法作者:ヨハン・ハリ作品社Amazonインスタント化と「モヤモヤ」への耐性の喪失私たちは今、インスタントで断片的な刺激に取り巻かれています。YouTubeのレコメンド、TikTokの短い動画、LINEスタンプ──一定のリズムで繰り返されるインスタントで分かりやすい感覚やコミュニケーションが蔓延しています。スマホを持つことで、即時的な満足にいつでもアクセスできる状態にあり、「消化しきれなさ」「難しさ」「モヤモヤ」といった時間もコストもかかるものは人気がなくなっています。技術ドキュメントを読むことは、まさにこの「モヤモヤ」との戦いです。一読してすぐに理解できるものではありません。何度も読み返し、実際に試し、エラーに出会い、また読み返す。この時間のかかるプロセスが、インスタント化した感覚に慣れた私たちには耐えがたいのです。新しい技術を学ぶとき、最初は「モヤモヤ」します。でも、このモヤモヤした状態を抱えたまま、読み続け、試し続けることでしか、深い理解には到達できません。ChatGPTやClaudeに「要約して」と頼んでしまう。確かに、それでスッキリはします。でも、その過程で失われるものがあります。孤独と孤立の喪失スマホによる常時接続の世界では、何か一つのことに取り組み、一つのことに没頭する＜孤立＞が喪失しています。反射的なコミュニケーションを積み重ねるということは、相手の人格や心理状態を想像しないコミュニケーションです。同時に、退屈に耐えきれず、何か刺激やコミュニケーションを求めてスマホをいじってしまい、自分一人で時間を過ごす＜孤独＞も失われかけています。スマホ時代に必要なのは孤独と孤立であり、それらがあってこそ、自分を浸している感覚に耳を澄ませ、刺激的な経験と折り合いをつけることができます。技術ドキュメントを読むことは、まさにこの「孤立」を必要とします。一人で、ドキュメントと向き合う時間。このシンプルな行為が、現代では驚くほど難しくなっています。ネガティブ・ケイパビリティの欠如ネガティブ・ケイパビリティとは、「結論づけず、モヤモヤした状態で留めておく能力」です。把握しきれない謎をそのまま抱えておくことで、そこから新しい何かをどこまでも汲み取ろうとする姿勢のことです。これは、他者の経験を理解したり、技術を学んだりするときに必要です。謎を安易に「自分のわかる範囲」に回収しない能力と言えます。新しい技術を学ぶとき、すぐに「わかった」と思いたくなります。でも実際には、わかっていないことだらけです。このモヤモヤした状態を抱えたまま、読み続け、試し続ける。この能力が、現代人には欠けているのかもしれません。自己啓発の罠と他者の想像力悩みや困難を抱えている人は、「自分の直観に従って判断しろ」「自分の情熱に従え」というメッセージに心を揺さぶられます。しかし、このアプローチには内なる声は一つであり、その声こそ自分を然るべき一つの進路へと導いてくれるはずという前提があります。他者の想像力は、「ノイズ」としてラベリングされてしまいます。私たちは、一枚岩のような存在ではありません。自分の内側にはいくつもの声が発せられています。「他者に見られる自分」も自分の重要な構成要素となるので、他者はノイズどころか、自分を豊かに育てるものです。「才能がない」という言葉も、実はこの自己啓発の罠と表裏一体です。「才能がないから無理」は自己責任の裏返しです。でも実際には、他者の想像力を借りること、ドキュメントを丁寧に読むこと、先輩に質問することは、ノイズではなく成長の糧なのです。「自分の頭で考える」の代わりに、「他人の頭で考える」「他者の想像力を自分に取り入れる」ことが大切です。才能ではなく、学び方の問題「才能がある」と見なされる人々を注意深く見ると、彼らの多くは特別な能力を持っているわけではありません。彼らは効果的な学び方を知っているだけなのです。例えば、指摘と助言の違いを理解している人は、より速く成長します。「このコードのどこが悪いですか?」は指摘を求める質問で、過去の実績に焦点を当て、しばしば批判的な応答を引き出します。一方で「このコードをより保守性の高いものにするにはどうアプローチすべきでしょうか?」は助言を求める質問で、未来に焦点を当て、建設的な提案を引き出します。この小さな違いが、学びの質を大きく変えます。才能があるように見える人は、こうした学び方の技術を実践しています。彼らは「分からない」と素直に認め、「教えてください」と謙虚に頼み、そして得られた助言を素直に実践します。これは才能ではなく、態度の問題なのです。学びとは何か－〈探究人〉になるために (岩波新書)作者:今井 むつみ岩波書店Amazon後退も成長のプロセスの一部才能という概念を手放すと、もう一つ重要な認識が生まれます。それは、成長が必ずしも直線的ではないということです。私たちは、成長を一方向的な進歩として捉えがちです。しかし実際の成長は、螺旋を描くように進んでいきます。前進し、停滞し、時には後退し、そしてまた前進します。この後退期を「才能がない証拠」として捉えるか、「成長のための再編成」として捉えるかで、その後の軌道は大きく変わります。技術を学ぶ過程でも、この現象は頻繁に起きます。新しいフレームワークを学び始めた当初は順調に進みます。しかし、ある程度理解が深まると、突然全てが分からなくなる瞬間が来ます。これは実は、表面的な理解から深い理解へと移行する兆候なのです。しかし多くの人は、この瞬間を「やはり自分には才能がない」と解釈し、学習を放棄してしまいます。人は前進するために時に立ち止まり、後退し、そしてまた前進した先には以前よりも大きく飛躍しています。このプロセスを理解することで、停滞期や後退期を前向きに捉え直すことができます。それは失敗ではなく、次の飛躍のための準備期間なのです。手を動かすことの救いエンジニアという仕事には、一つの大きな救いがあります。それは、手を動かしている間、才能への不安が消えるということです。「自分には才能がない」という悩みは、頭の中でぐるぐる回り始めると、どんどん大きくなります。でも「これを作りたい」と思って実装を始めた瞬間、その悩みはどこかに消えます。目の前にあるのは、具体的な問題だけです。エラーが出る。調べる。解決する。また詰まる。また調べる。この「詰まる→調べる→解決する」のサイクルを回すこと自体が、静かに自信を育てていきます。最初は1つのエラーに1時間かかったのが、30分になり、10分になる。その変化を実感するとき、「成長している」という手応えが得られます。理想ではなく、作りたいものを追う重要なのは、「優秀なエンジニアになりたい」という抽象的な目標ではなく、「このアプリを作りたい」「この機能を実装したい」という具体的な目標に向かって手を動かすことです。完璧主義に陥る人は、結果に過度な完成度を求めるあまり、小さな一歩を踏み出せません。「理想的なアーキテクチャを設計してから始めよう」「全ての技術を理解してから作ろう」──そう考えて、結局何も始められない。でも実際には、小さく作って、動かして、直して、また作る。このサイクルを回すことでしか、良いものは生まれません。一つのエラーを解決する。一つの機能を実装する。一つのテストを通す。この小さな積み上げが、気づけば大きなものになっています。綿密な計画よりも、不完全でも動く一歩の方が、はるかに価値があります。あえて視野を狭めろここで、少し逆説的なことを言います。特に若い時期には、根拠がなくても、自分を信じることが重要です。「才能という幻想」を批判してきたこの記事で、矛盾するように聞こえるかもしれません。しかし、「自分には才能がある」という固定的な思い込みと、「自分はできるようになる」という成長への信頼は、全く別物です。若いうちは、視野をあえて狭めることも必要です。「これが本当に正しい道なのか」「自分に向いているのか」──そんな冷静な自己分析ばかりしていると、一歩も踏み出せなくなります。時には、根拠のない自信を持って、盲信的に突き進むことも必要です。「プログラミングなんて簡単だろう」という、ある意味で無知ゆえの大胆さ。この「若気の至り」とも言える姿勢が、最初の一歩を踏み出させてくれます。その盲信的な姿勢が、いつか本当の自信に変わります。根拠のない自信が、実績という根拠を伴った自信になります。そして気づけば、最初は「嘘」だった「自分はできる」という言葉が、本当になっているのです。問題を面白がる力もう一つ、見落とされがちな視点があります。それは、学びにおける遊び心です。才能があるように見える人は、実はこの遊び心を持っています。彼らは学びを苦痛として捉えるのではなく、謎解きとして楽しんでいます。新しいバグに出会えば「面白い現象だ」と興味を持ち、理解できない概念に出会えば「理解できたら面白そうだ」と好奇心を抱きます。この姿勢は、才能ではなく選択です。同じ状況を「苦痛」として捉えるか「挑戦」として捉えるか──その選択が、長期的な成長の軌道を決めます。そして、この選択は意識的に訓練できます。義務として学ぶのではなく、探究心を持って取り組むとき、人は最も成長します。ぐちゃぐちゃ考える暇があったら才能があるかどうかなんて、作っているときには関係ありません。目の前のエラーメッセージは、あなたが才能があるかどうかなんて気にしていません。ただ、解決策を求めているだけです。ドキュメントを読む。エラーメッセージをちゃんと読む。仮説を立てて検証する。うまくいかなければ別の方法を試す。これらは全て、才能ではなく、プロセスです。コンテストで優秀な成績を残した人たちも、結局は同じことをしています。彼らが特別なのではありません。ただ、このプロセスを高速で回せるようになっただけです。そして、その高速化は、繰り返しによってしか得られません。自分が未熟だと不安に思いながらインターンシップを始めた私が、3年経って確信していることがあります。それは、手を動かし続けた人は、必ず前に進んでいるということです。才能について悩む時間を、1行でも多くコードを書く時間に変える。理想の自分について考える時間を、作りたいものを作る時間に変える。その積み重ねが、気づけば「成長」と呼ばれるものになっています。才能という言葉を使わないここまで読んで、一つの結論に至るかもしれません。それは、才能という言葉を使わないことの重要性です。「才能がある」「才能がない」──この二元論は、成長の可能性を見えなくしてしまいます。代わりに、より具体的で建設的な言葉を使うべきです。「まだ学んでいない」「まだ練習が足りない」「まだ自分に合った学び方に出会っていない」──こうした表現は、現在の状態を固定的なものではなく、変化可能なものとして捉えさせます。インターン生に技術を教える際も、この視点の転換を意識しています。「才能がない」という言葉を聞いたら、必ず問い返します。「具体的に、何が難しいと感じている?」と。すると、「才能」という曖昧な概念ではなく、具体的な課題が見えてきます。そして具体的な課題は、具体的な対策で解決できます。「あなたには向いていないかも」ではなく、「どういう環境や説明の仕方なら理解できるだろうか」と考えます。この視点の転換が、教育者として最も重要な態度なのかもしれません。では、才能という言葉を使わないとしたら、何を語るべきなのでしょうか。それは、成長のメカニズムそのものです。どうすれば効果的に学べるか。どうすれば困難に直面しても諦めずに続けられるか。どうすれば自分の可能性を最大限に引き出せるか──こうした実践的な問いに答えることが、才能という幻想よりもはるかに価値があります。これは抽象的な話ではありません。とても実践的な話です。毎朝同じ時間に起きる習慣。集中できる環境を整える工夫。失敗から学ぶための振り返りの時間。他者から助言を求める勇気──これらは全て、トレーニング可能なスキルです。そして、これらのスキルの蓄積が、才能と呼ばれるものの正体なのかもしれません。HIDDEN POTENTIAL 可能性の科学――あなたの限界は、まだ先にある (三笠書房　電子書籍)作者:アダム・グラント三笠書房Amazon時間という最も公平な資源才能という概念に対して、時間は最も公平な資源です。どんな人にも、1日は24時間しかありません。もちろん、その24時間をどう使えるかは、環境によって大きく異なります。しかし、与えられた時間の中で、何を選択するか──その選択の積み重ねが、最終的な差を生みます。才能がある人とない人の違いは、実は時間の使い方の違いなのかもしれません。才能があるように見える人は、学習に多くの時間を投資しています。しかしそれは、単純に勉強時間が長いという意味ではありません。むしろ、質の高い時間の使い方を知っているということです。例えば、同じ1時間でも、受動的にチュートリアルを見るのと、能動的に問題を解こうとするのでは、学びの質が全く異なります。同じエラーに出会っても、すぐに答えを探すのと、まず自分で考えてみるのでは、理解の深さが変わります。時間という公平な資源を、どう使うか。これは才能ではなく、戦略の問題です。そして戦略は、学ぶことができます。あっという間に人は死ぬから　「時間を食べつくすモンスター」の正体と倒し方作者:佐藤 舞（サトマイ）KADOKAWAAmazonどうしようもなく満たされない性質についてここまで「才能という言葉を使わないこと」を言ってきましたが、最後に一つだけ、もしエンジニアに才能というものがあるとすれば何か、という問いに答えたいと思います。それは、どうしようもなく満たされない性質です。知りたいと思う。理解したいと思う。作りたいと思う。解決したいと思う。そして、その過程を楽しめる。それをしてないと、ちゃんと生きていけない。そういう性質。これは祝福でもあり、同時に呪いでもあります。なぜなら、これらの能力はコントロールできないことが多いからです。夜中の3時に突然コードのことを考え始める。休日なのに技術ドキュメントを読んでしまう。趣味と仕事の境界が曖昧になる。多くの不都合を抱えています。だから、あまり気にしなくて良いのです。才能と能力が一致しているのは、かなり稀です。「満たされなさ」を持っていても、それが必ずしも成果に結びつくわけではありません。逆に、その「満たされなさ」を持たずとも、優れたエンジニアになることは十分に可能です。自分に才能があるのかないのか。何者かになれる人となれない人の違いは何なのか。その境目はありません。「才能がある」とか「天才だ」というのは、原因ではなく結果に対して付けられる評価です。何かを成し遂げた後で、周りが「あの人には才能があったんだ」と言うだけです。始める前から、自分に才能があるかどうかなんて、誰にも分かりません。そして、それを気にする必要もありません。重要なのは、今、目の前にあることに取り組むかどうか。その選択だけです。ご冗談でしょう、ファインマンさん（上） (岩波現代文庫)作者:Ｒ．Ｐ．ファインマン岩波書店Amazonご冗談でしょう、ファインマンさん（下） (岩波現代文庫)作者:Ｒ．Ｐ．ファインマン岩波書店Amazonおわりに様々な場所で、様々な「才能」を目撃してきました。コンテスト会場、企業のオフィス、勉強会、ワークショップ──華々しく成功した人も、静かに立ち去った人も、黙々と歩き続けている人も。私が伝えたかったのは「才能なんて存在しない」という単純なメッセージではありません。「才能という言葉を使うことで、私たちは何を見失っているのか」ということです。才能という言葉は便利です。でも、その便利さと引き換えに、私たちは変化の可能性を、成長の余地を、自分と他者の可能性を信じる力を手放しています。「才能がない」という言葉を、もし今、心の中で繰り返しているのなら──それは本当は違うかもしれません。エラーメッセージを、ちゃんと読んでいないだけかもしれません。仮説を、一つずつ潰していないだけかもしれません。インスタントな答えを求めて、モヤモヤと向き合っていないだけかもしれません。まだ、自分に合った学び方に出会っていないだけかもしれません。小さなことです。でも、その小さなことを飛ばしているから、「才能がない」と思い込んでしまう。コンテストで輝いていた同期が、燃え尽きていることがあります。勉強会で熱心だった後輩が、姿を見せなくなることがあります。一方で、当時は目立たなかった誰かが、誰も予想しなかった場所で花を咲かせていることもあります。スタート地点の優劣など、長い人生においてはほとんど意味をなさない──20代を通じて、私はそう学びました。あなたの可能性は、スタート地点では測れません。どれだけ伸びたか、どれだけ学んだか、どれだけ変化したか──それこそが、本当の意味での能力です。才能という幻想を手放したとき、初めて見えてくる景色があります。それは、不完全な今の自分を受け入れ、それでも前に進み続けることの静かな勇気です。未熟な自分がインターンシップを始めて3年。今でも不安はあります。でも、若手と一緒に作業する中で気づきました。彼らが必要としているのは、全てを知り尽くした指導者ではありません。共に悩み、共に考え、そして「才能」という言葉で可能性を閉ざさない、そんな誰かです。この記事を通じて、私自身もまた、自分に言い聞かせています。才能があるかどうかなんて、後になってから誰かが決めることです。大切なのは、今、目の前にあることに手を動かし続けること。その積み重ねだけです。最後に、私自身のことを少しだけ。私にはいくつかの目標があります。世界的に有名なOSSを作って、海外で見知らぬ人にコーヒーを奢ってもらいたいです。書籍をコンスタントに出して、いつか道端でサインを求められたいです。週刊プレイボーイに連載を載せて、毎週誰から指摘されても反論ができるようにグラビア雑誌を買うことです。できるかどうかは分かりません。才能があるかどうかも分かりません。でも、文章を書き続けています。コードを書き続けています。なぜなら、それが私にとって「満たされなさ」を満たす行為だからです。そして、その過程を楽しんでいるからです。あなたにも、そんな「満たされなさ」があるなら。それに向かって、ただ手を動かし続けてください。それが才能かどうかなんて、後になってから誰かが決めることです。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[今更ながらadkを使ってみた]]></title>
            <link>https://zenn.dev/akasan/articles/637c35253400e7</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/637c35253400e7</guid>
            <pubDate>Mon, 27 Oct 2025 12:50:38 GMT</pubDate>
            <content:encoded><![CDATA[今回はadkを使ってみました。すでに提供が開始されてからかなり日数が立っていますが使っていなかったことに気づきまして、今回Qucikstartを試してみました（エージェントを実装できる方法が他に色々ありすぎて漏れていましたw）。 adkとは？adkとはAgent Development Kitの省略であり、エージェントを開発・デプロイするためのフレームワークになります。GeminiやGoogleのエコシステムに最適化されてはいますが利用するモデルについてはそれ以外のものも利用でき、他のフレームワークと互換性があるものとなっています。利用用途としてはadkをつかってエージェントをくみ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[技術力に優劣はある(「技術力に優劣はない」を読んで)]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/10/27/134629</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/10/27/134629</guid>
            <pubDate>Mon, 27 Oct 2025 04:46:29 GMT</pubDate>
            <content:encoded><![CDATA[sizu.meはじめに先日、「技術力に優劣はない（技育などに参加している学生に向けて）」という記事を読みました。技育に参加する学生たちへの励ましのメッセージで、技術との向き合い方の多様性を認め、コミュニケーション力の重要性を説き、相互リスペクトの大切さを訴える、とても温かい内容でした。この記事は、あの記事の対象読者ではない私が、横から口を出すような形になってしまうことを承知で書いています。 元の記事の主張——技術の感受性には段階があること、ジュニアにはコミュニケーションが大事なこと、べき論に揺さぶられないこと、どの段階にいてもキャリアは作れること——これらは本質的に正しいと思います。ただ、私はこう思います。それでもなお、技術力という軸においては、やはり優劣が存在し、それが中長期的なキャリアに大きな影響を与えます。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきましょう。技術との向き合い方元の記事では、技術への向き合い方を3段階に分けていました。この分類は本質を捉えていると思います。技術を道具として使う人技術を理解する人技術を創る人この分類自体はとても良いのですが、私はこれをポケモンの進化のような段階的なものとは捉えていません。むしろ、これらは固定的な段階ではなく、状況や分野によってシームレスに行き来するものだと感じています。例えば、Reactについては深い理解があり、新しいパターンを生み出せる人でも、機械学習の分野では既存のライブラリを使うだけかもしれません。人は常に3つの状態を往復しています。新しい分野に挑戦すれば「道具として使う」状態に戻りますし、経験を積めば「理解する」状態に移行し、さらに探求すれば「創る」状態に到達します。それぞれの状態の中には優劣は存在するここで重要なのは、これら3つの状態は確かに流動的ですが、それぞれの状態の中には明確に優劣が存在するということです。「道具として使う」中には優劣があります。 同じ「道具として使う」状態でも、ドキュメントを読んで適切に活用できる人と、エラーが出たらすぐに諦めてしまう人では、生産性に大きな差があります。基本的な概念を理解しながら使っている人と、ほぼブラックボックスとして使っている人では、応用力が全く異なります。そして今、生成AIを効果的に活用できる人とそうでない人では、学習速度に圧倒的な差が生まれています。エラーメッセージをAIに投げて適切な解決策を引き出せる人と、ただコピペして満足する人では、問題解決能力が変わってきます。「理解する」中には優劣があります。 内部実装を読んで理解している人と、公式ドキュメントレベルの理解に留まっている人では、問題解決能力に差があります。パフォーマンスの特性やエッジケースまで把握している人と、基本的な使い方だけ知っている人では、設計の質が変わってきます。ここでも生成AIの活用法に差が出ます。複雑なコードベースの理解を加速するためにAIを使える人と、単に「これ何してるの？」と聞くだけの人では、深い理解への到達速度が違います。技術的な仮説を立て、AIに検証させながら学びを深められる人は、独学だけの人より効率的に専門性を高められます。「創る」中には優劣があります。 既存のものを少し改良したレベルと、まったく新しいパラダイムを生み出すレベルでは、技術的なインパクトが桁違いです。自分のプロジェクトで使える小さなライブラリを作る人と、業界全体に影響を与えるOSSを開発する人では、その影響力は比較になりません。そして今、生成AIを創造のパートナーとして使いこなせる人とそうでない人では、アウトプットの質と量に大きな差が生まれています。アイデアの壁打ち相手としてAIを使い、設計の初期段階を加速できる人。実装の定型部分をAIに任せ、本質的な設計に集中できる人。こういった使い方ができる人は、同じ時間でより高度なものを創り出せます。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazon向き合い方の違いを優劣として捉えがちしかし、学生や若いソフトウェアエンジニアは、この向き合い方の違いを、ソフトウェアエンジニアとしての優劣として捉えがちだという側面があります。「自分は道具として使っているだけだから、ダメなエンジニアだ」「あの人は技術を創っているから、自分よりずっと上だ」こういった思考に陥りやすいです。それが過度な自己否定につながったり、逆に、ある分野で「創る」状態に到達したことで慢心したりします。しかし、向き合い方は分野によって変わります。誰もが全ての技術について「創る」状態にいるわけではありません。そして、「道具として使う」状態であることが、必ずしも劣っているわけではありません。重要なのは、どの状態にいるかではなく、その状態の中でどのレベルにいるか、そして複数の領域でどう組み合わせているかです。熟達論―人はいつまでも学び、成長できる―作者:為末大新潮社Amazon能力ではなく衝動や偏愛人を「道具として使う」状態から「理解する」状態へ、さらには「創る」状態へと突き動かすものは、おそらくは計画的なキャリアデザインではありません。むしろ、それは衝動や偏愛に近いものだと思います。あるいは、そうした衝動を自然と抱けるような環境に身を置けるかどうかです。「なぜかこのエラーメッセージが気になる」「この実装がどうなっているのか知りたくて仕方がない」「この技術で何かを作りたいという衝動が止まらない」——こういった、理屈では説明しきれない偏愛が、人を技術の深みへと引き込んでいきます。そして、周囲に技術を深く追求する人たちがいる環境は、そうした衝動を自然と育んでくれます。人生のレールを外れる衝動のみつけかた (ちくまプリマー新書)作者:谷川嘉浩筑摩書房Amazonそれでもなお、市場価値の差は存在するしかし、この3つの状態の間には、やはり市場価値の差が存在します。そして、どの状態に長く留まっているか、その状態の中でどのレベルにいるかが、中長期的なキャリアに大きな影響を与えます。「道具として使う」状態に留まり続けることのリスクは、年齢を重ねるほど大きくなります。表面的な理解しかないエンジニアは、年齢を重ねると「代替可能な人材」になっていきます。若手の方が給与が安く、学習意欲も高いです。同じ「道具として使う」状態であれば、企業が選ぶのは若手です。一方、主要な技術領域で「理解する」状態に到達できれば、市場価値は変わります。そして、いくつかの領域で「創る」状態に到達している人は、さらに大きな影響力を持ちます。さらに、同じ「理解する」状態でも、そのレベルの高さによって市場価値は大きく変わってきます。この差を「優劣ではない、違いだ」と言えるでしょうか？ 市場は明確に評価しています。ジュニアに技術力は求められていない？元の記事は「ジュニアに技術力は求められていない」と述べていました。確かに、新卒や入社1〜2年目であれば、それは正しいです。しかし、これを「技術力を磨かなくてもいい理由」にしてはいけません。「ITエンジニアの転職学」では年収600万円を超えるには、以下のような能力で「自立レベル」への到達が求められます。設計力/実装力：アーキテクチャ設計、コーディング、技術選定など専門性の深さと広さ：特定領域の深い知識と、周辺技術の幅広い理解推進力・プロジェクト貢献：プロジェクトを前に進める力、スケジュール管理組織貢献：チームビルディング、メンバー育成、採用への貢献事業・顧客貢献：ビジネス価値への理解、顧客課題の解決情報発信・プレゼンス：技術ブログ、登壇、OSS活動などこのレベルに到達するのは、通常は入社3〜5年目だと言われています。つまり、「ジュニアには技術力は求められていない」というのは、せいぜい20代半ばまでの話です。それを過ぎても設計力/実装力や専門性が低いままだと、キャリアは確実に行き詰まります。ITエンジニアの転職学 2万人の選択から見えた、後悔しないキャリア戦略 (KS科学一般書)作者:赤川 朗講談社Amazonコミュニケーション力と技術力は対立しない元の記事では、技術の勉強をしている人とそうでない人が対比され、後者は「別の有意義なことをしている」と書かれていました。確かに、ゲームをしたり、友達と飲みに行ったりする時間は人生において大切です。キャリアは短距離走ではなく、中長距離走です。 燃え尽きないことが重要であり、適度な息抜きや趣味の時間は必要です。しかし、それは「技術を学ばない理由」にはなりません。 むしろ、中長距離だからこそ、地道な積み重ねが最終的に大きな差を生みます。1年、3年、5年と継続的に学び続けることで、技術力は確実に向上します。なぜなら、優秀なエンジニアは、技術力もコミュニケーション力も両方高いからです。これは対立するものではなく、掛け算で効いてくるものです。私が見てきた優秀なエンジニアたちは、例外なく以下の特徴を持っていました。設計力/実装力が高い（主要技術について「理解する」以上の状態）コミュニケーション力も高いビジネス理解力がある学習意欲が高い「技術力がないから、コミュニケーション力で勝負する」というのは、戦略ではなく妥協です。本当に市場価値を高めたいなら、先ほど挙げた6つの能力を、バランス良く磨く必要があります。syu-m-5151.hatenablog.comキャリアの中盤で見えてくる分岐点20代のうちは、技術力の差はそれほど致命的ではません。コミュニケーション力や調整力でカバーできるし、「これから成長すればいい」という期待値もあります。しかし、キャリアの中盤になると、市場が求めるレベルは急激に上がります。技術的な意思決定ができることチームをリードできることアーキテクチャ設計ができること若手を育成できることこれらはすべて、高い技術力を前提としています。 コミュニケーション力だけでは、技術的な意思決定はできません。表面的な理解では、アーキテクチャ設計はできません。自分が技術を深く理解していなければ、若手を育成することもできません。早期のマインド切り替えと継続的な努力「追いつけない」ではなく「只々積み上げる」元の記事には、圧倒的なテックリードを見て「自分が3に行けることはないと実感した」という記述があった。この気持ちはよくわかります。圧倒的な技術力を持つ人を目の当たりにしたとき、「自分には無理だ」と感じる瞬間は、多くのエンジニアが経験することです。しかし、そのテックリードもまた、努力の積み重ねでそこに到達しているということを忘れてはいけません。彼らは最初から「創る」状態にいたわけではません。膨大な時間をかけて技術を学び、無数のエラーと格闘し、何度も失敗を繰り返し、そして徐々に深い理解を獲得していった。「あの人は天才だから」と片付けてしまうのは、その人が積み重ねてきた努力を見ないことになります。そして、自分自身の成長の可能性を閉ざすことにもなります。その積み重ねを軽く見てはいけません。確かに、技術に対する偏愛や衝動の強さは人それぞれです。しかし、それでもなお、努力で到達できる範囲は思っているより広いです。 毎日1時間でもいいです、技術書を読みましょう。個人プロジェクトに取り組みましょう。エラーメッセージと真剣に向き合いましょう。こういった地道な積み重ねが、1年後、3年後、5年後の自分を作ります。技術力が高いエンジニアは、キャリアの中盤以降も選択肢が広がり続けます。一方、主要技術について表面的な理解に留まっているエンジニアは、選択肢が狭まっていきます。これが、早期に技術力を磨くことの重要性です。達人プログラマー ―熟達に向けたあなたの旅― 第2版作者:David Thomas,Andrew Huntオーム社Amazonやる気は行動の後からついてくる「技術を学ばなければ」と頭では理解していても、なかなか実行に移せません。モチベーションが湧かません。やる気が出ません。こういった悩みを抱えている人は多い。しかし、ここで重要な真実があります。やる気を出すには、やるしかません。多くの人は「やる気が出たら始めよう」と考える。しかし、これは因果が逆です。やる気は行動の前に現れるものではなく、行動の後からついてくるものです。心理学の研究でも明らかになっているが、人間の脳は「行動を始めてから」やる気を出すようにできています。作業興奮という現象です。まずは5分だけコードを書いてみる。1ページだけ技術書を読んでみる。すると、脳が活性化し、自然と続けたくなります。「理想的な環境が整ったら」「十分な時間ができたら」「気分が乗ったら」——こういった条件を待っていても、その日は永遠に来ません。理想的な状態を待つのではなく、不完全なままでも始めることです。毎日30分でいいです。週末の2時間でいいです。小さく始めて、継続しましょう。それが1ヶ月、3ヶ月、1年と続けば、気づいたときには大きな差になっています。「やる気が出ないから動けない」のではなく、「動かないからやる気が出ない」のです。だから、やる気を出すには、やるしかありません。 今この瞬間から、小さな一歩を踏み出しましょう。ジェームズ・クリアー式 複利で伸びる1つの習慣作者:ジェームズ・クリアーパンローリング株式会社Amazon学生のうちに気づけるなら私が最も伝えたいのは、早期にマインドを切り替え、只々研鑽を積み重ねることの重要性だ。早く気づけば気づくほど、リカバリーは容易になります。学生なら今が絶好のタイミングです。時間はたっぷりあります。大学の授業だけでなく、個人プロジェクト、OSS、インターン——自分に合った形で技術と向き合いましょう。一時の成功も失敗も、長い人生の中では泡のようなものです。 今日のコンテストでの勝利も、明日の挫折も、それ自体は大した意味を持たません。重要なのは、そこから何を学び、次にどう活かすかです。そして、本当のトップレベルを見に行こう。 自分より優秀な人たちがいる環境に飛び込み、「ボコボコにされる」経験をしましょう。それは屈辱的かもしれないが、それこそが成長のチャンスです。ただし、一度の挫折で諦めないでほしいです。 圧倒的な実力差を見せつけられても、それは終わりではありません。自分の現在地を知る機会です。そこから、只々積み上げていけばいいです。社会人になってから気づいても遅くはない20代であっても、キャリアの中盤であっても、「技術力を磨かなければ」と気づいた時点から始めれば、必ず変わります。ただし、学生時代より難易度は上がります。家庭があるかもしれません。体力も落ちているかもしれません。それでも、今から本気で取り組めば、道は開けます。業務時間外の勉強を習慣化しましょう。技術書を読みましょう。個人プロジェクトを作りましょう。2〜3年本気で取り組めば、主要技術について表面的な理解から深い理解へと確実に移行できます。そうなれば、市場価値は大きく変わります。気づいた時点が、あなたにとっての「今」です。過去を悔やむより、今から只々積み上げていきましょう。キャリア戦略の選択肢エンジニアとして生きていく上で、大きく分けて2つの戦略があります。選択肢1: 技術のスペシャリストを目指す本気で技術を磨き、技術者として高い評価を得られるエンジニアになります。これは楽な道ではません。業務時間外も勉強し、常に新しい技術にキャッチアップし、OSSにコントリビュートし、深夜までコードを書きます。しかし、その努力は報われる。キャリアの中盤で選択肢が広がり、技術者としての充実感を得られます。市場価値も高く、転職の選択肢も豊富です。スタッフエンジニア　マネジメントを超えるリーダーシップ作者:Will Larson日経BPAmazon選択肢2: 技術とビジネスのバランス型を目指す設計力/実装力は一定レベルに抑え、組織貢献や事業・顧客貢献で価値を出す。プロダクトマネージャーやエンジニアリングマネージャーを目指す道です。これも立派な戦略です。しかし、技術の基礎理解は必須です。 表面的な理解だけで「マネジメントに進む」というのは、逃げに過ぎません。マネージャーやPMになっても、技術を深く理解していなければ、チームから信頼されず、技術的な制約や可能性を踏まえた意思決定もできません。どちらを選ぶにせよ、技術力に優劣があることを認め、自分の現在地を正確に把握することが、全ての出発点です。 そして、気づいた時点から、只々積み上げていくことが大切です。エンジニアのためのマネジメントキャリアパス ―テックリードからCTOまでマネジメントスキル向上ガイド作者:Camille FournierオライリージャパンAmazon一つの物差しで人を測るなここまで技術力の重要性を語ってきたが、同時に伝えておきたいことがあります。学生時代から社会人の初期にかけて、私はカンファレンスやイベントで、相手の技術的な知識を試すような会話をしていました。わざと難しい質問を投げかけて、相手が答えられないのを見て優越感に浸る。今振り返ると、最低です。当時の私は、技術力の有無だけで人間の優劣を測っていました。学生のギーク層にありがちな行動だが、自分がイキれる相手を見つけて、マウントを取るのは確かに気持ちがいい。でも、それは恥ずべき行為です。他者と働く──「わかりあえなさ」から始める組織論 (NewsPicksパブリッシング)作者:宇田川元一ニューズピックスAmazonただし、逆の極端も問題だと思っています。世の中には「技術力なんてどうでもいい、面白い人間かどうかが全て」という価値観もあります。確かに、人間的な魅力は重要です。でも、それを唯一の評価軸にして「技術バカは使えない」「コミュ力こそ全て」と言い切るのも、結局は別の物差しで人を測っているだけです。技術力で人を測るのも、コミュ力で人を測るのも、面白さで人を測るのも、本質的には同じ過ちです。この記事で私は「技術力の優劣を直視せよ」と書いてきた。市場価値という文脈では、技術力の差は厳然として存在します。それを無視してキャリアを語ることはできません。しかし、それはあくまで市場価値という一つの軸での話です。 技術力が高いからといって人として偉いわけではません。逆に、技術力が低いからといって人として劣っているわけでもません。イベントで出会った人が、あなたより技術的な知識が少ないように見えても、その人にはその人の文脈があります。学びの途中かもしれません。別の分野のエキスパートかもしれません。技術以外の部分で圧倒的な価値を生み出している人かもしれません。大切なのは、相手の文脈を読み取って会話できることです。 自分の得意な物差しだけで人を評価し、優越感に浸るのは、いくら専門性が高くても人として未熟です。技術力を磨くことと、人として成熟することは、まったく別の話なのだから。「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策作者:今井むつみ日経BPAmazonおわりに長々と書いてきたが、最後にもう一度、元の記事への敬意を示したい。元の記事は、学生たちを励まし、多様性を尊重し、相互リスペクトを訴える、とても温かい内容でした。その優しさと配慮は、本当に素晴らしいと思います。私はこの記事で「技術力に優劣はある」と主張してきた。それは市場価値やキャリアという観点では事実です。しかし同時に、技術力で人間の価値を測ってはいけません。技術力が高いことと、人として成熟していることは別物です。むしろ、技術力があるからこそ、謙虚さとリスペクトを忘れてはいけません。「優劣はない」という優しい言葉に安住せず、現実を直視してほしいです。そして、今のうちに本気で技術を学んでほしいです。キャリアは中長距離走です。 今なら、まだ間に合います。ただし、技術を学ぶ過程で、決して人を見下してはいけません。相手の文脈を理解し、リスペクトを持ってコミュニケーションを取りましょう。それができて初めて、優秀なエンジニアと言えるのだと思います。この記事は、元の記事の筆者や読者を否定する意図はありません。対象読者ではない私が横から口を出すような形になってしまい申し訳ありませんが、学生時代の自分に伝えたかったこと、そして過去の自分を反省する気持ちを込めて書きました。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：sshm]]></title>
            <link>https://zenn.dev/akasan/articles/6d97f52cccfeef</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/6d97f52cccfeef</guid>
            <pubDate>Sun, 26 Oct 2025 10:19:23 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第15回目の本日はsshmを紹介しようと思います。sshmを利用するとsshの設定に関してTUIインターフェースで操作できます。なお、第14回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/80f8931f8523cd sshmとは？公式GitHubによると、sshmは、SSHホストの管理と接続方法を変革する美しいコマンドラインツールです。Go言語で構築され、直感的なTUIインターフェースを備えているため、SSH接続管理が簡単かつ快適になります。とのことで、SSHホストをTUIで...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Astro で Standard ML のシンタクスハイライト]]></title>
            <link>https://silasol.la/posts/2025-10-26-02_astro-sml/</link>
            <guid isPermaLink="false">https://silasol.la/posts/2025-10-26-02_astro-sml/</guid>
            <pubDate>Sun, 26 Oct 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[デフォルトでハイライトされない言語を TextMate を用いた拡張で認識させます．]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rayシリーズ：Ray Dataへの入門 ~quickstart~]]></title>
            <link>https://zenn.dev/akasan/articles/3cdf0bd79a898a</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/3cdf0bd79a898a</guid>
            <pubDate>Sat, 25 Oct 2025 12:05:51 GMT</pubDate>
            <content:encoded><![CDATA[今回はRayでデータを取り扱うためのRay Dataについて、Quickstartを通して入門してみました。 Ray Dataとは？Ray Dataは、Ray上に構築されたMLとAIワークロードのためのスケーラブルなデータ処理ライブラリです。 バッチ推論やデータ前処理、MLトレーニングのためのインジェストなど、AIワークロードを表現するための柔軟で高性能なAPIを提供してくれます。他の分散データシステムとは異なり、Ray Dataはストリーミング実行を特徴としており、大規模なデータセットを効率的に処理し、CPUとGPUの両方のワークロードで高い利用率を維持します。Ray Data...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[30歳を迎えたMLエンジニアが今後の計画を考えてみた]]></title>
            <link>https://zenn.dev/akasan/articles/35d7eeebb7a84c</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/35d7eeebb7a84c</guid>
            <pubDate>Fri, 24 Oct 2025 13:09:25 GMT</pubDate>
            <content:encoded><![CDATA[本日筆者は30歳を迎えまして、人生のある意味節目なので今後のプランを考えてみました。 まずは20代を振り返る 何をやってきたか22際から新卒エンジニアとして働き始めて8年程度でしょうか、色々な業務をこなしてきました。ざっと上げただけでもこんな感じですかね。ソフトウェア開発OCRを利用した業務効率化ソフトウェアの改修データ分析ソフトウェアの設計・開発プログラミング効率化のためのソフトウェア開発異常検知モデルの結果や設定をするためのWebアプリケーションの実装ロボット制御開発経路計画立案システムの構築ロボットの制御ソフトウェア開発ロボット制御のための回路...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[anyenvやasdfに代わる？miseで始める開発環境管理]]></title>
            <link>https://sreake.com/blog/mise-development-env-management/</link>
            <guid isPermaLink="false">https://sreake.com/blog/mise-development-env-management/</guid>
            <pubDate>Fri, 24 Oct 2025 12:34:35 GMT</pubDate>
            <content:encoded><![CDATA[はじめに 開発環境の構築において「このプロジェクトは Node.js 16 系だけど、別の案件は 18 系じゃないと動かない」といった状況に遭遇することは少なくありません。 プロジェクトごとに異なる言語やツールのバージョ […]The post anyenvやasdfに代わる？miseで始める開発環境管理 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[NeMo Guardrailsを試してみた]]></title>
            <link>https://zenn.dev/akasan/articles/0b825a53e78e06</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/0b825a53e78e06</guid>
            <pubDate>Thu, 23 Oct 2025 14:18:27 GMT</pubDate>
            <content:encoded><![CDATA[今回はNVIDIAが提供するNeMo Guardrailsを利用してみました。NeMo Guardrailsを利用することでプログラムを用いてガードレール機能を導入することができます。 NeMo Guardrailsとは？こちらの解説によると、NeMo Guardrails はプログラム可能なガードレールを LLM ベースの対話システムに簡単に追加するための OSS です。NeMo Guardrails を使用する事で、簡単なコンフィグレーションの作成と Python によるコーディングのみで、信頼性のある、安全でセキュアな LLM 対話システムの構築を簡単に行う事ができます。...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Gemini CLI でセキュアで堅牢な開発をするためのプラクティス集]]></title>
            <link>https://zenn.dev/kimitsu/articles/secure-and-robust-development-with-gemini-cli</link>
            <guid isPermaLink="false">https://zenn.dev/kimitsu/articles/secure-and-robust-development-with-gemini-cli</guid>
            <pubDate>Thu, 23 Oct 2025 01:52:31 GMT</pubDate>
            <content:encoded><![CDATA[先日、クラウドネイティブ × Gemini CLIというイベントで『Gemini CLI でもセキュアで堅牢な開発をしたい！』というタイトルで登壇させていただきました。時間都合で端折ってしまった部分が多かったため、本記事で行間を埋めつつ最新の状況をお伝えします。登壇の内容は全て記載するため、イベントに参加されなかった方も読んでいただければと思います。 はじめに本記事は Gemini CLI を個人レベルではなく企業やチームとして使いたい方を対象とします。そのため、Gemini CLI の基本的な部分（例えばどのようにインストールするか、settings.jsonとは何か、基本...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[DecisionTree分類器の構造を可視化してみる]]></title>
            <link>https://zenn.dev/akasan/articles/dc29b37ec0d998</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/dc29b37ec0d998</guid>
            <pubDate>Wed, 22 Oct 2025 13:31:10 GMT</pubDate>
            <content:encoded><![CDATA[今回はscikit-learnのDecisionTree分類器の学習結果を可視化する方法をまとめてみます。 DecisionTree分類器とは？DecisionTree分類器は決定木を利用した分類器です。構造としては二分木で、各ノードで何かしらの条件により入力データが2つに分割されます。その分割を複数段階適用することでクラス分類をすると言うものになります。DecisionTree分類器については以下をご参照ください。https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifi...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[build.nvidia.comからgpt-oss-120bを使ってみた]]></title>
            <link>https://zenn.dev/akasan/articles/1bb37e8ad6de59</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/1bb37e8ad6de59</guid>
            <pubDate>Tue, 21 Oct 2025 13:38:50 GMT</pubDate>
            <content:encoded><![CDATA[今回はbuild.nvidia.comで利用できるgpt-oss-120bを利用してみました。 build.nvidia.comとは？build.nvidia.comはNVIDIAが提供しているNIMのAPIを試せる環境となっています。NIMとは公式ページにて以下のように説明されています。NVIDIA NIM™ は、クラウド、データセンター、ワークステーション、エッジなど、あらゆる NVIDIA アクセラレーテッド インフラストラクチャに最新の AI モデルを迅速にデプロイできるように、最適化された事前構築済みの推論マイクロサービスを提供します。要はマイクロサービスとして様...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[LogisticRegressionの重みを可視化してみる]]></title>
            <link>https://zenn.dev/akasan/articles/f3ec2f94a385b3</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/f3ec2f94a385b3</guid>
            <pubDate>Mon, 20 Oct 2025 14:11:09 GMT</pubDate>
            <content:encoded><![CDATA[今回はLogisticRegressionの回帰係数を可視化して各特徴量の分類に対する寄与度を可視化してみました。 検証内容今回はscikit-learn上で利用できるirisデータを使います。irisは多クラス（３クラス）データであり特徴量は4つあります。LogisticRegressionを学習させ、その回帰係数を可視化してみます。 早速実装する 環境構築まずは必要なライブラリをインストールします。uv init iris_logistic_regression -p 3.12cd iris_logistic_regressionuv add scikit-le...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Gemini CLIでもセキュアで堅牢な開発をしたい！]]></title>
            <link>https://speakerdeck.com/yunosukey/gemini-clidemosekiyuadejian-lao-nakai-fa-wositai</link>
            <guid isPermaLink="false">https://speakerdeck.com/yunosukey/gemini-clidemosekiyuadejian-lao-nakai-fa-wositai</guid>
            <pubDate>Sun, 19 Oct 2025 04:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[imbalanced-learnを利用してアンダー/オーバーサンプリングを実施してみた]]></title>
            <link>https://zenn.dev/akasan/articles/7a148787cb3be8</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/7a148787cb3be8</guid>
            <pubDate>Sun, 19 Oct 2025 03:34:17 GMT</pubDate>
            <content:encoded><![CDATA[今回はimbalanced-learnを利用してデータセットの偏りを調整する方法を試してみました。機械学習ではデータの分布がとても重要であり、偏ったデータ分布は好ましくない場合が多いです。そのような場合にデータの偏りを補正するためのライブラリとしてimbalanced-learnがあり、今回はそれを利用してみました。 データの偏りとは？文字通りですが、データに偏りがある状態をいいます。例えばある病気について、診察対象の人が病気に罹患しているかしていないかをまとめたデータセットがあったとします。仮にその病気に罹患している人が極めて少数の場合、このデータセットは大半が罹患していない人...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitHub Actions の Job から WireGuard で VPN アクセス]]></title>
            <link>https://qiita.com/yteraoka/items/eef62dc05aa96fbed3b6</link>
            <guid isPermaLink="false">https://qiita.com/yteraoka/items/eef62dc05aa96fbed3b6</guid>
            <pubDate>Sat, 18 Oct 2025 09:09:27 GMT</pubDate>
            <content:encoded><![CDATA[背景GitHub Actions の Job で家のネットワークにアクセスさせたいことがあり、いったんは Squid を認証付きで publilc に公開するというのをやっていたのですが、やっぱり嬉しくないのでどうしたものかと思っていたのですが WireGuard が使...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[cargo-chefがRustのDockerビルドを高速化する話]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/10/18/163911</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/10/18/163911</guid>
            <pubDate>Sat, 18 Oct 2025 07:39:11 GMT</pubDate>
            <content:encoded><![CDATA[はじめに前回の記事では、Rust の Docker イメージサイズを 98%削減する方法を解説しました。その中で最も重要な役割を果たしているのが cargo-chef です。この記事では、cargo-chef の仕組みと動作原理を深く掘り下げていきます。syu-m-5151.hatenablog.comcargo-chef は、Docker のレイヤーキャッシングと Cargo のビルドモデルの根本的な不整合を解決し、Rust プロジェクトのDockerビルドを5倍高速化します。Luca Palmieri が「Zero to Production In Rust」のために作成したこのツールは、ソースコード変更のたびに 20 分以上かかっていたリビルドを、依存関係をアプリケーションコードから分離してキャッシュし、2〜3 分のビルドに変えました。www.zero2prod.comcargo-chef は依存関係情報のみを捉えた「レシピ」を作成し、ソースコードが変更されても有効なままの別レイヤーで高コストな依存関係のコンパイルをキャッシュできます。約 500 の依存関係を持つ商用コードベースでは、ビルド時間が約 10 分から約 2 分に短縮され、CI/CD の速度とインシデント対応時間に直接影響を与えます。github.comRustのDockerビルドにおける根本的な問題Docker のレイヤーキャッシングは、各命令(RUN、COPY、ADD)に対してレイヤーを作成します。いずれかのレイヤーが変更されると、そのレイヤーとそれ以降のすべてのレイヤーが無効化されます。標準的な Rust Dockerfile は重大な問題に直面します: 依存関係のマニフェストとソースコードの両方を一緒にコピーする必要があるため、ソースの変更があるとビルドキャッシュ全体が無効になってしまうのです。問題のあるパターン:FROM rust:1.75WORKDIR /appCOPY . .              # マニフェストとソースを一緒にコピーRUN cargo build       # 変更のたびにすべてを再ビルドPython の pip install -r requirements.txt や Node の npm install とは異なり、Cargoには依存関係のみをビルドするネイティブな方法がありません。cargo build コマンドは、依存関係とソースのコンパイルを統一された操作として扱います。cargo build --only-deps のようなフラグは存在しません。このアーキテクチャ上の制限により、他の言語では美しく機能する標準的な Docker パターンが、Rust では壊滅的に失敗してしまいます。影響は開発ワークフロー全体に波及します。すべてのコード変更—たった 1 文字の修正でさえ—数百の依存関係の完全な再コンパイルを引き起こします。2〜4 コアの CI システムでは、ビルドが 30 分を超えることがあります。これにより、デプロイ速度、インシデント対応時間、開発者の反復サイクルに厳しい下限が生まれます。本番環境のインシデントで緊急パッチが必要な場合、その 20 分のビルドが 20 分のダウンタイムになります。Rustのビルドが特に問題になる理由Rust のコンパイルモデルは、コンパイル時間の速度よりも実行時パフォーマンスを優先します。リリースビルド(--release)は、中規模のプロジェクトで 15〜20 分かかる広範な LLVM 最適化パスを実行します。ジェネリクス、トレイト特殊化、単相化の多用により、依存関係は各使用パターンに対して相当量のコードをコンパイルします。非同期エコシステム(tokio、actix-web、tonic)はこれを悪化させます—これらのクレートは単純なアプリケーションでもコンパイルが重いのです。インクリメンタルコンパイルは存在しますが、リリースビルドではデフォルトで無効になっており、外部依存関係には役立ちません。Docker の本番ビルドは常に --release プロファイルを使用するため、遅いコンパイルパスを避けられません。依存関係のコンパイルは通常、総ビルド時間の 80〜90%を消費しますが、これらの依存関係はアプリケーションコードに比べてほとんど変更されません。この逆転した関係—最も遅い部分が最も変更されない—こそが、cargo-chef が活用するポイントです。アーキテクチャプロジェクト構造:src/main.rs - コマンドパースを含む CLI エントリポイントsrc/lib.rs - ライブラリエントリポイントsrc/recipe.rs - レシピ生成、依存関係ビルド、クッキングロジックsrc/skeleton.rs - プロジェクトスケルトンの作成とダミーファイル生成cargo-chef のアーキテクチャは 2 つの抽象化を中心としています: RecipeとSkeleton。Recipe はシリアライズ可能なコンテナで、Skeleton は実際のマニフェストデータとロックファイルを含みます。これらの構造により、コアワークフローが可能になります: 分析 → シリアライズ → 再構築 → ビルド。レシピコンセプトと動作原理「レシピ」は、ソースコードなしで依存関係をビルドするために必要な最小限の情報を捉えたJSONファイル(recipe.json)です。これは Python の requirements.txt と同じ目的を果たしますが、Rust のより複雑なプロジェクト構造に対応しています。レシピの内容:プロジェクト全体のすべての Cargo.toml ファイルとその相対パスCargo.lock ファイル(存在する場合)、正確な依存関係バージョンのためすべてのバイナリとライブラリの明示的な宣言—正規の場所(src/main.rs、src/lib.rs)にあるものでもスケルトン再構築のためのプロジェクト構造メタデータpub struct Recipe {    pub skeleton: Skeleton,}pub struct Skeleton {    manifests: Vec<Manifest>,    lock_file: Option<String>,}この構造は人間が読める JSON にシリアライズされ、レシピはデバッグ可能で検査可能です。明示的なターゲット宣言により、Cargo が通常ファイルの場所からターゲットを推測する場合でも、信頼性の高いキャッシュが保証されます。動作原理と内部メカニズムcargo-chef は、マルチステージビルドで連携する 2 つのコマンドを提供します:1. cargo chef prepare --recipe-path recipe.jsonこのコマンドは次のように現在のプロジェクトを分析します。ベースパスからディレクトリを再帰的にトラバース相対パスを保持してすべての Cargo.toml ファイルを収集依存関係バージョンロックのために Cargo.lock を読み取りSkeleton データ構造を作成マニフェスト内の明示的なターゲット宣言を確保recipe.json にシリアライズprepare コマンドは高速(通常 1 秒未満)です。ファイル構造を分析して TOML をパースするだけで、コンパイルは行わないためです。2. cargo chef cook --release --recipe-path recipe.jsonこのコマンドは次のように再構築とビルドを行います。recipe.json を Skeleton に逆シリアライズskeleton.build_minimum_project() を呼び出してディレクトリ構造を再作成すべての Cargo.toml ファイルを相対パスに書き込みCargo.lock をディスクに書き込みすべてのターゲット(main.rs、lib.rs、build.rs)に対してダミーソースファイルを作成指定されたフラグで cargo build を実行skeleton.remove_compiled_dummies() 経由でコンパイル済みダミーアーティファクトを削除ダミーファイルトリック: cargo-chef は次のように最小限の有効な Rust ファイルを作成します。// ダミーのmain.rsfn main() {}// ダミーのlib.rs// (空または最小限)これらは Cargo がコンパイル可能なプロジェクトを要求する条件を満たしますが、実際のロジックは含まれていません。その後、Cargo は通常通りすべての依存関係を解決してコンパイルし、キャッシュされたアーティファクトを生成します。ダミーアーティファクトは後でクリーンアップされ、外部依存関係のコンパイル結果のみが残ります。重要な技術的制約: cook とその後の build コマンドは、同じ作業ディレクトリから実行すべきです。これは、target/debug/deps 内の Cargo の *.d ファイルにターゲットディレクトリへの絶対パスが含まれているためです。ディレクトリを移動するとキャッシュの利用が壊れます。これは cargo-chef の制限ではなく、cargo-chef が尊重する Cargo の動作です。Docker統合とマルチステージビルドcargo-chef は、Docker のマルチステージビルド機能用に特別に設計されています。標準的なパターンは 3 つのステージを使用します:標準的な3ステージパターン:FROM lukemathwalker/cargo-chef:latest-rust-1 AS chefWORKDIR /app# ステージ1: Planner - レシピを生成FROM chef AS plannerCOPY . .RUN cargo chef prepare --recipe-path recipe.json# ステージ2: Builder - 依存関係をキャッシュFROM chef AS builderCOPY --from=planner /app/recipe.json recipe.jsonRUN cargo chef cook --release --recipe-path recipe.json# ↑ このレイヤーは依存関係が変更されるまでキャッシュされる# 次にソースをコピーしてアプリケーションをビルドCOPY . .RUN cargo build --release --bin app# ステージ3: Runtime - 最小限の本番イメージFROM debian:bookworm-slim AS runtimeWORKDIR /appCOPY --from=builder /app/target/release/app /usr/local/binENTRYPOINT ["/usr/local/bin/app"]キャッシングの仕組み:各 Docker ステージは独立したキャッシングを維持します。ステージは COPY --from 文を通じてのみやり取りします。この分離が cargo-chef の効果の鍵です。planner ステージの COPY . . は planner キャッシュを無効化(ただしこれは高速)Planner はフルソースツリーから recipe.json を生成Builder ステージは COPY --from=planner 経由で recipe.json のみを受け取るrecipe.jsonのチェックサムが変更されていない限り、builderの依存関係レイヤーはキャッシュされたままCargo.toml または Cargo.lock が変更された場合にのみ recipe.json が変更されるソースコードの変更は recipe.json に影響しないため、依存関係レイヤーはキャッシュされたままキャッシュ無効化ロジック:ソースコード変更 → plannerステージ無効化                → recipe.json変更なし                → builderの依存関係レイヤーキャッシュ済み ✓                → アプリケーションビルドのみ実行依存関係変更    → plannerステージ無効化                → recipe.json変更                → builderの依存関係レイヤー無効化 ✗                → フルリビルド必要これはインセンティブを完璧に整合させます: 高コストな操作(依存関係コンパイル)は、そうあるべき時(依存関係が変更されていない時)にキャッシュされ、高速な操作(ソースコンパイル)は期待通り毎回の変更で実行されます。ビルドプロセスの統合とサポート機能cargo-chef は標準的な Cargo ワークフローとシームレスに統合し、ビルドカスタマイズの全範囲をサポートします:ビルドコマンド:build(デフォルト)check(--check フラグ経由)clippyzigbuildサポートされるオプション:プロファイル選択: --release、--debug、カスタム --profile機能: --features、--no-default-features、--all-featuresターゲット: --target、--target-dir(ファーストクラスのクロスコンパイルサポート)ターゲットタイプ: --benches、--tests、--examples、--all-targets、--bins、--binワークスペース: --workspace、--package、--manifest-pathCargo フラグ: --offline、--frozen、--locked、--verbose、--timingsツールチェーンオーバーライド: cargo +nightly chef cookワークスペースサポートは自動です。cargo-chef はワークスペース内のすべてのクレートを検出し、正しく処理します。ファイルやクレートが移動しても、cargo-chef は自動的に適応します—Dockerfile の変更は不要です。これは、プロジェクト構造をハードコードする手動アプローチに対する大きな利点です。ビルド済みDockerイメージは Docker Hub の lukemathwalker/cargo-chef で利用可能で、柔軟なタグ付けができます。latest-rust-1.75.0(特定の Rust バージョンの最新 cargo-chef)0.1.72-rust-latest(最新の Rust の特定 cargo-chef)Alpine バリアント: latest-rust-1.70.0-alpine3.18バージョンの一貫性: すべてのステージで同一のRustバージョンを使用すべきです。バージョンの不一致は、異なるコンパイラバージョンが異なるアーティファクトを生成するため、キャッシングを無効化します。主要機能と実用的なユースケース主なユースケース:1. CI/CDパイプラインの最適化 - 標準的なユースケースです。すべてのコード変更が CI で Docker ビルドをトリガーします。cargo-chef なしでは、各ビルドが 500 以上のすべての依存関係を再コンパイルします(10〜20 分)。cargo-chef があれば、変更されていない依存関係はキャッシュされ、ビルドは 2〜3 分に短縮されます。これは次のような点に直接影響します。デプロイ速度(機能をより速くリリース)インシデント対応(本番環境をより速くパッチ)開発者体験(PR へのより速いフィードバック)インフラコスト(消費される CPU 分の削減)2. マルチステージビルド - ビルド環境とランタイム環境を分離。ビルダーステージは完全な Rust ツールチェーン(800MB 以上)を含み、ランタイムステージは最小イメージ(25〜50MB)を使用します。cargo-chef は、高コストなビルダーステージをキャッシュ状態に保つことで、このパターンを実用的にします。3. ワークスペース/モノレポプロジェクト - 依存関係を共有する複数のバイナリとライブラリを自動的に処理します。手動アプローチはワークスペースで破綻します; cargo-chef は透過的に処理します。4. クロスコンパイル - --target フラグ経由でファーストクラスサポート。例: Alpine Linux デプロイのために x86_64-unknown-linux-musl バイナリを CI でビルド。ターゲット指定は依存関係キャッシング中に尊重されます。高度な最適化戦略:sccacheとの組み合わせ:FROM rust:1.75 AS baseRUN cargo install --locked cargo-chef sccacheENV RUSTC_WRAPPER=sccache SCCACHE_DIR=/sccache# ... plannerステージ ...FROM base AS builderRUN --mount=type=cache,target=$SCCACHE_DIR,sharing=locked \    cargo chef cook --release --recipe-path recipe.jsonこの組み合わせは2層のキャッシングを提供します。cargo-chef: 粗粒度(依存関係レイヤー全体)sccache: 細粒度(個々のコンパイルアーティファクト)1 つの依存関係が変更された場合、cargo-chef はすべてを再ビルドしますが、sccache は個々のクレートコンパイルをキャッシュします。変更された依存関係のみが実際に再コンパイルされます。BuildKitキャッシュマウント:RUN --mount=type=cache,target=/usr/local/cargo/registry \    --mount=type=cache,target=/usr/local/cargo/git \    cargo chef cook --release --recipe-path recipe.jsonこれは cargo レジストリ自体をキャッシュし、再ダウンロードを回避します。sccache および cargo-chef と組み合わせることで、Rust Docker ビルドの現在のベストプラクティスとなります。重要な制限と考慮事項作業ディレクトリの制約 - cargo cook と cargo build は、Cargo の *.d ファイル内の絶対パスのため、同じディレクトリから実行すべきです。これは Docker では煩わしくありませんが、認識すべきです。ローカルパス依存関係 - プロジェクト外の依存関係(path = "../other-crate" で指定)は、変更されていなくてもゼロから再ビルドされます。これは、タイムスタンプベースのフィンガープリントに関連する Cargo の制限(issue #2644)です。コピーするとタイムスタンプが変更され、フィンガープリントが無効になります。ローカル開発には不向き - cargo-chef はコンテナビルド専用に設計されています。既存のコードベースでローカルに実行すると、ファイルが上書きされる可能性があります。このツールは、ターミナル環境で実行される場合の安全警告を含みます。ワークスペースの動作 - cargo chef cook はデフォルトですべてのワークスペースメンバーをビルドします。1 つのサービスのみが必要な大規模ワークスペースの場合、これによりビルド時間が増加する可能性があります。回避策には、ターゲットビルドフラグまたはサービスごとの個別の Dockerfile が含まれます。最適なユースケース - cargo-chef は以下に最大の利益を提供します。中規模から大規模プロジェクト(500 以上の依存関係)安定した依存関係ツリー(まれに変更)頻繁なデプロイ(CI/CD 環境)共有ビルドインフラを持つチーム環境非常に小規模なプロジェクト(少数の依存関係)の場合、オーバーヘッドが利益を上回る可能性があります。設計パターンとアーキテクチャの決定注目すべき技術的決定:JSONレシピ形式 - バイナリ形式ではなく JSON を使用し、レシピは人間が読めてデバッグ可能です。recipe.json を検査して、cargo-chef が何を抽出したかを正確に確認できます。明示的なターゲット宣言 - 正規の場所にある場合でも、すべてのターゲットを明示的に宣言するように Cargo.toml を変更します。これにより、キャッシュ無効化全体で Cargo がそれらを確実に認識します。マニフェスト操作 - 手動パースではなく、ワークスペース構造へのプログラマティックアクセスに cargo_metadata クレートを使用します。これにより Cargo の進化に伴う堅牢性が提供されます。TOML順序保持 - preserve_order 機能を持つ TOML を使用して、シリアライゼーションを通じたラウンドトリップ時にマニフェスト構造の整合性を維持します。安全機能 - atty クレートを使用したターミナル検出。対話的に実行された場合の警告メッセージ。ローカル環境での偶発的なファイル上書きを防ぐために、明示的なユーザー確認が必要です。採用された設計パターン:ビルダーパターン(Recipe/Skeleton 構築)コマンドパターン(CommandArg enum)ファサードパターン(複雑さを隠すシンプルな 2 コマンドインターフェース)テンプレートメソッドパターン(build_dependencies オーケストレーション)おわりにcargo-chef は、Cargo 自体が提供しない依存関係とソースコンパイルの分離を作成することで、Rust 特有の Docker レイヤーキャッシング問題を解決します。このツールの優雅さはシンプルさにあります: 依存関係管理を再発明するのではなく、Cargo が最も得意とすることを可能にする最小限の有効なプロジェクト構造を作成し、Docker のレイヤーキャッシングメカニズムと完璧に整合します。必須のベストプラクティス:すべての Docker ステージで同一の Rust バージョンを使用cook と build 間で一貫した作業ディレクトリを維持レジストリキャッシング用の BuildKit キャッシュマウントと組み合わせる細粒度のコンパイルキャッシング用に sccache を追加最小限のランタイムイメージを持つマルチステージビルドを使用.dockerignore でビルドコンテキストを最小化cargo-chefを使用すべき場合:中規模から大規模の Rust プロジェクトCI/CD Docker ビルド安定した依存関係ツリーを持つプロジェクト高速な反復サイクルを必要とするチーム迅速なインシデント対応を必要とする本番デプロイ。cargo-chef は、Docker 経由で Rust アプリケーションをデプロイするチームにとって不可欠なツールに成熟しており、より良い開発者体験、より速いデプロイ、削減されたインフラコストに直接変換される測定可能なパフォーマンス改善を提供します。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[glomを使ってdictのネストを取り扱ってみた]]></title>
            <link>https://zenn.dev/akasan/articles/1d839a9083627c</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/1d839a9083627c</guid>
            <pubDate>Sat, 18 Oct 2025 06:23:24 GMT</pubDate>
            <content:encoded><![CDATA[今回はPythonのライブラリであるglomを使ってみました。glomを利用するとネストされたdictを扱う際にいくつもキーにアクセスするためにカッコを使わなくても簡単にアクセスできるようになります。ちなみに、なぜこのライブラリを知ったかというと以下の記事が気になって読んでいると出てきたので調べてみた次第です。ぜひ以下の記事もご覧ください。https://medium.com/@abdur.rahman12/the-python-toolbelt-12-tiny-libraries-that-solve-big-problems-9a6be9309e43 glomとは？glom...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AIエージェント入門 〜基礎からMCP・A2Aまで〜]]></title>
            <link>https://speakerdeck.com/shukob/aiezientoru-men-ji-chu-karamcpa2amade</link>
            <guid isPermaLink="false">https://speakerdeck.com/shukob/aiezientoru-men-ji-chu-karamcpa2amade</guid>
            <pubDate>Sat, 18 Oct 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[https://genai-users.connpass.com/event/373059/2025年10月18日、オープンソースカンファレンス2025 Online/Fallで発表した資料です。今話題となっている「AIエージェント」について、要素技術となる生成AIを用いてどのように自律的に動作するのか基礎を説明した後、AIが外部のツールやデータにアクセスするためのオープンプロトコルであるMCP（Model Context Protocol）や、複数のエージェントによる分業と連携を可能にするオープンプロトコルA2A（Agent-to-Agent）について解説しました。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[英語4文字のセキュリティ用語あれこれ説明できる？ - SBOM/SAST/DAST...]]></title>
            <link>https://zenn.dev/r4ynode/articles/security-english-words</link>
            <guid isPermaLink="false">https://zenn.dev/r4ynode/articles/security-english-words</guid>
            <pubDate>Sat, 18 Oct 2025 03:00:01 GMT</pubDate>
            <content:encoded><![CDATA[セキュリティの話になると、謎の4文字くらいの英語が羅列しているのを見たことありません？それらのセキュリティ用語を説明できますか？私はできません多すぎて分からなくなるので少し整理します。!内容は概要程度です。機能面についても利用するソフトウェアやベンダーに依存するため参考程度に。 早見表用語一言解説SBOMソフトウェア部品表。構成要素を一覧化する。SCAOSSやライブラリの脆弱性・ライセンス管理。ASTアプリの脆弱性を検出するセキュリティテスト。SASTソースコードを静的解析して脆弱性検出。DAST実行中アプリに攻撃して...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[二つのCubeの重なり部分を削除したUSD primの生成方法]]></title>
            <link>https://zenn.dev/akasan/articles/0b0a014a5eb790</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/0b0a014a5eb790</guid>
            <pubDate>Fri, 17 Oct 2025 13:58:23 GMT</pubDate>
            <content:encoded><![CDATA[今回はふと気になったので、OpenUSDで二つのCubeを生成してその重なっているところを削除したような図形を作る方法を調べてみました。※ ChatGPTに作り方を聞きました。いつもお世話になっております。 今回やってみたかったこともう少し厳密に今回やってみたかったことを文字起こしすると以下のようになります。二つのCubeをA、BとするAとBには重なる部分があるとするAからAとBが重なっている場所を削除する 早速ChatGPTに聞いてみた質問内容としては以下のように問い合わせました。pxr.UsdGeom.Cubeで作成したキューブAとBがあるとします。例えば...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[RustのDockerfile、2025年はこれでいこう]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/10/17/070250</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/10/17/070250</guid>
            <pubDate>Thu, 16 Oct 2025 22:02:50 GMT</pubDate>
            <content:encoded><![CDATA[はじめに「Dockerでビルドすると遅いんだよね」「イメージが2GB超えちゃって…」そんな会話はもう過去の話です。2025年、コンテナ化は劇的に進化しました。Rustも例外ではありません。cargo-chefとBuildKitキャッシュマウントの組み合わせでビルド時間を5-10倍短縮、2.63GBのイメージをdistrolessイメージで約50MB、musl静的リンクならわずか1.7MBという値を達成できます。この記事では、実践的なDockerfileパターンとベンチマーク結果を詳しく解説します。実際に検証したAxum Webアプリケーションでは、distroless版で50.3MB、musl+scratch版で1.71MBを達成しました。中規模プロジェクト（約500の依存関係）での初回ビルドは10分、コード変更後の再ビルドはわずか40秒です。信じられないかもですが、これが2025年の現実です。ちゃんとやれって話です。あと皆さんのDockerfileも教えて欲しいです。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。2025年の重要なアップデートRust 2024 Edition（2025年2月20日リリース）Rust 1.85.0でRust 2024 Editionが安定版になりました。Docker環境でRust 1.85以降を使えば、Edition 2024の機能が使えます。doc.rust-lang.orgblog.rust-lang.orgDocker関連の進化Docker Engine v28：コンテナネットワーキングのセキュリティ強化、AMD GPUサポートdocs.docker.comdocker init GA：Rustプロジェクト用の最適化されたDockerfile自動生成docs.docker.comDocker Bake GA：複雑なビルド設定の宣言的管理docs.docker.comBuildKit 0.25.1：Git URLクエリパラメータ、シークレットの環境変数化など新機能github.com基本的な考え方マルチステージビルドは前提条件2025年でマルチステージビルドを使わないのは、正直あり得ません。まずメンテナンス性が格段に向上します。最終的な成果物以外ではサイズを意識したトリッキーな記述が不要になるため、Dockerfileの可読性が劇的に良くなります。次にビルド速度のアップ。並列化、キャッシュマウント、tmpfsなど最適化オプションが豊富に使えるようになり、ビルドパイプライン全体が高速化します。そして何よりセキュリティの向上。シークレット管理の仕組みが標準化され、機密情報の取り扱いが安全になりました。docs.docker.comCOPYは最小限に、--mountを活用COPYが登場するのは、実質的に2つの場面だけです。マルチステージビルドで別ステージから成果物を持ってくる場合と、最終ステージでアプリケーションバイナリをコピーする場合。それ以外、特にソースコードのビルド時には--mount=type=bindを使用します。docs.docker.com必ず記述すべきおまじない# syntax=docker/dockerfile:1この1行を必ず先頭に記述します。最新のDockerfile構文が自動的に利用され、新機能が使えるようになります。docs.docker.com2025年のDockerfileはこれでやります前置きはこれくらいにして、実際のコードを見ていきましょう。これが2025年のRust標準Dockerfileです。cargo-chefによる依存関係の分離、BuildKitキャッシュマウント、distrolessイメージ、非rootユーザー実行。この記事で解説してきたベストプラクティスのすべてが、この1つのテンプレートに詰め込まれています。# syntax=docker/dockerfile:1ARG RUST_VERSION=1.85ARG APP_NAME=myapp# cargo-chefを使った依存関係キャッシングFROM lukemathwalker/cargo-chef:latest-rust-${RUST_VERSION} AS chefWORKDIR /appFROM chef AS plannerCOPY . .RUN cargo chef prepare --recipe-path recipe.jsonFROM chef AS builder# 依存関係のビルド（キャッシュ可能）COPY --from=planner /app/recipe.json recipe.jsonRUN --mount=type=cache,target=/usr/local/cargo/registry,sharing=locked \    --mount=type=cache,target=/usr/local/cargo/git,sharing=locked \    cargo chef cook --release --recipe-path recipe.json# アプリケーションのビルドCOPY . .RUN --mount=type=cache,target=/usr/local/cargo/registry,sharing=locked \    --mount=type=cache,target=/usr/local/cargo/git,sharing=locked \    --mount=type=cache,target=/app/target,sharing=locked \    cargo build --release --bin ${APP_NAME} && \    cp ./target/release/${APP_NAME} /bin/server# テストステージ（オプション）FROM chef AS testCOPY . .RUN --mount=type=cache,target=/usr/local/cargo/registry \    --mount=type=cache,target=/usr/local/cargo/git \    cargo test# 本番ステージ：distrolessFROM gcr.io/distroless/cc-debian12:nonroot AS runtimeCOPY --from=builder /bin/server /app/WORKDIR /appEXPOSE 8000ENTRYPOINT ["/app/server"]このDockerfileの主な特徴cargo-chefによる依存関係の分離とキャッシングBuildKitキャッシュマウントでレイヤーを跨いだキャッシュdistrolessによる最小サイズと高セキュリティ非rootユーザー（:nonrootタグ）での実行オプショナルなテストステージビルド最適化の3つの柱1. cargo-chefcargo-chefは、Rustの依存関係管理をDockerレイヤーキャッシュに適合させる画期的なツールです。依存関係のコンパイルとソースコードのコンパイルを完全に分離します。動作メカニズム（2段階）：cargo chef prepare：Cargo.tomlとCargo.lockを解析してrecipe.jsonを作成cargo chef cook：最小限のプロジェクト構造を再構築して依存関係のみをビルド重要：同じRustバージョンと作業ディレクトリを全ステージで使用すること。異なるバージョンを使うとキャッシュが無効化されます。実測データ：cargo-chefのみで55%の改善cargo-chef + sccacheで79%の改善（34秒→7秒）商用プロジェクト（14,000行、500依存関係）で10分→2分github.com2. BuildKitキャッシュマウントBuildKitのキャッシュマウント（Docker 18.09以降）を使うと、レイヤー無効化を超えて永続化するキャッシュボリュームが利用できます。3つの重要なキャッシュポイント：RUN --mount=type=cache,target=/usr/local/cargo/registry,sharing=locked \    --mount=type=cache,target=/usr/local/cargo/git,sharing=locked \    --mount=type=cache,target=/app/target,sharing=locked \    cargo build --release/usr/local/cargo/registry：crates.ioからのダウンロード/usr/local/cargo/git：Git依存関係/app/target：ビルド成果物sharing=lockedパラメータは排他アクセスを保証し、パッケージマネージャーの破損を防ぎます。CI環境でのキャッシュ共有：# GitHub Actions- uses: docker/build-push-action@v6  with:    cache-from: type=gha    cache-to: type=gha,mode=maxパフォーマンスベンチマーク：ベースライン：90.60秒BuildKitキャッシュマウント：15.63秒（5.8倍高速）cargo-chef：18.81秒（4.8倍高速）三位一体（chef + BuildKit + sccache）：7-12秒（7.5-13倍高速）docs.docker.com3. sccachesccache（v0.7.x）はMozilla製のccache風コンパイララッパーで、個々のコンパイル成果物を細粒度でキャッシュします。github.comFROM rust:1.85 AS builder# sccacheのインストールと設定RUN cargo install sccache --version ^0.7ENV RUSTC_WRAPPER=sccache \    SCCACHE_DIR=/sccache \    CARGO_INCREMENTAL=0WORKDIR /appRUN --mount=type=cache,target=/usr/local/cargo/registry \    --mount=type=cache,target=$SCCACHE_DIR,sharing=locked \    --mount=type=bind,target=. \    cargo build --release重要：CARGO_INCREMENTAL=0は必須。インクリメンタルコンパイルとsccacheは競合します。キャッシュヒット率：初回ビルド：0%ソースコード変更のみ：85-95%依存関係を更新した時：60-75%注意点：sccacheの効果は環境によって大きく異なります。一部の環境では効果が薄く、逆にオーバーヘッドとなる場合があります。自環境でのベンチマークが必須です。イメージサイズの最適化：ベースイメージ選択戦略ビルドステージ：rust:slim推奨2025年はrust:slim（Debian系）でよいと思っています。console.cloud.google.comFROM rust:1.85-slim-bookworm AS builder理由はシンプルです。Debian stable（bookworm）ベースでglibcを使用しているため、広範な互換性とマルチスレッドワークロードでの優れたパフォーマンスを発揮します。完全版のrust:latestが624MBもあるのに対し、rust:slimはコンパイルに必要な最小限のパッケージだけを含んでいます。無駄がありません。rust:alpineは避けてください。 muslの互換性問題に加えて、マルチスレッドアプリケーションで最大30倍のパフォーマンス劣化が報告されています。イメージサイズの小ささに惹かれる気持ちはわかりますが、本番環境でこの劣化は致命的です。https://hub.docker.com/_/rust最終ステージ：distroless推奨gcr.io/distroless/cc-debian12が2025年の標準です。FROM gcr.io/distroless/cc-debian12:nonrootdistrolessの特徴：サイズ：21-29MBglibc、SSL証明書、タイムゾーンデータ、/etc/passwdを含むパッケージマネージャー、シェル不要なバイナリを完全排除SLSA 2準拠、cosign署名検証が可能CVEスキャンで従来イメージより50-80%少ない脆弱性:nonrootタグでUID 65534（nobody）として非rootで実行github.comイメージサイズ比較（実測値） イメージ構成  サイズ  用途  特徴  scratch + musl（実測）  1.71MB  CLIツール最小化  完全静的リンク  distroless/static  2-3MB  静的リンクバイナリ  最小限のファイル  distroless/cc-debian12（実測）  50.3MB  Webアプリ推奨  glibc  debian-slim  80-120MB  フル互換性  デバッグツールあり  rust:latest（未最適化）  2.63GB  開発専用  ビルドツール込み 実測削減率：rust:latest（2.63GB）→ distroless（50.3MB）：98.1%削減rust:latest（2.63GB）→ musl+scratch（1.71MB）：99.9%削減静的リンク vs 動的リンクmusl（x86_64-unknown-linux-musl）での静的リンク：FROM rust:1.85-alpine AS builderRUN apk add --no-cache musl-devWORKDIR /app# 依存関係のキャッシュCOPY Cargo.toml Cargo.lock ./RUN --mount=type=cache,target=/usr/local/cargo/registry \    mkdir src && echo "fn main() {}" > src/main.rs && \    cargo build --release --target x86_64-unknown-linux-musl && \    rm -rf src# アプリケーションのビルドCOPY src ./srcRUN --mount=type=cache,target=/usr/local/cargo/registry \    cargo build --release --target x86_64-unknown-linux-muslFROM scratchCOPY --from=builder /app/target/x86_64-unknown-linux-musl/release/myapp /myappENTRYPOINT ["/myapp"]利点：依存関係ゼロで完全にポータブルscratchコンテナで実行可能イメージサイズ5-10MB欠点：シングルスレッドで0.9-1.0倍、マルチスレッドで0.03-0.5倍のパフォーマンス一部依存関係でsegfaultのリスク本番環境の推奨：複雑なアプリケーション（Webサーバー、DB接続）：glibc + distroless/cc-debian12シンプルなCLIツール：musl + scratchを検討パフォーマンスが重要：必ずglibcを使用マルチアーキテクチャビルドlinux/amd64とlinux/arm64の両対応が2025年の標準要件です。cargo-zigbuild：セットアップゼロのクロスコンパイルcargo-zigbuild（v0.20.1）はZigツールチェインを使い、セットアップ不要でクロスコンパイルできます。github.com# syntax=docker/dockerfile:1ARG RUST_VERSION=1.85FROM --platform=$BUILDPLATFORM rust:${RUST_VERSION}-alpine AS builderWORKDIR /app# Zigとcargo-zigbuildのインストールRUN apk add --no-cache musl-dev openssl-dev zigRUN cargo install --locked cargo-zigbuild# ターゲットの設定ARG TARGETPLATFORMRUN case ${TARGETPLATFORM} in \    "linux/amd64") echo x86_64-unknown-linux-musl > /rust_target ;; \    "linux/arm64") echo aarch64-unknown-linux-musl > /rust_target ;; \    esac && \    rustup target add $(cat /rust_target)# 依存関係とビルドCOPY Cargo.toml Cargo.lock ./RUN --mount=type=cache,target=/usr/local/cargo/registry \    mkdir src && echo "fn main() {}" > src/main.rs && \    cargo zigbuild --release --target $(cat /rust_target) && \    rm -rf srcCOPY src ./srcRUN --mount=type=cache,target=/usr/local/cargo/registry \    cargo zigbuild --release --target $(cat /rust_target)FROM alpine:latestARG TARGETPLATFORMCOPY --from=builder /app/target/*/release/app /appCMD ["/app"]重要：--platform=$BUILDPLATFORMを使うと、ビルド自体はネイティブアーキテクチャで実行できるので、QEMUエミュレーションより圧倒的に速いです（QEMUエミュレーションは16-25倍遅い）。実測データ：ネイティブビルド：2-3分QEMUエミュレーション：50分（16-25倍遅い）cargo-zigbuildクロスコンパイル：13分Docker buildxでのマルチプラットフォームビルド# ビルダーの作成docker buildx create --name container-builder \    --driver docker-container --bootstrap --use# マルチプラットフォームビルドdocker buildx build \    --platform linux/amd64,linux/arm64 \    -t myimage:latest \    --push .https://docs.docker.com/build/buildx/docs.docker.comセキュリティベストプラクティス1. 非rootユーザーで実行distroless :nonrootタグが最も簡単：FROM gcr.io/distroless/cc-debian12:nonrootCOPY --from=builder /app/target/release/myapp /usr/local/bin/CMD ["/usr/local/bin/myapp"]自動的にUID 65534（nobody）として実行されます。カスタムユーザー作成：FROM debian:bookworm-slimARG UID=10001RUN adduser \    --disabled-password \    --gecos "" \    --home "/nonexistent" \    --shell "/sbin/nologin" \    --no-create-home \    --uid "${UID}" \    appuserUSER appuserCOPY --from=builder /app/target/release/myapp /app/CMD ["/app/myapp"]2. 脆弱性スキャンTrivy（推奨）：# イメージスキャンdocker run --rm -v /var/run/docker.sock:/var/run/docker.sock \    aquasec/trivy image myapp:latest# CI/CD統合- name: Run Trivy scan  uses: aquasecurity/trivy-action@master  with:    image-ref: 'myapp:${{ github.sha }}'    severity: 'CRITICAL,HIGH'    exit-code: '1'github.comdistrolessのセキュリティ優位性：Alpine（musl）からChiseled Ubuntu（glibc）への移行で30+ CVEが0 CVEにdistrolessイメージはAlpineより50-80%少ないCVEパッケージマネージャー不在により攻撃ベクトル削減SLSA 2準拠、cosign署名認証3. シークレット管理絶対に避けるべき：環境変数へのシークレット設定イメージに焼き込まれてしまいます。正しい方法：# ビルド時シークレットRUN --mount=type=secret,id=api_token,env=API_TOKEN \    cargo build --release# 実行時docker build --secret id=api_token,env=API_TOKEN .4. イメージバージョンのピン留め# ❌ 避けるべきFROM rust:latest# ✅ 推奨FROM rust:1.85-slim-bookwormユースケース別DockerfileWebアプリケーション（Axum / Actix-web）上記の「標準Dockerfile」パターンをそのまま使用できます。CLIツール（完全静的リンク）# syntax=docker/dockerfile:1FROM rust:1.85-alpine AS builderWORKDIR /appRUN apk add --no-cache musl-dev openssl-dev openssl-libs-static# 依存関係のキャッシュCOPY Cargo.toml Cargo.lock ./RUN --mount=type=cache,target=/usr/local/cargo/registry \    mkdir src && echo "fn main() {}" > src/main.rs && \    cargo build --release --target x86_64-unknown-linux-musl && \    rm -rf srcCOPY src ./srcRUN --mount=type=cache,target=/usr/local/cargo/registry \    cargo build --release --target x86_64-unknown-linux-muslFROM scratchCOPY --from=builder /app/target/x86_64-unknown-linux-musl/release/cli-tool /app/ENTRYPOINT ["/app/cli-tool"]シェルエイリアスは以下のように設定できます。alias my-cli='docker run --rm -v $(pwd):/data my-cli-image'ワークスペース（モノレポ）対応# syntax=docker/dockerfile:1ARG SERVICE_NAME=api-gatewayARG RUST_VERSION=1.85FROM lukemathwalker/cargo-chef:latest-rust-${RUST_VERSION} AS chefWORKDIR /appFROM chef AS plannerCOPY . .RUN cargo chef prepare --recipe-path recipe.jsonFROM chef AS builderARG SERVICE_NAMECOPY --from=planner /app/recipe.json recipe.jsonRUN --mount=type=cache,target=/usr/local/cargo/registry,sharing=locked \    --mount=type=cache,target=/usr/local/cargo/git,sharing=locked \    cargo chef cook --release --bin ${SERVICE_NAME} --recipe-path recipe.jsonCOPY . .RUN --mount=type=cache,target=/usr/local/cargo/registry,sharing=locked \    --mount=type=cache,target=/app/target,sharing=locked \    cargo build --release --bin ${SERVICE_NAME} && \    cp ./target/release/${SERVICE_NAME} /bin/serviceFROM gcr.io/distroless/cc-debian12:nonrootCOPY --from=builder /bin/service /app/ENTRYPOINT ["/app/service"]異なるサービスを同じDockerfileから生成できます。docker build --build-arg SERVICE_NAME=api-gateway -t gateway .docker build --build-arg SERVICE_NAME=user-service -t users .実践的な検証結果実際のAxum Webアプリケーション（依存関係82個）で3つの戦略を検証しました。検証環境：CPU: Apple M-series (ARM64)Docker: Colima on macOSRust: 1.85 (Edition 2024)3つのパターン比較パターン1: Naive（最適化なし）- デフォルトの実態Dockerfile.naive は何も工夫しないシンプルなビルドです。これが「デフォルトの何もしていない状態」です。⚠️ デフォルト状態のビルド結果初回ビルド時間: 約10-15分（依存関係82個を全てコンパイル）ソースコード変更後の再ビルド: 約10-15分（依存関係も毎回再コンパイル）最終イメージサイズ: 2.63GBセキュリティ: rootユーザー、開発ツール込み（脆弱性大）問題点：ソースコード1行変更するだけで10-15分のビルドが毎回走るイメージに不要なRustコンパイラ（500MB）、ビルドツール、ドキュメントが全て含まれるマルチステージビルドがないため、最終イメージが巨大cargo-chefがないため、依存関係とソースコードが分離されていないパターン2: Baseline（cargo-chef + distroless）Dockerfile は2025年の推奨パターンです。ビルド結果ビルド時間: 38秒（依存関係キャッシュ済み）最終イメージサイズ: 50.3MBセキュリティ: 非rootユーザー（UID 65534）、最小限のファイルTrivy脆弱性: 0 HIGH/CRITICALパターン3: Ultra-minimal（musl + scratch）Dockerfile.musl は最小サイズを優先したパターンです。ビルド結果ビルド時間: 46秒（依存関係キャッシュ済み）最終イメージサイズ: 1.71MBセキュリティ: rootユーザー（scratchに制限あり）比較結果まとめ 項目  Naive (未最適化)  Baseline (distroless)  Ultra-minimal (musl)  イメージサイズ  2.63GB  50.3MB  1.71MB  削減率  - (100%)  98.1%削減  99.9%削減  ビルド時間  30秒  38秒  46秒  マルチステージ  ❌ なし  ✅ あり (4段階)  ✅ あり (2段階)  キャッシュ最適化  ❌ なし  ✅ cargo-chef + BuildKit  ✅ BuildKit  ベースイメージ  rust:1.85 (full)  distroless/cc-debian12  scratch  リンク方式  動的（glibc）  動的（glibc）  静的（musl）  開発ツール  ❌ 含まれる  ✅ 除去済み  ✅ 除去済み  セキュリティ  ❌ 低  ✅ 高  ⚠️ 中  デバッグ  ✅ 可能  ❌ 困難  ❌ 不可能 パフォーマンスベンチマーク商用プロジェクト（14,000行、500依存関係）：最適化なし：10分cargo-chef使用：2分（5倍高速化）大規模ワークスペース（400 crate、1500依存関係）：未最適化：約65分最適化後：約2分（30倍以上の改善）検証の再現方法このリポジトリで実際に試せます。# Baseline版のビルドdocker build -t rust-demo:baseline .# Ultra-minimal版のビルドdocker build -f Dockerfile.musl -t rust-demo:musl .# サイズ比較docker images | grep rust-demo# 動作確認docker run -p 8000:8000 rust-demo:baselinedocker run -p 8001:8000 rust-demo:muslよくある問題と解決策OpenSSLリンクエラーエラー： "Could not find directory of OpenSSL installation"解決策1：vendored OpenSSL（最も簡単）[dependencies]openssl = { version = "0.10", features = ["vendored"] }解決策2：Alpine適切パッケージFROM rust:1.85-alpineRUN apk add --no-cache openssl-dev openssl-libs-static musl-dev解決策3：Debianベース使用FROM rust:1.85-slim-bookwormRUN apt-get update && apt-get install -y pkg-config libssl-dev解決策4：rustls（Rust-native TLS）[dependencies]reqwest = { version = "0.11", features = ["rustls-tls"], default-features = false }muslリンクエラーAlpine向け：FROM rust:1.85-alpineRUN apk add musl-dev openssl-dev openssl-libs-staticRUN rustup target add x86_64-unknown-linux-muslENV PKG_CONFIG_ALLOW_CROSS=1RUN cargo build --release --target x86_64-unknown-linux-musl必要な環境変数：RUSTFLAGS='-C target-feature=+crt-static'PKG_CONFIG_ALLOW_CROSS=1OPENSSL_STATIC=1（システムOpenSSL使用時）DNS解決エラー（scratchイメージ）解決策1：distroless/static使用FROM gcr.io/distroless/static-debian12解決策2：Pure Rust DNSリゾルバー[dependencies]reqwest = { version = "0.11", features = ["trust-dns"] }解決策3：必要ファイルコピーFROM alpine:latest AS ca-certificatesRUN apk add -U --no-cache ca-certificatesFROM scratchCOPY --from=ca-certificates /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/.dockerignoreの重要性.dockerignoreがないと、target/ディレクトリ（数GB）がビルドコンテキストに含まれ、ビルドが遅くなります。# .dockerignoretarget/.git/.env*.log効果: ビルドコンテキストのサイズを数GBから数MBに削減 → ビルド開始が高速化。イメージサイズ肥大化一般的原因と解決策：最終イメージにビルドツール含む → マルチステージビルドで93%削減本番環境でfull rustイメージを使用 → slimランタイムベースで95%削減バイナリにデバッグシンボルが含まれる → strip target/release/myappで30-40%削減開発依存関係 → プロファイル設定[profile.release]strip = truelto = truecodegen-units = 12025年の新ツール活用docker init - プロジェクトの素早い立ち上げ# プロジェクトディレクトリで実行docker init# Rustを選択すると自動生成：# - Dockerfile# - compose.yaml# - .dockerignore# - README.Docker.mddocs.docker.comDocker Bake - 複雑なビルドの管理docker-bake.hcl:group "default" {  targets = ["app"]}variable "TAG" {  default = "latest"}target "app" {  context = "."  dockerfile = "Dockerfile"  tags = ["myapp:${TAG}"]  platforms = ["linux/amd64", "linux/arm64"]  cache-from = ["type=registry,ref=myapp:cache"]  cache-to = ["type=registry,ref=myapp:cache,mode=max"]}# 実行docker buildx bake# 変数をオーバーライドdocker buildx bake --set TAG=v1.0.0docs.docker.comおわりにこの記事では、2025年時点でのRust Dockerのベストプラクティスを包括的に解説しました。cargo-chefによる依存関係の分離キャッシング、BuildKitの永続キャッシュマウント、distrolessイメージによるセキュリティ強化という3つの柱を中心に、実践的なDockerfileパターンと実測データを提供しています。Rustのコンテナ化は長い間「ビルドが遅い」「イメージが大きい」という課題を抱えていました。コンパイル時間の長さは諦めるしかなく、数GBのイメージサイズは「Rustだから仕方ない」と言われてきました。しかし、2025年現在、その課題は完全に解決しました。適切な最適化で、ビルド時間を5-10倍短縮、イメージサイズを98-99%削減できます。これは単なる理論ではなく、実際のプロダクション環境で日々使われている技術です。2025年のゴールデンルールこの記事で紹介した技術を実践する際は、以下の10のポイントを押さえておくといいでしょう。# syntax=docker/dockerfile:1を必ず記述 - 最新のDockerfile構文を自動利用cargo-chefで依存関係を分離 - 5-10倍のビルド高速化を実現BuildKitキャッシュマウントを活用 - レイヤーを超える永続的なキャッシュdistroless/cc-debian12:nonrootを使用 - 50MB、非root、高セキュリティrust:slim-bookwormでビルド - Alpineは避ける（マルチスレッド性能問題）RUN --mount=type=bindでソースコードをマウント - COPYの最小化マルチステージビルドは必須 - 2025年の前提条件非rootユーザーで実行 - セキュリティの基本原則TrivyまたはGrypeでスキャン - 継続的なセキュリティ検証イメージバージョンをピン留め - :latestは避ける大半の本番ワークロードには、glibc + distroless/cc-debian12 + cargo-chefの組み合わせが最適解です。この構成により、50MBの小サイズ、2分の高速ビルド、フルパフォーマンス、優れたセキュリティプロファイルを実現できます。マルチスレッドアプリケーションでmuslを使う場合、1点だけ注意が必要です。最大30倍のパフォーマンス劣化リスクがあるので、本番環境への導入前に必ずベンチマークで検証しましょう。イメージサイズだけで判断すると、後で後悔します。2025年のRust Dockerは、従来の課題を完全に克服しました。高速、小サイズ、セキュア、マルチアーキテクチャ対応の成熟した技術スタックになっています。この記事で紹介した標準Dockerfileパターンは、そのままプロダクション環境で使える構成です。まずは標準パターンから始めて、必要なら sccache や cargo-zigbuild などの高度な最適化を追加するといいでしょう。Rustエコシステムの進化とDockerの機能強化で、今後もさらに改善していくはずです。この記事が、あなたのRustアプリケーションのコンテナ化に役立てば嬉しいです。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[skorchを使ってPyTorchモデルを学習してみた]]></title>
            <link>https://zenn.dev/akasan/articles/e8fd84246d013c</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/e8fd84246d013c</guid>
            <pubDate>Thu, 16 Oct 2025 12:49:36 GMT</pubDate>
            <content:encoded><![CDATA[今回はskorchを使ってPyTorchのモデルを学習してみました。skorchを利用すると、scikit-learnと同じ使い勝手でモデルを学習できるようになります。 skorchとは？先ほども書いたように、skorchを利用するとscikit-learnと互換性がある記述方式でPyTorchのモデルを学習できます。後ほどサンプルを見ながら進めますが、PyTorchで定義したモデルをskorchに受け渡して学習に利用できます。https://github.com/skorch-dev/skorch 早速使ってみる今回はGitHubに乗っているサンプルを元に使ってみます。...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[baconを知らずにRust書いてた]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/10/16/170800</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/10/16/170800</guid>
            <pubDate>Thu, 16 Oct 2025 08:08:00 GMT</pubDate>
            <content:encoded><![CDATA[cargo-watch、やめるってよRustを書いてると、気づくんですよね。保存ボタンを押すたび、手動でcargo checkとかcargo testとか叩いてる自分に。「あれ、俺って原始人だっけ？」みたいな気持ちになる。そこで救世主として現れたのがcargo-watchだったわけです。過去形。github.comそう、cargo-watchはもうメンテされてないんです。引退しちゃった。ここで一旦、真面目な話を。10年以上もcargo-watchとwatchexecっていうOSSプロジェクトを守り続けてきたFélix Saparelliさんに、心から敬意と感謝を。あなたのおかげで、世界中の無数のRust開発者が「あ、これ便利じゃん」って生産性爆上げできたんです。本当にありがとうございました。で、公式READMEには作者本人がこう書き残してる。"It's time to let it go. Use Bacon. Remember Cargo Watch."なんかもう、エモすぎません？10年以上続いたプロジェクトが、バトンを次世代に渡して静かに去っていく感じ。その後継者がbacon。そして汎用性の塊みたいなwatchexec。ベーコンって名前、朝ごはん感あるけど、これが本当にすごいんですよ。というわけでこの記事では、Rust開発で使えるファイル監視ツールについて解説していきます。cargo-watchロス、今日で終わりにしましょう。baconって何？baconは、Rust専用に作られたバックグラウンドコードチェッカーです。エディタの隣で動かしておくと、ファイルを保存するたびに自動でコンパイルチェックを走らせて、エラーや警告をリアルタイムで表示してくれます。github.comcargo-watchとの違いcargo-watchの作者が「baconこそが自分の理想だった」と語っているほど、baconは進化しています。TUIで見やすい - エラーが警告より先に表示され、スクロール不要キーボード操作 - tでテスト、cでClippy、dでドキュメントと一瞬で切り替え小さい画面でも快適 - ターミナルのサイズに合わせて表示を最適化Rust Analyzerと競合しない - 開発体験がスムーズインストール# 基本インストールcargo install --locked bacon# オプション機能も入れる（クリップボード、サウンド）cargo install --locked bacon --features "clipboard sound"基本的な使い方プロジェクトのルートでbaconを起動するだけ。cd your-rust-projectbaconデフォルトではcargo checkが走ります。ファイルを保存すると自動で再チェック。主要なキーボードショートカットbaconの真価はキーボードショートカットにあります。t - テスト実行に切り替えc - Clippyに切り替えd - ドキュメントをブラウザで開くf - テスト失敗時、そのテストだけに絞り込みEsc - 前のジョブに戻るCtrl+j - すべてのジョブ一覧を表示h - ヘルプ表示q - 終了特定のジョブで起動# テストを監視bacon test# Clippyを監視bacon clippy# 厳格なClippyルール（pedantic）bacon pedantic# 高速テストランナー（nextest）bacon nextest# すべてのターゲットをチェックbacon check-all# 特定のジョブを指定bacon --job my-custom-jobbacon.toml で設定をカスタマイズプロジェクトに合わせてジョブを定義できます。# 設定ファイルを生成bacon --init設定例# bacon.toml# Windows向けのチェック[jobs.check-win]command = ["cargo", "check", "--target", "x86_64-pc-windows-gnu"]# 厳しめのClippy[jobs.clippy-strict]command = [    "cargo", "clippy", "--",    "-D", "warnings",    "-A", "clippy::collapsible_if",]need_stdout = false# サンプルをチェック[jobs.check-examples]command = ["cargo", "check", "--examples", "--color", "always"]watch = ["examples"]  # srcは自動で監視される# 実行ジョブ[jobs.run]command = ["cargo", "run"]allow_warnings = trueneed_stdout = true# キーバインディングのカスタマイズ[keybindings]shift-c = "job:clippy-strict"r = "job:run"設定しておいてよいことドキュメントを素早く確認[jobs.doc-open]command = ["cargo", "doc", "--no-deps", "--open"]need_stdout = falseon_success = "back"  # ドキュメントが開いたら前のジョブに戻る長時間実行するアプリケーション[jobs.server]command = ["cargo", "run"]allow_warnings = trueneed_stdout = truebackground = falseon_change_strategy = "kill_then_restart"watchexecとの使い分けbaconはRust専用ですが、watchexecは汎用的なファイル監視ツールです。github.comwatchexecを使うべき場合# インストールcargo install watchexec-cli# 基本的な使い方watchexec --restart cargo run# 特定の拡張子だけ監視watchexec -e rs,toml cargo test# デバウンス設定watchexec -d 2000 cargo checkwatchexecが向いているケース：- Rust以外の言語やツール- シェルスクリプトの実行- rsyncなどの同期処理- より細かい制御が必要な場合# 例：TypeScriptのビルドwatchexec -e ts,tsx npm run build# 例：ファイル同期watchexec -w src -- rsync -avhP ./src/ ./backup/実践的なワークフロー開発時のセットアップターミナルを分割左：Vim/Neovim右上：bacon右下：通常のシェル私はWarpを使ってペイン分割している。baconの起動bacon  # デフォルトでcheckが走るコードを書く保存すると自動でチェックエラーがあれば即座に表示エラーが消えたらClippyの警告が見えるテストを書くtキーでテストモードに切り替え失敗したらfで絞り込み修正したらEscで全テストに戻る最終チェックcキーでClippyの提案を確認コード品質を向上ちょっとしたTipsシェルエイリアスで効率化頻繁に使うコマンドをエイリアス化すると便利です。# ~/.zshrc または ~/.bashrc に追加alias bac='bacon'alias bacc='bacon clippy'alias bact='bacon test'alias bacp='bacon pedantic'watchexecで複数パスを監視# srcとtestsディレクトリの.rsと.tomlファイルを監視watchexec -e rs,toml -w src -w tests -- cargo testVim/Neovimとの連携nvim-bacon プラグインbaconの診断結果をNeovimに統合するプラグインがあります。github.com" lazy.nvim の場合{  'Canop/nvim-bacon',  config = function()    require('bacon').setup()  end}主な機能は以下の通り。エラー箇所へのジャンプQuickfixへの統合:Bacon コマンドでbaconを起動:BaconLoad で診断結果を読み込み補足：VS Code向けVS Codeユーザーの場合は、bacon-lsというLanguage Serverが利用可能です。まとめcargo-watchの時代は終わりました。でも、より良いツールが生まれています。こう使い分けよう：Rust開発 → bacon一択TUIが快適キーボードだけで完結設定ファイルで柔軟にカスタマイズそれ以外 → watchexec汎用的に使えるシンプルで強力シェルスクリプトとの相性抜群baconを知らずにRustを書いていた人は、今すぐ試してください。開発体験が一段階レベルアップします。cargo install --locked baconcd your-projectbaconたったこれだけ。あとはコードを書くだけです。参考リンク：- bacon公式サイト- watchexec GitHub- cargo-watch（アーカイブ済み）]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ディレクトリ構成 ~ハイブリッド型編~]]></title>
            <link>https://sreake.com/blog/hybrid-directory-structure-good-practice/</link>
            <guid isPermaLink="false">https://sreake.com/blog/hybrid-directory-structure-good-practice/</guid>
            <pubDate>Thu, 16 Oct 2025 04:41:28 GMT</pubDate>
            <content:encoded><![CDATA[はじめに アプリケーション開発において、ディレクトリ構成は保守性・拡張性・開発効率に直結する設計要素です。 本記事では、ディレクトリ構成に悩む現場に向けて、ハイブリッド型構成をご紹介します。 ⚠️ この構成が「唯一の正解 […]The post ディレクトリ構成 ~ハイブリッド型編~ first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Pythonの@オペレータについて調べてみた]]></title>
            <link>https://zenn.dev/akasan/articles/e78d7c565fadaa</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/e78d7c565fadaa</guid>
            <pubDate>Wed, 15 Oct 2025 13:52:08 GMT</pubDate>
            <content:encoded><![CDATA[今回はPythonで@をオペレータとして利用する方法を調べてみました。Python、特にNumPyを利用して行列を取り扱っていると、計算の時に@をオペレータとして使うことがしばしばあります。というか私はNumPy以外で@をオペレータとして使っていることをみたことはありませんでした。+や-など一般的なさん術オペレータはよく利用しますが@はどのようにすれば使えるようになるのかふと気になり調べてみました。 NumPyにおける@オペレータNumPyでは@は行列積を計算するためのオペレータとなっています。例えば以下にAとB二つの行列が会った時に、その積を計算できます。以下の例はBを単位行列に...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：chafa]]></title>
            <link>https://zenn.dev/akasan/articles/80f8931f8523cd</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/80f8931f8523cd</guid>
            <pubDate>Tue, 14 Oct 2025 09:50:27 GMT</pubDate>
            <content:encoded><![CDATA[今回は久々のコマンド紹介シリーズです。第14回目の本日はchafaを紹介しようと思います。chafaを利用するとターミナル上で画像とかGIFを参照することができます。なお、第13回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/6392d28e0e02f0 chafaとは？公式GitHubによると、Chafaは、アニメーションGIFなどの画像データを、端末での表示に適したグラフィック形式またはANSI/Unicode文字アートに変換するコマンドラインユーティリティです。幅広い機能をサポートしており、歴史...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[文章力を分解してちゃんと文章を書く。]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/10/14/133602</link>
            <guid isPermaLink="false">https://syu-m-5151.hatenablog.com/entry/2025/10/14/133602</guid>
            <pubDate>Tue, 14 Oct 2025 04:36:02 GMT</pubDate>
            <content:encoded><![CDATA[はじめに文章を読むとは、自分の中で文章を再構築するということである。あなたは技術記事を読んで「わかった」と思ったのに、いざ実装しようとすると何も書けなかった経験はないだろうか。ドキュメントを読んで「理解した」と思ったのに、同僚に説明しようとすると言葉が出てこなかった経験はないだろうか。私にはある。何度もある。悲しい。これは単なる理解不足ではない。もっと根本的な問題だ。私たちは「読む」と「書く」を別々のスキルだと思い込んでいる。しかし、それは違うと私は考えている。読むとき、私たちは頭の中で文章を再構築している。書き手の言葉を、自分のスキーマ（枠組み）に翻訳し、自分の言葉で理解し直している。読むことは、実は書くことなのだ。ただ、それが頭の中で行われているだけだ。だから、「わかった」と思っても実装できないのは、頭の中で再構築したものと現実の折り合いがついていないのだ。自分の言葉で書き直せていないのだ。「読解力を分解してちゃんと文章を読む。」という記事を書いたあと、私はあることに気づいた。文章を読む力を分解して説明しようとすればするほど、自分が書く文章の問題点が見えてくるのだ。読み手がどこでつまずくかを想像すると、自分が読むときにどこでつまずいていたかが見えてくる。syu-m-5151.hatenablog.comそして、ある結論に辿り着いた。書けない人間は、読めない。これは挑発でも誇張でもない。書く力と読む力は、コインの表裏ではなく、同じものなのだ。書く経験を通じて、私たちは「文章がどのように読まれるか」を学ぶ。一文が長すぎると読み手の認知負荷が上がること。主語が不明確だと読み手が推測を強いられること。構造が曖昧だと読み手が迷子になること。逆もまたあることだ。読む経験を通じて、私たちは「文章がどのように書かれるべきか」を学ぶ。明快な文章はどのような構造を持っているか。わかりやすい説明はどのように展開されるか。読解力の記事では、読む力を3つの段階に分解した。今回の記事では、書く力を同じように分解していく。第1段階：正確に書く第2段階：誤読されないように書くスキーマを想像し、知識の呪いを断ち切る。認知バイアスを考慮し、読み手が必要な情報にたどり着ける文脈を設計する。第3段階：心を動かすように書く書くことで、初めて読めるようになる。読むことで、初めて書けるようになる。この循環的な関係を理解することが、文章力を高める第一歩だ。そして、この循環が複利的に機能する。書く力が向上すると読む力も向上し、読む力が向上するとまた書く力も向上する。この正のフィードバックループが、指数関数的な成長を生み出す。片方だけを鍛えようとしても、成長は頭打ちになる。両輪を回すことが、文章力を本質的に高める唯一の道だ。では、なぜ書く力と読む力は、これほどまでに密接に結びついているのだろうか。その理由を、まず理解する必要がある。このブログが良ければ読者になったり、nwiizoのXやGithubをフォローしてくれると嬉しいです。では、早速はじめていきます。書く力と読む力は、なぜ表裏一体なのか書けないということは、理解していないということだエラーログを読めない人は、エラーメッセージを吐き出させるときも曖昧な表現をする。「エラーが発生しました」とだけ書いて、どのエラーが、どの条件で、何が原因で発生したのかを書かない。なぜか？自分がエラーログを読むときに、これらの情報を抽出できていないからだ。というか想像できていないからだ。読んで困った時の自分を。読むときに「どこに何が書いてあるか」を理解できていない人は、吐き出させるときにも「どこに何を書くべきか」を理解できない。これは単なる不注意ではない。書こうとして初めて、「何をどの順序で書くべきか」という問いに直面する。書こうとして初めて、「読み手は何を知りたいのか」という問いに直面する。この問いと格闘する過程で、私たちは文章の構造を深く理解する。技術記事を読んで「わかった」と思うのは、個々の文章を理解したということだ。しかし、それを実装できないのは、全体の構造を理解していないからだ。これは、ラバーダック・デバッギングと同じ原理だ。コードを声に出して説明しようとすると、理解の穴が見えてくる。文章を書こうとすると、読解の穴が見えてくる。書こうとして手が止まる瞬間、そこに理解の穴がある。誤読された経験が、誤読を防ぐ力を育てる理解の穴が見えるだけでは十分ではない。さらに重要なのは、自分が書いた文章がどう読まれるかを知ることだ。「この文章は誤解される」と事前に気づくには、自分が誤読された経験が必要だ。吐き出させた文章が意図と違う形で受け取られた経験。怒りのコメントを受けた経験。これらの痛い経験を通じて、人は「どんな書き方が誤解を生むか」を学ぶ。誤読には、いくつかのパターンがある。パターン1：主語の曖昧さによる誤読この機能の実装が遅れています。仕様が複雑で理解に時間がかかっています。書き手は「私」のつもりで書いている。しかし、読み手は「チーム全体」だと解釈するかもしれない。この誤読は、書き手が主語を省略したことで生じる。パターン2：文脈の欠如による誤読この実装方法は悪くない。書き手は、他の実装方法と比較して「悪くない」と言っている。しかし、読み手は、この実装方法が「及第点」程度だと解釈するかもしれない。パターン3：二重否定による誤読この問題は無視できない。書き手は「重要だ」と言いたい。しかし、読み手は「ある程度重要だが、最優先ではない」と解釈するかもしれない。誤読された経験は、痛い。しかし、その痛みこそが、書く力と読む力を同時に高める。書く経験が乏しい人は、読むときにも「書き手の意図」を想像できない。スキーマは読み書き両方で機能する誤読を防ぐには、さらに深い理解が必要だ。それは、読み手と書き手でスキーマが異なるという理解だ。人はスキーマを通して文章を理解する。スキーマとは、私たちが頭の中に持っている知識の枠組みのこと。例えば、「非同期処理」というキーワードを見たとき、Rustエンジニアの頭の中では、tokio、async/await、Future traitといった関連する概念が自動的に呼び出される。しかし、スキーマは読むときだけでなく、書くときにも機能している。そして、書くときのスキーマの働き方が、しばしば問題を引き起こす。あなたが「非同期処理を実装した」と書くとき、あなたの頭の中には「非同期処理」についての豊富なスキーマがある。だから、読み手もそのスキーマを共有していると無意識に仮定してしまう。これを「知識の呪い」と呼ぶ。【悪い例】非同期処理を実装しました。これでパフォーマンスが改善されます。書き手にとって、これは十分に明確だ。しかし、読み手はどうか？Rustエンジニアは「tokioのasync/awaitを使うのか」と想像する。Goエンジニアは「goroutineを使うのか」と想像する。非同期処理に馴染みのないエンジニアは「何が改善されるのか」すらわからない。書く力が高い人は、「読み手は自分とは違うスキーマを持っている」と意識的に認識する。そして、読み手のスキーマを想像し、橋を架けるように書く。【良い例】非同期処理を実装しました。従来は3つのマイクロサービスへのHTTPリクエストを順番に実行していたため、合計で3秒かかっていました。今回、Rustのtokioとasync/awaitを使ってこれらのリクエストを並行実行するように変更しました。その結果、3つのリクエストが同時に実行されるため、最も遅いリクエスト（1秒）の時間だけで完了するようになりました。これにより、全体の処理時間が3秒から1秒に短縮され、APIのレスポンスタイムが大幅に改善されました。では、この「読み手のスキーマを想像する力」は、どうやって獲得できるのか？答えは、読み手として多様な文章に触れ、「わからない」を経験することだ。自分が知らない分野の技術記事を読んで、「専門用語が多くてわからない」と感じる。その経験が、書き手として「専門用語を使うときは説明を加えよう」という意識を育てる。書くことは、読む力を鍛える最良の訓練ここまで見てきたように、書く経験は読む力を高める。しかし、その逆も真だ。読む経験は書く力を高める。この循環を最も効果的に回す方法が、実は書くことなのだ。なぜか？書こうとすると、言語化できない部分に直面するからだ。頭の中では理解しているつもりでも、いざ文章にしようとすると言葉が出てこない。この瞬間、あなたは「本当は理解していなかった」と気づく。しかし、問題はもっと深い。ちゃんと読むとは、自分の中でちゃんと書くということでもある。複雑な文章を読むとき、私たちは無意識のうちに「これはつまり、こういうことだな」と自分の言葉で要約している。この「内なる執筆」ができない人は、文章を読んでも理解が浅い。例を見てみよう。技術記事に「エラーハンドリングを実装すると、システムの信頼性が向上する」と書いてある。浅い読み方：「エラーハンドリングを実装すると信頼性が向上するのか。なるほど。」深い読み方：「エラーハンドリングを実装すると信頼性が向上する、と言っている。なぜか？エラーハンドリングがないと、エラーが発生したときにプログラムがパニックして停止してしまう。その結果、ユーザーはサービスを使えなくなる。一方、エラーハンドリングを実装すれば、エラーが発生してもプログラムは継続でき、ユーザーに明確なエラーメッセージを返せる。つまり、『信頼性が向上する』とは『エラー時でもサービスを継続できる』という意味だな。」深い読み方をしている人は、頭の中で文章を書いている。この「内なる執筆」の能力は、実際に書く経験を通じて鍛えられる。外に向けて文章を書くとき、私たちは「どう表現すれば伝わるか」を考える。この試行錯誤が、内なる執筆の能力を高める。だから、外に向けて書く訓練をすることは、内に向けて書く力も鍛える。このように、書く力と読む力は表裏一体だ。では、具体的にどう書けばよいのか。読解力の記事と同様、書く力も3つの段階に分解して見ていこう。第1段階：正確に書く読解力の第1段階は「書かれていることを正確に理解する力」だった。文章力の第1段階は、「伝えたいことを正確に伝える力」だ。これは、技術的なスキルだ。感性や才能ではなく、学習可能なスキルだ。悪文とは何か。それは、一義的に解釈できない文章だ。一つの文を読んで、複数の意味に解釈できてしまう。主語が不明確で、誰が何をしているのかわからない。修飾関係が複雑で、何がどこにかかっているのか判然としない。こうした構造的な問題が、悪文を生む。文章を書くコツは、芸術的な名文を書くことではない。読みにくい「悪文」を書かないことである。では、悪文を防ぐにはどうすればよいか。ここでは四つ紹介します。他にも悪文を分かりやすくする方法はいくらかありますがたくさん本が出ていますのでそちらを参考にしてほしいです。悪文の構造　――機能的な文章とは (ちくま学芸文庫)作者:千早耿一郎筑摩書房Amazon「文章術のベストセラー100冊」のポイントを1冊にまとめてみた。作者:藤𠮷 豊,小川 真理子日経BPAmazon一文一義で書く【悪い例】デプロイ作業中にDBマイグレーションが失敗したため、問題箇所をスキップすればデプロイは可能ですが、Xモジュールへの影響が不明なので、明日Yさんが出社してから対応するか、今日スキップしてデプロイするか、どちらが良いと思いますか？この一文には、6つの義が詰め込まれている。読み手は、これらすべてを一度に処理しなければならない。認知負荷が高すぎる。なぜ一文一義が重要なのか？人間の作業記憶（ワーキングメモリ）の容量は限られている。一文が長く、複数の義が含まれていると、読み手は文の途中で最初の部分を忘れてしまう。一文一義で書くことは、読み手の認知リソースを尊重することだ。【良い例】デプロイ作業中、DBマイグレーションに失敗しました。問題箇所をスキップすればデプロイは可能ですが、Xモジュールへの影響が不明です。対応方針を相談させてください。以下の2つの選択肢のうち、どちらが良いでしょうか？A. 明日Yさんが出社後、一緒に影響範囲を調査してから対応するB. 今日、問題箇所をスキップしてデプロイする一文一義の原則を守るには、3つのルールがある。ルール1：文章は短くするルール2：形容詞と被形容詞はなるべく近づけるルール3：一つの文に、主語と述語はひとつずつ短く、近く、シンプルに。これが機能的な文章の基本だ。主語を明示する一文一義を守るだけでは不十分だ。次に重要なのは、誰が何をしているかを明確にすることだ。日本語は主語を省略できる言語だ。しかし、文章を書くとき、特に技術文書やビジネス文書を書くとき、文脈が常に明らかとは限らない。主語を省略すると、3つの問題が生じる。問題1：責任の所在が不明確になる【悪い例】バグを修正しました。【良い例】私がバグを修正しました。問題2：行為者が不明確になる【悪い例】テストを実行して、結果を確認しました。【良い例】私がテストを実行しました。Aさんが結果を確認しました。問題3：複数の解釈が可能になる【悪い例】レビュー後、デプロイしました。【良い例】Aさんのレビュー後、私がデプロイしました。では、どうすればよいか？主語を省略してもよい場合と、省略してはいけない場合を区別する。主語を省略してもよい場合：直前の文と同じ主語の場合、文脈から主語が明らかな場合。主語を省略してはいけない場合：主語が変わる場合、責任の所在を明確にする必要がある場合、複数の解釈が可能な場合。冗長さを避ける正確に書くことは重要だが、冗長に書くことは避けなければならない。必要な情報だけを、必要な長さで書く。冗長な文章は、読み手の時間を無駄にする。忙しいエンジニアは、冗長な文章を読む時間がない。冗長な文章は、重要な情報を埋もれさせる。冗長さには、いくつかのパターンがある。パターン1：同じことを繰り返す【悪い例】この問題は重要な問題です。なぜなら、この問題を放置すると、ユーザーに影響が出る重大な問題だからです。【良い例】この問題は重要です。放置するとユーザーに影響が出ます。パターン2：不要な修飾語を使う【悪い例】非常に重要な機能の実装を丁寧に進めています。【良い例】重要な機能を実装中です。「非常に」「丁寧に」といった修飾語は、情報を追加していない。削除しても意味は変わらない。パターン3：回りくどい表現を使う【悪い例】バグを修正することに成功しました。【良い例】バグを修正しました。「〜することに成功しました」は、「〜しました」で十分だ。冗長さを避けるには、3つの原則がある。原則1：削除できる言葉は削除する原則2：同じ情報は一度だけ書く原則3：具体的な動詞を使う簡潔さは、尊重の表現だ。読み手の時間を尊重し、認知リソースを尊重する。構造を明確にする一文一義で書き、主語を明示し、冗長さを避ける。しかし、それだけでは不十分だ。文章全体の構造を明確にする必要がある。箇条書きと文章の使い分けは、書き手の重要なスキルだ。並列関係の情報は箇条書きで、因果関係の情報は文章で。なぜ構造が重要なのか？構造は、思考の可視化だからだ。構造を明確にする最も基本的な単位は、パラグラフ（段落）だ。一つのパラグラフには、一つの主張しか含めない。構造を明確にするには、3つのレベルがある。レベル1：文のレベルレベル2：パラグラフのレベルレベル3：セクションのレベルこの3つのレベルの構造が明確な文章は、読み手にとって理解しやすい。第1段階の「正確に書く」力を身につけると、少なくとも誤解されない文章が書けるようになる。しかし、それだけでは不十分だ。読み手は、あなたの意図を汲み取ろうとしてくれるとは限らない。次の段階では、より能動的に誤読を防ぐ技術を学ぶ。ユーザーの問題解決とプロダクトの成功を導く　エンジニアのためのドキュメントライティング作者:ジャレッド・バーティ,ザッカリー・サラ・コーライセン,ジェン・ランボーン,デービッド・ヌーニェス,ハイディ・ウォーターハウス日本能率協会マネジメントセンターAmazon第1段階の実践訓練訓練1：一文一義の練習訓練2：主語の明示訓練3：冗長さの削除訓練4：構造の可視化訓練5：要約を書くAIを使った第1段階の訓練生成AIは、第1段階の訓練に有効だ。AIに構造をチェックさせるAIの文章を添削する重要な注意点第2段階：誤読されないように書く読解力の第2段階は「書かれていない意図を汲み取る力」だった。文章力の第2段階は、「読み手の誤読を防ぐ力」だ。第1段階では、文章の構造的な問題を防ぐ方法を学んだ。一文一義で書き、主語を明示し、冗長さを避け、構造を明確にする。しかし、構造が正しくても、誤読は起きる。なぜか？読み手と書き手でスキーマが異なるからだ。前のセクションで「知識の呪い」について説明した。ここでは、その呪いを断ち切り、読み手のスキーマに合わせて書く具体的な方法を学ぶ。「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策作者:今井むつみ日経BPAmazon技術ドキュメントの品質は、ここで決まる特に技術ドキュメントにおいては、第2段階が品質を決定づける。第1段階の「正確に書く」は、技術ドキュメントの必要条件だ。構造が曖昧で、主語が不明確で、冗長な技術ドキュメントは、そもそも読むに値しない。しかし、第1段階をクリアしただけでは、良い技術ドキュメントにはならない。技術ドキュメントの良し悪しを分けるのは、読み手が迷わず、誤解せず、必要な情報にたどり着けるかだ。これこそが第2段階の本質だ。構造的には正しいが、読み手のスキーマを無視したドキュメント。専門用語が説明なしに使われ、前提知識が明示されず、文脈が欠如しているドキュメント。こうしたドキュメントは、正確ではあるが、使えない。逆に、読み手のスキーマを想像し、知識の呪いを断ち切り、読み手が必要な情報にたどり着ける文脈を設計したドキュメントは、読み手を迷わせない。読み手は、探している情報をすぐに見つけられる。誤解なく理解できる。そして、次のアクションを取れる。APIリファレンス、設計書、運用手順書、トラブルシューティングガイド。これらの技術ドキュメントは、第3段階の「心を動かす」手法は不要だ。感情に訴える必要はない。しかし、第2段階の「誤読されないように書く」技術は、絶対に必要だ。技術ドキュメントを書くとき、常に自問すべきだ。「読み手は、この情報を探しているとき、どんな状況にいるのか？」「読み手は、どのくらいの前提知識を持っているのか？」「読み手は、この用語を知っているのか？」これらの問いに答えることが、使える技術ドキュメントと使えない技術ドキュメントを分ける。読み手のスキーマを想像するドキュメントを書くとき、まず問うべきは「読み手は誰か？」だ。読み手は誰か？何を知っていて、何を知らないか？どんな問題を解決しようとしているか？知識の呪いを断ち切るには、3つの方法がある。方法1：具体化する方法2：例示する方法3：段階的に説明する読み手のスキーマを想像する能力は、読み手として多様な文章に触れ、「わからない」を経験することで獲得できる。しかし、スキーマを想像するだけでは不十分だ。次に重要なのは、読み手の認知バイアスを考慮することだ。認知バイアスを考慮する読み手がどんなバイアスを持っているかを想定し、誤読を防ぐ。パターン1：二重否定による混乱【誤読されやすい例】この実装方法は悪くない。【誤読されにくい例】この実装方法は、実用上十分な性能を持っています。具体的には、毎秒1000リクエストを処理できます。パターン2：曖昧な数量表現【誤読されやすい例】この問題は重要です。【誤読されにくい例】この問題は、今週中に対応が必要です。なぜなら、放置するとユーザーがログインできなくなるからです。パターン3：主観的な評価【誤読されやすい例】このツールは使いやすい。【誤読されにくい例】このツールは、5分で環境構築できます。コマンド一つで起動でき、GUIで操作できます。認知バイアスを考慮した文章は、客観的で、具体的で、測定可能だ。文脈を設計する技術記事を書くとき、どこまで前提知識を説明すべきか。この判断には原則がある。原則1：読み手のレベルに合わせる原則2：この記事で必要な知識だけを説明する原則3：外部リソースを活用するテンプレートを活用する第2段階における最も実用的な方法の一つが、テンプレートの活用だ。テンプレートは、第1段階の「構造を明確にする」技術と似ているが、その目的は異なる。第1段階では、書き手が構造的に正しい文章を書くためのツールだった。第2段階では、読み手が迷わず、必要な情報にたどり着けるためのツールだ。テンプレートには、3つの利点がある。利点1：読み手の予測可能性を高める利点2：必要な情報を漏れなく提供する利点3：読み手の認知負荷を減らす例えば、バグ報告のテンプレートは次のようになる。## 概要[バグの概要を一行で]## 再現手順1. [手順1]2. [手順2]3. [手順3]## 期待される動作[何が起きるべきか]## 実際の動作[実際に何が起きたか]## 環境- OS: - ブラウザ: - バージョン: ## 追加情報[スクリーンショット、ログなど]このテンプレートを使えば、読み手（バグを修正するエンジニア）は、必要な情報をすぐに見つけられる。「再現手順はどこだ？」「どの環境で起きたんだ？」と探す時間を削減できる。技術ドキュメントのテンプレートは次のようになる。## 概要[この文書が何について説明するか]## 前提条件[読者が知っているべきこと、必要な環境]## 手順[具体的な手順、コード例]## トラブルシューティング[よくある問題と解決法]## 参考資料[関連するドキュメント、リンク]プルリクエストのテンプレートは次のようになる。## 変更内容[何を変更したか]## 変更理由[なぜ変更したか]## 影響範囲[どの機能に影響するか]## テスト[どのようにテストしたか]## レビューのポイント[レビュアーに特に見てほしい箇所]テンプレートを使う際の注意点：テンプレートは、読み手を助ける道具だ。しかし、テンプレートに縛られすぎてはいけない。状況に応じて、テンプレートをカスタマイズする。不要なセクションは削除し、必要なセクションは追加する。重要なのは、「読み手が必要な情報にたどり着けるか」という問いだ。テンプレートは、この問いに答えるための手段であって、目的ではない。第2段階の「誤読されないように書く」力を身につけると、読み手に正確に情報を伝えられるようになる。読み手のスキーマを想像し、認知バイアスを考慮し、読み手が必要な情報にたどり着ける文脈を設計する。しかし、それだけでは不十分だ。情報を伝えるだけでなく、読み手の心を動かす必要がある。なぜなら、心が動かなければ、読み手は行動しないからだ。次の段階では、その方法を学ぶ。第2段階の実践訓練訓練1：説明を書くスキーマを想像しながら書く訓練だ。「この人は何を知っていて、何を知らないか？」を考える。具体的には、次のような取り組みができる。初心者向けに、自分が得意な技術を説明する記事を書く。専門用語を使うたびに、「この用語は説明が必要か？」と自問する。書いた後、その分野に詳しくない人に読んでもらい、わからなかった箇所を聞く。訓練2：批判的に読む訓練3：テンプレートの作成エストなど）のテンプレートを作る。ただし、第1段階の「構造を明確にする」だけでなく、「読み手が必要な情報にたどり着けるか」という視点で作る。読み手が最も知りたい情報は何か？それをどこに配置すれば見つけやすいか？AIを使った第2段階の訓練AIに読み手のスキーマを想像させるAIと対話しながら書く重要な注意点第3段階：心を動かすように書く読解力の第3段階は「本当に重要なことを見抜く力」だった。文章力の第3段階は、「読み手の心を動かす力」だ。なお、この第3段階は、技術記事、ブログ、プレゼンテーションなど、読者の心を動かす必要がある文章に適用される。技術ドキュメント（APIリファレンス、設計書、仕様書など）では、第1段階と第2段階で十分だ。むしろ、客観性と正確性が重視される技術ドキュメントには、この段階の手法は合わない場合が多い。「読みたいこと」とは何か？多くの人が誤解する。「読みたいこと」とは、「自由に好き勝手に自分の気持ちを書くこと」ではない。「読みたいこと」とは、自分が読者だったら読みたいと思うものだ。自分が本屋で金を出して買いたいと思うもの。自分が時間を使って読みたいと思うもの。書きたいことではない。読みたいことだ。これは、他人の視点に立てという話ではない。徹底的に自分の視点で、自分が読者として読みたいかどうかを問うということだ。この問いは、書きたいことを書く自由よりも、はるかに厳しい制約だ。第1段階では構造を学び、第2段階では誤読を防ぐ技術を学んだ。しかし、それだけでは読み手の心は動かない。心を動かすには、まず読者を引きつける必要がある。三行で撃つ 〈善く、生きる〉ための文章塾作者:近藤 康太郎ＣＥメディアハウスAmazon最初の三行で撃つ最初の一文、長くても三行くらいで心を撃たないと、忙しい読者は逃げていく。読者はあなたに興味がない。読者にとって、あなたの書こうとするテーマはどうでもいい。冷厳な現実だ。では、どうすれば最初の三行で読者を撃てるのか？方法1：問題を提示する方法2：驚きを与える方法3：具体的な利益を示すしかし、最も重要なのは、お前が何者かは、読者にとって関係ないということだ。【悪い例】私は10年間、技術記事を書いてきました。その経験から学んだ文章術を共有します。読者は、基本的にあなたの経歴に興味がない。あなたが何年エンジニアをやってきたか、どんな実績があるか、ほとんどの読者にとってどうでもいい。読者が知りたいのは、「この記事は自分の問題を解決してくれるのか？」「面白い時間が過ごせるか？」「読む価値のある新しい視点があるのか？」「具体的で実践できる内容なのか？」「読んだ後、自分は何ができるようになるのか？」。これらの問いだけだ。書き手の自己紹介から始まる記事は、これらの問いに答えていない。だから、読者は離れていく。【良い例】エラーメッセージを読めない人は、エラーメッセージを吐き出させるときも曖昧だ。なぜか？この書き出しは、問題提起だ。読者は「なぜだろう？」と思う。書き出しで読者を引きつけることができた。しかし、心を動かすにはそれだけでは不十分だ。次に必要なのは、空虚な言葉を避けることだ。常套句を避ける書き出しで読者を引きつけても、内容が空虚なら読者は離れていく。そして、内容を空虚にする最大の敵が、常套句だ。常套句は、まさに「わかったつもり」を生み出す装置だ。このアプローチはベストプラクティスです。「ベストプラクティス」とは何か？誰が決めたのか？どういう文脈で最適なのか？なぜ最適なのか？これらの問いに答えない限り、「ベストプラクティス」という言葉は空虚だ。常套句には、いくつかのパターンがある。パターン1：抽象的なバズワードラクティス、レバレッジ、シナジー、エンパワーメント、イノベーション。これらの言葉は、具体的な内容を隠蔽する。パターン2：「としたもんだ表現」パターン3：擬音語・擬態語・流行語常套句を避けることは、思考を深めることだ。「ベストプラクティス」と書こうとして、「本当にベストなのか？」と自問する。この思考の過程が、文章を具体的にし、説得力を高める。常套句を避け、具体的に書くことができたら、次は自分にしか書けない内容を書く。自分の言葉で書く【常套句に逃げる例】Rustの所有権システムは学習が難しい。でも、理解すれば強力だ。これは誰でも書ける文章だ。【自分の言葉で書く例】私がRustの所有権システムを理解するのに、3ヶ月かかった。最初の1ヶ月は、borrowチェッカーのエラーが理解できず、「なぜこのコードが動かないのか」と毎日フラストレーションを感じていた。「cannot borrow `*x` as mutable because it is also borrowed as immutable」このエラーメッセージを見るたびに、「Cのポインタのように自由に使わせてくれよ」と思っていた。転機は、所有権を「責任の所在」として捉え直してからだ。「このデータに対する責任は誰が持つのか」と考えるようになってから、borrowチェッカーのメッセージが「監査人の指摘」として理解できるようになった。この文章は、あなたにしか書けない。あなたの体験、あなたの発見だ。自分の言葉で書くには、3つの要素が必要だ。要素1：具体的な体験要素2：五感で世界を切り取る要素3：思考の過程自分の言葉で書くとは、言い換えることだ。「所有権」という抽象的な概念を、「責任の所在」という具体的な比喩で言い換える。言い換えるとは、考えることだ。しかし、自分の言葉で書くだけでは不十分だ。言葉だけでは、読み手の心は十分には動かない。次に必要なのは、エピソードの力だ。技術ブログの書き方はここに書いているので読んでみてほしいです。syu-m-5151.hatenablog.comsyu-m-5151.hatenablog.com響く文章は説明しない【説明する例】ドキュメントを書くことは重要です。なぜなら、ドキュメントがないとユーザーが困るからです。説明は響かない。【エピソードで語る例】私が初めてオンコール当番を担当したとき、深夜2時にアラートが鳴った。Datadogのダッシュボードには、「CPU usage > 80%」というアラートしか表示されていなかった。「どのサービスのCPUが高いのか」「何が原因なのか」「どうやって対処すればいいのか」何もわからず、私は1時間を無駄にした。結局、先輩を叩き起こして対処してもらった。先輩は5分で原因を特定し、10分で対処した。翌朝、先輩に聞いた。「なぜそんなに早く対処できたんですか？」先輩は言った。「アラートに必要な情報が書いてあったからだよ」そのとき誓った。自分がアラートを作るときは、必ずRunbookへのリンクを含めようと。それから3年、私はこの誓いを守っている。エピソードは響く。具体的な場面、具体的な感情、具体的な決断。これらが、読み手の心を動かす。なぜエピソードは説明よりも響くのかエピソードが響く理由は、共感にある。読み手は、あなたの物語の中に自分を見出す。「深夜2時のアラート」「何もわからない焦り」「先輩を叩き起こす申し訳なさ」。これらの感情は、多くのエンジニアが経験したことがある。あるいは、いつか経験するかもしれない。だから、読み手は「ああ、わかる」と思う。この「わかる」という感覚が、共感だ。共感は、説明では生まれない。「ドキュメントは重要です」という説明は、頭では理解できる。しかし、心は動かない。一方、エピソードは、読み手を物語の中に引き込む。読み手は、あなたの経験を追体験する。あなたの焦りを感じ、あなたの学びを共有する。共感してもらえる物語には、3つの条件がある。条件1：普遍的な感情を含む条件2：具体的な状況を描く追体験できる。「1時間を無駄にした」という具体的な時間。「先輩を叩き起こした」という具体的な行動。条件3：弱さを見せる共感は、信頼を生む。読み手があなたの物語に共感すると、あなたの言葉を信頼するようになる。「この人は、自分と同じ問題に直面して、それを乗り越えた人だ」。この信頼が、読み手を行動に移させる。説明では信頼は生まれない。しかし、共感できる物語は、信頼を築く。ただし、共感を意図的に操作しようとしてはいけない。作られた感情や、誇張された困難は、読み手に見抜かれる。本当に経験したこと、本当に感じたこと、本当に学んだことを書く。その誠実さが、最も強い共感を生む。エピソードで語るには、ストーリーの構造が必要だ。状況 - どんな状況だったか問題 - 何が問題だったか行動 - 何をしたか結果 - どうなったか学び - 何を学んだか自分の言葉で書き、共感してもらえるエピソードで語る。しかし、それでも心を動かすには、もう一つ必要なものがある。それは、あなたの生き方や物語そのものだ。書くことは生きること「書くことは生きること」。文章を書くことは、技術ではない。生き方だ。思索が深まるほどに、世界の切り取り方が変わり、自分が変わる。技術記事を書くとき、私たちは技術を説明しているだけではない。私たちは、技術を通して世界を理解している。「なぜこの技術は存在するのか」「どんな問題を解決するのか」「どんな未来を可能にするのか」。これらの問いに答えることは、技術を理解することであり、同時に世界を理解することだ。そして、これらの問いに答える過程で、私たちは自分自身を理解する。書くことで、私たちは自分になる。書くことは、自分の物語を紡ぐこと書くことは、単に情報を伝えることではない。自分の物語を紡ぐことだ。あなたがエンジニアとして生きてきた日々。深夜のデバッグ、突然の本番障害、チームでの議論、新しい技術との出会い、失敗から学んだ教訓。これらすべてが、あなたの物語だ。書くとは、これらの断片的な経験を、一つの物語として編集することだ。物語には、3つの力がある。力1：意味を与える力力2：つながりを生む力力3：未来を変える力しかし、物語を紡ぐには、勇気が必要だ。自分の失敗を書くこと。「わからなかった」「1時間を無駄にした」「先輩を叩き起こした」。これらの弱さを見せることは、恥ずかしい。しかし、完璧な成功物語は、誰の心も動かさない。読み手が求めているのは、完璧なヒーローではない。同じように悩み、同じように失敗し、それでも前に進んだ人の物語だ。あなたの物語は、すでにある。日々の仕事の中で、あなたは物語を生きている。書くことは、その物語を可視化することだ。そして、可視化することで、物語はより明確になる。「自分は何を大切にしているのか」「どんな価値観で生きているのか」「どこに向かっているのか」。物語を書くことで、あなたは自分の物語を理解する。わたしにしか、書けないものは、ある。わたしにしか、紡げない物語は、ある。そう信じることから、文章は始まる。第3段階の実践訓練なお、これらの訓練は、技術記事、ブログ、プレゼンテーションを書く人向けだ。技術ドキュメントを書く人は、第1段階と第2段階の訓練に集中してほしい。訓練1：書き出しを3パターン書く訓練2：常套句を見つけて書き直すラクティス」→「なぜベストなのか？どういう条件で？」と問う。技術記事では、抽象的な言葉が説得力を失わせる。訓練3：自分の体験を書く訓練4：説明ではなく、エピソードで語る訓練5：自分の文章を読み直すAIを使った第3段階の訓練AIに書き出しを生成させて、添削するAIに常套句を指摘させるAIに自分の文章を批判させるAIには書けないものを書くおわりに「読解力を分解してちゃんと文章を読む。」を書いたとき、私は気づいた。読む力を説明しようとすることは、書く力を鍛えることでもあると。そして今、「文章力を分解してちゃんと文章を書く。」を書き終えて、改めて実感する。書く力を説明しようとすることは、読む力を鍛えることでもあると。読む力と書く力は、別々のスキルではない。同じスキルの異なる側面だ。この記事の冒頭で、私はこう書いた。「技術記事を読んで『わかった』と思ったのに、いざ実装しようとすると何も書けなかった経験はないだろうか」。なぜ実装できないのか。答えは明確だ。頭の中で再構築できていないからだ。読むとは、実は書くことなのだ。ただ、それが頭の中で行われているだけだ。だから、読む力を高めたいなら、書くことだ。書く力を高めたいなら、読むことだ。この循環が、複利的に機能する。第1段階では、正確に書く技術を学んだ。一文一義、主語の明示、構造の明確化。これは、悪文を書かないための必要条件だ。第2段階では、誤読を防ぐ技術を学んだ。読み手のスキーマを想像し、知識の呪いを断ち切り、文脈を設計する。特に技術ドキュメントでは、この段階が品質を決定づける。第3段階では、心を動かす技術を学んだ。書き出しで引きつけ、常套句を避け、自分の言葉で語り、エピソードで伝える。ただし、これは技術記事やブログに適用される段階であり、技術ドキュメントには不要だ。しかし、文章を書くことの意味は、スキルを高めることだけではない。書くことは、思考を深めることだ。思索が深まるほどに、世界の切り取り方が変わり、自分が変わる。書くことは、世界を理解することだ。技術を説明しようとするとき、私たちは「なぜこの技術は存在するのか」「どんな問題を解決するのか」を問う。書くことは、自分を理解することだ。言語化できない部分に直面したとき、私たちは「本当は理解していなかった」と気づく。だから、書くことは生きることだ。明日から、何か一つ書いてみよう。Slackのスレッドでもいい。プルリクエストのコメントでもいい。技術記事でもいい。書こうとして手が止まる瞬間、そこに理解の穴がある。その穴を埋めることが、あなたの成長だ。わたしにしか、書けないものは、ある。そう信じて、書き続けることだ。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[TFLintカスタムプラグインで始める Terraformコード品質管理]]></title>
            <link>https://speakerdeck.com/bells17/tflintkasutamupuraguindeshi-meru-terraformkodopin-zhi-guan-li</link>
            <guid isPermaLink="false">https://speakerdeck.com/bells17/tflintkasutamupuraguindeshi-meru-terraformkodopin-zhi-guan-li</guid>
            <pubDate>Tue, 14 Oct 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Go Night Talks – After Conference の LT資料ですhttps://mercari.connpass.com/event/367075/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitHubで管理されているZennのtopicsを集計するコードをclaude codeに作らせた]]></title>
            <link>https://zenn.dev/akasan/articles/1cc5493f3e077a</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/1cc5493f3e077a</guid>
            <pubDate>Mon, 13 Oct 2025 04:17:00 GMT</pubDate>
            <content:encoded><![CDATA[今回はタイトル通り、GitHubでZennの記事を管理している場合に、どのようなtopicsがよく利用されているか集計するための機能をclaude codeに作らせてみました。私自身連続170記事以上出している関係で、どのような技術をよく利用しているか調べたくなり、作らせてみました。 ZennをGitHubで管理するためのフォルダ構成違いはあるかもしれませんが、基本的には以下のフォルダ構成で管理されていると思います。articles/  hogehoge.md  fugafuga.mdbooks/  ...images/  ...scrapes  ...今回はa...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[OpenAI Agent Builderを使ってGuardrail実装してみた]]></title>
            <link>https://zenn.dev/akasan/articles/c1698aa0289828</link>
            <guid isPermaLink="false">https://zenn.dev/akasan/articles/c1698aa0289828</guid>
            <pubDate>Sun, 12 Oct 2025 04:19:21 GMT</pubDate>
            <content:encoded><![CDATA[今回は、現地時間10月6日にOpenAIが発表したAgent Builderという機能を早速使ってみました。Agent Builderを利用することで、GUIを利用してエージェントを作成することができるようになります。 Agent Builderとは？Agent BuilderはOpenAI DevDay 2025にて発表された新しいプロダクトとなっています。Agent Builderを利用すると、ドラッグアンドドロップでロジックを構成し、ツールを接続やカスタムガードレールを構成するためのキャンバスを利用できます。また、プレビューの実行、インラインのeval設定、完全なバージョニン...]]></content:encoded>
        </item>
    </channel>
</rss>