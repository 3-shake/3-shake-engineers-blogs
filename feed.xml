<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Tue, 03 Dec 2024 11:34:33 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[退屈なことはRust Build Scripts にやらせよう]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/12/03/143149</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/12/03/143149</guid>
            <pubDate>Tue, 03 Dec 2024 05:31:49 GMT</pubDate>
            <content:encoded><![CDATA[こちらの記事は Rust Advent Calendar 2024 シリーズ 3 3日目の記事です！qiita.comはじめにRustのビルドスクリプト（build.rs）は、コンパイル前のデータ処理や環境設定を自動化する強力なツールです。しかし、大いなる力には、大いなる責任が伴います。コードの生成、リソースの最適化、プラットフォーム固有の設定管理など、ビルド時の様々なタスクを効率的に処理できます。今回は、そのユースケースの1つとして、郵便番号データを処理するビルドスクリプトの実装を詳しく解説します。この例を通じて、build.rsの基本的な使い方から実践的な活用方法まで、段階的に理解を深めていきましょう。doc.rust-lang.orgはじめにユースケース：郵便番号データの処理実装の全体像実装の詳細解説1. ファイル変更の監視設定2. パスの設定3. データの処理4. 結果の出力生成したデータの利用方法1. アプリケーションでのデータ読み込み2. 検索機能の実装build.rsの主要な機能1. 環境変数の設定2. リンカ設定3. コードの生成実践的な利用シーン1. 設定ファイルの統合と生成2. プロトコル定義ファイルの生成3. アセットファイルの埋め込み4. データベースマイグレーションファイルの統合参考資料まとめユースケース：郵便番号データの処理このビルドスクリプトは、複数のJSONファイルに分散された郵便番号データを1つのファイルにマージする処理を行います。github.com実装の全体像use serde_json::Value;use std::collections::HashMap;use std::fs;use std::path::Path;use walkdir::WalkDir;fn main() {    println!("cargo:rerun-if-changed=jpostcode-data/data/json");    let json_dir = Path::new("jpostcode-data/data/json");    let out_dir = std::env::var("OUT_DIR").unwrap();    let dest_path = Path::new(&out_dir).join("address_data.json");    let mut merged_data = HashMap::new();    // ... データ処理ロジック ...}実装の詳細解説1. ファイル変更の監視設定println!("cargo:rerun-if-changed=jpostcode-data/data/json");この行は、指定したディレクトリ内のファイルが変更された場合にのみビルドスクリプトを再実行するように設定します。これにより、不必要なビルド時間を削減できます。2. パスの設定let json_dir = Path::new("jpostcode-data/data/json");let out_dir = std::env::var("OUT_DIR").unwrap();let dest_path = Path::new(&out_dir).join("address_data.json");json_dir: 入力となるJSONファイルが格納されているディレクトリout_dir: Cargoが提供するビルド出力ディレクトリdest_path: 生成されるファイルの出力先3. データの処理for entry in WalkDir::new(json_dir).into_iter().filter_map(|e| e.ok()) {    if entry.file_type().is_file()        && entry.path().extension().map_or(false, |ext| ext == "json")    {        let content = fs::read_to_string(entry.path()).unwrap();        let file_data: HashMap<String, Value> = serde_json::from_str(&content).unwrap();        let prefix = entry.path().file_stem().unwrap().to_str().unwrap();        for (suffix, data) in file_data {            let full_postcode = format!("{}{}", prefix, suffix);            merged_data.insert(full_postcode, data);        }    }}このコードブロックでは以下の処理を行っています。WalkDirを使用してディレクトリを再帰的に走査JSONファイルのみを対象にフィルタリング各ファイルの内容を読み込みとパースファイル名とデータを組み合わせて完全な郵便番号を生成マージされたデータに追加4. 結果の出力fs::write(dest_path, serde_json::to_string(&merged_data).unwrap()).unwrap();処理したデータを1つのJSONファイルとして出力します。生成したデータの利用方法1. アプリケーションでのデータ読み込みuse once_cell::sync::Lazy;use serde::{Deserialize, Serialize};use std::collections::HashMap;#[derive(Debug, Serialize, Deserialize)]struct Address {    postcode: String,    prefecture: String,    city: String,    // ... 他のフィールド}static ADDRESS_MAP: Lazy<HashMap<String, Vec<Address>>> = Lazy::new(|| {    let data = include_str!(concat!(env!("OUT_DIR"), "/address_data.json"));    serde_json::from_str(data).expect("Failed to parse address data")});2. 検索機能の実装fn lookup_address(postal_code: &str) -> Option<&Vec<Address>> {    ADDRESS_MAP.get(postal_code)}fn search_by_prefecture(prefecture: &str) -> Vec<&Address> {    ADDRESS_MAP        .values()        .flat_map(|addresses| addresses.iter())        .filter(|addr| addr.prefecture == prefecture)        .collect()}build.rsの主要な機能1. 環境変数の設定// コンパイル時の条件設定println!("cargo:rustc-cfg=feature=\"custom_feature\"");// 環境変数の設定println!("cargo:rustc-env=APP_VERSION=1.0.0");2. リンカ設定// 外部ライブラリのリンクprintln!("cargo:rustc-link-lib=sqlite3");println!("cargo:rustc-link-search=native=/usr/local/lib");3. コードの生成// バージョン情報の生成let version_code = format!(    "pub const VERSION: &str = \"{}\";\n",    env!("CARGO_PKG_VERSION"));fs::write("version.rs", version_code)?;実践的な利用シーン1. 設定ファイルの統合と生成複数の環境向けの設定ファイルを1つに統合する例：use std::collections::HashMap;use serde_json::Value;fn main() {    println!("cargo:rerun-if-changed=config/");        let environments = ["development", "staging", "production"];    let mut merged_config = HashMap::new();        for env in environments {        let config_path = format!("config/{}.json", env);        let config_content = std::fs::read_to_string(&config_path).unwrap();        let config: Value = serde_json::from_str(&config_content).unwrap();                merged_config.insert(env, config);    }        let out_dir = std::env::var("OUT_DIR").unwrap();    let dest_path = Path::new(&out_dir).join("config.rs");        // 設定をRustのコードとして出力    let config_code = format!(        "pub static CONFIG: Lazy<HashMap<&str, Value>> = Lazy::new(|| {{            serde_json::from_str({}).unwrap()        }});",        serde_json::to_string(&merged_config).unwrap()    );        std::fs::write(dest_path, config_code).unwrap();}使用例：// main.rsuse once_cell::sync::Lazy;include!(concat!(env!("OUT_DIR"), "/config.rs"));fn get_database_url(env: &str) -> String {    CONFIG[env]["database"]["url"].as_str().unwrap().to_string()}2. プロトコル定義ファイルの生成Protocol Buffersの定義ファイルからRustコードを生成する例：use std::process::Command;fn main() {    println!("cargo:rerun-if-changed=proto/");        // protoファイルのコンパイル    let status = Command::new("protoc")        .args(&[            "--rust_out=src/generated",            "--proto_path=proto",            "service.proto"        ])        .status()        .unwrap();            if !status.success() {        panic!("Failed to compile proto files");    }        // 生成されたコードをモジュールとして登録    let mod_content = r#"        pub mod generated {            include!("generated/service.rs");        }    "#;        std::fs::write("src/proto_mod.rs", mod_content).unwrap();}使用例：// lib.rsmod proto_mod;use proto_mod::generated::{UserRequest, UserResponse};pub async fn handle_user_request(req: UserRequest) -> UserResponse {    // プロトコル定義に基づいた処理}3. アセットファイルの埋め込み画像やテキストファイルをバイナリに埋め込む例：use std::collections::HashMap;use base64;fn main() {    println!("cargo:rerun-if-changed=assets/");        let mut assets = HashMap::new();        // 画像ファイルの埋め込み    for entry in std::fs::read_dir("assets").unwrap() {        let entry = entry.unwrap();        let path = entry.path();                if path.extension().map_or(false, |ext| ext == "png" || ext == "jpg") {            let content = std::fs::read(&path).unwrap();            let encoded = base64::encode(&content);                        let asset_name = path.file_name().unwrap().to_str().unwrap();            assets.insert(asset_name.to_string(), encoded);        }    }        // アセットデータをRustコードとして出力    let out_dir = std::env::var("OUT_DIR").unwrap();    let dest_path = Path::new(&out_dir).join("assets.rs");        let assets_code = format!(        "pub static ASSETS: Lazy<HashMap<String, String>> = Lazy::new(|| {{            let mut m = HashMap::new();            {}            m        }});",        assets.iter().map(|(k, v)| {            format!("m.insert(\"{}\".to_string(), \"{}\".to_string());", k, v)        }).collect::<Vec<_>>().join("\n")    );        std::fs::write(dest_path, assets_code).unwrap();}使用例：// lib.rsuse once_cell::sync::Lazy;include!(concat!(env!("OUT_DIR"), "/assets.rs"));pub fn get_image_data(name: &str) -> Option<Vec<u8>> {    ASSETS.get(name)        .map(|encoded| base64::decode(encoded).unwrap())}4. データベースマイグレーションファイルの統合SQLマイグレーションファイルを1つのモジュールにまとめる例：fn main() {    println!("cargo:rerun-if-changed=migrations/");        let mut migrations = Vec::new();        // マイグレーションファイルの収集    for entry in std::fs::read_dir("migrations").unwrap() {        let entry = entry.unwrap();        let path = entry.path();                if path.extension().map_or(false, |ext| ext == "sql") {            let version = path.file_stem().unwrap().to_str().unwrap()                .split('_').next().unwrap();            let content = std::fs::read_to_string(&path).unwrap();                        migrations.push((version.to_string(), content));        }    }        // マイグレーションをRustコードとして出力    let migrations_code = format!(        "pub static MIGRATIONS: &[(&str, &str)] = &[{}];",        migrations.iter()            .map(|(ver, sql)| format!("(\"{}\", \"{}\")", ver, sql.replace("\"", "\\\"")))            .collect::<Vec<_>>()            .join(",\n")    );        let out_dir = std::env::var("OUT_DIR").unwrap();    let dest_path = Path::new(&out_dir).join("migrations.rs");    std::fs::write(dest_path, migrations_code).unwrap();}使用例：// database.rsinclude!(concat!(env!("OUT_DIR"), "/migrations.rs"));pub async fn run_migrations(db: &SqlitePool) -> Result<()> {    for (version, sql) in MIGRATIONS {        db.execute(sql).await?;        println!("Applied migration version {}", version);    }    Ok(())}これらの例は、build.rsの実践的な使用方法を示しています。各例で以下のような利点があります。コンパイル時のリソース最適化開発時の利便性向上ランタイムパフォーマンスの改善コードの保守性向上実際のプロジェクトでは、これらの手法を組み合わせたり、プロジェクトの要件に合わせてカスタマイズしたりすることで、より効率的な開発環境を構築できます。しかし、魔環境もしくはビルド地獄を顕現させることもできるので注意が必要だと思いました。参考資料The Cargo Book - Build ScriptsRust By Example - Build Scriptsまとめこのビルドスクリプトの実装例を通じて、build.rsの有用性が明確になりました。コンパイル時のデータ最適化や複数ファイルの統合処理、動的なコード生成、そしてプラットフォーム固有の設定管理など、多岐にわたる機能を提供します。実際のプロジェクトでは、これらの機能を組み合わせることで、効率的な開発環境とビルドプロセスを実現できます。build.rsを活用することで、コンパイル時に必要なリソースの最適化や設定の自動化が可能となり、開発効率の向上とコードの保守性改善に大きく貢献します。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Transformer論文を生成AIで要約してみた]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/12/02/233507</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/12/02/233507</guid>
            <pubDate>Mon, 02 Dec 2024 14:35:07 GMT</pubDate>
            <content:encoded><![CDATA[この記事は生成AI Advent Calendar 2024の3日目の記事です。AIの歴史は60年ほどで、「冬の時代」と呼ばれる停滞期もありましたが、昨今の生成AIの発展は「Transformer」と呼ばれる論文から始まりました。この「Transformer」論文をわかりやすいように生成AIに要約させてみました。arxiv.org「Transformer」論文は上記サイトで見ることができます。論文の正式名称は「Attention Is All You Need」で、現在 v7。右側のAccess Paper:から閲覧することができます。なお、PDFの直リンクはこちらGoogle CloudのVertex AIでGeminiに要約させた結果は以下です。プロンプト「この論文を日本語で高校3年生レベルにもわかるように要約してください。」この論文は、「Transformer」という、機械翻訳などのシーケンス変換タスクに革新をもたらした新しいニューラルネットワークアーキテクチャを提案しています。高校3年生にもわかるように要約すると、以下のようになります。従来の機械翻訳の問題点:従来の機械翻訳は、RNN（再帰型ニューラルネットワーク）という技術を主に使っていました。RNNは文章を単語ごとに順番に処理していくため、長い文章だと処理に時間がかかります。また、並列処理が難しいため、計算速度を上げるのが困難でした。Transformerの革新的な点:Transformerは、「Attention（注意機構）」という仕組みに完全に基づいており、RNNのような順番に処理する仕組みを完全に排除しました。Attention機構は、翻訳したい単語を生成する際に、入力文全体の中でどの単語に注目すべきかを判断する仕組みです。人間の翻訳作業で例えると、翻訳する際に原文の関連する部分に注目するのと同じような働きをします。この仕組みにより、以下の利点が生まれました。並列処理が可能: 単語を順番に処理する必要がないため、並列処理が可能になり、計算速度が大幅に向上しました。長い文章への対応力向上: RNNでは、文章が長くなるほど精度が落ちやすいという問題がありましたが、Attention機構は入力文全体を一度に見ることができるため、長い文章でも高い精度を維持できます。Transformerの成果:Transformerは、従来のモデルよりも高い精度を達成し、さらに学習時間も大幅に短縮しました。具体的には、英語からドイツ語への翻訳と英語からフランス語への翻訳タスクで、当時の最高精度を更新しました。Transformerの仕組みを簡単に説明すると:Transformerは、エンコーダとデコーダという2つの部分から構成されています。エンコーダ: 入力文を解析し、各単語の意味をベクトル表現に変換します。デコーダ: エンコーダの出力とAttention機構を利用して、翻訳文を生成します。エンコーダとデコーダは、それぞれ複数の層が積み重なった構造になっています。各層は、Attention機構と全結合層という2つのサブ層から構成されています。Transformerの今後の展望:Transformerは、テキスト以外のデータ（画像、音声、動画など）にも応用できる可能性があり、様々な分野での活用が期待されています。また、文章生成をより効率的に行うための研究も進められています。簡単に言うと、Transformerは、人間の「注意」の仕組みに似た仕組みを使って、従来よりも高速で高精度な機械翻訳を実現した画期的な技術です。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2025年の崖から考える我々のパーパス（序章）]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/12/01/232229</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/12/01/232229</guid>
            <pubDate>Sun, 01 Dec 2024 14:22:29 GMT</pubDate>
            <content:encoded><![CDATA[はじめにこの記事は3-shake Advent Calendar 2024 シリーズ1の2日目の記事です。1日目はシリーズ1がYutaro ShirayamaさんのポストCloud9？クラウドIDE CoderでPlatform Engineeringを実践する2日目はシリーズ2がYoshinori Teraokaさんのvector で kubernetes の container log を CloudWatch Logs に転送するでした。なお、シリーズ2の2日目はshingo919さんの 九州旅行記（ドライブでの九州一週旅行は大変だった！）です。2025年の崖今回は「2025年の崖」について軽くご紹介したいと思います。いよいよ2025年になりますが、ITでは「2025年の崖」という言葉が存在します。2025年の崖がある中で、スリーシェイクのSreake事業部が果たす役割を考えていきたいと思います。「2025年の崖」をググったら色々出てきますが、経済産業省のレポートが1次情報源的かつわかりやすいでしょう。www.meti.go.jpなお、DXレポート ～ITシステム「2025年の崖」の克服とDXの本格的な展開～（サマリー）はスライド5枚にまとまっており、さっと読みやすいです。「2025年の崖」は要するに何なのかというと、IT人材が不足しており、レガシーシステムを保守するのに限界が来ている。DXも推進しないといけない。何とかしないともう後が無い。という状況。2015年時点で、IT人材の不足が約17万人とされていたところ、2025年には約43万人にまで上ります。既存のレガシーシステムの保守がブラックボックス、属人的になっており、DX化の足枷に → デジタル競争の敗者に技術的負債が溜まる一方保守運用の担い手不足で、サイバーセキュリティ事故が起きやすくこんな厳しい状況を打破するには、ユーザとベンダーそれぞれで対策していく必要があります。ユーザは人材・資金を保守からDXにシフトベンダーも同様に人材・資金を保守からDXにシフトベンダーはAI、アジャイル、マイクロサービス等最新技術を用いたビジネスにシフトやることはわかっていても、そう簡単にはいきません。ただし、スリーシェイクのSreake事業では、内製化支援も行っており、これまで数々の企業様の支援を行ってまいりました。Sreakeという商材は難しく、入社して1年が経った私もストンと腹落ちできる説明ができないままでしたが、「2025年の崖」をどう克服するかが我々のパーパスだと感じました。私は生成AIアプリケーション開発支援というDXを担当しておりますが、案件の推進を通して、「DX推進」を語れるようになっていきたいと思います。今回は、序章のような形で今後も2025年の崖について書いていければと思います。次の3-shake Advent Calendar 2024はシリーズ1がkechigonさんの「Google Cloud monitoringのアラートをGitHub issueに通知する」シリーズ2がtryu___さんの「kubebuilder使ってpodの監視してみた」です。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[vector で kubernetes の container log を CloudWatch Logs に転送する]]></title>
            <link>https://qiita.com/yteraoka/items/df0777cdcb403a7af750</link>
            <guid>https://qiita.com/yteraoka/items/df0777cdcb403a7af750</guid>
            <pubDate>Sun, 01 Dec 2024 12:20:46 GMT</pubDate>
            <content:encoded><![CDATA[Vector とはvector は timber とともに買収され datadog がメンテナンスしているオープンソースプロジェクトのようです。(Datadog acquires Timber T…]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[週間アトデ 2024-12-01]]></title>
            <link>https://blog.atusy.net/2024/12/01/atodeyomanakata/</link>
            <guid>https://blog.atusy.net/2024/12/01/atodeyomanakata/</guid>
            <pubDate>Sun, 01 Dec 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[アトデヨム、ウソジャナイ、ヨムノタノシー]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Geminiのビジネス利用でのメリットを語る]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/11/30/233039</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/11/30/233039</guid>
            <pubDate>Sat, 30 Nov 2024 14:30:39 GMT</pubDate>
            <content:encoded><![CDATA[この記事はGCP(Google Cloud Platform) Advent Calendar 2024 1日目の記事です。2024年はIT業界にとって、最も話題に上がったトピックは生成AIだったのではないでしょうか？2023年までは生成AIと家は、ChatGPTでしたが、2024年はGoogleがBardをリブランディングして、Gemini（ジェミニ）とし、しのぎを削っています。私はGoogle Cloudのパートナー企業である株式会社スリーシェイク Sreake事業部にて、Geminiを用いた生成AIアプリケーション開発に携わっており、Geminiのビジネス利用でのメリットを語りたいと思います。Gemini-1.5-Proは最大200万トークンの読み込みが可能Geminiの強みの中で、最も他の生成AIモデルと差別化できているのが、トークン数の長さです。これにより、動画解析などへの利用もしやすくなりました。Geminiはマルチモーダルなので、音声、画像、動画なども処理可能です。量の目安としては以下になります。書籍15〜20冊程度の分量動画約2時間音声約22時間BigQueryで容易にデータ分析基盤を構築可能他のクラウドには同様のサービスがなく、同じ機能を実現するためには複数のサービスを組み合わせる必要があります。AzureやAWS、オンプレのデータはそのままで読み込みだけ行う機能もあります。今お使いのシステム構成はほぼ変えず、追加構築可能となります。Geminiは他のモデルと比較してトークンあたりの利用料が安いGoogle Cloud上で稼働させるのに最適化しているためです。他社のクラウドで使える生成AIモデルは別会社のものなので、クラウドも生成AIもGoogleのGeminiによって、この点も強みです！もしもGeminiの出力結果が著作権侵害で係争が発生してもGoogle Cloudがサポート他クラウドにはないサービスです。こちらも、クラウドも生成AIも会社が揃っている強みと言えるでしょう。真実性1位！Gemini 1.5 ProがNIKKEI Digital Governanceが調査した真実性のスコアで1位となりました！以下の記事は最初日経で見れていたと思うのですが、今はNIKKEI Digital Governanceに登録しないと見れないようです。博識のGoogle､主観強いMeta　生成AIの｢真実性｣を検証上記画像は下記記事から引用させていただきました。note.com2024年もあと少し。2025年もGeminiとともに生成AIを盛り上げていきたいと思います！GCP(Google Cloud Platform) Advent Calendar 2024 次の記事はknak72さんによる企業のセキュリティ強化に！ Chrome Enterprise Premium のURLフィルタリングとマルウェアスキャン機能です。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[3-shake Advent Calendar 2024 やっていきます #3SHAKE]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/11/30/142710</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/11/30/142710</guid>
            <pubDate>Sat, 30 Nov 2024 05:27:10 GMT</pubDate>
            <content:encoded><![CDATA[こんにちは、nwiizoです。晩秋の肌寒さが身にしみるこの11月も今日で終わりですね。ついこの前、昨年のAdvent Calendarで記事埋めを依頼され、慌ただしく準備した記憶が鮮明です。まったく、時の流れとは不思議なものです。今年もスリーシェイクのAdvent Calendarを開催することができます。この企画が実現したのは、ひとえに社内の方々の温かいご協力の賜物であり、その事実に深い感謝の念を抱いております。qiita.comスリーシェイクは「インフラをシンプルにしてイノベーションを起こす」というビジョンのもと、クラウド、セキュリティ、データ連携、HR領域で4つのサービスを展開しているテクノロジーカンパニーです。3-shake.com先日、シリーズB追加ラウンドとしてNTTデータ、SCSKから10億円の資金調達を実施し、資本業務提携を締結するニュースが出るなど、着実に成長を続けています。prtimes.jp今年のAdvent Calendarでも、エンジニアの技術的な記事だけでなく、スリーシェイクで働く様々な職種のメンバーによる記事をお届けする予定です。エンジニア以外にも営業、カスタマーサクセス、広報、経営企画など、多様なバックグラウンドを持つメンバーたちが、それぞれの視点からスリーシェイクでの経験や日々の発見を共有していきます。なぜ技術的な記事に限定しないのか。それは、私たちが目指すイノベーションには、技術だけでなく、様々な専門性や視点が必要だと考えているからです。このAdvent Calendarを通じて、スリーシェイクがどのような会社で、どんな人たちが働いているのか、より深く知っていただければ幸いです。記事の更新情報は、スリーシェイクの公式Xアカウント（@3shake_Inc）でお知らせしていきますので、ぜひフォローをお願いします！また、Advent Calendarも合わせてチェックしていただければと思います。成長を続けるスリーシェイクの「今」を知るきっかけとして、どうぞお楽しみください！jobs-3-shake.com]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイク、Google Cloud Japan の「 Google Cloud Partner Top Engineer 2025 」にて3名のエンジニアが受賞]]></title>
            <link>https://sreake.com/blog/%e3%82%b9%e3%83%aa%e3%83%bc%e3%82%b7%e3%82%a7%e3%82%a4%e3%82%af%e3%80%81google-cloud-japan-%e3%81%ae%e3%80%8c-google-cloud-partner-top-engineer-2025-%e3%80%8d%e3%81%ab%e3%81%a63%e5%90%8d%e3%81%ae/</link>
            <guid>https://sreake.com/blog/%e3%82%b9%e3%83%aa%e3%83%bc%e3%82%b7%e3%82%a7%e3%82%a4%e3%82%af%e3%80%81google-cloud-japan-%e3%81%ae%e3%80%8c-google-cloud-partner-top-engineer-2025-%e3%80%8d%e3%81%ab%e3%81%a63%e5%90%8d%e3%81%ae/</guid>
            <pubDate>Thu, 28 Nov 2024 06:03:47 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）のエンジニア3名が、Google Cloud Japan が高い技術力を持ったエンジニアを表彰するプログラムである「 Google Cloud Partner Top Engineer 2025 」に選出されたことをお知らせします。The post スリーシェイク、Google Cloud Japan の「 Google Cloud Partner Top Engineer 2025 」にて3名のエンジニアが受賞 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[3-shake における組織的な Google Cloud Partner Top Engineer 推進について]]></title>
            <link>https://sreake.com/blog/google-cloud-partner-top-engineer-2025/</link>
            <guid>https://sreake.com/blog/google-cloud-partner-top-engineer-2025/</guid>
            <pubDate>Thu, 28 Nov 2024 06:00:00 GMT</pubDate>
            <content:encoded><![CDATA[はじめに 3-shakeで、Engineering Team Lead / SRE をやっている横尾（@866mfs）です 今回、3-shake では、佐藤 慧太(@SatohJohn), 横尾 杏之介(@866mfs) […]The post 3-shake における組織的な Google Cloud Partner Top Engineer 推進について first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コミュニティ紹介: Kubernetes Meetup Novice]]></title>
            <link>https://speakerdeck.com/bells17/komiyuniteishao-jie-kubernetes-meetup-novice</link>
            <guid>https://speakerdeck.com/bells17/komiyuniteishao-jie-kubernetes-meetup-novice</guid>
            <pubDate>Thu, 28 Nov 2024 05:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Cloud Native Days Winter 2024のCommunity & Beginner LTでお話した資料です。https://pfem.notion.site/CNDW2024-Community-Beginner-LT-13821b0141e0800cb403c880cb4d2738]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[メインテーマはKubernetes]]></title>
            <link>https://speakerdeck.com/nwiizo/meintemahakubernetes</link>
            <guid>https://speakerdeck.com/nwiizo/meintemahakubernetes</guid>
            <pubDate>Thu, 28 Nov 2024 05:00:00 GMT</pubDate>
            <content:encoded><![CDATA[2024年16:20-17:00（Track A）にて「メインテーマはKubernetes」というタイトルで登壇します。セッションURL:https://event.cloudnativedays.jp/cndw2024/talks/2373公式URL:https://event.cloudnativedays.jp/cndw2024/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[KubeCon + Cloud NativeCon North America 参加レポート]]></title>
            <link>https://sreake.com/blog/kubecon-cloud-nativecon-north-america-2024-report/</link>
            <guid>https://sreake.com/blog/kubecon-cloud-nativecon-north-america-2024-report/</guid>
            <pubDate>Wed, 27 Nov 2024 00:28:01 GMT</pubDate>
            <content:encoded><![CDATA[はじめに こんにちは！3-shak inc, で SRE をやっている横尾(@866mfs)です。 2024/11/12 ~ 2024/11/15 に開催された、 KubeCon + CloudNativeCo […]The post KubeCon + Cloud NativeCon North America 参加レポート first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[mini.aiで日本語の括弧の中身をrepeatableに編集する]]></title>
            <link>https://blog.atusy.net/2024/11/27/mini-ai-ja/</link>
            <guid>https://blog.atusy.net/2024/11/27/mini-ai-ja/</guid>
            <pubDate>Wed, 27 Nov 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[mini.aiとremapをうまく活用するとaj[で「foo」のような日本語の括弧に対して発動するテキストオブジェクトをdot-repeatableに実装できることに気付きました。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Neovimのイベントタイミングガイド]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/11/27/023303</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/11/27/023303</guid>
            <pubDate>Tue, 26 Nov 2024 17:33:03 GMT</pubDate>
            <content:encoded><![CDATA[はじめにNeovimでの設定やプラグイン開発において、適切なタイミングでコードを実行することは非常に重要です。このガイドでは、Neovimの主要なイベントについて、実用的な例を交えながら解説します。1. 起動時のイベント系統Neovimの起動プロセスで最も重要なイベントはVimEnterです。これは全ての初期化処理（vimrcの読み込み、プラグインの初期化など）が完了した後に発火します：vim.api.nvim_create_autocmd("VimEnter", {  callback = function()    -- プラグインの初期化    -- カラースキームの設定    -- ステータスラインの設定など  end,})2. バッファ操作のイベント系統バッファの作成から読み込みまでの主要なイベント：BufNew: バッファ作成直後BufAdd: バッファリストへの追加時BufReadPre: ファイル読み込み前BufReadPost: ファイル読み込み後BufEnter: バッファアクティブ化時vim.api.nvim_create_autocmd("BufReadPost", {  pattern = "*",  callback = function()    -- ファイル読み込み後の処理    -- 最後のカーソル位置の復元など  end,})3. 編集モードのイベント系統テキスト編集に関連する主要なイベント：InsertEnter: 挿入モード開始時TextChangedI: 挿入モードでテキスト変更時InsertLeave: 挿入モード終了時TextChanged: ノーマルモードでテキスト変更時vim.api.nvim_create_autocmd("InsertEnter", {  pattern = "*",  callback = function()    -- 挿入モード開始時の設定    -- 相対行番号の無効化など  end,})4. ファイル保存のイベント系統ファイル保存時の処理フロー：BufWritePre: 保存前BufWrite: 保存処理中BufWritePost: 保存後vim.api.nvim_create_autocmd("BufWritePre", {  pattern = "*",  callback = function()    -- 保存前の自動整形    -- 末尾の空白除去など  end,})5. 終了時のイベント系統Neovim終了時の処理順序：QuitPre: 終了コマンド実行時VimLeavePre: 終了処理開始前VimLeave: 最終終了処理時vim.api.nvim_create_autocmd("VimLeavePre", {  callback = function()    -- セッション保存    -- 未保存バッファの保存など  end,})実践的なサンプルコード以下は、よくある設定パターンの例です：-- ファイルタイプ別の設定vim.api.nvim_create_autocmd("FileType", {  pattern = {"python", "lua", "rust"},  callback = function()    local settings = {      python = { indent = 4, expandtab = true },      lua = { indent = 2, expandtab = true },      rust = { indent = 4, expandtab = true }    }    local ft = vim.bo.filetype    if settings[ft] then      vim.bo.shiftwidth = settings[ft].indent      vim.bo.expandtab = settings[ft].expandtab    end  end,})-- 自動保存の設定vim.api.nvim_create_autocmd({"InsertLeave", "TextChanged"}, {  pattern = "*",  callback = function()    if vim.bo.modified and vim.bo.buftype == "" then      vim.cmd("silent! write")    end  end,})-- 最後のカーソル位置を復元vim.api.nvim_create_autocmd("BufReadPost", {  pattern = "*",  callback = function()    local last_pos = vim.fn.line("'\"")    if last_pos > 0 and last_pos <= vim.fn.line("$") then      vim.cmd('normal! g`"')    end  end,})注意点イベントは適切な順序で処理される必要があります重い処理は非同期で行うことを推奨しますパターンマッチングを活用して、必要なファイルタイプのみで実行するようにしますvim.schedule()を使用して、UIブロッキングを避けます参考文献Neovim オートコマンドドキュメントAutocmd | 5. eventsNeovim Lua API リファレンスnvim_create_autocmd())]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rustでterraform plan/apply のターゲット指定を簡単にするツールを作ってみた - tfocusの仕組みと使い方]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/11/27/004309</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/11/27/004309</guid>
            <pubDate>Tue, 26 Nov 2024 15:43:09 GMT</pubDate>
            <content:encoded><![CDATA[1. はじめにこんにちは、nwiizoです。本記事では、Terraformで特定のリソースだけをplan/applyするためのインタラクティブCLIツール「tfocus」の設計と実装について、Rustの学習という観点も交えながら詳しく解説していきます。github.comまた、良さそうであればGithub Starsをいただきたいです。2. 背景と動機2.1 開発の契機大規模なTerraformコードベースでの作業において、様々な課題に直面することがあります。本番環境で特定リソースにトラブルが発生した際の調査や、開発中の変更を検証する場合、また大規模な変更を段階的に適用する必要がある場合などが典型的な例です。従来のTerraform CLIでも-targetオプションでリソースを指定できますが、正確なリソースパスを記述する必要があり、緊急時の運用には適していません。特に本番環境でのインシデント対応時には、迅速かつ正確なリソース指定が求められます。developer.hashicorp.com2.2 解決したい問題ツールの開発にあたり、複数の課題解決を目指しています。まずリソース選択を直感的に行えるようにすることで、運用者の負担を軽減します。同時に操作ミスを未然に防ぐ仕組みを導入し、安全性を確保します。また、緊急時にも迅速な対応ができるインターフェースを実現し、効率的なデバッグ作業を可能にすることで、運用効率の向上を図ります。3. 技術スタックの選定3.1 Rustを選んだ理由Rustを採用した理由は複数あります。まず、ゼロコスト抽象化による高いパフォーマンスを実現できることが挙げられます。また、強力な型システムと所有権モデルにより、メモリ安全性を確保できます。さらに、様々なOS向けにネイティブバイナリを生成できるクロスプラットフォーム対応も重要な選定理由となりました。豊富なクレートが利用可能な充実したエコシステムも、開発効率を高める要因となっています。最後に、純粋な学習目的として、小規模なツール開発を通じてRustの理解を深めることも目指しています。何かを引用するために書籍を貼ったが何を引用したいか忘れてしまった(がぎりぎりでこのブログを書いている為に調べることができない)。達人プログラマー ―熟達に向けたあなたの旅― 第2版作者:David Thomas,Andrew Huntオーム社Amazon3.2 主要な依存クレート[dependencies]walkdir = "2.3"      # ファイルシステム走査regex = "1.5"        # パターンマッチングclap = "4.4"         # CLIパーサーthiserror = "1.0"    # エラー型colored = "2.0"      # カラー出力crossterm = "0.27"   # TUIfuzzy-matcher = "0.3" # あいまい検索doc.rust-lang.org各クレートの選定理由：walkdir: 効率的な再帰的ファイル走査を提供regex: 高速で柔軟なパターンマッチングが可能clap: 型安全なCLI引数パーサーthiserror: エラー型の簡潔な定義crossterm: プラットフォーム独立なTUI実装fuzzy-matcher: 使いやすいあいまい検索機能4. 実装の詳細4.1 アーキテクチャ設計プロジェクトは機能ごとに明確に分離された以下のモジュール構成を採用しています：src/├── cli.rs        # CLIインターフェース├── display.rs    # 表示処理├── error.rs      # エラー型├── executor.rs   # Terraform実行├── input.rs      # 入力処理├── main.rs       # エントリーポイント├── project.rs    # プロジェクト解析├── selector.rs   # リソース選択UI└── types.rs      # 共通型定義各モジュールの責務：cli.rs: コマンドライン引数の定義と解析#[derive(Parser)]#[command(author, version, about)]pub struct Cli {    /// Terraformディレクトリのパス    #[arg(short, long, default_value = ".")]    pub path: PathBuf,    /// 実行する操作    #[arg(short, long)]    pub operation: Option<Operation>,    /// 詳細出力の有効化    #[arg(short, long)]    pub verbose: bool,}project.rs: Terraformファイルの解析impl TerraformProject {    pub fn parse_directory(path: &Path) -> Result<Self> {        let mut project = TerraformProject::new();        for file_path in Self::find_terraform_files(path)? {            project.parse_file(&file_path)?;        }        Ok(project)    }    fn parse_file(&mut self, path: &Path) -> Result<()> {        let content = fs::read_to_string(path)?;        self.parse_resources(&content, path)?;        self.parse_modules(&content, path)?;        Ok(())    }}4.2 エラーハンドリング型安全なエラーハンドリングを実現するため、カスタムエラー型を定義：#[derive(Error, Debug)]pub enum TfocusError {    #[error("IO error: {0}")]    Io(#[from] std::io::Error),    #[error("Failed to parse terraform file: {0}")]    ParseError(String),    #[error("Invalid target selection")]    InvalidTargetSelection,    #[error("Terraform command failed: {0}")]    TerraformError(String),    #[error("No terraform files found")]    NoTerraformFiles,}4.3 リソース選択UIの実装fuzzy検索を活用した効率的なリソース選択：impl Selector {    fn filter_items(&mut self) {        let query = self.query.to_lowercase();        let mut matches: Vec<(usize, i64)> = self            .items            .iter()            .enumerate()            .filter_map(|(index, item)| {                self.matcher                    .fuzzy_match(&item.search_text.to_lowercase(), &query)                    .map(|score| (index, score))            })            .collect();                // スコアでソート        matches.sort_by_key(|&(_, score)| -score);        self.filtered_items = matches.into_iter()            .map(|(index, _)| index)            .collect();    }    fn render_screen(&mut self) -> Result<()> {        let mut stdout = stdout();        execute!(            stdout,            terminal::Clear(ClearType::All),            cursor::MoveTo(0, 0)        )?;                self.render_search_box()?;        self.render_items()?;        self.render_status_line()?;                stdout.flush()?;        Ok(())    }}4.4 パフォーマンス最適化実行速度とメモリ使用量の最適化：[profile.release]opt-level = 3        # 最高レベルの最適化lto = true          # リンク時最適化codegen-units = 1   # 単一コード生成ユニットstrip = true        # バイナリサイズ削減5. Rustから学ぶシステム設計tfocusの実装を通じて学べるRustの重要概念プログラミングRust 第2版作者:Jim Blandy,Jason Orendorff,Leonora F. S. TindallオライリージャパンAmazon5.1 所有権とライフタイムリソースの効率的な管理：impl Resource {    pub fn full_name(&self) -> String {        if self.is_module {            format!("module.{}", self.name)        } else {            format!("{}.{}", self.resource_type, self.name)        }    }}5.2 エラー伝播?演算子を使用した簡潔なエラーハンドリング：pub fn execute_terraform_command(    operation: &Operation,    target_options: &[String],) -> Result<()> {    let mut command = Command::new("terraform");    command.arg(operation.to_string());        for target in target_options {        command.arg(target);    }        let status = command.spawn()?.wait()?;        if status.success() {        Ok(())    } else {        Err(TfocusError::TerraformError(            "Command execution failed".to_string()        ))    }}5.3 トレイトの活用共通インターフェースの定義：pub trait Display {    fn render(&self) -> Result<()>;    fn update(&mut self) -> Result<()>;}6. まとめ6.1 現在の成果このプロジェクトは現在、直感的なリソース選択UIを実現し、クロスプラットフォームでの利用を可能にしています。また、効率的なメモリ使用を実現するとともに、型安全なエラーハンドリングを導入することで、安定性の向上にも成功しています。6.2 今後の展開使われるようになったらやっていきたいこと。機能拡張の面では、依存関係の可視化機能を導入し、リソース状態をより詳細に表示できるようにしたいと考えています。さらに、バッチ処理のサポートを追加することで、大規模な処理にも対応できるようにしていきます。品質向上については、テストカバレッジを拡大し、システム全体のパフォーマンスを最適化していく予定です。また、エラーメッセージをより分かりやすく改善することで、ユーザー体験の向上を図ります。ドキュメント整備においては、API文書を充実させ、初心者向けのチュートリアルを作成していきます。さらに、実際の使用シーンを想定したユースケース集を整備することで、ユーザーの理解促進を支援していきたいと考えています。おわりにtfocusの開発を通じて、RustとTerraformの実践的な活用方法を示しました。このツールが皆様のインフラ運用の一助となれば幸いです。コードはGitHubで公開しています：nwiizo/tfocusフィードバックやコントリビューションをお待ちしています。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[RustでJSONを扱いたいのでSerde入門します]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/11/26/141035</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/11/26/141035</guid>
            <pubDate>Tue, 26 Nov 2024 05:10:35 GMT</pubDate>
            <content:encoded><![CDATA[はじめにRustでデータのシリアライズ/デシリアライズを扱う際、最も広く使われているのがserdeクレートです。特にWeb APIやファイル入出力でよく使用されるJSONとの相互変換において、非常に重宝するツールです。今回は、serdeの基本的な使い方と、開発効率を上げるためのツールについて解説します。SerdeとはSerdeは"Serialize"と"Deserialize"を組み合わせた造語で、データ構造の変換を担当するRustのフレームワークです。多様なデータフォーマットに対応（JSON、YAML(アーカイブされている)、TOML等）高性能で型安全な実装カスタマイズ可能な属性システムコード生成による簡単な実装docs.rsプロジェクトのセットアップまず、Cargo.tomlに必要な依存関係を追加します。[dependencies]serde = { version = "1.0", features = ["derive"] }serde_json = "1.0"基本的な使い方1. 構造体の定義use serde::{Serialize, Deserialize};#[derive(Serialize, Deserialize, Debug)]struct User {    name: String,    age: u32,    email: String,    is_active: bool,}2. JSONからRustへの変換（デシリアライズ）fn main() {    let json_str = r#"    {        "name": "John Doe",        "age": 30,        "email": "john@example.com",        "is_active": true    }    "#;    let user: User = serde_json::from_str(json_str).unwrap();    println!("Deserialized user: {:?}", user);}3. RustからJSONへの変換（シリアライズ）fn main() {    let user = User {        name: "Jane Doe".to_string(),        age: 25,        email: "jane@example.com".to_string(),        is_active: true,    };    let json = serde_json::to_string_pretty(&user).unwrap();    println!("Serialized JSON:\n{}", json);}JSON to Rust ツールの活用開発効率を大幅に向上させるツールとして、「JSON to Rust」があります。このツールは、JSONデータからRustの構造体定義を自動生成してくれます。JSON to Rustの使い方https://jsonformatter.org/json-to-rust にアクセス左側のペインにJSONデータを貼り付け自動的に右側にRustの構造体定義が生成される例えば、以下のようなJSONデータがあった場合{    "user_profile": {        "id": 123,        "username": "rust_lover",        "settings": {            "theme": "dark",            "notifications": true        },        "tags": ["rust", "programming"]    }}以下のようなRust構造体が生成されます。// Example code that deserializes and serializes the model.// extern crate serde;// #[macro_use]// extern crate serde_derive;// extern crate serde_json;//// use generated_module::[object Object];//// fn main() {//     let json = r#"{"answer": 42}"#;//     let model: [object Object] = serde_json::from_str(&json).unwrap();// }extern crate serde_derive;#[derive(Serialize, Deserialize)]pub struct Welcome3 {    #[serde(rename = "user_profile")]    user_profile: UserProfile,}#[derive(Serialize, Deserialize)]pub struct UserProfile {    #[serde(rename = "id")]    id: i64,    #[serde(rename = "username")]    username: String,    #[serde(rename = "settings")]    settings: Settings,    #[serde(rename = "tags")]    tags: Vec<String>,}#[derive(Serialize, Deserialize)]pub struct Settings {    #[serde(rename = "theme")]    theme: String,    #[serde(rename = "notifications")]    notifications: bool,}高度な使い方カスタム属性の活用Serdeは様々な属性を提供して、シリアライズ/デシリアライズの挙動をカスタマイズできます。#[derive(Serialize, Deserialize, Debug)]struct Configuration {    #[serde(rename = "apiKey")]    api_key: String,        #[serde(default)]    timeout_seconds: u32,        #[serde(skip_serializing_if = "Option::is_none")]    optional_field: Option<String>,}エラーハンドリング実際のアプリケーションでは、適切なエラーハンドリングが重要です。use serde::{Serialize, Deserialize};use std::error::Error;use std::fs;use std::io;use std::collections::HashMap;// ユーザーの基本構造体#[derive(Serialize, Deserialize, Debug)]struct User {    id: u32,    name: String,    age: u32,    email: String,    is_active: bool,    // オプショナルなフィールド    #[serde(skip_serializing_if = "Option::is_none")]    metadata: Option<HashMap<String, String>>,}// カスタムエラー型の定義#[derive(Debug)]enum UserError {    ParseError(serde_json::Error),    // JSONパースエラー    ValidationError(String),          // バリデーションエラー    DatabaseError(String),            // DB操作エラー    IoError(io::Error),              // ファイル操作エラー}// serde_json::ErrorからUserErrorへの変換を実装impl From<serde_json::Error> for UserError {    fn from(err: serde_json::Error) -> UserError {        UserError::ParseError(err)    }}// io::ErrorからUserErrorへの変換を実装impl From<io::Error> for UserError {    fn from(err: io::Error) -> UserError {        UserError::IoError(err)    }}// std::error::Errorトレイトの実装impl std::fmt::Display for UserError {    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {        match self {            UserError::ParseError(e) => write!(f, "Parse error: {}", e),            UserError::ValidationError(msg) => write!(f, "Validation error: {}", msg),            UserError::DatabaseError(msg) => write!(f, "Database error: {}", msg),            UserError::IoError(e) => write!(f, "IO error: {}", e),        }    }}impl Error for UserError {}// Userの実装impl User {    // バリデーションメソッド    fn validate(&self) -> Result<(), UserError> {        if self.name.is_empty() {            return Err(UserError::ValidationError("Name cannot be empty".to_string()));        }        if self.age > 150 {            return Err(UserError::ValidationError("Invalid age".to_string()));        }        if !self.email.contains('@') {            return Err(UserError::ValidationError("Invalid email format".to_string()));        }        Ok(())    }}// 基本的なJSONパース関数fn parse_user(json_str: &str) -> Result<User, serde_json::Error> {    // map_errを使用してエラーをログ出力    serde_json::from_str(json_str).map_err(|e| {        println!("Error parsing JSON: {}", e);        e  // 元のエラーを返す    })}// より詳細なエラーハンドリングを行う関数fn process_user_data(json_str: &str) -> Result<User, UserError> {    // JSONのパース    let user: User = serde_json::from_str(json_str)?;  // ?演算子でエラーを伝播        // バリデーション    user.validate()?;  // ?演算子でエラーを伝播        Ok(user)}// 複数ユーザーからの検索（Option型との組み合わせ）fn find_user_by_id(json_str: &str, target_id: u32) -> Result<Option<User>, UserError> {    // JSONから複数ユーザーをパース    let users: Vec<User> = serde_json::from_str(json_str)?;        // 指定されたIDのユーザーを探す    Ok(users.into_iter().find(|user| user.id == target_id))}// ファイル操作を含むエラーハンドリングfn load_user_from_file(path: &str) -> Result<User, UserError> {    // ファイルを読み込み    let content = fs::read_to_string(path).map_err(|e| {        eprintln!("Failed to read file {}: {}", path, e);        UserError::IoError(e)    })?;    // JSONをパースしてUserを返す    process_user_data(&content)}// ファイルへの保存fn save_user_to_file(user: &User, path: &str) -> Result<(), UserError> {    // UserをJSONに変換    let json = serde_json::to_string_pretty(user).map_err(|e| {        eprintln!("Failed to serialize user: {}", e);        UserError::ParseError(e)    })?;    // ファイルに書き込み    fs::write(path, json).map_err(|e| {        eprintln!("Failed to write to file {}: {}", path, e);        UserError::IoError(e)    })?;    Ok(())}fn main() {    // 1. 有効なJSONの例    let valid_json = r#"        {            "id": 1,            "name": "John Doe",            "age": 30,            "email": "john@example.com",            "is_active": true,            "metadata": {                "last_login": "2024-01-01",                "location": "Tokyo"            }        }    "#;    // 2. 無効なJSONの例（バリデーションエラー）    let invalid_json = r#"        {            "id": 2,            "name": "",            "age": 200,            "email": "invalid-email",            "is_active": true        }    "#;    // 3. 複数ユーザーのJSONの例    let users_json = r#"[        {            "id": 1,            "name": "John Doe",            "age": 30,            "email": "john@example.com",            "is_active": true        },        {            "id": 2,            "name": "Jane Doe",            "age": 25,            "email": "jane@example.com",            "is_active": true        }    ]"#;    // 4. 各種エラーハンドリングの実演    println!("1. 基本的なパース:");    match parse_user(valid_json) {        Ok(user) => println!("成功: {:?}", user),        Err(e) => println!("エラー: {}", e),    }    println!("\n2. バリデーション付きパース:");    match process_user_data(invalid_json) {        Ok(user) => println!("成功: {:?}", user),        Err(e) => println!("エラー: {}", e),    }    println!("\n3. ユーザー検索:");    match find_user_by_id(users_json, 1) {        Ok(Some(user)) => println!("ユーザーが見つかりました: {:?}", user),        Ok(None) => println!("ユーザーが見つかりません"),        Err(e) => println!("エラー: {}", e),    }    println!("\n4. ファイル操作:");    // 有効なユーザーをファイルに保存    if let Ok(user) = parse_user(valid_json) {        match save_user_to_file(&user, "user.json") {            Ok(()) => println!("ユーザーを保存しました"),            Err(e) => println!("保存エラー: {}", e),        }        // 保存したファイルから読み込み        match load_user_from_file("user.json") {            Ok(loaded_user) => println!("ロードしたユーザー: {:?}", loaded_user),            Err(e) => println!("ロードエラー: {}", e),        }    }}ベストプラクティス型の使い分け必須フィールドは通常の型オプショナルフィールドはOption<T>配列はVec<T>を使用エラーハンドリングunwrap()は開発時のみ使用本番コードではResultを適切に処理カスタム属性の活用#[serde(rename)]でフィールド名の変換#[serde(default)]でデフォルト値の設定#[serde(skip_serializing_if)]で条件付きスキップまず、Cargo.tomlにchronoの依存関係を追加します。use chrono;use serde::{Deserialize, Serialize};use std::collections::HashMap;use std::error::Error as StdError;use std::fmt;use std::fs; // chronoクレートのインポート// ベストプラクティスに基づいた構造体の定義#[derive(Serialize, Deserialize, Debug)]struct UserProfile {    // 1. 必須フィールド（通常の型）    id: u64,    username: String,    email: String,    // 2. オプショナルフィールド（Option<T>の使用）    #[serde(skip_serializing_if = "Option::is_none")]    phone_number: Option<String>,    #[serde(skip_serializing_if = "Option::is_none")]    biography: Option<String>,    // 3. 配列（Vec<T>の使用）    #[serde(skip_serializing_if = "Vec::is_empty")]    interests: Vec<String>,    // 4. カスタム属性の活用    // JSONでは"lastLoginTime"として表示    #[serde(rename = "lastLoginTime")]    last_login_time: String,    // デフォルト値の設定    #[serde(default)]    is_active: bool,    // 動的なキーバリューペア    #[serde(default, skip_serializing_if = "HashMap::is_empty")]    metadata: HashMap<String, String>,}// カスタムエラー型の定義#[derive(Debug)]enum ProfileError {    JsonError(serde_json::Error),    ValidationError(String),    IoError(std::io::Error),}// ProfileErrorにDisplayトレイトを実装impl fmt::Display for ProfileError {    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {        match self {            ProfileError::JsonError(e) => write!(f, "JSON error: {}", e),            ProfileError::ValidationError(e) => write!(f, "Validation error: {}", e),            ProfileError::IoError(e) => write!(f, "IO error: {}", e),        }    }}// ProfileErrorにErrorトレイトを実装impl StdError for ProfileError {    fn source(&self) -> Option<&(dyn StdError + 'static)> {        match self {            ProfileError::JsonError(e) => Some(e),            ProfileError::ValidationError(_) => None,            ProfileError::IoError(e) => Some(e),        }    }}// エラー変換の実装impl From<serde_json::Error> for ProfileError {    fn from(err: serde_json::Error) -> Self {        ProfileError::JsonError(err)    }}impl From<std::io::Error> for ProfileError {    fn from(err: std::io::Error) -> Self {        ProfileError::IoError(err)    }}// UserProfileの実装impl UserProfile {    // コンストラクタ    fn new(id: u64, username: String, email: String) -> Self {        UserProfile {            id,            username,            email,            phone_number: None,            biography: None,            interests: Vec::new(),            last_login_time: chrono::Utc::now().to_rfc3339(),            is_active: true,            metadata: HashMap::new(),        }    }    // バリデーション    fn validate(&self) -> Result<(), ProfileError> {        if self.username.is_empty() {            return Err(ProfileError::ValidationError(                "Username cannot be empty".to_string(),            ));        }        if !self.email.contains('@') {            return Err(ProfileError::ValidationError(                "Invalid email format".to_string(),            ));        }        Ok(())    }    // メタデータの追加    fn add_metadata(&mut self, key: &str, value: &str) {        self.metadata.insert(key.to_string(), value.to_string());    }    // 興味・関心の追加    fn add_interest(&mut self, interest: &str) {        self.interests.push(interest.to_string());    }}// プロファイル処理関数fn process_profile(json_str: &str) -> Result<UserProfile, ProfileError> {    // JSONからプロファイルを作成    let profile: UserProfile = serde_json::from_str(json_str)?;    // バリデーション    profile.validate()?;    Ok(profile)}// ファイル操作を含むプロファイル保存fn save_profile(profile: &UserProfile, path: &str) -> Result<(), ProfileError> {    // バリデーション    profile.validate()?;    // JSON文字列に変換（整形付き）    let json = serde_json::to_string_pretty(profile)?;    // ファイルに保存    fs::write(path, json)?;    Ok(())}fn main() -> Result<(), Box<dyn StdError>> {    // 1. プロファイルの作成    let mut profile = UserProfile::new(1, "john_doe".to_string(), "john@example.com".to_string());    // オプショナルフィールドの設定    profile.phone_number = Some("123-456-7890".to_string());    profile.biography = Some("Tech enthusiast and developer".to_string());    // 興味・関心の追加    profile.add_interest("Programming");    profile.add_interest("Open Source");    // メタデータの追加    profile.add_metadata("location", "Tokyo");    profile.add_metadata("timezone", "UTC+9");    // 2. JSONへの変換と保存    println!("保存するプロファイル:");    println!("{:#?}", profile);    save_profile(&profile, "profile.json").map_err(|e| Box::new(e) as Box<dyn StdError>)?;    println!("\nプロファイルを保存しました");    // 3. JSONからの読み込みとバリデーション    let json_str = r#"{        "id": 2,        "username": "jane_doe",        "email": "jane@example.com",        "phone_number": "098-765-4321",        "biography": "Software Engineer",        "interests": ["AI", "Machine Learning"],        "lastLoginTime": "2024-01-01T00:00:00Z",        "metadata": {            "location": "Osaka",            "language": "ja"        }    }"#;    match process_profile(json_str) {        Ok(loaded_profile) => {            println!("\n読み込んだプロファイル:");            println!("{:#?}", loaded_profile);        }        Err(e) => match e {            ProfileError::JsonError(e) => println!("JSONエラー: {}", e),            ProfileError::ValidationError(e) => println!("バリデーションエラー: {}", e),            ProfileError::IoError(e) => println!("I/Oエラー: {}", e),        },    }    // 4. 無効なデータの例    let invalid_json = r#"{        "id": 3,        "username": "",        "email": "invalid-email"    }"#;    match process_profile(invalid_json) {        Ok(_) => println!("予期せぬ成功"),        Err(e) => match e {            ProfileError::ValidationError(msg) => {                println!("\nバリデーションエラー（期待通り）: {}", msg)            }            _ => println!("予期せぬエラー"),        },    }    Ok(())}まとめSerdeは、RustでJSONを扱う際の強力なツールです。JSON to Rustのようなツールと組み合わせることで、より効率的な開発が可能になります。基本的な使い方を押さえた上で、プロジェクトの要件に応じて高度な機能を活用していくことをお勧めします。参考リンクSerde公式ドキュメントJSON to Rust Converterserde_json クレートドキュメント]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[社内活動の取り組み紹介~ スリーシェイクでこんな取り組みしてます ~]]></title>
            <link>https://speakerdeck.com/bells17/she-nei-huo-dong-noqu-rizu-mishao-jie-surisieikudekonnaqu-rizu-misitemasu</link>
            <guid>https://speakerdeck.com/bells17/she-nei-huo-dong-noqu-rizu-mishao-jie-surisieikudekonnaqu-rizu-misitemasu</guid>
            <pubDate>Tue, 26 Nov 2024 05:00:00 GMT</pubDate>
            <content:encoded><![CDATA[CloudNative Days Winter 2024 船上LT会 小さな一歩、大きな飛躍〜クラウドネイティブを継続する〜 で発表したLT資料です。https://cloudnativedays.connpass.com/event/334620/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[【ISUCON14対策】private-isuチャレンジ記]]></title>
            <link>https://zenn.dev/melanmeg/articles/a8ece09570279f</link>
            <guid>https://zenn.dev/melanmeg/articles/a8ece09570279f</guid>
            <pubDate>Mon, 25 Nov 2024 09:01:34 GMT</pubDate>
            <content:encoded><![CDATA[はじめに2024/12/8(日)に開催のISUCON14へ向けて練習した記録です。お題は private-isu と呼ばれるISUCON練習問題の中でも、特にメジャーなものを解くことにしました。結論として、最終スコアは44,2852点でした。ここに辿り着く道のりは険しかったです💦練習リポジトリ：https://github.com/melanmeg/private-isu-challengeまた、パフォーマンス改善タスクを求められる現場の方々にも、実際に役立つテクニックも恐らくあるはずで、興味のある方、色んな方に読んでいただけると嬉しいです。改善したことだけ知りたい方...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[私の為のNvChadのキーマッピングガイド]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/11/24/171651</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/11/24/171651</guid>
            <pubDate>Sun, 24 Nov 2024 08:16:51 GMT</pubDate>
            <content:encoded><![CDATA[はじめに私は定期的に必要なことを忘れてしまう。子ども時代に水を口に入れて水の飲み方を忘れてしまったことがある。大切なことを今まで普通にできたことが急にできなくなることがある。学習もそう、定期的に復習して思い出すことが大切だと感じているが突然忘れてしまうことがある。突然忘れてしまうと探す必要があるが毎回探すのが面倒になってきたのでNvChadのキーマッピングをまとめてみた。基本的なショートカット表記<C> = Ctrlキー<leader> = スペースキー（デフォルト）<A> = Altキー<S> = Shiftキーよく使う機能とそのキーマッピング1. ファイル操作で必須のコマンド<C-s>    - 保存（これだけは絶対覚える。:w なんてやっているとvsCodeを使っている人にバカにされる）<C-c>    - ファイル全体をコピー（便利）<leader>fm - フォーマット（コードを整形してくれる）<leader>n  - 行番号の表示/非表示<leader>rn - 相対行番号の切り替え2. 検索系（Telescope）検索系は本当によく使うので、最優先で覚えたいです。<leader>ff - ファイル検索（最重要）<leader>fw - プロジェクト内のテキスト検索（grep）<leader>fb - 開いているバッファを検索<leader>fo - 最近開いたファイルを検索<leader>fz - 現在のバッファ内をあいまい検索<leader>cm - Gitコミットを検索<leader>gt - Gitのステータスを表示github.com3. LSP関連（コードジャンプ・リファレンス）コードリーディングする時に本当に助かる機能たちです。gd - 定義へジャンプ（最も使う）gr - 参照を探す（変数やメソッドの使用箇所を探せる）K  - ドキュメントを表示（カーソル位置の要素の説明を表示）gi - 実装へジャンプ（インターフェースから実装を探せる）<leader>ds - 診断情報をloclistに表示github.com4. 画面分割とウィンドウ移動複数のファイルを同時に見たい時に使います。<C-h> - 左のウィンドウへ<C-l> - 右のウィンドウへ<C-j> - 下のウィンドウへ<C-k> - 上のウィンドウへ5. バッファ操作<leader>b - 新しいバッファを開く<tab> - 次のバッファへ<S-tab> - 前のバッファへ<leader>x - バッファを閉じる6. ターミナル操作ターミナルは必要に応じて呼び出せます。<A-i> - フローティングターミナル（これが一番便利）<A-h> - 水平分割のターミナル<A-v> - 垂直分割のターミナル<C-x> - ターミナルモードを抜ける7. その他の便利機能<leader>ch - チートシート表示（キーマッピングを忘れた時用）<leader>/  - コメントアウトのトグル<C-n>     - ファイルツリーの表示/非表示<leader>e  - ファイルツリーにフォーカス<Esc>     - ハイライトをクリアなぜこれらのキーマッピングを覚える必要があるのか私の経験上、以下の機能は開発効率を大きく向上させてくれます。ファイル検索（Telescope）プロジェクト内のファイルを素早く見つけられるコードベースの把握が容易になるGit操作との連携で変更管理がしやすいLSP機能コードの定義や参照を素早く調べられるリファクタリングが楽になるコードの理解が深まるエラー診断が即座にわかるRust を書いていると 1 箇所書き換えると芋づる式に修正が発生するのでどうしても必要になる。ターミナル統合エディタを離れずにコマンドを実行できるgit操作やビルドが快適フローティング表示で作業の邪魔にならないバッファ管理複数ファイルの編集がスムーズ必要なファイルをすぐに切り替えられるなぜNvChadを選んだのか実は、私のエディタ遍歴は長い。最初はVimから始まり、その後SpaceVim、AstroNvim、LunarVimなど、様々なNeovim系のディストリビューションを試してきた。VSCodeやIntelliJ IDEAのVimプラグインも使っていた時期がある。その過程で、Vimのキーバインドの快適さと、モダンなIDEの便利さ、その両方の良さを実感していた。ただ、どれも何かが違った。なんとなくしっくりこない。そんな中で出会ったのがNvChadだった。そんな中でNvChadに出会い、決め手となったのは開発体制の健全さだった。リポジトリは定期的に更新され、ドキュメントも整備されている。破壊的な変更がある場合も、きちんとアナウンスされ、移行のガイドラインが提供される。コミュニティも活発で、問題が起きた時のサポートも期待できる。nvchad.comさらに、NvChadの設計思想も気に入った。必要最小限の機能を高速に動作させることを重視し、その上で必要な機能を追加できる拡張性を持っている。プラグインマネージャーにlazy.nvimを採用し、起動時間の最適化もされている。LSPやTreeSitterの統合も洗練されており、快適なコーディング環境を提供してくれる。結果として、NvChadは私の理想とするエディタ環境に最も近かった。Vimの哲学を大切にしながら、モダンな開発環境を実現している。もちろん、完璧なエディタは存在しないし、NvChadにも改善の余地はきっとある。しかし、現時点で最も信頼できる選択肢の一つであることは間違いない。Vimを学ぶために通常のVimを学ぶ場合は、「実践Vim 思考のスピードで編集しよう！」がおすすめだ。Vimの基本から応用までを体系的に学べ、実践的な例も豊富に掲載されている。実践Vim　思考のスピードで編集しよう！ (アスキー書籍)作者:Ｄｒｅｗ Ｎｅｉｌ,新丈 径角川アスキー総合研究所Amazonまた、Vim Adventuresというゲームも面白い。ゲーム感覚でVimのキー操作を学べ、楽しみながら基本的なコマンドが身につく。初心者にも優しい学習カーブで、Vimの世界に入るきっかけとして最適だ。vim-adventures.comしかし、NvChadはこれらの基本的なVimの知識に加えて、モダンなIDE的機能を提供してくれる。このガイドでは、特にNvChad特有の機能に焦点を当てて説明しました。私自身、日々の開発作業でNvChadの恩恵を受けており、その便利さを多くの人と共有したいと考えている。まとめ私はVimを使い始めて数年経つが、今でも新しい発見がある。NvChadも同様で、日々の作業の中で「こんな機能があったのか」と驚かされることが多い。最初は覚えることの多さに圧倒されるかもしれないが、焦る必要はない。私の経験では、まずは基本的なファイル操作から始めるのが良い。保存やコピーといった最低限の操作を確実に覚えることで、日常的な編集作業に支障がなくなる。次に、Telescopeによるファイル検索を習得すると、作業効率が格段に上がる。プロジェクト内のファイルを瞬時に探せるようになり、コードベースの把握も容易になる。その後、LSPの基本機能を学んでいくと良いだろう。定義ジャンプやドキュメント表示は、コードリーディングの強力な味方となる。ウィンドウ操作とバッファ管理、ターミナル操作は、これらの基本操作に慣れてから徐々に取り入れていけば良い。結局のところ、エディタは道具でしかない。完璧に使いこなす必要はなく、自分の作業をサポートしてくれる程度に理解していれば十分だ。このガイドも、そんな私のような「忘れっぽいプログラマー」のための備忘録として活用してもらえれば幸いだ。少しずつでも確実に、自分なりのNvChadの使い方を見つけていってほしい。参考リンクNvChad公式ドキュメントGitHub - NvChad/NvChadNeovim LSP Documentation]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[週間アトデ 2024-11-22]]></title>
            <link>https://blog.atusy.net/2024/11/22/atodeyomanakata/</link>
            <guid>https://blog.atusy.net/2024/11/22/atodeyomanakata/</guid>
            <pubDate>Fri, 22 Nov 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[アトデヨム、ウソジャナイ、ヨムノタノシー]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Reckoner における Datadog Browser Test の活用事例 / Datadog Browser Test at Reckoner]]></title>
            <link>https://speakerdeck.com/nomadblacky/datadog-browser-test-at-reckoner</link>
            <guid>https://speakerdeck.com/nomadblacky/datadog-browser-test-at-reckoner</guid>
            <pubDate>Wed, 20 Nov 2024 05:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Japan Datadog User Group Meetup#6https://datadog-jp.connpass.com/event/334594/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[先人の知見から学ぶ、その経験則]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/11/20/122114</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/11/20/122114</guid>
            <pubDate>Wed, 20 Nov 2024 03:21:14 GMT</pubDate>
            <content:encoded><![CDATA[この度、Cloud Native における最新の機能やベストプラクティスにおいての学びについて、登壇させていただくことになりました。このテーマについて私なりに取り留めのない思考を整理した考えを共有させていただきます。event.cloudnativedays.jpソフトウェアエンジニアリングの型についてソフトウェアの世界には、プログラミング言語における変数やデータの「型」とは別に、長年の経験と知恵から生まれた様々な型が存在します。ここでいう「型」とは、開発者の思考や行動のパターンを体系化したものを指します。これらの型は、プログラマーが日々直面する問題に対する体系的な解決策を提供します。こうした型は、文脈や状況によって様々な呼び方をします。例えば、同じような問題解決のアプローチでも、ある文脈では「パターン」、別の文脈では「ベストプラクティス」と呼ばれることがあります。また、同じような設計手法でも、技術スタックやチームの文化によって異なる名前で知られていることもあります。このように、型の呼び方は多様ですが、その本質は問題解決のための知恵の結晶であることは変わりません。そのため、このブログでは意図的に「定石」「パターン」「手法」「アプローチ」「作法」「ベストプラクティス」など、様々な呼び方を用いて型を説明していきます。これは、同じような概念や手法が異なる文脈で別の名前で呼ばれている実態を反映させるためです。それぞれの呼び方が持つニュアンスの違いを理解することで、型に対するより深い理解が得られると考えています。いろんな名前の型の種類と特徴まず「定石」は、特定の状況下での最適な対処方法を示します。例えば、データベースにおけるN+1問題の解決方法やメモリリーク対策の手順など、具体的な技術的課題に対する確立された解決策です。次に「パターン」は、一般的な設計上の問題に対する標準的な解決策を提供します。いくつかの文脈で登場しますがコードやソフトウェアの構造化と再利用性を高めます。「手法」は開発プロセスを改善するための具体的な方法論を指します。テスト駆動開発（TDD）、リファクタリング、継続的インテグレーションなどが該当し、より体系的な開発アプローチを可能にします。「アプローチ」は問題解決への基本的な考え方や戦略を示し、ドメイン駆動設計（DDD）やマイクロサービスアーキテクチャなどが含まれます。また、「作法」はコードの品質と保守性を高めるための慣習を表します。SOLID原則、クリーンコード、命名規則などがこれにあたり、チーム開発における共通理解を促進します。「ベストプラクティス」は実践で効果が実証された推奨される方法であり、セキュリティ対策、パフォーマンスチューニング、エラー処理などの具体的な実装手法を含みます。他にも同じような文脈なのにいろんな言い方の「型」があります。aws.amazon.comlearn.microsoft.comcloud.google.com型の重要な特性これらの型には、いくつかの重要な特性があります。まず状況依存性があり、プロジェクトの規模や要件、チームの習熟度、ビジネスドメインによって最適な型が変化します。また、進化と適応の性質も持ち合わせており、新しい技術の登場により型自体が進化したり、既存の型が新しい文脈で再解釈されたり、チームの経験を通じて洗練されていきます。さらに、相互補完性も重要な特性です。複数の型を組み合わせることで相乗効果が生まれ、異なる型が互いの弱点を補完し合います。状況に応じて型を柔軟に組み合わせることが、効果的な問題解決には不可欠です。このように、ソフトウェアにおける「型」は、単なる規則や制約ではなく、効果的な問題解決のための知識体系として機能しています。これらの型を理解し、適切に活用することで、より効率的で品質の高い開発が可能になります。型の存在を認識し、その本質を理解することは、プログラマーとしての成長において重要な要素となるでしょう。プリンシプル オブ プログラミング 3年目までに身につけたい 一生役立つ101の原理原則作者:上田勲秀和システムAmazonどの巨人の型に乗るのか？ソフトウェアの世界で「定石」を学ぶことは、ある種の賭けのような性質を持っています。最初は論理的な理解が難しい概念や方法論を受け入れる必要があるにもかかわらず、その価値は実践してみないとわからないという矛盾を抱えているためです。多くの場合、「きっと将来役立つはず」という信念に基づいて学習を進める必要があります。この学習における矛盾は、特に高度な開発手法を習得する際に顕著に現れます。例えば、テスト駆動開発（TDD）の習得では、最初はテストを先に書くという一見非効率に思える手法に違和感を覚えるでしょう。しかし、この手法の真価は、実際にプロジェクトで実践し、コードの品質向上や保守性の改善を体験してはじめて理解できます。同様に、アーキテクチャ設計原則の導入においても、初期段階では過度に複雑に感じられる設計パターンや抽象化の価値を理解することは困難です。デザインパターンの学習や関数型プログラミングの考え方も、習得には相当な時間と労力を要します。これらの知識は、直接的な効果が見えにくい一方で、長期的には開発効率と品質を大きく向上させる可能性を秘めています。このジレンマを乗り越えるためには、段階的な学習アプローチと実践を通じた検証が重要になります。小規模なプロジェクトや個人的な開発で新しい手法を試し、その効果を実感することから始めることで、より大きなプロジェクトでの適用に向けた確信と経験を積むことができます。ルールズ・オブ・プログラミング ―より良いコードを書くための21のルール作者:Chris Zimmermanオーム社Amazon作法の習得における難しさ確立された手法（パターン）の習得には、独特の困難さが伴います。その中でも特に重要な課題として、習得前後のジレンマと成長段階による最適解の変化が挙げられます。まず、習得前後のジレンマについて考えてみましょう。体得するまでは本当の価値がわからないという特徴は、多くの開発手法に共通しています。例えば、ある設計パターンを学び始めた時点では、それがどのような状況でどれほどの効果を発揮するのか、具体的にイメージすることが困難です。さらに厄介なことに、体得してしまうと、その影響を客観的に評価しづらくなるという逆説的な問題も存在します。手法が無意識のうちに身についてしまうと、その手法を使わない場合との比較が難しくなり、問題が発生した際に、その原因がパターンの適用にあるのか、それとも他の要因によるものなのか、判断が困難になってしまいます。次に、成長段階による最適解の変化について着目する必要があります。プログラマーとしての習熟度によって最適な手法が変わるというのは、多くの現場で観察される現象です。例えば、初級者の段階では、まずはシンプルな実装手法に焦点を当て、基本的なプログラミングスキルを確実に身につけることが重要です。中級者になると、設計パターンの理解と適切な適用が課題となり、コードの構造化や再利用性を意識した開発が求められるようになります。上級者では、さらに進んで、パターンの取捨選択や状況に応じた最適化が必要となります。また、チームの規模や製品の成熟度によっても適切なアプローチは変化します。小規模なチームでは比較的シンプルな設計で十分な場合でも、チームが大きくなるにつれて、より体系的なアプローチが必要となることがあります。同様に、プロダクトの初期段階では迅速な開発を優先し、成熟期に入ってからより洗練された設計パターンを導入するなど、状況に応じた柔軟な対応が求められます。このように、作法の習得プロセスは単純な知識の蓄積ではなく、様々な要因を考慮しながら、継続的に改善と適応を行っていく必要のある複雑な取り組みと言えます。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazon不適切なパターンを見分けるための3つの条件複雑さという落とし穴不適切なパターンの最も顕著な特徴は、シンプルさの欠如です。優れたパターンには、核となる概念がシンプルで説明が簡潔であり、様々な状況への応用が柔軟に可能という特徴があります。このシンプルさは、単なる実装の簡素さだけでなく、パターンが解決しようとする問題と解決方法の関係性が明確であることを意味します。一方で、複雑な条件分岐が多い実装手法や、例外処理が複雑に絡み合ったエラーハンドリング、過度に抽象化された設計パターンなどは、保守性を低下させる要因となりかねません。特に、抽象化の層が必要以上に深くなると、コードの見通しが悪くなり、バグの温床となる可能性があります。シンプルさを欠いたパターンは、チームメンバー間での共有や理解を困難にし、結果として開発効率の低下やメンテナンスコストの増大を招くことがあります。批判を許さない教条主義検証がタブー視されている状況は、不適切なパターンの存在を示す重要な指標です。「それが会社の方針だから」という説明やレガシーコードの無批判な踏襲、特定の実装パターンへの過度な信仰は、危険な兆候と言えます。このような状況では、パターンの有効性や適用範囲について、客観的な評価や建設的な議論が行われにくくなります。定石の効果は常に検証可能であるべきであり、新しい技術やアプローチとの比較検討を行える環境が必要です。また、チーム内で改善提案が歓迎される雰囲気を醸成することも、健全なパターン活用には不可欠です。例えば、定期的なコードレビューやアーキテクチャ検討会での議論、実装パターンの効果測定など、具体的な検証の機会を設けることが重要です。パターンの効果や適用方法について、オープンな議論と継続的な改善が可能な環境を整えることで、より適切なパターンの選択と進化が促進されます。また、新しいチームメンバーからの質問や疑問を歓迎する文化を作ることで、既存のパターンの妥当性を定期的に見直すきっかけにもなります。魔法の解決策という幻想パターンに対する過度な期待は、不適切な適用を引き起こす大きな要因です。特定のアーキテクチャやパターンへの過度な期待や、新しいフレームワークやツールへの盲目的な信仰は、実装の複雑化や運用コストの増大を引き起こす可能性があります。特に、「銀の弾丸」を求める姿勢は、現実的な問題解決を見失わせる原因となりかねません。どんなパターンにも適用範囲や限界があることを認識し、状況に応じた適切な選択を行うことが重要です。例えば、マイクロサービスアーキテクチャは分散システムの柔軟性を高める可能性がありますが、運用の複雑さやネットワークの信頼性など、新たな課題も同時にもたらします。期待と現実のギャップを冷静に評価し、パターンの適用による実際の効果を慎重に見極める必要があります。これには、パターン導入前後での定量的な指標の比較や、チームメンバーからのフィードバック収集、実際のユーザーへの影響分析など、多角的な評価アプローチが求められます。また、パターンの導入は段階的に行い、各段階での効果を確認しながら進めることで、リスクを最小限に抑えることができます。仮説思考―ＢＣＧ流　問題発見・解決の発想法 内田和成の思考作者:内田 和成東洋経済新報社Amazon定石の進化と検証確立された手法は、暫定的な真実としての性質を持っています。これは、定石が先人の経験則の集大成として形成されながらも、常に改善の余地があるという特徴を示しています。時代とともに技術は進化し、新しい方法論が生まれることで、既存の定石が見直されたり置き換わったりすることは珍しくありません。この変化を受け入れ、柔軟に適応していく姿勢が重要です。また、定石の適用には段階的な最適化が必要です。プロジェクトの初期段階では、迅速な開発とフィードバックループの確立を重視した手法が有効です。その後、サービスがスケールしていく段階では、パフォーマンスや保守性を考慮したパターンの導入が必要となってきます。さらに、プロダクトが成熟期に入ったメンテナンスフェーズでは、長期的な運用を見据えた定石の適用が求められます。このように、プロジェクトのライフサイクルに応じて、適切な手法を選択し組み合わせていくことが重要です。そして、これらの手法の有効性を担保するためには、継続的な検証が不可欠です。具体的には、パフォーマンス指標による定量的な評価や、実際のユーザーからのフィードバックの収集、さらにはチーム内での定期的な振り返りを通じて、採用している手法の効果を多角的に検証する必要があります。この検証プロセスを通じて、チームは定石の適用方法を改善し、より効果的な開発プラクティスを確立することができます。このような進化と検証のサイクルを通じて、定石は単なる形式的なルールではなく、実践的で価値のある知識体系として発展していきます。重要なのは、定石を固定的なものとして捉えるのではなく、常に改善と適応を繰り返す生きた知識として扱うことです。それによって、チームは変化する要求や技術環境に柔軟に対応しながら、より効果的な開発プロセスを実現することができます。論点思考作者:内田 和成東洋経済新報社Amazonおわりにそもそも、Kubernetesは型の集大成とも言える存在です。PodやDeployment、Service、Operatorなど、その設計思想には分散システム開発における長年の経験と知恵が型として結晶化されています。Kubernetesの各機能は、それぞれが独立した型でありながら、組み合わさることでより大きな価値を生み出しており、まさにここで議論してきた型の相互補完性を体現していると言えるでしょう。ソフトウェアにおける定石やパターンとの付き合い方は、プログラマーとしての成長において重要な要素となります。ここで重要なのは、バランスの取れたアプローチです。定石を完全に否定せず、かといって盲目的にも従わないという姿勢を保ちながら、常に検証と改善を心がけることが大切です。チームや製品の成長に合わせて手法を進化させていくことで、より効果的な開発プロセスを確立することができます。また、開発手法の習得には継続的な学習のサイクルが不可欠です。まずは基本的なパターンを学び実践するところから始め、経験を積みながら定石の本質を理解していきます。その過程で、状況に応じて手法を適応させたり改善したりすることで、より深い理解と実践的なスキルを身につけることができます。さらに、未来への視点を持つことも重要です。現在の課題解決だけでなく、将来の拡張性も考慮に入れた選択を心がけます。新しい技術やアプローチに対してオープンな姿勢を保つことで、より良い解決策を見出す可能性を広げることができます。また、チーム全体での知識と経験の共有を促進することで、組織としての成長も期待できます。定石やパターンは確かに重要な指針となりますが、それは絶対的な真理ではありません。状況や文脈に応じて、柔軟に解釈し適用していく必要があります。プログラマーとして成長するには、確立された手法を理解し、適切に活用しながら、常に改善と進化を続けることが重要です。この継続的な学習と適応のプロセスこそが、真に効果的な開発手法の確立につながるのです。このような姿勢で開発に取り組むことで、個人としての技術力向上だけでなく、チーム全体の生産性と品質の向上にも貢献することができます。ソフトウェアの世界は常に進化し続けており、その中で成長し続けるためには、確かな基礎と柔軟な思考を併せ持つことが不可欠なのです。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[プロンプトエンジニアリングハンズオン]]></title>
            <link>https://shu-kob.hateblo.jp/entry/2024/11/19/172452</link>
            <guid>https://shu-kob.hateblo.jp/entry/2024/11/19/172452</guid>
            <pubDate>Tue, 19 Nov 2024 08:24:52 GMT</pubDate>
            <content:encoded><![CDATA[genai-users.connpass.com↑上記勉強会の資料です。shu-kob.hateblo.jp↑こちらの記事の「プロンプトエンジニアリング」もご覧ください。（上記記事はChatGPT）先ずは復習してみましょうGeminiにアクセスgemini.google.comお好みで、ChatGPTやClaudeを使用しても構いません。プロンプトエンジニアリングJSON形式で出力カレーのレシピを教えてください。出力は以下のJSON形式にしてください。==============={  "材料": ["材料1", "材料2"],  "手順": ["手順1", "手順2"]}==============={  "材料": [    "玉ねぎ 1個",    "にんじん 1本",    "じゃがいも 2個",    "牛肉 300g",    "カレールー 2箱",    "サラダ油 大さじ2",    "水 800ml",    "塩 少々",    "こしょう 少々"  ],  "手順": [    "玉ねぎ、にんじん、じゃがいもは食べやすい大きさに切る。",    "鍋にサラダ油を熱し、牛肉を炒め、色が変わったら玉ねぎを加えて炒める。",    "にんじん、じゃがいもを加えてさらに炒める。",    "水を加え、アクを取りながら煮込む。",    "野菜が柔らかくなったらカレールーを加えて溶かす。",    "塩こしょうで味を調え、5分ほど煮込む。"  ]}出力結果をJSON Formatterで確認JSON Formatter & ValidatorZero-shotプロンプティングZero-Shotプロンプティングとは、大規模言語モデル（LLM）に対して、事前に具体的な例を示すことなく、一度の指示でタスクを実行させるプロンプトエンジニアリング手法です。以下はニュース記事のタイトルです。「政治」「経済」「芸能」「スポーツ」「科学」「その他」のうち1つに分類してください。回答だけ一言で出力してください===========================紅白出場歌手の選考基準 NHK公開芸能Few-shotプロンプティングFew-Shotプロンプティングは、大規模言語モデル（LLM）に対して、タスクを実行するための具体的な例をいくつか示すことで、モデルの性能を向上させるプロンプトエンジニアリングの手法です。Zero-Shotプロンプティングとの違いZero-Shotプロンプティングが、一切の例を示さずにタスクを実行させるのに対し、Few-Shotプロンプティングでは、少数の例を提示することで、モデルがより効率的にタスクを学習できるようにします。以下はニュース記事のタイトルです。「政治」「経済」「芸能」「スポーツ」「科学」「その他」のうち1つに分類してください。回答だけ一言で出力してください===========================「紅白出場歌手の選考基準 NHK公開」===========================以下は例です「G20 バイデン氏不在で集合写真」：政治「岡田将生&高畑充希結婚 SNS反応」：芸能芸能Zero-shot Chain-of-ThoughtプロンプティングZero-shot Chain-of-Thought（CoT）プロンプティングは、大規模言語モデル（LLM）に対して、具体的な例を示すことなく、段階的な推論プロセスを踏ませるように指示するプロンプトエンジニアリングの手法です。回答だけ一言で出力してください。10 + 2 * 3 - 4 * 28ステップバイステップで考えてください。10 + 2 * 3 - 4 * 2## ステップバイステップで解いてみましょう！**与えられた式:** 10 + 2 * 3 - 4 * 2**解き方:**数学では、**掛け算と割り算**は、**足し算と引き算**よりも先に計算します。これを**優先順位**と言います。1.  **掛け算を計算する:**    * 2 * 3 = 6    * 4 * 2 = 8    式は、10 + 6 - 8 に変わります。2.  **残りの計算を行う:**    * 10 + 6 = 16    * 16 - 8 = 8**答え:** 8**まとめ:**与えられた式をステップバイステップで解くと、答えは**8**になります。**ポイント:*** **優先順位:** 掛け算と割り算は、足し算と引き算よりも先に計算します。* **計算順序:** 左から右へ計算していきます。**補足:**もし、計算の順番を変えたい場合は、**かっこ**を使います。例えば、(10 + 2) * 3 - 4 * 2 のようにかっこでくくると、最初に10と2を足してから3をかけることになります。**この説明で理解できましたか？** もし、まだ疑問な点があれば、遠慮なく質問してくださいね。Few-shot Chain-of-ThoughtプロンプティングFew-shot CoTプロンプティングは、大規模言語モデル（LLM）に、いくつかの例を示しながら、段階的な推論プロセスを踏ませることで、より複雑な問題を解かせる手法です。このグループの奇数を合計すると偶数になります。: 4、8、9、15、12、2、1。A: 奇数を全て加えると(9, 15, 1)25になります。答えはFalseです。このグループの奇数を合計すると偶数になります。: 17、10、19、4、8、12、24。A: 奇数を全て加えると(17, 19)36になります。答えはTrueです。このグループの奇数を合計すると偶数になります。: 16、11、14、4、8、13、24。A: 奇数を全て加えると(11, 13)24になります。答えはTrueです。このグループの奇数を合計すると偶数になります。: 17、9、10、12、13、4、2。A: 奇数を全て加えると(17, 9, 13)39になります。答えはFalseです。このグループの奇数を合計すると偶数になります。: 15、32、5、13、82、7、1。A:参考文献LangChainとLangGraphによるRAG・AIエージェント［実践］入門10倍速で成果が出る！ChatGPTスゴ技大全]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rのパッケージ内でloggerパッケージを使う]]></title>
            <link>https://blog.atusy.net/2024/11/19/logger-in-r-package/</link>
            <guid>https://blog.atusy.net/2024/11/19/logger-in-r-package/</guid>
            <pubDate>Tue, 19 Nov 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Rのloggerパッケージをパッケージ開発に使う場合、.onLoad関数内でログレベルなどの設定しよう。.onLoad関数のpkgname引数をlogger::log_thresholdなどの設定関数のnamespace引数に渡すと、パッケージ内のログだけを対象に設定を変更できます。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[#技育CAMPキャラバン in福岡🗣️で学生の質問に答えた。]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/11/17/003421</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/11/17/003421</guid>
            <pubDate>Sat, 16 Nov 2024 15:34:21 GMT</pubDate>
            <content:encoded><![CDATA[はじめに先日、技育CAMPキャラバンin福岡に社会人エンジニアとして参加し、学生の皆さんと対話する貴重な機会を得ました。このイベントは一方的な講義形式ではなく、各企業がブースを設け、学生と直接対話できる形式で行われました。talent.supporterz.jp私は株式会社スリーシェイクのSreake事業部に所属しています。当社はインフラエンジニアやSRE特化の企業であり、必ずしも全ての学生エンジニアの志望と合致するわけではありません。そのため、マッチングに時間が余った際には、先輩社会人として学生からの様々な質問に答える時間を持つことができました(もちろん、インフラエンジニアやSREに興味がある学生は応募してほしいです)。jobs-3-shake.com実はこの内容は半分冗談で半分本気なのですが、基本的な生活習慣の重要性は本当に伝えたいメッセージの一つです。なので、後半に参考文献などを貼ってます。もう、おじさんなので学生エンジニアに出会ったら、集中力を高める食事、認知機能を向上させる運動、記憶の定着に不可欠な質の良い睡眠、創造性を引き出す意識的な休憩といった基本的な生活習慣の最適化と、予期せぬチャンスを活かす計画的偶発性理論に基づくキャリア形成の話しかしていない。— nwiizo (@nwiizo) 2024年11月16日   この記事では、学生の皆さんから頂いた質問と回答を整理してまとめました。完璧な内容ではないかもしれませんが、対話を通じてかつての自分自身の悩みや不安が蘇り、過去の自分に語りかけているような不思議な感覚を覚えました。この内容が、ご質問いただいた学生の皆さまはもちろんのこと、同様の悩みを抱えているすべての方々の参考となれば幸いです。なお、各回答は異なる方々からの質問に対して、それぞれの文脈に沿ってお答えしたものとなっております。Q.失敗するのが怖くて全体として中途半端になってしまうこの質問をされた時に分かりすぎて泣きそうになった。エンジニアとして働いてきたり少し長く生きた経験から言えることは、失敗を恐れることよりも、挑戦しないことのほうが人生にとって大きなリスクとなるということです。結局のところ、これは自己愛の問題なのかもしれません。「時間を無駄にしたくない」「労力を無駄にしたくない」「チャンスを無駄にしたくない」。そういった思いが強すぎると、かえって何も始められなくなってしまいます。この「無駄にしたくない」という感情の根底には、自分を大切にする気持ちが強すぎるあまり、逆に自分を縛ってしまうというパラドックスがあります。完璧を求めすぎる。失敗を許せない。その背景には、実は自分への過度な期待や要求があるのです。嫌われる勇気作者:岸見 一郎,古賀 史健ダイヤモンド社Amazonでも、人生は無駄にしても良いんです。むしろ、無駄を恐れるあまり何も挑戦しないほうが、本当の意味で人生を無駄にしてしまうことになります。健全な自己愛とは、失敗しても自分を受け入れられる強さ、完璧でない自分を許せる余裕を持つことなのです。人生で最も価値のあるものは、一朝一夕には手に入りません。技術力も、人間関係も、信頼も、全て時間をかけて少しずつ築き上げていくものです。その時間を掛けられるかどうかは、今この瞬間にどれだけ自分を信じられるかにかかっています。そして、自分を信じるためには、失敗した自分も含めて、まるごと受け入れる覚悟が必要です。実は、本当に価値のあるものには、必ず痛みが伴います。すぐに得られる快楽は往々にして一時的なものですが、時間をかけて獲得したものこそが、本物の価値を持つのです。エンジニアとしての技術力も同じです。一朝一夕には身につかず、時には挫折も味わう。でも、その痛みを受け入れ、耐えることができれば、必ず実を結ぶのです。私自身、数々の失敗を経験してきました。コンテストに出て準備不足で大敗したり、本番環境でのデプロイミス、重要な機能の設計ミス、プロジェクトの見積もり違い、スタートアップへの参画での関わり方の間違いなど。一見すると、これらは全て「無駄な失敗」のように思えます。しかし、これらの失敗は全て、今の私の技術力と判断力の基礎となっています。失敗から学べる環境は、社会人になるとむしろ少なくなります。学生時代は、失敗から学ぶ最高の機会なのです。小さな挑戦から始めて、失敗した時の対応策を事前に考えておく。そして失敗から学んだことを必ず記録し、同じ失敗を繰り返さない仕組みを作る。これが私の失敗との向き合い方です。完璧を目指すのではなく、失敗してもいいと自分に許可を出すこと。そこから本当の挑戦が始まるのです。これは、自分を信頼し、自分を大切にする健全な自己愛の表れでもあります。また、簡単に手に入るものは、簡単に失われます。でも、痛みを伴って得たものは、決して簡単には失われない。この事実を心に留めておいてください。そして、これは自分自身との関係性においても同じことが言えます。自分を大切にしすぎるあまり縛ってしまうのではなく、失敗も含めて受け入れる。その寛容さこそが、本当の意味での自己愛なのかもしれません。超一流になるのは才能か努力か？ (文春e-book)作者:アンダース・エリクソン,ロバート・プール文藝春秋AmazonQ.プログラミングがあまり分からなくて不安ですこれはとても一般的な不安です。実は私も、そして多くのエンジニアも同じ経験をしてきました。プログラミングの習得は、多くの人が思い描くような線形的な成長カーブを描きません。理解が全く進まないように感じる時期が長く続き、そしてある日突然、「あ、わかった！」という瞬間が訪れるのです。これは私たちの脳が新しい概念を理解する際によく見られるパターンです。たとえば、プログラミングの各種概念は最初のうちは本当に理解が困難です。でも、ある時を境に急に全体像が見えてくる。それまでモヤモヤしていた霧が晴れるように、概念が腑に落ちる瞬間が必ずやってきます**。だからこそ、今理解できないからと諦めるのは本当に惜しいことです。理解できないのは当たり前の段階なのです。むしろ、理解できなくて当然の時期を耐え忍ぶことこそが、プログラミング習得の本質とも言えます。私たちはどう学んでいるのか　――創発から見る認知の変化 (ちくまプリマー新書)作者:鈴木宏昭筑摩書房Amazonそれと合わせて、私から一つアドバイスさせていただきたいことがあります。それは言語化能力を磨くことです。プログラミングの学習において、概念を言葉で説明できる能力は非常に重要です。なぜなら、自分の理解を言葉にすることで、その理解がより深まり、また他者と共有できるようになるからです。学んだことを日記やブログに書き留めることから始めてみましょう。技術書を読んでその内容を自分の言葉で要約してみる。分からないことを質問する際にも、自分の理解状態を具体的に言語化してみる。これらの活動は、一見するとプログラミングの学習から外れているように思えるかもしれません。しかし、言語化能力はエンジニアにとって、いくら高くても困ることのないスキルです。コードを書く力と、それを説明する力。この両輪があってこそ、真に優れたエンジニアとなれるのです。最後に繰り返しになりますが、今の不安は決して特別なものではありません。理解できないことに耐え、学び続ける勇気さえあれば、必ず道は開けます。今は理解できなくても、それは単に「まだ」理解できていないだけなのです。焦らず、諦めず、そして何より自分を信じて、一歩ずつ前に進んでいってください。ワイド新版　思考の整理学 (単行本 --)作者:外山　滋比古筑摩書房AmazonQ.キャリア形成をするときにどうすればよいでしょうか？10年程度のエンジニア経験を通じて、最も重要だと感じているのは「計画的偶発性」の考え方です。予期せぬチャンスは必ず訪れますが、それを活かせるかどうかは、日頃の準備にかかっています。そして、どのような道を選んでも、基礎的なスキルの習得は必須です。技術力はもちろん、コミュニケーション能力、プロジェクトマネジメントの基礎、ドキュメンテーションスキルなど、技術以外の部分が実は大きな差を生みます。これらを支えるのが規則正しい生活習慣です。質の良い睡眠、バランスの取れた食事、適度な運動。この当たり前のことを当たり前にできることが、長期的なキャリアを支える土台となります。最後に付け加えておきたいのは、最初の選択が全てを決めるわけではないということです。キャリアは常に変化し続けるものであり、必要に応じて軌道修正することも可能です。大切なのは、その時々で最善と思える選択をし、その環境で最大限学び、成長することです。イシューからはじめよ［改訂版］――知的生産の「シンプルな本質」作者:安宅和人英治出版AmazonQ.就活のときに気にしたほうがいいこと就職活動で自分が気にしていたのは相手の立場や背景を理解したコミュニケーションです。人事部門、現場エンジニア、経営層など、話す相手によって重視する観点が異なります。同じ経験や能力でも、相手の関心に応じて伝え方を工夫する必要があります。人事との対話では、将来のキャリアビジョンやチームへの貢献について。現場エンジニアとは技術的な興味や具体的な実装経験について。経営層にはビジネスへの理解や組織全体への価値提供について。このように文脈に応じて自分の強みを効果的に伝えられることが重要です。また、会社選びにおいては技術環境だけでなく、育成・評価制度やチームの雰囲気も重要な要素です。メンター制度の有無、技術研修の充実度、キャリアパスの明確さ。そしてチーム内のコミュニケーションスタイル、残業や休暇の取得状況、チーム間の連携方法。これらが実際の働きやすさを大きく左右します。このような状況に応じたコミュニケーション能力は、就活だけでなく、その後のエンジニアとしてのキャリアでも大きな差となって現れます。相手の関心や視点を理解し、それに応じて自分の経験や考えを効果的に伝える。これは単なる処世術ではなく、エンジニアに求められる重要なスキルの一つなのです。「何回説明しても伝わらない」はなぜ起こるのか？　認知科学が教えるコミュニケーションの本質と解決策作者:今井むつみ日経BPAmazonQ.学生の間でやったほうがいいこと正直に申し上げると、この質問に対する模範解答を示すことは避けたいと思います。なぜなら、誰もが自分の人生の主人公であり、その選択に責任を持つべきだからです。ただし、一つだけ確実に言えることがあります。それは、誰もあなたを救ってくれないということです。社会人になってから「あの時こうしておけば良かった」と思うことは誰にでもあります。しかし、それはその時の自分が選択した結果であり、その選択に対する責任は自分自身にあるのです。あなたの人生の舵を取れるのは、あなただけです。そして、その選択の結果として感じる後悔も、あなただけのものです。他人の経験談や助言は参考程度に留め、最終的には自分で考え、決断し、その結果に向き合う覚悟を持ってください。SOFT SKILLS ソフトウェア開発者の人生マニュアル 第2版作者:ジョン・ソンメズ日経BPAmazonQ.SREって何ですか？この質問に関しては、私が以前書いた「点でしかないものを線で見る為に - 「SREの前に」」というブログ記事と登壇資料を紹介しました(同運営イベントなので・・・)。syu-m-5151.hatenablog.comこの記事では、SREの考え方や、実践に必要な基礎知識について詳しく解説しています。あとはインフラエンジニア版の競技プログラミングサイトを紹介した。sadservers.comQ.生産性を上げる方法はありますか？私からの回答は明確です。「スマートフォンを制限すること」に尽きます。現代の最大の生産性の敵は、実はポケットの中にあります。スマートフォンは素晴らしいツールですが、使い方を誤ると大きな時間泥棒となります。これは単なる時間管理の問題ではありません。スマートフォンやSNSは、意図的に依存性を持つように設計されています。「ついスマホを見てしまう」「暇があれば通知をチェックしている」「SNSやYouTubeを見ていたら、気づいたら何時間も経っていた」—これらは偶然ではありません。これらのプラットフォームは、ドーパミンという報酬物質を放出させ、継続的な使用を促す仕組みになっているのです。その影響は私たちの生活のあらゆる面に及びます。集中力の低下により、情報過多で何をしようとしていたのかを忘れてしまう。メンタルヘルスへの悪影響として、衝撃的なニュースや他人の投稿を見て不安や劣等感を感じる。さらには睡眠の質の低下をもたらし、就寝前の使用が質の良い睡眠を妨げています。では、具体的にどうすれば良いのでしょうか。まずは物理的にスマホを遠ざけることから始めましょう。自分の部屋に置かないという選択は、思い切った対策に思えるかもしれませんが、効果は絶大です。目覚まし時計などのような、スマホの代替となるツールを積極的に活用することで、依存度を下げることができます。そして何より大切なのは、リアルで人と会って交流することです。オンラインのつながりに頼りすぎると、かえって孤独感が深まることがあります。実際の対面でのコミュニケーションは、心の健康を保つ上で非常に重要です。重要なのは、これは決してあなたの意志の弱さが原因ではないということです。現代のテクノロジーは、人間の脳の仕組みを巧妙に利用するように設計されています。だからこそ、意識的な制限と代替手段の確保が必要なのです。休憩時間もスマートフォンに頼るのではなく、軽い運動や瞑想を取り入れる。寝る前の読書習慣をつけるなど、スマートフォンに依存しない生活リズムを作ることで、驚くほど生産性が向上します。あなたの本来の能力を最大限に発揮するために、まずはスマートフォンとの適切な距離感を見つけることから始めてみてください。スマホ脳（新潮新書）作者:アンデシュ・ハンセン新潮社AmazonQ.周りのすごい人と比べてしまって落ち込みますこの悩みをよく聞きます。俺も思います。確かに私たち人間は、ついつい目に見えるラベルで判断してしまいがちです。学歴、過去の実績、Xのフォロワー数、有名企業でのインターン経験、GitHubのスター数など。でも、エンジニアの本当の凄さは、そんな表面的なところにはありません。人生は、運よりも実力よりも「勘違いさせる力」で決まっている作者:ふろむだダイヤモンド社Amazon私が長年エンジニアとして働いてきて確信しているのは、本当に優れたエンジニアの価値は、その人が直面する問題をどう解決するか、チームにどう貢献するか、そして日々どう成長していくかにあるということです。時には、ほんの些細な気づきや熱量や視点の違いが、大きなアウトプットの差を生むことがあります。これは学生時代に限らず、社会人になってからも同様です。確かに、自分が目指したいキャリアイメージに向けて、意識的にある種のラベルを獲得しようとすることは否定しません。それも一つの戦略です。ただし、より重要なのは、自分の思考プロセスや行動を明確に言語化できる能力です。「なぜその選択をしたのか」「どのように問題を解決したのか」を論理的に説明できる人は、社会に出てからより高く評価される傾向にあります。肩書きや過去の実績は、その人の一部分でしかありません。むしろ、今この瞬間にどれだけ真摯に技術や事業と向き合っているか、どれだけ学ぼうとする意欲があるか、そしてどれだけチームに価値をもたらしているか。そういった日々の積み重ねこそが、エンジニアとしての本質的な価値を形作っていくのです。だからこそ、表面的なラベルで自分を判断する必要はありません。あなたにしかできない貢献の仕方があり、あなたにしかない成長の道筋があるはずです。重要なのは、自分の考えや行動を明確に言語化し、それを他者と共有できること。そして、他の人と比べるのではなく、昨日の自分と比べて、一歩ずつでも確実に前に進んでいくことです。いかにして問題をとくか作者:G．ポリア丸善出版Amazon余談ですが、技術的な記事を書いたり登壇したりすることで「いいね」を集めたり、ハッカソンやビジネスコンテストで賞を獲得したりすることで得られる達成感は、一時的な快感に過ぎず、あくまでも外部からの評価でしかありません。イベントやSNSでの反響は確かにモチベーションの維持や目標設定には有効です。しかし、それを自分の技術力の証明と混同してしまうのは危険です。特に、外部での評価が高まると実際の技術力以上に自己評価が膨らみがちです。定期的に競技プログラミングやISUCON、CTF、学生ならICTSCにでも参加して、自分の現在地を冷静に確認することをお勧めします。結局のところ、ソフトウェアエンジニアにとって最も大切なのは、地道なコーディングと技術力の着実な積み重ねなのです。質問ではないのですが投稿まとめツイートの内容をサクッとまとめます。エンジニアの間で「運動が大切だ」という話をよく耳にします。確かにその通りですが、健康維持には運動以外にも同等に重要な要素が複数あります。これは人生の多くの側面に当てはまる話です。「すごい」と感じる人に出会ったとき、その瞬間にその人と自分の実力差や実績の差に圧倒されがちですが、実はそれは表面的な差でしかありません。大切なのは、基本的な生活習慣を整え、地道な努力を10、20年単位で継続できるかどうかです。短期的には大きな差が付いているように見えても、正しい生活習慣と共に粘り強く継続することで、必ず追い付き、追い越すことができます。運動脳作者:アンデシュ・ハンセンAmazon質の良い睡眠は、技術の習得と定着に直接的な影響を与えます。睡眠中、脳は日中の学習内容を整理し、長期記憶として定着させる重要な作業を行っています。しかし、多くのエンジニアは必要な睡眠時間を確保できていない「睡眠負債」の状態にあります。これは単なる「睡眠不足」という言葉で片付けられる問題ではありません。借金と同じように、睡眠負債は返済が滞ると、脳も体も思うように機能しなくなり、最終的には「眠りの自己破産」を引き起こしてしまいます。その結果、集中力の低下、記憶力の減退、さらには深刻な健康上の問題まで引き起こす可能性があります。特に危険なのは、睡眠負債による「マイクロスリープ（瞬間的居眠り）」です。1秒未満から10秒程度の意識の途切れは、本人も気づかないうちに起こり、作業中の重大なミスや事故につながりかねません。コードレビューやインフラ作業など、高度な注意力を要する作業において、これは深刻な問題となります。対策として重要なのは、就寝前のブルーライトを避け、規則正しい睡眠サイクルを維持することです。週末の寝だめでは解決しない睡眠負債を作らないよう、平日から意識的に睡眠時間を確保することが、長期的な学習効率と作業パフォーマンスを支える土台となります。スタンフォード式　最高の睡眠作者:西野 精治サンマーク出版Amazon適切な食事も、持続的な集中力の維持に不可欠です。ただ、多くのエンジニアに共通して見られる問題として、安易に糖質に偏った食事を選択しがちという傾向があります。手軽なカップ麺やパン類、菓子類への依存は、一時的な満足感は得られても、長期的には集中力の低下を招きます。特に気をつけたいのがタンパク質の摂取不足です。プログラミングは脳を使う仕事であり、脳の働きを最適化するためには十分なタンパク質摂取が欠かせません。忙しい中でも、プロテインドリンクの活用や、コンビニで手に入る鶏むね肉のサラダなど、手軽にタンパク質を補給できる方法を確保しておくことをお勧めします。ここで個人的におすすめなのが低温調理器の活用です。特に鶏むね肉の調理に関しては、低温調理器があれば手間をかけずに柔らかく美味しいタンパク質を確保できます。帰宅後に調理を始めるのは大変ですが、低温調理器なら出勤前にセットしておくだけで、帰宅時には完璧な火加減の料理が待っています。しかも、大量調理が可能なので、一度の調理で数日分のタンパク質を準備できます。コーヒーや糖分に頼りすぎない食生活を意識することも重要です。特に朝食では、炭水化物とタンパク質をバランスよく摂取することで、一日を通して安定したパフォーマンスを発揮できます。疲れない体をつくる最高の食事術作者:牧田善二小学館Amazonそして見落とされがちなのが、意識的な休養時間の確保です。連続的な作業は、必ずしも生産性の向上には繋がりません。むしろ、疲れをごまかして動き続けることは、回復に要する時間を延ばすだけでなく、深刻な健康上の問題を引き起こす可能性があります。休養には「生理的休養」「心理的休養」「社会的休養」の3種類があり、これらを適切に組み合わせることで、より効果的な疲労回復が期待できます。ただし、ここで言う休養とは、スマートフォンを触ることではありません。むしろ、休憩時間にスマートフォンを見ることは、脳を別の形で疲労させてしまう最悪の選択と言えます。理想的な休養とは、「自分で決めた」「仕事とは関係ない」「成長できる」「楽しむ余裕がある」という条件を満たした活動を指します。これらの要素が揃うことで、単なる休憩ではなく、心身の本質的な回復と成長をもたらす「攻めの休養」となります。デジタルデバイスから完全に離れ、心身をリセットする時間が必要です。短い散歩や深呼吸、窓の外を眺めるなど、意識的に何もしない時間を作ることで、脳は自然と新しいアイデアを生み出す準備を整えていきます。これは一見、時間の無駄に思えるかもしれませんが、長期的な生産性向上には不可欠な投資なのです。休養学―あなたを疲れから救う作者:片野 秀樹東洋経済新報社Amazon運動も確かに重要ですが、それは全体の一部分でしかありません。質の良い睡眠、バランスの取れた食事、適切な休憩。これらすべての要素が揃って初めて、エンジニアとして最高のパフォーマンスを発揮できるのです。ぜひ、生活習慣全体を見直す機会にしていただければと思います。おわりに後から見返すと純粋な学生に対して偉そうで斜に構えた回答をしてるなぁ… もっとベタをやれって思ってしまいました。ともあれ無事に終わって良かったです。学生の皆さんと対話できる貴重な機会を得て、私自身も多くの気づきがありました。かつての自分も同じような不安や悩みを抱えていたことを思い出し、その時の気持ちが今でも鮮明に蘇ってきます。そして不思議なことに、皆さんの質問に答えながら、過去の自分自身とも対話をしているような感覚がありました。技術の世界は常に変化し続けています。その中で最も重要なのは、技術そのものではなく、技術を学び続ける力、問題を解決する力、そして人と協力する力です。これは今も昔も変わらない真理だと感じています。皆さんには無限の可能性があります。当時の私がそうだったように、今は不安や迷いがあるかもしれません。でも、その不安を抱えながらも一歩を踏み出す勇気があれば、必ず道は開けます。失敗を恐れず、積極的に挑戦し続けてください。私たち社会人エンジニアは、かつての自分を重ねながら、皆さんの成長を心から応援しています。そして、この対話を通じて、私自身も過去の自分と向き合い、その不安や迷いを受け止め直すことができました。私たちは常に、過去の自分を励ましながら、未来の誰かの道標となれるよう成長し続けているのかもしれません。なお、イベントでお会いした学生の皆さん、もし追加の質問や相談事があれば、お気軽にDMをください。可能な範囲で、皆さんのキャリアについて一緒に考えていけたらと思います。pitta.me]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[PostgreSQLので全文検索拡張機能、pg_bigmを試す]]></title>
            <link>https://zenn.dev/nnaka2992/articles/use_pgbigm_on_cloudsql</link>
            <guid>https://zenn.dev/nnaka2992/articles/use_pgbigm_on_cloudsql</guid>
            <pubDate>Sat, 16 Nov 2024 11:12:07 GMT</pubDate>
            <content:encoded><![CDATA[アプリケーションを開発しているとアプリケーションログの分析や、JSONデータに対する分析など全文検索機能を求められることがたびたびあります。そういった場合はElasticsearchのように全文検索に特化したデータベースを導入することが多いです。しかし単純な文章の検索[^特にトランザクション用途]や小規模に利用される場合ばわざわざ専用のデータベースを管理作りたくないというケースが多いです。今回はPostgreSQLで利用可能な全文検索インデックスの拡張機能であるpg_bigmを紹介します。 検証環境の作成 CloudSQL 構成Cloud SQL EditionsE...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンドの引数にJSONやYAMLを使うと便利かも]]></title>
            <link>https://blog.atusy.net/2024/11/16/json-as-cmd-args/</link>
            <guid>https://blog.atusy.net/2024/11/16/json-as-cmd-args/</guid>
            <pubDate>Sat, 16 Nov 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[コマンドの引数をいっそJSONやYAMLにしちゃうと、シェルスクリプトの引数処理でwhileループを回避できる、配列など複雑な値もJSONの枠組みで扱える、JSONSchemaでバリデーションできると、嬉しいことが沢山かも。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイク、Think IT連載「Kubernetesスペシャリストが注目する関連ツール探求」が連載開始から1周年]]></title>
            <link>https://sreake.com/blog/kubernetes-2/</link>
            <guid>https://sreake.com/blog/kubernetes-2/</guid>
            <pubDate>Thu, 14 Nov 2024 01:00:00 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）は、インプレスグループが運営するエンジニア向け技術解説サイト「Think IT」にて連載中の「Kubernetesスペシャリストが注目する関連ツール探求」が、連載開始から1周年を迎えることをお知らせします。The post スリーシェイク、Think IT連載「Kubernetesスペシャリストが注目する関連ツール探求」が連載開始から1周年 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイク、「CloudNative Days Winter 2024」に出展・登壇]]></title>
            <link>https://sreake.com/blog/cloudnative-days-winter-2024/</link>
            <guid>https://sreake.com/blog/cloudnative-days-winter-2024/</guid>
            <pubDate>Tue, 12 Nov 2024 01:19:07 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）は、2024年11⽉28日（木）・29日（金）に開催される「CloudNative Days Winter 2024」に出展および登壇することをお知らせします。The post スリーシェイク、「CloudNative Days Winter 2024」に出展・登壇 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[点でしかないものを線で見る為に - 「SREの前に」というタイトルで登壇しました。]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2024/11/11/110223</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2024/11/11/110223</guid>
            <pubDate>Mon, 11 Nov 2024 02:02:23 GMT</pubDate>
            <content:encoded><![CDATA[はじめに先日、技育プロジェクト（株式会社サポーターズ）主催の技育CAMPアカデミアという勉強会にて「SREの前に」というイベントで登壇する機会をいただきました。今回は「点」としての情報を「線」として繋げて見ることの重要性について、お話しさせていただきました。このイベントは、特にこれからSREを目指す学生の方々に向けて、運用の基礎的な考え方や歴史的背景を共有することを目的としています。サピエンス全史　上　文明の構造と人類の幸福 (河出文庫)作者:ユヴァル・ノア・ハラリ河出書房新社Amazonイベントページtalent.supporterz.jpどこにでも答えがある時代私たちは情報があふれる時代に生きています。技術書やオンラインドキュメント、技術ブログ、そして最近では生成AIなど、様々な方法で技術知識を得ることができます。しかし、これらの情報の多くは「点」として存在しています。なぜその技術が生まれたのか、どのような課題を解決しようとしていたのか、当時のエンジニアたちは何を考えていたのか―――そういった文脈や歴史的な背景は、資料や書籍だけでは見えづらいものです。それでも必要とされるエンジニアになってほしい「SREとは何か」という知識自体は、今や簡単に手に入ります。しかし、なぜSREという概念が必要とされるようになったのか、従来の運用との本質的な違いは何か、といった背景を理解することは容易ではありません。運用の世界では、過去の経験や失敗から学び、それを現在の実践に活かすことが非常に重要です。こうした経験や知見は、単なる技術ドキュメントからは読み取ることが難しいのです。そして、さらに重要なのは、その時々の「正解っぽい何か」を理解し、実際の課題解決に活かせるようになることです。技術やプラクティスは、それ自体が目的なのではありません。例えば、SREの施策やベストプラクティスも、結局のところ「どうすれば安定的にサービスを運用できるか」という課題に対する一つの解答なのです。私たちに求められているのは、その解答を理解し、自分たちの文脈に合わせて適切に活用していく力ではないでしょうか。技術の変遷を知ることで見えてくるものこの20年間で技術は劇的に変化しました。クラウドの普及、コンテナ技術の発展、マイクロサービスアーキテクチャの採用など、システムの在り方そのものが大きく変わってきています。しかし、これらの変化の根底には「より良いサービスを、より確実に、より効率的に提供したい」という普遍的な願いがあります。技術の進化を「新しい技術の登場」としてだけでなく、「なぜその技術が必要とされたのか」という視点で理解することで、次に何が必要とされるのか、自分たちはどう進化していくべきなのかが見えてくるはずです。発表を通じて伝えたかったこと今回の発表で、特に若手エンジニアの皆さんに伝えたかったのは、技術を「点」で捉えるのではなく、その背景にある文脈や歴史的な流れを「線」として理解することの大切さです。これは単に「過去を知る」ということではなく、未来への洞察力を養うことにもつながります。変化の激しいIT業界では、個々の技術は常に進化し、新しいものに置き換わっていきます。しかし、その変化の本質を理解し、次の一手を考えられるエンジニアこそが、これからも必要とされ続けるのだと信じています。そして、これは重要な点なのですが、私たちが目にする技術の変遷は、常に正解への道のりだったわけではありません。むしろ、その時々の制約や状況の中で、エンジニアたちが必死に模索した結果の一つにすぎません。「その時はそれしか選択肢がなかった」という判断もまた、とても重要な文脈です。この視点を持つことで、現在の技術選択に対しても、より深い理解と柔軟な判断が可能になるのではないでしょうか。発表資料 speakerdeck.com今回の発表では、以下のような内容をお話させていただきました。運用の歴史的変遷2000年代前半の運用現場では、多くが手作業で行われ、開発チームと運用チームの間には大きな壁が存在していました。その後、2009年頃からDevOpsの概念が登場し、開発と運用の協調が重要視されるようになりました。2010年代に入ると、GoogleによってSREが体系化され、データドリブンな運用やプロアクティブな障害対策が標準的なアプローチとなっていきました。現代の運用における課題現在のSREは、システムの複雑化やマイクロサービスアーキテクチャの採用により、新たな課題に直面しています。特に以下の点が重要になってきています：システムの複雑性の管理クラウドネイティブ環境での信頼性確保組織の成長に伴う運用のスケーリング継続的なシステム改善の実現歴史から学ぶ重要性発表では特に、過去の経験や失敗から学ぶことの重要性を強調しました。技術の進化は決して直線的ではなく、過去の課題が形を変えて再び現れることも少なくありません。そのため、歴史的な文脈を理解することは、現在の課題に対する解決策を考える上で非常に重要です。この発表が、技術を学ぶ方々、特に学生の皆さんにとって、個々の知識を繋げて理解するための一助となれば幸いです。単に「今」の技術トレンドを追いかけるだけでなく、その背景にある文脈や歴史を理解することで、より深い技術理解と、将来の変化への対応力を身につけることができるのではないかと考えています。システムの本質を見失わないために本発表では詳しく触れませんでしたが、ここで一つ重要な課題に言及しておきたいと思います。クラウドの発展は、確かにシステム開発を劇的に効率化しました。ですが、その便利さは大きな落とし穴も持っています。クラウドの力が強大になり、エンジニアの技術力が相対的に低下し、それがさらなるクラウド依存を生む。この負のサイクルは、私たちの目の前で着実に進行しています。禅とオートバイ修理技術 上 (ハヤカワ文庫NF)作者:ロバート Ｍ パーシグ早川書房Amazonシステムが動作している状態さえ維持できれば問題ないという考え方や、複雑な問題はクラウドサービスに任せておけばよいという姿勢は、一見合理的に見えます。しかし、システムの性能改善や障害対応時に、表面的な理解しかないエンジニアには、その本質的な原因を特定することすらできません。各システムの深い理解と、時には「痛み」とも呼べる経験は必要不可欠です。しかし、「動いているからいい」という現状で、この必要性を伝えることは非常に難しい。これは現代のエンジニアリング教育における最大の課題です。禅とオートバイ修理技術 下 (ハヤカワ文庫NF)作者:ロバート Ｍ パーシグ早川書房Amazonエンジニアリングの本質は表面的な最適化ではありません。まず根本的な理解があり、その上で適切な抽象化や最適化を行う―――これこそが、私たちが目指すべき姿なのです。コンピュータの構成と設計　MIPS Edition　第6版 　上・下電子合本版作者:David Patterson,John Hennessy日経BPAmazon最後に今回の発表を通じて、多くの学生の方々と交流する機会を得ました。皆さんの熱心な質問や鋭い観察には、とても励まされました。もうすぐ30歳を迎える身として、学生の皆さんの真摯な質問一つひとつに胸が熱くなり、できる限り丁寧に答えたいという気持ちで一杯になりました。実は私自身、学生時代は進むべき道に悩み、多くの不安を抱えていました。だからこそ、今回質問をしてくださった学生の皆さん、そしてイベントに来てくださった全ての方々と、いつかじっくりとお話ができればと思っています。（ちなみに、この年になっても人見知りが抜けず、時々無愛想な態度をとってしまうことがあります。そんな時は「まだまだ成長途中のエンジニア」として、温かい目で見守っていただけると嬉しいです）技術の世界は日々変化していきますが、その変化の中に普遍的な価値を見出し、理解を深めていく姿勢は、エンジニアとして成長していく上で最も重要な要素の一つだと考えています。時には「その時はそれしか選択肢がなかった」という判断があったことを理解しつつ、過去のエンジニアにリスペクトを送りつつ私たちはきっと、この悩みや探求の過程を共有することで、共に成長していけるはずです。最後に、このような貴重な機会を提供してくださった技育プロジェクト（株式会社サポーターズ）のスタッフの皆様、そして参加してくださった皆様に心より感謝申し上げます。若手エンジニアの皆さんの成長を、これからも微力ながら支援させていただければ幸いです。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[qfscope.nvimでtelescope.nvimの検索結果を絞り込む]]></title>
            <link>https://blog.atusy.net/2024/11/11/qfscope-nvim/</link>
            <guid>https://blog.atusy.net/2024/11/11/qfscope-nvim/</guid>
            <pubDate>Mon, 11 Nov 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[telescope.nvimの検索結果をファイル名や該当行の内容で絞り込みたいときのために、qfscope.nvimを開発しました。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Kubernetes Sidecar 一問一答]]></title>
            <link>https://sreake.com/blog/kubernetes-native-sidecar/</link>
            <guid>https://sreake.com/blog/kubernetes-native-sidecar/</guid>
            <pubDate>Fri, 08 Nov 2024 04:06:41 GMT</pubDate>
            <content:encoded><![CDATA[はじめに Kubernetes 1.29からBeta機能となったSidecar Containerという機能を使う機会があったので、これについて一問一答形式で概要を共有してみようと思います。 小粒なTipsになりますがご […]The post Kubernetes Sidecar 一問一答 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
    </channel>
</rss>