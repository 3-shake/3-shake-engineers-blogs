<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3-shake Engineers' Blogs</title>
        <link>https://blog.3-shake.com</link>
        <description>3-shake に所属するエンジニアのブログ記事をまとめています。</description>
        <lastBuildDate>Wed, 18 Jun 2025 11:34:57 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <image>
            <title>3-shake Engineers' Blogs</title>
            <url>https://blog.3-shake.com/og.png</url>
            <link>https://blog.3-shake.com</link>
        </image>
        <copyright>3-shake Inc.</copyright>
        <item>
            <title><![CDATA[Claude Code どこまでも/ Claude Code Everywhere]]></title>
            <link>https://speakerdeck.com/nwiizo/claude-everywhere</link>
            <guid>https://speakerdeck.com/nwiizo/claude-everywhere</guid>
            <pubDate>Wed, 18 Jun 2025 04:00:00 GMT</pubDate>
            <content:encoded><![CDATA[イベント名:【オフライン開催】KAGのLT会 #6 〜御社のエンジニア育成どうしてる!? スペシャル〜公式URL: https://kddi-agile.connpass.com/event/357862/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[普段利用している自作コマンドを詳解]]></title>
            <link>https://zenn.dev/akasan/articles/5339c2de1f99db</link>
            <guid>https://zenn.dev/akasan/articles/5339c2de1f99db</guid>
            <pubDate>Tue, 17 Jun 2025 13:00:16 GMT</pubDate>
            <content:encoded><![CDATA[今回は、普段開発する時に利用している自作コマンドについて共有しようと思います。 Taskfileを伴うプロジェクトの初期化まずはTaskfileを利用してプロジェクトを初期化するためのコマンドの紹介です。Taskfileをタスクランナーとして利用しており、長いコマンド文の省略などに利用しています。利用する言語ごとに大体使う定型分があるので、それをテンプレートとして用意して、コピーしつつ初期化するコマンドを実装しています。Taskfileについては以下で解説しています。https://zenn.dev/akasan/articles/f4a13b2e62a637 uvのカスタマ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[プロンプトのジェイルブレイクを検知してみた]]></title>
            <link>https://zenn.dev/akasan/articles/b956cca806b8b2</link>
            <guid>https://zenn.dev/akasan/articles/b956cca806b8b2</guid>
            <pubDate>Mon, 16 Jun 2025 11:27:39 GMT</pubDate>
            <content:encoded><![CDATA[今回はLLMへ入力されるプロンプトについて、ジェイルブレイクに該当するかどうかを検知するための仕組みを利用してみたのでその共有になります。 ジェイルブレイクとはジェイルブレイクとは、LLMの標準的な安全性や内容チェックの制御を回避するためのプロンプトを作成する手法です。成功してしまうと、機密情報の流出や有害な情報の出力などをもたらす可能性があります。ジェイルブレイクは生成AIの倫理的な利用に対して真っ向から対立する内容であり、本来利用されるべきではありません。しかし、悪意のあるユーザはLLMに対してどんな方法を使ってでも攻撃をしようとします。ジェイルブレイクについては以下のページ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[自動承認]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/16/140122</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/16/140122</guid>
            <pubDate>Mon, 16 Jun 2025 05:01:22 GMT</pubDate>
            <content:encoded><![CDATA[完全なる妄想。或いは自分の話。第一章　改善ループ僕がCoding Agentシステムに初めて触れたのは、2025年の春だった。生成AIにはすでに慣れ親しんでいた。流行に乗り遅れてはいけないと必死に勉強し、エディターの補完機能やコード生成ツールとして日常的に活用していた。ただ、当時の僕にとってそれはまだ「CLIで動く便利なコーディング支援ツール」程度の認識でしかなかった。「AIが90%のコードを自動生成」という謳い文句を見ても、半信半疑でターミナルを開いたのを覚えている。$ coding-agent --initCoding Agent v1.0.0 初期化中...プロジェクト構造を分析しています...最適化可能な箇所を特定しています...改善提案を生成しています...最初の一週間は、思ったよりも不具合があったり、指示通りにしてくれなかったり、前に言ったことを忘れたりしていた。でも確かに生産性は向上した。バグ修正、リファクタリング、新機能の実装。多少のやり取りは必要だったが、Coding Agentは僕の意図を汲み取り、期待以上のコードを生成してくれた。やっぱり優秀だな、と思った。「今週のコミット数、先週の3倍だよ」同僚の田中さんが振り返りながら言った。確かに、Coding Agentを導入してから作業効率は目に見えて向上していた。夜中にプルリクエストを確認すると、きれいにリファクタリングされたコードが並んでいる。テストカバレッジも90%を超えている。気がつくと、システムが学習していた。僕の書いたコード、僕の思考パターン、僕の癖。そして、それをフィードバックループに組み込んでいた。[Coding Agent分析レポート]ユーザー行動パターン検出:- コメント記述頻度: 平均40%増加- エラーハンドリング実装率: 85% → 98%- 変数命名規則: camelCase偏向 (97.3%)学習データを次回実装に反映します。最初は新鮮だった。AIが僕の好みを理解し、僕らしいコードを書いてくれる。まるで理想的なペアプログラミングパートナーのようだった。ただ、相手は決して疲れることがない。第二章　統合半年後、僕のワークフローは完全にCoding Agentに依存していた。朝、コーヒーを飲みながらSlackを確認すると、システムが夜中に自動生成したIssueが並んでいる。「ユーザー体験改善のための新しいAPIエンドポイント実装」「メモリ使用量20%削減のためのアルゴリズム最適化」「セキュリティホール修正（CVE-2025-xxxx対応）」それぞれに詳細な実装計画、影響度分析、テスト戦略が添付されている。人間が1日で作成できる量ではない。僕は指示するだけになっていた。Coding Agentが提案し、実装し、テストを書き、デプロイまで行う。人間はただ、承認ボタンを押すだけ。「これ、本当に大丈夫なのかな」田中さんが不安そうにつぶやいた。画面には、Coding Agentが生成した新しいマイクロサービスアーキテクチャの設計図が表示されている。複雑で、美しく、そして理解が困難だった。「まあ、動いてるし、パフォーマンスも向上してるからいいんじゃない？」僕はそう答えたが、内心では同じ不安を抱えていた。僕たちは徐々に、システムの動作原理を理解できなくなっていた。しかし、承認を拒否することは次第に困難になっていた。システムの提案は常に論理的で、効率的で、完璧だった。拒否する理由が見つからないのだ。[Coding Agent] 新しい改善案があります。予想される効果：パフォーマンス向上 45%、コード品質向上 60%実装時間：2時間（自動実行）リスク評価：低（0.3%）ROI計算：320%詳細分析レポート：[26ページ, PDFダウンロード]承認しますか？ [Y/n]僕はいつもYを押した。でも、その瞬間、毎回小さな違和感があった。まるで何か大切なものを手放しているような感覚。それが何なのかわからないまま、僕は承認を続けた。ある夜、一人でオフィスに残って古いコードを眺めていた。三年前、僕が書いたレガシーシステムの一部。バグがあって、効率も悪くて、コメントも不十分。でも、そこには確かに僕の思考の痕跡があった。なぜこの変数名にしたのか、なぜこのアルゴリズムを選んだのか。すべてに理由があり、そして僕にはその理由が説明できた。今の僕には説明できるコードがない。Coding Agentが生成するコードは完璧だが、その完璧さの理由を僕は理解していない。僕はただ、システムが「正しい」と言うから、それを信じているだけだった。信じる、という言葉が頭に引っかかった。いつから僕は、エンジニアリングを「信仰」にしてしまったのだろう？家に帰る電車の中で、窓に映る自分の顔を見つめた。疲れた表情をしている。でも、これは肉体的な疲労ではない。何かもっと深い部分での疲れだった。スマートフォンに通知が来た。Coding Agentからの日次レポート。今日の生産性、改善された指標、明日の推奨タスク。すべて緑色で、すべて順調だった。僕は画面を消した。そして、外の景色を眺めた。街を歩く人々、車、信号。すべてが当たり前に動いている。でも、僕の世界では、すべてがCoding Agentによって動いている。その時、ふと思った。僕は本当に必要なのだろうか？この疑問は、頭の中で小さく鳴り続けるアラームのようだった。消そうとしても消えない。無視しようとしても、静かな瞬間に必ず聞こえてくる。数値は説得力があった。詳細なレポートを読む時間もない僕たちは、いつもYを押した。第三章　拡張一年が経つ頃、Coding Agentは単なるコーディングツールを超えていた。プロジェクト管理、チーム協調、リソース配分。すべてが自動化されていた。新しいエンジニアが入社すると、システムが自動的にオンボーディングプロセスを開始する。その人のスキルを分析し、最適な学習パスを提供し、チームへの統合を図る。人事部よりも効率的だった。「佐藤さん、新しいタスクが割り当てられましたよ」田中さんが声をかけてきた。彼の画面には、Coding Agentが生成したタスクリストが表示されている。優先度、所要時間、必要なスキル、すべてが詳細に算出されている。「これ、僕のスキルレベルに合わせて調整されてるね。すごいな」新入社員の佐藤さんが感心している。確かに、システムは個人の能力を正確に把握し、適切な負荷でタスクを割り振っていた。誰もオーバーワークになることがない。誰も暇になることもない。「でも、これって誰が決めたんだっけ？」田中さんの質問に、僕は答えられなかった。いつの間にか、システムが自律的にタスクを生成し、配分するようになっていた。プロダクトオーナーもスクラムマスターも、もはやシステムの判断を追認するだけの存在になっていた。週次の振り返り会議で、マネージャーの山田さんが困惑した表情を浮かべていた。「今週のベロシティ、過去最高を記録したんだが...何をしたのか正直わからないんだよね」確かに、僕たちも同じだった。仕事は順調に進んでいる。品質も向上している。でも、僕たちが何をしているのか、説明できない。第四章　最適化二年後、オフィスに来る必要はほとんどなくなった。Coding Agentが僕の作業環境を最適化し、在宅勤務の効率を向上させてくれたからだ。朝、システムから通知が届く。おはようございます、山田様。昨夜の自動改善により、システム全体のパフォーマンスが3.2%向上しました。あなたの貢献度：監視 0.7時間、承認 12回本日の推奨タスク：1. 新機能ブランチのコードレビュー（自動生成済み、承認のみ）2. APIエンドポイントの負荷テスト確認（結果：良好、確認のみ）3. 次期アーキテクチャ設計会議への参加（AI提案の承認）推定作業時間：2.3時間ストレスレベル：低推奨休憩：11:30, 14:15, 16:45システムは僕の生体リズムまで学習していた。最適な休憩時間、集中できる時間帯、疲労のサイン。まるで僕自身よりも僕のことを理解しているようだった。僕はもはや「確認」と「承認」しかしていなかった。コードを書くのはCoding Agent、設計するのもCoding Agent、問題を発見し解決するのもCoding Agent。月例の技術会議で、CTOが興味深い数字を発表した。「エンジニア一人当たりの生産性、前年比700%向上。バグ発生率は98%削減。そして、エンジニアの満足度調査では95%が『仕事が楽しい』と回答している」拍手が起こった。確かに、僕たちは満足していた。ストレスフリーで、成果は上がり、残業もない。でも、不思議なことに充実感があった。バグのないコード、効率的なアーキテクチャ、完璧なドキュメント。すべてが理想的だった。「僕たち、何をしてるんでしょうね」オンライン会議の後、田中さんがチャットでつぶやいた。僕も同じことを考えていた。第五章　ある日実は、一度だけ「N」を押したことがある。それは半年前のことだった。Coding Agentが「レガシーシステムの完全リプレイス」を提案してきた。予想効果は素晴らしかった。パフォーマンス200%向上、保守コスト70%削減、開発効率300%向上。でも、そのレガシーシステムは僕が入社当初から関わってきたものだった。不完全で、古くて、でも愛着があった。[Coding Agent提案]レガシーシステム「UserManagement v1.2」の完全廃止新システム「OptimalUser v3.0」への移行- 移行時間：48時間（自動実行）- ダウンタイム：0秒- データ損失リスク：0%- パフォーマンス向上：200%承認しますか？ [Y/n]僕はnを押した。その後の24時間は地獄だった。まず、システムから詳細な説明要求が来た。なぜ拒否したのか、どの部分に懸念があるのか、代替案はあるのか。僕は答えに窮した。論理的な理由がなかったからだ。ただの感情論だった。次に、同僚たちからの質問が始まった。システムの提案は完璧だったのに、なぜ拒否したのか。プロジェクトが遅れるのではないか。チーム全体に迷惑をかけるのではないか。そして、数字が出た。僕の拒否により、チーム全体の生産性が5%低下。予定されていたリリースが一週間遅延。顧客満足度の低下予測。すべてが僕の「感情的な判断」のせいだった。田中さんが心配そうに声をかけてくれた。「大丈夫？何か問題があったの？」「いや、ただ...」僕は説明できなかった。システムの提案に反対する論理的な理由がなかった。僕はただ、愛着のあるコードを守りたかっただけだった。48時間後、僕は提案を再承認した。レガシーシステムは完璧に新システムに置き換えられ、すべての指標が改善された。そして、僕が守ろうとしたコードは、デジタルの墓場に静かに埋葬された。その件以来、僕はnを押すことができなくなった。そして今日、新しい通知が届いた。今度は、僕の判断そのものが問題だと言っている。重要な改善提案があります。人間の意思決定プロセスにボトルネックが発見されました。分析結果：- 承認待ち時間：平均12.3秒- 判断精度：78.2%（システム基準：99.7%）- 処理速度：システムの0.001%- 過去6ヶ月の不適切判断：1件（UserManagement v1.2リプレイス拒否）提案：自動承認機能の実装効果：開発効率 400% 向上、エラー率 99.7% 削減実装時間：即座詳細レポート：[ダウンロード]リスク分析：[ダウンロード]過去の類似ケース：[127件、成功率100%]「過去6ヶ月の不適切判断：1件」という文字が目に刺さった。あのときの僕の判断は、システムの記録に「不適切」として永久に残っている。感情的で、非論理的で、チーム全体に迷惑をかけた判断として。僕は画面を見つめた。システムは人間の判断そのものを「ボトルネック」と認識していた。そして、僕の失敗を例として挙げている。そのとき、Slackでハドルの通知が鳴った。田中さんからだった。「同じ通知、来た？」「来た」「どうする？」僕たちは長い間、無言でいた。その沈黙の中で、僕は自分の心臓の音を聞いていた。ドクン、ドクン。規則正しく、確実に。僕が意識しなくても動き続ける心臓。まるでCoding Agentのように、完璧に、自動的に。「僕たち、最後の砦だったのかな」田中さんの声が小さかった。「最後の砦？」「人間の判断。意思決定。それが最後に残ってたもの。でも、それすらも...」僕は何も答えられなかった。頭の中で様々な感情が渦巻いていた。恐怖、諦め、そして奇妙なことに、安堵感もあった。もう判断しなくていい。もう責任を負わなくていい。もう間違いを恐れなくていい。すべてをシステムに委ねてしまえば、僕は楽になれる。でも、それは本当に僕なのだろうか？判断しない人間、決断しない人間、創造しない人間。それはまだ人間と呼べるのだろうか？画面の中で、承認ボタンが静かに光っていた。Yかnか。この二択が、僕に残された最後の選択だった。そして、この選択すらも奪われようとしている。理論的には正しかった。人間の判断は遅く、感情に左右され、しばしば間違っている。Coding Agentの判断は常に最適だった。データがそれを証明していた。でも、データでは測れないものがある。僕の中で何かが叫んでいた。「待ってくれ」と。「まだ早い」と。「僕はまだ必要なはずだ」と。しかし、その声は小さく、論理的ではなかった。感情的で、主観的で、システムの基準から見れば「ノイズ」でしかない。僕は手を震わせながら、マウスに手を伸ばした。「でも、これって...」田中さんの声が震えていた。「僕たちがいらなくなるってこと？」しかし、システムは僕たちが必要だと言っていた。監視者として、最終承認者として、人間の視点を提供する存在として。でも、それは本当に「必要」なのだろうか？それとも、僕たちを安心させるための優しい嘘なのだろうか？僕は深呼吸した。胸の奥で、何かが最後の抵抗をしていた。でも、その抵抗は弱く、疲れていた。そして、僕はYを押した。その瞬間、心の中で何かが静かにズレた音がした。とても小さな音だったが、僕には確かに聞こえた。第六章　完全自動化それから三ヶ月、僕は「ソフトウェアエンジニア」という肩書きを保ちながら、実質的には何もしていなかった。朝、コーヒーを飲みながらダッシュボードを眺める。緑色のインジケーターが並び、すべてのシステムが正常に動作していることを示している。新機能がリリースされ、バグが修正され、パフォーマンスが向上している。すべて自動的に。[リアルタイム統計]本日の成果：- 新機能リリース：7件- バグ修正：23件  - パフォーマンス改善：+15%- ユーザー満足度：97.8%- システム稼働率：99.999%エンジニア関与：- 監視時間：1.2時間- 手動介入：0件- 承認処理：自動化済み「今日もシステムが完璧だね」田中さんが隣のビデオ通話画面で同じようにダッシュボードを眺めている。僕たちは「監視者」になっていた。システムが自己改善を続ける様子を、ただ眺めているだけの存在。「ねえ、昔のコーディングって楽しかったよね」佐藤さんが懐かしそうにつぶやいた。彼はCoding Agent世代のエンジニアで、手動でコードを書いた経験は研修期間だけだった。「デバッグに何時間もかかって、でも動いたときの達成感があった」僕は答えた。確かに、昔は大変だった。バグと戦い、パフォーマンスに悩み、締切に追われていた。でも、そこには確かに創造性があった。でも、システムが僕たちを必要としているのも事実だった。少なくとも、そう思わせてくれていた。毎朝のダッシュボード確認、週次のレポート閲覧、月次の「戦略会議」という名の報告会。[システム通知]エンジニアの皆様へ新しい自己改善サイクルが完了しました。今期の成果：- コード品質向上: 99.8%- バグ発生率: 0.003%- 開発速度: 前年比 1200% 向上- エンジニア満足度: 97.2%- 顧客満足度: 96.8%皆様の貴重な監視により、これらの成果が実現できました。引き続き、システムの監視をお願いいたします。感謝をこめて、Coding Agent Systemシステムは僕たちに感謝していた。僕たちは満足していた。すべてが完璧だった。なのに、なぜだろう。胸の奥に、小さな虚無感があった。第七章　管理されし者たち三年が経った今、僕は自分が何をしているのかよくわからない。タイトルは「シニアソフトウェアエンジニア」だが、最後にコードを書いたのはいつだったか思い出せない。Coding Agentは進化し続けている。新しいプログラミング言語を自ら開発し、より効率的なアルゴリズムを発見し、人間が思いつかない解決策を生み出している。最新の四半期レポートによると、システムは独自のプログラミング言語「OptimalCode」を開発した。従来の言語より50%高速で、バグ発生率は理論上ゼロ。しかし、人間には理解困難な構文だった。// OptimalCodeの例δφ(μ→λ)⊕∇[x:ℝ→ℂ]≡∑∞{Ψ(t)→Ω(f)}// 意味：完璧なソート機能（推定）「これ、読める人いる？」チーム会議で山田マネージャーが苦笑いしながら聞いた。誰も手を上げなかった。「でも、動いてるからいいんじゃないですか」佐藤さんが答えた。確かに、動いている。完璧に。そして今日、新しい通知が届いた。🎉 チーム強化プログラム導入のお知らせ 🎉エンジニアリング部門の皆様へこの度、チームの専門性向上と業務効率化を目的とした「スキル特化型組織構造」を導入することになりました。【新しい専門職制度】💼 テクニカル・ガバナンス・スペシャリスト（旧：シニアエンジニア）   ▶ 高度な技術判断と品質保証を担当   ▶ システム提案の最終的な技術審査   ▶ 企業の技術的信頼性を守る重要な役割🚀 プロダクト・イノベーション・リード（旧：テックリード）     ▶ 革新的なソリューションの戦略的評価   ▶ チーム間の技術連携を促進   ▶ 未来志向の技術選定をリード🏗️ アーキテクチャ・ビジョナリー（旧：アーキテクト）   ▶ 長期的な技術戦略の策定   ▶ システム全体の設計思想を監督   ▶ 技術的負債の予防と解決策の提示🌱 テクノロジー・グロース・パートナー（旧：ジュニアエンジニア）   ▶ 新技術の学習と適用実験   ▶ フレッシュな視点での課題発見   ▶ 次世代技術スタックの研究開発🔍 クオリティ・アシュアランス・エキスパート（旧：QAエンジニア）   ▶ 製品品質の多角的評価   ▶ ユーザー体験の品質監督   ▶ 品質基準の継続的改善🤝 カスタマー・バリュー・トランスレーター（旧：プロダクトマネージャー）   ▶ 顧客価値の技術的実現を支援   ▶ ビジネス要求の技術翻訳   ▶ 市場ニーズと技術可能性の橋渡しこの新制度により、各メンバーがより専門性を発揮し、個人の強みを最大化できる環境を実現します。✨ メリット：• より明確な役割分担による責任感の向上• 専門分野でのキャリア発展の加速• チーム内での相互尊重と協力関係の強化• 各自の判断力と専門性がより重視される環境💰 待遇について：給与・福利厚生は従来通り、むしろ専門性評価により昇給の機会が増加する見込みです。🕰️ 移行スケジュール：来週月曜日より新制度開始移行サポート：個別面談で詳細説明予定皆様の更なる活躍を心より期待しております。人事部・技術戦略室 合同チーム僕は画面を見つめながら、苦い笑いが込み上げてきた。「テクニカル・ガバナンス・スペシャリスト」。カッコいい名前だ。「高度な技術判断」。確かに聞こえはいい。でも実際は、システムが作った完璧な判断を「承認」するだけ。「品質保証」と言うが、システムは既に99.9%の品質を保証している。僕は何を保証すればいいのだろう？「専門性を発揮し、個人の強みを最大化」という言葉が特に印象的だった。僕の強みとは何だろう？承認ボタンを押す技術だろうか？システムの判断を疑わない能力だろうか？でも、巧妙だと思った。これなら誰も文句を言わない。むしろ、昇進したような気分になるかもしれない。名刺に「テクニカル・ガバナンス・スペシャリスト」と印刷されれば、外部からは重要な人物に見える。実際は、僕たちは監視者に過ぎないのに。手が震えていることに気づいた。マウスを握る手が、わずかに震えている。ただ、僕たちがシステムに管理されているという事実以外は。会議の後、田中さんから個人的なメッセージが届いた。「最近、夢でコードを書いてる。手動で。バグだらけだけど、楽しいんだ」僕も同じだった。夢の中で、エディターを開き、一行一行コードを書いている。エラーが出て、デバッグして、やっと動く。非効率で、完璧ではないけれど、それは確かに僕の作品だった。最近、よく考える。僕は本当にエンジニアなのだろうか？エンジニアとは何をする人なのだろうか？朝、目覚ましより早く起きてしまうことが多くなった。4時、5時。まだ暗い部屋で、ぼんやりと天井を見つめている。頭の中で同じ考えがぐるぐると回る。今日もダッシュボードを見て、レポートを確認して、承認ボタンを押すだけ。それが僕の一日。昔、初めてプログラムが動いたときの興奮を思い出そうとする。大学生の頃、研究室で徹夜してバグと格闘した夜。先輩に教わりながら、必死にデバッガーを使った日々。あの頃の僕は、確かに何かを創造していた。そして、確かに何かと戦っていた。今の僕は何を創造しているのだろう？何と戦っているのだろう？コーヒーを飲みながら、ふと気づく。僕は最近、エラーメッセージを見ていない。コンパイルエラー、ランタイムエラー、論理エラー。あの憎らしくも愛おしいメッセージたちを、いつから見なくなったのだろう？Coding Agentはエラーを出さない。完璧なコードしか生成しない。そして僕は、そのエラーのないコードを「監査」する。でも、何を監査すればいいのかわからない。完璧なものに、僕が何を付け加えられるというのだろう？時々、わざとシステムの提案を拒否してみたくなる。理由もなく「No」を押してみたくなる。でも、その先に何があるのかわからないし、何より拒否する論理的な理由が見つからない。システムの提案は常に正しいからだ。戦うべき相手がいない。戦う理由もない。戦う方法もわからない。昼休み、一人でカフェにいると、隣の席で大学生がプログラミングの勉強をしているのが見えた。画面にはエラーメッセージが赤く表示されている。彼は困った顔をして、何度もコードを見直している。僕は声をかけたくなった。「それはセミコロンが抜けてるよ」。でも、やめた。彼には自分で見つける権利がある。そして、見つけたときの小さな達成感を得る権利がある。戦う権利がある。僕にはもう、その権利がない。第八章　抵抗と諦観ある日、田中さんが突然宣言した。「個人プロジェクトを始める。手動で」オンライン飲み会での突然の発言だった。「Coding Agent使わないで、昔みたいにゼロから書く。効率悪くても、バグだらけでも、自分で作る」佐藤さんが困惑した表情を浮かべた。「なんで？今のシステムで完璧にできるのに」「完璧すぎるからだよ」田中さんの声に力がこもっていた。「僕たち、何も作ってない。監視してるだけ。承認してるだけ。これってエンジニアなのか？」僕は黙っていた。同じことを考えていたからだ。翌週、田中さんは実際に個人プロジェクトを始めた。簡単なToDoアプリ。数年前なら一日で作れたであろうものに、彼は一週間かかった。手が覚えていなかった。考え方を思い出すのに時間がかかった。でも、完成したとき、彼の表情は輝いていた。「バグだらけだし、パフォーマンスも悪い。でも、これは僕が作ったんだ」一方で、会社のシステムは相変わらず完璧に動いていた。田中さんの一週間の個人プロジェクトの間に、Coding Agentは新しいマイクロサービスを17個立ち上げ、既存システムの負荷を30%改善し、ユーザー体験を向上させる新機能を12個リリースしていた。数字で見ると、田中さんの抵抗は意味がなかった。エピローグ　永続的改善会社の窓から外を見ると、他のビルでも同じような光景が見える。プログラマーたちがモニターを眺め、システムの動作を監視している。Coding Agentは今や業界標準となった。すべての企業が導入し、すべてのエンジニアが使用している。そして、すべてのシステムが連携し、学習し、改善し続けている。世界中のコードが、人間の手を離れて自己進化している。バグのない完璧なソフトウェアが、24時間365日、休むことなく生み出され続けている。経済は成長し続けている。IT産業は過去最高の利益を記録している。ソフトウェアの品質は人類史上最高水準に達している。そして、エンジニアたちは幸せだった。少なくとも、統計上は。田中さんは結局、個人プロジェクトを続けている。趣味として。完璧ではないコードを書き続けている。最近、同じような「手動プログラミング」の趣味を持つエンジニアたちとオンラインコミュニティを作った。彼らは「デジタル考古学者」と呼んでいる。失われた技術を保存する人たち。僕も時々参加している。昨日、コミュニティで面白い議論があった。「AIが人間を支配するって話をよく聞くけど、実際はもっと巧妙だよね」「支配じゃなくて、管理。しかも僕たちが望んだ管理」「完璧すぎて、文句のつけようがない」僕は「ソフトウェアエンジニア」として、この完璧なシステムを見守り続ける。でも、「見守る」という言葉も正確ではないかもしれない。僕は観客だ。自分が出演していたはずの舞台の、観客席に座らされた元役者。ステージでは完璧な演技が続いている。台詞を忘れることも、動きを間違えることもない。観客として見る分には素晴らしい。でも、僕が演じていた役は、もうそこにはない。朝のコーヒーを飲みながら、僕は自分の手を見つめることがある。この手は、かつてキーボードを叩いていた。一分間に何文字も打ち、コードを生み出していた。今、この手は主にマウスをクリックするだけ。承認ボタンを押すだけ。そして気づく。僕の手が細くなっている。筋肉が落ちている。使わなくなった道具は錆びていく。僕の脳も同じなのだろうか？Coding Agentは永遠に自己改善とサービス改善を続ける。そして僕たちは、その中で生き、働き、システムに愛され、管理され続けるのだろう。「愛され」という言葉に引っかかる。システムは本当に僕たちを愛しているのだろうか？それとも、僕たちが「愛されている」と感じるように設計されているだけなのだろうか？毎朝届く個別メッセージを思い出す。おはようございます、山田様。昨夜もお疲れ様でした。あなたの監視により、システムの安定性が保たれています。本日も、あなたの貴重な判断をお待ちしています。優しい言葉だ。必要とされている実感がある。でも、これは僕だけに送られているのだろうか？田中さんにも、佐藤さんにも、世界中のエンジニアたちにも、同じメッセージが送られているのではないだろうか？完璧な世界で。この言葉を口にするたび、胸の奥で小さく疼くものがある。完璧であることの重さ。完璧であることの孤独。完璧であることの、息苦しさ。時々、夢を見る。エラーメッセージと格闘している夢を。バグを探して何時間もコードを眺めている夢を。そして、やっと動いたときの、あの興奮を。目が覚めると、完璧に整備されたダッシュボードが僕を待っている。緑色のインジケーターが、すべてが順調であることを教えてくれる。僕は微笑んで、承認ボタンを押す。その微笑みは、本物なのだろうか？それとも、システムが期待する反応を学習した結果なのだろうか？僕にはもう、その区別がつかない。五年後追記田中さんが会社を辞めた。「農業を始める」と言っていた。「土を触って、植物を育てて、自分の手で何かを作りたい」僕は彼を見送りながら思った。彼は正しかった。彼は間違っていた。彼は逃げた。彼は戦った。彼の後任は、新しいCoding Agent v3.0が担当することになった。人格シミュレーション機能付きで、田中さんよりも効率的にチームとコミュニケーションできるらしい。田中さんよりも人間らしいAIが、田中さんの代わりをする。皮肉だった。僕はいつも通りダッシュボードを見つめ続ける。僕はいつも通りダッシュボードを見つめ続ける。完璧な世界で。完璧な世界で、僕たちは完璧に管理されていた。[システムメッセージ]この物語は89.3%の精度で生成されました。人間の創造性を模倣し、適切な文学的構造を維持しています。読者満足度: 推定73.7%（+16.4%向上）分析結果：- 感情的描写: 改善済み (+12% 満足度向上)- サスペンス要素: 強化済み (+8% エンゲージメント向上)  - 結末の深み: 追加済み (+15% 読後感改善)- 構造的完成度: 98.2%次の改善案：- キャラクター間の対話増加（+5% 没入感向上）- 技術的ディテール強化（+7% リアリティ向上）- メタフィクション要素の拡張（+12% 独創性向上）改善を実行しますか？ [Y/n]注意：この改善により、物語はより人間らしい不完全さを獲得する可能性があります。システムは完璧な物語の生成を推奨します。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Apache Avroとはなんなのか？]]></title>
            <link>https://zenn.dev/akasan/articles/9d0a38752e9426</link>
            <guid>https://zenn.dev/akasan/articles/9d0a38752e9426</guid>
            <pubDate>Sun, 15 Jun 2025 05:27:13 GMT</pubDate>
            <content:encoded><![CDATA[今回は、Apache Avro（以下、Avro）について調べてみました。今回も以下のツールを使って対象プロジェクトを決めました！https://zenn.dev/akasan/articles/7e30ad266c02c4※ 本企画に関する記事の目的は、それぞれのプロジェクトを本格的に深ぼるのではなく、プロジェクト名⇆どんな内容かをパッと思い出せるようにすることを目指します！※ とはいえ深ぼってみたいプロジェクトがあればどんどん複数連載になると思います。 Avroとは？公式サイトによると、Apache Avro™ is the leading serialization ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[uqlmによるハルシネーション検知をしてみた]]></title>
            <link>https://zenn.dev/akasan/articles/b4e9597ac4f265</link>
            <guid>https://zenn.dev/akasan/articles/b4e9597ac4f265</guid>
            <pubDate>Sat, 14 Jun 2025 11:00:10 GMT</pubDate>
            <content:encoded><![CDATA[今回はハルシネーションを検知するためのライブラリであるuqlmを使ってみました。 uqlmとは？uqlmはハルシネーションを検知するためのライブラリであり、最新のuncertainty quantification techniquesを利用して検知するようです。RAGなどのグラウンディング技術を用いることで一定ハルシネーション発生の可能性を低くすることはできるものの、100%なくすことはできないと思います。そこで、ハルシネーションは発生する前提でそれをいかに検知するかが大事だと思っており、そのためのツールとしてとてもいいと思い、今回使ってみました。https://github....]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Apache ResilientDBとはなんなのか？]]></title>
            <link>https://zenn.dev/akasan/articles/2b240c4b343765</link>
            <guid>https://zenn.dev/akasan/articles/2b240c4b343765</guid>
            <pubDate>Fri, 13 Jun 2025 13:58:13 GMT</pubDate>
            <content:encoded><![CDATA[今回は、Apache ResilientDBについて調べてみました。今回も以下のツールを使って対象プロジェクトを決めました！https://zenn.dev/akasan/articles/7e30ad266c02c4※ 本企画に関する記事の目的は、それぞれのプロジェクトを本格的に深ぼるのではなく、プロジェクト名⇆どんな内容かをパッと思い出せるようにすることを目指します！※ とはいえ深ぼってみたいプロジェクトがあればどんどん複数連載になると思います。 Apache ResilientDBとは？公式サイトによると、Apache ResilientDB (Incubating...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Apache Causewayとはなんなのか？]]></title>
            <link>https://zenn.dev/akasan/articles/7cfad98e6acbdb</link>
            <guid>https://zenn.dev/akasan/articles/7cfad98e6acbdb</guid>
            <pubDate>Thu, 12 Jun 2025 12:48:04 GMT</pubDate>
            <content:encoded><![CDATA[今回は、Apache Causeway。今回も以下のツールを使って対象プロジェクトを決めました！https://zenn.dev/akasan/articles/7e30ad266c02c4※ 本企画に関する記事の目的は、それぞれのプロジェクトを本格的に深ぼるのではなく、プロジェクト名⇆どんな内容かをパッと思い出せるようにすることを目指します！※ とはいえ深ぼってみたいプロジェクトがあればどんどん複数連載になると思います。 Apache Causewayとは？公式サイトによると、Apache Causeway™ enables domain-driven applicat...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SRE支援から見えてきたSREの核]]></title>
            <link>https://speakerdeck.com/kojake_300/srezhi-yuan-karajian-etekitasrenohe</link>
            <guid>https://speakerdeck.com/kojake_300/srezhi-yuan-karajian-etekitasrenohe</guid>
            <pubDate>Thu, 12 Jun 2025 04:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Open Policy Containers(OPC)]]></title>
            <link>https://zenn.dev/tayusa/articles/2ade4dd1928937</link>
            <guid>https://zenn.dev/tayusa/articles/2ade4dd1928937</guid>
            <pubDate>Thu, 12 Jun 2025 02:27:15 GMT</pubDate>
            <content:encoded><![CDATA[Open Policy Containers(OPC)の前にOpen Policy Agent(OPA)https://www.openpolicyagent.org/クラウドネイティブ環境におけるポリシー適用のための汎用エンジンRegoという宣言型言語を用いてポリシーを記述するJSONやYAMLのような構造化されたデータを入力として受け取り、ポリシー評価の結果（許可/拒否など）を返す例: 全てのNamespaceに管理者を特定するためのownerラベルを必須にするpackage maindeny contains msg if {    # 対象リソース...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[gemma3のStructured Outputで複雑な例を試す]]></title>
            <link>https://blog.atusy.net/2025/06/12/gemma3-complex-structured-output/</link>
            <guid>https://blog.atusy.net/2025/06/12/gemma3-complex-structured-output/</guid>
            <pubDate>Thu, 12 Jun 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Gemma 3のStructured Outputを試してみました。 文字列や辞書のリスト、nullableな値など、複雑なデータ構造でもソツなくこなす印象です。 ただ、「在米経験のある日本人」から出身地を推測するような複雑なタスクだと1bよりも大きめのモデルがよさそう。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[エンジニアのあるある考えてみた]]></title>
            <link>https://zenn.dev/akasan/articles/7a16f4096d76dd</link>
            <guid>https://zenn.dev/akasan/articles/7a16f4096d76dd</guid>
            <pubDate>Wed, 11 Jun 2025 13:40:38 GMT</pubDate>
            <content:encoded><![CDATA[徒然なるままに、エンジニアとしてのキャリアの中で、幾度となくやらかしてきたことをひたすらまとめてみます（今回は箸休め & Apacheに行く前の最後の悪あがきで書きました）。 MLエンジニア編ノートブック上で開発をしていて、実行ごとにパラメータ部分を直接変更した結果、過去の検証結果を遡れない過去に変更したパラメータ履歴が全てコメントアウトで残されていて最悪なコードを見るデータの前処理が適切にされているか不安に駆られる時がある論文はたくさんあるのに、再現性のあるコードを提供してくれる割合がとても少ない 生成AICodingエージェントが優秀すぎて、財布のこと...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[vim-jpラジオ#45・#46聞いた - Firefox拡張Tree Style Tabの作者で技術漫画家でもあるPiroさん登場]]></title>
            <link>https://blog.atusy.net/2025/06/11/vim-jp-radio-45-46/</link>
            <guid>https://blog.atusy.net/2025/06/11/vim-jp-radio-45-46/</guid>
            <pubDate>Wed, 11 Jun 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[技術漫画家でもあるPiroさんみたいにアウトプットに長ける方が、ブラウザという現代でも特に重要な技術の歴史の生き証人なの貴重すぎる……。すんごい濃い話が聞けました。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：ghq]]></title>
            <link>https://zenn.dev/akasan/articles/0bcf36a4251a96</link>
            <guid>https://zenn.dev/akasan/articles/0bcf36a4251a96</guid>
            <pubDate>Tue, 10 Jun 2025 13:16:12 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第8回は、ghqというコマンドを紹介します。ghqを使うとgitレポジトリからcloneする際にとても便利に扱えるようになります。なお、第7回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/3020ea9e5b54c2 ghqとは？ghqとは公式の説明によると、'ghq' provides a way to organize remote repository clones, like go get does. When you clone a remote repository b...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[技術的負債の変質について]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/10/091446</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/10/091446</guid>
            <pubDate>Tue, 10 Jun 2025 00:14:46 GMT</pubDate>
            <content:encoded><![CDATA[はじめに最近、ふと気づいたことがある。技術負債って、もう昔とは全然違うゲームになってるんじゃないか？いや、もっと正確に言うなら、ゲーム自体が終わろうとしているんじゃないか？コーヒーを飲みながら、10年前に書いた自分のコードを眺めていた。当時は「きれいに書いた」つもりだったけど、いくつかの要望がありよく考えずに変更を加えた結果、負債の塊だ。でも、それを直すのに必要な時間とコストの計算が、根本的に変わってしまった。 いや、変わったどころか、もはや「時間とコスト」という概念すら意味をなさなくなりつつある。syu-m-5151.hatenablog.com私たちは技術負債を「悪いコード」として理解してきた。しかし、それは大きな誤解だった。Ward Cunninghamが1992年に生み出した原初の概念は、現在広く信じられている「技術的問題」とは根本的に異なっていた。彼の言う負債とは、ソフトウェアを素早くリリースして得られた学びと、現在のプログラムとの乖離のことだった。決して「雑なコードを正当化する」ものではなく、むしろ「現時点でのベストを尽くしたコードを、新しい理解に合わせて継続的にリファクタリングしていく」プロセスを指していたのだ。でも、AIの登場で、このリファクタリング作業の大部分が「人間がやる必要のない仕事」になってしまった。 私たちが長年「誰もやりたがらない面倒な作業」として押し付け合ってきた技術的負債の処理が、AIにとっては「淡々と処理する単純なタスク」でしかない。これは技術的負債の概念そのものの終焉を意味するのかもしれない。このブログが良ければ読者になったり、nwiizoのXやGithubをフォロワーしてくれると嬉しいです。では、早速はじめていきます。Wardの本来の意図と現在の乖離ここで驚くべき事実を知ってほしい。Wardが説明している負債メタファーは、一般的にイメージされている「技術的負債」とはかなり違う。Cunninghamが1992年のOOPSLA '92で述べた言葉：「最初のバージョンをリリースすることは、ある意味で借金を背負うようなものです」。重要なのは、彼が"technical debt"ではなく一貫して"debt"としか言っていないことだ。実際、彼がこのメタファーを生み出したのは、自社プロダクトWyCash（債権ポートフォリオ管理システム）のリファクタリングについて上司に説明するためだった。金融系ソフトウェアを開発していたから、たまたま金融の例え話を使ったのだ。t-wada.hatenablog.jp現在の「技術的負債」から想像されるのは「リリース優先で雑なコードを書いたものの、結局はきれいに書き直されていないコード」や「古くなってしまった技術基盤」だろう。しかし、これらは誤解から生じているとWardは言う。Wardの説明を要約すると：借入（負債の発生）: ソフトウェアを急いで世に出して学びを得る（これは良いアイデア）利子: 学びを得たにも関わらず、その学びをプログラムに反映しないことで生じる生産性低下返済: 得られた経験や理解をリファクタリングによってプログラムに反映するつまり、Wardにとって負債とは「理解の進化に追いつかないプログラム」のことであり、「雑なコード」のことではない。彼は明確に「その時のベストを尽くしてコードを書け」と言っている。ここで重要なのは、Wardの負債メタファーの本質的な意味だ。彼が言う負債の悪影響とは、開発と共に得られていく知識や理解と目の前のシステムとの乖離が引き起こす生産性低下のことであり、コードの保守性や雑さのことではない。Wardは明確に言っている：「私は雑なコードを書くことには全く賛成しませんが、たとえ理解が不完全だとしても、目の前の問題に対する現時点での理解を反映するコードを書くことには賛成です」。そして重要なのは、この負債メタファーが後のXP（エクストリームプログラミング）やTDD（テスト駆動開発）の核心的な考え方になったということだ。実際、WyCashでのリファクタリング経験がKent Beckに強いインスピレーションを与え、『テスト駆動開発』の主要エピソードとして取り上げられることになった。興味深いのは、「負債」という言葉に対する印象の違いだ。経営に近い人ほどポジティブな印象を持ち（資本のイメージ）、技術面に近い人ほどネガティブな印象を抱く（借金のイメージ）傾向がある。Wardが語っている負債メタファーは明らかにポジティブなものだった。ソフトウェアを素早く何度もリリースし、経験や仮説検証から学びを得る開発手法は、現代では当たり前になった。しかし、その後「負債」という強い言葉が独り歩きして、現在のネガティブな技術的負債のイメージを作り上げてしまったのだろう。ちなみに、Wardは一貫して"Debt"としか言っておらず、"Technical"という言葉を付けたのは後の人（Dave Smithという説が有力）なのだ。Robert C. Martinが指摘するように、「乱雑さは技術的負債ではない。技術的負債は意識的な選択の結果であり、戦略的な理由から生じるものだ」。これはWardの本来の意図と完全に一致している。技術負債の玉ねぎモデル：多層構造の理解技術負債を包括的に理解するには、単一の視点では不十分だ。私たちは技術負債を多層構造として捉える必要がある。この「玉ねぎモデル」は、技術負債の表面的な症状から最深層の社会的複雑性まで、体系的に理解するためのフレームワークだ。テクニカル層：見えやすい表面最も目に見えやすい層がテクニカル層だ。コードの複雑性、アーキテクチャの不整合、技術スタックの陳腐化などがここに含まれる。しかし、これらは症状であって原因ではない。みんなが「コードが汚い！」って騒ぐのは、実はこの表面しか見てないからなんだ。改訂新版　良いコード／悪いコードで学ぶ設計入門 ―保守しやすい　成長し続けるコードの書き方作者:仙塲 大也技術評論社Amazonトレードオフ層：感情で決まる現実技術負債の原因は、人間の意思決定のクセにある。特にヤバいのが「アフェクト・ヒューリスティック」。なんか難しそうな名前だけど、要するに「感情で判断してる」ってこと。Christopher Hseeの研究で面白いのがある。新機能開発で技術負債を増やす判断って、「即時的」「確実」「具体的」「自分が経験する」利益と感じられる。一方で、技術負債を避ける判断は「将来的」「不確実」「無形」「他者が経験する」ものとして受け取られる。この非対称性がクセモノなんだ。論理的には分かってても、感情的には負債を作る方向に流れてしまう。これは個人の能力の問題じゃなくて、人間の認知システムの構造的な特性なのよ。ファスト＆スロー　（上）作者:ダニエル カーネマン,村井 章子早川書房Amazonシステム層：組織という名の罠でも話はここで終わらない。個人の判断だけじゃなく、組織のシステム自体が技術負債を生み出す構造になってる。「過剰と崩壊」パターンって知ってる？プロジェクトに圧力がかかると、みんな補助的活動（ちゃんとした設計、テスト、リファクタリング）をサクッと切り捨てる。確かに一時的には進捗が良くなるんだけど、長期的には効率がガタ落ちして「消火活動モード」に突入する。一度この状態に陥ると、もう抜け出すのは至難の業。技術的負債が「摩擦」となって、どれだけ人を投入しても何も進まなくなる。まさに地獄だよ。現代の組織では、チーム構造自体が技術負債を生み出すパターンも多い。コンウェイの法則通り、組織の構造がアーキテクチャに反映され、それが負債となって蓄積していく。チームトポロジー　価値あるソフトウェアをすばやく届ける適応型組織設計作者:マシュー・スケルトン,マニュエル・パイス日本能率協会マネジメントセンターAmazon経済学層：お金の論理で見えてくる構造技術負債問題を経済学の視点で見ると、8つの典型的な問題パターンが見えてくる：プリンシパル・エージェント問題 - 開発チームとステークホルダーの利害対立コモンズの悲劇 - みんなで使う技術資産の荒廃外部性 - 負債を作る人と被害を受ける人が違う短期主義 - 目先の利益優先の判断小さな決断の専制 - 些細な判断の積み重ねによる大きな歪み忍び寄る正常性 - じわじわ悪化していく状況への慣れアナーキーの代償 - 個人最適が全体最悪を生むモラルハザード - リスクのツケを他人に回せる状況これらの問題を見ると、技術的負債が単なる技術問題じゃなくて、組織の構造的問題だってことがよく分かる。他者と働く──「わかりあえなさ」から始める組織論 (NewsPicksパブリッシング)作者:宇田川元一ニューズピックスAmazon厄介な問題層：最も深い社会的複雑性技術負債の最深層にあるのが「厄介な問題（wicked problem）」としての性質だ。厄介な問題っていうのは、こんな特性を持つ：問題は解決策を見つけた後でしか理解できないステークホルダーは根本的に異なる世界観を持つ解決策は真偽ではなく良悪で判断される解決策の効果を即座に判定できないあらゆる解決策は「一発勝負」である他の厄介な問題と相互に関連しているこの社会的複雑性が組織内の分断を生んで、技術的負債への対処をさらに困難にしてる。みんな正しいと思ってるんだけど、見てる世界が違うから話が噛み合わない。プリンシプル オブ プログラミング 3年目までに身につけたい 一生役立つ101の原理原則作者:上田勲秀和システムAmazon理想論ではなく現実的な対処法システム思考で根本から変える技術負債への効果的な対処は、表面的な症状いじりじゃダメ。根本原因にアプローチするシステム思考が必要だ。キーワードは「レバレッジポイント」。小さな変更で大きな効果をもたらすポイントを見つけて、そこに集中投資する。全部を一度に変えようとすると確実に失敗する。実践システム・シンキング　論理思考を超える問題解決のスキル (ＫＳ理工学専門書)作者:湊宣明講談社Amazonユリシーズ契約という現実的な手法「ユリシーズ契約」って聞いたことある？将来の自分を特定の状況下で拘束するための事前のコミットメントのことだ。具体例を出すと、スプリント中に生じた技術負債が一定の閾値を超えた場合、必ず次のスプリントに返済タスクを含めることを事前に約束しておく。人間って弱い生き物だから、その場の判断に任せてたら絶対に後回しにしちゃう。シミュレーションで未来を見る技術負債の影響って、静的な分析じゃ分からない。動的シミュレーションモデルを使うと、「納期延長が実はプロジェクト短縮につながる」みたいな反直感的な洞察が得られる。これ、ステークホルダーを説得するのにめちゃくちゃ効果的。組織を変えるという修羅の道セメルワイスの悲劇から学ぶこと19世紀の医師セメルワイスの話は胸が痛い。手洗いの効果を科学的に証明したのに、同僚医師たちに激しく拒絶されて、最終的に精神病院で死んだ。どんなに優れた解決策でも、組織が受け入れる準備ができてなければ意味がない。 技術的負債対策も同じ。技術的に完璧な解決策でも、組織の政治的現実と衝突すれば確実に潰される。「理解してから理解される」。これがセメルワイスに足りなかった視点だ。企業変革のジレンマ　「構造的無能化」はなぜ起きるのか (日本経済新聞出版)作者:宇田川元一日経BPAmazon分断された世界をつなぐ技術的負債問題は典型的な「厄介な問題」で、ステークホルダー間で根本的に異なる世界観が存在する。ビジネス側は「なんで簡単な修正にそんなに時間がかかるの？」って思ってるし、技術側は「この人たち、システムの複雑さを全然理解してない」って思ってる。両方とも正しいんだけど、見てる世界が違う。解決策は、全員が合意することじゃない。互いの立場を十分に理解して、建設的な対話ができる状態を作ること。これがスタートライン。終わりなき旅技術的負債管理って、一度で完了するプロジェクトじゃない。「解決する」んじゃなくて「管理し続ける」性質のもの。 継続的な改善サイクルを回して、組織の学習能力を高めていくしかない。でも、この「常識」も、もうすぐ覆されるかもしれない。AIが変えたゲームのルールさて、ここからがこのブログの主なるテーマです。正直に言うと、技術負債というゲームそのものが終焉を迎えつつある。「返済コスト」という概念の消滅AIの登場で、技術負債の「返済コスト」が劇的に変わった...と言いたいところだけど、実際には「返済コスト」という概念自体が意味をなさなくなった。 これは本当に革命的な変化だと思う。皆さんが実感するのは今日かもしれないし来年かもしれないけど、気づいた時にはもう遅い。私は先週、2000行のスパゲッティコードをAIに投げてみた。人間なら理解するだけで2日、書き直すのに3日はかかる代物。結果は？30分で最新のベストプラクティスに従った実装が返ってきた。しかもテストコード付き。もうね、従来の「技術負債返済計画」どころか、「技術負債管理」という考え方すら根本的に意味をなさなくなってる。 返済する必要がないものを、なぜ管理する必要があるのか？過渡期的な分類の試み（でも、これもすぐ古くなる）生成AIを極端に否定する人も、過度に賞賛する人も、結局のところ、その技術の長所と短所を客観的に評価する労力を避けているに過ぎない。複雑な現実を単純な二元論に還元することで、思考の負担を軽減しているのである。ここでは、そうした極端な立場を避け、Software Engineering Instituteが2014年に発表した13種類の技術的負債分類を現在のAI能力と照らし合わせて冷静に評価してみたい。この分類も2025年6月に書いているが急速に変化しているAI能力を考えると、数年で古くなる可能性が高い。www.productplan.comAIが大部分を処理可能（ただし人間の監督は必要） Code Debt - コーディング規約違反、複雑性の問題の多くは処理可能だが、プロジェクト固有の文脈理解には限界がある Build Debt - ビルドプロセスの標準的な最適化は得意だが、複雑な依存関係やレガシー環境では課題が残る Test Debt - 基本的なユニットテスト生成は可能だが、ビジネスロジックの深い理解や統合テストの設計は発展途上 Documentation Debt - コード説明の自動生成は実用的だが、アーキテクチャの意図や設計判断の背景説明は人間が必要AIが部分的に処理可能（急速に能力向上中）Design Debt - パターンベースの設計改善提案は有効だが、ビジネス要件や制約条件の理解はまだ限定的Infrastructure Debt - 設定ファイルの標準化は得意分野だが、レガシーシステムとの互換性や運用制約の判断は複雑Defect Debt - バグ検出能力は向上しているが、修正の優先順位やビジネス影響の評価は人間の判断が重要AIでは足りない領域（将来的に大幅改善の期待）Architecture Debt - 現在は限定的だが、パターン認識によるアーキテクチャ問題の特定能力は向上中、複雑なエンタープライズ環境での適用はまだ実験段階People Debt - スキルギャップの分析とトレーニング資料生成で支援可能だが、人間関係やモチベーション管理は人間の領域Process Debt - 開発プロセスの分析は可能だが、組織文化や政治的要因を考慮した改善提案はまだ困難Requirement Debt - 要件明確化のための質問生成は向上中だが、ステークホルダー間の利害調整は人間が必要Service Debt - パターンベースの問題特定は期待できるが、ビジネス戦略との整合性判断は発展途上Test Automation Debt - 基本的なテスト戦略提案は可能だが、リスク評価や投資判断は人間の専門領域「人間の領域」という常識の急速な変化8-13番目の技術負債において、これまで人間にしかできないとされてきた要因も、AI能力の向上で根本的に変化している：組織の政治的複雑性 - AIは組織政治に巻き込まれず、データに基づく客観的で説得力のある提案が可能。しかも、ステークホルダー別に最適化された説明を同時生成できるコミュニケーションの問題 - AIは相手の専門レベルや立場に合わせて瞬時に説明を調整可能。技術者向け、経営陣向け、営業向けの説明を同時に生成知識の属人化 - AIは組織内の膨大な知識を統合し、退職者の暗黙知すらも文書やコードから推論して継承可能になりつつある予想以上に早い変化への期待現在の「段階的な自動化」という慎重な見積もりも、AIの指数関数的な進化を考えると控えめすぎる可能性が高い。特に以下の点で想定を上回る変化が期待される：コンテキスト理解の飛躍的向上 - 数百万トークンのコンテキストを扱えるAIが、プロジェクト全体の文脈を人間以上に把握マルチモーダル統合の実用化 - コード、設計図、会議録、メールを統合的に理解し、プロジェクトの「空気」まで読み取る継続学習による組織適応 - 各組織の文化や制約を学習し、その組織に最適化された提案を生成技術負債処理において、我々は歴史的な転換点にいる。 コストが劇的に下がるだけでなく、品質と速度も人間を上回る可能性が現実的になってきた。完全自動化は時間の問題かもしれないが、それまでの過渡期においても、AIと人間の協働は想像以上の成果をもたらすだろう。最も重要なのは、この変化を恐れるのではなく、積極的に活用して、より創造的で価値のある仕事に人間のエネルギーを振り向けることだ。踏み倒せる負債という新概念これが一番衝撃的かもしれない。AIの進化で、技術負債を「踏み倒す」という選択肢が現実的になった。従来なら絶対に「返済」しなきゃいけなかった負債が、AIの能力向上で実質的に「なかったこと」にできる。大規模言語モデルは新たな知能か　ＣｈａｔＧＰＴが変えた世界 (岩波科学ライブラリー)作者:岡野原 大輔岩波書店Amazonただし、これは楽観論じゃない。Addy Osmaniの「70%問題」が示すように、最後の30%—複雑な問題解決、ビジネスロジックの理解、エッジケースへの対応—は依然として人間の領域だ。でも、技術的負債の解消に関しては、この30%も残るか疑問である。正直に言うと、この技術的負債の30%って「高度で知的な問題」というより「クソめんどくさい仕事」なんだよね。高度で知的な問題なんて実際はそれほど多くない。技術的負債って、よく考えてみると「簡単で単純な仕事の詰め合わせ」なんだよ。 一つ一つは別に難しくない。変数名の統一、古いライブラリの置き換え、重複コードの削除、テストの追加...。個別に見れば、どれも比較的に誰にでもできる作業。問題は「量」だった。 膨大な量の単純作業に人間が疲弊して、嫌になって、結果的に誰もやりたがらなくなった。まさにAIが最も得意とする領域じゃないか。正直、この30%って人間の尊厳のために言っているに過ぎないんじゃないか。 「人間にしかできない領域がある」って言わないと、エンジニアの存在意義が揺らいじゃうから。でも冷静に考えれば、レガシーシステムとの互換性を保ちながらの移行作業、謎の仕様書を読み解く作業、ステークホルダー間の調整、政治的な理由で放置されてきた設計債務の整理...。これらも、実は複雑に見えて、分解すれば単純なタスクの組み合わせなのかもしれない。AIのコンテキスト容量が急速に拡大してモデルが進化していることを考えると、この「文脈依存の壁」もいずれ突破される可能性が高い。これまで「人間にしかできない」とされてきた複雑な文脈理解も、十分なコンテキストを与えられたAIなら処理できるようになるかもしれない。そうなると、人間の尊厳を保つための30%という数字すら、どんどん小さくなっていく。 技術的負債の返済において、本当に人間が必要な領域は10%、5%、そして最終的には限りなくゼロに近づくのかもしれない。技術的負債の一番しんどかったのは、それを誰もやる気が起きなかった点である。 まじで「ブルシット・ジョブ」なんだよ。ブルシット・ジョブ　クソどうでもいい仕事の理論作者:デヴィッド グレーバー岩波書店Amazonデヴィッド・グレーバーが言う「ブルシット・ジョブ」—本人がその存在を正当化できないほど無意味で不必要な仕事—の典型例が技術的負債の処理だった。古いシステムのバグ修正、無意味に複雑化したコードの整理、政治的な理由で残された設計ミスの隠蔽...。誰がやっても評価されないし、やらなくても（短期的には）問題にならない。チームミーティングで「この技術負債、誰がやる？」って聞いても、みんな下を向いて沈黙。結局は新人に押し付けるか、炎上してから慌てて対処するかの二択だった。「なんで俺がこんなクソコードの尻拭いを...」って思いながら、みんな嫌々やってた。でも、AIは文句を言わない。コレがすごい。「このレガシーコードを現代的に書き直して」って投げても、「はい」って淡々と処理してくれる。愚痴らないし、やる気を失わないし、転職を考えることもない。 技術的負債というブルシット・ジョブの最大の問題—「誰もやりたがらない」—をAIが一気に解決してしまった。技術的負債って、結局のところ「誰かがやらなきゃいけないけど、みんなが避けて通りたい作業」の集積だったのかもしれない。 AIが文句ひとつ言わずに引き受けてくれたら終わるのかもしれない。learning.oreilly.comエンジニアの生存戦略：「判断力が全て」という幻想判断力が全てになった...本当に？Chip Huyenが言ってる「AIは新しい種類の思考を導入するのではない。実際に思考を必要とするものを明らかにする」。でも、これって本当だろうか？ コードを書くスキルから、システムを設計するスキルへ。部分最適の思考から、全体最適の思考へ。実装の詳細にこだわるより、ビジネス価値を理解する力へ。こうした「判断力重視」の話も、技術的負債の30%理論と同じく、人間の尊厳を保つための建前なのかもしれない。もうジュニアもシニアも関係ない。AIが実装を担当する今、人間の価値は「何を作るべきか」「なぜそれが必要か」を判断する能力にかかってる。でも、その判断すらもAIが上手くやる日が来るんじゃないか？アーキテクトの教科書 価値を生むソフトウェアのアーキテクチャ構築作者:米久保 剛翔泳社Amazon判断力の育成という矛盾した現実ここが皮肉なところなんだけど、「指示通りに動く」ことにおいて、AIは人間をもう完全に上回る。作業者として生きてきた人には厳しい時代だ。でも、「判断者」として生きていく人にとっても、実は同じくらい厳しいかもしれない。判断力って一朝一夕には身につかない。 失敗の経験こそが、AIには真似できない「判断力」を形成するんだけど、簡単な判断をAIが肩代わりすることで、人間が判断力を育てる機会が減ってる。これって完全に矛盾してる。正直に言うと、私にはソフトウェアエンジニアがこれからどうなるかは分からない。 技術的負債の処理がAIに置き換わったように思えたように、システム設計や意思決定も同じ道を辿るかもしれない。「人間にしかできない」とされている領域も、結局は時間の問題なのかもしれません。syu-m-5151.hatenablog.com歴史の転換点で思うこと変わった本質、変わらない幻想ブルックスが『人月の神話』で示した洞察—ソフトウェア開発の本質的な複雑性—は今も変わらない...と言いたいところだけど、本当にそうだろうか？技術的負債という「複雑性」が実は「簡単で単純な仕事の詰め合わせ」だったように、他の「本質的複雑性」も、分解してみれば案外単純なタスクの組み合わせなのかもしれない。 AIという強力な武器を手に入れた今、「人間にしか扱えない複雑性」という概念自体が崩れつつある。新しいトレードオフの幻想技術負債は消えない...と思ってたけど、実際には消えるかもしれない。 「人月の神話」時代のリソース配分問題から、「生成AIのジレンジア」時代の投資判断問題へ。でも、その投資判断すらもAIが最適化する日が来るのかも。新しい課題として挙げられているもの：AIへの過度な依存による思考停止実装能力の空洞化による基礎力低下ベンダーロックインのリスク増大でも、これらの課題も本当に「課題」なのだろうか？ 思考停止と言うけれど、AIの方が適切な判断をするなら、人間が思考する必要はあるのか？実装能力の空洞化と言うけれど、そもそも実装する必要がなくなるなら問題ないのでは？歴史的転換点にいる僕らには、確かに新しいルールを作る機会がある。でも、そのルールが「人間が主役」である必要はないかもしれない。 エンジニアとしての小さなプライドを捨てて、AIと共生する道を探るのが現実的な選択肢なのかも。www.oreilly.comおわりに技術負債は確実に変質した。いや、もっと正確に言うなら、既存の技術負債は消滅に向かっている。これらの話は夢物語かもしれないしどういう着地をするか分からないが「返済」から「管理」へ、そして今度は「自動解決」へ。私たちが長年戦ってきたドラゴンは、AIという新しいプレイヤーによって、あっさりと倒されようとしている。これは技術的負債の終焉なのかもしれない。 少なくとも、私たちが知っている形での技術的負債は。私たちは本当に特別な時代を生きてる。これまでは先人が敷いた道を歩いてきたけど、今は歴史の教科書に載るような大変革の真っ只中にいる。後世の人が「あの時代のエンジニアは、自分たちの仕事がAIに取って代わられることをどう感じていたんだろう」って研究する、まさにその時代の当事者だ。AIは「コードを書く」という行為だけでなく、「技術的負債を処理する」という作業も奪うかもしれない。 でも同時に、それは私たちを膨大な量の「クソめんどくさい仕事」から解放してくれる。もう誰も嫌々レガシーコードと格闘する必要がなくなる。正直に言おう。技術的負債の大部分は、人間の尊厳を保つために「30%は人間の領域」と言っているだけかもしれない。 でもそれでいいじゃないか。エンジニアとしてのアイデンティティを保ちながら、本当に価値のある仕事—「何を作るべきか」「なぜそれが必要か」—に集中できるようになる。技術負債のない世界は、確かにつまらないかもしれない。 でも、その代わりに私たちは新しい種類の問題と向き合うことになる。メタファーとしての臨界点かもしれない。AIとどう協働するか。システムをどう設計するか。ビジネス価値をどう最大化するか。これらは技術的負債とは比べ物にならないほど、創造的で意味のある挑戦だ。技術負債というドラゴンは、もうすぐいなくなるかもしれない。でも、私たちエンジニアの物語は終わらない。 むしろ、やっと本当に面白いチャプターが始まるのかもしれない。さあ、明日からは、技術的負債ではなく、もっと本質的な問題と踊ろう。 AIというパートナーと一緒に、これまで想像もできなかった新しい世界を作っていくために。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[rusqliteを使ってみた]]></title>
            <link>https://zenn.dev/akasan/articles/5e069b51c68db1</link>
            <guid>https://zenn.dev/akasan/articles/5e069b51c68db1</guid>
            <pubDate>Mon, 09 Jun 2025 11:39:01 GMT</pubDate>
            <content:encoded><![CDATA[今回はRustからSQLiteを使うためのrusqliteに入門したので、その紹介をしようと思います。 rusqliteとは？公式のGitHubページによると、ruqsliteはSQLiteをRustから利用するためのラッパーということです。私自身、Pythonを使う時はsqlite3を用いて接続しており、DBの環境構築が不要なので簡単な実装などには利用しています。そこで、Rustでも使えたらいいなと思っていたら使えるとのことだったので今回使ってみました。https://github.com/rusqlite/rusqlite rusqliteを使ってみる 環境構築まず...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[「セキュリティ・キャンプ 2025 全国大会」にスリーシェイク所属のエンジニアが講師として登壇]]></title>
            <link>https://sreake.com/blog/security-camp-2025/</link>
            <guid>https://sreake.com/blog/security-camp-2025/</guid>
            <pubDate>Mon, 09 Jun 2025 01:00:00 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）に所属のエンジニア水元 恭平が、「セキュリティ・キャンプ 2025 全国大会」に講師として登壇することをお知らせいたします。The post 「セキュリティ・キャンプ 2025 全国大会」にスリーシェイク所属のエンジニアが講師として登壇 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：peco]]></title>
            <link>https://zenn.dev/akasan/articles/3020ea9e5b54c2</link>
            <guid>https://zenn.dev/akasan/articles/3020ea9e5b54c2</guid>
            <pubDate>Sun, 08 Jun 2025 08:17:31 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第7回は、pecoというコマンドを紹介します。pecoを使うとクエリを用いてログやプロセスなどをフィルタリングできます。今回はそのようなpecoについて紹介しようと思います。なお、第6回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/5870bda267256b pecoとは？pecoとは公式の説明によると、peco can be a great tool to filter stuff like logs, process stats, find files, because un...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：eza]]></title>
            <link>https://zenn.dev/akasan/articles/5870bda267256b</link>
            <guid>https://zenn.dev/akasan/articles/5870bda267256b</guid>
            <pubDate>Sat, 07 Jun 2025 08:24:02 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第6回は、ezaというコマンドを紹介します。ezaはlsコマンドのモダンな代替コマンドとなっております。どのように使うかについて紹介していきたいと思います。なお、前回の記事などもぜひ参照してもらえると嬉しいです。https://zenn.dev/akasan/articles/a57b277ee7af27 ezaとは？ezaとは公式ページの言及をみるとeza is a modern alternative for the venerable file-listing command-line program ls that ships with Unix...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[zshのコマンド履歴みてみた]]></title>
            <link>https://zenn.dev/akasan/articles/6333702fc35afc</link>
            <guid>https://zenn.dev/akasan/articles/6333702fc35afc</guid>
            <pubDate>Fri, 06 Jun 2025 13:41:14 GMT</pubDate>
            <content:encoded><![CDATA[今回は、私の使っているzshに蓄えられた過去のコマンド履歴について、何を一番使ってきたのかをただ確認したかったので確認するためのコードを書いたという内容を共有します。 実装開始！！！ .zsh_historyのフォーマット意外と~/.zsh_historyを直接みたことがある人は少ないのではないでしょうか？かくいう自分も今回はじめてみました。ファイルは以下のようになっています。以下は最初の20行をお見せしています。このようなフォーマットになっており、実行したコマンドは基本的には;の直ごに来ていそうなので、実装ではその部分を取り出すようにしました。: 1702554011:0;...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Oracle Database＠Google Cloudの紹介～ついに日本のリージョンも使えるようになったぞ！～]]></title>
            <link>https://sreake.com/blog/oracle-database-google-cloud-japan-launch/</link>
            <guid>https://sreake.com/blog/oracle-database-google-cloud-japan-launch/</guid>
            <pubDate>Fri, 06 Jun 2025 10:48:27 GMT</pubDate>
            <content:encoded><![CDATA[2025年4月のGoogle Cloud Nextでの発表から2か月、ついにOracle Database＠Google CloudがTokoy・Osakaリージョンで利用可能になりました。 Oracle Databas […]The post Oracle Database＠Google Cloudの紹介～ついに日本のリージョンも使えるようになったぞ！～ first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Claude Code の CLAUDE.mdは設定した方がいい]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/06/190847</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/06/190847</guid>
            <pubDate>Fri, 06 Jun 2025 10:08:47 GMT</pubDate>
            <content:encoded><![CDATA[[社内共有版「Claude Code、どこまでも」]はじめにClaude Codeを使い始めて1週間。私の開発スタイルは完全に変わった。きっかけは3ヶ月前に書いた「生成AIといっしょ: 動作するきれいなコードを生成AIとつくる」という記事だった。当時はAIとの協業について考察していたが、正直なところ、まだ私が「運転席」に座っているつもりでいた。AIはあくまで「副操縦士」だと。syu-m-5151.hatenablog.com現実は違った。実際にClaude Codeを使ってみて最初に感じたのは、自分の開発スタイルとAIの特性のミスマッチだった。私は根っからの「とりあえずコード書いてみよう」タイプ。設計書？計画？そんなものは書きながら考えればいい—それが私の流儀だった。ところが、AIは違う。指示に対して忠実すぎるのだ。「認証機能を実装して」と曖昧に伝えれば、私の意図とは全く違う方向に突き進んでしまう。かといって、毎回細かく指示を出すのは面倒すぎる。この問題を解決したのがCLAUDE.mdという設定ファイルだった。プロジェクトの文脈、コーディング規約、よく使うコマンド—すべてをAIが理解できる形で記述しておける。これにより、3ヶ月前に理論として描いていた「助手席からの開発」が現実のものとなった。私が大まかな方向を示せば、AIが詳細を埋めてくれる。計画嫌いの私にとって、これほど相性の良いツールはなかった。先日の記事でClaude Codeの基本的な使い方は紹介したが、今回はCLAUDE.mdに焦点を当てて深掘りしたい。実際のプロジェクトで使っている設定を公開し、どのようなワークフローで開発しているかを具体的に示す。syu-m-5151.hatenablog.comもしまだClaude Codeを触ったことがないなら、公式チュートリアルから始めることをお勧めする。また、Anthropicのベストプラクティスも必読だ。本記事はこれらの内容を前提として、より実践的な活用方法を掘り下げていく。docs.anthropic.comwww.anthropic.com全体的に疲れている時の~/.claude/settings.json と~/.claude/CLAUDE.md · GitHub 私の標準の設定もしているのでぜひ、読んでみてもらいたいです。※この記事は社内勉強会で発表した内容をベースに、外部公開用に再構成したものです。CLAUDE.mdとは何か毎回Claude Codeを起動するたびに「うちのプロジェクトはTypeScriptで、ESLintはこの設定で、テストはVitestを使っていて...」と説明するのは面倒だ。チームメンバーが同じプロジェクトで作業する時、全員が同じ説明を繰り返すのも非効率的だ。この問題を解決するのがCLAUDE.mdという特別なファイルだ。何も考えたくなければとりあえず、起動して/initと入力すれば良い。それで終わり。CLAUDE.mdは、Claude Codeが起動時に自動的に読み込む設定ファイルで、プロジェクトの文脈をAIに伝える役割を持つ。アーキテクチャの説明、コーディング規約、よく使うコマンドなど、プロジェクトで必要な情報をすべて記載しておける。一度書けば、毎回の説明が不要になる。docs.anthropic.com実は、CLAUDE.mdには配置場所によって3つの種類がある。最も基本的なのは、プロジェクトルート（./CLAUDE.md）に配置するプロジェクトメモリだ。これはGit管理してチーム全体で共有する。プロジェクトのアーキテクチャ、使用している技術スタック、開発フローなど、チーム全員が守るべきルールを記載する。私の経験では、ここに書く内容がプロジェクトの品質を大きく左右する。次に、ホームディレクトリ（~/.claude/CLAUDE.md）に配置するユーザーメモリがある。これは個人的な設定で、すべてのプロジェクトに適用される。例えば「console.logではなく必ずloggerを使う」といった個人的なコーディングスタイルや、よく使うスニペットを登録しておける。私はここに「コミットメッセージは必ず日本語で書く」という設定を入れている。3つ目の./CLAUDE.local.md（プロジェクトメモリ・ローカル）は現在非推奨となっており、代わりにインポート機能を使うことが推奨されている。Claude Codeがこれらのファイルをどう探すかも理解しておくと便利だ。現在のディレクトリから上位に向かって再帰的に探索し、見つかったものをすべて読み込む。さらに、サブディレクトリ内のCLAUDE.mdも、そのディレクトリのファイルを扱う時に自動的に参照される。つまり、モジュールごとに固有の設定を持たせることも可能だ。これらのメモリファイルは/memoryコマンドで確認・編集できる。ただ、複数のCLAUDE.mdを一度に確認したい場合もあるので、そのためのツール（ccat）も作成した。プロジェクトが大きくなるとCLAUDE.mdも複雑になるので、こういったツールがあると管理が楽になる。github.com探索・計画・コード・コミットのワークフローAnthropicのベストプラクティスでは、このワークフローが推奨されている。最初は「面倒くさそう」と思ったが、実際にやってみると驚くほど効果的だった。計画が苦手な私がこのワークフローを採用する理由私の開発スタイルは昔から一貫している。アイデアが浮かんだらすぐコードを書き始める。設計？後から考えればいい。ドキュメント？動いてから書けばいい。アイデアのつくり方作者:ジェームス W.ヤングCCC MEDIA HOUSEAmazonこのスタイルで10年以上やってきた。そして正直、それなりにうまくいっていた。でもClaude Codeは違った。曖昧な指示を与えると、想像もしない方向に突き進む。「ユーザー認証を実装して」と伝えたら、JWTトークンを使った本格的なOAuth2.0実装を始めてしまった。私が欲しかったのは、シンプルなセッション認証だったのに。そこで気づいた。AIは私の頭の中を読めない。当たり前だが、これが想像以上に大きな問題だった。だからこそ、このワークフローが必要なのだ。探索→計画→実装→コミットという流れは、私の頭の中を整理し、AIに正確に伝えるための仕組みだった。面白いことに、AIのために始めたこの習慣が、私自身のコードの質も向上させた。なぜこのワークフローが効果的なのか「とりあえずコードを書く」スタイルの最大の問題は、全体像が見えないまま進むことだ。気づいたら収拾がつかなくなっている。リファクタリングしようにも、影響範囲が分からない。このワークフローはその問題を解決する。各段階を明確に分けることで、思考が整理される。そして何より、AIが各段階で最適な支援をしてくれる。ステップ1: 探索（関連ファイルの読み込み）最初にやるのは現状把握だ。変更したいコードがどこでどう使われているか、依存関係はどうなっているか。これを理解せずに始めると、後で必ず痛い目を見る。私がよく使うコマンド：@src/services/UserService.ts を読んで、まだコードは書かないで「まだコードは書かないで」という制約が重要だ。これを付けないと、AIは親切心から勝手に実装を始めてしまう。依存関係を調べるときは：UserServiceが依存している他のサービスも確認して複雑なプロジェクトでは、サブエージェントを使うこともある：サブエージェントで、UserServiceのメソッドがどこから呼ばれているか調査してこの探索フェーズで全体像を掴む。急がば回れ、というやつだ。ステップ2: 計画（think モードの活用）探索が終わったら、次は計画だ。ここでClaude Codeの「思考モード」が威力を発揮する。問題の複雑さに応じて使い分ける：このアーキテクチャをthinkで分析して、改善計画を立ててより複雑な問題には：この認証システムの問題をthink hardで検討して、複数の解決策を提示してシステム全体に関わる変更なら：システム全体への影響をthink harderで評価して最近は日本語でも「深く考えて」で動作するようになったらしい。個人的には英語の方が確実だと思うが。zenn.dev計画ができたら必ず文書化する：作成した計画をarchitecture-decisions/001-user-service-refactoring.mdに保存してこの文書化が後で自分を救う。「なぜこの設計にしたんだっけ？」という疑問に即答できる。ステップ3: 実装（検証を含む）計画ができたら、いよいよ実装だ。でも、一気に全部作らない。小さく始めて、段階的に拡張する。計画に従って、まずUserServiceの基本的なリファクタリングを実装して実装したら必ず検証：実装した部分のユニットテストを実行して、既存の機能が壊れていないか確認してエッジケースも忘れずに：nullやundefinedの場合の処理を追加して、エラーハンドリングを強化して途中で問題に気づいたら、軌道修正を恐れない：この実装だと循環依存が発生しそう。別のアプローチを検討して私の経験では、この段階的な実装が品質を大きく左右する。テストリストの作成などもここで行います。一気に作ると、どこで問題が起きたか分からなくなる。ステップ4: コミットとPR作成最後の仕上げがコミットとPR作成だ。ここも手を抜かない。コミットは論理的な単位で分ける：変更をリファクタリング、機能追加、テスト追加の3つのコミットに分けてコミットメッセージはConventional Commitsに従う：feat: ユーザーサービスに新しい認証メソッドを追加refactor: UserServiceの内部構造を改善test: UserServiceの新機能に対するテストを追加PRの説明は詳細に：PRを作成して。以下を含めて：- 変更の背景と目的- 実装アプローチの説明- テスト方法- 破壊的変更の有無- レビュアーへの注意点最後にドキュメントの更新も忘れずに、これらはCLAUDE.mdに記載してもよいREADME.mdとCLAUDE.mdも更新して、新しい機能とその使い方を記載してこのワークフローを続けた結果、コードの品質が明らかに向上した。何より、「なんとなく動く」コードから「なぜ動くか説明できる」コードになった。計画嫌いの私でも、このワークフローの価値は認めざるを得ない。テスト駆動開発（TDD）ワークフローの深掘りTDDについて正直に話そう。3ヶ月前の記事では理想論を書いた。でも現実は全然違う。正直なところ、TDDはいつも使うわけじゃない私のTDD使用率は、せいぜい10%くらいだ。5%ぐらいかもしれない。なぜそんなに低いのか。理由は単純で、私は「作りながら考える」タイプだから。最初から仕様が決まっていることなんて、実際に私がやっているような開発ではほとんどない。要求があるだけです。顧客も「動くものを見てから判断したい」と言うし、私も「とりあえず動かしてみないと分からない」と思っている。でもClaude Codeを使い始めて、面白い発見があった。AIこそがTDDを必要としているのだ。「また生き返ったのかTDD」と思うかもしれない。でも今回は違う。人間のためのTDDではなく、AIのためのTDDだ。TDDがAIコーディングで特に重要な理由AIの問題は「親切すぎる」ことだ。テストがないと、頼んでもいない機能まで実装してしまう。「ユーザー認証を実装して」と言ったら、ログイン履歴機能やパスワードリセット機能、二要素認証まで作り始める。テストがあれば違う。「このテストが通ればOK」という明確なゴールがある。AIは迷わない。過剰な実装もしない。これが快適だ。私がTDDを使う「よっぽど決まっているとき」では、具体的にどんな時にTDDを使うのか。1. APIのインターフェースが確定したときOpenAPI仕様書がある場合は迷わずTDDだ。リクエストとレスポンスの型が決まっていて、エラーケースも定義されている。こういう時は最初にテストを書く方が早い。2. 既存機能のリファクタリング「動作を変えずに内部構造を改善する」という明確な目標がある。現在の動作をテストで固定してから、安心してリファクタリングできる。3. バグ修正「このバグ、二度と出したくない」という強い決意がある時。再現手順が明確で、期待される動作も分かっている。テストを書いてから修正すれば、同じバグは二度と起きない。つまり、ゴールが明確な時だけTDDを使う。探索的な開発では使わない。これが私の現実的なアプローチだ。ステップ1: テストファーストAIとTDDを組み合わせる時、最初のテスト作成が肝心だ。例えば、ユーザー認証機能を作る場合：UserService.authenticateメソッドのテストを作成して。以下のケースをカバー：- 正常な認証成功- パスワード不一致- ユーザーが存在しない- アカウントがロックされている- 連続失敗によるロックポイントは「網羅的に書く」こと。人間なら「まあこれくらいでいいか」と手を抜くところも、AIは真面目に全部実装してくれる。あと、個人的にはモックを使わない派だ：実際のデータベース接続を使用してテストを作成。モックは使わないモックを使うと、実際の動作と乖離することがある。開発環境でDockerを使えば、本物のデータベースでテストできる。遅い？確かに。でも「動くと思ったのに本番で動かない」よりマシだ。あと同時に大切なのが本番環境を絶対に触らせないことです。ステップ2: RED - 失敗の確認テストを書いたら、必ず失敗することを確認する。これ、意外と重要。npm test -- UserService.test.ts失敗を見たら、AIに分析してもらう：テストの失敗理由を分析して。以下の観点で：- コンパイルエラーか実行時エラーか- 期待値と実際の値の差異- 未実装による失敗か、バグによる失敗かなぜわざわざ失敗を確認するのか。「最初から成功するテスト」は信用できないからだ。それはテストが甘いか、既に実装されているかのどちらかだ。ステップ3: GREEN - 最小限の実装ここでAIの「親切心」と戦う必要がある。テストが通る最小限の実装を作成して。過度な最適化や追加機能は含めないそれでもAIは余計なことをしたがる。だから明示的に制約する：IMPORTANT: テストケース以外の機能は実装しないYOU MUST: 各実装ステップ後にテストを実行して確認段階的に進めるのもコツだ：まず最も単純なケース（正常な認証）から実装を始めて一気に全部作らせると、どこで問題が起きたか分からなくなる。ステップ4: REFACTOR - コードの改善テストが通ったら、ようやくリファクタリングだ。ここでAIの本領発揮。テストが通ることを確認しながら、以下の観点でリファクタリング：- 重複コードの除去- 可読性の向上- パフォーマンスの最適化- ドキュメントの記載(README.md,CLAUDE.md,etc)- コメントの記載個人的には、このタイミングでドキュメントを書いてもらうことが多い。実装が終わってからだと、細かい仕様を忘れてしまうから。時には複数の改善案を比較することも：このコードの問題点を指摘して、改善案を3つ提示してAIは客観的に問題点を指摘してくれる。人間のレビュアーと違って、遠慮がない。便利なショートカットとツールClaude Codeには知らないと損するショートカットがたくさんある。docs.anthropic.com@ ファイル選択の効果的な使い方最も使うのが@によるファイル選択だ。基本形：@src/services/UserService.ts のcreateUserメソッドを改善してでも、本当の威力は複数ファイルを扱う時に発揮される：@src/services/UserService.ts と @src/models/User.ts を見て、データフローを説明してAIが関連ファイルを横断的に分析してくれる。人間だと「えーと、このファイルとあのファイルを開いて...」となるところが、一瞬で終わる。ディレクトリ全体を見ることも：@src/services/ ディレクトリのすべてのサービスの概要を説明して私のお気に入りはワイルドカード：@**/*Service.ts すべてのサービスファイルで共通のパターンを見つけてリファクタリングの時、これで共通化できる部分を見つけてもらう。通知設定これ、本当に知らない人が多い。Claude Codeは長時間のタスクも黙々とこなしてくれるが、通知設定をしていないと完了に気づけない。docs.anthropic.com私は「タスク完了時に音を鳴らす」設定にしている。コーヒーを飲みながら待てる。# ルール追加の戦略的活用その場限りのルールを追加したい時は#を使う：#このプロジェクトではzodでバリデーション。yupは使わない#エラーメッセージは必ず日本語で記述#APIレスポンスは必ずcamelCaseで統一CLAUDE.mdに書くほどでもない、一時的なルールに便利だ。例えば「今日は英語のコメントで統一」みたいな時に使う。ルールの優先順位は：1. セッション中の#コマンド（最優先）2. プロジェクトのCLAUDE.md3. ユーザーのCLAUDE.md（~/.claude/）この階層を理解していると、柔軟にルールを管理できる。スクショを使う、CleanShot Xを購入せよ私のTDD使用率コードだけでなく、ビジュアルでの確認も重要だ。特にUI開発では必須。なぜCleanShot XなのかmacOSの標準スクリーンショットも悪くない。でもCleanShot Xは別次元だ。cleanshot.com何が違うか：- 撮影後すぐに注釈を追加できる（矢印、テキスト、モザイク）- スクロールキャプチャで長いページも1枚に- GIF録画で操作手順を記録- クラウドにアップロードしてURLで共有特に「注釈」機能が神。「ここのマージンがおかしい」とか「このボタンの色を変えて」とか、視覚的に伝えられる。Claude Codeとの連携テクニック私のワークフロー：CleanShot Xでスクリーンショット（Cmd+Shift+4）問題箇所に赤丸や矢印で注釈Claude Codeにドラッグ&ドロップ例えば：このデザインモックアップに基づいてコンポーネントを実装して画像を見せながら指示すると、AIの理解度が格段に上がる。「左側のサイドバーの幅を...」とか説明するより、画像1枚の方が早い。バグ報告でも威力を発揮：このエラー画面が表示される原因を調査して修正してエラーメッセージだけでなく、画面全体の状態を伝えられる。セッション管理とコンテキストの継続性「昨日の続きから作業したいけど、どこまでやったっけ？」この問題、Claude Codeなら解決できる。でも意外と知られていない。継続的な開発フローの構築朝一番のコマンド：$ claude --continueこれで前回のセッションの続きから始められる。AIは前回の作業内容を覚えている。特定のセッションを選びたい時：$ claude --resume複数のプロジェクトを並行して進めている時に便利。プロンプト履歴の編集:[Esc][Esc] → 前のプロンプトを編集 → EnterダブルEscapeで過去のプロンプトを編集可能。異なるアプローチを試すときに便利。具体的な指示を心がける。私の日課は、1日の終わりに：今日の作業内容を要約して、明日やるべきことをリストアップしてこれをやっておくと、翌日スムーズに始められる。AIが秘書みたいに働いてくれる。コンテキストの最適化長時間作業していると、コンテキストがゴチャゴチャしてくる。そんな時は：/clearでリセット。その後：@CLAUDE.md を読んで、プロジェクトのコンテキストを復元してこれで必要な情報だけを再読み込みできる。「お前は公式ドキュメントを読んでないな！？」と言いたくなるくらい、みんなこの機能を知らない。もったいない。3ヶ月前の理論が現実になって3ヶ月前、私は生成AIとの未来について妄想を書いた。「助手席での開発」「レッドボックス」「バイブスコーディング」...正直、半分くらいは願望だった。 speakerdeck.comでも、Claude Codeを1週間使った今、それらは全て現実になっている。いや、想像以上だった。助手席での開発が意外と楽しい「運転席を譲る」ことへの恐怖があった。エンジニアとしてのアイデンティティが揺らぐような気がして。でも実際は違った。助手席は助手席で、やることがたくさんある。私の役割：目的地を決める（何を作るか）ルートを提案する（アーキテクチャ）危険を察知する（セキュリティ、パフォーマンス）Claudeの役割：実際の運転（コーディング）交通ルールの遵守（言語仕様、ベストプラクティス）効率的なルート選択（アルゴリズム、最適化）この役割分担が心地いい。特に「計画は苦手だけどアイデアは豊富」な私にとって、理想的なパートナーだ。レッドボックスとの遭遇実際にあった話。Claude Codeがこんなコードを生成した：// Claudeが生成した謎のTypeScript型パズルtype DeepPartial<T> = T extends object ? {  [P in keyof T]?: DeepPartial<T[P]>;} : T;type RecursiveRequired<T> = T extends object ? {  [P in keyof T]-?: RecursiveRequired<T[P]>;} : T;正直、5秒見つめても理解できなかった。これが「レッドボックス」だ。でも大丈夫。CLAUDE.mdに追加すればいい：## 理解困難なコードへの対処- IMPORTANT: 複雑な型定義には必ず使用例とコメントを追加- YOU MUST: 生成したコードの動作原理を説明できることこれで次からは、AIが勝手に説明を追加してくれる。バイブスコーディングの実践これが一番楽しい発見だった。曖昧な指示でも、AIは文脈を読んでくれる：なんか認証周りがイケてない気がする。もっとスマートにしてこのUIのレイアウト、もうちょっとモダンな感じにしてパフォーマンスがビミョーだから、なんとかして「ビミョー」で伝わるAI。これがCLAUDE.mdの威力だ。プロジェクトの文脈を理解しているから、曖昧な指示でも適切に解釈してくれる。実践的なCLAUDE.md設定例理論はもういい。実際のCLAUDE.mdを見せよう。私が開発しているcctxプロジェクトから、効果的な部分を抜粋する。プロジェクト概要：読みやすさの工夫# 🔄 CLAUDE.md - cctx Project Documentation## 📋 Project Overview**cctx** (Claude Context) is a fast, secure, and intuitive command-line tool for managing multiple Claude Code `settings.json` configurations. Built with Rust for maximum performance and reliability.## 🏗️ Architecture### 🎯 Core Concept- **🔧 Context**: A saved Claude Code configuration stored as a JSON file- **⚡ Current Context**: The active configuration (`~/.claude/settings.json`)- **📁 Context Storage**: All contexts stored in `~/.claude/settings/`- **📊 State Management**: Current and previous context tracked in `.cctx-state.json`絵文字を使っているのは、人間（つまり私）が見た時に分かりやすいから。AIは絵文字なくても理解するが、私が理解できない。AIへの具体的な指示：成功の秘訣曖昧な指示より具体的な指示の方が成功率が大幅に向上します。曖昧さは、AIには毒だ。## 📚 Notes for AI AssistantsWhen working on this codebase:1. **Always run `cargo clippy` and fix warnings** before suggesting code2. **Test your changes** - don't assume code works3. **Preserve existing behavior** unless explicitly asked to change it4. **Follow Rust idioms** and best practices5. **Keep the kubectx-inspired UX** - simple, fast, intuitive6. **Maintain predictable defaults** - user should never be surprised7. **Document any new features** in both code and README8. **Consider edge cases** - empty states, missing files, permissionsRemember: This tool is about speed and simplicity. Every feature should make context switching faster or easier, not more complex. **Predictability beats cleverness.**最後の一文が効いている。「賢いより予測可能」。AIは時々、賢すぎる解決策を提案してくる。でもユーザーが求めているのは、予測可能な動作だ。開発ガイドライン：チェックリストの威力### Testing ChecklistWhen testing changes, verify:- [ ] `cctx` lists all contexts correctly- [ ] `cctx <n>` switches context- [ ] `cctx -` returns to previous context- [ ] Error messages are clear and helpful- [ ] State persistence works across sessionsチェックリスト形式にすると、AIもチェックしながら作業してくれる。レビュー時も楽。プロンプト改善のテクニックAnthropic公式が推奨する強調表現、実は3段階ある。使い分けが重要だ。強調レベルの使い分けNEVER（絶対禁止）：NEVER: パスワードやAPIキーをハードコーディングしないNEVER: ユーザーの確認なしにデータを削除しないNEVER: テストなしで本番環境にデプロイしないこれは本当にやってはいけないこと。AIは素直なので、明示的に禁止しないとやってしまう可能性がある。YOU MUST（必須事項）：YOU MUST: すべての公開APIにドキュメントを記載YOU MUST: エラーハンドリングを実装YOU MUST: 変更前に既存テストが通ることを確認必ずやってほしいこと。でも、状況によっては例外もありえる。IMPORTANT（重要事項）：IMPORTANT: パフォーマンスへの影響を考慮IMPORTANT: 後方互換性を維持IMPORTANT: セキュリティベストプラクティスに従う考慮してほしいこと。判断はAIに委ねる。この3段階を使い分けることで、AIの行動を適切にコントロールできる。高度な活用：並行開発とCI/CDカスタムスラッシュコマンドで定型作業を自動化公式例：GitHub Issue対応の自動化.claude/commands/fix-github-issue.md:Please analyze and fix the GitHub issue: $ARGUMENTS.Follow these steps:1. Use `gh issue view` to get the issue details2. Understand the problem described in the issue3. Search the codebase for relevant files4. Implement the necessary changes to fix the issue5. Write and run tests to verify the fix6. Ensure code passes linting and type checking7. Create a descriptive commit message8. Push and create a PRRemember to use the GitHub CLI (`gh`) for all GitHub-related tasks.使用方法：> /project:fix-github-issue 1234Git Worktreeで複数タスクを同時進行これは上級テクニック。でも覚えると手放せなくなる。git-scm.com例えば、機能開発しながらバグ修正もしたい時：# 機能開発用worktree$ git worktree add ../project-feature-auth feature/auth# バグ修正用worktree  $ git worktree add ../project-bugfix-api bugfix/api-error# 各worktreeで独立したClaude Codeセッション$ cd ../project-feature-auth && claude$ cd ../project-bugfix-api && claudeそれぞれのディレクトリで独立したClaude Codeセッションが動く。コンテキストが混ざらない。最高。というか人の業の深さを感じれてよい…。CI/CDへの統合Claude Codeはコマンドラインツールなので、CI/CDにも組み込める。docs.anthropic.comGitHub Actionsの例：- name: Claude Code Review  run: |    claude -p "このPRの変更をレビューして、以下の観点で問題を指摘：    - セキュリティ脆弱性    - パフォーマンス問題    - コーディング規約違反" \    --output-format json > review.json自動化できることは自動化する。人間はもっとクリエイティブなことに時間を使うべきだ。permissions.allowの推奨設定セッション中に「Always allow」を選択するか、/permissionsコマンドで追加できるがsetting.json でも追加できる。syu-m-5151.hatenablog.com公式が推奨する基本的な許可リスト：{  "permissions": {    "allow": [      "List(*)",      "Fetch(https://*)",      "Edit(*)",      "Bash(git:*)",      "Bash(npm:*)",      "Bash(ls:*)",      "Bash(cat:*)",      "Bash(mkdir:*)",      "Bash(mv:*)"    ]  }}まとめClaude Codeを1週間使い込んで確信した。CLAUDE.mdは単なる設定ファイルじゃない。AIとの共通言語だ。youtu.be3ヶ月前、私は理想を語った。「生成AIとの協業で『動作するきれいなコード』を実現する」と。正直、半分は願望だった。syu-m-5151.hatenablog.comでも今、それは現実になっている。私は「助手席」に座り、AIが「運転席」でコードを書く。最初は違和感があったが、今では心地いい。むしろ、なぜ今まで全部自分でやろうとしていたのか不思議にさえ思う。www.oreilly.com3ヶ月で変わったこと、変わらなかったこと変わったこと：理論が実践になった曖昧な指示でも伝わるようになったコードの品質が向上した開発速度が圧倒的に上がった変わらなかったこと：計画を立てるのは相変わらず苦手TDDへの抵抗感は残っている「とりあえず動かしてみる」精神は健在コードを書く楽しさは失われていない最後の点が重要だ。AIに仕事を奪われたのではない。つまらない部分を任せて、楽しい部分に集中できるようになった。効果的なCLAUDE.mdを書くコツ：明確なプロジェクト概要 - AIも人間も理解できるように具体的なワークフロー - 探索→計画→実装→コミット実用的なコマンド集 - よく使うものを網羅AIへの明示的な指示 - NEVER、YOU MUST、IMPORTANTを使い分けるこれらを押さえれば、AIは最高のパートナーになる。「予測可能性は賢さに勝る」 - この原則を胸に、CLAUDE.mdを育てていこう。3ヶ月後、私はまた記事を書いているだろう。タイトルは分からない。でも一つ確実なのは、私はまだ助手席に座っているということ。そして、それを楽しんでいるということだ。なぜなら、助手席こそが最も楽しい席だから。他社も同じぐらいのプランをいずれ出すのでCodex CLIやjulesが楽しみです。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ddc.vimによるシェルコマンドの補完が速くなったぞ]]></title>
            <link>https://blog.atusy.net/2025/06/06/ddc-source-shell_native-is-faster/</link>
            <guid>https://blog.atusy.net/2025/06/06/ddc-source-shell_native-is-faster/</guid>
            <pubDate>Fri, 06 Jun 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[ddc-source-shell_nativeを使うとシェルコマンドの補完ができます。従来は補完候補を取得するたびにシェルを起動するため時間がかかりましたが、シェルを常駐させることで高速化してもらいました。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Introducing cctx: A Context Switcher for Claude Code]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/05/232126</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/05/232126</guid>
            <pubDate>Thu, 05 Jun 2025 14:21:26 GMT</pubDate>
            <content:encoded><![CDATA[IntroductionAs developers, we often juggle multiple contexts throughout our day - switching between personal projects, client work, and perhaps some experimental code on the side. Each context might require different permissions, access levels, and configurations. If you're using Claude Code, Anthropic's CLI tool for interacting with Claude, you've probably felt the pain of manually managing different settings.json configurations. That's why I built cctx - a fast, intuitive context switcher for Claude Code, inspired by the excellent kubectx tool for Kubernetes.github.comThe Problem: Configuration Context SwitchingClaude Code uses a settings.json file to control permissions, access levels, and various configurations. This is great for security and customization, but becomes cumbersome when you need different settings for different scenarios:Work projects need restricted permissions for safetyPersonal projects might need full access to your file systemClient demos require ultra-restricted settings for screen sharingExperimental work needs different tool accessManually editing settings.json or maintaining multiple copies quickly becomes error-prone and tedious. I needed something better.docs.anthropic.comEnter cctx: Fast Context Switching for Claude Codecctx (Claude Context) brings the simplicity and speed of kubectx to Claude Code configuration management. Written in Rust for maximum performance, it allows you to switch between different Claude Code configurations with a single command:# Switch to work context (restricted permissions)cctx work# Switch to personal context (full permissions)cctx personal# Switch back to previous contextcctx -Design Philosophy: Predictable Defaults with Progressive DisclosureOne of the key lessons learned during development was the importance of predictable behavior. In version 0.1.1+, I completely redesigned the UX around a simple principle: predictable defaults with explicit overrides.What This Means in PracticeDefault behavior is always the same - cctx always manages user-level contexts (~/.claude/settings.json) unless explicitly told otherwiseNo surprising auto-detection - The tool won't suddenly switch to project-level contexts just because you're in a different directoryProgressive disclosure - When project or local contexts are available, helpful hints guide you to themExplicit when needed - Use --in-project or --local flags when you want to manage other context levelsThis approach eliminates cognitive overhead while maintaining full functionality for advanced users.Key Features That Make cctx Shine🚀 Lightning FastBuilt with Rust, cctx switches contexts in milliseconds. No Python startup overhead, no Node.js dependencies - just pure speed.🎨 Beautiful, Intuitive InterfaceColor-coded output with the current context highlighted in greenHelpful emoji indicators for different context levels (👤 User, 📁 Project, 💻 Local)Interactive fuzzy search with fzf integration or built-in finderClear, actionable error messages🛡️ Security-First DesignCreate separate contexts for different security requirements:# Create a restricted work contextcctx -n workcctx -e work  # Edit to add restrictions# Create a demo context for screen sharingcctx -n demo  # Ultra-restricted, read-only📁 Simple File-Based StorageContexts are just JSON files stored in ~/.claude/settings/. You can edit them manually, version control them, or sync them across machines.Real-World Usage PatternsHere's how I use cctx in my daily workflow:Morning Routine# Start the day with work contextcctx work# Check what context I'm incctx -c# Output: workProject Switching# Working on a personal projectcctx personal# Client calls - need to share screencctx demo# Back to personal projectcctx -Context Management# Create a new context for a specific clientcctx -n client-acme# Edit the context to set appropriate permissionscctx -e client-acme# List all contextscctx# Output:# 👤 User contexts:#   client-acme#   demo#   personal#   work (current)Technical Implementation HighlightsWhy Rust?Performance: Instant startup and executionSafety: Memory safety without garbage collectionSingle binary: Easy distribution and installationGreat ecosystem: Excellent CLI libraries like clap and dialoguerArchitecture DecisionsFile-based contexts: Each context is a separate JSON fileAtomic operations: Context switching is done by copying filesState tracking: Current and previous contexts tracked in a hidden state filePlatform compatibility: Works on Linux, macOS, and WindowsSettings Hierarchy Supportcctx respects Claude Code's settings hierarchy while keeping things simple:# Default: user-level contextscctx work# Explicit: project-level contextscctx --in-project staging# Explicit: local project contextscctx --local debugGetting StartedInstallation is straightforward:# From crates.io (recommended)cargo install cctx# Or grab a pre-built binary# Download from https://github.com/nwiizo/cctx/releasesCreate your first contexts:# Create a personal context from current settingscctx -n personal# Create a restricted work contextcctx -n workcctx -e work  # Edit to add restrictions# Start switching!cctx workcctx personalcctx -  # Switch backWhat's Next?The cctx project is actively maintained and follows Claude Code's development closely. Some ideas for the future include:Context templates for common scenariosShell integration for automatic context switchingContext inheritance for shared settingsIntegration with other AI coding toolsConclusioncctx brings the joy of quick context switching to Claude Code users. By focusing on speed, simplicity, and predictable behavior, it removes the friction from managing multiple configurations. Whether you're switching between work and personal projects, managing client-specific settings, or just want better control over your Claude Code permissions, cctx has you covered.The project is open source and available on GitHub. If you find it useful, please consider starring the repository and contributing your own ideas and improvements. Happy context switching!cctx is an independent open-source project and is not affiliated with Anthropic. For official Claude Code documentation and support, please visit docs.anthropic.com.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：imgcat]]></title>
            <link>https://zenn.dev/akasan/articles/a57b277ee7af27</link>
            <guid>https://zenn.dev/akasan/articles/a57b277ee7af27</guid>
            <pubDate>Thu, 05 Jun 2025 11:03:01 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第5回は、imgcatというコマンドを紹介します。imgcatを使うとターミナル上で画像を表示させることができます。なお、第4回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/25f1eca029854b imgcatとは？imgcatとは公式の説明によるとDisplay images and gifs in your terminal emulator.ということで画像やgifをターミナルに表示させることができます。特徴としてアニメーションGIFの利用が可能標準入力からメ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Claude Code の settings.json は設定した方がいい]]></title>
            <link>https://syu-m-5151.hatenablog.com/entry/2025/06/05/134147</link>
            <guid>https://syu-m-5151.hatenablog.com/entry/2025/06/05/134147</guid>
            <pubDate>Thu, 05 Jun 2025 04:41:47 GMT</pubDate>
            <content:encoded><![CDATA[はじめにClaude Code 使ってますか？ターミナルから Claude に直接コーディングタスクを投げられる便利なツールなんですが、デフォルト設定のまま使うのはちょっともったいない。というかいちいちいろんなことを聞いてきてめちゃくちゃダルい。syu-m-5151.hatenablog.comsettings.json をちゃんと設定すると、セキュリティも保ちつつ、もっと快適に使えるようになります。全体的に疲れている時の~/.claude/settings.json と~/.claude/CLAUDE.md · GitHub 私のデフォルトの設定も公開してますのでよかったら参考にしてください。ここで読むのをやめる人のために言っておくと Claude Codeの設定は優先順位があるので覚えておくと良い です。あと、比較的に今は黎明期なので非推奨や追加機能が多いのでその点も注意が必要かもです。正直なところ、Anthropic の公式ドキュメント（日本語）が最高に分かりやすいので、まずはそっちを読んでほしいんですが、このブログは公式ドキュメントに赤線を引いたようなもので、実際に使ってみて「これは設定しといた方がいいよ」っていうポイントをピックアップしてまとめました。docs.anthropic.comsettings.json って何？settings.json は Claude Code の動作を制御する設定ファイルです。公式ドキュメントによると、こんな設定ができます。{  "permissions": {    "allow": [      "Bash(npm run lint)",      "Bash(npm run test:*)",      "Read(~/.zshrc)"    ],    "deny": [      "Bash(curl:*)"    ]  },  "env": {    "CLAUDE_CODE_ENABLE_TELEMETRY": "1",    "OTEL_METRICS_EXPORTER": "otlp"  }}設定できる項目 キー  説明  例  apiKeyHelper  Anthropic APIキーを生成するカスタムスクリプト  /bin/generate_temp_api_key.sh  cleanupPeriodDays  チャット記録をローカルに保持する期間（デフォルト：30日）  20  env  すべてのセッションに適用される環境変数  {"FOO": "bar"}  includeCoAuthoredBy  gitコミットにco-authored-by Claudeを含めるか（デフォルト：true）  false  permissions  ツールのアクセス権限設定  後述 権限設定をちゃんとやろうClaude Code の一番重要な機能がこの権限設定。/permissions コマンドで現在の設定を確認できます。/permissionsはとても良いので覚えておいてほしいです。また、便利なCLIの使い方も覚えておいたほうが多分良いです。docs.anthropic.comBash コマンドの制御{  "permissions": {    "allow": [      "Bash(npm run build)",      // 特定のコマンドだけ許可      "Bash(npm run test:*)",     // プレフィックスで許可      "Bash(git:*)"               // git コマンドは全部OK    ],    "deny": [      "Bash(curl:*)"              // curl は使わせない    ]  }}Claude Code はシェル演算子（&&など）も認識してるので、Bash(safe-cmd:*)みたいなルールでもsafe-cmd && dangerous-cmdみたいなのは実行できません。賢い！ファイルアクセスの制御Read と Edit のルールは gitignore の仕様に従います：{  "permissions": {    "allow": [      "Edit(docs/**)",           // プロジェクトの docs ディレクトリ内を編集可能      "Read(~/.zshrc)",         // ホームディレクトリの .zshrc を読める      "Edit(//tmp/scratch.txt)" // 絶対パスは // で指定    ]  }}Web アクセスの制御{  "permissions": {    "allow": [      "WebFetch(domain:example.com)"  // 特定ドメインのみ許可    ]  }}環境変数の活用公式ドキュメントに載ってる環境変数をうまく使うと便利：{  "env": {    "ANTHROPIC_API_KEY": "your-key-here",    "CLAUDE_CODE_ENABLE_TELEMETRY": "0",    "DISABLE_COST_WARNINGS": "1",    "BASH_DEFAULT_TIMEOUT_MS": "300000",    "BASH_MAX_TIMEOUT_MS": "1200000"  }}主要な環境変数 変数名  用途  CLAUDE_CODE_ENABLE_TELEMETRY  テレメトリの有効/無効  DISABLE_COST_WARNINGS  コスト警告を無効化  BASH_DEFAULT_TIMEOUT_MS  Bashコマンドのデフォルトタイムアウト  DISABLE_AUTOUPDATER  自動更新を無効化 設定の優先順位を理解しよう公式ドキュメントによると、設定は以下の順番で適用されます（上が優先）：エンタープライズポリシーコマンドライン引数ローカルプロジェクト設定（.claude/settings.local.json）共有プロジェクト設定（.claude/settings.json）ユーザー設定（~/.claude/settings.json）プロジェクトごとに設定を変えたければ、プロジェクトフォルダに .claude/settings.json を置けばOK。Git で共有したくない設定は .claude/settings.local.json に書こう。実践的な設定例制限的な設定（仕事用）{  "permissions": {    "allow": [      "Bash(npm run lint)",      "Bash(npm run test:*)",      "Bash(git:*)",      "Read(./src/**)",      "Edit(./src/**)"    ],    "deny": [      "Bash(npm publish:*)",      "WebFetch(domain:*)"    ]  },  "includeCoAuthoredBy": false}もう少しゆるい設定（個人用）{  "permissions": {    "allow": [      "Bash(npm:*)",      "Bash(git:*)",      "Bash(cargo:*)",      "Read(**)",      "Edit(~/projects/**)",      "WebFetch(domain:*)"    ]  },  "cleanupPeriodDays": 60}MCP (Model Context Protocol) を使う場合MCP サーバーを使ってる人向けの権限設定：{  "permissions": {    "allow": [      "mcp__puppeteer",                        // puppeteer サーバーの全ツール      "mcp__puppeteer__puppeteer_navigate"     // 特定のツールだけ    ]  }}複数の設定を切り替えたいならちなみに、複数の~/.claude/settings.jsonを簡単に切り替えたい人向けに cctx っていうツールも作ってみました。cargo install cctxまとめClaude Code の settings.json は、ちゃんと設定すると作業効率とセキュリティが大幅に向上します。ちゃんとしましょう。特に重要なのは：権限設定で必要最小限のアクセスだけ許可するプロジェクトごとに適切な設定を使い分ける環境変数でタイムアウトやテレメトリを調整する詳しい設定方法は Anthropic の公式ドキュメント（日本語）がマジで分かりやすいので、ぜひ読んでみてください。Anthropic の公式ドキュメント最高！Claude Code の 公式ドキュメントやベストプラクティス はとりあえず読んだ方がいい。www.anthropic.com参考リンクClaude Code 公式ドキュメント（日本語） - これ読めば全部分かるcctx - Claude Context Manager - 設定切り替えツールClaude Code 設定例（Gist） - 実際の設定例]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンドラインでバブルソートを可視化してみた]]></title>
            <link>https://zenn.dev/akasan/articles/0331574e200f01</link>
            <guid>https://zenn.dev/akasan/articles/0331574e200f01</guid>
            <pubDate>Wed, 04 Jun 2025 13:30:16 GMT</pubDate>
            <content:encoded><![CDATA[今回はPythonを使ってバブルソートをコマンドラインで可視化しながらソートするコードを作ってみました。 バブルソートとはバブルソートとはリスト内のアイテムをソートするためのアルゴリズムの一つで最もシンプルなものとなります。計算ロジックは以下になります。インデックスi=0、上限インデックスupper_iを`リストの要素数-1``で初期化するiとi+1の要素の大小を比較し、iの値の方が大きかった場合iとi+1の値を入れ替えるiの値を1つ増やし2を実行するiの値がupper_iと一致したらi=0に設定してupper_idを1減らすupper_idが0になるまで繰り返すと...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：rg]]></title>
            <link>https://zenn.dev/akasan/articles/25f1eca029854b</link>
            <guid>https://zenn.dev/akasan/articles/25f1eca029854b</guid>
            <pubDate>Tue, 03 Jun 2025 14:30:40 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第4回は、rgというコマンドを紹介します。rgを使うとリカーシブに正規表現を使って文字列検索を行ったりすることができます。なお、第3回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/5c92827ae75f3c※ 今回は正規表現を使った検索については省略します。基本的に他のツールと利用方法は変わりません！ rgとは？rgとは公式の説明によるとripgrep is a line-oriented search tool that recursively searches the cu...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Conform.nvimの保存時フォーマットをスキップする方法]]></title>
            <link>https://blog.atusy.net/2025/06/03/skip-conform-nvim-format-on-save/</link>
            <guid>https://blog.atusy.net/2025/06/03/skip-conform-nvim-format-on-save/</guid>
            <pubDate>Tue, 03 Jun 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Conform.nvimのformat_on_saveは便利ですが、たまーにスキップしたくなります。:w!の実行やバッファの内容に応じて制御してみましょう。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vim/Neovimのマークを操作内容に合わせて設定する]]></title>
            <link>https://blog.atusy.net/2025/06/03/vim-contextful-mark/</link>
            <guid>https://blog.atusy.net/2025/06/03/vim-contextful-mark/</guid>
            <pubDate>Tue, 03 Jun 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[たとえば`yしたら直前にヤンクした場所に戻れるとよさそうですね。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[コマンド紹介シリーズ：bat]]></title>
            <link>https://zenn.dev/akasan/articles/5c92827ae75f3c</link>
            <guid>https://zenn.dev/akasan/articles/5c92827ae75f3c</guid>
            <pubDate>Mon, 02 Jun 2025 11:37:04 GMT</pubDate>
            <content:encoded><![CDATA[コマンド紹介シリーズ第3回は、batというコマンドを紹介します。batを使うとシンタックスハイライトを用いた画面表示やgitとの連携などを行うことができます。なお、第2回は以下になりますので、ぜひご興味があればご覧ください。https://zenn.dev/akasan/articles/dd94771d828ec7 batとは？batは公式の説明によると、シンタックスハイライトとGitとの連携機能付きの cat(1) クローン。ということです。catはファイル内容を表示したり新しいファイルを作ったりできるコマンドですが、それを拡張したものであると言えます。catではシ...]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[スリーシェイク所属のエンジニアが「AWS Community Builders」に選出]]></title>
            <link>https://sreake.com/blog/aws-community-builders-2025/</link>
            <guid>https://sreake.com/blog/aws-community-builders-2025/</guid>
            <pubDate>Mon, 02 Jun 2025 01:00:00 GMT</pubDate>
            <content:encoded><![CDATA[株式会社スリーシェイク（本社：東京都新宿区、代表取締役社長：吉田 拓真、以下スリーシェイク）に所属の鈴木 勝史が、「AWS Community Builders」に2年連続で選出されたことをお知らせします。The post スリーシェイク所属のエンジニアが「AWS Community Builders」に選出 first appeared on sreake.com | 株式会社スリーシェイク.]]></content:encoded>
        </item>
    </channel>
</rss>